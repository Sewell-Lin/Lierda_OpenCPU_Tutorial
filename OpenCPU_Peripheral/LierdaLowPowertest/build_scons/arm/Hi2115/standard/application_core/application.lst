
build_scons\arm\Hi2115\standard\application_core\application.elf:     file format elf32-littlearm
build_scons\arm\Hi2115\standard\application_core\application.elf
architecture: arm, flags 0x00000112:
EXEC_P, HAS_SYMS, D_PAGED
start address 0x00001a35

Program Header:
0x70000001 off    0x00036168 vaddr 0x00026168 paddr 0x00026168 align 2**2
         filesz 0x000000c8 memsz 0x000000c8 flags r--
    LOAD off    0x00010000 vaddr 0x00000000 paddr 0x00000000 align 2**16
         filesz 0x000000a0 memsz 0x000000a0 flags r--
    LOAD off    0x000100c0 vaddr 0x000000c0 paddr 0x000000c0 align 2**16
         filesz 0x00000054 memsz 0x00000054 flags r--
    LOAD off    0x00010120 vaddr 0x00000120 paddr 0x00000120 align 2**16
         filesz 0x00026140 memsz 0x00026140 flags r-x
    LOAD off    0x00040400 vaddr 0x01000400 paddr 0x00026260 align 2**16
         filesz 0x00000218 memsz 0x00000218 flags rwx
    LOAD off    0x00040680 vaddr 0x01000680 paddr 0x00026478 align 2**16
         filesz 0x00000000 memsz 0x000028ac flags rw-
    LOAD off    0x00042f30 vaddr 0x01002f30 paddr 0x00026478 align 2**16
         filesz 0x00000000 memsz 0x00000070 flags rw-
    LOAD off    0x00050000 vaddr 0x01000000 paddr 0x01000000 align 2**16
         filesz 0x00000000 memsz 0x00000400 flags rw-
    LOAD off    0x0004fee0 vaddr 0x0100fee0 paddr 0x0100fee0 align 2**16
         filesz 0x00000000 memsz 0x00000020 flags rw-
    LOAD off    0x0004ff00 vaddr 0x0100ff00 paddr 0x0100ff00 align 2**16
         filesz 0x00000000 memsz 0x000000a0 flags rw-
    LOAD off    0x00041000 vaddr 0x40001000 paddr 0x40001000 align 2**16
         filesz 0x00000000 memsz 0x00000a00 flags rw-
private flags = 5000200: [Version5 EABI] [soft-float ABI]

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 startup       000000a0  00000000  00000000  00010000  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  1 .version_str  00000054  000000c0  000000c0  000100c0  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  2 .text         00026040  00000120  00000120  00010120  2**4
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  3 .init         00000004  00026160  00026160  00036160  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  4 .fini         00000004  00026164  00026164  00036164  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  5 .ARM.exidx    000000c8  00026168  00026168  00036168  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  6 .ARM.extab    00000030  00026230  00026230  00036230  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  7 .stacks       00000400  01000000  01000000  00050000  2**2
                  ALLOC
  8 .ramtext      000000d0  01000400  00026260  00040400  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  9 .data         00000148  010004d0  00026330  000404d0  2**2
                  CONTENTS, ALLOC, LOAD, DATA
 10 .bss          000028ac  01000680  00026478  00040680  2**7
                  ALLOC
 11 .preserve     00000070  01002f30  00026478  00042f30  2**3
                  ALLOC
 12 .heap         00000000  01002fa0  01002fa0  00040618  2**0
                  CONTENTS
 13 .sys_status   00000020  0100fee0  0100fee0  0004fee0  2**3
                  ALLOC
 14 .ipc_mailbox  000000a0  0100ff00  0100ff00  0004ff00  2**2
                  ALLOC
 15 .peripherals  00000a00  40001000  40001000  00041000  2**2
                  ALLOC
 16 .ARM.attributes 00000028  00000000  00000000  00040618  2**0
                  CONTENTS, READONLY
 17 .comment      0000007e  00000000  00000000  00040640  2**0
                  CONTENTS, READONLY
 18 .debug_info   00089b12  00000000  00000000  000406be  2**0
                  CONTENTS, READONLY, DEBUGGING
 19 .debug_abbrev 000136d3  00000000  00000000  000ca1d0  2**0
                  CONTENTS, READONLY, DEBUGGING
 20 .debug_loc    0003e43e  00000000  00000000  000dd8a3  2**0
                  CONTENTS, READONLY, DEBUGGING
 21 .debug_aranges 00004e18  00000000  00000000  0011bce8  2**3
                  CONTENTS, READONLY, DEBUGGING
 22 .debug_ranges 000064b0  00000000  00000000  00120b00  2**0
                  CONTENTS, READONLY, DEBUGGING
 23 .debug_line   00022de7  00000000  00000000  00126fb0  2**0
                  CONTENTS, READONLY, DEBUGGING
 24 .debug_str    00022335  00000000  00000000  00149d97  2**0
                  CONTENTS, READONLY, DEBUGGING
 25 .debug_frame  0000e380  00000000  00000000  0016c0cc  2**2
                  CONTENTS, READONLY, DEBUGGING
SYMBOL TABLE:
00000000 l    d  startup	00000000 startup
000000c0 l    d  .version_str	00000000 .version_str
00000120 l    d  .text	00000000 .text
00026160 l    d  .init	00000000 .init
00026164 l    d  .fini	00000000 .fini
00026168 l    d  .ARM.exidx	00000000 .ARM.exidx
00026230 l    d  .ARM.extab	00000000 .ARM.extab
01000000 l    d  .stacks	00000000 .stacks
01000400 l    d  .ramtext	00000000 .ramtext
010004d0 l    d  .data	00000000 .data
01000680 l    d  .bss	00000000 .bss
01002f30 l    d  .preserve	00000000 .preserve
01002fa0 l    d  .heap	00000000 .heap
0100fee0 l    d  .sys_status	00000000 .sys_status
0100ff00 l    d  .ipc_mailbox	00000000 .ipc_mailbox
40001000 l    d  .peripherals	00000000 .peripherals
00000000 l    d  .ARM.attributes	00000000 .ARM.attributes
00000000 l    d  .comment	00000000 .comment
00000000 l    d  .debug_info	00000000 .debug_info
00000000 l    d  .debug_abbrev	00000000 .debug_abbrev
00000000 l    d  .debug_loc	00000000 .debug_loc
00000000 l    d  .debug_aranges	00000000 .debug_aranges
00000000 l    d  .debug_ranges	00000000 .debug_ranges
00000000 l    d  .debug_line	00000000 .debug_line
00000000 l    d  .debug_str	00000000 .debug_str
00000000 l    d  .debug_frame	00000000 .debug_frame
00000000 l    df *ABS*	00000000 vectors.c
00001b0c l     F .text	00000002 isr_not_implemented
00000000 l    df *ABS*	00000000 build_version.c
000000c0 l     O .version_str	00000054 build_version_information
00000000 l    df *ABS*	00000000 build_scons\arm\Hi2115\standard\application_core\os\LiteOS\platform/cpu/los_dispatch.o
e000ed04 l       *ABS*	00000000 OS_NVIC_INT_CTRL
e000ed20 l       *ABS*	00000000 OS_NVIC_SYSPRI2
00f00000 l       *ABS*	00000000 OS_NVIC_PENDSV_PRI
10000000 l       *ABS*	00000000 OS_NVIC_PENDSVSET
00000010 l       *ABS*	00000000 OS_TASK_STATUS_RUNNING
00000182 l       .text	00000000 TaskSwitch
00000000 l    df *ABS*	00000000 build_scons\arm\Hi2115\standard\application_core\lib\nlibc\string/arm/memcpy.o
00000218 l       .text	00000000 .neul_memcpy_debug_assert_memcpy_start
00000200 l       .text	00000000 .neul_memcpy_debug_assert_dest_lt_src
000001f6 l       .text	00000000 .neul_memcpy_debug_assert_dest_gt_src
0000020a l       .text	00000000 .neul_memcpy_debug_assert
0000026c l       .text	00000000 .neul_memcpy_small_start
0000021c l       .text	00000000 .neul_memcpy_start
0000021e l       .text	00000000 .neul_memcpy_realign
0000027a l       .text	00000000 .neul_memcpy_dst_ul
0000029c l       .text	00000000 .neul_memcpy_src_ul
0000022c l       .text	00000000 .neul_memcpy_20_check
0000023c l       .text	00000000 .neul_memcpy_12_check
00000230 l       .text	00000000 .neul_memcpy_20
00000268 l       .text	00000000 .neul_memcpy_end
00000248 l       .text	00000000 .neul_memcpy_4_check
00000260 l       .text	00000000 .neul_memcpy_1_start
00000250 l       .text	00000000 .neul_memcpy_4
00000278 l       .text	00000000 .neul_memcpy_small_end
00000270 l       .text	00000000 .neul_memcpy_small
00000288 l       .text	00000000 .neul_memcpy_small_unaligned
000002c8 l       .text	00000000 .neul_memcpy_small_unaligned2
000002b0 l       .text	00000000 .neul_memcpy_unaligned_dest_loop
000002d0 l       .text	00000000 .neul_memcpy_unaligned_dest_end
00000000 l    df *ABS*	00000000 build_scons\arm\Hi2115\standard\application_core\lib\nlibc\string/arm/memset.o
00000370 l       .text	00000000 .neul_memset_small_start
0000037c l       .text	00000000 .neul_memset_dst_ul
00000344 l       .text	00000000 .neul_memset_mid_start
000002fc l       .text	00000000 .neul_memset_realigned_large
00000310 l       .text	00000000 .neul_memset_24
00000340 l       .text	00000000 .neul_memset_end
0000031a l       .text	00000000 .neul_memset_12_check
00000324 l       .text	00000000 .neul_memset_4_check
0000033a l       .text	00000000 .neul_memset_1
00000330 l       .text	00000000 .neul_memset_4
00000350 l       .text	00000000 .neul_memset_mid_4
00000360 l       .text	00000000 .neul_memset_mid_end
0000035a l       .text	00000000 .neul_memset_mid_1
0000037a l       .text	00000000 .neul_memset_small_end
00000374 l       .text	00000000 .neul_memset_small
0000038c l       .text	00000000 .neul_memset_align_loop
00000398 l       .text	00000000 .neul_memset_dst_ul_selection
0000039e l       .text	00000000 .neul_memset_dst_ul_selection_small
00000000 l    df *ABS*	00000000 _thumb1_case_uqi.o
00000000 l    df *ABS*	00000000 _udivsi3.o
000003b8 l       .text	00000000 .udivsi3_skip_div0_test
00000000 l    df *ABS*	00000000 _divsi3.o
000004cc l       .text	00000000 .divsi3_skip_div0_test
00000000 l    df *ABS*	00000000 _dvmd_tls.o
00000000 l    df *ABS*	00000000 _aeabi_uldivmod.o
00000000 l    df *ABS*	00000000 libgcc2.c
00000000 l    df *ABS*	00000000 libgcc2.c
00000000 l    df *ABS*	00000000 unwind-arm.c
000008bc l     F .text	00000016 selfrel_offset31
000008d4 l     F .text	00000074 search_EIT_table
00000948 l     F .text	00000028 __gnu_unwind_get_pr_addr
00000970 l     F .text	0000009c get_eit_entry
00000a0c l     F .text	00000054 restore_non_core_regs
00000a60 l     F .text	0000000c _Unwind_decode_typeinfo_ptr.isra.0
00000a6c l     F .text	00000004 __gnu_unwind_24bit.isra.1
00000a70 l     F .text	00000002 _Unwind_DebugHook
00000a74 l     F .text	0000003c unwind_phase2
00000ab0 l     F .text	000000c8 unwind_phase2_forced
00000c8c l     F .text	00000018 _Unwind_GetGR
00000cd4 l     F .text	00000018 _Unwind_SetGR
00000d5c l     F .text	000002e0 __gnu_unwind_pr_common
00000000 l    df *ABS*	00000000 libunwind.o
00000000 l    df *ABS*	00000000 pr-support.c
00001408 l     F .text	00000032 next_unwind_byte
0000143c l     F .text	00000018 _Unwind_GetGR.constprop.0
00001454 l     F .text	00000008 unwind_UCB_from_context
00000000 l    df *ABS*	00000000 _clzsi2.o
00000000 l    df *ABS*	00000000 _clzdi2.o
00000000 l    df *ABS*	00000000 _thumb1_case_sqi.o
00000000 l    df *ABS*	00000000 _thumb1_case_shi.o
00000000 l    df *ABS*	00000000 _thumb1_case_uhi.o
00000000 l    df *ABS*	00000000 app_os_init.c
00001834 l     F .text	0000001c app_send_to_incoming_queue_from_isr
00001850 l     F .text	0000011c app_main
01000680 l     O .bss	00000004 app_incoming_queue
00000000 l    df *ABS*	00000000 main.c
00000000 l    df *ABS*	00000000 build_scons\arm\Hi2115\standard\application_core\app\standard\application_core\startup.o
00000400 l       *ABS*	00000000 STACK_SIZE_SYSTEM
01000000 l       .stacks	00000000 stack_system_end
00001a4c l       .text	00000000 .version_table_invalid
00001a4e l       .text	00000000 .version_table_valid
00001a5a l       .text	00000000 .stack_fill
00001a68 l       .text	00000000 .stack_fill_loop_end
00001a60 l       .text	00000000 .stack_fill_loop
00001a7a l       .text	00000000 .end_clear_bss_loop
00001a72 l       .text	00000000 .clear_bss_loop
00001a90 l       .text	00000000 .end_set_ramtext_loop
00001a84 l       .text	00000000 .set_ramtext_loop
00001aa6 l       .text	00000000 .end_set_data_loop
00001a9a l       .text	00000000 .set_data_loop
00001ab0 l       .text	00000000 .hwinitdone
00001aba l       .text	00000000 .swinitdone
00001ac8 l       .text	00000000 .enter_main
00000000 l    df *ABS*	00000000 panic.c
01000684 l     O .bss	00000001 already_panicking
00000000 l    df *ABS*	00000000 cmsis_rpc.c
00001b68 l     F .text	0000000a cmsis_rpc_task_yield
00001b74 l     F .text	0000001c cmsis_rpc_sent_take_semaphore
00001b90 l     F .text	0000001c cmsis_rpc_take_semaphore
00001bac l     F .text	00000018 cmsis_rpc_sent_give_semaphore
00001bc4 l     F .text	00000018 cmsis_rpc_give_semaphore
00001bdc l     F .text	00000018 send_to_incoming_queue_from_isr
00001bf4 l     F .text	00000018 wait_on_incoming_queue
00001c0c l     F .text	00000044 wait_on_outgoing_queue
00001c50 l     F .text	0000002c send_to_outgoing_queue_from_isr
0100068c l     O .bss	00000004 rpc_incoming_queue
01000690 l     O .bss	0000000c rpc_outgoing_queue
0100069c l     O .bss	0000000c rpc_semaphores
010006a8 l     O .bss	00000004 rpc_sent_semaphore
00000000 l    df *ABS*	00000000 rpc_interface.c
00001d58 l     F .text	00000032 rpc_interface_get_max_command_id
00001d8a l     F .text	00000014 rpc_get_core_id
00001db4 l     F .text	000004a0 rpc_interface_ipc_callback
010006d6 l     O .bss	00000d98 received_data
010006ac l     O .bss	00000020 irq_callback
010006cc l     O .bss	00000008 receive_info
010006d4 l     O .bss	00000002 receive_state
0100146e l     O .bss	00000018 received_response
01001486 l     O .bss	00000002 rpc_interface_state
00000000 l    df *ABS*	00000000 rpc_auto_generated_application.c
00002408 l     F .text	0000002c rpc_blocking_loop
00002434 l     F .text	00000028 rpc_command_release
0000245c l     F .text	00000048 rpc_command_claim
000024a4 l     F .text	00000032 internal_incomming_command_get_apps_rpc_version
000024d6 l     F .text	00000052 internal_incomming_command_get_plmn_results_ind
00002528 l     F .text	0000000c void_default_weak_handler_CORES_uint8
00002534 l     F .text	0000002c internal_incomming_command_attach_status_set_result_ind
00002560 l     F .text	0000002c internal_incomming_command_plmn_select_result_ind
0000258c l     F .text	0000002c internal_incomming_command_registration_status_ind
000025b8 l     F .text	0000002c internal_incomming_command_connection_status_ind
000025e4 l     F .text	0000002c internal_incomming_command_ip_address_changed
00002610 l     F .text	0000002c internal_incomming_command_cfun_result_ind
0000263c l     F .text	0000002c internal_incomming_command_update_package_parse_cnf
00002668 l     F .text	0000002c internal_incomming_command_update_package_process_cnf
00002694 l     F .text	0000002c internal_incomming_command_update_package_flash_write_done
000026c0 l     F .text	0000002c internal_incomming_command_psm_status_ind
000026ec l     F .text	0000002c internal_incomming_command_radio_command_abort_ind
00002718 l     F .text	0000002c internal_incomming_command_flowcontrol_status
00002744 l     F .text	0000002c internal_incomming_command_pdp_modify_result
00002770 l     F .text	0000002c internal_incomming_command_driver_adc_action_response
0000279c l     F .text	0000002c internal_incomming_command_app_flash_erase_response
000027c8 l     F .text	0000002c internal_incomming_command_app_flash_write_response
000027f4 l     F .text	0000002c internal_incomming_command_pin_status_ind
00002820 l     F .text	00000048 internal_incomming_command_socket_data_sent
00002868 l     F .text	00000048 internal_incomming_command_non_ip_data_sent
000028b0 l     F .text	00000072 internal_incomming_command_recvfrom
00002922 l     F .text	00000082 internal_incomming_command_socket_recv
000029a4 l     F .text	00000052 internal_incomming_command_socket_notify
000029f6 l     F .text	0000006e internal_incomming_command_ping_ind
00002a64 l     F .text	00000060 internal_incomming_command_sms_mgs_result_ind
00002ac4 l     F .text	00000060 internal_incomming_command_sms_cmd_result_ind
00002b24 l     F .text	00000064 internal_incomming_command_current_time_ind
00002b88 l     F .text	0000002c internal_incomming_command_rf_calibration_rtc_ind
00002bb4 l     F .text	00000046 internal_incomming_command_update_package_get_package_version_cnf
00002bfa l     F .text	00000046 internal_incomming_command_update_package_get_package_name_cnf
00002c40 l     F .text	0000000c void_default_weak_handler_CORES_uint32_uint16
00002c4c l     F .text	00000042 internal_incomming_command_update_package_data_req
00002c8e l     F .text	00000030 internal_incomming_command_update_package_flash_erase_done
00002cbe l     F .text	0000001a internal_incomming_command_service_recovery
00002cd8 l     F .text	0000001a internal_incomming_command_cring_ind
00002cf2 l     F .text	00000052 internal_incomming_command_pdp_act_or_deact_result_ind
00002d44 l     F .text	00000070 internal_incomming_command_edrx_changed_ind
00002db4 l     F .text	00000054 internal_incomming_command_radiotest_response
00002e08 l     F .text	00000054 internal_incomming_command_sms_cmt_pdu_ind
00002e5c l     F .text	00000054 internal_incomming_command_rxcalist_response
00002eb0 l     F .text	00000064 internal_incomming_command_nonip_recvfrom
00002f14 l     F .text	00000044 internal_incomming_command_pin_result_ind
00002f58 l     F .text	0000004e internal_incomming_command_kv_apps_cache_flushed
00002fa6 l     F .text	00000062 internal_incomming_command_ip_info
00003008 l     F .text	0000004c internal_incomming_command_ciot_opt_status_ind
00003054 l     F .text	00000042 internal_incomming_command_driver_adc_read_response
00003096 l     F .text	00000044 internal_incomming_command_t3324_t3412_ext_value_changed_ind
00000000 l    df *ABS*	00000000 rpc_helpers.c
00000000 l    df *ABS*	00000000 log.c
01001488 l     O .bss	00000001 log_is_full_log_enabled
0100148c l     O .bss	00000004 missed_messages
01001490 l     O .bss	00000004 mutex
01001494 l     O .bss	00000064 s.5771
01000590 l     O .data	00000001 log_current_verbosity
01000591 l     O .data	00000001 log_is_enabled_state
00000000 l    df *ABS*	00000000 log_trigger.c
00000000 l    df *ABS*	00000000 flog.c
00000000 l    df *ABS*	00000000 log_uart.c
000068c8 l     F .text	00000010 log_uart_retrigger_from_timer
000068d8 l     F .text	00000010 log_uart_dma_tx_isr_callback
000068e8 l     F .text	00000078 log_uart_write_blocking
00006b00 l     F .text	00000016 log_reader_info_action_handler
01001500 l     O .bss	00000080 packed_short_log
01001580 l     O .bss	00000004 semaphore_log_output
01001584 l     O .bss	00000004 semaphore_log_reader_enable
01001588 l     O .bss	00000004 semaphore_logs
0100158c l     O .bss	00000004 semaphore_uart
01001590 l     O .bss	00000004 sequence_number
01000592 l     O .data	00000001 log_uart
00000000 l    df *ABS*	00000000 ota.c
00006f4c l     F .text	00000018 update_package_parse_cnf
00006f64 l     F .text	00000018 update_package_process_cnf
00006f7c l     F .text	00000044 update_package_get_package_info_cnf
00006fc0 l     F .text	00000008 update_package_get_package_name_cnf
00006fc8 l     F .text	00000008 update_package_get_package_version_cnf
01001594 l     O .bss	00000004 get_package_info_buff_callback
01001598 l     O .bss	00000004 get_package_info_cnf_callback
0100159c l     O .bss	00000004 package_parse_finish_callback
010015a0 l     O .bss	00000004 package_validate_finish_callback
00000000 l    df *ABS*	00000000 ota_iflash.c
00007078 l     F .text	00000020 update_package_flash_write_done
00007098 l     F .text	00000024 update_package_flash_erase_done
010015b0 l     O .bss	00000200 ota_package_buff
010015a4 l     O .bss	00000004 flash_erase_callback
010015a8 l     O .bss	00000001 flash_erased_ok
010015ac l     O .bss	00000004 flash_write_callback
00000000 l    df *ABS*	00000000 neul_kv_storage.c
000071ec l     F .text	00000014 neul_kv_find_key_location_in_cache
00007200 l     F .text	00000026 kv_empty_cache
00007228 l     F .text	000000d4 set_cache_operation_in_progress
000072fc l     F .text	000000b8 add_kv_cache_key_by_type
000073b4 l     F .text	00000058 read_kv_cache_key
0000740c l     F .text	0000002c set_cache_operation_clean
00007438 l     F .text	0000001e neul_kv_queue_cache_for_write
00007458 l     F .text	000000e8 neul_kv_find_key_for_writing
010017b0 l     O .bss	00000010 kv_cache_base
010017c0 l     O .bss	00000004 kv_cache_mutex
010017c4 l     O .bss	00000010 kv_cache_root_a
010017d4 l     O .bss	00000010 kv_cache_root_b
010017e4 l     O .bss	00000004 kv_cache_root_primary
010017e8 l     O .bss	00000004 kv_cache_root_secondary
00000000 l    df *ABS*	00000000 aio_manager.c
010017ec l     O .bss	00000004 aio_manager_mutex
00000000 l    df *ABS*	00000000 neul_io_bank.c
00007700 l     F .text	0000005c io_bank_init_helper
010017f0 l     O .bss	00000001 bank_l1_voltage
010017f1 l     O .bss	00000001 bank_r2_voltage
010017f4 l     O .bss	00000004 io_bank_mutex
00000000 l    df *ABS*	00000000 update.c
010017f8 l     O .bss	00000004 flash_erase_done_callback
010017fc l     O .bss	00000004 flash_write_done_callback
01001800 l     O .bss	00000004 get_package_name_cnf_callback
01001804 l     O .bss	00000004 get_package_version_cnf_callback
01001808 l     O .bss	00000004 package_parse_cnf_callback
0100180c l     O .bss	00000004 package_process_cnf_callback
00000000 l    df *ABS*	00000000 log_behaviour_config.c
00000000 l    df *ABS*	00000000 network_management.c
00000000 l    df *ABS*	00000000 socket.c
00007964 l     F .text	0000001c report_tcp_seq_send_result
00007980 l     F .text	0000001c socket_status_update.part.0
0000799c l     F .text	00000024 tcp_ul_indicator_acquire
000079c0 l     F .text	00000020 tcp_ul_indicator_release
000079e0 l     F .text	0000008c close_local_socket
01001810 l     O .bss	00000004 data_buffered
01001814 l     O .bss	00000001 flowcontrol_enabled
01001818 l     O .bss	00000004 message_buffered
0100181c l     O .bss	00000004 message_dropped
01001820 l     O .bss	0000001c socket_list
0100183c l     O .bss	0000001c tcp_ul_indicator_list
01001858 l     O .bss	00000004 tcp_ul_indicator_mutex
00000000 l    df *ABS*	00000000 iflog.c
0100185c l     O .bss	00000108 iflog_cache
01000593 l     O .data	00000001 iflog_enable_write
00000000 l    df *ABS*	00000000 aio_functions.c
00000000 l    df *ABS*	00000000 app_at_main.c
000082b4 l     F .text	000000c0 at_perform_one_atcommand
00008374 l     F .text	0000001c at_free_cmd_memory
00008390 l     F .text	00000090 app_at_send_next_command
00008420 l     F .text	0000003c at_radio_cmd_abort_callback
0000845c l     F .text	00000048 at_sim_pin_ind_callback
01001964 l     O .bss	00000001 at_initialized
01001968 l     O .bss	00000004 at_processing_cmd_cb
01001970 l     O .bss	00000008 blocking_begin_time
01001978 l     O .bss	00000001 g_at_cmd_in_progress
0100197c l     O .bss	00000008 g_at_cmd_info
01001984 l     O .bss	00000001 g_at_processing_cmd_abortable
01001985 l     O .bss	00000001 g_blocking_at_command_protected
00000000 l    df *ABS*	00000000 app_at_private.c
00008be0 l     F .text	0000001c app_at_clean_ip_mtu
00008bfc l     F .text	00000050 at_common_non_ip_data_report_callback
00008c4c l     F .text	00000010 at_crtdcp_callback
00008c5c l     F .text	00000010 at_nrnpdm_callback
00008c6c l     F .text	0000003c sms_send_cmd_result_callback
00008ca8 l     F .text	0000003c sms_send_msg_result_callback
01001986 l     O .bss	00000002 app_at_active_cid_ip_min_mtu
01001988 l     O .bss	00000016 app_at_ip_mtu_info
0100199e l     O .bss	00000002 app_at_non_ip_mtu_info
010019a0 l     O .bss	00000001 crtdcp_mode
010019a3 l     O .bss	00000001 non_ip_data_report_mode
00000000 l    df *ABS*	00000000 app_at_response.c
00022fec l     O .text	000000a0 g_cmee_errno_table
00022ebc l     O .text	00000130 g_ceer_emm_cause_str
010019a5 l     O .bss	00000001 g_cmee_error_type
0002308c l     O .text	00000010 g_cms_errno_table
00000000 l    df *ABS*	00000000 app_at_send_data.c
00009548 l     F .text	00000080 app_at_send_at_rsp
00000000 l    df *ABS*	00000000 app_at_uart_driver.c
000096c0 l     F .text	00000014 at_uart_trigger_received_at_notify_callback
000096d4 l     F .text	00000018 at_uart_kick_recv_process
000096ec l     F .text	00000008 at_uart_main_normal_uart_callback
000096f4 l     F .text	00000008 at_uart_main_lp_uart_callback
000096fc l     F .text	00000020 at_uart_main_tx_uart_write_callback
0000971c l     F .text	00000024 at_uart_flush_data
00009740 l     F .text	00000042 at_uart_enable_software_flow_control.isra.2
00009784 l     F .text	00000034 at_uart_frame_error_lp_uart_callback
000097d8 l     F .text	00000124 at_uart_configure.constprop.6
000098fc l     F .text	00000044 at_uart_reinit
010019d1 l     O .bss	00000acb at_uart_receive_uart_buffer
00009f48 l     F .text	00000028 at_uart_change_config
00009ff0 l     F .text	00000058 at_uart_change_config_timeout_callback
010019a6 l     O .bss	00000001 at_uart_buffer_err_flag
010019a7 l     O .bss	00000001 at_uart_buffer_frame_err_flag
010019a8 l     O .bss	00000001 at_uart_buffer_parity_err_flag
010019a9 l     O .bss	00000001 at_uart_config_status
010019aa l     O .bss	00000001 at_uart_config_store
010019ac l     O .bss	00000004 at_uart_config_timeout
010019b0 l     O .bss	00000001 at_uart_handler
010019b1 l     O .bss	00000001 at_uart_high_speed_enable
010019b4 l     O .bss	00000008 at_uart_last_config
010019bc l     O .bss	00000004 at_uart_mutex
010019c0 l     O .bss	00000008 at_uart_new_config
010019c8 l     O .bss	00000004 at_uart_pin_config
010019cc l     O .bss	00000004 at_uart_quick_search_index
010019d0 l     O .bss	00000001 at_uart_receive_status
0100249c l     O .bss	00000004 at_uart_received_at_notify_callback
010024a0 l     O .bss	00000002 at_uart_received_size
010024a2 l     O .bss	00000001 at_uart_recv_at_cmd_header_flag
010024a4 l     O .bss	00000004 at_uart_recv_queue
010024a8 l     O .bss	00000001 at_uart_stop_sleep_vote_flag
010024ac l     O .bss	00000004 at_uart_sys_timer_handle
010024b0 l     O .bss	00000004 at_uart_tx_data
00000000 l    df *ABS*	00000000 app_at_utils.c
0000a0e8 l     F .text	0000002a at_parse_char_to_hex
010024b4 l     O .bss	00000004 app_at_param_table
0002346f l     O .text	0000002c CSWTCH.152
0002349b l     O .text	00000028 CSWTCH.154
00000000 l    df *ABS*	00000000 app_at_async_notify.c
0000ac20 l     F .text	00000024 app_at_asnyc_take_semaphore
0000ac44 l     F .text	00000020 app_at_asnyc_give_semaphore
010024b8 l     O .bss	00000004 app_at_asyc_semaphore
010024bc l     O .bss	00000004 async_list
00000000 l    df *ABS*	00000000 app_at_cmd_parse.c
0000ad90 l     F .text	00000004 at_handle_NDIEID_cmd_test
0000ad94 l     F .text	00000038 at_set_ciot_opt_callback
0000adcc l     F .text	00000088 npin_result_callback
0000ae54 l     F .text	00000040 pdp_context_activate_or_deactivate_callback
0000ae94 l     F .text	0000005c at_socket_sent_callback
0000aef0 l     F .text	0000003c socket_callback
0000af2c l     F .text	00000070 connection_status_callback
0000af9c l     F .text	00000010 at_handle_NCIDSTATUS_cmd_test
0000afac l     F .text	00000010 at_handle_NSOSTATUS_cmd_test
0000afbc l     F .text	000000c0 at_handle_CGEQOS_cmd_test
0000b07c l     F .text	00000010 at_handle_CCIOTOPT_cmd_test
0000b08c l     F .text	00000038 at_handle_NCPCDPR_cmd_test
0000b0c4 l     F .text	00000010 at_handle_NXLOG_cmd_test
0000b0d4 l     F .text	00000010 at_handle_NIPINFO_cmd_test
0000b0e4 l     F .text	00000030 at_handle_NIPINFO_cmd_read
0000b114 l     F .text	00000010 at_handle_CGDATA_cmd_test
0000b124 l     F .text	00000010 at_handle_CIPCA_cmd_test
0000b134 l     F .text	00000010 at_handle_NPRDEFLASH_cmd_test
0000b144 l     F .text	00000010 at_handle_NFWUPD_cmd_test
0000b154 l     F .text	00000010 at_handle_NPTWEDRXS_cmd_test
0000b164 l     F .text	00000010 at_handle_CEDRXS_cmd_test
0000b174 l     F .text	00000010 at_handle_NGACTR_cmd_test
0000b184 l     F .text	0000003c at_handle_NGACTR_cmd_read
0000b1c0 l     F .text	00000010 at_handle_CGACT_cmd_test
0000b1d0 l     F .text	00000010 at_handle_CNMA_cmd_test
0000b1e0 l     F .text	00000010 at_handle_CMMS_cmd_test
0000b1f0 l     F .text	00000010 at_handle_CSMS_cmd_test
0000b200 l     F .text	00000010 at_handle_CPSMS_cmd_test
0000b210 l     F .text	00000010 at_handle_NTPERMID_cmd_test
0000b220 l     F .text	00000010 at_handle_NATSPEED_cmd_test
0000b230 l     F .text	00000010 at_handle_CGSN_cmd_test
0000b240 l     F .text	00000010 at_handle_NLOGLEVEL_cmd_test
0000b250 l     F .text	00000010 at_handle_CTZR_cmd_test
0000b260 l     F .text	0000003c at_handle_CTZR_cmd_read
0000b29c l     F .text	00000010 at_handle_NITZ_cmd_test
0000b2ac l     F .text	00000010 at_handle_CGAUTH_cmd_test
0000b2bc l     F .text	00000010 at_handle_CGDCONT_cmd_test
0000b2cc l     F .text	00000010 at_handle_CMEE_cmd_test
0000b2dc l     F .text	00000010 at_handle_NPSMR_cmd_test
0000b2ec l     F .text	00000054 at_handle_NPSMR_cmd_read
0000b340 l     F .text	00000010 at_handle_CSCON_cmd_test
0000b350 l     F .text	00000010 at_handle_CEREG_cmd_test
0000b360 l     F .text	00000010 at_handle_CSQ_cmd_test
0000b370 l     F .text	00000010 at_handle_CFUN_cmd_test
0000b380 l     F .text	00000010 at_handle_NCHIPINFO_cmd_test
0000b390 l     F .text	00000010 at_handle_UE_STATS_cmd_test
0000b3a0 l     F .text	00000010 at_handle_CGATT_cmd_test
0000b3b0 l     F .text	0000007c app_at_send_socket_or_cid_status_string
0000b42c l     F .text	00000074 at_handle_NCIDSTATUS_cmd_exec
0000b4a0 l     F .text	0000009c app_at_send_at_rsp_apnrc_string
0000b53c l     F .text	00000054 at_handle_NSOSTATUS_cmd_exec
0000b590 l     F .text	00000098 output_ue_stats_bler
0000b628 l     F .text	00000078 output_ue_statshp
0000b6a0 l     F .text	00000298 at_handle_CRSM_cmd_set
0000b938 l     F .text	00000120 at_handle_CSIM_cmd_set
0000ba58 l     F .text	00000138 at_handle_CGLA_cmd_set
0000bb90 l     F .text	0000008c at_handle_CCHO_cmd_set
0000bc1c l     F .text	000000a4 at_handle_CPINR_cmd_exec
0000bcc0 l     F .text	00000018 nxlog_output_response_to_at_uart_callback
0000bcd8 l     F .text	0000011c at_handle_NCONFIG_cmd_test
0000bdf4 l     F .text	000000a8 at_handle_CPINR_cmd_set
0000be9c l     F .text	0000005c at_handle_CPIN_cmd_read
0000bef8 l     F .text	000000d8 at_handle_CPIN_cmd_set
0000c0d0 l     F .text	00000018 cpin_result_callback
0000bfd0 l     F .text	00000100 at_handle_NPIN_cmd_set
0000c0e8 l     F .text	0000000c modify_pdp_callback
0000c0f4 l     F .text	00000028 cfun_result_callback
0000c11c l     F .text	00000088 at_handle_CGTFT_cmd_test
0000c1a4 l     F .text	000000d8 at_get_available_plmn_callback
0000c27c l     F .text	0000006c at_handle_nping_callback
0000c2e8 l     F .text	00000098 at_handle_CGEQOS_cmd_read
0000c380 l     F .text	00000078 at_handle_CGEQOS_cmd_set
0000c3f8 l     F .text	0000005c at_handle_CCIOTOPT_cmd_read
0000c454 l     F .text	000000e4 at_handle_CCIOTOPT_cmd_set
0000c538 l     F .text	000000cc app_at_send_at_rsp_active_string
0000c604 l     F .text	00000010 at_handle_CGCMOD_cmd_test
0000c614 l     F .text	00000010 at_handle_CGCONTRDP_cmd_test
0000c624 l     F .text	00000010 at_handle_CGAPNRC_cmd_test
0000c634 l     F .text	00000078 at_handle_CGAPNRC_cmd_exec
0000c6ac l     F .text	00000064 at_handle_CGAPNRC_cmd_set
0000c710 l     F .text	0000003c at_handle_CGCMOD_cmd_set
0000c74c l     F .text	0000007c at_handle_NCPCDPR_cmd_read
0000c7c8 l     F .text	000001a0 app_at_send_at_rsp_cgcontrdp_string
0000c968 l     F .text	00000040 at_handle_CGCONTRDP_cmd_exec
0000c9a8 l     F .text	00000038 at_handle_CGCONTRDP_cmd_set
0000c9e0 l     F .text	000000a0 at_handle_NDIEID_cmd_exec
0000ca80 l     F .text	00000088 at_handle_NXLOG_cmd_set
0000cb08 l     F .text	00000012 at_handle_CNMPSD_cmd_exec
0000cb1c l     F .text	000000c4 nipinfo_callback
0000cbe0 l     F .text	0000004c at_handle_NATSPEED_cmd_read
0000cc2c l     F .text	000000ec output_ue_stats_radio
0000cd18 l     F .text	0000016c at_handle_CGDATA_cmd_set
0000ce84 l     F .text	00000048 at_handle_CIPCA_cmd_read
0000cecc l     F .text	0000006a at_handle_CIPCA_cmd_set
0000cf38 l     F .text	0000009c at_handle_NPOWERCLASS_cmd_test
0000cfd4 l     F .text	00000094 at_handle_NBAND_read
0000d068 l     F .text	0000009c at_handle_NPOWERCLASS_cmd_read
0000d104 l     F .text	000001f0 at_handle_NPRDEFLASH_cmd_set
0000d2f4 l     F .text	000000e2 at_handle_NFWUPD_cmd_set
0000d3d8 l     F .text	00000064 at_handle_CEER_cmd_exec
0000d43c l     F .text	00000108 at_get_pending_data_list_common_handle
0000d544 l     F .text	00000048 at_common_get_pending_non_ip_send_data_list
0000d58c l     F .text	0000000a at_handle_NQPNPD_cmd_exec
0000d596 l     F .text	0000000a at_handle_NQPODCP_cmd_exec
0000d5a0 l     F .text	00000070 at_common_handle_non_ip_report_data_mode_test
0000d610 l     F .text	00000010 at_handle_NRNPDM_cmd_test
0000d620 l     F .text	00000010 at_handle_CRTDCP_cmd_test
0000d630 l     F .text	00000080 at_common_non_ip_send_data_test
0000d6b0 l     F .text	00000010 at_handle_NSNPD_cmd_test
0000d6c0 l     F .text	00000010 at_handle_CSODCP_cmd_test
0000d6d0 l     F .text	00000038 at_handle_NRNPDM_cmd_read
0000d708 l     F .text	00000040 at_handle_CRTDCP_cmd_read
0000d748 l     F .text	00000048 at_handle_CGACT_cmd_read
0000d790 l     F .text	00000058 at_handle_CGACT_cmd_set
0000d7e8 l     F .text	00000054 at_handle_CMGC_cmd_set
0000d83c l     F .text	00000054 at_handle_CMGS_cmd_set
0000d890 l     F .text	000000a0 at_handle_CNMA_cmd_set
0000d930 l     F .text	00000054 at_handle_CMMS_cmd_read
0000d984 l     F .text	0000006c at_handle_CSMS_cmd_read
0000d9f0 l     F .text	00000098 at_handle_CSMS_cmd_set
0000da88 l     F .text	0000008c sms_receive_message_callback
0000db14 l     F .text	00000054 at_handle_CSCA_cmd_read
0000db68 l     F .text	00000088 at_handle_CSCA_cmd_set
0000dbf0 l     F .text	00000080 at_handle_CLAC_cmd_exec
0000dc70 l     F .text	000000b8 at_handle_CGMR_cmd_exec
0000dd28 l     F .text	00000044 at_handle_CGMM_cmd_exec
0000dd6c l     F .text	0000016c at_handle_NATSPEED_cmd_set
0000ded8 l     F .text	00000148 at_handle_NTSETID_cmd_set
0000e020 l     F .text	00000044 at_handle_CGMI_cmd_exec
0000e064 l     F .text	00000070 at_handle_NLOGLEVEL_cmd_read
0000e0d4 l     F .text	000000bc at_handle_NLOGLEVEL_cmd_set
0000e190 l     F .text	00000084 at_handle_NCCID_cmd_read
0000e214 l     F .text	00000008 at_handle_NCCID_cmd_exc
0000e21c l     F .text	00000108 ctzr_callback
0000e324 l     F .text	00000044 at_handle_NITZ_cmd_read
0000e368 l     F .text	000000b4 at_handle_CGAUTH_cmd_read
0000e41c l     F .text	000000b0 at_handle_CGAUTH_cmd_set
0000e4cc l     F .text	000001f0 at_handle_CGDCONT_cmd_read
0000e6bc l     F .text	000001f4 at_handle_CGDCONT_cmd_set
0000e8b0 l     F .text	0000021c at_handle_NSOCR_cmd_set
00011914 l     F .text	000000c4 at_socket_status_callback
0000eacc l     F .text	000000d8 at_handle_NCONFIG_cmd_read
0000eba4 l     F .text	00000134 at_handle_NCONFIG_cmd_set
0000ecd8 l     F .text	000000a0 at_handle_NPING_cmd_set
0000ed78 l     F .text	0000002c at_handle_CMEE_cmd_read
0000eda4 l     F .text	0000008c at_handle_CSCON_cmd_read
0000ee30 l     F .text	000000a0 at_handle_CGPADDR_cmd_exec
0000eed0 l     F .text	000000d4 at_handle_CGPADDR_cmd_set
0000efa4 l     F .text	0000002a at_handle_CGPADDR_cmd_test
0000efd0 l     F .text	00000048 at_handle_CSQ_cmd_exec
0000f018 l     F .text	0000006c at_handle_CIMI_cmd_exec
0000f084 l     F .text	00000028 at_handle_NRB_cmd_exec
0000f0ac l     F .text	0000003c at_handle_CFUN_cmd_read
0000f0e8 l     F .text	00000128 at_handle_NCHIPINFO_cmd_set
0000f210 l     F .text	00000078 at_handle_NRDTEST_set
00010b2c l     F .text	00000074 nrdtest_callback
0000f288 l     F .text	000000a0 at_handle_NBAND_test
0000f328 l     F .text	0000007c at_handle_NBAND_set
0000f3a4 l     F .text	0000002a at_handle_UE_STATS_cmd_exec
0000f3d0 l     F .text	000000ac output_ue_stats_cell
0000f47c l     F .text	00000080 output_ue_stats_appsmem
0000f4fc l     F .text	000000f0 at_handle_UE_STATS_cmd_set
0000f5ec l     F .text	00000012 at_handle_NCSEARFCN_cmd_exec
0000f600 l     F .text	000000a0 at_handle_NEARFCN_cmd_set
0000f6a0 l     F .text	0000003c at_handle_CGATT_cmd_read
0000f6dc l     F .text	00000014 at_handle_COPS_cmd_test
0000f6f0 l     F .text	000000cc at_handle_COPS_cmd_read
0000f7bc l     F .text	000000f0 at_handle_COPS_cmd_set
0000f8ac l     F .text	0000003c at_parse_convert_hexstring_to_uuid.part.0
0000f8e8 l     F .text	0000005e at_handle_CGSN_cmd_exec
0000f948 l     F .text	00000114 at_handle_CGSN_cmd_set
0000fa5c l     F .text	0000001e at_uint8_to_binary_string.part.1
0000fa7c l     F .text	000000d0 at_set_edrx_ptwedrx_changed_callback
0000fb4c l     F .text	0000000e at_set_edrx_changed_callback
0000fb5a l     F .text	00000012 at_set_ptwedrx_changed_callback
0000fb6c l     F .text	000000d8 at_handle_CEDRXRDP_cmd_exec
0000fc44 l     F .text	000000c0 at_cedrxs_nptwedrxs_common_handle_read
0000fd04 l     F .text	0000000a at_handle_NPTWEDRXS_cmd_read
0000fd0e l     F .text	0000000a at_handle_CEDRXS_cmd_read
0000fd18 l     F .text	00000018 check_at_allocated_socket
0000fd30 l     F .text	00000084 at_handle_NSOSTATUS_cmd_set
0000fdb4 l     F .text	00000058 at_handle_NQSOS_cmd_read
0000fe0c l     F .text	00000090 at_handle_NQSOS_cmd_set
0000fe9c l     F .text	00000160 at_handle_NSORF_cmd_set
0000fffc l     F .text	00000218 at_nsost_nsostf_common_handle
00010214 l     F .text	0000000a at_handle_NSOSTF_cmd_set
0001021e l     F .text	0000000a at_handle_NSOST_cmd_set
00010228 l     F .text	00000124 at_handle_NSOSD_cmd_set
0001034c l     F .text	0000008e at_handle_NSOCO_cmd_set
000103da l     F .text	00000062 at_cgtft_decimal_string_to_uint16_range.part.4
0001043c l     F .text	000003b0 at_handle_CGTFT_cmd_set
000107ec l     F .text	0000003e at_parse_binary_string_to_uint8
0001082c l     F .text	00000128 at_cedrxs_nptwedrxs_common_handle_set
00010954 l     F .text	0000000a at_handle_NPTWEDRXS_cmd_set
0001095e l     F .text	0000000a at_handle_CEDRXS_cmd_set
00010968 l     F .text	000000b8 at_handle_CPSMS_cmd_set
00010a20 l     F .text	00000060 at_handle_NCIDSTATUS_cmd_set
00010a80 l     F .text	00000038 at_handle_NPSMR_cmd_set
00010ab8 l     F .text	00000038 at_handle_NUICC_cmd_set
00010af0 l     F .text	0000003a at_handle_CCHC_cmd_set
00010ba0 l     F .text	00000052 at_handle_NCPCDPR_cmd_set
00010bf4 l     F .text	00000048 at_handle_NIPINFO_cmd_set
00010c3c l     F .text	0000004e at_handle_NPOWERCLASS_cmd_set
00010c8c l     F .text	0000014c at_common_handle_non_ip_send_data_parse.part.15
00010dd8 l     F .text	00000018 at_handle_NSNPD_cmd_set
00010df0 l     F .text	00000048 at_handle_NGACTR_cmd_set
00010e38 l     F .text	0000001a at_handle_CNMA_cmd_exec
00010e52 l     F .text	00000038 at_handle_CMMS_cmd_set
00010e8a l     F .text	0000005e at_handle_NTPERMID_cmd_set
00010ee8 l     F .text	0000004c at_handle_CTZR_cmd_set
00010f34 l     F .text	0000003c at_handle_NITZ_set
00010f70 l     F .text	00000054 at_handle_CCLK_set
00010fc4 l     F .text	00000046 at_handle_NSOCL_cmd_set
0001100a l     F .text	00000036 at_handle_CMEE_cmd_set
00011040 l     F .text	00000048 at_handle_CSCON_cmd_set
00011088 l     F .text	0000005c at_handle_CEREG_cmd_set
000117bc l     F .text	00000044 service_status_callback
00011800 l     F .text	00000068 t3324_t3412_ext_value_callback
000110e4 l     F .text	0000004c at_handle_CFUN_cmd_set
00011130 l     F .text	00000038 at_handle_CGATT_cmd_set
00011168 l     F .text	000002d0 at_handle_CGTFT_cmd_read
00011438 l     F .text	00000004 at_handle_CRSM_cmd_test
0001143c l     F .text	00000004 at_handle_NEARFCN_cmd_test
00011440 l     F .text	00000004 at_handle_CGMM_cmd_test
00011444 l     F .text	00000004 at_handle_CGMI_cmd_test
00011448 l     F .text	00000004 at_handle_CGMR_cmd_test
0001144c l     F .text	00000004 at_handle_CIMI_cmd_test
00011450 l     F .text	00000004 at_handle_NRDTEST_test
00011454 l     F .text	00000004 at_handle_CLAC_cmd_test
00011458 l     F .text	00000004 at_handle_CCLK_cmd_test
0001145c l     F .text	00000004 at_handle_NCCID_cmd_test
00011460 l     F .text	00000004 at_handle_NQPODCP_cmd_test
00011464 l     F .text	00000004 at_handle_NQPNPD_cmd_test
00011468 l     F .text	00000004 at_handle_CSCA_cmd_test
0001146c l     F .text	00000004 at_handle_CMGS_cmd_test
00011470 l     F .text	00000004 at_handle_CMGC_cmd_test
00011474 l     F .text	00000004 at_handle_CEER_cmd_test
00011478 l     F .text	00000004 at_handle_CEDRXRDP_cmd_test
0001147c l     F .text	00000004 at_handle_CNMPSD_cmd_test
00011480 l     F .text	00000004 at_handle_CPIN_cmd_test
00011484 l     F .text	00000004 at_handle_CPINR_cmd_test
00011488 l     F .text	00000004 at_handle_CCHO_cmd_test
0001148c l     F .text	00000004 at_handle_CCHC_cmd_test
00011490 l     F .text	00000004 at_handle_CGLA_cmd_test
00011494 l     F .text	00000004 at_handle_CSIM_cmd_test
00011498 l     F .text	00000004 at_handle_NUICC_cmd_test
0001149c l     F .text	0000001a at_handle_CSODCP_cmd_set
000114b6 l     F .text	00000036 at_handle_CRTDCP_cmd_set
000114ec l     F .text	00000036 at_handle_NRNPDM_cmd_set
00011524 l     F .text	000000a0 at_handle_CPSMS_cmd_read
000115c4 l     F .text	0000017c output_cereg_print
00011740 l     F .text	0000006e output_cereg_info
000117ae l     F .text	0000000c at_handle_CEREG_cmd_read
00011868 l     F .text	000000ac at_handle_CCLK_cmd_read
010024c0 l     O .bss	00000001 app_at_ciot_reporting
010024c1 l     O .bss	00000001 app_at_ip_info
010024c2 l     O .bss	00000006 app_at_state_info
010024c8 l     O .bss	00000004 sock_at_allocated
000234c9 l     O .text	0000000b CSWTCH.755
00023529 l     O .text	00000007 at_cgeqos_support_qci_value
00023f68 l     O .text	0000000c core_name
000247e4 l     O .text	00000018 log_level_names
000247fc l     O .text	00000014 mem_stats_labels
00024810 l     O .text	00000008 nconfig_false_true_value_name
00024818 l     O .text	0000005c nconfig_function_names
0002493f l     O .text	0000000c rsp_rest_string.7278
00000000 l    df *ABS*	00000000 app_at_cmd_register.c
010024cc l     O .bss	00000004 at_cmd_registered_table
00000000 l    df *ABS*	00000000 app_at_filter.c
010024d0 l     O .bss	00000004 at_filter_update_state_callback
00000000 l    df *ABS*	00000000 app_at_module_ota.c
00011b3c l     F .text	00000020 at_get_package_info_buff
00011b5c l     F .text	00000040 ota_package_print_result
00011b9c l     F .text	00000028 at_ota_helper_take_binary
00011bc4 l     F .text	00000018 at_ota_binary_create.part.2
00011bdc l     F .text	00000024 at_ota_helper_give_binary.isra.0
00011c00 l     F .text	00000010 at_ota_helper_package_parse_done
00011c10 l     F .text	00000008 at_ota_helper_erase_done
00011c18 l     F .text	00000008 at_ota_helper_download_done
00011c20 l     F .text	00000008 at_ota_helper_get_package_info_done
010024d4 l     O .bss	00000004 at_ota_binary
010024d8 l     O .bss	00000004 ota_package_info_buff
010024dc l     O .bss	00000004 package_offset
010024e0 l     O .bss	00000004 package_sn
01000594 l     O .data	00000001 at_ota_package_parse_status
0002515c l     O .text	00000028 CSWTCH.25
00025184 l     O .text	0000000c CSWTCH.34
00000000 l    df *ABS*	00000000 app_at_module_production.c
00011e60 l     F .text	00000004 at_handle_NCALTEMPSENSOR_cmd_test
00011e64 l     F .text	00000010 at_handle_NRDMIPI_cmd_test
00011e74 l     F .text	00000010 at_handle_NRDEXEC_cmd_test
00011e84 l     F .text	00000010 at_handle_NRDSET_cmd_test
00011e94 l     F .text	00000010 at_handle_NRDCTRL_cmd_test
00011ea4 l     F .text	000000f8 at_handle_NRDMIPI_cmd_set
00011f9c l     F .text	0000050c at_handle_NRDEXEC_cmd_set
000127fc l     F .text	0000001e nrdexec_rxlist_callback
000124a8 l     F .text	000000b4 at_handle_NRDSET_cmd_read
0001255c l     F .text	0000018c at_handle_NRDSET_cmd_set
000126e8 l     F .text	0000007c at_handle_NRDCTRL_cmd_set
00012764 l     F .text	00000030 at_handle_NCALTEMPSENSOR_cmd_set
00012794 l     F .text	00000068 nrdexec_rxlist_callback.part.1
010024e4 l     O .bss	00000001 initialed.5083
00025420 l     O .text	00000078 production_at_cmd_table
00000000 l    df *ABS*	00000000 logical_channel.c
00000000 l    df *ABS*	00000000 backtrace.c
00012960 l     F .text	00000034 trace_fn
010024e5 l     O .bss	00000001 already_tracing
00000000 l    df *ABS*	00000000 irmalloc.c
00000000 l    df *ABS*	00000000 los_memory.c
010024e8 l     O .bss	0000000c upper_ope
00000000 l    df *ABS*	00000000 los_slabmem.c
010024f4 l     O .bss	00000004 g_SlabAllocCount
010024f8 l     O .bss	00000004 g_SlabFreeCount
010024fc l     O .bss	00000004 p_slab_last
00000000 l    df *ABS*	00000000 los_task.c
00012e34 l     F .text	00000014 LOS_ListDelete
00000000 l    df *ABS*	00000000 los_heap.c
01002500 l     O .bss	00000004 g_uwAllocCount
01002504 l     O .bss	00000004 g_uwFreeCount
00000000 l    df *ABS*	00000000 los_slab.c
00000000 l    df *ABS*	00000000 los_misc.c
00000000 l    df *ABS*	00000000 los_hw.c
00000000 l    df *ABS*	00000000 los_sleep.c
01000400 l     F .ramtext	00000020 osEnterSleep
01002508 l     O .bss	00000008 MyEntryTime
01002510 l     O .bss	00000004 counter_handle
01002518 l     O .bss	00000008 losRtcTimeCalibrate
01002520 l     O .bss	00000004 losSystickCalibrate
01002528 l     O .bss	00000008 rtc_delay
01002530 l     O .bss	00000004 ulStopClockVetoes
00000000 l    df *ABS*	00000000 los_priqueue.c
00000000 l    df *ABS*	00000000 los_swtmr.c
00013f28 l     F .text	00000060 osSwTmrTimeoutHandle
00000000 l    df *ABS*	00000000 los_sys.c
00000000 l    df *ABS*	00000000 los_tick.c
00000000 l    df *ABS*	00000000 los_timeslice.c
00000000 l    df *ABS*	00000000 los_queue.c
00000000 l    df *ABS*	00000000 los_atomicbitset.c
00000000 l    df *ABS*	00000000 cmsis_liteos.c
01002534 l     O .bss	00000004 KernelState
00000000 l    df *ABS*	00000000 uart.c
00014c14 l     F .text	00000030 uart_rx_buffer_unsent_data
00014c44 l     F .text	00000058 uart_helper_invoke_rx_callback
00014c9c l     F .text	00000028 uart_rx_dma_transfer_finish_manipulate
00014cc4 l     F .text	00000028 uart_rx_dma_transfer_prepare_manipulate
00014cec l     F .text	00000028 uart_tx_dma_transfer_finish_manipulate
00014d14 l     F .text	00000028 uart_tx_dma_transfer_prepare_manipulate
00014d3c l     F .text	00000068 uart_helper_tx_fragments_claim_next_available
00014da4 l     F .text	00000020 uart_ensure_sleep_vetoed
00014dc4 l     F .text	00000034 uart_helper_get_used_rx_buffer_space
00014df8 l     F .text	00000020 uart_remove_any_sleep_veto
00014e18 l     F .text	00000050 uart_assert_software_tx_flow_control
00014e68 l     F .text	0000001c uart_helper_handle_received_control_char
00014e84 l     F .text	0000000c uart_assert_software_tx_flow_control2
00014e90 l     F .text	0000000c uart_assert_software_tx_flow_control1
00014e9c l     F .text	0000000c uart_assert_software_tx_flow_control0
00014ea8 l     F .text	00000040 uart_issue_rx_flow_control_char
00014ee8 l     F .text	00000074 uart_assert_software_rx_flow_control
00014f5c l     F .text	00000038 uart_helper_determine_rx_flow_control
00014f94 l     F .text	00000048 uart_helper_put_data_in_rx_buffer
00014fdc l     F .text	000000ec uart_error_isr
000150c8 l     F .text	0000000a uart_error_isr2
000150d2 l     F .text	0000000a uart_error_isr1
000150dc l     F .text	0000000a uart_error_isr0
000150e6 l     F .text	0000000c uart_assert_software_rx_flow_control2
000150f2 l     F .text	0000000c uart_assert_software_rx_flow_control1
000150fe l     F .text	0000000c uart_assert_software_rx_flow_control0
0001510c l     F .text	000000e0 uart_idle_isr
000151ec l     F .text	0000000a uart_idle_isr2
000151f6 l     F .text	0000000a uart_idle_isr1
00015200 l     F .text	0000000a uart_idle_isr0
0001520c l     F .text	0000014c uart_tx_isr
00015358 l     F .text	0000000a uart_tx_isr2
00015362 l     F .text	0000000a uart_tx_isr1
0001536c l     F .text	0000000a uart_tx_isr0
00015378 l     F .text	000000e0 uart_rx_isr
00015458 l     F .text	0000000a uart_rx_isr2
00015462 l     F .text	0000000a uart_rx_isr1
0001546c l     F .text	0000000a uart_rx_isr0
000154bc l     F .text	0000000c uart_rx_dma_transfer_finish.part.0
000154bc l     F .text	0000000c uart_tx_dma_transfer_prepare.part.3
000154bc l     F .text	0000000c uart_tx_dma_transfer_finish.part.2
000154bc l     F .text	0000000c uart_rx_dma_transfer_prepare.part.1
000154c8 l     F .text	00000024 uart_rx_dma_transfer_finish
000154ec l     F .text	00000024 uart_rx_dma_transfer_prepare
00015510 l     F .text	00000024 uart_tx_dma_transfer_finish
00015534 l     F .text	00000024 uart_tx_dma_transfer_prepare
00015558 l     F .text	00000014 uart_helper_take_semaphore_or_panic
0001556c l     F .text	00000038 uart_claim_mutexes
000155a4 l     F .text	00000014 uart_helper_give_semaphore_or_panic
000155b8 l     F .text	00000034 uart_release_mutexes
000155ec l     F .text	00000074 uart_rx_buffer_release.isra.9
00015660 l     F .text	0000000a uart_rx_buffer_release2
0001566a l     F .text	0000000a uart_rx_buffer_release1
00015674 l     F .text	0000000a uart_rx_buffer_release0
00015680 l     F .text	00000054 uart_deconfigure_state
0100253c l     O .bss	0000000c uart_data_register
01002548 l     O .bss	0000000c uart_dmac_register
01002554 l     O .bss	0000000c uart_flow_control_state_array
01002560 l     O .bss	0000000c uart_pin_config
0100256c l     O .bss	0000000c uart_rx_mutex
01002578 l     O .bss	0000000c uart_rx_state
01002584 l     O .bss	00000001 uart_sleep_vetoed
01002588 l     O .bss	0000000c uart_tx_mutex
01002594 l     O .bss	0000000c uart_tx_state
000254e0 l     O .text	0000000c uart_assert_software_rx_flow_control_functions
000254ec l     O .text	0000000c uart_assert_software_tx_flow_control_functions
000254f8 l     O .text	00000030 uart_interrupt_handlers
00025528 l     O .text	0000000c uart_release_functions
00025534 l     O .text	00000003 uart_rx_dma_peripheral
00025537 l     O .text	00000003 uart_tx_dma_peripheral
00000000 l    df *ABS*	00000000 aio_manager_control.c
010025a0 l     O .bss	00000017 aio_resources_status_table
010025b7 l     O .bss	00000006 deferred_mux_select_config
00000000 l    df *ABS*	00000000 temp_mon.c
010005ce l     O .data	00000002 temperature_coeff
00000000 l    df *ABS*	00000000 dma.c
0001655c l     F .text	0000001c dma_configs_adding_fsm_transit_batched_part
00016578 l     F .text	0000001c dma_configs_adding_fsm_transit_batched_end
00016594 l     F .text	00000038 dma_ch_config_peripheral_preprocess
000165cc l     F .text	00000028 dma_configs_adding_fsm_transit_single
000165f4 l     F .text	0000004c dma_transfer
00016640 l     F .text	0000001c dma_release_mutexes
0001665c l     F .text	00000024 dma_ch_remove_any_sleep_veto
00016680 l     F .text	00000040 dma_ch_open_set_peripheral_feature
000166c0 l     F .text	000000d0 dma_fill_driver_ch_config
00016790 l     F .text	00000034 dma_configs_adding_fsm_batched_running
000167c4 l     F .text	000000f8 dma_configs_adding_fsm_batched_complete
000168bc l     F .text	00000040 dma_configs_adding_fsm_batched_start
000168fc l     F .text	0000005c dma_init_user_common_config
00016958 l     F .text	00000084 dma_configs_adding_fsm_single
000169dc l     F .text	00000020 dma_claim_mutexes
000169fc l     F .text	0000003a dma_transfer_head_configs
00016a38 l     F .text	00000058 dma_err_isr
00016a90 l     F .text	0000006c dma_done_isr
010025bd l     O .bss	00000004 dma_ch_sleep_veto
010025c4 l     O .bss	00000050 dma_config_controller
01002614 l     O .bss	00000010 dma_transfer_peripheral_finish
01002624 l     O .bss	00000004 dmac_mutex
0002553a l     O .text	00000009 cycle_type_maps.5576
00025543 l     O .text	00000004 dma_addr_inc_shift
00025548 l     O .text	00000010 dma_configs_adding_fsm_handler_list
00025558 l     O .text	0000000c dma_configs_adding_fsm_transit
00025564 l     O .text	00000009 dma_dst_addr_inc_map
0002556d l     O .text	00000009 dma_src_addr_inc_map
00000000 l    df *ABS*	00000000 uart_common.c
00016d0c l     F .text	0000003a uart_common_release_pins
00016d46 l     F .text	00000016 uart_common_release_peripheral
00025576 l     O .text	0000000c uart_common_pin_functions
00000000 l    df *ABS*	00000000 clocks.c
00000000 l    df *ABS*	00000000 gpio.c
00017050 l     F .text	00000018 gpio_any_interrupts_registered
00017068 l     F .text	00000018 gpio_any_pins_claimed
00017080 l     F .text	00000024 gpio_bitget
000170a4 l     F .text	00000030 gpio_bitclr
000170d4 l     F .text	00000030 gpio_bitset
01002638 l     O .bss	000000a0 gpio_handlers
01002628 l     O .bss	00000008 gpio_claimed
01002630 l     O .bss	00000008 gpio_direction
010026d8 l     O .bss	00000008 gpio_registered_interrupts
00025582 l     O .text	00000001 gpio_input_default_config
00025583 l     O .text	00000002 gpio_output_default_config
00000000 l    df *ABS*	00000000 ipc.c
0100ff00 l     O .ipc_mailbox	000000a0 ipc_mailboxes
010026e0 l     O .bss	00000004 id.4774
010026e4 l     O .bss	00000024 ipc_handlers
00000000 l    df *ABS*	00000000 log_buffer.c
000175b4 l     F .text	00000068 log_buffer_helper_add
0001761c l     F .text	0000003c log_buffer_get_available.constprop.0
01002708 l     O .bss	00000002 log_buffer_size
0100270c l     O .bss	00000004 log_buffer_start
01002710 l     O .bss	00000004 log_section_control
00000000 l    df *ABS*	00000000 log_buffer_reader.c
00017810 l     F .text	0000001e circled_index
00017830 l     F .text	00000078 log_buffer_reader_get_msg_header
01002714 l     O .bss	00000018 buffer_reader_control
0100272c l     O .bss	0000000c section_control
00000000 l    df *ABS*	00000000 log_memory_section.c
00000000 l    df *ABS*	00000000 lp_uart.c
00017c40 l     F .text	00000024 lp_uart_get_buffer_level
00017c64 l     F .text	00000044 lp_uart_determine_rx_flow_control
00017ca8 l     F .text	00000018 lp_uart_call_interrupt
00017cc0 l     F .text	0000002c lp_uart_release_pins
00017cec l     F .text	00000164 lp_uart_irq
01002738 l     O .bss	00000001 irq_enabled_flags
0100273c l     O .bss	00000018 lp_callbacks
01002754 l     O .bss	00000001 lp_uart_buffer_read_pos
01002755 l     O .bss	00000001 lp_uart_buffer_write_pos
01002756 l     O .bss	00000040 lp_uart_data_buffer
01002796 l     O .bss	00000040 lp_uart_error_buffer
010027d6 l     O .bss	00000001 lp_uart_last_frame_errors
010027d7 l     O .bss	00000001 lp_uart_last_parity_errors
010027d8 l     O .bss	00000001 lp_uart_rx_buffer_lower_water_margin
010027d9 l     O .bss	00000001 lp_uart_rx_buffer_upper_water_margin
010027da l     O .bss	00000001 lp_uart_rx_errors
010027db l     O .bss	00000001 lp_uart_rx_flow_control_asserted
010027dc l     O .bss	00000004 lp_uart_rx_flow_control_callback
010027e0 l     O .bss	00000001 lp_uart_tx_flow_control_asserted
010027e4 l     O .bss	00000004 lp_uart_tx_flow_control_callback
010027e8 l     O .bss	00000001 rx_irq_threshold_level
010005d0 l     O .data	00000001 lp_rts
010005d1 l     O .data	00000001 lp_rx
00000000 l    df *ABS*	00000000 non_os_utils.c
010027ec l     O .bss	00000004 driver_init_bits
010027f0 l     O .bss	00000002 non_os_critical_nesting
00000000 l    df *ABS*	00000000 pio.c
00000000 l    df *ABS*	00000000 reboot.c
010027f2 l     O .bss	00000002 reboot_reset_reason
00000000 l    df *ABS*	00000000 rtc.c
00018320 l     F .text	0000001c get_free_timer
0001833c l     F .text	00000048 set_next_rtc_timer_interrupt
00018384 l     F .text	00000094 rtc_irq_handler
00018418 l     F .text	00000058 add_to_active_list
00018470 l     F .text	0000007c timer_remove
01002808 l     O .bss	00000200 rtc_timer_store
010027f4 l     O .bss	00000004 rtc_active_timers
010027f8 l     O .bss	00000004 rtc_dormant_timers
010027fc l     O .bss	00000004 rtc_free_timers
01002800 l     O .bss	00000001 rtc_in_rtc_irq
00000000 l    df *ABS*	00000000 system_status.c
01000420 l     F .ramtext	0000001c system_status_enter_critical
0100043c l     F .ramtext	0000000c system_status_exit_critical
0100fee0 l     O .sys_status	00000020 system_status
00000000 l    df *ABS*	00000000 watchdog.c
01002a0d l     O .bss	00000001 watchdog_flags
01002a0e l     O .bss	00000001 watchdog_inited
01002a10 l     O .bss	00000004 watchdog_interval
00000000 l    df *ABS*	00000000 hal_gpio.c
00000000 l    df *ABS*	00000000 hal_pio.c
40001000 l     O .peripherals	00000a00 hal_pio_registers
00000000 l    df *ABS*	00000000 hal_lpuart_specific.c
00000000 l    df *ABS*	00000000 hal.c
00018d1e l       .text	00000000 NMI_MSP
00018d22 l       .text	00000000 NMI_END
00018d6e l       .text	00000000 HardFault_MSP
00018d72 l       .text	00000000 HardFault_END
010005d2 l     O .data	00000001 i.4834
010005d3 l     O .data	00000001 i.4841
00000000 l    df *ABS*	00000000 hal_clocks.c
00000000 l    df *ABS*	00000000 hal_dma.c
00018e44 l     F .text	00000058 hal_dma_ch_ctrl_data_structure_fill
01002a80 l     O .bss	00000080 hal_dma_ch_ctrl
01002b00 l     O .bss	00000010 hal_dma_ch_incontinuous_config
01002b10 l     O .bss	00000001 hal_dma_ch_intr_enabled_flags
01002b14 l     O .bss	00000010 hal_dma_ch_peripheral_prepare_callback
01002b24 l     O .bss	00000050 hal_dma_channel
01002b74 l     O .bss	00000001 hal_dma_initialised
00025585 l     O .text	00000004 hal_dma_addr_inc_shift
00000000 l    df *ABS*	00000000 hal_lpc.c
00000000 l    df *ABS*	00000000 hal_reboot.c
01002b76 l     O .bss	00000002 reset_cause
00000000 l    df *ABS*	00000000 hal_rtc.c
01002b78 l     O .bss	00000004 hal_rtc_irq_callback
01002b80 l     O .bss	00000008 hal_rtc_last_clock_timer
00000000 l    df *ABS*	00000000 hal_uart.c
01002b88 l     O .bss	00000003 hal_uart_force_isr_flags
01002b8b l     O .bss	00000001 hal_uart_initialised
01002b8c l     O .bss	00000030 hal_uart_interrupt_handler
00025590 l     O .text	00000005 rx_level_bytes.4793
00000000 l    df *ABS*	00000000 hal_ipc_irq.c
00000000 l    df *ABS*	00000000 hal_lpuart.c
00019f24 l     F .text	00000040 hal_lpuart_update_rts_signal_state
01002bbc l     O .bss	00000001 hal_lpuart_rts_state
01002bc0 l     O .bss	00000004 lpuart_irq_callback
010005d8 l     O .data	00000001 hal_lpuart_rts_pin
00000000 l    df *ABS*	00000000 hal_uart_specific.c
00025598 l     O .text	0000000c hal_uart_bases
000255a4 l     O .text	00000003 uart_interrupt_lines
00000000 l    df *ABS*	00000000 eflash.c
0001a1b4 l     F .text	00000010 eflash_exec_common_callback
0001a1c4 l     F .text	0000003c eflash_generic_cmd_send
0001a200 l     F .text	00000010 eflash_exec_write_enable_cmd
0001a210 l     F .text	00000064 eflash_wake
0001a274 l     F .text	00000028 eflash_delete_mutex
0001a29c l     F .text	00000020 eflash_remove_any_sleep_veto
0001a2bc l     F .text	00000020 eflash_ensure_sleep_vetoed
0001a2dc l     F .text	00000050 eflash_is_processing
0001a32c l     F .text	000000d8 eflash_helper_erase
0001a404 l     F .text	0000001a eflash_helper_take_mutex.constprop.4
0001a41e l     F .text	00000016 eflash_helper_give_mutex
0001a434 l     F .text	00000058 eflash_sleep
01002bc4 l     O .bss	00000001 eflash_available
01002bc5 l     O .bss	00000001 eflash_cmd_exec_error
01002bc8 l     O .bss	00000004 eflash_mutex
01002bcc l     O .bss	00000001 eflash_sleep_vetoed
01002bcd l     O .bss	00000001 eflash_spi_bus
01002bce l     O .bss	00000005 eflash_spi_pin
00000000 l    df *ABS*	00000000 snprintf.c
00000000 l    df *ABS*	00000000 vsnprintf.c
00000000 l    df *ABS*	00000000 vsprintf.c
00000000 l    df *ABS*	00000000 vvprintf.c
00000000 l    df *ABS*	00000000 abs.c
00000000 l    df *ABS*	00000000 atoi.c
00000000 l    df *ABS*	00000000 exit.c
00000000 l    df *ABS*	00000000 strtol.c
00000000 l    df *ABS*	00000000 strtoul.c
00000000 l    df *ABS*	00000000 memchr.c
00000000 l    df *ABS*	00000000 memcmp.c
00000000 l    df *ABS*	00000000 memmove.c
00000000 l    df *ABS*	00000000 strchr.c
00000000 l    df *ABS*	00000000 strcmp.c
00000000 l    df *ABS*	00000000 strlen.c
00000000 l    df *ABS*	00000000 strncmp.c
00000000 l    df *ABS*	00000000 strncpy.c
00000000 l    df *ABS*	00000000 time.c
0001b440 l     F .text	0000002c years_to_days
0001b46c l     F .text	0000005c ymd_to_scalar
01002bd4 l     O .bss	00000024 tms
00000000 l    df *ABS*	00000000 assert.c
00000000 l    df *ABS*	00000000 sprintf.c
00000000 l    df *ABS*	00000000 preserve.c
01002bf8 l     O .bss	00000001 valid
00000000 l    df *ABS*	00000000 adc.c
01002bfc l     O .bss	00000004 app_adc_semaphore
01002c00 l     O .bss	00000004 protocol_core_reading
01002c04 l     O .bss	00000001 protocol_core_ret_val
00000000 l    df *ABS*	00000000 flash_log.c
00000000 l    df *ABS*	00000000 identity.c
00000000 l    df *ABS*	00000000 log.c
00000000 l    df *ABS*	00000000 neul_time.c
01002c08 l     O .bss	00000004 time_zone_reporting_callback
00000000 l    df *ABS*	00000000 nonip_messaging.c
01002c0c l     O .bss	00000004 nonip_cp_only_callback
01002c10 l     O .bss	00000004 nonip_received_callback
01002c14 l     O .bss	00000004 nonip_sent_data_result_callback
00000000 l    df *ABS*	00000000 production.c
01002c18 l     O .bss	00000004 rdexec_rxlist_callback
01002c1c l     O .bss	00000004 rdtest_callback
00000000 l    df *ABS*	00000000 radio.c
01002c20 l     O .bss	00000004 attach_callback
01002c24 l     O .bss	00000004 cfun_result_callback
01002c28 l     O .bss	00000004 ciot_opt_callback
01002c2c l     O .bss	00000004 connection_status_callback
01002c30 l     O .bss	00000004 cring_ind_callback
01002c34 l     O .bss	00000004 get_available_plmn_callback
01002c38 l     O .bss	00000004 ip_info_callback
01002c3c l     O .bss	00000004 neul_psm_status_callback
01002c40 l     O .bss	00000004 pdp_act_callback
01002c44 l     O .bss	00000004 pdp_context_report_callback
01002c48 l     O .bss	00000004 pdp_modify_callback
01002c4c l     O .bss	00000004 pin_command_callback
01002c50 l     O .bss	00000004 radio_command_abort_callback
01002c54 l     O .bss	00000004 registration_status_callback
01002c58 l     O .bss	00000004 service_recovery_callback
01002c5c l     O .bss	00000004 set_edrx_changed_callback
01002c60 l     O .bss	00000004 set_plmn_state_callback
01002c64 l     O .bss	00000004 set_ptwedrx_changed_callback
01002c68 l     O .bss	00000004 sim_pin_ind_call_back
01002c6c l     O .bss	00000004 t3324_t3412_ext_value_changed_callback
00000000 l    df *ABS*	00000000 reboot.c
00000000 l    df *ABS*	00000000 sms_messaging.c
01002c70 l     O .bss	00000004 sms_cmt_pdu_callback
01002c74 l     O .bss	00000004 sms_send_cmd_result_callback
01002c78 l     O .bss	00000004 sms_send_msg_result_callback
00000000 l    df *ABS*	00000000 system.c
00000000 l    df *ABS*	00000000 ue_stats.c
00000000 l    df *ABS*	00000000 identity.c
01002c7c l     O .bss	00000001 neul_identity_svn
00000000 l    df *ABS*	00000000 getifaddrs.c
01002c80 l     O .bss	0000000c ip_changed_callback_table
00000000 l    df *ABS*	00000000 icmp_ping.c
01002c8c l     O .bss	00000004 ping_callback
00000000 l    df *ABS*	00000000 network.c
00000000 l    df *ABS*	00000000 network_ip4.c
01002c90 l     O .bss	00000010 str.3675
00000000 l    df *ABS*	00000000 network_ip6.c
01002ca0 l     O .bss	00000028 str.3673
00000000 l    df *ABS*	00000000 neul_utils.c
00000000 l    df *ABS*	00000000 activity_indication.c
01002cc8 l     O .bss	00000004 activity_delay_milliseconds
01002ccc l     O .bss	00000001 indication_count
01002cd0 l     O .bss	00000004 indication_mutex
010005e0 l     O .data	00000001 activity_indication_pin
00000000 l    df *ABS*	00000000 pppd.c
0001d854 l     F .text	00000010 ppp_output_cb_fn
0001d864 l     F .text	0000003c pppd_terminate
0001d8a0 l     F .text	00000018 ppp_socket_callback
0001d8b8 l     F .text	00000070 ppp_uart_callback
0001d928 l     F .text	00000078 linkStatusCB
0001d9a0 l     F .text	00000154 ppp_main
01002cd8 l     O .bss	00000004 last_packet_recv_time
01002cdc l     O .bss	00000001 num_plus_symbols
01002cdd l     O .bss	00000001 ppp_addr_set
01002ce0 l     O .bss	00000004 ppp_exited
01002ce4 l     O .bss	00000014 ppp_ipaddr
01002cf8 l     O .bss	00000004 ppp_queue_handle
01002cfc l     O .bss	00000004 ppp_thread
01002d00 l     O .bss	00000004 ppp_uart_handler
01002d04 l     O .bss	00000054 pppd_netif
01002d58 l     O .bss	00000004 ppps
01002d5c l     O .bss	00000004 terminate_timer
01002d60 l     O .bss	00000004 terminate_timer_last_recv
01002d64 l     O .bss	00000004 uart_release_callback
00000000 l    df *ABS*	00000000 ppp.c
0001dc98 l     F .text	00000020 ppp_netif_init_cb
0001dce0 l     F .text	00000030 ppp_netif_output_ip4
0001dcb8 l     F .text	00000026 ppp_do_connect
00000000 l    df *ABS*	00000000 pppos.c
0001e0a0 l     F .text	00000032 pppos_send_config
0001e0d2 l     F .text	00000016 pppos_recv_config
0001e0e8 l     F .text	00000010 pppos_destroy
0001e0f8 l     F .text	00000028 pppos_input_free_current_packet
0001e120 l     F .text	0000001e pppos_disconnect
0001e13e l     F .text	0000002e pppos_connect
0001e16c l     F .text	00000008 pppos_listen
0001e174 l     F .text	000000a0 pppos_output_append
000258a0 l     O .text	00000200 fcstab
0001e214 l     F .text	00000080 pppos_output_last
0001e294 l     F .text	0000013c pppos_netif_output
0001e3d0 l     F .text	000000c8 pppos_write
00025aa4 l     O .text	00000020 pppos_callbacks
00000000 l    df *ABS*	00000000 utils.c
0001eb80 l     F .text	00000028 ppp_logit
00025be3 l     O .text	00000011 hexchars.5160
00000000 l    df *ABS*	00000000 auth.c
00000000 l    df *ABS*	00000000 ipcp.c
0001eda0 l     F .text	0000003e ipcp_cilen
0001edde l     F .text	0000008e ipcp_addci
0001ee6c l     F .text	000000aa ipcp_ackci
0001ef16 l     F .text	00000100 ipcp_rejci
0001f016 l     F .text	0000000a ipcp_close
0001f020 l     F .text	00000016 ipcp_open
0001f036 l     F .text	0000000a ipcp_lowerdown
0001f040 l     F .text	0000000a ipcp_lowerup
0001f04a l     F .text	0000000a ipcp_input
0001f054 l     F .text	00000044 ipcp_init
0001f098 l     F .text	0000001a ipcp_finished
0001f0b2 l     F .text	00000036 ipcp_down
0001f0e8 l     F .text	00000140 ipcp_up
0001f228 l     F .text	00000254 ipcp_nakci
0001f47c l     F .text	0000006e ipcp_resetci
0001f4ea l     F .text	0000028a ipcp_reqci
0001f774 l     F .text	0000000a ipcp_protrej
00025c48 l     O .text	0000003c ipcp_callbacks
00000000 l    df *ABS*	00000000 lcp.c
0001f780 l     F .text	0000006c lcp_cilen
0001f7ec l     F .text	00000178 lcp_ackci
0001f964 l     F .text	0000023a lcp_rejci
0001fba0 l     F .text	00000114 lcp_addci
0001fcb4 l     F .text	00000018 lcp_protrej
0001fccc l     F .text	00000016 lcp_delayed_up
0001fce4 l     F .text	00000038 lcp_input
0001fd1c l     F .text	00000080 lcp_init
0001fd9c l     F .text	0000000a lcp_finished
0001fda6 l     F .text	0000000a lcp_starting
0001fdb0 l     F .text	0000006c lcp_down
000202e4 l     F .text	00000018 LcpEchoTimeout
0001fea0 l     F .text	0000004c lcp_resetci
0001feec l     F .text	000002a8 lcp_reqci
00020224 l     F .text	000000c0 LcpEchoCheck
000202fc l     F .text	000000f0 lcp_up
000203ec l     F .text	000003e4 lcp_nakci
000207fc l     F .text	000000e4 lcp_extcode
00025ea0 l     O .text	0000003c lcp_callbacks
00000000 l    df *ABS*	00000000 magic.c
01002d68 l     O .bss	00000004 magic_randomseed
00000000 l    df *ABS*	00000000 fsm.c
00020930 l     F .text	000000f4 fsm_sconfreq
00020b98 l     F .text	000000b0 fsm_timeout
00020c48 l     F .text	00000084 terminate_layer
00000000 l    df *ABS*	00000000 los_mux.c
00000000 l    df *ABS*	00000000 los_sem.c
00000000 l    df *ABS*	00000000 los_err.c
00000000 l    df *ABS*	00000000 los_hw_tick.c
00000000 l    df *ABS*	00000000 los_config.c
00000000 l    df *ABS*	00000000 spi.c
00021734 l     F .text	00000024 ssp_remove_any_sleep_veto
00021758 l     F .text	0000002a ssp_busy_wait
00021782 l     F .text	00000022 spi_set_pio
000217a4 l     F .text	00000026 ssp_helper_take_semaphore.constprop.9
000217ca l     F .text	00000022 ssp_helper_give_semaphore
000217ec l     F .text	00000016 spi_release_pio
00021802 l     F .text	0000003a spi_pio_release.isra.2
01002d6c l     O .bss	00000008 ssp_mutex
01002d74 l     O .bss	00000002 ssp_sleep_vetoed
010005e1 l     O .data	0000000a spi_pins
000260fa l     O .text	00000002 ssp_inited
00000000 l    df *ABS*	00000000 hal_ssp.c
00022164 l     F .text	00000090 hal_ssp_interrupt_handler
01002d78 l     O .bss	00000020 ssp_interrupt_handler
000260fc l     O .text	00000008 hal_ssp_bases
00026104 l     O .text	00000002 hal_ssp_clken_masks
00026106 l     O .text	00000002 hal_ssp_interrupt_lines
00000000 l    df *ABS*	00000000 abort.c
00000000 l    df *ABS*	00000000 rand.c
010005ec l     O .data	00000004 myseed
00000000 l    df *ABS*	00000000 strstr.c
00000000 l    df *ABS*	00000000 signal.c
010005f0 l     O .data	0000001c handlers
00000000 l    df *ABS*	00000000 lwip_support_log.c
01002d98 l     O .bss	00000064 s.4014
00000000 l    df *ABS*	00000000 lwip_support_memp.c
00000000 l    df *ABS*	00000000 lwip_support_netif.c
0002236c l     F .text	00000014 ip4_socket_recv_notify_callback
01002dfc l     O .bss	00000004 netif_callback
00000000 l    df *ABS*	00000000 lwip_support_pbuf.c
00000000 l    df *ABS*	00000000 lwip_support_serial.c
00022694 l     F .text	00000018 serial_uart_callback
01002e00 l     O .bss	00000001 serial_lwip_uart
01002e04 l     O .bss	00000004 serial_rx_callback
0100060c l     O .data	0000000c neul_lwip_uart_config
00000000 l    df *ABS*	00000000 lwip_support_sys.c
00000000 l    df *ABS*	00000000 lwip_support_timeouts.c
00022820 l     F .text	00000028 sys_timeout_default_handler
00022848 l     F .text	00000020 sys_timeout_init_mutex
01002e08 l     O .bss	00000004 timeout_list
01002e0c l     O .bss	00000004 timeout_mutex
00000000 l    df *ABS*	00000000 hal_sectors.c
00000000 l    df *ABS*	00000000 ctype.c
00000000 l    df *ABS*	00000000 c:/gcc-arm-none-eabi-7-2017-q4-major-win32/bin/../lib/gcc/arm-none-eabi/7.2.1/thumb/v6-m/crti.o
00009190 g     F .text	0000000c set_is_pdu
000013a8 g     F .text	00000030 .hidden ___Unwind_ForcedUnwind
00000b7c g     F .text	00000054 .hidden __gnu_Unwind_RaiseException
00015d98 g     F .text	00000020 uart_get_software_tx_flow_control_assert_function
00016fb4 g     F .text	0000002a uart_common_disable_uart
0001ec24 g     F .text	0000002c link_terminated
00013d4c g     F .text	0000001c osPriqueueEnqueue
0001c76c g     F .text	00000018 get_extended_error_cause
00005d54 g     F .text	00000052 command_close_logical_channel
00012cc8 g     F .text	00000084 osSlabMemFree
000184ec g     F .text	000000a0 rtc_init
00022548 g     F .text	0000000c pbuf_realloc
010014f8 g     O .bss	00000004 log_uart_early_stop_timer
00007864 g     F .text	0000000c neul_update_register_package_process_cnf_callback
00019bce g     F .text	0000000e hal_uart_is_busy
010019a4 g     O .bss	00000001 wait_for_sms_data
000191b4 g     F .text	0000020c hal_dma_transfer
000046a0 g     F .text	00000052 command_radio_config_tx_tone
01002ef8 g     O .bss	00000018 input_data_array
0001bb18 g     F .text	0000000c set_time_zone_reporting
00018fc8 g     F .text	00000010 hal_dma_ch_state_get
0001ce2c g     F .text	00000040 get_imeisv
0001b7fc g     F .text	00000018 remote_command_driver_adc_action_response
00004f26 g     F .text	00000072 command_set_edrxs_and_ptw
000146a4 g     F .text	00000030 osKernelInitialize
0001359c g     F .text	00000070 LOS_TaskYield
0001952c g     F .text	00000020 hal_dma_ch_is_enabled
0000702c g     F .text	0000001c set_update_method
0001b7dc g     F .text	00000020 remote_command_driver_adc_read_response
0000892c g     F .text	00000030 app_at_send_sms_callback_response
00007870 g     F .text	0000000c neul_update_register_package_get_package_name_cnf_callback
000218b4 g     F .text	00000184 spi_claim
010019a1 g     O .bss	00000001 is_ESC
0001d694 g     F .text	0000005a neul_string_convert_str_to_BCD
00013a30 g     F .text	00000004 osTaskExit
0001bca4 g     F .text	00000038 production_execute_radiotest
00013694 g     F .text	0000002c LOS_TaskUnlock
00013978 g     F .text	0000001c osSlabAllocatorAlloc
0001b184 g     F .text	0000000e __exit
00012ff0 g     F .text	00000034 osTimerListDelete
00018dac g     F .text	00000038 hal_cpu_init
00019144 g     F .text	00000058 hal_dma_ch_config_buffer_remove_config
00019694 g     F .text	0000001c hal_lpc_set_sleep_on_exit
0000a788 g     F .text	000000a4 at_get_string_param
00017c0c g     F .text	00000026 log_memory_section_get
00019cc0 g     F .text	0000000a IRQ_UART2_Handler
00019f14 g     F .text	00000010 hal_lpuart_get_fifo_level
00004eae g     F .text	00000078 command_get_power_saving_mode
0000605a g     F .text	00000054 command_delete_tft_req
0001bab0 g     F .text	00000036 neul_log_set_log_level
00006ffc g     F .text	00000030 ota_get_package_info_req
00019b38 g     F .text	00000088 hal_uart_set_enable_uart
0002234c g     F .text	00000002 memp_init_pool
0001a8ae g     F .text	00000026 vsprintf
01002f1c g     O .bss	00000008 g_stUnusedSemList
0001a09c g     F .text	00000054 hal_uart_specific_enable_clock
00025894 g     O .text	0000000c protocols
0000507c g     F .text	0000005c command_get_extended_error_cause
00009d68 g     F .text	0000001c at_uart_mark_ensure_change_config
00007ff0 g     F .text	0000002a close_socket
0002570c g     O .text	00000014 ip_addr_any
00022abc g     O .text	00000094 protocol_incomming_command_table
00014ad4 g     F .text	00000028 osSemaphoreRelease
00000000 g     O startup	000000a0 isr_vector_table
00006af0 g     F .text	00000010 log_uart_trigger
00018d5c g     F .text	00000050 HardFault_Handler
0001a034 g     F .text	0000002c hal_uart_specific_get_uart
00009014 g     F .text	0000000c at_get_non_ip_data_report_mode
00003f10 g     F .text	00000054 command_close_socket
0001cd3e g     F .text	00000008 prepare_for_powerdown
0001c1b0 g     F .text	00000026 get_bands
00007d84 g     F .text	00000034 connect
0001bc8c g     F .text	00000018 remote_command_non_ip_data_sent
00003d0e g     F .text	0000004e command_query_ue_stats
0001715c g     F .text	000000a8 gpio_claim
00018934 g     F .text	00000008 hal_gpio_clear_interrupt
000216d8 g     F .text	00000012 LOS_Start
00013510 g     F .text	0000004c osTaskWait
00013b28 g     F .text	0000002c los_lpt_set_delay_ms
000147e8 g     F .text	00000068 osThreadNew
0000895c g     F .text	00000284 at_init
00012d4c g     F .text	00000094 osSlabStatisticsGet
0000aa08 g     F .text	00000050 at_check_num_sc_for_sc_index
00017444 g     F .text	000000cc ipc_send_message
00006178 g     F .text	0000005c command_get_pin_state
00017b30 g     F .text	000000dc log_buffer_reader_discard
000216ec g     F .text	00000048 osMain
00007170 g     F .text	00000060 ota_package_download
00022554 g     F .text	0000001e pbuf_free
0000793c g     F .text	00000028 network_config_init
00013b98 g     F .text	00000030 TaskStepTick
000036d6 g     F .text	00000060 command_execute_radiotest
000032a0 g     F .text	0000004a command_get_security_log_level
00015d78 g     F .text	00000020 uart_get_software_rx_flow_control_assert_function
000141d0 g     F .text	00000028 SysTick_Handler
0001dd3c g     F .text	00000020 ppp_init
000225c8 g     F .text	00000060 pbuf_cat
000092bc g     F .text	0000009e get_ip_addr
00019040 g     F .text	00000084 hal_dma_ch_config_buffer_get_free_config
00011c28 g     F .text	0000019c at_ota_exec_cmd
00013718 g     F .text	000000c4 osHeapAlloc
00012a4c g     F .text	00000026 irmalloc_get_machine_readable_stats
000095d6 g     F .text	0000000e app_at_send_at_rsp_string_lines
00001b0c  w    F .text	00000002 IRQ_PWM1IN_Handler
00006504 g     F .text	00000034 internal_incomming_response_default_blocking_response
0000775c g     F .text	00000054 io_bank_init
0001b30a g     F .text	00000032 memmove
00006788 g     F .text	00000058 log_event_string
00003a76 g     F .text	00000054 command_delete_pdp_context
0001bf7c g     F .text	00000024 production_radio_config_get_gpio
00015eb8 g     F .text	00000070 uart_register_parity_error_callback
00001b0c  w    F .text	00000002 IRQ_SWD_COMMS_Handler
00005ce8 g     F .text	0000006c command_open_logical_channel
000012f4 g     F .text	00000000 .hidden __gnu_Unwind_Save_VFP
00001378 g     F .text	00000030 .hidden _Unwind_Resume_or_Rethrow
000091a8 g     F .text	0000000c get_is_pdu
000194ec g     F .text	00000030 hal_dma_clear_interrupt
0000017c g     F .text	00000002 PendSV_Handler
0001a86c g     F .text	00000018 snprintf
00012bf0 g     F .text	00000040 osSlabMemInit
00018d0c g     F .text	00000050 NMI_Handler
00000148 g       *ABS*	00000000 __data_size__
00026230 g       .ARM.exidx	00000000 __exidx_end
0000412a g     F .text	0000006c command_socket_connect
00012a00 g     F .text	00000014 irmalloc
000065d0 g     F .text	0000001c log_init
000141f8 g     F .text	00000010 osTimesliceInit
0001a060 g     F .text	0000003c hal_uart_specific_reset_uart
0001e498 g     F .text	00000058 pppos_create
000084a4 g     F .text	0000000c get_at_cmd_in_progress
0001de04 g     F .text	00000016 ppp_start
0000585c g     F .text	0000005c command_get_initial_pdp_context
0001c9b0 g     F .text	00000014 remote_command_pdp_modify_result
0000103c g     F .text	0000000a .hidden __aeabi_unwind_cpp_pr0
000060ae g     F .text	00000060 command_set_tft_req
00018b9c g     F .text	0000000c hal_lpuart_specific_release
00014154 g     F .text	00000060 LOS_SwtmrDelete
01000448 g     F .ramtext	0000001c system_status_signal_enter_wfi
0001d024 g     F .text	000000ce getdnsaddr
0002117c g     F .text	00000078 LOS_MuxDelete
00003e96 g     F .text	0000007a command_allocate_socket
00019d3c g     F .text	00000010 hal_lpuart_disable_interrupts
01002e4c g     O .bss	00000004 g_uwIdleTaskID
01002e40 g     O .bss	00000004 m_aucSysMem0
00020d20 g     F .text	0000004c fsm_protreject
00009524 g     F .text	00000024 get_ceer_register_reject_cause
00020d6c g     F .text	00000344 fsm_input
0001285c g     F .text	00000040 open_logical_channel
00001cc4 g     F .text	00000094 rpc_init
00001774 g     F .text	0000000a .hidden _Unwind_GetRegionStart
000141b4 g     F .text	0000001a LOS_Tick2MS
000078a8 g     F .text	00000014 remote_command_update_package_parse_cnf
00011a1c g     F .text	00000054 at_non_ip_sent_callback
00001378 g     F .text	00000030 .hidden ___Unwind_Resume_or_Rethrow
0001cc62 g     F .text	0000002c read_short_message_service_address
000047ea g     F .text	00000062 command_radio_config_set_rio_v
0001951c g     F .text	00000010 hal_dma_ch_select_primary
00016cb8 g     F .text	00000054 dma_transfer_peripheral_bytes
00013fe4 g     F .text	00000040 osSwtmrStop
0001c810 g     F .text	00000038 get_apn_rate_control_context
00006372 g     F .text	00000070 command_get_socket_status
0001d6ee g     F .text	00000028 neul_string_convert_uint8_array_to_uint32
00009600 g     F .text	00000050 app_at_send_at_rsp_string_rn_no_claim
00017c34 g     F .text	0000000c log_memory_section_get_control
00015f98 g     F .text	000000a0 uart_unregister_rx_callback
00007e88 g     F .text	00000098 send_with_indication
0000a112 g     F .text	00000028 at_get_cmd_length
0001a844 g     F .text	0000001c eflash_get_32kblock_id
0001c4c0 g     F .text	00000014 remote_command_registration_status_ind
00014bf4 g     F .text	00000010 osUartVetoCallbackRegister
00003d5c g     F .text	00000054 command_set_ue_cfun
00012a38 g     F .text	00000014 irfree
00018fac g     F .text	0000000c hal_dma_ch_register_peripheral_prepare_callback
00018254 g     F .text	0000001a pio_init
0000a50c g     F .text	00000100 at_get_uint16_param
00006b18 g     F .text	00000150 log_uart_nxlog_ctrl
000050d8 g     F .text	0000009c command_get_edrxrdp
000013d8 g     F .text	00000030 .hidden _Unwind_Backtrace
0001c914 g     F .text	0000000c neul_radio_register_abort_handler
000055ca g     F .text	00000054 command_register_kvcache
00022ab8 g     O .text	00000004 application_incomming_command_table
0001a860 g     F .text	0000000c eflash_is_available
000186dc g     F .text	00000074 get_current_time_ms
01002f24 g     O .bss	00000004 g_pstAllSem
000095c8 g     F .text	0000000e app_at_send_at_rsp_string
00014b98 g     F .text	0000005c osMessageQueueGet
00016ea4 g     F .text	00000018 uart_common_is_claimed
01000400 g       .stacks	00000000 __SYSTEM_STACK_END__
0001bd4a g     F .text	00000024 production_radio_config_read_mipi_word
000039d8 g     F .text	0000009e command_set_pdp_context
0001d2a4 g     F .text	0000012c ip4addr_aton
00004c54 g     F .text	0000006c command_sms_send_short_message
00019fb4 g     F .text	0000002c hal_lpuart_init
00013a3c g     F .text	0000003c LOS_Schedule
000190c4 g     F .text	00000044 hal_dma_ch_config_buffer_get_first_used
00016038 g     F .text	000002f8 uart_write
00001b0c  w    F .text	00000002 IRQ_PWM0OUT_Handler
00006fd0 g     F .text	00000012 ota_package_upgrade_req
010004a4 g     F .ramtext	0000000c hal_lpc_enter_wfi
000012c4 g     F .text	0000002a .hidden __restore_core_regs
00001304 g     F .text	00000000 .hidden __gnu_Unwind_Save_VFP_D_16_to_31
0001bd8a g     F .text	0000001c production_radio_config_tx_tone
0001c298 g     F .text	0000003e get_pending_data_seqs
01000400 g       .ramtext	00000000 __ramtext_begin__
0001c38a g     F .text	00000050 set_pdp_context_auth_param
0001de84 g     F .text	000000d4 ppp_input
0001c96e g     F .text	00000018 get_pdp_context_dynamic_param_request_state
0001a7fc g     F .text	00000048 eflash_32kblock_erase
00019bec g     F .text	00000038 hal_uart_force_tx_isr
0001d718 g     F .text	00000094 activity_indication_init
0001bfd2 g     F .text	0000001a set_plmn_search_range
0001c41e g     F .text	00000014 set_nconfig
0001baa8 g     F .text	00000008 free_dieid
00006a30 g     F .text	0000001c log_uart_update_watermark_level
00022216 g     F .text	0000000a IRQ_SSP1_Handler
00009154 g     F .text	0000000c set_at_sms_msg_type
00012e48 g     F .text	00000048 osTskSortLinkTicksGet
00000b78 g     F .text	00000004 .hidden _Unwind_GetCFA
000001f0 g     F .text	00000000 memcpy
0001c2f8 g     F .text	00000050 activate_pdp_context
00014878 g     F .text	00000050 osTimerNew
00009368 g     F .text	0000000c set_cmee_error_type
00008104 g     F .text	00000110 iflog_write
00018b00 g     F .text	00000014 hal_pio_clear_interrupt
00008db0 g     F .text	000000f4 get_cgpaddr_cid
000068ac g     F .text	00000008 flog_log_write
00014908 g     F .text	00000038 osTimerStop
01002cd4 g     O .bss	00000004 input_data_first
0000a3e0 g     F .text	0000003c at_check_hex_string_prefix
000193c0 g     F .text	0000002c hal_dma_ch_scatter_gather_alternate_config_buffer_alloc
000048a2 g     F .text	0000005c command_radio_config_get_gpio
0001ec9c g     F .text	0000001a link_down
00009940 g     F .text	0000000c at_uart_get_status
00000ca4 g     F .text	00000030 .hidden _Unwind_VRS_Set
01002ea0 g     O .bss	00000004 m_pstSwtmrFreeList
0000a2e4 g     F .text	000000fc at_create_param_array
0001c9c4 g     F .text	00000028 remote_command_ciot_opt_status_ind
00019854 g     F .text	00000034 hal_uart_release
00012de0 g     F .text	00000054 osSlabGetMaxBlkSize
00019ce0 g     F .text	0000000c IRQ_APPS0_Handler
000080bc g     F .text	0000003c iflog_init
0001ca8c g     F .text	00000018 delete_tft_req
00014a7c g     F .text	00000058 osSemaphoreAcquire
0001e038 g     F .text	0000001c cifaddr
00018f48 g     F .text	0000002c hal_dma_is_claimed
00009990 g     F .text	0000000c at_uart_set_frame_error_status
00012e90 g     F .text	00000044 osIdleTask
000006a4 g     F .text	0000003e .hidden __aeabi_uldivmod
00012ae4 g     F .text	0000002c LOS_MemAlloc
0001c894 g     F .text	00000018 set_initial_pdp_context
00022878 g     F .text	000000c4 sys_timeout
000065be g     F .text	00000012 rpc_get_int8
00004484 g     F .text	00000066 command_update_package_flash_write
0001c670 g     F .text	00000030 remote_command_pdp_act_or_deact_result_ind
00019bc0 g     F .text	0000000e hal_uart_is_tx_fifo_full
0000a9e0 g     F .text	00000026 at_parse_calculate_crc8
01002e50 g     O .bss	00000004 g_uwSwtmrTaskID
00018284 g     F .text	00000008 pio_set_function
00012f70 g     F .text	00000080 osTaskAdd2TimerList
0001c098 g     F .text	00000014 remote_command_attach_status_set_result_ind
000207d0 g     F .text	0000002c lcp_lowerdown
00005174 g     F .text	00000072 command_get_firmware_version
000030ec g     F .text	0000005e command_get_dieid
000215c4 g     F .text	000000ac LOS_SemPost
01002ed8 g     O .bss	00000020 current_time_info
00005b54 g     F .text	00000028 command_rai_req
00005c94 g     F .text	00000054 command_calibrate_temperature
0001d508 g     F .text	00000010 ip6addr_ntoa
0001bebc g     F .text	00000064 production_radio_config_rx_calist
000003b8 g     F .text	0000010a .hidden __udivsi3
0000524e g     F .text	0000005a command_get_rfconfig_version
000078bc g     F .text	00000014 remote_command_update_package_process_cnf
0001c160 g     F .text	0000003a get_registration_status
00013b1c g     F .text	0000000c los_rtc_callback
000097b8 g     F .text	00000020 at_uart_mark_can_receive
000052f2 g     F .text	00000060 command_get_chipinfo
000129c4 g     F .text	00000038 get_backtrace
0001bb96 g     F .text	0000003e set_system_time_from_apps
000223fc g     F .text	00000088 netif_add
00007820 g     F .text	0000000e neul_update_package_flash_write
0001a884 g     F .text	0000002a vsnprintf
0000762c g     F .text	00000002 remote_command_kv_apps_cache_flushed
00005e22 g     F .text	00000054 command_pdp_modify_req
000145ea g     F .text	0000001e osAtomicBitsetGetBit
00017400 g     F .text	00000044 ipc_register_handler
000147dc g     F .text	00000008 osKernelGetTick2ms
00007f20 g     F .text	000000d0 recvfrom
00019f64 g     F .text	00000034 hal_lpuart_assign_rts_pin
00001b0c  w    F .text	00000002 IRQ_CAP_Handler
0000919c g     F .text	0000000c clear_is_pdu
000077b0 g     F .text	0000000e neul_update_get_update_status
00006834 g     F .text	00000024 log_get_local_log_level
00017ff8 g     F .text	00000028 lp_uart_flush_data
00001b0c  w    F .text	00000002 IRQ_PWM0IN_Handler
000213b8 g     F .text	00000058 osSemInit
00013968 g     F .text	00000010 osSlabAllocatorDestroy
00000cec g     F .text	00000070 .hidden __gnu_Unwind_Backtrace
00005f42 g     F .text	00000064 command_set_qos_req
00007aa4 g     F .text	0000001c get_sock_type
0001b1d8 g     F .text	000000d0 strtoul
000193ec g     F .text	00000048 hal_dma_enable_interrupt
0001d012 g     F .text	00000012 freednsaddrs
0001e054 g     F .text	00000028 sifup
00020a24 g     F .text	00000010 fsm_init
00012f40 g     F .text	00000030 osTaskPriModify
00019678 g     F .text	0000001c hal_lpc_set_sleep_mode
01002ec0 g     O .bss	00000008 g_stTaskTimeSlice
01002e3a g     O .bss	00000002 sms_len
00001cbc g     F .text	00000008 rpc_main
00000738 g     F .text	00000182 .hidden __udivmoddi4
00005c42 g     F .text	00000052 command_get_pdp_context_dynamic_param_request_state
00009d28 g     F .text	00000028 at_uart_mark_need_change_to_ppp
00019cd4 g     F .text	0000000c IRQ_PROTOCOL0_Handler
00001b0c  w    F .text	00000002 IRQ_I2C0_Handler
000221f4 g     F .text	00000018 hal_ssp_disable_interrupt
01002eb0 g     O .bss	00000008 g_ullTickCount
0001983c g     F .text	00000018 hal_uart_is_claimed
000119d8 g     F .text	00000044 psm_status_callback
000012fc g     F .text	00000000 .hidden __gnu_Unwind_Save_VFP_D
00007cc4 g     F .text	0000007c socket
000022e8 g     F .text	00000018 rpc_thread_main
00000174 g     F .text	00000000 osTaskSchedule
01002e54 g     O .bss	00000008 g_stTskRecyleList
000128b6 g     F .text	00000056 generic_uicc_logical_channel_access
00013a78 g     F .text	000000a4 osTskStackInit
00003fd0 g     F .text	0000008c command_sendto
00021fd8 g     F .text	00000038 hal_ssp_set_spi_mode
00016330 g     F .text	00000058 uart_write_immediately_char
00001b0c  w    F .text	00000002 IRQ_TMR0_Handler
0001c658 g     F .text	00000018 deactivate_pdp_req
00019918 g     F .text	00000038 hal_uart_set_baud_rate
00019fe0 g     F .text	00000020 hal_lpuart_get_word
00015478 g     F .text	00000044 uart_is_need_awake
000078e8 g     F .text	00000018 remote_command_update_package_get_package_version_cnf
0000cf40 g       .heap	00000000 __INTHEAP_SIZE__
01002a14 g     O .bss	00000004 exception_stack_frame_ptr
000173f0 g     F .text	00000010 ipc_deinit
01002ec8 g     O .bss	00000008 g_stFreeQueueList
000003a4 g     F .text	00000012 .hidden __gnu_thumb1_case_uqi
0001cc4a g     F .text	00000018 get_cnma_acknowledgement_expected
00001060 g     F .text	00000264 .hidden _Unwind_VRS_Pop
0000a82c g     F .text	0000008c at_get_hexstring_param
0000ac64 g     F .text	00000058 delayed_async_output_list
00001054  w    F .text	0000000a .hidden __aeabi_unwind_cpp_pr2
0001cd7a g     F .text	00000042 get_cell_info
01002e5c g     O .bss	00000008 g_stTskSortLink
00013d68 g     F .text	00000014 osPriqueueDequeue
000148c8 g     F .text	00000040 osTimerStart
0000575e g     F .text	00000062 command_get_power_band_class
00022794 g     F .text	0000000c neul_lwip_serial_enable_software_flow_control
00014850 g     F .text	0000001a osThreadYield
000076a4 g     F .text	00000014 neul_kv_cache_register
0001b82c g     F .text	00000018 flash_log_write
000013d8 g     F .text	00000030 .hidden ___Unwind_Backtrace
000095f2 g     F .text	0000000e app_at_send_at_rsp_string_lines_with_claim_and_log_restricted
00003cac g     F .text	00000062 command_get_nconfig
0001bd18 g     F .text	00000032 production_radio_config_meas_rssi
000048fe g     F .text	00000028 command_prepare_for_powerdown
01000598 g     O .data	00000030 slab_mem
01002e10 g     O .bss	00000024 rpc_mailboxes
0000398c g     F .text	0000004c command_get_connection_status
0001a000 g     F .text	00000010 hal_lpuart_get_parity_errors
0001bb24 g     F .text	00000068 remote_command_current_time_ind
00022788 g     F .text	0000000c neul_lwip_serial_set_baud
0001c0fc g     F .text	00000064 get_csq
00019bdc g     F .text	0000000e hal_uart_is_rx_fifo_empty
0001355c g     F .text	0000003e osTaskWake
0001bf40 g     F .text	0000003c production_radio_config_rx_verify
0000314a g     F .text	00000052 command_set_protocol_log_level
000043e0 g     F .text	0000005a command_firmware_upgrade_req
000035b6 g     F .text	00000060 command_set_band
00007c38 g     F .text	0000008c remote_command_socket_notify
000095e4 g     F .text	0000000e app_at_send_at_rsp_string_lines_with_claim_and_log
000068be g     F .text	00000008 flog_get_available_size
0001cc90 g     F .text	0000000c set_sms_pdu_callback
00026168 g       .ARM.exidx	00000000 __exidx_start
0001954c g     F .text	00000024 hal_dma_ch_is_closed
000068a4 g     F .text	00000008 flog_set_write_enable
0000aa58 g     F .text	000001c8 at_get_tm_param
0001dd5c g     F .text	000000a8 ppp_new
0001486a g     F .text	0000000e osDelay
0001367c g     F .text	00000018 LOS_TaskLock
0001d518 g     F .text	0000010e ip6addr_aton
0001e4f0 g     F .text	00000200 pppos_input
000006e4 g     F .text	00000054 .hidden __aeabi_lmul
0001ebc0 g     F .text	00000018 ppp_warn
0000ad70 g     F .text	00000020 app_at_async_notify_init
00021eb4 g     F .text	00000054 hal_ssp_claim
0001bc58 g     F .text	00000026 nonip_sendto
0001c2d6 g     F .text	00000022 delete_pdp_context
00021490 g     F .text	0000004c LOS_BinarySemCreate
00018020 g     F .text	00000068 lp_uart_get_data
00006894 g     F .text	00000008 log_trigger
00006468 g     F .text	0000009a command_radio_config_rx_calist
0001c0d8 g     F .text	00000014 remote_command_pin_status_ind
0001c5e0 g     F .text	0000000c neul_radio_register_pin_handler
00021310 g     F .text	000000a8 LOS_MuxPost
00021c78 g     F .text	0000023c spi_recv_data
00001318 g     F .text	00000030 .hidden ___Unwind_RaiseException
000067e0 g     F .text	00000054 log_set_local_log_level
00007e4a g     F .text	0000003e send
00022774 g     F .text	00000014 neul_lwip_serial_set_pins
00007630 g     F .text	00000074 neul_kv_init
000142a8 g     F .text	000000c4 LOS_QueueCreate
0001ca18 g     F .text	0000002a get_ciot_opt
00022264 g     F .text	00000010 abort
00001348 g     F .text	00000030 .hidden ___Unwind_Resume
00020ab8 g     F .text	0000005a fsm_open
000172f4 g     F .text	000000d4 IRQ_GPIO_Handler
000146d4 g     F .text	0000003c osKernelGetState
000140a4 g     F .text	00000058 LOS_SwtmrStart
0001df58 g     F .text	0000000e ppp_write
00003254 g     F .text	0000004c command_get_protocol_log_level
0001c260 g     F .text	0000001e get_cfun
00016ebc g     F .text	00000034 uart_common_release
00013f88 g     F .text	00000020 osSwtmrScan
00021688 g     F .text	00000050 osTickStart
0000808c g     F .text	00000030 get_socket_status
00026160 g     F .init	00000000 _init
00003bc8 g     F .text	00000082 command_get_pdp_context_auth_param
0001893c g     F .text	00000008 hal_gpio_is_interrupt_asserted
0000784c g     F .text	0000000c neul_update_register_flash_erase_done_callback
00007540 g     F .text	00000068 neul_kv_set_with_attributes
00006960 g     F .text	000000d0 log_uart_init
0001b198 g     F .text	00000040 strtol
0001c92c g     F .text	0000001c remote_command_ip_info
00019a1c g     F .text	00000040 hal_uart_disable_interrupt
010003fc g     O .stacks	00000400 stack_system
00016530 g     F .text	00000008 aio_manager_get_deferred_mux_select_config
000099ec g     F .text	00000070 at_uart_write
00002254 g     F .text	00000038 rpc_interface_init
00005668 g     F .text	00000094 command_get_apn_rate_control_context
00013994 g     F .text	0000003c osSlabAllocatorFree
00002528  w    F .text	0000000c remote_command_app_flash_erase_response
00016ef0 g     F .text	0000004c uart_common_configure_rx_interrupts
0001ba58 g     F .text	00000050 get_dieid
00003b46 g     F .text	00000082 command_set_pdp_context_auth_param
0001c7fc g     F .text	00000014 remote_command_cring_ind
00001308 g     F .text	00000000 .hidden __gnu_Unwind_Restore_WMMXD
0001daf4 g     F .text	00000048 ppp_set_serial_config
00017a14 g     F .text	0000011c log_buffer_reader_claim_next
00014626 g     F .text	00000040 osAtomicBitsetFindClearAndSet
0001b7d0 g     F .text	0000000c preserve_valid
000176d4 g     F .text	0000013c log_buffer_message
000032ea g     F .text	00000072 command_kv_get
0001be38 g     F .text	00000042 production_radio_config_tx_verify
00006630 g     F .text	0000000c log_get_verbosity
00005da6 g     F .text	0000007c command_generic_uicc_logical_channel_access
0000319c g     F .text	00000064 command_set_vdd_io_level
0001c1d6 g     F .text	00000034 get_support_bands
000084b0 g     F .text	0000000c get_at_processing_cmd_abortable
0000a2a4 g     F .text	00000014 at_parse_convert_sms_result
0001289c g     F .text	0000001a close_logical_channel
00005980 g     F .text	00000062 command_iflog_iflash_write
00004cc0 g     F .text	0000006c command_sms_send_command
0001eb68 g     F .text	00000016 ppp_slprintf
0001b844 g     F .text	0000001a flash_log_read
0001a160 g     F .text	0000001c hal_uart_specific_enable_irq
0001860c g     F .text	0000004c rtc_set_current_time
0001ed80 g     F .text	00000020 np_finished
0000443a g     F .text	0000004a command_update_package_flash_erase
00025124 g     O .text	00000038 ue_stats_labels
00001a34  w    F .text	0000009c Reset_Handler
0001de38 g     F .text	0000004c ppp_singlebuf
00026260 g       *ABS*	00000000 __ramtext_load__
00016538 g     F .text	00000024 temp_mon_set_coefficient
00019d5c g     F .text	00000008 hal_lpuart_deinit
00014208 g     F .text	0000003c osTimesliceCheck
0001e6f0 g     F .text	00000478 ppp_vslprintf
00016388 g     F .text	00000070 uart_flush_data
00007048 g     F .text	00000030 ota_init
00006fe4 g     F .text	00000018 ota_package_parse_req
00025fb0 g     O .text	00000020 lcp_protent
0001b77c g     F .text	00000054 preserve_init
0001e07c g     F .text	00000016 sifdown
0001a028 g     F .text	0000000c hal_lpuart_set_callback
00019ad8 g     F .text	0000003e hal_uart_clear_interrupt
00008504 g     F .text	00000428 at_main
0000015e g     F .text	00000000 LOS_IntLock
00018a84 g     F .text	0000004c hal_pio_set_gpio_output
00020a60 g     F .text	00000058 fsm_lowerdown
0001b9e4 g     F .text	00000024 get_rfconfig_version
00004302 g     F .text	0000004a command_update_package_parse_req
00009020 g     F .text	00000134 at_process_sms_data
0001c7ce g     F .text	0000002e get_mtu_size
000178a8 g     F .text	0000009c log_buffer_reader_init
0001bbe2 g     F .text	0000000e get_time_update_mode
0000a0a4 g     F .text	00000044 at_uart_baud_rate_valid_check
0001b744 g     F .text	0000002c set_exception_stack_frame
00013ecc g     F .text	0000005c osSwTmrStart
00017658 g     F .text	00000054 log_buffer_init
00014afc g     F .text	00000044 osMessageQueueNew
000176ac g     F .text	00000026 log_buffer_get_available_for_next_message
00022662 g     F .text	00000010 free_buffer_from_pbuf
000140fc g     F .text	00000058 LOS_SwtmrStop
00006538 g     F .text	00000010 rpc_get_buffer
000000d0 g       *ABS*	00000000 __ramtext_size__
0001d130 g     F .text	00000020 remote_command_ip_address_changed
00007a6c g     F .text	00000038 socket_init
01002e64 g     O .bss	00000004 g_pstTaskCBArray
01002f30 g     O .preserve	0000002c backtrace
000189d4 g     F .text	0000002c hal_pio_config_drive
00006a4c g     F .text	000000a4 log_uart_init_after_rtos
01002e34 g     O .bss	00000006 rpc_auto_generated_handles
0001bda6 g     F .text	00000020 production_radio_config_set_tx_gains
0000a290 g     F .text	00000014 at_parse_convert_neul_result
000188fe g     F .text	0000000a hal_gpio_clear
00019c30 g     F .text	0000007c hal_uart_isr
0001c956 g     F .text	00000018 set_pdp_context_dynamic_param_request_state
00025c84 g     O .text	00000020 ipcp_protent
00015d24 g     F .text	00000054 uart_set_software_flow_control_water_margin
00003c4a g     F .text	00000062 command_set_nconfig
00013b80 g     F .text	00000018 los_lpt_disable
000051e6 g     F .text	00000068 command_get_ssb_version
000038f0 g     F .text	0000009c command_get_registration_status
00004ace g     F .text	00000052 command_sms_set_more_message_to_send
000070bc g     F .text	00000038 ota_iflash_write
0002207c g     F .text	00000024 hal_ssp_enable
0001c224 g     F .text	00000028 set_cfun
000023f8 g     F .text	00000006 remote_command_get_apps_rpc_version
00008ce4 g     F .text	0000000c set_sms_len
00007888 g     F .text	0000000c neul_update_register_flash_write_done_callback
00022258 g     F .text	0000000c hal_ssp_get_base
00017fe4 g     F .text	00000014 lp_uart_disable_software_flow_control
000012f0 g     F .text	00000000 .hidden __gnu_Unwind_Restore_VFP
0002230c g     F .text	00000040 lwip_support_log
00019cec g     F .text	0000003c hal_ipc_init_interrupts
0001d1d0 g     F .text	00000034 ipaddr_aton
0001d3d0 g     F .text	00000138 ip6addr_ntoa_r
000185f0 g     F .text	0000000c rtc_get_time
0001c630 g     F .text	00000028 activate_pdp_req
00014b40 g     F .text	00000058 osMessageQueuePut
00020b12 g     F .text	00000086 fsm_sdata
0001dff2 g     F .text	00000016 ppp_send_config
01002e68 g     O .bss	00000004 g_uwTskMaxNum
01002e44 g     O .bss	00000004 slab_mem_count
0000196c g     F .text	00000050 app_os_init
000004cc g     F .text	00000000 .hidden __aeabi_idiv
0001df66 g     F .text	0000000c ppp_link_terminated
000173c8 g     F .text	00000028 ipc_init
000220d4 g     F .text	00000010 hal_ssp_read_data
0001cd46 g     F .text	00000034 get_ue_stats
00009d50 g     F .text	00000018 at_uart_mark_need_change_to_at
0001c0ec g     F .text	0000000e get_service_state
00004766 g     F .text	00000084 command_radio_config_get_tx_gains
01002f28 g     O .bss	00000004 g_stUserErrFunc
000224e0 g     F .text	00000068 pbuf_alloc
0001a128 g     F .text	00000038 hal_uart_specific_disable_clock
00003e48 g     F .text	0000004e command_get_defined_cids
00022486 g     F .text	00000002 netif_set_link_up
00001348 g     F .text	00000030 .hidden _Unwind_Resume
0000a22a g     F .text	00000066 at_parse_buf_hex_to_uint64
0001cac4 g     F .text	00000038 get_tft_context
00005fa6 g     F .text	00000060 command_get_qos
0001df74 g     F .text	00000078 ppp_close
00017204 g     F .text	00000050 gpio_release
01002e6c g     O .bss	00000002 g_usLosTaskLock
0001ca72 g     F .text	0000001a get_qos
00022134 g     F .text	00000030 hal_ssp_interrupt_is_set
01002e70 g     O .bss	00000008 g_stLosTask
00000c4c g     F .text	00000010 .hidden _Unwind_DeleteException
01000618 g       .data	00000000 __data_end__
00000c48 g     F .text	00000002 .hidden _Unwind_Complete
00014244 g     F .text	00000064 osQueueInit
000181dc g     F .text	00000028 non_os_exit_critical
01002f10 g     O .bss	00000004 g_pstAllMux
00011b28 g     F .text	00000014 at_trigger_filter_send
0001cb96 g     F .text	0000001a read_more_message_to_send
010005d4 g     O .data	00000004 hal_sectors_ram_heap_start
0001d628 g     F .text	0000006c neul_string_convert_BCD_to_str
0001c19a g     F .text	00000016 set_bands
00014940 g     F .text	00000038 osTimerDelete
0000999c g     F .text	0000000c at_uart_set_received_at_notify_callback
00014710 g     F .text	00000030 osKernelStart
00008d08 g     F .text	000000a8 plmn_select
0001c500 g     F .text	00000038 set_edrxs
00019904 g     F .text	0000000a hal_uart_get_error_register
00009220 g     F .text	0000008c app_at_min_ip_mtu_from_active_cids
000017a4 g     F .text	0000003c .hidden __clzsi2
00019d64 g     F .text	00000050 hal_lpuart_set_interrupts
00008f74 g     F .text	00000054 at_pre_process_sms_data
00006f3c g     F .text	00000010 log_uart_enable
000156d4 g     F .text	00000060 uart_init
0001b85e g     F .text	0000002c set_imei
0000acbc g     F .text	000000b4 delayed_async_print
0000663c g     F .text	0000014c log_event
0001b2a8 g     F .text	00000024 memchr
01002f14 g     O .bss	00000008 g_stUnusedMuxList
00025720 g     O .text	00000014 ip_addr_broadcast
00005af2 g     F .text	00000062 command_set_network_config
00018ad0 g     F .text	00000030 hal_pio_is_interrupt_asserted
01002f2c g       .bss	00000000 __bss_end__
000052a8 g     F .text	0000004a command_get_temp_coefficient
00001b0c  w    F .text	00000002 IRQ_PWM1OUT_Handler
00025aa0 g     O .text	00000002 memp_PPPOS_PCB
0000180c g     F .text	00000014 .hidden __gnu_thumb1_case_shi
00014978 g     F .text	0000002c osMutexNew
000180f8 g     F .text	0000006c lp_uart_disable_irq
00007808 g     F .text	00000018 neul_update_package_get_package_version_req
0001a0f0 g     F .text	00000038 hal_uart_specific_is_clock_enabled
00018974 g     F .text	00000040 hal_pio_set_function
00007858 g     F .text	0000000c neul_update_register_package_parse_cnf_callback
0001bfec g     F .text	00000018 clear_stored_earfcn
00018218 g     F .text	0000002c non_os_set_driver_initalised
00001b0c  w    F .text	00000002 IRQ_I2C1_Handler
00009a80 g     F .text	00000208 at_uart_recv_process
000196e0 g     F .text	00000034 hal_rtc_set_irq_time
00019cca g     F .text	00000008 IRQ_SECURITY0_Handler
000182ac g     F .text	00000026 reboot_system
0001b68c g     F .text	0000007c mktime
000250f8 g     O .text	0000002c ue_stats_bler_labels
0001de1a g     F .text	0000001e ppp_link_end
00018f74 g     F .text	00000038 hal_dma_ch_configure_peripheral_feature
00022484 g     F .text	00000002 netif_set_addr
00013d9c g     F .text	0000001c osPriqueueSize
000147b4 g     F .text	00000028 osKernelGetTickCount
00022298 g     F .text	00000040 strstr
000139d0 g     F .text	00000010 osSlabAllocatorEmpty
000077be g     F .text	0000001a neul_update_firmware_upgrade_req
00022274 g     F .text	00000024 rand
000198fc g     F .text	00000008 hal_uart_get_data_register
0001a198 g     F .text	0000001c hal_uart_specific_set_pending_irq
0001877c g     F .text	0000002c system_status_init
0001ebd8 g     F .text	00000018 ppp_notice
01000464 g     F .ramtext	00000040 system_status_signal_exit_wfi
000196b0 g     F .text	0000000c hal_lpc_get_status_register
0001c4ec g     F .text	00000014 remote_command_connection_status_ind
000223f0 g     F .text	0000000c netif_ip4_socket_recv_notify_register
00008048 g     F .text	00000020 sock_callback_set
00008fc8 g     F .text	00000020 at_set_crtdcp_mode
00001b0c  w    F .text	00000002 IRQ_SECURITY1_Handler
0001bd6e g     F .text	0000001c production_radio_config_write_mipi_word
0000145c g     F .text	000002f0 .hidden __gnu_unwind_execute
0001cb7e g     F .text	00000018 set_more_message_to_send
00012926 g     F .text	0000003a restricted_sim_access
00004d98 g     F .text	0000004c command_get_cnma_acknowledgement_expected
00007c24 g     F .text	00000014 remote_command_flowcontrol_status
0001c0c0 g     F .text	00000018 remote_command_pin_result_ind
000187a8 g     F .text	00000064 system_status_system_starting
000220a0 g     F .text	00000024 hal_ssp_disable
000185bc g     F .text	00000032 rtc_add_at
00019d4c g     F .text	00000010 hal_lpuart_enable_interrupts
0001cdbc g     F .text	0000003e get_imei
000057c0 g     F .text	0000004a command_get_update_status
0000592c g     F .text	00000054 command_iflog_cache_register
0000a088 g     F .text	0000001c at_uart_should_restart_at
0001b3b6 g     F .text	0000004e strncmp
00018194 g     F .text	00000020 lp_uart_unset_callback
0001c470 g     F .text	0000000c set_registration_status_callback
000012f8 g     F .text	00000000 .hidden __gnu_Unwind_Restore_VFP_D
0001d194 g     F .text	0000003c remote_command_ping_ind
0001bd00 g     F .text	00000018 production_radio_config_ctrl
000070f4 g     F .text	0000002c ota_iflash_erase
00012994 g     F .text	00000030 record_backtrace
00021f7c g     F .text	00000024 hal_ssp_get_data_size
0001c464 g     F .text	0000000c set_psm_status_reporting_callback
0001fe1c g     F .text	00000084 lcp_lowerup
00007b08 g     F .text	00000108 remote_command_recvfrom
000198e0 g     F .text	0000001c hal_uart_get_rx_fifo_level
0001b404 g     F .text	0000003c strncpy
000208e0 g     F .text	0000001e lcp_sprotrej
0001bc80 g     F .text	0000000c set_non_ip_sent_callback
00009c88 g     F .text	00000024 at_uart_read_current_config
00022044 g     F .text	00000038 hal_ssp_set_clock_prescale
00006296 g     F .text	0000006c command_restricted_sim_access
00007e2c g     F .text	0000001e sendto
0000580a g     F .text	00000052 command_set_initial_pdp_context
00016de0 g     F .text	000000c4 uart_common_claim
0001ec50 g     F .text	0000004c upper_layers_down
00018fd8 g     F .text	00000010 hal_dma_ch_state_set
00022120 g     F .text	00000014 hal_ssp_is_busy
00014778 g     F .text	0000003c osKernelUnlock
000099a8 g     F .text	00000024 at_uart_claim
00020914 g     F .text	00000008 magic_randomize
0001c4a0 g     F .text	0000001e get_power_saving_mode
00015c58 g     F .text	00000090 uart_close
0001ce6c g     F .text	0000003c get_serial_number
00009e00 g     F .text	000000c0 at_uart_init
00009984 g     F .text	0000000c at_uart_set_buffer_error_status
00022756 g     F .text	0000001e sio_write
0001436c g     F .text	000001a4 osQueueOperate
01002e48 g     O .bss	00000004 pSlabMemAllocator
00026330 g       *ABS*	00000000 __data_load__
0001980c g     F .text	00000030 hal_uart_claim
00000be4 g     F .text	00000046 .hidden __gnu_Unwind_Resume
00016b70 g     F .text	00000148 dma_ch_open
00013a34 g     F .text	00000008 osSchedule
00001b10 g     F .text	00000058 panic
00009374 g     F .text	00000088 at_status_sms_output
000093fc g     F .text	00000128 at_status_output
00015990 g     F .text	000002c8 uart_open
0001a48c g     F .text	00000164 eflash_init
00020ccc g     F .text	00000052 fsm_close
00019888 g     F .text	00000026 hal_uart_set_fifo
00014c0c g     F .text	00000008 osRemoveStopClocksVeto
0001880c g     F .text	0000000c system_status_set_expected_wake_time
000096b8 g     F .text	00000008 app_at_send_at_string_delayed_async
00026134 g     F .text	0000002c system_status_jlink_disconnected
00013fa8 g     F .text	00000018 osSwTmrGetNextTimeout
00001300 g     F .text	00000000 .hidden __gnu_Unwind_Restore_VFP_D_16_to_31
00019614 g     F .text	00000064 IRQ_DMA_Handler
0001990e g     F .text	0000000a hal_uart_get_flag_register
0001b2cc g     F .text	0000003e memcmp
0001cd28 g     F .text	00000016 get_chip_temp_coefficient
000077d8 g     F .text	00000018 neul_update_package_parse_req
00021410 g     F .text	00000080 LOS_SemCreate
000044ea g     F .text	00000052 command_rf_config_ctrl
00022488 g     F .text	00000002 netif_set_link_down
00013bc8 g     F .text	000000f8 los_SuppressTicksAndSleep
00003494 g     F .text	00000064 command_getifaddr
00013ce8 g     F .text	00000030 tickless_remove_stop_clocks_veto
000163f8 g     F .text	00000130 uart_get_data
000182d4 g     F .text	0000000c reboot_get_reset_reason
00008cfc g     F .text	0000000c get_sms_uart_pdu_len
00001318 g     F .text	00000030 .hidden _Unwind_RaiseException
0000484c g     F .text	00000056 command_radio_config_set_gpio
000179d8 g     F .text	0000003c log_buffer_get_used_space
000006a0  w    F .text	00000002 .hidden __aeabi_ldiv0
01002ea4 g     O .bss	00000004 m_pstSwtmrCBArray
00019478 g     F .text	00000074 hal_dma_configure_interrupt
0001e01e g     F .text	0000001a sifaddr
00005b7c g     F .text	00000064 command_get_dns_server_ip_address
00014608 g     F .text	0000001e osAtomicBitsetClearBit
000147e4 g     F .text	00000002 osMs2Tick
00009ec0 g     F .text	00000088 at_uart_deinit
00009178 g     F .text	0000000c get_wait_for_sms_data
00022aa0 g     O .text	00000004 APP_MAIN_QUEUE_TEMP
000028ac g       *ABS*	00000000 __bss_size__
0001c8e8 g     F .text	00000018 abort_radio_processing_command
00018164 g     F .text	00000030 lp_uart_set_callback
0000a182 g     F .text	00000068 at_parse_buf_hex_to_uint8
000211f4 g     F .text	0000011c LOS_MuxPend
00018948 g     F .text	00000018 hal_pio_release_all
0001c920 g     F .text	0000000c set_ip_info_callback
00007164 g     F .text	0000000c ota_check_flash_erased_result
0001c4d4 g     F .text	00000018 remote_command_t3324_t3412_ext_value_changed_ind
00006614 g     F .text	0000001c log_init_after_rtos
0001ccec g     F .text	0000003c get_chipinfo
00014a44 g     F .text	00000038 osSemaphoreNew
00015db8 g     F .text	00000050 uart_has_pending_transmissions
0001a020 g     F .text	00000008 hal_lpuart_clear_irq
0001c8ac g     F .text	0000001e get_initial_pdp_context
0000342e g     F .text	00000066 command_get_id
0001c458 g     F .text	0000000c set_connection_status_callback
0001d0f4 g     F .text	0000003c set_ipaddr_callback
0001c6a0 g     F .text	0000000c set_pdp_context_report_callback
00007d40 g     F .text	00000044 neul_bind
00014024 g     F .text	00000080 LOS_SwtmrCreate
0001ba08 g     F .text	00000028 get_imsi
0001c59c g     F .text	0000001e get_pin_state
010019a2 g     O .bss	00000001 is_pdu
0001cbfc g     F .text	0000002c send_command
000196d4 g     F .text	0000000c hal_reboot_get_reset_reason
000076b8 g     F .text	00000048 aio_manager_init
0001c71c g     F .text	00000050 remote_command_edrx_changed_ind
01002eb8 g     O .bss	00000004 g_uwCyclePerSec
00022672 g     F .text	00000022 buffer_to_pbuf
000185fc g     F .text	00000008 rtc_get_time_us
00004a4a g     F .text	00000084 command_sms_read_short_message_service
00005be0 g     F .text	00000062 command_set_pdp_context_dynamic_param_request_state
0001c538 g     F .text	0000003c set_ptwedrxs
000059e2 g     F .text	00000070 command_iflog_iflash_read
0001a8d4 g     F .text	0000089a vvprintf
000002e0 g     F .text	00000000 memset
00019db4 g     F .text	00000048 hal_lpuart_unset_interrupts
00009cac g     F .text	0000007c at_uart_mark_need_change_config
0100ff00 g       .sys_status	00000000 __sys_status_end__
0001c574 g     F .text	00000028 pin_command
01002ea8 g     O .bss	00000004 m_uwSwTmrHandlerQueue
0001ed18 g     F .text	00000034 link_established
000145bc g     F .text	0000002a osAtomicBitsetInit
0001bbfc g     F .text	0000000c nonip_set_message_received_callback
0001bf20 g     F .text	00000020 remote_command_rxcalist_response
000019f0 g     F .text	00000042 main
00022220 g     F .text	00000038 hal_ssp_disable_all_interrupts
00003200 g     F .text	00000054 command_set_security_log_level
00018244 g     F .text	00000010 non_os_is_this_interrupt_context
000045c2 g     F .text	00000072 command_radio_config_read_mipi_word
0001c24c g     F .text	00000014 remote_command_cfun_result_ind
00004396 g     F .text	0000004a command_update_package_get_package_name_req
00001b0c  w    F .text	00000002 IRQ_COMP_Handler
00009160 g     F .text	0000000c set_wait_for_sms_data
0001c348 g     F .text	00000042 get_pdp_context
00008fe8 g     F .text	0000000c at_query_crtdcp_mode
000198ae g     F .text	00000030 hal_uart_set_fifo_int_levels
0001d7ac g     F .text	000000a8 activity_indication_output
00015734 g     F .text	000001ac uart_claim
000053de g     F .text	0000009e command_radio_config_rx_verify
000019bc g     F .text	00000034 hw_init
00018204 g     F .text	00000014 non_os_is_driver_initialised
0001c61c g     F .text	00000014 remote_command_service_recovery
00019d28 g     F .text	00000014 hal_ipc_deinit_interrupts
000037f2 g     F .text	0000004c command_get_available_plmn
00009f70 g     F .text	00000080 at_uart_switch_to_new_config
0000a8e4 g     F .text	0000001c at_is_param_in_double_quotes
0000a048 g     F .text	00000040 at_uart_switch_to_ppp
0001826e g     F .text	00000016 pio_release
0100fee0 g       .sys_status	00000000 __sys_status_start__
010004d0 g       .data	00000000 __data_begin__
00017fc4 g     F .text	00000020 lp_uart_enable_software_flow_control
0001c9ec g     F .text	0000002c set_ciot_opt
000003b8 g     F .text	00000000 .hidden __aeabi_uidiv
0001a17c g     F .text	0000001c hal_uart_specific_disable_irq
00017510 g     F .text	00000090 ipc_receive_message
0000782e g     F .text	0000000e neul_update_package_flash_erase
00013e38 g     F .text	00000094 osSwTmrInit
010004d0 g       .ramtext	00000000 __ramtext_end__
0000228c g     F .text	0000005c rpc_interface_poll
00001b0c  w    F .text	00000002 SVC_Handler
00005010 g     F .text	0000006c command_get_cell_info
0001be1c g     F .text	0000001c production_radio_config_set_gpio
0001cdfc g     F .text	00000018 set_svn
01002e3c g     O .bss	00000002 sms_uart_pdu_len
00019740 g     F .text	00000050 hal_rtc_get_time_us
000188e4 g     F .text	00000010 hal_gpio_config_dir
00003676 g     F .text	00000060 command_get_supported_bands
00019cb6 g     F .text	0000000a IRQ_UART1_Handler
00016afc g     F .text	00000074 dma_init
000188d4 g     F .text	00000010 watchdog_get_time
00021f08 g     F .text	00000038 hal_ssp_release
0000335c g     F .text	0000006e command_set_id
00018b14 g     F .text	00000064 hal_pio_set_interrupt
0001c004 g     F .text	00000028 set_plmn_state
00012b4c g     F .text	0000007e LOS_MemStatisticsGet
00000166 g     F .text	00000000 LOS_IntUnLock
0002234e g     F .text	0000000e memp_malloc_pool
00017944 g     F .text	00000094 log_buffer_reader_lock_next
00013fc0 g     F .text	00000024 osSwTmrAdjust
00018fb8 g     F .text	00000010 hal_dma_ch_deregister_peripheral_prepare_callback
0001c988 g     F .text	00000028 modify_pdp_req
000065a0 g     F .text	0000001e rpc_get_int16
00004196 g     F .text	00000074 command_set_ping
00018bb4 g     F .text	00000158 hal_lpuart_specific_set_baud_rate
00014c04 g     F .text	00000008 osAddStopClocksVeto
00002c40  w    F .text	0000000c remote_command_update_package_data_req
0000787c g     F .text	0000000c neul_update_register_package_get_package_version_cnf_callback
0002210c g     F .text	00000014 hal_ssp_tx_fifo_is_empty
01000688 g     O .bss	00000004 panic_registered_callback
0000657a g     F .text	00000026 rpc_get_int32
00013d7c g     F .text	00000020 osPriqueueTop
0001caa4 g     F .text	00000020 set_tft_req
00018088 g     F .text	00000008 lp_uart_get_fifo_level
00013b54 g     F .text	0000002c los_lpt_start
0001c874 g     F .text	00000020 get_power_band_class
0001c848 g     F .text	00000014 remote_command_psm_status_ind
0001389c g     F .text	00000054 osHeapStatisticsGet
000149ec g     F .text	0000001e osMutexRelease
0000a13a g     F .text	00000048 at_parse_buf_to_hex_forward_order
000004cc g     F .text	000001cc .hidden __divsi3
00019950 g     F .text	00000022 hal_uart_set_data_bits
00000bd0 g     F .text	00000014 .hidden __gnu_Unwind_ForcedUnwind
0001c048 g     F .text	00000028 get_available_plmn
00014740 g     F .text	00000038 osKernelLock
0001a010 g     F .text	00000010 hal_lpuart_get_frame_errors
01000000 g       .ARM.extab	00000000 __RAM_BEGIN__
00007894 g     F .text	00000014 remote_command_update_package_flash_erase_done
00009a5c g     F .text	00000024 at_uart_create_queue
00013db8 g     F .text	00000040 osSwTmrTask
0001ba30 g     F .text	00000028 get_iccid
0001b360 g     F .text	0000003e strcmp
00004b20 g     F .text	0000005c command_sms_read_more_message_to_send
00009d84 g     F .text	0000007c at_uart_store_new_config
000181b4 g     F .text	00000028 non_os_enter_critical
000092ac g     F .text	00000010 app_at_ip_mtu_init
000227f0 g     F .text	0000002e sys_thread_new
0002220c g     F .text	0000000a IRQ_SSP0_Handler
00022870 g     F .text	00000008 sys_jiffies
0001ec08 g     F .text	00000018 ppp_dbglog
000222d8 g     F .text	00000020 __sigdfl
00016f3c g     F .text	00000030 uart_common_configure_tx_interrupts
00008ff4 g     F .text	00000020 at_set_non_ip_data_report_mode
00001c7c g     F .text	00000040 rpc_interface_create_queue
0001cb18 g     F .text	00000024 request_reboot
0100ffa0 g       .ipc_mailbox	00000000 __ipc_mailbox_end__
00003892 g     F .text	0000005e command_get_imsi
00000c2c g     F .text	0000001a .hidden __gnu_Unwind_Resume_or_Rethrow
0001290c g     F .text	0000001a uicc_status_control
00008214 g     F .text	0000002c iflog_get_available_size
00005aa6 g     F .text	0000004c command_abort_processing_command
00013290 g     F .text	00000038 osTaskEntry
0001c432 g     F .text	00000026 get_nconfig
00026164 g     F .fini	00000000 _fini
000012c4 g     F .text	0000002a .hidden restore_core_regs
00011a74 g     F .text	00000008 at_get_internal_cmd_table_address
0000a8b8 g     F .text	0000002c at_get_ip_param
00001314 g     F .text	00000000 .hidden __gnu_Unwind_Save_WMMXC
01002e78 g     O .bss	00000004 g_bTaskScheduled
0001919c g     F .text	00000018 hal_dma_check_ch_transfer_config
00018908 g     F .text	0000002c hal_gpio_disable_all_interrupts
00006244 g     F .text	00000052 command_uicc_status_control
000084bc g     F .text	0000000c get_at_blocking_at_command_protected
0001b814 g     F .text	00000018 flash_log_register
0001c0ac g     F .text	00000014 remote_command_plmn_select_result_ind
000149a4 g     F .text	00000048 osMutexAcquire
00001da0 g     F .text	00000014 set_receive_info
00019cac g     F .text	0000000a IRQ_UART0_Handler
0001b714 g     F .text	00000018 sprintf
0001b8b4 g     F .text	00000044 get_man_identifier
0000996c g     F .text	0000000c at_uart_set_parity_error_status
0001cb3c g     F .text	00000020 set_short_message_service_type
000071d4 g     F .text	00000018 ota_iflash_register_callback
00019dfc g     F .text	0000004c hal_lpuart_set_wordlength
0001cb5c g     F .text	00000022 read_short_message_service_type
0001ebf0 g     F .text	00000018 ppp_info
00005e76 g     F .text	00000062 command_set_ciot_opt
00019c24 g     F .text	0000000a hal_uart_get_dmac_register
000068b4 g     F .text	00000008 flog_read
000033ca g     F .text	00000064 command_set_id_permanence
0001ca42 g     F .text	00000018 delete_qos
010005c8 g     O .data	00000003 uart_rx_dma_ch
00013cc0 g     F .text	00000028 tickless_add_stop_clocks_veto
00003736 g     F .text	00000060 command_execute_plmn_select
00019f98 g     F .text	0000001c IRQ_LPUART_Handler
0000994c g     F .text	00000008 at_uart_get_receive_buffer
0001b72c g     F .text	00000018 set_last_panic
00022b50 g     O .text	0000002c security_incomming_command_table
0001eba8 g     F .text	00000018 ppp_error
01002fa0 g       *ABS*	00000000 __INTHEAP_BEGIN__
00015f28 g     F .text	00000070 uart_register_frame_error_callback
00007ac0 g     F .text	00000048 get_tcp_pending_data_seqs
0001be7a g     F .text	00000042 production_radio_config_tx_calist
0001c20a g     F .text	00000018 get_connection_status
00000400 g       *ABS*	00000000 __SYSTEM_STACK_SIZE__
0001b770 g     F .text	0000000c set_last_exception
0000179c g     F .text	00000006 .hidden _Unwind_GetTextRelBase
0100ff00 g       .ipc_mailbox	00000000 __ipc_mailbox_start__
01002e9c g     O .bss	00000004 g_pstLosPriorityQueueList
0001ccb4 g     F .text	0000001c remote_command_sms_mgs_result_ind
0002558c g     O .text	00000004 hal_sectors_ram_heap_size
00003aca g     F .text	0000007c command_get_pdp_context
00016d5c g     F .text	00000084 uart_common_validate_pin_config
00013df8 g     F .text	00000040 osSwTmrTaskCreate
0001dd10 g     F .text	0000002a ppp_listen
0000a1ea g     F .text	00000040 at_parse_buf_hex_to_uint16
000084c8 g     F .text	0000003c app_at_send_callback_response
000099cc g     F .text	00000020 at_uart_release
00013a1c g     F .text	00000014 LOS_Align
000063e2 g     F .text	00000086 command_radio_config_tx_calist
000061d4 g     F .text	00000070 command_get_pin_remaining_retries
00018b78 g     F .text	00000024 hal_lpuart_specific_claim
000137dc g     F .text	000000c0 osHeapFree
00023fa4 g     O .text	00000840 g_at_cmd_table
010014fc g     O .bss	00000002 log_uart_protocol_log_watermark
00006548 g     F .text	00000032 rpc_get_int64
00013a08 g     F .text	00000014 osSlabAllocatorGetSlabInfo
00018960 g     F .text	00000014 hal_pio_release
0001c85c g     F .text	00000018 set_power_band_class
0001c47c g     F .text	0000000c set_t3324_t3412_ext_value_changed_callback
000139e0 g     F .text	00000028 osSlabAllocatorGetUsedItemCnt
0001cec8 g     F .text	0000014a getifaddrs
00015e08 g     F .text	000000b0 uart_register_rx_callback
00011b1c g     F .text	0000000c at_get_registered_cmd_table_address
00021f40 g     F .text	0000003c hal_ssp_set_data_size
000138f0 g     F .text	00000028 osHeapGetMaxBlkSize
00006302 g     F .text	00000070 command_get_cid_status
000075b2 g     F .text	0000007a neul_kv_get
00012b18 g     F .text	00000034 LOS_MemFree
0000a41c g     F .text	000000f0 at_get_uint32_param
0001bb8c g     F .text	0000000a remote_command_rf_calibration_rtc_ind
00020a34 g     F .text	0000002a fsm_lowerup
0001c6ac g     F .text	00000070 get_pdp_state
0001c5ec g     F .text	00000030 get_edrxs_and_ptw
000210b0 g     F .text	00000060 osMuxInit
00017046 g     F .text	00000008 clocks_get_core_clock
00012bca g     F .text	00000024 LOS_MemGetMaxBlkSize
000078d0 g     F .text	00000018 remote_command_update_package_get_package_name_cnf
0001a5f0 g     F .text	00000130 eflash_write_data
0001ce14 g     F .text	00000018 get_svn
00007c10 g     F .text	00000012 remote_command_socket_recv
000214dc g     F .text	000000e8 LOS_SemPend
01002e3e g     O .bss	00000001 report_type
00001780 g     F .text	00000012 .hidden _Unwind_GetLanguageSpecificData
00018e9c g     F .text	0000004c hal_dma_init
0000916c g     F .text	0000000c clear_wait_for_sms_data
00003616 g     F .text	00000060 command_get_band
0000a6e4 g     F .text	000000a4 at_get_1dp_to_int16_param
0001be00 g     F .text	0000001c production_radio_config_set_rio_v
000077f0 g     F .text	00000018 neul_update_package_get_package_name_req
00004f98 g     F .text	00000078 command_get_edrxs_and_ptw
0001b986 g     F .text	0000002e get_ssb_version
00003db0 g     F .text	0000004c command_read_service_status
0002091c g     F .text	00000014 magic
000136c0 g     F .text	00000058 osHeapInit
00019434 g     F .text	00000044 hal_dma_disable_interrupt
0001cea8 g     F .text	00000020 freeifaddrs
000199d6 g     F .text	00000044 hal_uart_enable_interrupt
00008ea4 g     F .text	000000d0 get_cgpaddr_cid_range
0001ccd0 g     F .text	0000001c remote_command_sms_cmd_result_ind
000129fc g     F .text	00000002 irmalloc_init_default
00016fde g     F .text	00000068 uart_common_enable_uart
00004d2c g     F .text	0000006c command_sms_set_new_msg_ack
00003dfc g     F .text	0000004c command_read_ue_cfun
000068bc g     F .text	00000002 flog_page_read_finish
000220e4 g     F .text	00000014 hal_ssp_tx_fifo_is_full
00003f64 g     F .text	0000006c command_neul_bind
00000c5c g     F .text	00000030 .hidden _Unwind_VRS_Get
00008240 g     F .text	00000050 iflog_read
00018ee8 g     F .text	00000060 hal_dma_claim
00018a00 g     F .text	0000004c hal_pio_config_pull
00012a94 g     F .text	00000050 osMemSystemInit
00001310 g     F .text	00000000 .hidden __gnu_Unwind_Restore_WMMXC
00018764 g     F .text	0000000c rtc_get_daylight_saving_time
000004c4 g     F .text	00000008 .hidden __aeabi_uidivmod
01000680 g       .bss	00000000 __bss_begin__
0001cafc g     F .text	0000001c get_cid_status
00003796 g     F .text	0000005c command_get_plmn_status
00018090 g     F .text	00000068 lp_uart_enable_irq
00022868 g     F .text	00000008 sys_now
00018898 g     F .text	00000024 watchdog_kick
000131c4 g     F .text	000000cc osTaskSelfDelete
0001dfec g     F .text	00000006 new_phase
00017e50 g     F .text	00000154 lp_uart_init
000220f8 g     F .text	00000014 hal_ssp_rx_fifo_is_empty
01002e3f g     O .bss	00000001 at_sms_msg_type
00005ed8 g     F .text	0000006a command_get_ciot_opt
0001cc28 g     F .text	00000022 set_new_msg_ack
00020900 g     F .text	00000014 magic_init
00018fe8 g     F .text	00000058 hal_dma_ch_config_buffer_init
0000174c g     F .text	00000028 .hidden __gnu_unwind_frame
00007db8 g     F .text	00000074 sendto_with_indication
000017f8 g     F .text	00000012 .hidden __gnu_thumb1_case_sqi
000013a8 g     F .text	00000030 .hidden _Unwind_ForcedUnwind
00012a14 g     F .text	00000024 irzalloc
0001c070 g     F .text	00000028 set_service_state
0001d294 g     F .text	00000010 ip4addr_ntoa
0001d204 g     F .text	0000008e ip4addr_ntoa_r
0001e092 g     F .text	00000006 get_mask
01002a0c g     O .bss	00000001 system_status_flash_write_vetos
00007138 g     F .text	0000002c ota_package_init
00006006 g     F .text	00000054 command_delete_qos
01002e7c g     O .bss	00000008 g_stLosFreeTask
00022010 g     F .text	00000034 hal_ssp_set_serial_clock_rate
0000547c g     F .text	00000076 command_nonip_sendto
0001828c g     F .text	00000016 pio_output_config
000226ac g     F .text	0000009c sio_open
00012b10 g     F .text	00000008 LOS_MemAllocAlign
0001360c g     F .text	00000070 LOS_TaskDelay
0001c488 g     F .text	00000018 set_power_saving_mode
00008cf0 g     F .text	0000000c set_sms_uart_pdu_len
000042b6 g     F .text	0000004c command_get_time_update_mode
0000405c g     F .text	00000056 command_get_pending_data_seqs
00012c30 g     F .text	00000098 osSlabMemAlloc
00002528  w    F .text	0000000c remote_command_app_flash_write_response
00021fa0 g     F .text	00000038 hal_ssp_set_frame_format
000134d4 g     F .text	0000003c osIdleTaskCreate
000189b4 g     F .text	00000020 hal_pio_get_function
00025788 g     O .text	00000002 memp_PPP_PCB
0000383e g     F .text	00000054 command_set_attach_state
00017fa4 g     F .text	0000001e lp_uart_deinit
01002ed0 g     O .bss	00000004 g_pstAllQueue
00019b16 g     F .text	00000020 hal_uart_disable_uart
0000783c g     F .text	0000000e neul_update_package_allocate_flash
00022572 g     F .text	00000056 pbuf_header
0001281c g     F .text	00000040 production_at_cmd_init
00018ba8 g     F .text	0000000c hal_lpuart_specific_clear_irq
00018604 g     F .text	00000008 rtc_get_time_ms
00018848 g     F .text	00000050 watchdog_enable
0001b8f8 g     F .text	00000044 get_man_model
00018770 g     F .text	0000000c rtc_get_time_zone
00019972 g     F .text	00000026 hal_uart_set_stop_bits
000056fc g     F .text	00000062 command_set_power_band_class
01002a08 g     O .bss	00000004 system_status_debug_longest_wake_delay
00011dc4 g     F .text	0000009c at_ota_download_package
0001b192 g     F .text	00000006 exit
00019e48 g     F .text	0000004c hal_lpuart_set_parity
00019790 g     F .text	00000034 hal_rtc_get_time_ms
000182a2 g     F .text	0000000a pio_input_config
0001cbd0 g     F .text	0000002c send_short_message
0001bfba g     F .text	00000018 production_calibrate_temperature
00016f6c g     F .text	00000048 uart_common_configure_line_settings
0000130c g     F .text	00000000 .hidden __gnu_Unwind_Save_WMMXD
00020194 g     F .text	00000032 lcp_open
0000356a g     F .text	0000004c command_clear_stored_earfcn
000091b4 g     F .text	0000006c app_at_get_non_ip_mtu_size
010005dc g     O .data	00000004 __ctype_ptr__
0001b708 g     F .text	0000000c __asm_memcpy_assert
0002183c g     F .text	00000078 spi_release
0001858c g     F .text	00000030 rtc_delete
0000453c g     F .text	00000086 command_radio_config_meas_rssi
000023fe g     F .text	00000008 rpc_init_receive_section
01002eac g     O .bss	00000004 m_pstSwtmrSortList
00006c68 g     F .text	000002d4 log_main
0000fee0 g       *ABS*	00000000 __RAM_SIZE__
0000420a g     F .text	00000072 command_set_system_time_from_apps
0000610e g     F .text	0000006a command_get_tft_context
00019e94 g     F .text	00000034 hal_lpuart_set_stop
00018944 g     F .text	00000002 hal_pio_init
0001b178 g     F .text	0000000c atoi
010005cb g     O .data	00000003 uart_tx_dma_ch
00004b7c g     F .text	0000006c command_sms_set_short_message_service_address
0001ec20 g     F .text	00000002 link_required
000255a8 g     O .text	00000101 _ctype_
00007924 g     F .text	00000018 set_network_config
0001db3c g     F .text	0000000c ppp_set_ppp_exit_callback
0001db74 g     F .text	00000124 pppd_go
0001c8cc g     F .text	0000001c remote_command_get_plmn_results_ind
0001ed66 g     F .text	0000001a np_down
00022380 g     F .text	00000070 netif_ip4_socket_recv
000006a0  w    F .text	00000002 .hidden __aeabi_idiv0
00021670 g     F .text	00000018 LOS_ErrHandle
000172a4 g     F .text	00000050 gpio_clear
0000a60c g     F .text	00000064 at_get_uint8_param
0001c948 g     F .text	0000000e rai_req
000080f8 g     F .text	0000000c iflog_set_write_enable
00004926 g     F .text	00000054 command_pdp_activate_req
00014568 g     F .text	00000054 LOS_QueueWriteCopy
00021acc g     F .text	000001ac spi_send_data
000188bc g     F .text	00000018 watchdog_disable
0001cbb0 g     F .text	0000001e set_short_message_service_address
000054f2 g     F .text	00000070 command_get_mtu_size
0000427c g     F .text	0000003a command_set_time_update_mode
000030dc g     F .text	00000010 rpc_auto_generated_init
000040b2 g     F .text	00000078 command_socket_send
00014666 g     F .text	0000003e osBitsetEmpty
0001b88a g     F .text	0000002a set_serial_number
00019ec8 g     F .text	0000004c hal_lpuart_set_syncmode
01002f60 g     O .preserve	00000040 preserve_data_lib
01002ebc g     O .bss	00000004 g_uwTicksPerSec
0001b4c8 g     F .text	000001c4 gmtime
00004be8 g     F .text	0000006c command_sms_read_short_message_service_address
000006e4 g     F .text	00000054 .hidden __muldi3
01000000 g       .stacks	00000000 __SYSTEM_STACK_BEGIN__
00019720 g     F .text	00000020 IRQ_RTC_Handler
0001e008 g     F .text	00000016 ppp_recv_config
0000497a g     F .text	00000054 command_pdp_deactivate_req
000132c8 g     F .text	00000190 LOS_TaskCreateOnly
00004e42 g     F .text	0000006c command_set_power_saving_mode
00009954 g     F .text	0000000c at_uart_get_parity_error_status
0001c3da g     F .text	00000044 get_pdp_context_auth_param
0001b39e g     F .text	00000018 strlen
00002300 g     F .text	000000f8 rpc_interface_scatter_send
0001b93c g     F .text	00000026 set_imei_permanence
000034f8 g     F .text	00000072 command_set_earfcn_range
00001048  w    F .text	0000000a .hidden __aeabi_unwind_cpp_pr1
0001c5ba g     F .text	00000026 get_pin_remaining_retries
010004d0 g     O .data	000000c0 app_tasks
00004de4 g     F .text	0000005e command_get_iccid
01002e8c g     O .bss	00000010 ramHeap
000071d0 g     F .text	00000002 ota_poll
0001a720 g     F .text	000000dc eflash_read_data
000196bc g     F .text	00000018 hal_reboot_init
00017254 g     F .text	00000050 gpio_set
00014510 g     F .text	00000058 LOS_QueueReadCopy
00005a52 g     F .text	00000054 command_update_package_allocate_flash
0001b170 g     F .text	00000008 abs
00009960 g     F .text	0000000c at_uart_get_frame_error_status
0001b33c g     F .text	00000024 strchr
000227a0 g     F .text	0000000c neul_lwip_serial_set_rx_callback
0001ecb8 g     F .text	0000004c continue_networks
00011a7c g     F .text	000000a0 at_cmd_register
0001bdc6 g     F .text	0000003a production_radio_config_get_tx_gains
0001c784 g     F .text	0000004a get_edrxedp
0001ed04 g     F .text	00000012 start_networks
0000434c g     F .text	0000004a command_update_package_get_package_version_req
00001794 g     F .text	00000006 .hidden _Unwind_GetDataRelBase
0000016e g     F .text	00000000 LOS_IntRestore
01002538 g     O .bss	00000004 uart_is_need_awake_callback
00026108 g     F .text	0000002c system_status_jlink_connected
00017104 g     F .text	00000058 gpio_init
000182e0 g     F .text	00000040 reboot_notify_security_of_reboot
0001bbf0 g     F .text	0000000c nonip_set_cp_only_message_received_callback
000049ce g     F .text	0000007c command_sms_set_short_message_service
00018818 g     F .text	00000030 watchdog_init
000158e0 g     F .text	000000b0 uart_release
0000689c g     F .text	00000008 flog_init
00016528 g     F .text	00000008 aio_manager_get_status_table
00008068 g     F .text	00000024 remote_command_socket_data_sent
00004634 g     F .text	0000006c command_radio_config_write_mipi_word
00005562 g     F .text	00000068 command_execute_pin_command
0001d150 g     F .text	00000044 icmp_ping_send
000145e6 g     F .text	00000004 osAtomicBitsetGetNumBits
000075a8 g     F .text	0000000a neul_kv_set
00007900 g     F .text	00000014 remote_command_update_package_flash_write_done
00013458 g     F .text	0000007c LOS_TaskCreate
000188f4 g     F .text	0000000a hal_gpio_set
00007914 g     F .text	00000010 neul_log_get_log_behaviour_restricted
00014a0c g     F .text	00000038 osMutexDelete
000017e0 g     F .text	00000016 .hidden __clzdi2
0000a900 g     F .text	000000e0 at_get_atcmd_cb_from_atstring
0001c02c g     F .text	0000001a get_plmn_state
00018a4c g     F .text	00000038 hal_pio_set_gpio_direction
00019998 g     F .text	0000003e hal_uart_set_parity
00019570 g     F .text	000000a4 hal_dma_ch_open
000201c8 g     F .text	0000005c lcp_close
00001820 g     F .text	00000014 .hidden __gnu_thumb1_case_uhi
0002235c g     F .text	0000000e memp_free_pool
0001ca5a g     F .text	00000018 set_qos_req
0001db48 g     F .text	0000002c pppd_set_ip_address
000175a0 g     F .text	00000014 ipc_check_outbox_free
0001ed4c g     F .text	0000001a np_up
00019108 g     F .text	0000003c hal_dma_ch_config_buffer_add_config
00000698 g     F .text	00000008 .hidden __aeabi_idivmod
00006858 g     F .text	0000003c log_level_init
00013d18 g     F .text	00000034 osPriqueueInit
00022748 g     F .text	0000000e sio_send
00018de4 g     F .text	00000060 hal_clocks_get_core_clock_mid_value
0001bbd4 g     F .text	0000000e set_time_update_mode
00000120 g     F .text	00000000 LOS_StartToRun
0001cc9c g     F .text	00000018 remote_command_sms_cmt_pdu_ind
00021a38 g     F .text	00000094 spi_activate
0001bcdc g     F .text	00000024 remote_command_radiotest_response
000220c4 g     F .text	00000010 hal_ssp_write_data
0001b962 g     F .text	00000024 set_serialnumber_permanence
00013024 g     F .text	000000b8 osTaskScan
00008290 g     F .text	00000022 aio_func_set_default_temperature_coefficient
0001e098 g     F .text	00000008 netif_set_mtu
01002e84 g     O .bss	00000008 g_stTaskTimerList
0002293c g     F .text	0000007c sys_untimeout
00012ed4 g     F .text	0000006c osTskSortLinkUpdate
0001c27e g     F .text	0000001a get_defined_cids
0002248a g     F .text	00000054 ip4_input
00018658 g     F .text	00000084 rtc_rf_calibration_rtc
0001bfa0 g     F .text	0000001a production_radio_config_tx_test
0001bae6 g     F .text	00000032 neul_log_get_log_level
0000801c g     F .text	0000002c socklen
0000561e g     F .text	0000004a command_kv_queue_cache_for_write
000046f2 g     F .text	00000074 command_radio_config_set_tx_gains
000227ac g     F .text	00000044 neul_lwip_serial_deinit
00021110 g     F .text	0000006c LOS_MuxCreate
000130dc g     F .text	000000e8 osTaskInit
00005352 g     F .text	0000008c command_radio_config_tx_verify
0000a2b8 g     F .text	0000002c at_free_at_params
000065ec g     F .text	00000028 log_full_log_enabled_init
00012a74 g     F .text	00000020 LOS_mem_reg_ex_ope
0001c900 g     F .text	00000014 remote_command_radio_command_abort_ind
00001b0c  w    F .text	00000002 IRQ_EDGE_Handler
000197c4 g     F .text	00000048 hal_uart_init
00019714 g     F .text	0000000c hal_rtc_set_callback
00009650 g     F .text	00000068 app_at_send_convert_hexstring_no_claim
000058b8 g     F .text	00000074 command_radio_config_tx_test
00022628 g     F .text	0000003a pbuf_to_buffer
0000a670 g     F .text	00000074 at_get_int16_param
00007120 g     F .text	00000018 initialise_fota
00015ce8 g     F .text	0000003c uart_enable_software_flow_control
000222f8 g     F .text	00000014 raise
0000935c g     F .text	0000000c get_cmee_error_type
0001bc08 g     F .text	00000050 remote_command_nonip_recvfrom
00019a5c g     F .text	0000007c hal_uart_configure_interrupt
00009184 g     F .text	0000000c set_report_type
00018750 g     F .text	00000012 get_current_time
00009978 g     F .text	0000000c at_uart_get_buffer_error_status
010004b0 g     F .ramtext	00000020 hal_rtc_get_time
0001b9b4 g     F .text	00000030 get_firmware_version
00013918 g     F .text	00000050 osSlabAllocatorNew
00011a70 g     F .text	00000004 at_get_internal_cmd_table_size



Disassembly of section .text:

00000120 <LOS_StartToRun>:
    .type LOS_StartToRun, %function
    .global LOS_StartToRun
LOS_StartToRun:
    .fnstart
    .cantunwind
    LDR     R4, =OS_NVIC_SYSPRI2
     120:	4c2c      	ldr	r4, [pc, #176]	; (1d4 <TaskSwitch+0x52>)
    LDR     R5, =OS_NVIC_PENDSV_PRI
     122:	4d2d      	ldr	r5, [pc, #180]	; (1d8 <TaskSwitch+0x56>)
    STR     R5, [R4]
     124:	6025      	str	r5, [r4, #0]

    LDR     R0, =g_bTaskScheduled
     126:	482d      	ldr	r0, [pc, #180]	; (1dc <TaskSwitch+0x5a>)
    MOVS    R1, #1
     128:	2101      	movs	r1, #1
    STR     R1, [R0]
     12a:	6001      	str	r1, [r0, #0]

    MOVS    R0, #2
     12c:	2002      	movs	r0, #2
    MSR     CONTROL, R0
     12e:	f380 8814 	msr	CONTROL, r0


    LDR     R0, =g_stLosTask
     132:	482b      	ldr	r0, [pc, #172]	; (1e0 <TaskSwitch+0x5e>)
    LDR     R2, [R0, #4]
     134:	6842      	ldr	r2, [r0, #4]
    LDR     R0, =g_stLosTask
     136:	482a      	ldr	r0, [pc, #168]	; (1e0 <TaskSwitch+0x5e>)
    STR     R2, [R0]
     138:	6002      	str	r2, [r0, #0]

    LDR     R3, =g_stLosTask
     13a:	4b29      	ldr	r3, [pc, #164]	; (1e0 <TaskSwitch+0x5e>)
    LDR     R0, [R3]
     13c:	6818      	ldr	r0, [r3, #0]
    LDRH    R7, [R0 , #4]
     13e:	8887      	ldrh	r7, [r0, #4]
    MOVS    R6,  #OS_TASK_STATUS_RUNNING
     140:	2610      	movs	r6, #16
    ORRS    R7,  R7, R6
     142:	4337      	orrs	r7, r6
    STRH    R7,  [R0 , #4]
     144:	8087      	strh	r7, [r0, #4]

    LDR     R3, [R0]
     146:	6803      	ldr	r3, [r0, #0]
    ADDS    R3, R3, #36
     148:	3324      	adds	r3, #36	; 0x24

    LDMFD   R3!, {R0-R2}
     14a:	cb07      	ldmia	r3!, {r0, r1, r2}
    ADDS    R3, R3, #4
     14c:	3304      	adds	r3, #4
    LDMFD   R3!, {R4-R7}
     14e:	cbf0      	ldmia	r3!, {r4, r5, r6, r7}
    MSR     PSP, R3
     150:	f383 8809 	msr	PSP, r3
    SUBS    R3, R3, #20
     154:	3b14      	subs	r3, #20
    LDR     R3,  [R3]
     156:	681b      	ldr	r3, [r3, #0]

    MOV     LR, R5
     158:	46ae      	mov	lr, r5
    CPSIE   I
     15a:	b662      	cpsie	i
    BX      R6
     15c:	4730      	bx	r6

0000015e <LOS_IntLock>:
     .type LOS_IntLock, %function
    .global LOS_IntLock
LOS_IntLock:
    .fnstart
    .cantunwind
    MRS     R0, PRIMASK
     15e:	f3ef 8010 	mrs	r0, PRIMASK
    CPSID   I
     162:	b672      	cpsid	i
    BX      LR
     164:	4770      	bx	lr

00000166 <LOS_IntUnLock>:
    .type LOS_IntUnLock, %function
    .global LOS_IntUnLock
LOS_IntUnLock:
    .fnstart
    .cantunwind
    MRS    R0, PRIMASK
     166:	f3ef 8010 	mrs	r0, PRIMASK
    CPSIE  I
     16a:	b662      	cpsie	i
    BX     LR
     16c:	4770      	bx	lr

0000016e <LOS_IntRestore>:
    .type LOS_IntRestore, %function
    .global LOS_IntRestore
LOS_IntRestore:
    .fnstart
    .cantunwind
    MSR   PRIMASK, R0
     16e:	f380 8810 	msr	PRIMASK, r0
    BX    LR
     172:	4770      	bx	lr

00000174 <osTaskSchedule>:
    .type osTaskSchedule, %function
    .global osTaskSchedule
osTaskSchedule:
    .fnstart
    .cantunwind
    LDR     R0, =OS_NVIC_INT_CTRL
     174:	481b      	ldr	r0, [pc, #108]	; (1e4 <TaskSwitch+0x62>)
    LDR     R1, =OS_NVIC_PENDSVSET
     176:	491c      	ldr	r1, [pc, #112]	; (1e8 <TaskSwitch+0x66>)
    STR     R1, [R0]
     178:	6001      	str	r1, [r0, #0]
    BX      LR
     17a:	4770      	bx	lr

0000017c <PendSV_Handler>:
    .type PendSV_Handler, %function
    .global PendSV_Handler
PendSV_Handler:
    .fnstart
    .cantunwind
    MRS     R12, PRIMASK
     17c:	f3ef 8c10 	mrs	ip, PRIMASK
    CPSID   I
     180:	b672      	cpsid	i

00000182 <TaskSwitch>:



TaskSwitch:
    MRS     R0, PSP
     182:	f3ef 8009 	mrs	r0, PSP

    SUBS    R0, #36
     186:	3824      	subs	r0, #36	; 0x24
    STMIA   R0!, {R4-R7}
     188:	c0f0      	stmia	r0!, {r4, r5, r6, r7}
    MOV     R3, R8                  
     18a:	4643      	mov	r3, r8
    MOV     R4, R9
     18c:	464c      	mov	r4, r9
    MOV     R5, R10
     18e:	4655      	mov	r5, sl
    MOV     R6, R11
     190:	465e      	mov	r6, fp
    MOV     R7, R12
     192:	4667      	mov	r7, ip
    STMIA   R0!, {R3 - R7}
     194:	c0f8      	stmia	r0!, {r3, r4, r5, r6, r7}

    SUBS    R0, #36
     196:	3824      	subs	r0, #36	; 0x24

    LDR     R5, =g_stLosTask
     198:	4d11      	ldr	r5, [pc, #68]	; (1e0 <TaskSwitch+0x5e>)
    LDR     R6, [R5]
     19a:	682e      	ldr	r6, [r5, #0]
    STR     R0, [R6]
     19c:	6030      	str	r0, [r6, #0]


    LDRH    R7, [R6 , #4]
     19e:	88b7      	ldrh	r7, [r6, #4]
    MOVS    R3, #OS_TASK_STATUS_RUNNING
     1a0:	2310      	movs	r3, #16
    BICS     R7, R7, R3
     1a2:	439f      	bics	r7, r3
    STRH    R7, [R6 , #4]
     1a4:	80b7      	strh	r7, [r6, #4]


    LDR     R0, =g_stLosTask
     1a6:	480e      	ldr	r0, [pc, #56]	; (1e0 <TaskSwitch+0x5e>)
    LDR     R0, [R0, #4]
     1a8:	6840      	ldr	r0, [r0, #4]
    STR     R0, [R5]
     1aa:	6028      	str	r0, [r5, #0]


    LDRH    R7, [R0 , #4]
     1ac:	8887      	ldrh	r7, [r0, #4]
    MOVS    R3,  #OS_TASK_STATUS_RUNNING
     1ae:	2310      	movs	r3, #16
    ORRS    R7,  R7, R3
     1b0:	431f      	orrs	r7, r3
    STRH    R7,  [R0 , #4]
     1b2:	8087      	strh	r7, [r0, #4]

    LDR     R1,   [R0]
     1b4:	6801      	ldr	r1, [r0, #0]
    ADDS    R1,   #16
     1b6:	3110      	adds	r1, #16
    LDMFD   R1!, {R3-R7}
     1b8:	c9f8      	ldmia	r1!, {r3, r4, r5, r6, r7}
    MOV     R8, R3                  
     1ba:	4698      	mov	r8, r3
    MOV     R9, R4
     1bc:	46a1      	mov	r9, r4
    MOV     R10, R5
     1be:	46aa      	mov	sl, r5
    MOV     R11, R6
     1c0:	46b3      	mov	fp, r6
    MOV     R12, R7  
     1c2:	46bc      	mov	ip, r7
    SUBS    R1,  #36
     1c4:	3924      	subs	r1, #36	; 0x24
    LDMFD   R1!, {R4-R7}
     1c6:	c9f0      	ldmia	r1!, {r4, r5, r6, r7}
    
    ADDS    R1,   #20
     1c8:	3114      	adds	r1, #20
    MSR     PSP,  R1
     1ca:	f381 8809 	msr	PSP, r1

    MSR     PRIMASK, R12
     1ce:	f38c 8810 	msr	PRIMASK, ip
    BX      LR
     1d2:	4770      	bx	lr
    LDR     R4, =OS_NVIC_SYSPRI2
     1d4:	e000ed20 	.word	0xe000ed20
    LDR     R5, =OS_NVIC_PENDSV_PRI
     1d8:	00f00000 	.word	0x00f00000
    LDR     R0, =g_bTaskScheduled
     1dc:	01002e78 	.word	0x01002e78
    LDR     R0, =g_stLosTask
     1e0:	01002e70 	.word	0x01002e70
    LDR     R0, =OS_NVIC_INT_CTRL
     1e4:	e000ed04 	.word	0xe000ed04
    LDR     R1, =OS_NVIC_PENDSVSET
     1e8:	10000000 	.word	0x10000000
     1ec:	00000000 	.word	0x00000000

000001f0 <memcpy>:
   
/* LINTSTUB: Func: void *memcpy(void *dst, const void *src, size_t len) */
ENTRY(memcpy)

#ifndef NDEBUG                /* For now, we want to check if memmove should be being used */
    cmp   r0, r1
     1f0:	4288      	cmp	r0, r1
    beq   .neul_memcpy_debug_assert_memcpy_start
     1f2:	d011      	beq.n	218 <.neul_memcpy_debug_assert_memcpy_start>
    blt   .neul_memcpy_debug_assert_dest_lt_src
     1f4:	db04      	blt.n	200 <.neul_memcpy_debug_assert_dest_lt_src>

000001f6 <.neul_memcpy_debug_assert_dest_gt_src>:
.neul_memcpy_debug_assert_dest_gt_src:
    mov   r3, r1              /* r3 is our only temp register here */
     1f6:	460b      	mov	r3, r1
    adds  r3, r3, r2          /* Add the length to r3 */
     1f8:	189b      	adds	r3, r3, r2
    cmp   r3, r0              /* Compare src+length with dest, assert if r3>r0 */
     1fa:	4283      	cmp	r3, r0
    bgt   .neul_memcpy_debug_assert
     1fc:	dc05      	bgt.n	20a <.neul_memcpy_debug_assert>
    b     .neul_memcpy_debug_assert_memcpy_start
     1fe:	e00b      	b.n	218 <.neul_memcpy_debug_assert_memcpy_start>

00000200 <.neul_memcpy_debug_assert_dest_lt_src>:

.neul_memcpy_debug_assert_dest_lt_src:
    mov   r3, r0              /* r3 is our only temp register here */
     200:	4603      	mov	r3, r0
    adds  r3, r3, r2          /* Add the length to r3 */
     202:	189b      	adds	r3, r3, r2
    cmp   r3, r1              /* Compare dest+length with src, assert if r3>r1 */
     204:	428b      	cmp	r3, r1
    bgt   .neul_memcpy_debug_assert
     206:	dc00      	bgt.n	20a <.neul_memcpy_debug_assert>
    b     .neul_memcpy_debug_assert_memcpy_start
     208:	e006      	b.n	218 <.neul_memcpy_debug_assert_memcpy_start>

0000020a <.neul_memcpy_debug_assert>:

.neul_memcpy_debug_assert:
    mov r0, lr
     20a:	4670      	mov	r0, lr
    push {lr}
     20c:	b500      	push	{lr}
    bl  __asm_memcpy_assert
     20e:	f01b fa7b 	bl	1b708 <__asm_memcpy_assert>
    pop  {r0}
     212:	bc01      	pop	{r0}
    mov  lr, r0               /* Lets re-setup the return address to help any debugger that comes along */
     214:	4686      	mov	lr, r0
    b    .                    /* we have trashed our r0, we cannot continue even if the assert returns */
     216:	e7fe      	b.n	216 <.neul_memcpy_debug_assert+0xc>

00000218 <.neul_memcpy_debug_assert_memcpy_start>:
.neul_memcpy_debug_assert_memcpy_start:
#endif

    cmp   r2, #5              /* This function is not safe if the length is 0, lets fix that */
     218:	2a05      	cmp	r2, #5
    blt   .neul_memcpy_small_start   
     21a:	db27      	blt.n	26c <.neul_memcpy_small_start>

0000021c <.neul_memcpy_start>:
.neul_memcpy_start:
    
    push  {r0, r4-r7}         /* Lets save the registers early in this version */
     21c:	b4f1      	push	{r0, r4, r5, r6, r7}

0000021e <.neul_memcpy_realign>:

.neul_memcpy_realign:                  
    mov   r5, r0              /* And operations are 'destructive' so lets copy first */
     21e:	4605      	mov	r5, r0
    mov   r6, r1            
     220:	460e      	mov	r6, r1
    ldr   r7, =#3             /* If the bottom two bits are set, we are not aligned */
     222:	4f2c      	ldr	r7, [pc, #176]	; (2d4 <.neul_memcpy_unaligned_dest_end+0x4>)
                            
    ands  r5, r5, r7          /* r5 = r5 & 0x03 */
     224:	403d      	ands	r5, r7
    bgt .neul_memcpy_dst_ul   /* Branch to dest not aligned */
     226:	dc28      	bgt.n	27a <.neul_memcpy_dst_ul>
    ands  r6, r6, r7        
     228:	403e      	ands	r6, r7
    bgt .neul_memcpy_src_ul   /* Branch to src not aligned */
     22a:	dc37      	bgt.n	29c <.neul_memcpy_src_ul>

0000022c <.neul_memcpy_20_check>:
                              /* We are aligned, just need to copy */
.neul_memcpy_20_check:
    cmp   r2, #20            
     22c:	2a14      	cmp	r2, #20
    blt .neul_memcpy_12_check /* if less than, jump to byte by byte */
     22e:	db05      	blt.n	23c <.neul_memcpy_12_check>

00000230 <.neul_memcpy_20>:

.align 4
.neul_memcpy_20:              /* 20 Byte loop */
    ldmia r1!, {r3-r7}      
     230:	c9f8      	ldmia	r1!, {r3, r4, r5, r6, r7}
    stmia r0!, {r3-r7}      
     232:	c0f8      	stmia	r0!, {r3, r4, r5, r6, r7}
    subs  r2, r2, #20         /* Subtract our count by 20 */
     234:	3a14      	subs	r2, #20
    beq .neul_memcpy_end      /* Done, time to end */
     236:	d017      	beq.n	268 <.neul_memcpy_end>
    cmp   r2, #20            
     238:	2a14      	cmp	r2, #20
    bge .neul_memcpy_20       /* More to do, so back we go */
     23a:	daf9      	bge.n	230 <.neul_memcpy_20>

0000023c <.neul_memcpy_12_check>:

.neul_memcpy_12_check:
    cmp   r2, #12            
     23c:	2a0c      	cmp	r2, #12
    blt .neul_memcpy_4_check
     23e:	db03      	blt.n	248 <.neul_memcpy_4_check>
    
    ldmia r1!, {r5-r7}      
     240:	c9e0      	ldmia	r1!, {r5, r6, r7}
    stmia r0!, {r5-r7}      
     242:	c0e0      	stmia	r0!, {r5, r6, r7}
    subs  r2, r2, #12
     244:	3a0c      	subs	r2, #12
    beq .neul_memcpy_end
     246:	d00f      	beq.n	268 <.neul_memcpy_end>

00000248 <.neul_memcpy_4_check>:
    
.neul_memcpy_4_check:
    cmp   r2, #4            
     248:	2a04      	cmp	r2, #4
    blt .neul_memcpy_1_start	/* We cannot have 0 left (checked at start and after each subs) */
     24a:	db09      	blt.n	260 <.neul_memcpy_1_start>
     24c:	46c0      	nop			; (mov r8, r8)
     24e:	46c0      	nop			; (mov r8, r8)

00000250 <.neul_memcpy_4>:
.align 4
.neul_memcpy_4:
    ldmia r1!, {r7}      
     250:	c980      	ldmia	r1!, {r7}
    stmia r0!, {r7}      
     252:	c080      	stmia	r0!, {r7}
    subs  r2, r2, #4
     254:	3a04      	subs	r2, #4
    beq .neul_memcpy_end
     256:	d007      	beq.n	268 <.neul_memcpy_end>
    cmp   r2, #4            
     258:	2a04      	cmp	r2, #4
    bge .neul_memcpy_4
     25a:	daf9      	bge.n	250 <.neul_memcpy_4>
     25c:	46c0      	nop			; (mov r8, r8)
     25e:	46c0      	nop			; (mov r8, r8)

00000260 <.neul_memcpy_1_start>:
 
.align 3       
.neul_memcpy_1_start:
    subs  r2, r2, #1
     260:	3a01      	subs	r2, #1
    ldrb  r4, [r1, r2]          
     262:	5c8c      	ldrb	r4, [r1, r2]
    strb  r4, [r0, r2]      
     264:	5484      	strb	r4, [r0, r2]
    bgt   .neul_memcpy_1_start                   
     266:	dcfb      	bgt.n	260 <.neul_memcpy_1_start>

00000268 <.neul_memcpy_end>:
                            
.neul_memcpy_end:           
    pop   {r0, r4-r7}
     268:	bcf1      	pop	{r0, r4, r5, r6, r7}
    RET
     26a:	46f7      	mov	pc, lr

0000026c <.neul_memcpy_small_start>:
    
/* A small byte by byte copy loop, can only be used before the registers get pushed (only changes r2) */
.neul_memcpy_small_start:
    cmp   r2, #0
     26c:	2a00      	cmp	r2, #0
    beq   .neul_memcpy_small_end
     26e:	d003      	beq.n	278 <.neul_memcpy_small_end>

00000270 <.neul_memcpy_small>:
.align 3
.neul_memcpy_small:
    subs  r2, r2, #1
     270:	3a01      	subs	r2, #1
    ldrb  r3, [r1, r2]          
     272:	5c8b      	ldrb	r3, [r1, r2]
    strb  r3, [r0, r2]
     274:	5483      	strb	r3, [r0, r2]
    bgt     .neul_memcpy_small
     276:	dcfb      	bgt.n	270 <.neul_memcpy_small>

00000278 <.neul_memcpy_small_end>:
.neul_memcpy_small_end:
    RET
     278:	46f7      	mov	pc, lr

0000027a <.neul_memcpy_dst_ul>:
    
.neul_memcpy_dst_ul:
    cmp   r2, #20             /* Setting up the main loop is not easy, for less */
     27a:	2a14      	cmp	r2, #20
    blt   .neul_memcpy_1_start/* than 20 bytes its better to just byte by byte it */
     27c:	dbf0      	blt.n	260 <.neul_memcpy_1_start>
    
/*  Step 1 - Align Dest (r0) r5 already contains (Dest & 0x03)*/
    mov   r6,  r2
     27e:	4616      	mov	r6, r2
    ldr   r3, =#4
     280:	4b15      	ldr	r3, [pc, #84]	; (2d8 <.neul_memcpy_unaligned_dest_end+0x8>)
    subs  r2,  r3, r5		  /* r2 = 4 - r5 where r5 has to be 1-3 */
     282:	1b5a      	subs	r2, r3, r5
    subs  r6, r6, r2          /* since we are about to write this we need to subs it */
     284:	1ab6      	subs	r6, r6, r2
    mov   r5, r2              /* we need to store the amount we are writing */
     286:	4615      	mov	r5, r2

00000288 <.neul_memcpy_small_unaligned>:

.neul_memcpy_small_unaligned: /* Align our dest location by copying 1 to 3 bytes */
    subs  r2, r2, #1
     288:	3a01      	subs	r2, #1
    ldrb  r3, [r1, r2]          
     28a:	5c8b      	ldrb	r3, [r1, r2]
    strb  r3, [r0, r2]
     28c:	5483      	strb	r3, [r0, r2]
    bgt     .neul_memcpy_small_unaligned
     28e:	dcfb      	bgt.n	288 <.neul_memcpy_small_unaligned>

    mov   r2, r6              /* Move the amount left back */
     290:	4632      	mov	r2, r6
    
    adds  r0, r0, r5          /* move both the src and dest pointer on */
     292:	1940      	adds	r0, r0, r5
    adds  r1, r1, r5          
     294:	1949      	adds	r1, r1, r5
    
    mov   r6, r1              /* move the current src location into r6 */
     296:	460e      	mov	r6, r1
    ands  r6, r6, r7          /* r7 is still #3, as set above */
     298:	403e      	ands	r6, r7
    beq  .neul_memcpy_realign /* We are now fully aligned, re-go as normal */
     29a:	d0c0      	beq.n	21e <.neul_memcpy_realign>

0000029c <.neul_memcpy_src_ul>:

.neul_memcpy_src_ul:
/*  Step 2 - Dest is aligned, but src is not.  We need to align src down, the store shift values */
    mov   r5, r2              /* copy r2 (num of bytes) into r5 */
     29c:	4615      	mov	r5, r2
    bics  r5, r5, r7          /* mask of the end two bits (bit clear -> r5 = r5 & !r7), r7 is still #3 */
     29e:	43bd      	bics	r5, r7
    beq   .neul_memcpy_small_unaligned2  /* To get here we have to have somthing to write, but it is less than 4 bytes */
     2a0:	d012      	beq.n	2c8 <.neul_memcpy_small_unaligned2>
    subs  r2, r2, r5          /* reduce r2 by the number of bytes that will be written in the loop below */
     2a2:	1b52      	subs	r2, r2, r5
    
    adds  r5,  r5, r0		  /* For this loop, we need r5 to be the final write value */
     2a4:	182d      	adds	r5, r5, r0
    bics  r1,  r1, r7         /* bit clear the address so its aligned - I like this number (#3) it got used lots! */
     2a6:	43b9      	bics	r1, r7
    
    lsls  r6,  r6, #3         /* We need to work out the shift values */
     2a8:	00f6      	lsls	r6, r6, #3
    ldr   r7,  =#32           /* Good bye #3 :-( */
     2aa:	4f0c      	ldr	r7, [pc, #48]	; (2dc <.neul_memcpy_unaligned_dest_end+0xc>)
    subs  r7, r7, r6
     2ac:	1bbf      	subs	r7, r7, r6
     2ae:	46c0      	nop			; (mov r8, r8)

000002b0 <.neul_memcpy_unaligned_dest_loop>:
.align 4
.neul_memcpy_unaligned_dest_loop:
    ldmia r1!, {r3-r4}       /* Load in 2 full words from the unaligned source */
     2b0:	c918      	ldmia	r1!, {r3, r4}
    subs  r1,  r1, #4        /* Although we have loaded in 2 words, we will mangle them into 1, so only want to move the pointer by 4 */
     2b2:	3904      	subs	r1, #4
    lsrs  r3,  r3, r6        /* Shift the value in the first word right by r6 (8 ,16,24) */
     2b4:	40f3      	lsrs	r3, r6
    lsls  r4,  r4, r7        /* Shift the value in the second word left by r7 (24,16,8)  */
     2b6:	40bc      	lsls	r4, r7
    adds  r3,  r3, r4        /* Add them together to get 1 aligned word */
     2b8:	191b      	adds	r3, r3, r4
    stmia r0!, {r3}          /* store the word */
     2ba:	c008      	stmia	r0!, {r3}
    cmp   r0,  r5            /* Check if our dest pointer is at the stop location */
     2bc:	42a8      	cmp	r0, r5
    bne   .neul_memcpy_unaligned_dest_loop
     2be:	d1f7      	bne.n	2b0 <.neul_memcpy_unaligned_dest_loop>
    
    cmp   r2, #0
     2c0:	2a00      	cmp	r2, #0
    beq   .neul_memcpy_unaligned_dest_end
     2c2:	d005      	beq.n	2d0 <.neul_memcpy_unaligned_dest_end>

    lsrs  r6,  r6, #3         /* this register contained the '>> x' value, which was the lowest 2 bits of r1 << 3 */
     2c4:	08f6      	lsrs	r6, r6, #3
    adds  r1,  r1, r6         /* We now need to add the unalignment back to r1, which we get by shifting r6 back then adding on to r1 */
     2c6:	1989      	adds	r1, r1, r6

000002c8 <.neul_memcpy_small_unaligned2>:
    
.neul_memcpy_small_unaligned2:/* Copy the remaining bytes 1-3, no need to align, as we should still be aligned from above */
    subs  r2, r2, #1
     2c8:	3a01      	subs	r2, #1
    ldrb  r3, [r1, r2]          
     2ca:	5c8b      	ldrb	r3, [r1, r2]
    strb  r3, [r0, r2]
     2cc:	5483      	strb	r3, [r0, r2]
    bgt     .neul_memcpy_small_unaligned2
     2ce:	dcfb      	bgt.n	2c8 <.neul_memcpy_small_unaligned2>

000002d0 <.neul_memcpy_unaligned_dest_end>:
.neul_memcpy_unaligned_dest_end:
    pop   {r0, r4-r7}
     2d0:	bcf1      	pop	{r0, r4, r5, r6, r7}
    RET
     2d2:	46f7      	mov	pc, lr
    ldr   r7, =#3             /* If the bottom two bits are set, we are not aligned */
     2d4:	00000003 	.word	0x00000003
    ldr   r3, =#4
     2d8:	00000004 	.word	0x00000004
    ldr   r7,  =#32           /* Good bye #3 :-( */
     2dc:	00000020 	.word	0x00000020

000002e0 <memset>:

#include <asm.h>

/* LINTSTUB: Func: void *memset(void *dst, int ch, size_t count) */
ENTRY(memset)
    cmp   r2, #7              /* For small values, we might as well byte by byte it */
     2e0:	2a07      	cmp	r2, #7
    blt   .neul_memset_small_start
     2e2:	db45      	blt.n	370 <.neul_memset_small_start>
    
    lsrs  r3, r0, #2          /* This block checks if we are aligned */
     2e4:	0883      	lsrs	r3, r0, #2
    lsls  r3, r3, #2          /* Masks off the bottom two bits of r0 into r3 (x >> 2) << 2 */
     2e6:	009b      	lsls	r3, r3, #2
    eors  r3, r3, r0          /* Then xors them together and checks if >0 */
     2e8:	4043      	eors	r3, r0
    bgt   .neul_memset_dst_ul
     2ea:	dc47      	bgt.n	37c <.neul_memset_dst_ul>
    
    cmp   r2, #24             /* Due to the setup of large writes we will have a shortened loop for under 24 */
     2ec:	2a18      	cmp	r2, #24
    blt   .neul_memset_mid_start
     2ee:	db29      	blt.n	344 <.neul_memset_mid_start>
    
    push  {r0, r4-r7}         /* A large memset, lets use all the low registers */
     2f0:	b4f1      	push	{r0, r4, r5, r6, r7}
    
    lsls  r1, r1, #24         /* We want to be able to word write, so extend our char into a full word */
     2f2:	0609      	lsls	r1, r1, #24
    lsrs  r3, r1, #8
     2f4:	0a0b      	lsrs	r3, r1, #8
    orrs  r1, r1, r3
     2f6:	4319      	orrs	r1, r3
    lsrs  r3, r1, #16
     2f8:	0c0b      	lsrs	r3, r1, #16
    orrs  r1, r1, r3
     2fa:	4319      	orrs	r1, r3

000002fc <.neul_memset_realigned_large>:
    
.neul_memset_realigned_large:
    mov   r3, r1              /* Copy the full word to the other registers for multiple writes */
     2fc:	460b      	mov	r3, r1
    mov   r4, r1
     2fe:	460c      	mov	r4, r1
    mov   r5, r1
     300:	460d      	mov	r5, r1
    mov   r6, r1
     302:	460e      	mov	r6, r1
    mov   r7, r1
     304:	460f      	mov	r7, r1
     306:	46c0      	nop			; (mov r8, r8)
     308:	46c0      	nop			; (mov r8, r8)
     30a:	46c0      	nop			; (mov r8, r8)
     30c:	46c0      	nop			; (mov r8, r8)
     30e:	46c0      	nop			; (mov r8, r8)

00000310 <.neul_memset_24>:
    
.align 4
.neul_memset_24:              /* Loop through 24 bytes at a time */
    stmia r0!, {r1, r3-r7}
     310:	c0fa      	stmia	r0!, {r1, r3, r4, r5, r6, r7}
    subs  r2, r2, #24
     312:	3a18      	subs	r2, #24
    beq   .neul_memset_end
     314:	d014      	beq.n	340 <.neul_memset_end>
    cmp   r2, #24
     316:	2a18      	cmp	r2, #24
    bge .neul_memset_24       /* More to do, so back we go */
     318:	dafa      	bge.n	310 <.neul_memset_24>

0000031a <.neul_memset_12_check>:
    
.neul_memset_12_check:        /* Check for 12 bytes */
    cmp   r2, #12
     31a:	2a0c      	cmp	r2, #12
    blt   .neul_memset_4_check
     31c:	db02      	blt.n	324 <.neul_memset_4_check>

    stmia r0!, {r1, r3-r4}
     31e:	c01a      	stmia	r0!, {r1, r3, r4}
    subs  r2, r2, #12
     320:	3a0c      	subs	r2, #12
    beq   .neul_memset_end
     322:	d00d      	beq.n	340 <.neul_memset_end>

00000324 <.neul_memset_4_check>:
    
.neul_memset_4_check:         /* Check for 4 bytes */
    cmp   r2, #4
     324:	2a04      	cmp	r2, #4
    blt   .neul_memset_1
     326:	db08      	blt.n	33a <.neul_memset_1>
     328:	46c0      	nop			; (mov r8, r8)
     32a:	46c0      	nop			; (mov r8, r8)
     32c:	46c0      	nop			; (mov r8, r8)
     32e:	46c0      	nop			; (mov r8, r8)

00000330 <.neul_memset_4>:
.align 4                      /* NOTE - This align covers both loops, if the loops change, consider adding another align */
.neul_memset_4:               /* Loop through 4 bytes at a time */
    stmia r0!, {r1}
     330:	c002      	stmia	r0!, {r1}
    subs  r2, r2, #4
     332:	3a04      	subs	r2, #4
    beq   .neul_memset_end
     334:	d004      	beq.n	340 <.neul_memset_end>
    cmp   r2, #4
     336:	2a04      	cmp	r2, #4
    bge .neul_memset_4        /* More to do, so back we go */
     338:	dafa      	bge.n	330 <.neul_memset_4>

0000033a <.neul_memset_1>:
.neul_memset_1:               /* Loop through 1 byte at a time */
    subs  r2, r2, #1
     33a:	3a01      	subs	r2, #1
    strb  r1, [r0, r2]      
     33c:	5481      	strb	r1, [r0, r2]
    bgt   .neul_memset_1
     33e:	dcfc      	bgt.n	33a <.neul_memset_1>

00000340 <.neul_memset_end>:
.neul_memset_end:
    pop   {r0, r4-r7}         /* Pop the required registers */
     340:	bcf1      	pop	{r0, r4, r5, r6, r7}
    RET                       /* And done */
     342:	46f7      	mov	pc, lr

00000344 <.neul_memset_mid_start>:

    /* For values under 24 we are faster skipping the stack push and reg copy and doing just word at a time */
.neul_memset_mid_start:
    lsls  r1, r1, #24         /* We want to be able to word write, so extend our char into a full word */
     344:	0609      	lsls	r1, r1, #24
    lsrs  r3, r1, #8
     346:	0a0b      	lsrs	r3, r1, #8
    orrs  r1, r1, r3
     348:	4319      	orrs	r1, r3
    lsrs  r3, r1, #16
     34a:	0c0b      	lsrs	r3, r1, #16
    orrs  r1, r1, r3
     34c:	4319      	orrs	r1, r3
    mov   r3, r0              /* At the end, r0 has to be unchanged, so lets work with r3 in this loop */
     34e:	4603      	mov	r3, r0

00000350 <.neul_memset_mid_4>:
.align 4                      /* NOTE - This align covers both loops, if the loops change, consider adding another align */
.neul_memset_mid_4:
    stmia r3!, {r1}
     350:	c302      	stmia	r3!, {r1}
    subs  r2, r2, #4
     352:	3a04      	subs	r2, #4
    beq   .neul_memset_mid_end
     354:	d004      	beq.n	360 <.neul_memset_mid_end>
    cmp   r2, #4
     356:	2a04      	cmp	r2, #4
    bge  .neul_memset_mid_4        /* More to do, so back we go */
     358:	dafa      	bge.n	350 <.neul_memset_mid_4>

0000035a <.neul_memset_mid_1>:
.neul_memset_mid_1:
    subs  r2, r2, #1
     35a:	3a01      	subs	r2, #1
    strb  r1, [r3, r2]
     35c:	5499      	strb	r1, [r3, r2]
    bgt   .neul_memset_mid_1
     35e:	dcfc      	bgt.n	35a <.neul_memset_mid_1>

00000360 <.neul_memset_mid_end>:
.neul_memset_mid_end:
    RET
     360:	46f7      	mov	pc, lr
     362:	46c0      	nop			; (mov r8, r8)
     364:	46c0      	nop			; (mov r8, r8)
     366:	46c0      	nop			; (mov r8, r8)
     368:	46c0      	nop			; (mov r8, r8)
     36a:	46c0      	nop			; (mov r8, r8)
     36c:	46c0      	nop			; (mov r8, r8)
     36e:	46c0      	nop			; (mov r8, r8)

00000370 <.neul_memset_small_start>:

.align 4
    /* A small byte by byte set loop, can only be used before the registers get pushed (only changes r2) */
.neul_memset_small_start:
    cmp   r2, #0
     370:	2a00      	cmp	r2, #0
    beq   .neul_memset_small_end
     372:	d002      	beq.n	37a <.neul_memset_small_end>

00000374 <.neul_memset_small>:
.neul_memset_small:
    subs  r2, r2, #1
     374:	3a01      	subs	r2, #1
    strb  r1, [r0, r2]
     376:	5481      	strb	r1, [r0, r2]
    bgt   .neul_memset_small
     378:	dcfc      	bgt.n	374 <.neul_memset_small>

0000037a <.neul_memset_small_end>:
.neul_memset_small_end:
    RET
     37a:	46f7      	mov	pc, lr

0000037c <.neul_memset_dst_ul>:

.neul_memset_dst_ul:          /* To get here we know we have at least 7 bytes to set, so we can set up our word */
    push  {r0, r4-r7}         /* We need to preserve the origional r0 to return it, mixing pushes is hard, so just push everything */
     37c:	b4f1      	push	{r0, r4, r5, r6, r7}
    lsls  r1, r1, #24         /* We want to be able to word write, so extend our char into a full word */
     37e:	0609      	lsls	r1, r1, #24
    lsrs  r3, r1, #8
     380:	0a0b      	lsrs	r3, r1, #8
    orrs  r1, r1, r3
     382:	4319      	orrs	r1, r3
    lsrs  r3, r1, #16
     384:	0c0b      	lsrs	r3, r1, #16
    orrs  r1, r1, r3
     386:	4319      	orrs	r1, r3
    
    lsls  r3, r0, #30         /* And off all but the last two bits by ((x << 30) >> 30) */
     388:	0783      	lsls	r3, r0, #30
    lsrs  r3, r3, #30         /* #4-r3 is now the number of bytes needed to write to align r0 */
     38a:	0f9b      	lsrs	r3, r3, #30

0000038c <.neul_memset_align_loop>:
.neul_memset_align_loop:
    strb  r1, [r0]
     38c:	7001      	strb	r1, [r0, #0]
    adds  r0, r0, #1
     38e:	3001      	adds	r0, #1
    subs  r2, r2, #1
     390:	3a01      	subs	r2, #1
    adds  r3, r3, #1          /* This loop needs an extra command to increase and check r3 */
     392:	3301      	adds	r3, #1
    cmp   r3, #4
     394:	2b04      	cmp	r3, #4
    bne   .neul_memset_align_loop
     396:	d1f9      	bne.n	38c <.neul_memset_align_loop>

00000398 <.neul_memset_dst_ul_selection>:

.neul_memset_dst_ul_selection:
    cmp   r2, #24             /* We now need to check where in the normal memset to jump back to, now that we are aligned */
     398:	2a18      	cmp	r2, #24
    blt   .neul_memset_dst_ul_selection_small
     39a:	db00      	blt.n	39e <.neul_memset_dst_ul_selection_small>
    b     .neul_memset_realigned_large
     39c:	e7ae      	b.n	2fc <.neul_memset_realigned_large>

0000039e <.neul_memset_dst_ul_selection_small>:
.neul_memset_dst_ul_selection_small:
    mov   r3, r0
     39e:	4603      	mov	r3, r0
    pop   {r0, r4-r7}
     3a0:	bcf1      	pop	{r0, r4, r5, r6, r7}
    b     .neul_memset_mid_4
     3a2:	e7d5      	b.n	350 <.neul_memset_mid_4>

000003a4 <__gnu_thumb1_case_uqi>:
     3a4:	b402      	push	{r1}
     3a6:	4671      	mov	r1, lr
     3a8:	0849      	lsrs	r1, r1, #1
     3aa:	0049      	lsls	r1, r1, #1
     3ac:	5c09      	ldrb	r1, [r1, r0]
     3ae:	0049      	lsls	r1, r1, #1
     3b0:	448e      	add	lr, r1
     3b2:	bc02      	pop	{r1}
     3b4:	4770      	bx	lr
     3b6:	46c0      	nop			; (mov r8, r8)

000003b8 <__udivsi3>:
     3b8:	2200      	movs	r2, #0
     3ba:	0843      	lsrs	r3, r0, #1
     3bc:	428b      	cmp	r3, r1
     3be:	d374      	bcc.n	4aa <__SYSTEM_STACK_SIZE__+0xaa>
     3c0:	0903      	lsrs	r3, r0, #4
     3c2:	428b      	cmp	r3, r1
     3c4:	d35f      	bcc.n	486 <__SYSTEM_STACK_SIZE__+0x86>
     3c6:	0a03      	lsrs	r3, r0, #8
     3c8:	428b      	cmp	r3, r1
     3ca:	d344      	bcc.n	456 <__SYSTEM_STACK_SIZE__+0x56>
     3cc:	0b03      	lsrs	r3, r0, #12
     3ce:	428b      	cmp	r3, r1
     3d0:	d328      	bcc.n	424 <__SYSTEM_STACK_SIZE__+0x24>
     3d2:	0c03      	lsrs	r3, r0, #16
     3d4:	428b      	cmp	r3, r1
     3d6:	d30d      	bcc.n	3f4 <__udivsi3+0x3c>
     3d8:	22ff      	movs	r2, #255	; 0xff
     3da:	0209      	lsls	r1, r1, #8
     3dc:	ba12      	rev	r2, r2
     3de:	0c03      	lsrs	r3, r0, #16
     3e0:	428b      	cmp	r3, r1
     3e2:	d302      	bcc.n	3ea <__udivsi3+0x32>
     3e4:	1212      	asrs	r2, r2, #8
     3e6:	0209      	lsls	r1, r1, #8
     3e8:	d065      	beq.n	4b6 <__SYSTEM_STACK_SIZE__+0xb6>
     3ea:	0b03      	lsrs	r3, r0, #12
     3ec:	428b      	cmp	r3, r1
     3ee:	d319      	bcc.n	424 <__SYSTEM_STACK_SIZE__+0x24>
     3f0:	e000      	b.n	3f4 <__udivsi3+0x3c>
     3f2:	0a09      	lsrs	r1, r1, #8
     3f4:	0bc3      	lsrs	r3, r0, #15
     3f6:	428b      	cmp	r3, r1
     3f8:	d301      	bcc.n	3fe <__udivsi3+0x46>
     3fa:	03cb      	lsls	r3, r1, #15
     3fc:	1ac0      	subs	r0, r0, r3
     3fe:	4152      	adcs	r2, r2
     400:	0b83      	lsrs	r3, r0, #14
     402:	428b      	cmp	r3, r1
     404:	d301      	bcc.n	40a <__SYSTEM_STACK_SIZE__+0xa>
     406:	038b      	lsls	r3, r1, #14
     408:	1ac0      	subs	r0, r0, r3
     40a:	4152      	adcs	r2, r2
     40c:	0b43      	lsrs	r3, r0, #13
     40e:	428b      	cmp	r3, r1
     410:	d301      	bcc.n	416 <__SYSTEM_STACK_SIZE__+0x16>
     412:	034b      	lsls	r3, r1, #13
     414:	1ac0      	subs	r0, r0, r3
     416:	4152      	adcs	r2, r2
     418:	0b03      	lsrs	r3, r0, #12
     41a:	428b      	cmp	r3, r1
     41c:	d301      	bcc.n	422 <__SYSTEM_STACK_SIZE__+0x22>
     41e:	030b      	lsls	r3, r1, #12
     420:	1ac0      	subs	r0, r0, r3
     422:	4152      	adcs	r2, r2
     424:	0ac3      	lsrs	r3, r0, #11
     426:	428b      	cmp	r3, r1
     428:	d301      	bcc.n	42e <__SYSTEM_STACK_SIZE__+0x2e>
     42a:	02cb      	lsls	r3, r1, #11
     42c:	1ac0      	subs	r0, r0, r3
     42e:	4152      	adcs	r2, r2
     430:	0a83      	lsrs	r3, r0, #10
     432:	428b      	cmp	r3, r1
     434:	d301      	bcc.n	43a <__SYSTEM_STACK_SIZE__+0x3a>
     436:	028b      	lsls	r3, r1, #10
     438:	1ac0      	subs	r0, r0, r3
     43a:	4152      	adcs	r2, r2
     43c:	0a43      	lsrs	r3, r0, #9
     43e:	428b      	cmp	r3, r1
     440:	d301      	bcc.n	446 <__SYSTEM_STACK_SIZE__+0x46>
     442:	024b      	lsls	r3, r1, #9
     444:	1ac0      	subs	r0, r0, r3
     446:	4152      	adcs	r2, r2
     448:	0a03      	lsrs	r3, r0, #8
     44a:	428b      	cmp	r3, r1
     44c:	d301      	bcc.n	452 <__SYSTEM_STACK_SIZE__+0x52>
     44e:	020b      	lsls	r3, r1, #8
     450:	1ac0      	subs	r0, r0, r3
     452:	4152      	adcs	r2, r2
     454:	d2cd      	bcs.n	3f2 <__udivsi3+0x3a>
     456:	09c3      	lsrs	r3, r0, #7
     458:	428b      	cmp	r3, r1
     45a:	d301      	bcc.n	460 <__SYSTEM_STACK_SIZE__+0x60>
     45c:	01cb      	lsls	r3, r1, #7
     45e:	1ac0      	subs	r0, r0, r3
     460:	4152      	adcs	r2, r2
     462:	0983      	lsrs	r3, r0, #6
     464:	428b      	cmp	r3, r1
     466:	d301      	bcc.n	46c <__SYSTEM_STACK_SIZE__+0x6c>
     468:	018b      	lsls	r3, r1, #6
     46a:	1ac0      	subs	r0, r0, r3
     46c:	4152      	adcs	r2, r2
     46e:	0943      	lsrs	r3, r0, #5
     470:	428b      	cmp	r3, r1
     472:	d301      	bcc.n	478 <__SYSTEM_STACK_SIZE__+0x78>
     474:	014b      	lsls	r3, r1, #5
     476:	1ac0      	subs	r0, r0, r3
     478:	4152      	adcs	r2, r2
     47a:	0903      	lsrs	r3, r0, #4
     47c:	428b      	cmp	r3, r1
     47e:	d301      	bcc.n	484 <__SYSTEM_STACK_SIZE__+0x84>
     480:	010b      	lsls	r3, r1, #4
     482:	1ac0      	subs	r0, r0, r3
     484:	4152      	adcs	r2, r2
     486:	08c3      	lsrs	r3, r0, #3
     488:	428b      	cmp	r3, r1
     48a:	d301      	bcc.n	490 <__SYSTEM_STACK_SIZE__+0x90>
     48c:	00cb      	lsls	r3, r1, #3
     48e:	1ac0      	subs	r0, r0, r3
     490:	4152      	adcs	r2, r2
     492:	0883      	lsrs	r3, r0, #2
     494:	428b      	cmp	r3, r1
     496:	d301      	bcc.n	49c <__SYSTEM_STACK_SIZE__+0x9c>
     498:	008b      	lsls	r3, r1, #2
     49a:	1ac0      	subs	r0, r0, r3
     49c:	4152      	adcs	r2, r2
     49e:	0843      	lsrs	r3, r0, #1
     4a0:	428b      	cmp	r3, r1
     4a2:	d301      	bcc.n	4a8 <__SYSTEM_STACK_SIZE__+0xa8>
     4a4:	004b      	lsls	r3, r1, #1
     4a6:	1ac0      	subs	r0, r0, r3
     4a8:	4152      	adcs	r2, r2
     4aa:	1a41      	subs	r1, r0, r1
     4ac:	d200      	bcs.n	4b0 <__SYSTEM_STACK_SIZE__+0xb0>
     4ae:	4601      	mov	r1, r0
     4b0:	4152      	adcs	r2, r2
     4b2:	4610      	mov	r0, r2
     4b4:	4770      	bx	lr
     4b6:	e7ff      	b.n	4b8 <__SYSTEM_STACK_SIZE__+0xb8>
     4b8:	b501      	push	{r0, lr}
     4ba:	2000      	movs	r0, #0
     4bc:	f000 f8f0 	bl	6a0 <__aeabi_idiv0>
     4c0:	bd02      	pop	{r1, pc}
     4c2:	46c0      	nop			; (mov r8, r8)

000004c4 <__aeabi_uidivmod>:
     4c4:	2900      	cmp	r1, #0
     4c6:	d0f7      	beq.n	4b8 <__SYSTEM_STACK_SIZE__+0xb8>
     4c8:	e776      	b.n	3b8 <__udivsi3>
     4ca:	4770      	bx	lr

000004cc <__divsi3>:
     4cc:	4603      	mov	r3, r0
     4ce:	430b      	orrs	r3, r1
     4d0:	d47f      	bmi.n	5d2 <__divsi3+0x106>
     4d2:	2200      	movs	r2, #0
     4d4:	0843      	lsrs	r3, r0, #1
     4d6:	428b      	cmp	r3, r1
     4d8:	d374      	bcc.n	5c4 <__divsi3+0xf8>
     4da:	0903      	lsrs	r3, r0, #4
     4dc:	428b      	cmp	r3, r1
     4de:	d35f      	bcc.n	5a0 <__divsi3+0xd4>
     4e0:	0a03      	lsrs	r3, r0, #8
     4e2:	428b      	cmp	r3, r1
     4e4:	d344      	bcc.n	570 <__divsi3+0xa4>
     4e6:	0b03      	lsrs	r3, r0, #12
     4e8:	428b      	cmp	r3, r1
     4ea:	d328      	bcc.n	53e <__divsi3+0x72>
     4ec:	0c03      	lsrs	r3, r0, #16
     4ee:	428b      	cmp	r3, r1
     4f0:	d30d      	bcc.n	50e <__divsi3+0x42>
     4f2:	22ff      	movs	r2, #255	; 0xff
     4f4:	0209      	lsls	r1, r1, #8
     4f6:	ba12      	rev	r2, r2
     4f8:	0c03      	lsrs	r3, r0, #16
     4fa:	428b      	cmp	r3, r1
     4fc:	d302      	bcc.n	504 <__divsi3+0x38>
     4fe:	1212      	asrs	r2, r2, #8
     500:	0209      	lsls	r1, r1, #8
     502:	d065      	beq.n	5d0 <__divsi3+0x104>
     504:	0b03      	lsrs	r3, r0, #12
     506:	428b      	cmp	r3, r1
     508:	d319      	bcc.n	53e <__divsi3+0x72>
     50a:	e000      	b.n	50e <__divsi3+0x42>
     50c:	0a09      	lsrs	r1, r1, #8
     50e:	0bc3      	lsrs	r3, r0, #15
     510:	428b      	cmp	r3, r1
     512:	d301      	bcc.n	518 <__divsi3+0x4c>
     514:	03cb      	lsls	r3, r1, #15
     516:	1ac0      	subs	r0, r0, r3
     518:	4152      	adcs	r2, r2
     51a:	0b83      	lsrs	r3, r0, #14
     51c:	428b      	cmp	r3, r1
     51e:	d301      	bcc.n	524 <__divsi3+0x58>
     520:	038b      	lsls	r3, r1, #14
     522:	1ac0      	subs	r0, r0, r3
     524:	4152      	adcs	r2, r2
     526:	0b43      	lsrs	r3, r0, #13
     528:	428b      	cmp	r3, r1
     52a:	d301      	bcc.n	530 <__divsi3+0x64>
     52c:	034b      	lsls	r3, r1, #13
     52e:	1ac0      	subs	r0, r0, r3
     530:	4152      	adcs	r2, r2
     532:	0b03      	lsrs	r3, r0, #12
     534:	428b      	cmp	r3, r1
     536:	d301      	bcc.n	53c <__divsi3+0x70>
     538:	030b      	lsls	r3, r1, #12
     53a:	1ac0      	subs	r0, r0, r3
     53c:	4152      	adcs	r2, r2
     53e:	0ac3      	lsrs	r3, r0, #11
     540:	428b      	cmp	r3, r1
     542:	d301      	bcc.n	548 <__divsi3+0x7c>
     544:	02cb      	lsls	r3, r1, #11
     546:	1ac0      	subs	r0, r0, r3
     548:	4152      	adcs	r2, r2
     54a:	0a83      	lsrs	r3, r0, #10
     54c:	428b      	cmp	r3, r1
     54e:	d301      	bcc.n	554 <__divsi3+0x88>
     550:	028b      	lsls	r3, r1, #10
     552:	1ac0      	subs	r0, r0, r3
     554:	4152      	adcs	r2, r2
     556:	0a43      	lsrs	r3, r0, #9
     558:	428b      	cmp	r3, r1
     55a:	d301      	bcc.n	560 <__divsi3+0x94>
     55c:	024b      	lsls	r3, r1, #9
     55e:	1ac0      	subs	r0, r0, r3
     560:	4152      	adcs	r2, r2
     562:	0a03      	lsrs	r3, r0, #8
     564:	428b      	cmp	r3, r1
     566:	d301      	bcc.n	56c <__divsi3+0xa0>
     568:	020b      	lsls	r3, r1, #8
     56a:	1ac0      	subs	r0, r0, r3
     56c:	4152      	adcs	r2, r2
     56e:	d2cd      	bcs.n	50c <__divsi3+0x40>
     570:	09c3      	lsrs	r3, r0, #7
     572:	428b      	cmp	r3, r1
     574:	d301      	bcc.n	57a <__divsi3+0xae>
     576:	01cb      	lsls	r3, r1, #7
     578:	1ac0      	subs	r0, r0, r3
     57a:	4152      	adcs	r2, r2
     57c:	0983      	lsrs	r3, r0, #6
     57e:	428b      	cmp	r3, r1
     580:	d301      	bcc.n	586 <__divsi3+0xba>
     582:	018b      	lsls	r3, r1, #6
     584:	1ac0      	subs	r0, r0, r3
     586:	4152      	adcs	r2, r2
     588:	0943      	lsrs	r3, r0, #5
     58a:	428b      	cmp	r3, r1
     58c:	d301      	bcc.n	592 <__divsi3+0xc6>
     58e:	014b      	lsls	r3, r1, #5
     590:	1ac0      	subs	r0, r0, r3
     592:	4152      	adcs	r2, r2
     594:	0903      	lsrs	r3, r0, #4
     596:	428b      	cmp	r3, r1
     598:	d301      	bcc.n	59e <__divsi3+0xd2>
     59a:	010b      	lsls	r3, r1, #4
     59c:	1ac0      	subs	r0, r0, r3
     59e:	4152      	adcs	r2, r2
     5a0:	08c3      	lsrs	r3, r0, #3
     5a2:	428b      	cmp	r3, r1
     5a4:	d301      	bcc.n	5aa <__divsi3+0xde>
     5a6:	00cb      	lsls	r3, r1, #3
     5a8:	1ac0      	subs	r0, r0, r3
     5aa:	4152      	adcs	r2, r2
     5ac:	0883      	lsrs	r3, r0, #2
     5ae:	428b      	cmp	r3, r1
     5b0:	d301      	bcc.n	5b6 <__divsi3+0xea>
     5b2:	008b      	lsls	r3, r1, #2
     5b4:	1ac0      	subs	r0, r0, r3
     5b6:	4152      	adcs	r2, r2
     5b8:	0843      	lsrs	r3, r0, #1
     5ba:	428b      	cmp	r3, r1
     5bc:	d301      	bcc.n	5c2 <__divsi3+0xf6>
     5be:	004b      	lsls	r3, r1, #1
     5c0:	1ac0      	subs	r0, r0, r3
     5c2:	4152      	adcs	r2, r2
     5c4:	1a41      	subs	r1, r0, r1
     5c6:	d200      	bcs.n	5ca <__divsi3+0xfe>
     5c8:	4601      	mov	r1, r0
     5ca:	4152      	adcs	r2, r2
     5cc:	4610      	mov	r0, r2
     5ce:	4770      	bx	lr
     5d0:	e05d      	b.n	68e <__divsi3+0x1c2>
     5d2:	0fca      	lsrs	r2, r1, #31
     5d4:	d000      	beq.n	5d8 <__divsi3+0x10c>
     5d6:	4249      	negs	r1, r1
     5d8:	1003      	asrs	r3, r0, #32
     5da:	d300      	bcc.n	5de <__divsi3+0x112>
     5dc:	4240      	negs	r0, r0
     5de:	4053      	eors	r3, r2
     5e0:	2200      	movs	r2, #0
     5e2:	469c      	mov	ip, r3
     5e4:	0903      	lsrs	r3, r0, #4
     5e6:	428b      	cmp	r3, r1
     5e8:	d32d      	bcc.n	646 <__divsi3+0x17a>
     5ea:	0a03      	lsrs	r3, r0, #8
     5ec:	428b      	cmp	r3, r1
     5ee:	d312      	bcc.n	616 <__divsi3+0x14a>
     5f0:	22fc      	movs	r2, #252	; 0xfc
     5f2:	0189      	lsls	r1, r1, #6
     5f4:	ba12      	rev	r2, r2
     5f6:	0a03      	lsrs	r3, r0, #8
     5f8:	428b      	cmp	r3, r1
     5fa:	d30c      	bcc.n	616 <__divsi3+0x14a>
     5fc:	0189      	lsls	r1, r1, #6
     5fe:	1192      	asrs	r2, r2, #6
     600:	428b      	cmp	r3, r1
     602:	d308      	bcc.n	616 <__divsi3+0x14a>
     604:	0189      	lsls	r1, r1, #6
     606:	1192      	asrs	r2, r2, #6
     608:	428b      	cmp	r3, r1
     60a:	d304      	bcc.n	616 <__divsi3+0x14a>
     60c:	0189      	lsls	r1, r1, #6
     60e:	d03a      	beq.n	686 <__divsi3+0x1ba>
     610:	1192      	asrs	r2, r2, #6
     612:	e000      	b.n	616 <__divsi3+0x14a>
     614:	0989      	lsrs	r1, r1, #6
     616:	09c3      	lsrs	r3, r0, #7
     618:	428b      	cmp	r3, r1
     61a:	d301      	bcc.n	620 <__divsi3+0x154>
     61c:	01cb      	lsls	r3, r1, #7
     61e:	1ac0      	subs	r0, r0, r3
     620:	4152      	adcs	r2, r2
     622:	0983      	lsrs	r3, r0, #6
     624:	428b      	cmp	r3, r1
     626:	d301      	bcc.n	62c <__divsi3+0x160>
     628:	018b      	lsls	r3, r1, #6
     62a:	1ac0      	subs	r0, r0, r3
     62c:	4152      	adcs	r2, r2
     62e:	0943      	lsrs	r3, r0, #5
     630:	428b      	cmp	r3, r1
     632:	d301      	bcc.n	638 <__divsi3+0x16c>
     634:	014b      	lsls	r3, r1, #5
     636:	1ac0      	subs	r0, r0, r3
     638:	4152      	adcs	r2, r2
     63a:	0903      	lsrs	r3, r0, #4
     63c:	428b      	cmp	r3, r1
     63e:	d301      	bcc.n	644 <__divsi3+0x178>
     640:	010b      	lsls	r3, r1, #4
     642:	1ac0      	subs	r0, r0, r3
     644:	4152      	adcs	r2, r2
     646:	08c3      	lsrs	r3, r0, #3
     648:	428b      	cmp	r3, r1
     64a:	d301      	bcc.n	650 <__divsi3+0x184>
     64c:	00cb      	lsls	r3, r1, #3
     64e:	1ac0      	subs	r0, r0, r3
     650:	4152      	adcs	r2, r2
     652:	0883      	lsrs	r3, r0, #2
     654:	428b      	cmp	r3, r1
     656:	d301      	bcc.n	65c <__divsi3+0x190>
     658:	008b      	lsls	r3, r1, #2
     65a:	1ac0      	subs	r0, r0, r3
     65c:	4152      	adcs	r2, r2
     65e:	d2d9      	bcs.n	614 <__divsi3+0x148>
     660:	0843      	lsrs	r3, r0, #1
     662:	428b      	cmp	r3, r1
     664:	d301      	bcc.n	66a <__divsi3+0x19e>
     666:	004b      	lsls	r3, r1, #1
     668:	1ac0      	subs	r0, r0, r3
     66a:	4152      	adcs	r2, r2
     66c:	1a41      	subs	r1, r0, r1
     66e:	d200      	bcs.n	672 <__divsi3+0x1a6>
     670:	4601      	mov	r1, r0
     672:	4663      	mov	r3, ip
     674:	4152      	adcs	r2, r2
     676:	105b      	asrs	r3, r3, #1
     678:	4610      	mov	r0, r2
     67a:	d301      	bcc.n	680 <__divsi3+0x1b4>
     67c:	4240      	negs	r0, r0
     67e:	2b00      	cmp	r3, #0
     680:	d500      	bpl.n	684 <__divsi3+0x1b8>
     682:	4249      	negs	r1, r1
     684:	4770      	bx	lr
     686:	4663      	mov	r3, ip
     688:	105b      	asrs	r3, r3, #1
     68a:	d300      	bcc.n	68e <__divsi3+0x1c2>
     68c:	4240      	negs	r0, r0
     68e:	b501      	push	{r0, lr}
     690:	2000      	movs	r0, #0
     692:	f000 f805 	bl	6a0 <__aeabi_idiv0>
     696:	bd02      	pop	{r1, pc}

00000698 <__aeabi_idivmod>:
     698:	2900      	cmp	r1, #0
     69a:	d0f8      	beq.n	68e <__divsi3+0x1c2>
     69c:	e716      	b.n	4cc <__divsi3>
     69e:	4770      	bx	lr

000006a0 <__aeabi_idiv0>:
     6a0:	4770      	bx	lr
     6a2:	46c0      	nop			; (mov r8, r8)

000006a4 <__aeabi_uldivmod>:
     6a4:	2b00      	cmp	r3, #0
     6a6:	d111      	bne.n	6cc <__aeabi_uldivmod+0x28>
     6a8:	2a00      	cmp	r2, #0
     6aa:	d10f      	bne.n	6cc <__aeabi_uldivmod+0x28>
     6ac:	2900      	cmp	r1, #0
     6ae:	d100      	bne.n	6b2 <__aeabi_uldivmod+0xe>
     6b0:	2800      	cmp	r0, #0
     6b2:	d002      	beq.n	6ba <__aeabi_uldivmod+0x16>
     6b4:	2100      	movs	r1, #0
     6b6:	43c9      	mvns	r1, r1
     6b8:	1c08      	adds	r0, r1, #0
     6ba:	b407      	push	{r0, r1, r2}
     6bc:	4802      	ldr	r0, [pc, #8]	; (6c8 <__aeabi_uldivmod+0x24>)
     6be:	a102      	add	r1, pc, #8	; (adr r1, 6c8 <__aeabi_uldivmod+0x24>)
     6c0:	1840      	adds	r0, r0, r1
     6c2:	9002      	str	r0, [sp, #8]
     6c4:	bd03      	pop	{r0, r1, pc}
     6c6:	46c0      	nop			; (mov r8, r8)
     6c8:	ffffffd9 	.word	0xffffffd9
     6cc:	b403      	push	{r0, r1}
     6ce:	4668      	mov	r0, sp
     6d0:	b501      	push	{r0, lr}
     6d2:	9802      	ldr	r0, [sp, #8]
     6d4:	f000 f830 	bl	738 <__udivmoddi4>
     6d8:	9b01      	ldr	r3, [sp, #4]
     6da:	469e      	mov	lr, r3
     6dc:	b002      	add	sp, #8
     6de:	bc0c      	pop	{r2, r3}
     6e0:	4770      	bx	lr
     6e2:	46c0      	nop			; (mov r8, r8)

000006e4 <__aeabi_lmul>:
     6e4:	b5f0      	push	{r4, r5, r6, r7, lr}
     6e6:	46ce      	mov	lr, r9
     6e8:	4647      	mov	r7, r8
     6ea:	0415      	lsls	r5, r2, #16
     6ec:	0c2d      	lsrs	r5, r5, #16
     6ee:	002e      	movs	r6, r5
     6f0:	b580      	push	{r7, lr}
     6f2:	0407      	lsls	r7, r0, #16
     6f4:	0c14      	lsrs	r4, r2, #16
     6f6:	0c3f      	lsrs	r7, r7, #16
     6f8:	4699      	mov	r9, r3
     6fa:	0c03      	lsrs	r3, r0, #16
     6fc:	437e      	muls	r6, r7
     6fe:	435d      	muls	r5, r3
     700:	4367      	muls	r7, r4
     702:	4363      	muls	r3, r4
     704:	197f      	adds	r7, r7, r5
     706:	0c34      	lsrs	r4, r6, #16
     708:	19e4      	adds	r4, r4, r7
     70a:	469c      	mov	ip, r3
     70c:	42a5      	cmp	r5, r4
     70e:	d903      	bls.n	718 <__aeabi_lmul+0x34>
     710:	2380      	movs	r3, #128	; 0x80
     712:	025b      	lsls	r3, r3, #9
     714:	4698      	mov	r8, r3
     716:	44c4      	add	ip, r8
     718:	464b      	mov	r3, r9
     71a:	4343      	muls	r3, r0
     71c:	4351      	muls	r1, r2
     71e:	0c25      	lsrs	r5, r4, #16
     720:	0436      	lsls	r6, r6, #16
     722:	4465      	add	r5, ip
     724:	0c36      	lsrs	r6, r6, #16
     726:	0424      	lsls	r4, r4, #16
     728:	19a4      	adds	r4, r4, r6
     72a:	195b      	adds	r3, r3, r5
     72c:	1859      	adds	r1, r3, r1
     72e:	0020      	movs	r0, r4
     730:	bc0c      	pop	{r2, r3}
     732:	4690      	mov	r8, r2
     734:	4699      	mov	r9, r3
     736:	bdf0      	pop	{r4, r5, r6, r7, pc}

00000738 <__udivmoddi4>:
     738:	b5f0      	push	{r4, r5, r6, r7, lr}
     73a:	464f      	mov	r7, r9
     73c:	4646      	mov	r6, r8
     73e:	46d6      	mov	lr, sl
     740:	b5c0      	push	{r6, r7, lr}
     742:	0004      	movs	r4, r0
     744:	b082      	sub	sp, #8
     746:	000d      	movs	r5, r1
     748:	4691      	mov	r9, r2
     74a:	4698      	mov	r8, r3
     74c:	428b      	cmp	r3, r1
     74e:	d82f      	bhi.n	7b0 <__udivmoddi4+0x78>
     750:	d02c      	beq.n	7ac <__udivmoddi4+0x74>
     752:	4641      	mov	r1, r8
     754:	4648      	mov	r0, r9
     756:	f001 f843 	bl	17e0 <__clzdi2>
     75a:	0029      	movs	r1, r5
     75c:	0006      	movs	r6, r0
     75e:	0020      	movs	r0, r4
     760:	f001 f83e 	bl	17e0 <__clzdi2>
     764:	1a33      	subs	r3, r6, r0
     766:	469c      	mov	ip, r3
     768:	3b20      	subs	r3, #32
     76a:	469a      	mov	sl, r3
     76c:	d500      	bpl.n	770 <__udivmoddi4+0x38>
     76e:	e076      	b.n	85e <__udivmoddi4+0x126>
     770:	464b      	mov	r3, r9
     772:	4652      	mov	r2, sl
     774:	4093      	lsls	r3, r2
     776:	001f      	movs	r7, r3
     778:	464b      	mov	r3, r9
     77a:	4662      	mov	r2, ip
     77c:	4093      	lsls	r3, r2
     77e:	001e      	movs	r6, r3
     780:	42af      	cmp	r7, r5
     782:	d828      	bhi.n	7d6 <__udivmoddi4+0x9e>
     784:	d025      	beq.n	7d2 <__udivmoddi4+0x9a>
     786:	4653      	mov	r3, sl
     788:	1ba4      	subs	r4, r4, r6
     78a:	41bd      	sbcs	r5, r7
     78c:	2b00      	cmp	r3, #0
     78e:	da00      	bge.n	792 <__udivmoddi4+0x5a>
     790:	e07b      	b.n	88a <__udivmoddi4+0x152>
     792:	2200      	movs	r2, #0
     794:	2300      	movs	r3, #0
     796:	9200      	str	r2, [sp, #0]
     798:	9301      	str	r3, [sp, #4]
     79a:	2301      	movs	r3, #1
     79c:	4652      	mov	r2, sl
     79e:	4093      	lsls	r3, r2
     7a0:	9301      	str	r3, [sp, #4]
     7a2:	2301      	movs	r3, #1
     7a4:	4662      	mov	r2, ip
     7a6:	4093      	lsls	r3, r2
     7a8:	9300      	str	r3, [sp, #0]
     7aa:	e018      	b.n	7de <__udivmoddi4+0xa6>
     7ac:	4282      	cmp	r2, r0
     7ae:	d9d0      	bls.n	752 <__udivmoddi4+0x1a>
     7b0:	2200      	movs	r2, #0
     7b2:	2300      	movs	r3, #0
     7b4:	9200      	str	r2, [sp, #0]
     7b6:	9301      	str	r3, [sp, #4]
     7b8:	9b0a      	ldr	r3, [sp, #40]	; 0x28
     7ba:	2b00      	cmp	r3, #0
     7bc:	d001      	beq.n	7c2 <__udivmoddi4+0x8a>
     7be:	601c      	str	r4, [r3, #0]
     7c0:	605d      	str	r5, [r3, #4]
     7c2:	9800      	ldr	r0, [sp, #0]
     7c4:	9901      	ldr	r1, [sp, #4]
     7c6:	b002      	add	sp, #8
     7c8:	bc1c      	pop	{r2, r3, r4}
     7ca:	4690      	mov	r8, r2
     7cc:	4699      	mov	r9, r3
     7ce:	46a2      	mov	sl, r4
     7d0:	bdf0      	pop	{r4, r5, r6, r7, pc}
     7d2:	42a3      	cmp	r3, r4
     7d4:	d9d7      	bls.n	786 <__udivmoddi4+0x4e>
     7d6:	2200      	movs	r2, #0
     7d8:	2300      	movs	r3, #0
     7da:	9200      	str	r2, [sp, #0]
     7dc:	9301      	str	r3, [sp, #4]
     7de:	4663      	mov	r3, ip
     7e0:	2b00      	cmp	r3, #0
     7e2:	d0e9      	beq.n	7b8 <__udivmoddi4+0x80>
     7e4:	07fb      	lsls	r3, r7, #31
     7e6:	4698      	mov	r8, r3
     7e8:	4641      	mov	r1, r8
     7ea:	0872      	lsrs	r2, r6, #1
     7ec:	430a      	orrs	r2, r1
     7ee:	087b      	lsrs	r3, r7, #1
     7f0:	4666      	mov	r6, ip
     7f2:	e00e      	b.n	812 <__udivmoddi4+0xda>
     7f4:	42ab      	cmp	r3, r5
     7f6:	d101      	bne.n	7fc <__udivmoddi4+0xc4>
     7f8:	42a2      	cmp	r2, r4
     7fa:	d80c      	bhi.n	816 <__udivmoddi4+0xde>
     7fc:	1aa4      	subs	r4, r4, r2
     7fe:	419d      	sbcs	r5, r3
     800:	2001      	movs	r0, #1
     802:	1924      	adds	r4, r4, r4
     804:	416d      	adcs	r5, r5
     806:	2100      	movs	r1, #0
     808:	3e01      	subs	r6, #1
     80a:	1824      	adds	r4, r4, r0
     80c:	414d      	adcs	r5, r1
     80e:	2e00      	cmp	r6, #0
     810:	d006      	beq.n	820 <__udivmoddi4+0xe8>
     812:	42ab      	cmp	r3, r5
     814:	d9ee      	bls.n	7f4 <__udivmoddi4+0xbc>
     816:	3e01      	subs	r6, #1
     818:	1924      	adds	r4, r4, r4
     81a:	416d      	adcs	r5, r5
     81c:	2e00      	cmp	r6, #0
     81e:	d1f8      	bne.n	812 <__udivmoddi4+0xda>
     820:	9800      	ldr	r0, [sp, #0]
     822:	9901      	ldr	r1, [sp, #4]
     824:	4653      	mov	r3, sl
     826:	1900      	adds	r0, r0, r4
     828:	4169      	adcs	r1, r5
     82a:	2b00      	cmp	r3, #0
     82c:	db23      	blt.n	876 <__udivmoddi4+0x13e>
     82e:	002b      	movs	r3, r5
     830:	4652      	mov	r2, sl
     832:	40d3      	lsrs	r3, r2
     834:	002a      	movs	r2, r5
     836:	4664      	mov	r4, ip
     838:	40e2      	lsrs	r2, r4
     83a:	001c      	movs	r4, r3
     83c:	4653      	mov	r3, sl
     83e:	0015      	movs	r5, r2
     840:	2b00      	cmp	r3, #0
     842:	db2d      	blt.n	8a0 <__udivmoddi4+0x168>
     844:	0026      	movs	r6, r4
     846:	4657      	mov	r7, sl
     848:	40be      	lsls	r6, r7
     84a:	0033      	movs	r3, r6
     84c:	0026      	movs	r6, r4
     84e:	4667      	mov	r7, ip
     850:	40be      	lsls	r6, r7
     852:	0032      	movs	r2, r6
     854:	1a80      	subs	r0, r0, r2
     856:	4199      	sbcs	r1, r3
     858:	9000      	str	r0, [sp, #0]
     85a:	9101      	str	r1, [sp, #4]
     85c:	e7ac      	b.n	7b8 <__udivmoddi4+0x80>
     85e:	4662      	mov	r2, ip
     860:	2320      	movs	r3, #32
     862:	1a9b      	subs	r3, r3, r2
     864:	464a      	mov	r2, r9
     866:	40da      	lsrs	r2, r3
     868:	4661      	mov	r1, ip
     86a:	0013      	movs	r3, r2
     86c:	4642      	mov	r2, r8
     86e:	408a      	lsls	r2, r1
     870:	0017      	movs	r7, r2
     872:	431f      	orrs	r7, r3
     874:	e780      	b.n	778 <__udivmoddi4+0x40>
     876:	4662      	mov	r2, ip
     878:	2320      	movs	r3, #32
     87a:	1a9b      	subs	r3, r3, r2
     87c:	002a      	movs	r2, r5
     87e:	4666      	mov	r6, ip
     880:	409a      	lsls	r2, r3
     882:	0023      	movs	r3, r4
     884:	40f3      	lsrs	r3, r6
     886:	4313      	orrs	r3, r2
     888:	e7d4      	b.n	834 <__udivmoddi4+0xfc>
     88a:	4662      	mov	r2, ip
     88c:	2320      	movs	r3, #32
     88e:	2100      	movs	r1, #0
     890:	1a9b      	subs	r3, r3, r2
     892:	2200      	movs	r2, #0
     894:	9100      	str	r1, [sp, #0]
     896:	9201      	str	r2, [sp, #4]
     898:	2201      	movs	r2, #1
     89a:	40da      	lsrs	r2, r3
     89c:	9201      	str	r2, [sp, #4]
     89e:	e780      	b.n	7a2 <__udivmoddi4+0x6a>
     8a0:	2320      	movs	r3, #32
     8a2:	4662      	mov	r2, ip
     8a4:	0026      	movs	r6, r4
     8a6:	1a9b      	subs	r3, r3, r2
     8a8:	40de      	lsrs	r6, r3
     8aa:	002f      	movs	r7, r5
     8ac:	46b0      	mov	r8, r6
     8ae:	4666      	mov	r6, ip
     8b0:	40b7      	lsls	r7, r6
     8b2:	4646      	mov	r6, r8
     8b4:	003b      	movs	r3, r7
     8b6:	4333      	orrs	r3, r6
     8b8:	e7c8      	b.n	84c <__udivmoddi4+0x114>
     8ba:	46c0      	nop			; (mov r8, r8)

000008bc <selfrel_offset31>:
     8bc:	6803      	ldr	r3, [r0, #0]
     8be:	005a      	lsls	r2, r3, #1
     8c0:	d403      	bmi.n	8ca <selfrel_offset31+0xe>
     8c2:	005b      	lsls	r3, r3, #1
     8c4:	085b      	lsrs	r3, r3, #1
     8c6:	18c0      	adds	r0, r0, r3
     8c8:	4770      	bx	lr
     8ca:	2280      	movs	r2, #128	; 0x80
     8cc:	0612      	lsls	r2, r2, #24
     8ce:	4313      	orrs	r3, r2
     8d0:	e7f9      	b.n	8c6 <selfrel_offset31+0xa>
     8d2:	46c0      	nop			; (mov r8, r8)

000008d4 <search_EIT_table>:
     8d4:	b5f0      	push	{r4, r5, r6, r7, lr}
     8d6:	4657      	mov	r7, sl
     8d8:	464e      	mov	r6, r9
     8da:	46de      	mov	lr, fp
     8dc:	4645      	mov	r5, r8
     8de:	b5e0      	push	{r5, r6, r7, lr}
     8e0:	4681      	mov	r9, r0
     8e2:	b083      	sub	sp, #12
     8e4:	4692      	mov	sl, r2
     8e6:	2900      	cmp	r1, #0
     8e8:	d025      	beq.n	936 <search_EIT_table+0x62>
     8ea:	1e4b      	subs	r3, r1, #1
     8ec:	469b      	mov	fp, r3
     8ee:	2700      	movs	r7, #0
     8f0:	9301      	str	r3, [sp, #4]
     8f2:	465b      	mov	r3, fp
     8f4:	18fb      	adds	r3, r7, r3
     8f6:	0fdc      	lsrs	r4, r3, #31
     8f8:	18e4      	adds	r4, r4, r3
     8fa:	464b      	mov	r3, r9
     8fc:	1064      	asrs	r4, r4, #1
     8fe:	00e5      	lsls	r5, r4, #3
     900:	195e      	adds	r6, r3, r5
     902:	0030      	movs	r0, r6
     904:	f7ff ffda 	bl	8bc <selfrel_offset31>
     908:	9b01      	ldr	r3, [sp, #4]
     90a:	4680      	mov	r8, r0
     90c:	42a3      	cmp	r3, r4
     90e:	d00b      	beq.n	928 <search_EIT_table+0x54>
     910:	0028      	movs	r0, r5
     912:	3008      	adds	r0, #8
     914:	4448      	add	r0, r9
     916:	f7ff ffd1 	bl	8bc <selfrel_offset31>
     91a:	45d0      	cmp	r8, sl
     91c:	d806      	bhi.n	92c <search_EIT_table+0x58>
     91e:	3801      	subs	r0, #1
     920:	4550      	cmp	r0, sl
     922:	d209      	bcs.n	938 <search_EIT_table+0x64>
     924:	1c67      	adds	r7, r4, #1
     926:	e7e4      	b.n	8f2 <search_EIT_table+0x1e>
     928:	4550      	cmp	r0, sl
     92a:	d905      	bls.n	938 <search_EIT_table+0x64>
     92c:	42a7      	cmp	r7, r4
     92e:	d002      	beq.n	936 <search_EIT_table+0x62>
     930:	1e63      	subs	r3, r4, #1
     932:	469b      	mov	fp, r3
     934:	e7dd      	b.n	8f2 <search_EIT_table+0x1e>
     936:	2600      	movs	r6, #0
     938:	0030      	movs	r0, r6
     93a:	b003      	add	sp, #12
     93c:	bc3c      	pop	{r2, r3, r4, r5}
     93e:	4690      	mov	r8, r2
     940:	4699      	mov	r9, r3
     942:	46a2      	mov	sl, r4
     944:	46ab      	mov	fp, r5
     946:	bdf0      	pop	{r4, r5, r6, r7, pc}

00000948 <__gnu_unwind_get_pr_addr>:
     948:	2801      	cmp	r0, #1
     94a:	d009      	beq.n	960 <__gnu_unwind_get_pr_addr+0x18>
     94c:	2802      	cmp	r0, #2
     94e:	d005      	beq.n	95c <__gnu_unwind_get_pr_addr+0x14>
     950:	2800      	cmp	r0, #0
     952:	d001      	beq.n	958 <__gnu_unwind_get_pr_addr+0x10>
     954:	2000      	movs	r0, #0
     956:	4770      	bx	lr
     958:	4802      	ldr	r0, [pc, #8]	; (964 <__gnu_unwind_get_pr_addr+0x1c>)
     95a:	e7fc      	b.n	956 <__gnu_unwind_get_pr_addr+0xe>
     95c:	4802      	ldr	r0, [pc, #8]	; (968 <__gnu_unwind_get_pr_addr+0x20>)
     95e:	e7fa      	b.n	956 <__gnu_unwind_get_pr_addr+0xe>
     960:	4802      	ldr	r0, [pc, #8]	; (96c <__gnu_unwind_get_pr_addr+0x24>)
     962:	e7f8      	b.n	956 <__gnu_unwind_get_pr_addr+0xe>
     964:	0000103d 	.word	0x0000103d
     968:	00001055 	.word	0x00001055
     96c:	00001049 	.word	0x00001049

00000970 <get_eit_entry>:
     970:	b530      	push	{r4, r5, lr}
     972:	4b23      	ldr	r3, [pc, #140]	; (a00 <get_eit_entry+0x90>)
     974:	b083      	sub	sp, #12
     976:	0005      	movs	r5, r0
     978:	1e8c      	subs	r4, r1, #2
     97a:	2b00      	cmp	r3, #0
     97c:	d026      	beq.n	9cc <get_eit_entry+0x5c>
     97e:	a901      	add	r1, sp, #4
     980:	0020      	movs	r0, r4
     982:	e000      	b.n	986 <get_eit_entry+0x16>
     984:	bf00      	nop
     986:	2800      	cmp	r0, #0
     988:	d01c      	beq.n	9c4 <get_eit_entry+0x54>
     98a:	9901      	ldr	r1, [sp, #4]
     98c:	0022      	movs	r2, r4
     98e:	f7ff ffa1 	bl	8d4 <search_EIT_table>
     992:	1e04      	subs	r4, r0, #0
     994:	d016      	beq.n	9c4 <get_eit_entry+0x54>
     996:	f7ff ff91 	bl	8bc <selfrel_offset31>
     99a:	6863      	ldr	r3, [r4, #4]
     99c:	64a8      	str	r0, [r5, #72]	; 0x48
     99e:	2b01      	cmp	r3, #1
     9a0:	d02a      	beq.n	9f8 <get_eit_entry+0x88>
     9a2:	1d20      	adds	r0, r4, #4
     9a4:	2b00      	cmp	r3, #0
     9a6:	db23      	blt.n	9f0 <get_eit_entry+0x80>
     9a8:	f7ff ff88 	bl	8bc <selfrel_offset31>
     9ac:	2300      	movs	r3, #0
     9ae:	64e8      	str	r0, [r5, #76]	; 0x4c
     9b0:	652b      	str	r3, [r5, #80]	; 0x50
     9b2:	6803      	ldr	r3, [r0, #0]
     9b4:	2b00      	cmp	r3, #0
     9b6:	db0f      	blt.n	9d8 <get_eit_entry+0x68>
     9b8:	f7ff ff80 	bl	8bc <selfrel_offset31>
     9bc:	6128      	str	r0, [r5, #16]
     9be:	2000      	movs	r0, #0
     9c0:	b003      	add	sp, #12
     9c2:	bd30      	pop	{r4, r5, pc}
     9c4:	2300      	movs	r3, #0
     9c6:	2009      	movs	r0, #9
     9c8:	612b      	str	r3, [r5, #16]
     9ca:	e7f9      	b.n	9c0 <get_eit_entry+0x50>
     9cc:	480d      	ldr	r0, [pc, #52]	; (a04 <get_eit_entry+0x94>)
     9ce:	490e      	ldr	r1, [pc, #56]	; (a08 <get_eit_entry+0x98>)
     9d0:	1a09      	subs	r1, r1, r0
     9d2:	10c9      	asrs	r1, r1, #3
     9d4:	9101      	str	r1, [sp, #4]
     9d6:	e7d9      	b.n	98c <get_eit_entry+0x1c>
     9d8:	0118      	lsls	r0, r3, #4
     9da:	0f00      	lsrs	r0, r0, #28
     9dc:	f7ff ffb4 	bl	948 <__gnu_unwind_get_pr_addr>
     9e0:	6128      	str	r0, [r5, #16]
     9e2:	1e43      	subs	r3, r0, #1
     9e4:	4198      	sbcs	r0, r3
     9e6:	2308      	movs	r3, #8
     9e8:	4240      	negs	r0, r0
     9ea:	4398      	bics	r0, r3
     9ec:	3009      	adds	r0, #9
     9ee:	e7e7      	b.n	9c0 <get_eit_entry+0x50>
     9f0:	2301      	movs	r3, #1
     9f2:	64e8      	str	r0, [r5, #76]	; 0x4c
     9f4:	652b      	str	r3, [r5, #80]	; 0x50
     9f6:	e7dc      	b.n	9b2 <get_eit_entry+0x42>
     9f8:	2300      	movs	r3, #0
     9fa:	2005      	movs	r0, #5
     9fc:	612b      	str	r3, [r5, #16]
     9fe:	e7df      	b.n	9c0 <get_eit_entry+0x50>
     a00:	00000000 	.word	0x00000000
     a04:	00026168 	.word	0x00026168
     a08:	00026230 	.word	0x00026230

00000a0c <restore_non_core_regs>:
     a0c:	6803      	ldr	r3, [r0, #0]
     a0e:	b510      	push	{r4, lr}
     a10:	0004      	movs	r4, r0
     a12:	07da      	lsls	r2, r3, #31
     a14:	d405      	bmi.n	a22 <restore_non_core_regs+0x16>
     a16:	3048      	adds	r0, #72	; 0x48
     a18:	079b      	lsls	r3, r3, #30
     a1a:	d50e      	bpl.n	a3a <restore_non_core_regs+0x2e>
     a1c:	f000 fc6c 	bl	12f8 <__gnu_Unwind_Restore_VFP_D>
     a20:	6823      	ldr	r3, [r4, #0]
     a22:	075a      	lsls	r2, r3, #29
     a24:	d50e      	bpl.n	a44 <restore_non_core_regs+0x38>
     a26:	071a      	lsls	r2, r3, #28
     a28:	d513      	bpl.n	a52 <restore_non_core_regs+0x46>
     a2a:	06db      	lsls	r3, r3, #27
     a2c:	d404      	bmi.n	a38 <restore_non_core_regs+0x2c>
     a2e:	0020      	movs	r0, r4
     a30:	30d1      	adds	r0, #209	; 0xd1
     a32:	30ff      	adds	r0, #255	; 0xff
     a34:	f000 fc6c 	bl	1310 <__gnu_Unwind_Restore_WMMXC>
     a38:	bd10      	pop	{r4, pc}
     a3a:	f000 fc59 	bl	12f0 <__gnu_Unwind_Restore_VFP>
     a3e:	6823      	ldr	r3, [r4, #0]
     a40:	075a      	lsls	r2, r3, #29
     a42:	d4f0      	bmi.n	a26 <restore_non_core_regs+0x1a>
     a44:	0020      	movs	r0, r4
     a46:	30d0      	adds	r0, #208	; 0xd0
     a48:	f000 fc5a 	bl	1300 <__gnu_Unwind_Restore_VFP_D_16_to_31>
     a4c:	6823      	ldr	r3, [r4, #0]
     a4e:	071a      	lsls	r2, r3, #28
     a50:	d4eb      	bmi.n	a2a <restore_non_core_regs+0x1e>
     a52:	0020      	movs	r0, r4
     a54:	3051      	adds	r0, #81	; 0x51
     a56:	30ff      	adds	r0, #255	; 0xff
     a58:	f000 fc56 	bl	1308 <__gnu_Unwind_Restore_WMMXD>
     a5c:	6823      	ldr	r3, [r4, #0]
     a5e:	e7e4      	b.n	a2a <restore_non_core_regs+0x1e>

00000a60 <_Unwind_decode_typeinfo_ptr.isra.0>:
     a60:	6803      	ldr	r3, [r0, #0]
     a62:	2b00      	cmp	r3, #0
     a64:	d000      	beq.n	a68 <_Unwind_decode_typeinfo_ptr.isra.0+0x8>
     a66:	181b      	adds	r3, r3, r0
     a68:	0018      	movs	r0, r3
     a6a:	4770      	bx	lr

00000a6c <__gnu_unwind_24bit.isra.1>:
     a6c:	2009      	movs	r0, #9
     a6e:	4770      	bx	lr

00000a70 <_Unwind_DebugHook>:
     a70:	4770      	bx	lr
     a72:	46c0      	nop			; (mov r8, r8)

00000a74 <unwind_phase2>:
     a74:	b570      	push	{r4, r5, r6, lr}
     a76:	0004      	movs	r4, r0
     a78:	000d      	movs	r5, r1
     a7a:	e008      	b.n	a8e <unwind_phase2+0x1a>
     a7c:	6c2b      	ldr	r3, [r5, #64]	; 0x40
     a7e:	002a      	movs	r2, r5
     a80:	6163      	str	r3, [r4, #20]
     a82:	0021      	movs	r1, r4
     a84:	2001      	movs	r0, #1
     a86:	6923      	ldr	r3, [r4, #16]
     a88:	4798      	blx	r3
     a8a:	2808      	cmp	r0, #8
     a8c:	d107      	bne.n	a9e <unwind_phase2+0x2a>
     a8e:	6c29      	ldr	r1, [r5, #64]	; 0x40
     a90:	0020      	movs	r0, r4
     a92:	f7ff ff6d 	bl	970 <get_eit_entry>
     a96:	2800      	cmp	r0, #0
     a98:	d0f0      	beq.n	a7c <unwind_phase2+0x8>
     a9a:	f021 fbe3 	bl	22264 <abort>
     a9e:	2807      	cmp	r0, #7
     aa0:	d1fb      	bne.n	a9a <unwind_phase2+0x26>
     aa2:	2000      	movs	r0, #0
     aa4:	6c29      	ldr	r1, [r5, #64]	; 0x40
     aa6:	f7ff ffe3 	bl	a70 <_Unwind_DebugHook>
     aaa:	1d28      	adds	r0, r5, #4
     aac:	f000 fc0a 	bl	12c4 <__restore_core_regs>

00000ab0 <unwind_phase2_forced>:
     ab0:	b5f0      	push	{r4, r5, r6, r7, lr}
     ab2:	46ce      	mov	lr, r9
     ab4:	4647      	mov	r7, r8
     ab6:	b580      	push	{r7, lr}
     ab8:	68c3      	ldr	r3, [r0, #12]
     aba:	4c2e      	ldr	r4, [pc, #184]	; (b74 <unwind_phase2_forced+0xc4>)
     abc:	4698      	mov	r8, r3
     abe:	44a5      	add	sp, r4
     ac0:	6983      	ldr	r3, [r0, #24]
     ac2:	0006      	movs	r6, r0
     ac4:	0014      	movs	r4, r2
     ac6:	3104      	adds	r1, #4
     ac8:	2240      	movs	r2, #64	; 0x40
     aca:	a805      	add	r0, sp, #20
     acc:	4699      	mov	r9, r3
     ace:	f7ff fb8f 	bl	1f0 <memcpy>
     ad2:	2300      	movs	r3, #0
     ad4:	ad04      	add	r5, sp, #16
     ad6:	9304      	str	r3, [sp, #16]
     ad8:	e023      	b.n	b22 <unwind_phase2_forced+0x72>
     ada:	22f0      	movs	r2, #240	; 0xf0
     adc:	6c2b      	ldr	r3, [r5, #64]	; 0x40
     ade:	0052      	lsls	r2, r2, #1
     ae0:	6173      	str	r3, [r6, #20]
     ae2:	0029      	movs	r1, r5
     ae4:	a87c      	add	r0, sp, #496	; 0x1f0
     ae6:	f7ff fb83 	bl	1f0 <memcpy>
     aea:	aa7c      	add	r2, sp, #496	; 0x1f0
     aec:	0031      	movs	r1, r6
     aee:	6933      	ldr	r3, [r6, #16]
     af0:	0020      	movs	r0, r4
     af2:	4798      	blx	r3
     af4:	9b8a      	ldr	r3, [sp, #552]	; 0x228
     af6:	0007      	movs	r7, r0
     af8:	646b      	str	r3, [r5, #68]	; 0x44
     afa:	9303      	str	r3, [sp, #12]
     afc:	464b      	mov	r3, r9
     afe:	9500      	str	r5, [sp, #0]
     b00:	9301      	str	r3, [sp, #4]
     b02:	0032      	movs	r2, r6
     b04:	0033      	movs	r3, r6
     b06:	0021      	movs	r1, r4
     b08:	2001      	movs	r0, #1
     b0a:	47c0      	blx	r8
     b0c:	2800      	cmp	r0, #0
     b0e:	d11f      	bne.n	b50 <unwind_phase2_forced+0xa0>
     b10:	22f0      	movs	r2, #240	; 0xf0
     b12:	a97c      	add	r1, sp, #496	; 0x1f0
     b14:	0052      	lsls	r2, r2, #1
     b16:	0028      	movs	r0, r5
     b18:	f7ff fb6a 	bl	1f0 <memcpy>
     b1c:	2400      	movs	r4, #0
     b1e:	2f08      	cmp	r7, #8
     b20:	d11f      	bne.n	b62 <unwind_phase2_forced+0xb2>
     b22:	6c29      	ldr	r1, [r5, #64]	; 0x40
     b24:	0030      	movs	r0, r6
     b26:	f7ff ff23 	bl	970 <get_eit_entry>
     b2a:	1e61      	subs	r1, r4, #1
     b2c:	418c      	sbcs	r4, r1
     b2e:	0007      	movs	r7, r0
     b30:	3409      	adds	r4, #9
     b32:	2800      	cmp	r0, #0
     b34:	d0d1      	beq.n	ada <unwind_phase2_forced+0x2a>
     b36:	6bab      	ldr	r3, [r5, #56]	; 0x38
     b38:	2110      	movs	r1, #16
     b3a:	646b      	str	r3, [r5, #68]	; 0x44
     b3c:	464b      	mov	r3, r9
     b3e:	4321      	orrs	r1, r4
     b40:	9301      	str	r3, [sp, #4]
     b42:	9500      	str	r5, [sp, #0]
     b44:	0033      	movs	r3, r6
     b46:	0032      	movs	r2, r6
     b48:	2001      	movs	r0, #1
     b4a:	47c0      	blx	r8
     b4c:	2800      	cmp	r0, #0
     b4e:	d000      	beq.n	b52 <unwind_phase2_forced+0xa2>
     b50:	2709      	movs	r7, #9
     b52:	0038      	movs	r0, r7
     b54:	23f5      	movs	r3, #245	; 0xf5
     b56:	009b      	lsls	r3, r3, #2
     b58:	449d      	add	sp, r3
     b5a:	bc0c      	pop	{r2, r3}
     b5c:	4690      	mov	r8, r2
     b5e:	4699      	mov	r9, r3
     b60:	bdf0      	pop	{r4, r5, r6, r7, pc}
     b62:	2f07      	cmp	r7, #7
     b64:	d1f4      	bne.n	b50 <unwind_phase2_forced+0xa0>
     b66:	0020      	movs	r0, r4
     b68:	6c29      	ldr	r1, [r5, #64]	; 0x40
     b6a:	f7ff ff81 	bl	a70 <_Unwind_DebugHook>
     b6e:	a805      	add	r0, sp, #20
     b70:	f000 fba8 	bl	12c4 <__restore_core_regs>
     b74:	fffffc2c 	.word	0xfffffc2c

00000b78 <_Unwind_GetCFA>:
     b78:	6c40      	ldr	r0, [r0, #68]	; 0x44
     b7a:	4770      	bx	lr

00000b7c <__gnu_Unwind_RaiseException>:
     b7c:	b570      	push	{r4, r5, r6, lr}
     b7e:	6bcb      	ldr	r3, [r1, #60]	; 0x3c
     b80:	b0fa      	sub	sp, #488	; 0x1e8
     b82:	640b      	str	r3, [r1, #64]	; 0x40
     b84:	0004      	movs	r4, r0
     b86:	000e      	movs	r6, r1
     b88:	2240      	movs	r2, #64	; 0x40
     b8a:	3104      	adds	r1, #4
     b8c:	a803      	add	r0, sp, #12
     b8e:	f7ff fb2f 	bl	1f0 <memcpy>
     b92:	2301      	movs	r3, #1
     b94:	425b      	negs	r3, r3
     b96:	9302      	str	r3, [sp, #8]
     b98:	e006      	b.n	ba8 <__gnu_Unwind_RaiseException+0x2c>
     b9a:	aa02      	add	r2, sp, #8
     b9c:	0021      	movs	r1, r4
     b9e:	6923      	ldr	r3, [r4, #16]
     ba0:	4798      	blx	r3
     ba2:	0005      	movs	r5, r0
     ba4:	2808      	cmp	r0, #8
     ba6:	d10a      	bne.n	bbe <__gnu_Unwind_RaiseException+0x42>
     ba8:	9b12      	ldr	r3, [sp, #72]	; 0x48
     baa:	0020      	movs	r0, r4
     bac:	0019      	movs	r1, r3
     bae:	9301      	str	r3, [sp, #4]
     bb0:	f7ff fede 	bl	970 <get_eit_entry>
     bb4:	2800      	cmp	r0, #0
     bb6:	d0f0      	beq.n	b9a <__gnu_Unwind_RaiseException+0x1e>
     bb8:	2009      	movs	r0, #9
     bba:	b07a      	add	sp, #488	; 0x1e8
     bbc:	bd70      	pop	{r4, r5, r6, pc}
     bbe:	a802      	add	r0, sp, #8
     bc0:	f7ff ff24 	bl	a0c <restore_non_core_regs>
     bc4:	2d06      	cmp	r5, #6
     bc6:	d1f7      	bne.n	bb8 <__gnu_Unwind_RaiseException+0x3c>
     bc8:	0031      	movs	r1, r6
     bca:	0020      	movs	r0, r4
     bcc:	f7ff ff52 	bl	a74 <unwind_phase2>

00000bd0 <__gnu_Unwind_ForcedUnwind>:
     bd0:	b510      	push	{r4, lr}
     bd2:	6182      	str	r2, [r0, #24]
     bd4:	6bda      	ldr	r2, [r3, #60]	; 0x3c
     bd6:	60c1      	str	r1, [r0, #12]
     bd8:	641a      	str	r2, [r3, #64]	; 0x40
     bda:	0019      	movs	r1, r3
     bdc:	2200      	movs	r2, #0
     bde:	f7ff ff67 	bl	ab0 <unwind_phase2_forced>
     be2:	bd10      	pop	{r4, pc}

00000be4 <__gnu_Unwind_Resume>:
     be4:	6943      	ldr	r3, [r0, #20]
     be6:	b570      	push	{r4, r5, r6, lr}
     be8:	640b      	str	r3, [r1, #64]	; 0x40
     bea:	68c3      	ldr	r3, [r0, #12]
     bec:	0004      	movs	r4, r0
     bee:	000d      	movs	r5, r1
     bf0:	2b00      	cmp	r3, #0
     bf2:	d115      	bne.n	c20 <__gnu_Unwind_Resume+0x3c>
     bf4:	000a      	movs	r2, r1
     bf6:	6923      	ldr	r3, [r4, #16]
     bf8:	0001      	movs	r1, r0
     bfa:	2002      	movs	r0, #2
     bfc:	4798      	blx	r3
     bfe:	2807      	cmp	r0, #7
     c00:	d007      	beq.n	c12 <__gnu_Unwind_Resume+0x2e>
     c02:	2808      	cmp	r0, #8
     c04:	d103      	bne.n	c0e <__gnu_Unwind_Resume+0x2a>
     c06:	0029      	movs	r1, r5
     c08:	0020      	movs	r0, r4
     c0a:	f7ff ff33 	bl	a74 <unwind_phase2>
     c0e:	f021 fb29 	bl	22264 <abort>
     c12:	2000      	movs	r0, #0
     c14:	6c29      	ldr	r1, [r5, #64]	; 0x40
     c16:	f7ff ff2b 	bl	a70 <_Unwind_DebugHook>
     c1a:	1d28      	adds	r0, r5, #4
     c1c:	f000 fb52 	bl	12c4 <__restore_core_regs>
     c20:	2201      	movs	r2, #1
     c22:	f7ff ff45 	bl	ab0 <unwind_phase2_forced>
     c26:	f021 fb1d 	bl	22264 <abort>
     c2a:	46c0      	nop			; (mov r8, r8)

00000c2c <__gnu_Unwind_Resume_or_Rethrow>:
     c2c:	68c3      	ldr	r3, [r0, #12]
     c2e:	b510      	push	{r4, lr}
     c30:	2b00      	cmp	r3, #0
     c32:	d005      	beq.n	c40 <__gnu_Unwind_Resume_or_Rethrow+0x14>
     c34:	6bcb      	ldr	r3, [r1, #60]	; 0x3c
     c36:	2200      	movs	r2, #0
     c38:	640b      	str	r3, [r1, #64]	; 0x40
     c3a:	f7ff ff39 	bl	ab0 <unwind_phase2_forced>
     c3e:	bd10      	pop	{r4, pc}
     c40:	f7ff ff9c 	bl	b7c <__gnu_Unwind_RaiseException>
     c44:	e7fb      	b.n	c3e <__gnu_Unwind_Resume_or_Rethrow+0x12>
     c46:	46c0      	nop			; (mov r8, r8)

00000c48 <_Unwind_Complete>:
     c48:	4770      	bx	lr
     c4a:	46c0      	nop			; (mov r8, r8)

00000c4c <_Unwind_DeleteException>:
     c4c:	6883      	ldr	r3, [r0, #8]
     c4e:	b510      	push	{r4, lr}
     c50:	2b00      	cmp	r3, #0
     c52:	d002      	beq.n	c5a <_Unwind_DeleteException+0xe>
     c54:	0001      	movs	r1, r0
     c56:	2001      	movs	r0, #1
     c58:	4798      	blx	r3
     c5a:	bd10      	pop	{r4, pc}

00000c5c <_Unwind_VRS_Get>:
     c5c:	2901      	cmp	r1, #1
     c5e:	d006      	beq.n	c6e <_Unwind_VRS_Get+0x12>
     c60:	2900      	cmp	r1, #0
     c62:	d006      	beq.n	c72 <_Unwind_VRS_Get+0x16>
     c64:	3903      	subs	r1, #3
     c66:	2002      	movs	r0, #2
     c68:	2901      	cmp	r1, #1
     c6a:	d900      	bls.n	c6e <_Unwind_VRS_Get+0x12>
     c6c:	4770      	bx	lr
     c6e:	2001      	movs	r0, #1
     c70:	e7fc      	b.n	c6c <_Unwind_VRS_Get+0x10>
     c72:	2b00      	cmp	r3, #0
     c74:	d108      	bne.n	c88 <_Unwind_VRS_Get+0x2c>
     c76:	2a0f      	cmp	r2, #15
     c78:	d806      	bhi.n	c88 <_Unwind_VRS_Get+0x2c>
     c7a:	0092      	lsls	r2, r2, #2
     c7c:	1882      	adds	r2, r0, r2
     c7e:	6852      	ldr	r2, [r2, #4]
     c80:	9b00      	ldr	r3, [sp, #0]
     c82:	2000      	movs	r0, #0
     c84:	601a      	str	r2, [r3, #0]
     c86:	e7f1      	b.n	c6c <_Unwind_VRS_Get+0x10>
     c88:	2002      	movs	r0, #2
     c8a:	e7ef      	b.n	c6c <_Unwind_VRS_Get+0x10>

00000c8c <_Unwind_GetGR>:
     c8c:	b500      	push	{lr}
     c8e:	b085      	sub	sp, #20
     c90:	ab03      	add	r3, sp, #12
     c92:	000a      	movs	r2, r1
     c94:	9300      	str	r3, [sp, #0]
     c96:	2100      	movs	r1, #0
     c98:	2300      	movs	r3, #0
     c9a:	f7ff ffdf 	bl	c5c <_Unwind_VRS_Get>
     c9e:	9803      	ldr	r0, [sp, #12]
     ca0:	b005      	add	sp, #20
     ca2:	bd00      	pop	{pc}

00000ca4 <_Unwind_VRS_Set>:
     ca4:	2901      	cmp	r1, #1
     ca6:	d006      	beq.n	cb6 <_Unwind_VRS_Set+0x12>
     ca8:	2900      	cmp	r1, #0
     caa:	d006      	beq.n	cba <_Unwind_VRS_Set+0x16>
     cac:	3903      	subs	r1, #3
     cae:	2002      	movs	r0, #2
     cb0:	2901      	cmp	r1, #1
     cb2:	d900      	bls.n	cb6 <_Unwind_VRS_Set+0x12>
     cb4:	4770      	bx	lr
     cb6:	2001      	movs	r0, #1
     cb8:	e7fc      	b.n	cb4 <_Unwind_VRS_Set+0x10>
     cba:	2b00      	cmp	r3, #0
     cbc:	d108      	bne.n	cd0 <_Unwind_VRS_Set+0x2c>
     cbe:	2a0f      	cmp	r2, #15
     cc0:	d806      	bhi.n	cd0 <_Unwind_VRS_Set+0x2c>
     cc2:	9b00      	ldr	r3, [sp, #0]
     cc4:	0092      	lsls	r2, r2, #2
     cc6:	681b      	ldr	r3, [r3, #0]
     cc8:	1882      	adds	r2, r0, r2
     cca:	6053      	str	r3, [r2, #4]
     ccc:	2000      	movs	r0, #0
     cce:	e7f1      	b.n	cb4 <_Unwind_VRS_Set+0x10>
     cd0:	2002      	movs	r0, #2
     cd2:	e7ef      	b.n	cb4 <_Unwind_VRS_Set+0x10>

00000cd4 <_Unwind_SetGR>:
     cd4:	b500      	push	{lr}
     cd6:	b085      	sub	sp, #20
     cd8:	ab03      	add	r3, sp, #12
     cda:	9203      	str	r2, [sp, #12]
     cdc:	9300      	str	r3, [sp, #0]
     cde:	000a      	movs	r2, r1
     ce0:	2300      	movs	r3, #0
     ce2:	2100      	movs	r1, #0
     ce4:	f7ff ffde 	bl	ca4 <_Unwind_VRS_Set>
     ce8:	b005      	add	sp, #20
     cea:	bd00      	pop	{pc}

00000cec <__gnu_Unwind_Backtrace>:
     cec:	b570      	push	{r4, r5, r6, lr}
     cee:	4c1a      	ldr	r4, [pc, #104]	; (d58 <__gnu_Unwind_Backtrace+0x6c>)
     cf0:	6bd3      	ldr	r3, [r2, #60]	; 0x3c
     cf2:	44a5      	add	sp, r4
     cf4:	6413      	str	r3, [r2, #64]	; 0x40
     cf6:	0006      	movs	r6, r0
     cf8:	000d      	movs	r5, r1
     cfa:	a819      	add	r0, sp, #100	; 0x64
     cfc:	1d11      	adds	r1, r2, #4
     cfe:	2240      	movs	r2, #64	; 0x40
     d00:	f7ff fa76 	bl	1f0 <memcpy>
     d04:	2301      	movs	r3, #1
     d06:	425b      	negs	r3, r3
     d08:	9318      	str	r3, [sp, #96]	; 0x60
     d0a:	e014      	b.n	d36 <__gnu_Unwind_Backtrace+0x4a>
     d0c:	210c      	movs	r1, #12
     d0e:	a818      	add	r0, sp, #96	; 0x60
     d10:	aa02      	add	r2, sp, #8
     d12:	f7ff ffdf 	bl	cd4 <_Unwind_SetGR>
     d16:	0029      	movs	r1, r5
     d18:	a818      	add	r0, sp, #96	; 0x60
     d1a:	47b0      	blx	r6
     d1c:	2800      	cmp	r0, #0
     d1e:	d112      	bne.n	d46 <__gnu_Unwind_Backtrace+0x5a>
     d20:	9b06      	ldr	r3, [sp, #24]
     d22:	aa18      	add	r2, sp, #96	; 0x60
     d24:	a902      	add	r1, sp, #8
     d26:	3008      	adds	r0, #8
     d28:	9301      	str	r3, [sp, #4]
     d2a:	4798      	blx	r3
     d2c:	0004      	movs	r4, r0
     d2e:	2805      	cmp	r0, #5
     d30:	d00a      	beq.n	d48 <__gnu_Unwind_Backtrace+0x5c>
     d32:	2809      	cmp	r0, #9
     d34:	d007      	beq.n	d46 <__gnu_Unwind_Backtrace+0x5a>
     d36:	9b28      	ldr	r3, [sp, #160]	; 0xa0
     d38:	a802      	add	r0, sp, #8
     d3a:	0019      	movs	r1, r3
     d3c:	9301      	str	r3, [sp, #4]
     d3e:	f7ff fe17 	bl	970 <get_eit_entry>
     d42:	2800      	cmp	r0, #0
     d44:	d0e2      	beq.n	d0c <__gnu_Unwind_Backtrace+0x20>
     d46:	2409      	movs	r4, #9
     d48:	a818      	add	r0, sp, #96	; 0x60
     d4a:	f7ff fe5f 	bl	a0c <restore_non_core_regs>
     d4e:	0020      	movs	r0, r4
     d50:	2390      	movs	r3, #144	; 0x90
     d52:	009b      	lsls	r3, r3, #2
     d54:	449d      	add	sp, r3
     d56:	bd70      	pop	{r4, r5, r6, pc}
     d58:	fffffdc0 	.word	0xfffffdc0

00000d5c <__gnu_unwind_pr_common>:
     d5c:	b5f0      	push	{r4, r5, r6, r7, lr}
     d5e:	46de      	mov	lr, fp
     d60:	4657      	mov	r7, sl
     d62:	464e      	mov	r6, r9
     d64:	4645      	mov	r5, r8
     d66:	b5e0      	push	{r5, r6, r7, lr}
     d68:	0016      	movs	r6, r2
     d6a:	2203      	movs	r2, #3
     d6c:	000d      	movs	r5, r1
     d6e:	0011      	movs	r1, r2
     d70:	b08b      	sub	sp, #44	; 0x2c
     d72:	001f      	movs	r7, r3
     d74:	9301      	str	r3, [sp, #4]
     d76:	6ceb      	ldr	r3, [r5, #76]	; 0x4c
     d78:	4001      	ands	r1, r0
     d7a:	1d1c      	adds	r4, r3, #4
     d7c:	9100      	str	r1, [sp, #0]
     d7e:	a907      	add	r1, sp, #28
     d80:	681b      	ldr	r3, [r3, #0]
     d82:	468b      	mov	fp, r1
     d84:	9408      	str	r4, [sp, #32]
     d86:	2f00      	cmp	r7, #0
     d88:	d06b      	beq.n	e62 <__gnu_unwind_pr_common+0x106>
     d8a:	0c1a      	lsrs	r2, r3, #16
     d8c:	041b      	lsls	r3, r3, #16
     d8e:	4659      	mov	r1, fp
     d90:	9307      	str	r3, [sp, #28]
     d92:	2302      	movs	r3, #2
     d94:	720b      	strb	r3, [r1, #8]
     d96:	33fd      	adds	r3, #253	; 0xfd
     d98:	4013      	ands	r3, r2
     d9a:	009b      	lsls	r3, r3, #2
     d9c:	724a      	strb	r2, [r1, #9]
     d9e:	18e4      	adds	r4, r4, r3
     da0:	9b00      	ldr	r3, [sp, #0]
     da2:	2b02      	cmp	r3, #2
     da4:	d100      	bne.n	da8 <__gnu_unwind_pr_common+0x4c>
     da6:	6bac      	ldr	r4, [r5, #56]	; 0x38
     da8:	6d2b      	ldr	r3, [r5, #80]	; 0x50
     daa:	07db      	lsls	r3, r3, #31
     dac:	d447      	bmi.n	e3e <__gnu_unwind_pr_common+0xe2>
     dae:	2300      	movs	r3, #0
     db0:	9305      	str	r3, [sp, #20]
     db2:	3308      	adds	r3, #8
     db4:	4003      	ands	r3, r0
     db6:	9302      	str	r3, [sp, #8]
     db8:	6827      	ldr	r7, [r4, #0]
     dba:	2f00      	cmp	r7, #0
     dbc:	d100      	bne.n	dc0 <__gnu_unwind_pr_common+0x64>
     dbe:	e112      	b.n	fe6 <__gnu_unwind_pr_common+0x28a>
     dc0:	9b01      	ldr	r3, [sp, #4]
     dc2:	2b02      	cmp	r3, #2
     dc4:	d049      	beq.n	e5a <__gnu_unwind_pr_common+0xfe>
     dc6:	8863      	ldrh	r3, [r4, #2]
     dc8:	8827      	ldrh	r7, [r4, #0]
     dca:	4698      	mov	r8, r3
     dcc:	3404      	adds	r4, #4
     dce:	2301      	movs	r3, #1
     dd0:	4640      	mov	r0, r8
     dd2:	469a      	mov	sl, r3
     dd4:	4398      	bics	r0, r3
     dd6:	6cab      	ldr	r3, [r5, #72]	; 0x48
     dd8:	210f      	movs	r1, #15
     dda:	4699      	mov	r9, r3
     ddc:	4481      	add	r9, r0
     dde:	0030      	movs	r0, r6
     de0:	f7ff ff54 	bl	c8c <_Unwind_GetGR>
     de4:	2100      	movs	r1, #0
     de6:	4581      	cmp	r9, r0
     de8:	d806      	bhi.n	df8 <__gnu_unwind_pr_common+0x9c>
     dea:	0039      	movs	r1, r7
     dec:	4653      	mov	r3, sl
     dee:	4399      	bics	r1, r3
     df0:	4449      	add	r1, r9
     df2:	4288      	cmp	r0, r1
     df4:	4189      	sbcs	r1, r1
     df6:	4249      	negs	r1, r1
     df8:	4643      	mov	r3, r8
     dfa:	005a      	lsls	r2, r3, #1
     dfc:	2302      	movs	r3, #2
     dfe:	4013      	ands	r3, r2
     e00:	2201      	movs	r2, #1
     e02:	4017      	ands	r7, r2
     e04:	433b      	orrs	r3, r7
     e06:	2b01      	cmp	r3, #1
     e08:	d03a      	beq.n	e80 <__gnu_unwind_pr_common+0x124>
     e0a:	2b00      	cmp	r3, #0
     e0c:	d030      	beq.n	e70 <__gnu_unwind_pr_common+0x114>
     e0e:	2b02      	cmp	r3, #2
     e10:	d11b      	bne.n	e4a <__gnu_unwind_pr_common+0xee>
     e12:	6823      	ldr	r3, [r4, #0]
     e14:	9a00      	ldr	r2, [sp, #0]
     e16:	005f      	lsls	r7, r3, #1
     e18:	087f      	lsrs	r7, r7, #1
     e1a:	2a00      	cmp	r2, #0
     e1c:	d167      	bne.n	eee <__gnu_unwind_pr_common+0x192>
     e1e:	2900      	cmp	r1, #0
     e20:	d006      	beq.n	e30 <__gnu_unwind_pr_common+0xd4>
     e22:	9a02      	ldr	r2, [sp, #8]
     e24:	2a00      	cmp	r2, #0
     e26:	d100      	bne.n	e2a <__gnu_unwind_pr_common+0xce>
     e28:	e07c      	b.n	f24 <__gnu_unwind_pr_common+0x1c8>
     e2a:	2f00      	cmp	r7, #0
     e2c:	d100      	bne.n	e30 <__gnu_unwind_pr_common+0xd4>
     e2e:	e0a9      	b.n	f84 <__gnu_unwind_pr_common+0x228>
     e30:	2b00      	cmp	r3, #0
     e32:	da00      	bge.n	e36 <__gnu_unwind_pr_common+0xda>
     e34:	3404      	adds	r4, #4
     e36:	3701      	adds	r7, #1
     e38:	00bf      	lsls	r7, r7, #2
     e3a:	19e4      	adds	r4, r4, r7
     e3c:	e7bc      	b.n	db8 <__gnu_unwind_pr_common+0x5c>
     e3e:	4659      	mov	r1, fp
     e40:	0030      	movs	r0, r6
     e42:	f000 fb0b 	bl	145c <__gnu_unwind_execute>
     e46:	2800      	cmp	r0, #0
     e48:	d010      	beq.n	e6c <__gnu_unwind_pr_common+0x110>
     e4a:	2009      	movs	r0, #9
     e4c:	b00b      	add	sp, #44	; 0x2c
     e4e:	bc3c      	pop	{r2, r3, r4, r5}
     e50:	4690      	mov	r8, r2
     e52:	4699      	mov	r9, r3
     e54:	46a2      	mov	sl, r4
     e56:	46ab      	mov	fp, r5
     e58:	bdf0      	pop	{r4, r5, r6, r7, pc}
     e5a:	6863      	ldr	r3, [r4, #4]
     e5c:	3408      	adds	r4, #8
     e5e:	4698      	mov	r8, r3
     e60:	e7b5      	b.n	dce <__gnu_unwind_pr_common+0x72>
     e62:	021b      	lsls	r3, r3, #8
     e64:	9307      	str	r3, [sp, #28]
     e66:	465b      	mov	r3, fp
     e68:	811a      	strh	r2, [r3, #8]
     e6a:	e799      	b.n	da0 <__gnu_unwind_pr_common+0x44>
     e6c:	2008      	movs	r0, #8
     e6e:	e7ed      	b.n	e4c <__gnu_unwind_pr_common+0xf0>
     e70:	9b00      	ldr	r3, [sp, #0]
     e72:	2b00      	cmp	r3, #0
     e74:	d002      	beq.n	e7c <__gnu_unwind_pr_common+0x120>
     e76:	2900      	cmp	r1, #0
     e78:	d000      	beq.n	e7c <__gnu_unwind_pr_common+0x120>
     e7a:	e08d      	b.n	f98 <__gnu_unwind_pr_common+0x23c>
     e7c:	3404      	adds	r4, #4
     e7e:	e79b      	b.n	db8 <__gnu_unwind_pr_common+0x5c>
     e80:	9b00      	ldr	r3, [sp, #0]
     e82:	2b00      	cmp	r3, #0
     e84:	d11a      	bne.n	ebc <__gnu_unwind_pr_common+0x160>
     e86:	2900      	cmp	r1, #0
     e88:	d016      	beq.n	eb8 <__gnu_unwind_pr_common+0x15c>
     e8a:	6823      	ldr	r3, [r4, #0]
     e8c:	0fdf      	lsrs	r7, r3, #31
     e8e:	6863      	ldr	r3, [r4, #4]
     e90:	1c9a      	adds	r2, r3, #2
     e92:	d0da      	beq.n	e4a <__gnu_unwind_pr_common+0xee>
     e94:	002a      	movs	r2, r5
     e96:	3258      	adds	r2, #88	; 0x58
     e98:	9206      	str	r2, [sp, #24]
     e9a:	3301      	adds	r3, #1
     e9c:	d100      	bne.n	ea0 <__gnu_unwind_pr_common+0x144>
     e9e:	e0bd      	b.n	101c <__gnu_unwind_pr_common+0x2c0>
     ea0:	1d20      	adds	r0, r4, #4
     ea2:	f7ff fddd 	bl	a60 <_Unwind_decode_typeinfo_ptr.isra.0>
     ea6:	ab06      	add	r3, sp, #24
     ea8:	0001      	movs	r1, r0
     eaa:	003a      	movs	r2, r7
     eac:	0028      	movs	r0, r5
     eae:	e000      	b.n	eb2 <__gnu_unwind_pr_common+0x156>
     eb0:	bf00      	nop
     eb2:	2800      	cmp	r0, #0
     eb4:	d000      	beq.n	eb8 <__gnu_unwind_pr_common+0x15c>
     eb6:	e082      	b.n	fbe <__gnu_unwind_pr_common+0x262>
     eb8:	3408      	adds	r4, #8
     eba:	e77d      	b.n	db8 <__gnu_unwind_pr_common+0x5c>
     ebc:	210d      	movs	r1, #13
     ebe:	0030      	movs	r0, r6
     ec0:	6a2f      	ldr	r7, [r5, #32]
     ec2:	f7ff fee3 	bl	c8c <_Unwind_GetGR>
     ec6:	4287      	cmp	r7, r0
     ec8:	d1f6      	bne.n	eb8 <__gnu_unwind_pr_common+0x15c>
     eca:	6aab      	ldr	r3, [r5, #40]	; 0x28
     ecc:	429c      	cmp	r4, r3
     ece:	d1f3      	bne.n	eb8 <__gnu_unwind_pr_common+0x15c>
     ed0:	0020      	movs	r0, r4
     ed2:	f7ff fcf3 	bl	8bc <selfrel_offset31>
     ed6:	210f      	movs	r1, #15
     ed8:	0002      	movs	r2, r0
     eda:	0030      	movs	r0, r6
     edc:	f7ff fefa 	bl	cd4 <_Unwind_SetGR>
     ee0:	0030      	movs	r0, r6
     ee2:	002a      	movs	r2, r5
     ee4:	2100      	movs	r1, #0
     ee6:	f7ff fef5 	bl	cd4 <_Unwind_SetGR>
     eea:	2007      	movs	r0, #7
     eec:	e7ae      	b.n	e4c <__gnu_unwind_pr_common+0xf0>
     eee:	6a2b      	ldr	r3, [r5, #32]
     ef0:	210d      	movs	r1, #13
     ef2:	0030      	movs	r0, r6
     ef4:	4698      	mov	r8, r3
     ef6:	f7ff fec9 	bl	c8c <_Unwind_GetGR>
     efa:	4580      	cmp	r8, r0
     efc:	d001      	beq.n	f02 <__gnu_unwind_pr_common+0x1a6>
     efe:	6823      	ldr	r3, [r4, #0]
     f00:	e796      	b.n	e30 <__gnu_unwind_pr_common+0xd4>
     f02:	6aab      	ldr	r3, [r5, #40]	; 0x28
     f04:	429c      	cmp	r4, r3
     f06:	d1fa      	bne.n	efe <__gnu_unwind_pr_common+0x1a2>
     f08:	2300      	movs	r3, #0
     f0a:	62eb      	str	r3, [r5, #44]	; 0x2c
     f0c:	3304      	adds	r3, #4
     f0e:	632b      	str	r3, [r5, #48]	; 0x30
     f10:	1d23      	adds	r3, r4, #4
     f12:	62af      	str	r7, [r5, #40]	; 0x28
     f14:	636b      	str	r3, [r5, #52]	; 0x34
     f16:	6823      	ldr	r3, [r4, #0]
     f18:	2b00      	cmp	r3, #0
     f1a:	da00      	bge.n	f1e <__gnu_unwind_pr_common+0x1c2>
     f1c:	e086      	b.n	102c <__gnu_unwind_pr_common+0x2d0>
     f1e:	2301      	movs	r3, #1
     f20:	9305      	str	r3, [sp, #20]
     f22:	e788      	b.n	e36 <__gnu_unwind_pr_common+0xda>
     f24:	2f00      	cmp	r7, #0
     f26:	d02d      	beq.n	f84 <__gnu_unwind_pr_common+0x228>
     f28:	2358      	movs	r3, #88	; 0x58
     f2a:	469c      	mov	ip, r3
     f2c:	44ac      	add	ip, r5
     f2e:	4663      	mov	r3, ip
     f30:	9303      	str	r3, [sp, #12]
     f32:	1d23      	adds	r3, r4, #4
     f34:	4699      	mov	r9, r3
     f36:	2300      	movs	r3, #0
     f38:	4698      	mov	r8, r3
     f3a:	ab06      	add	r3, sp, #24
     f3c:	0022      	movs	r2, r4
     f3e:	9304      	str	r3, [sp, #16]
     f40:	003b      	movs	r3, r7
     f42:	464c      	mov	r4, r9
     f44:	4647      	mov	r7, r8
     f46:	46b2      	mov	sl, r6
     f48:	4698      	mov	r8, r3
     f4a:	002e      	movs	r6, r5
     f4c:	4691      	mov	r9, r2
     f4e:	e003      	b.n	f58 <__gnu_unwind_pr_common+0x1fc>
     f50:	3404      	adds	r4, #4
     f52:	002f      	movs	r7, r5
     f54:	4545      	cmp	r5, r8
     f56:	d042      	beq.n	fde <__gnu_unwind_pr_common+0x282>
     f58:	9b03      	ldr	r3, [sp, #12]
     f5a:	0020      	movs	r0, r4
     f5c:	9306      	str	r3, [sp, #24]
     f5e:	f7ff fd7f 	bl	a60 <_Unwind_decode_typeinfo_ptr.isra.0>
     f62:	9b04      	ldr	r3, [sp, #16]
     f64:	0001      	movs	r1, r0
     f66:	2200      	movs	r2, #0
     f68:	0030      	movs	r0, r6
     f6a:	1c7d      	adds	r5, r7, #1
     f6c:	e000      	b.n	f70 <__gnu_unwind_pr_common+0x214>
     f6e:	bf00      	nop
     f70:	2800      	cmp	r0, #0
     f72:	d0ed      	beq.n	f50 <__gnu_unwind_pr_common+0x1f4>
     f74:	4643      	mov	r3, r8
     f76:	46b8      	mov	r8, r7
     f78:	0035      	movs	r5, r6
     f7a:	464c      	mov	r4, r9
     f7c:	4656      	mov	r6, sl
     f7e:	001f      	movs	r7, r3
     f80:	4598      	cmp	r8, r3
     f82:	d1bc      	bne.n	efe <__gnu_unwind_pr_common+0x1a2>
     f84:	210d      	movs	r1, #13
     f86:	0030      	movs	r0, r6
     f88:	f7ff fe80 	bl	c8c <_Unwind_GetGR>
     f8c:	9b06      	ldr	r3, [sp, #24]
     f8e:	6228      	str	r0, [r5, #32]
     f90:	626b      	str	r3, [r5, #36]	; 0x24
     f92:	62ac      	str	r4, [r5, #40]	; 0x28
     f94:	2006      	movs	r0, #6
     f96:	e759      	b.n	e4c <__gnu_unwind_pr_common+0xf0>
     f98:	0020      	movs	r0, r4
     f9a:	f7ff fc8f 	bl	8bc <selfrel_offset31>
     f9e:	3404      	adds	r4, #4
     fa0:	0007      	movs	r7, r0
     fa2:	63ac      	str	r4, [r5, #56]	; 0x38
     fa4:	0028      	movs	r0, r5
     fa6:	e000      	b.n	faa <__gnu_unwind_pr_common+0x24e>
     fa8:	bf00      	nop
     faa:	2800      	cmp	r0, #0
     fac:	d100      	bne.n	fb0 <__gnu_unwind_pr_common+0x254>
     fae:	e74c      	b.n	e4a <__gnu_unwind_pr_common+0xee>
     fb0:	0030      	movs	r0, r6
     fb2:	003a      	movs	r2, r7
     fb4:	210f      	movs	r1, #15
     fb6:	f7ff fe8d 	bl	cd4 <_Unwind_SetGR>
     fba:	2007      	movs	r0, #7
     fbc:	e746      	b.n	e4c <__gnu_unwind_pr_common+0xf0>
     fbe:	0007      	movs	r7, r0
     fc0:	210d      	movs	r1, #13
     fc2:	0030      	movs	r0, r6
     fc4:	f7ff fe62 	bl	c8c <_Unwind_GetGR>
     fc8:	6228      	str	r0, [r5, #32]
     fca:	2f02      	cmp	r7, #2
     fcc:	d12b      	bne.n	1026 <__gnu_unwind_pr_common+0x2ca>
     fce:	9b06      	ldr	r3, [sp, #24]
     fd0:	62eb      	str	r3, [r5, #44]	; 0x2c
     fd2:	002b      	movs	r3, r5
     fd4:	332c      	adds	r3, #44	; 0x2c
     fd6:	626b      	str	r3, [r5, #36]	; 0x24
     fd8:	62ac      	str	r4, [r5, #40]	; 0x28
     fda:	2006      	movs	r0, #6
     fdc:	e736      	b.n	e4c <__gnu_unwind_pr_common+0xf0>
     fde:	0035      	movs	r5, r6
     fe0:	464c      	mov	r4, r9
     fe2:	4656      	mov	r6, sl
     fe4:	e7ce      	b.n	f84 <__gnu_unwind_pr_common+0x228>
     fe6:	4659      	mov	r1, fp
     fe8:	0030      	movs	r0, r6
     fea:	f000 fa37 	bl	145c <__gnu_unwind_execute>
     fee:	2800      	cmp	r0, #0
     ff0:	d000      	beq.n	ff4 <__gnu_unwind_pr_common+0x298>
     ff2:	e72a      	b.n	e4a <__gnu_unwind_pr_common+0xee>
     ff4:	9b05      	ldr	r3, [sp, #20]
     ff6:	2b00      	cmp	r3, #0
     ff8:	d100      	bne.n	ffc <__gnu_unwind_pr_common+0x2a0>
     ffa:	e737      	b.n	e6c <__gnu_unwind_pr_common+0x110>
     ffc:	210f      	movs	r1, #15
     ffe:	0030      	movs	r0, r6
    1000:	f7ff fe44 	bl	c8c <_Unwind_GetGR>
    1004:	210e      	movs	r1, #14
    1006:	0002      	movs	r2, r0
    1008:	0030      	movs	r0, r6
    100a:	f7ff fe63 	bl	cd4 <_Unwind_SetGR>
    100e:	0030      	movs	r0, r6
    1010:	4a09      	ldr	r2, [pc, #36]	; (1038 <__gnu_unwind_pr_common+0x2dc>)
    1012:	210f      	movs	r1, #15
    1014:	f7ff fe5e 	bl	cd4 <_Unwind_SetGR>
    1018:	2007      	movs	r0, #7
    101a:	e717      	b.n	e4c <__gnu_unwind_pr_common+0xf0>
    101c:	210d      	movs	r1, #13
    101e:	0030      	movs	r0, r6
    1020:	f7ff fe34 	bl	c8c <_Unwind_GetGR>
    1024:	6228      	str	r0, [r5, #32]
    1026:	9b06      	ldr	r3, [sp, #24]
    1028:	626b      	str	r3, [r5, #36]	; 0x24
    102a:	e7d5      	b.n	fd8 <__gnu_unwind_pr_common+0x27c>
    102c:	0038      	movs	r0, r7
    102e:	3001      	adds	r0, #1
    1030:	0080      	lsls	r0, r0, #2
    1032:	1820      	adds	r0, r4, r0
    1034:	e74d      	b.n	ed2 <__gnu_unwind_pr_common+0x176>
    1036:	46c0      	nop			; (mov r8, r8)
    1038:	00000000 	.word	0x00000000

0000103c <__aeabi_unwind_cpp_pr0>:
    103c:	b510      	push	{r4, lr}
    103e:	2300      	movs	r3, #0
    1040:	f7ff fe8c 	bl	d5c <__gnu_unwind_pr_common>
    1044:	bd10      	pop	{r4, pc}
    1046:	46c0      	nop			; (mov r8, r8)

00001048 <__aeabi_unwind_cpp_pr1>:
    1048:	b510      	push	{r4, lr}
    104a:	2301      	movs	r3, #1
    104c:	f7ff fe86 	bl	d5c <__gnu_unwind_pr_common>
    1050:	bd10      	pop	{r4, pc}
    1052:	46c0      	nop			; (mov r8, r8)

00001054 <__aeabi_unwind_cpp_pr2>:
    1054:	b510      	push	{r4, lr}
    1056:	2302      	movs	r3, #2
    1058:	f7ff fe80 	bl	d5c <__gnu_unwind_pr_common>
    105c:	bd10      	pop	{r4, pc}
    105e:	46c0      	nop			; (mov r8, r8)

00001060 <_Unwind_VRS_Pop>:
    1060:	b5f0      	push	{r4, r5, r6, r7, lr}
    1062:	46ce      	mov	lr, r9
    1064:	4647      	mov	r7, r8
    1066:	b580      	push	{r7, lr}
    1068:	0005      	movs	r5, r0
    106a:	b0c3      	sub	sp, #268	; 0x10c
    106c:	0014      	movs	r4, r2
    106e:	001e      	movs	r6, r3
    1070:	2901      	cmp	r1, #1
    1072:	d055      	beq.n	1120 <_Unwind_VRS_Pop+0xc0>
    1074:	2900      	cmp	r1, #0
    1076:	d04b      	beq.n	1110 <_Unwind_VRS_Pop+0xb0>
    1078:	2903      	cmp	r1, #3
    107a:	d022      	beq.n	10c2 <_Unwind_VRS_Pop+0x62>
    107c:	2904      	cmp	r1, #4
    107e:	d149      	bne.n	1114 <_Unwind_VRS_Pop+0xb4>
    1080:	2b00      	cmp	r3, #0
    1082:	d147      	bne.n	1114 <_Unwind_VRS_Pop+0xb4>
    1084:	2a10      	cmp	r2, #16
    1086:	d845      	bhi.n	1114 <_Unwind_VRS_Pop+0xb4>
    1088:	2210      	movs	r2, #16
    108a:	6803      	ldr	r3, [r0, #0]
    108c:	421a      	tst	r2, r3
    108e:	d000      	beq.n	1092 <_Unwind_VRS_Pop+0x32>
    1090:	e0f1      	b.n	1276 <_Unwind_VRS_Pop+0x216>
    1092:	af20      	add	r7, sp, #128	; 0x80
    1094:	0038      	movs	r0, r7
    1096:	f000 f93d 	bl	1314 <__gnu_Unwind_Save_WMMXC>
    109a:	2300      	movs	r3, #0
    109c:	2001      	movs	r0, #1
    109e:	6ba9      	ldr	r1, [r5, #56]	; 0x38
    10a0:	0002      	movs	r2, r0
    10a2:	409a      	lsls	r2, r3
    10a4:	4214      	tst	r4, r2
    10a6:	d003      	beq.n	10b0 <_Unwind_VRS_Pop+0x50>
    10a8:	680e      	ldr	r6, [r1, #0]
    10aa:	009a      	lsls	r2, r3, #2
    10ac:	50be      	str	r6, [r7, r2]
    10ae:	3104      	adds	r1, #4
    10b0:	3301      	adds	r3, #1
    10b2:	2b04      	cmp	r3, #4
    10b4:	d1f4      	bne.n	10a0 <_Unwind_VRS_Pop+0x40>
    10b6:	0038      	movs	r0, r7
    10b8:	63a9      	str	r1, [r5, #56]	; 0x38
    10ba:	f000 f929 	bl	1310 <__gnu_Unwind_Restore_WMMXC>
    10be:	2000      	movs	r0, #0
    10c0:	e029      	b.n	1116 <_Unwind_VRS_Pop+0xb6>
    10c2:	2b03      	cmp	r3, #3
    10c4:	d126      	bne.n	1114 <_Unwind_VRS_Pop+0xb4>
    10c6:	0414      	lsls	r4, r2, #16
    10c8:	0c23      	lsrs	r3, r4, #16
    10ca:	0c16      	lsrs	r6, r2, #16
    10cc:	4698      	mov	r8, r3
    10ce:	18f3      	adds	r3, r6, r3
    10d0:	2b10      	cmp	r3, #16
    10d2:	d81f      	bhi.n	1114 <_Unwind_VRS_Pop+0xb4>
    10d4:	2208      	movs	r2, #8
    10d6:	6803      	ldr	r3, [r0, #0]
    10d8:	421a      	tst	r2, r3
    10da:	d000      	beq.n	10de <_Unwind_VRS_Pop+0x7e>
    10dc:	e098      	b.n	1210 <_Unwind_VRS_Pop+0x1b0>
    10de:	af20      	add	r7, sp, #128	; 0x80
    10e0:	0038      	movs	r0, r7
    10e2:	f000 f913 	bl	130c <__gnu_Unwind_Save_WMMXD>
    10e6:	4642      	mov	r2, r8
    10e8:	6bab      	ldr	r3, [r5, #56]	; 0x38
    10ea:	00f6      	lsls	r6, r6, #3
    10ec:	001c      	movs	r4, r3
    10ee:	2a00      	cmp	r2, #0
    10f0:	d008      	beq.n	1104 <_Unwind_VRS_Pop+0xa4>
    10f2:	00d4      	lsls	r4, r2, #3
    10f4:	1af2      	subs	r2, r6, r3
    10f6:	191c      	adds	r4, r3, r4
    10f8:	18ba      	adds	r2, r7, r2
    10fa:	6819      	ldr	r1, [r3, #0]
    10fc:	50d1      	str	r1, [r2, r3]
    10fe:	3304      	adds	r3, #4
    1100:	429c      	cmp	r4, r3
    1102:	d1fa      	bne.n	10fa <_Unwind_VRS_Pop+0x9a>
    1104:	63ac      	str	r4, [r5, #56]	; 0x38
    1106:	0038      	movs	r0, r7
    1108:	f000 f8fe 	bl	1308 <__gnu_Unwind_Restore_WMMXD>
    110c:	2000      	movs	r0, #0
    110e:	e002      	b.n	1116 <_Unwind_VRS_Pop+0xb6>
    1110:	2b00      	cmp	r3, #0
    1112:	d024      	beq.n	115e <_Unwind_VRS_Pop+0xfe>
    1114:	2002      	movs	r0, #2
    1116:	b043      	add	sp, #268	; 0x10c
    1118:	bc0c      	pop	{r2, r3}
    111a:	4690      	mov	r8, r2
    111c:	4699      	mov	r9, r3
    111e:	bdf0      	pop	{r4, r5, r6, r7, pc}
    1120:	0c13      	lsrs	r3, r2, #16
    1122:	0414      	lsls	r4, r2, #16
    1124:	4698      	mov	r8, r3
    1126:	0c24      	lsrs	r4, r4, #16
    1128:	2e01      	cmp	r6, #1
    112a:	d02e      	beq.n	118a <_Unwind_VRS_Pop+0x12a>
    112c:	2e05      	cmp	r6, #5
    112e:	d1f1      	bne.n	1114 <_Unwind_VRS_Pop+0xb4>
    1130:	191b      	adds	r3, r3, r4
    1132:	2b20      	cmp	r3, #32
    1134:	d8ee      	bhi.n	1114 <_Unwind_VRS_Pop+0xb4>
    1136:	4642      	mov	r2, r8
    1138:	2a0f      	cmp	r2, #15
    113a:	d970      	bls.n	121e <_Unwind_VRS_Pop+0x1be>
    113c:	46a1      	mov	r9, r4
    113e:	2c00      	cmp	r4, #0
    1140:	d17e      	bne.n	1240 <_Unwind_VRS_Pop+0x1e0>
    1142:	6baa      	ldr	r2, [r5, #56]	; 0x38
    1144:	4643      	mov	r3, r8
    1146:	63aa      	str	r2, [r5, #56]	; 0x38
    1148:	2b0f      	cmp	r3, #15
    114a:	d800      	bhi.n	114e <_Unwind_VRS_Pop+0xee>
    114c:	e09a      	b.n	1284 <_Unwind_VRS_Pop+0x224>
    114e:	464b      	mov	r3, r9
    1150:	2b00      	cmp	r3, #0
    1152:	d0db      	beq.n	110c <_Unwind_VRS_Pop+0xac>
    1154:	4668      	mov	r0, sp
    1156:	f000 f8d3 	bl	1300 <__gnu_Unwind_Restore_VFP_D_16_to_31>
    115a:	2000      	movs	r0, #0
    115c:	e7db      	b.n	1116 <_Unwind_VRS_Pop+0xb6>
    115e:	2300      	movs	r3, #0
    1160:	0410      	lsls	r0, r2, #16
    1162:	6ba9      	ldr	r1, [r5, #56]	; 0x38
    1164:	0c00      	lsrs	r0, r0, #16
    1166:	3601      	adds	r6, #1
    1168:	0032      	movs	r2, r6
    116a:	409a      	lsls	r2, r3
    116c:	4210      	tst	r0, r2
    116e:	d004      	beq.n	117a <_Unwind_VRS_Pop+0x11a>
    1170:	680f      	ldr	r7, [r1, #0]
    1172:	009a      	lsls	r2, r3, #2
    1174:	18aa      	adds	r2, r5, r2
    1176:	6057      	str	r7, [r2, #4]
    1178:	3104      	adds	r1, #4
    117a:	3301      	adds	r3, #1
    117c:	2b10      	cmp	r3, #16
    117e:	d1f3      	bne.n	1168 <_Unwind_VRS_Pop+0x108>
    1180:	2000      	movs	r0, #0
    1182:	04a3      	lsls	r3, r4, #18
    1184:	d4c7      	bmi.n	1116 <_Unwind_VRS_Pop+0xb6>
    1186:	63a9      	str	r1, [r5, #56]	; 0x38
    1188:	e7c5      	b.n	1116 <_Unwind_VRS_Pop+0xb6>
    118a:	191b      	adds	r3, r3, r4
    118c:	2b10      	cmp	r3, #16
    118e:	d8c1      	bhi.n	1114 <_Unwind_VRS_Pop+0xb4>
    1190:	4643      	mov	r3, r8
    1192:	2b0f      	cmp	r3, #15
    1194:	d8be      	bhi.n	1114 <_Unwind_VRS_Pop+0xb4>
    1196:	682b      	ldr	r3, [r5, #0]
    1198:	421e      	tst	r6, r3
    119a:	d006      	beq.n	11aa <_Unwind_VRS_Pop+0x14a>
    119c:	2203      	movs	r2, #3
    119e:	0028      	movs	r0, r5
    11a0:	4393      	bics	r3, r2
    11a2:	602b      	str	r3, [r5, #0]
    11a4:	3048      	adds	r0, #72	; 0x48
    11a6:	f000 f8a5 	bl	12f4 <__gnu_Unwind_Save_VFP>
    11aa:	af20      	add	r7, sp, #128	; 0x80
    11ac:	0038      	movs	r0, r7
    11ae:	f000 f8a1 	bl	12f4 <__gnu_Unwind_Save_VFP>
    11b2:	6baa      	ldr	r2, [r5, #56]	; 0x38
    11b4:	2c00      	cmp	r4, #0
    11b6:	d024      	beq.n	1202 <_Unwind_VRS_Pop+0x1a2>
    11b8:	4643      	mov	r3, r8
    11ba:	00db      	lsls	r3, r3, #3
    11bc:	18ff      	adds	r7, r7, r3
    11be:	2300      	movs	r3, #0
    11c0:	4699      	mov	r9, r3
    11c2:	0064      	lsls	r4, r4, #1
    11c4:	2300      	movs	r3, #0
    11c6:	00a4      	lsls	r4, r4, #2
    11c8:	58d1      	ldr	r1, [r2, r3]
    11ca:	50f9      	str	r1, [r7, r3]
    11cc:	3304      	adds	r3, #4
    11ce:	429c      	cmp	r4, r3
    11d0:	d1fa      	bne.n	11c8 <_Unwind_VRS_Pop+0x168>
    11d2:	464b      	mov	r3, r9
    11d4:	1912      	adds	r2, r2, r4
    11d6:	466f      	mov	r7, sp
    11d8:	2b00      	cmp	r3, #0
    11da:	d00f      	beq.n	11fc <_Unwind_VRS_Pop+0x19c>
    11dc:	4640      	mov	r0, r8
    11de:	2810      	cmp	r0, #16
    11e0:	d200      	bcs.n	11e4 <_Unwind_VRS_Pop+0x184>
    11e2:	2010      	movs	r0, #16
    11e4:	464b      	mov	r3, r9
    11e6:	00d9      	lsls	r1, r3, #3
    11e8:	2300      	movs	r3, #0
    11ea:	3810      	subs	r0, #16
    11ec:	00c0      	lsls	r0, r0, #3
    11ee:	1838      	adds	r0, r7, r0
    11f0:	58d4      	ldr	r4, [r2, r3]
    11f2:	50c4      	str	r4, [r0, r3]
    11f4:	3304      	adds	r3, #4
    11f6:	4299      	cmp	r1, r3
    11f8:	d1fa      	bne.n	11f0 <_Unwind_VRS_Pop+0x190>
    11fa:	1852      	adds	r2, r2, r1
    11fc:	2e01      	cmp	r6, #1
    11fe:	d1a1      	bne.n	1144 <_Unwind_VRS_Pop+0xe4>
    1200:	af20      	add	r7, sp, #128	; 0x80
    1202:	3204      	adds	r2, #4
    1204:	0038      	movs	r0, r7
    1206:	63aa      	str	r2, [r5, #56]	; 0x38
    1208:	f000 f872 	bl	12f0 <__gnu_Unwind_Restore_VFP>
    120c:	2000      	movs	r0, #0
    120e:	e782      	b.n	1116 <_Unwind_VRS_Pop+0xb6>
    1210:	4393      	bics	r3, r2
    1212:	6003      	str	r3, [r0, #0]
    1214:	3051      	adds	r0, #81	; 0x51
    1216:	30ff      	adds	r0, #255	; 0xff
    1218:	f000 f878 	bl	130c <__gnu_Unwind_Save_WMMXD>
    121c:	e75f      	b.n	10de <_Unwind_VRS_Pop+0x7e>
    121e:	2b10      	cmp	r3, #16
    1220:	d93b      	bls.n	129a <_Unwind_VRS_Pop+0x23a>
    1222:	2210      	movs	r2, #16
    1224:	4252      	negs	r2, r2
    1226:	4691      	mov	r9, r2
    1228:	4499      	add	r9, r3
    122a:	682b      	ldr	r3, [r5, #0]
    122c:	4219      	tst	r1, r3
    122e:	d008      	beq.n	1242 <_Unwind_VRS_Pop+0x1e2>
    1230:	2202      	movs	r2, #2
    1232:	0028      	movs	r0, r5
    1234:	438b      	bics	r3, r1
    1236:	4313      	orrs	r3, r2
    1238:	602b      	str	r3, [r5, #0]
    123a:	3048      	adds	r0, #72	; 0x48
    123c:	f000 f85e 	bl	12fc <__gnu_Unwind_Save_VFP_D>
    1240:	682b      	ldr	r3, [r5, #0]
    1242:	2204      	movs	r2, #4
    1244:	421a      	tst	r2, r3
    1246:	d121      	bne.n	128c <_Unwind_VRS_Pop+0x22c>
    1248:	4643      	mov	r3, r8
    124a:	2b0f      	cmp	r3, #15
    124c:	d803      	bhi.n	1256 <_Unwind_VRS_Pop+0x1f6>
    124e:	af20      	add	r7, sp, #128	; 0x80
    1250:	0038      	movs	r0, r7
    1252:	f000 f853 	bl	12fc <__gnu_Unwind_Save_VFP_D>
    1256:	466f      	mov	r7, sp
    1258:	0038      	movs	r0, r7
    125a:	f000 f853 	bl	1304 <__gnu_Unwind_Save_VFP_D_16_to_31>
    125e:	2410      	movs	r4, #16
    1260:	4643      	mov	r3, r8
    1262:	6baa      	ldr	r2, [r5, #56]	; 0x38
    1264:	1ae4      	subs	r4, r4, r3
    1266:	2c00      	cmp	r4, #0
    1268:	ddb8      	ble.n	11dc <_Unwind_VRS_Pop+0x17c>
    126a:	4643      	mov	r3, r8
    126c:	af20      	add	r7, sp, #128	; 0x80
    126e:	00db      	lsls	r3, r3, #3
    1270:	0064      	lsls	r4, r4, #1
    1272:	18ff      	adds	r7, r7, r3
    1274:	e7a6      	b.n	11c4 <_Unwind_VRS_Pop+0x164>
    1276:	4393      	bics	r3, r2
    1278:	6003      	str	r3, [r0, #0]
    127a:	30d1      	adds	r0, #209	; 0xd1
    127c:	30ff      	adds	r0, #255	; 0xff
    127e:	f000 f849 	bl	1314 <__gnu_Unwind_Save_WMMXC>
    1282:	e706      	b.n	1092 <_Unwind_VRS_Pop+0x32>
    1284:	a820      	add	r0, sp, #128	; 0x80
    1286:	f000 f837 	bl	12f8 <__gnu_Unwind_Restore_VFP_D>
    128a:	e760      	b.n	114e <_Unwind_VRS_Pop+0xee>
    128c:	0028      	movs	r0, r5
    128e:	4393      	bics	r3, r2
    1290:	602b      	str	r3, [r5, #0]
    1292:	30d0      	adds	r0, #208	; 0xd0
    1294:	f000 f836 	bl	1304 <__gnu_Unwind_Save_VFP_D_16_to_31>
    1298:	e7d6      	b.n	1248 <_Unwind_VRS_Pop+0x1e8>
    129a:	682b      	ldr	r3, [r5, #0]
    129c:	420b      	tst	r3, r1
    129e:	d007      	beq.n	12b0 <_Unwind_VRS_Pop+0x250>
    12a0:	2202      	movs	r2, #2
    12a2:	0028      	movs	r0, r5
    12a4:	438b      	bics	r3, r1
    12a6:	4313      	orrs	r3, r2
    12a8:	602b      	str	r3, [r5, #0]
    12aa:	3048      	adds	r0, #72	; 0x48
    12ac:	f000 f826 	bl	12fc <__gnu_Unwind_Save_VFP_D>
    12b0:	af20      	add	r7, sp, #128	; 0x80
    12b2:	0038      	movs	r0, r7
    12b4:	f000 f822 	bl	12fc <__gnu_Unwind_Save_VFP_D>
    12b8:	46a1      	mov	r9, r4
    12ba:	6baa      	ldr	r2, [r5, #56]	; 0x38
    12bc:	2c00      	cmp	r4, #0
    12be:	d000      	beq.n	12c2 <_Unwind_VRS_Pop+0x262>
    12c0:	e77a      	b.n	11b8 <_Unwind_VRS_Pop+0x158>
    12c2:	e73f      	b.n	1144 <_Unwind_VRS_Pop+0xe4>

000012c4 <__restore_core_regs>:
    12c4:	1c01      	adds	r1, r0, #0
    12c6:	3134      	adds	r1, #52	; 0x34
    12c8:	c938      	ldmia	r1!, {r3, r4, r5}
    12ca:	3b04      	subs	r3, #4
    12cc:	469c      	mov	ip, r3
    12ce:	601d      	str	r5, [r3, #0]
    12d0:	46a6      	mov	lr, r4
    12d2:	1c01      	adds	r1, r0, #0
    12d4:	3120      	adds	r1, #32
    12d6:	c93c      	ldmia	r1!, {r2, r3, r4, r5}
    12d8:	4690      	mov	r8, r2
    12da:	4699      	mov	r9, r3
    12dc:	46a2      	mov	sl, r4
    12de:	46ab      	mov	fp, r5
    12e0:	1c01      	adds	r1, r0, #0
    12e2:	3108      	adds	r1, #8
    12e4:	c9fc      	ldmia	r1!, {r2, r3, r4, r5, r6, r7}
    12e6:	6841      	ldr	r1, [r0, #4]
    12e8:	6800      	ldr	r0, [r0, #0]
    12ea:	46e5      	mov	sp, ip
    12ec:	bd00      	pop	{pc}
    12ee:	46c0      	nop			; (mov r8, r8)

000012f0 <__gnu_Unwind_Restore_VFP>:
    12f0:	4770      	bx	lr
    12f2:	46c0      	nop			; (mov r8, r8)

000012f4 <__gnu_Unwind_Save_VFP>:
    12f4:	4770      	bx	lr
    12f6:	46c0      	nop			; (mov r8, r8)

000012f8 <__gnu_Unwind_Restore_VFP_D>:
    12f8:	4770      	bx	lr
    12fa:	46c0      	nop			; (mov r8, r8)

000012fc <__gnu_Unwind_Save_VFP_D>:
    12fc:	4770      	bx	lr
    12fe:	46c0      	nop			; (mov r8, r8)

00001300 <__gnu_Unwind_Restore_VFP_D_16_to_31>:
    1300:	4770      	bx	lr
    1302:	46c0      	nop			; (mov r8, r8)

00001304 <__gnu_Unwind_Save_VFP_D_16_to_31>:
    1304:	4770      	bx	lr
    1306:	46c0      	nop			; (mov r8, r8)

00001308 <__gnu_Unwind_Restore_WMMXD>:
    1308:	4770      	bx	lr
    130a:	46c0      	nop			; (mov r8, r8)

0000130c <__gnu_Unwind_Save_WMMXD>:
    130c:	4770      	bx	lr
    130e:	46c0      	nop			; (mov r8, r8)

00001310 <__gnu_Unwind_Restore_WMMXC>:
    1310:	4770      	bx	lr
    1312:	46c0      	nop			; (mov r8, r8)

00001314 <__gnu_Unwind_Save_WMMXC>:
    1314:	4770      	bx	lr
    1316:	46c0      	nop			; (mov r8, r8)

00001318 <_Unwind_RaiseException>:
    1318:	b401      	push	{r0}
    131a:	a801      	add	r0, sp, #4
    131c:	b501      	push	{r0, lr}
    131e:	b085      	sub	sp, #20
    1320:	b4ff      	push	{r0, r1, r2, r3, r4, r5, r6, r7}
    1322:	a808      	add	r0, sp, #32
    1324:	4641      	mov	r1, r8
    1326:	464a      	mov	r2, r9
    1328:	4653      	mov	r3, sl
    132a:	465c      	mov	r4, fp
    132c:	4665      	mov	r5, ip
    132e:	c03e      	stmia	r0!, {r1, r2, r3, r4, r5}
    1330:	a801      	add	r0, sp, #4
    1332:	c83e      	ldmia	r0!, {r1, r2, r3, r4, r5}
    1334:	980f      	ldr	r0, [sp, #60]	; 0x3c
    1336:	9000      	str	r0, [sp, #0]
    1338:	2300      	movs	r3, #0
    133a:	b40c      	push	{r2, r3}
    133c:	a901      	add	r1, sp, #4
    133e:	f7ff fc1d 	bl	b7c <__gnu_Unwind_RaiseException>
    1342:	9b10      	ldr	r3, [sp, #64]	; 0x40
    1344:	b012      	add	sp, #72	; 0x48
    1346:	4718      	bx	r3

00001348 <_Unwind_Resume>:
    1348:	b401      	push	{r0}
    134a:	a801      	add	r0, sp, #4
    134c:	b501      	push	{r0, lr}
    134e:	b085      	sub	sp, #20
    1350:	b4ff      	push	{r0, r1, r2, r3, r4, r5, r6, r7}
    1352:	a808      	add	r0, sp, #32
    1354:	4641      	mov	r1, r8
    1356:	464a      	mov	r2, r9
    1358:	4653      	mov	r3, sl
    135a:	465c      	mov	r4, fp
    135c:	4665      	mov	r5, ip
    135e:	c03e      	stmia	r0!, {r1, r2, r3, r4, r5}
    1360:	a801      	add	r0, sp, #4
    1362:	c83e      	ldmia	r0!, {r1, r2, r3, r4, r5}
    1364:	980f      	ldr	r0, [sp, #60]	; 0x3c
    1366:	9000      	str	r0, [sp, #0]
    1368:	2300      	movs	r3, #0
    136a:	b40c      	push	{r2, r3}
    136c:	a901      	add	r1, sp, #4
    136e:	f7ff fc39 	bl	be4 <__gnu_Unwind_Resume>
    1372:	9b10      	ldr	r3, [sp, #64]	; 0x40
    1374:	b012      	add	sp, #72	; 0x48
    1376:	4718      	bx	r3

00001378 <_Unwind_Resume_or_Rethrow>:
    1378:	b401      	push	{r0}
    137a:	a801      	add	r0, sp, #4
    137c:	b501      	push	{r0, lr}
    137e:	b085      	sub	sp, #20
    1380:	b4ff      	push	{r0, r1, r2, r3, r4, r5, r6, r7}
    1382:	a808      	add	r0, sp, #32
    1384:	4641      	mov	r1, r8
    1386:	464a      	mov	r2, r9
    1388:	4653      	mov	r3, sl
    138a:	465c      	mov	r4, fp
    138c:	4665      	mov	r5, ip
    138e:	c03e      	stmia	r0!, {r1, r2, r3, r4, r5}
    1390:	a801      	add	r0, sp, #4
    1392:	c83e      	ldmia	r0!, {r1, r2, r3, r4, r5}
    1394:	980f      	ldr	r0, [sp, #60]	; 0x3c
    1396:	9000      	str	r0, [sp, #0]
    1398:	2300      	movs	r3, #0
    139a:	b40c      	push	{r2, r3}
    139c:	a901      	add	r1, sp, #4
    139e:	f7ff fc45 	bl	c2c <__gnu_Unwind_Resume_or_Rethrow>
    13a2:	9b10      	ldr	r3, [sp, #64]	; 0x40
    13a4:	b012      	add	sp, #72	; 0x48
    13a6:	4718      	bx	r3

000013a8 <_Unwind_ForcedUnwind>:
    13a8:	b401      	push	{r0}
    13aa:	a801      	add	r0, sp, #4
    13ac:	b501      	push	{r0, lr}
    13ae:	b085      	sub	sp, #20
    13b0:	b4ff      	push	{r0, r1, r2, r3, r4, r5, r6, r7}
    13b2:	a808      	add	r0, sp, #32
    13b4:	4641      	mov	r1, r8
    13b6:	464a      	mov	r2, r9
    13b8:	4653      	mov	r3, sl
    13ba:	465c      	mov	r4, fp
    13bc:	4665      	mov	r5, ip
    13be:	c03e      	stmia	r0!, {r1, r2, r3, r4, r5}
    13c0:	a801      	add	r0, sp, #4
    13c2:	c83e      	ldmia	r0!, {r1, r2, r3, r4, r5}
    13c4:	980f      	ldr	r0, [sp, #60]	; 0x3c
    13c6:	9000      	str	r0, [sp, #0]
    13c8:	2300      	movs	r3, #0
    13ca:	b40c      	push	{r2, r3}
    13cc:	ab01      	add	r3, sp, #4
    13ce:	f7ff fbff 	bl	bd0 <__gnu_Unwind_ForcedUnwind>
    13d2:	9b10      	ldr	r3, [sp, #64]	; 0x40
    13d4:	b012      	add	sp, #72	; 0x48
    13d6:	4718      	bx	r3

000013d8 <_Unwind_Backtrace>:
    13d8:	b401      	push	{r0}
    13da:	a801      	add	r0, sp, #4
    13dc:	b501      	push	{r0, lr}
    13de:	b085      	sub	sp, #20
    13e0:	b4ff      	push	{r0, r1, r2, r3, r4, r5, r6, r7}
    13e2:	a808      	add	r0, sp, #32
    13e4:	4641      	mov	r1, r8
    13e6:	464a      	mov	r2, r9
    13e8:	4653      	mov	r3, sl
    13ea:	465c      	mov	r4, fp
    13ec:	4665      	mov	r5, ip
    13ee:	c03e      	stmia	r0!, {r1, r2, r3, r4, r5}
    13f0:	a801      	add	r0, sp, #4
    13f2:	c83e      	ldmia	r0!, {r1, r2, r3, r4, r5}
    13f4:	980f      	ldr	r0, [sp, #60]	; 0x3c
    13f6:	9000      	str	r0, [sp, #0]
    13f8:	2300      	movs	r3, #0
    13fa:	b40c      	push	{r2, r3}
    13fc:	aa01      	add	r2, sp, #4
    13fe:	f7ff fc75 	bl	cec <__gnu_Unwind_Backtrace>
    1402:	9b10      	ldr	r3, [sp, #64]	; 0x40
    1404:	b012      	add	sp, #72	; 0x48
    1406:	4718      	bx	r3

00001408 <next_unwind_byte>:
    1408:	7a02      	ldrb	r2, [r0, #8]
    140a:	0003      	movs	r3, r0
    140c:	2a00      	cmp	r2, #0
    140e:	d10b      	bne.n	1428 <next_unwind_byte+0x20>
    1410:	7a42      	ldrb	r2, [r0, #9]
    1412:	2a00      	cmp	r2, #0
    1414:	d00f      	beq.n	1436 <next_unwind_byte+0x2e>
    1416:	3a01      	subs	r2, #1
    1418:	7242      	strb	r2, [r0, #9]
    141a:	6842      	ldr	r2, [r0, #4]
    141c:	1d11      	adds	r1, r2, #4
    141e:	6041      	str	r1, [r0, #4]
    1420:	2103      	movs	r1, #3
    1422:	6812      	ldr	r2, [r2, #0]
    1424:	7201      	strb	r1, [r0, #8]
    1426:	e002      	b.n	142e <next_unwind_byte+0x26>
    1428:	3a01      	subs	r2, #1
    142a:	7202      	strb	r2, [r0, #8]
    142c:	6802      	ldr	r2, [r0, #0]
    142e:	0e10      	lsrs	r0, r2, #24
    1430:	0212      	lsls	r2, r2, #8
    1432:	601a      	str	r2, [r3, #0]
    1434:	4770      	bx	lr
    1436:	20b0      	movs	r0, #176	; 0xb0
    1438:	e7fc      	b.n	1434 <next_unwind_byte+0x2c>
    143a:	46c0      	nop			; (mov r8, r8)

0000143c <_Unwind_GetGR.constprop.0>:
    143c:	b500      	push	{lr}
    143e:	b085      	sub	sp, #20
    1440:	ab03      	add	r3, sp, #12
    1442:	9300      	str	r3, [sp, #0]
    1444:	220c      	movs	r2, #12
    1446:	2300      	movs	r3, #0
    1448:	2100      	movs	r1, #0
    144a:	f7ff fc07 	bl	c5c <_Unwind_VRS_Get>
    144e:	9803      	ldr	r0, [sp, #12]
    1450:	b005      	add	sp, #20
    1452:	bd00      	pop	{pc}

00001454 <unwind_UCB_from_context>:
    1454:	b510      	push	{r4, lr}
    1456:	f7ff fff1 	bl	143c <_Unwind_GetGR.constprop.0>
    145a:	bd10      	pop	{r4, pc}

0000145c <__gnu_unwind_execute>:
    145c:	b5f0      	push	{r4, r5, r6, r7, lr}
    145e:	4657      	mov	r7, sl
    1460:	464e      	mov	r6, r9
    1462:	4645      	mov	r5, r8
    1464:	46de      	mov	lr, fp
    1466:	2300      	movs	r3, #0
    1468:	b5e0      	push	{r5, r6, r7, lr}
    146a:	b087      	sub	sp, #28
    146c:	9303      	str	r3, [sp, #12]
    146e:	330f      	adds	r3, #15
    1470:	4698      	mov	r8, r3
    1472:	3b08      	subs	r3, #8
    1474:	4699      	mov	r9, r3
    1476:	2380      	movs	r3, #128	; 0x80
    1478:	031b      	lsls	r3, r3, #12
    147a:	0006      	movs	r6, r0
    147c:	000f      	movs	r7, r1
    147e:	469a      	mov	sl, r3
    1480:	0038      	movs	r0, r7
    1482:	f7ff ffc1 	bl	1408 <next_unwind_byte>
    1486:	0004      	movs	r4, r0
    1488:	28b0      	cmp	r0, #176	; 0xb0
    148a:	d100      	bne.n	148e <__gnu_unwind_execute+0x32>
    148c:	e0c3      	b.n	1616 <__gnu_unwind_execute+0x1ba>
    148e:	0603      	lsls	r3, r0, #24
    1490:	d52a      	bpl.n	14e8 <__gnu_unwind_execute+0x8c>
    1492:	0003      	movs	r3, r0
    1494:	4642      	mov	r2, r8
    1496:	4393      	bics	r3, r2
    1498:	b2db      	uxtb	r3, r3
    149a:	2b80      	cmp	r3, #128	; 0x80
    149c:	d100      	bne.n	14a0 <__gnu_unwind_execute+0x44>
    149e:	e071      	b.n	1584 <__gnu_unwind_execute+0x128>
    14a0:	2b90      	cmp	r3, #144	; 0x90
    14a2:	d03d      	beq.n	1520 <__gnu_unwind_execute+0xc4>
    14a4:	2ba0      	cmp	r3, #160	; 0xa0
    14a6:	d100      	bne.n	14aa <__gnu_unwind_execute+0x4e>
    14a8:	e085      	b.n	15b6 <__gnu_unwind_execute+0x15a>
    14aa:	2bb0      	cmp	r3, #176	; 0xb0
    14ac:	d050      	beq.n	1550 <__gnu_unwind_execute+0xf4>
    14ae:	2bc0      	cmp	r3, #192	; 0xc0
    14b0:	d100      	bne.n	14b4 <__gnu_unwind_execute+0x58>
    14b2:	e096      	b.n	15e2 <__gnu_unwind_execute+0x186>
    14b4:	0003      	movs	r3, r0
    14b6:	464a      	mov	r2, r9
    14b8:	4393      	bics	r3, r2
    14ba:	b2db      	uxtb	r3, r3
    14bc:	2bd0      	cmp	r3, #208	; 0xd0
    14be:	d10a      	bne.n	14d6 <__gnu_unwind_execute+0x7a>
    14c0:	4653      	mov	r3, sl
    14c2:	4002      	ands	r2, r0
    14c4:	3201      	adds	r2, #1
    14c6:	431a      	orrs	r2, r3
    14c8:	2305      	movs	r3, #5
    14ca:	2101      	movs	r1, #1
    14cc:	0030      	movs	r0, r6
    14ce:	f7ff fdc7 	bl	1060 <_Unwind_VRS_Pop>
    14d2:	2800      	cmp	r0, #0
    14d4:	d0d4      	beq.n	1480 <__gnu_unwind_execute+0x24>
    14d6:	2409      	movs	r4, #9
    14d8:	0020      	movs	r0, r4
    14da:	b007      	add	sp, #28
    14dc:	bc3c      	pop	{r2, r3, r4, r5}
    14de:	4690      	mov	r8, r2
    14e0:	4699      	mov	r9, r3
    14e2:	46a2      	mov	sl, r4
    14e4:	46ab      	mov	fp, r5
    14e6:	bdf0      	pop	{r4, r5, r6, r7, pc}
    14e8:	23ff      	movs	r3, #255	; 0xff
    14ea:	0082      	lsls	r2, r0, #2
    14ec:	4013      	ands	r3, r2
    14ee:	1d1d      	adds	r5, r3, #4
    14f0:	ab05      	add	r3, sp, #20
    14f2:	469b      	mov	fp, r3
    14f4:	9300      	str	r3, [sp, #0]
    14f6:	220d      	movs	r2, #13
    14f8:	2300      	movs	r3, #0
    14fa:	2100      	movs	r1, #0
    14fc:	0030      	movs	r0, r6
    14fe:	f7ff fbad 	bl	c5c <_Unwind_VRS_Get>
    1502:	0663      	lsls	r3, r4, #25
    1504:	d420      	bmi.n	1548 <__gnu_unwind_execute+0xec>
    1506:	9b05      	ldr	r3, [sp, #20]
    1508:	469c      	mov	ip, r3
    150a:	4465      	add	r5, ip
    150c:	9505      	str	r5, [sp, #20]
    150e:	465b      	mov	r3, fp
    1510:	220d      	movs	r2, #13
    1512:	9300      	str	r3, [sp, #0]
    1514:	2100      	movs	r1, #0
    1516:	2300      	movs	r3, #0
    1518:	0030      	movs	r0, r6
    151a:	f7ff fbc3 	bl	ca4 <_Unwind_VRS_Set>
    151e:	e7af      	b.n	1480 <__gnu_unwind_execute+0x24>
    1520:	3b83      	subs	r3, #131	; 0x83
    1522:	4003      	ands	r3, r0
    1524:	2b0d      	cmp	r3, #13
    1526:	d0d6      	beq.n	14d6 <__gnu_unwind_execute+0x7a>
    1528:	ad05      	add	r5, sp, #20
    152a:	4002      	ands	r2, r0
    152c:	9500      	str	r5, [sp, #0]
    152e:	2300      	movs	r3, #0
    1530:	2100      	movs	r1, #0
    1532:	0030      	movs	r0, r6
    1534:	f7ff fb92 	bl	c5c <_Unwind_VRS_Get>
    1538:	9500      	str	r5, [sp, #0]
    153a:	2300      	movs	r3, #0
    153c:	220d      	movs	r2, #13
    153e:	2100      	movs	r1, #0
    1540:	0030      	movs	r0, r6
    1542:	f7ff fbaf 	bl	ca4 <_Unwind_VRS_Set>
    1546:	e79b      	b.n	1480 <__gnu_unwind_execute+0x24>
    1548:	9b05      	ldr	r3, [sp, #20]
    154a:	1b5d      	subs	r5, r3, r5
    154c:	9505      	str	r5, [sp, #20]
    154e:	e7de      	b.n	150e <__gnu_unwind_execute+0xb2>
    1550:	28b1      	cmp	r0, #177	; 0xb1
    1552:	d074      	beq.n	163e <__gnu_unwind_execute+0x1e2>
    1554:	28b2      	cmp	r0, #178	; 0xb2
    1556:	d100      	bne.n	155a <__gnu_unwind_execute+0xfe>
    1558:	e0cf      	b.n	16fa <__gnu_unwind_execute+0x29e>
    155a:	28b3      	cmp	r0, #179	; 0xb3
    155c:	d100      	bne.n	1560 <__gnu_unwind_execute+0x104>
    155e:	e084      	b.n	166a <__gnu_unwind_execute+0x20e>
    1560:	23fc      	movs	r3, #252	; 0xfc
    1562:	4003      	ands	r3, r0
    1564:	2bb4      	cmp	r3, #180	; 0xb4
    1566:	d0b6      	beq.n	14d6 <__gnu_unwind_execute+0x7a>
    1568:	464a      	mov	r2, r9
    156a:	4653      	mov	r3, sl
    156c:	4002      	ands	r2, r0
    156e:	3201      	adds	r2, #1
    1570:	431a      	orrs	r2, r3
    1572:	2101      	movs	r1, #1
    1574:	2301      	movs	r3, #1
    1576:	0030      	movs	r0, r6
    1578:	f7ff fd72 	bl	1060 <_Unwind_VRS_Pop>
    157c:	2800      	cmp	r0, #0
    157e:	d100      	bne.n	1582 <__gnu_unwind_execute+0x126>
    1580:	e77e      	b.n	1480 <__gnu_unwind_execute+0x24>
    1582:	e7a8      	b.n	14d6 <__gnu_unwind_execute+0x7a>
    1584:	0204      	lsls	r4, r0, #8
    1586:	0038      	movs	r0, r7
    1588:	f7ff ff3e 	bl	1408 <next_unwind_byte>
    158c:	2580      	movs	r5, #128	; 0x80
    158e:	4320      	orrs	r0, r4
    1590:	022d      	lsls	r5, r5, #8
    1592:	42a8      	cmp	r0, r5
    1594:	d09f      	beq.n	14d6 <__gnu_unwind_execute+0x7a>
    1596:	0104      	lsls	r4, r0, #4
    1598:	0500      	lsls	r0, r0, #20
    159a:	0c02      	lsrs	r2, r0, #16
    159c:	2300      	movs	r3, #0
    159e:	2100      	movs	r1, #0
    15a0:	0030      	movs	r0, r6
    15a2:	f7ff fd5d 	bl	1060 <_Unwind_VRS_Pop>
    15a6:	2800      	cmp	r0, #0
    15a8:	d195      	bne.n	14d6 <__gnu_unwind_execute+0x7a>
    15aa:	422c      	tst	r4, r5
    15ac:	d100      	bne.n	15b0 <__gnu_unwind_execute+0x154>
    15ae:	e767      	b.n	1480 <__gnu_unwind_execute+0x24>
    15b0:	2301      	movs	r3, #1
    15b2:	9303      	str	r3, [sp, #12]
    15b4:	e764      	b.n	1480 <__gnu_unwind_execute+0x24>
    15b6:	23ff      	movs	r3, #255	; 0xff
    15b8:	464a      	mov	r2, r9
    15ba:	011b      	lsls	r3, r3, #4
    15bc:	0019      	movs	r1, r3
    15be:	4382      	bics	r2, r0
    15c0:	4111      	asrs	r1, r2
    15c2:	000a      	movs	r2, r1
    15c4:	401a      	ands	r2, r3
    15c6:	0703      	lsls	r3, r0, #28
    15c8:	d502      	bpl.n	15d0 <__gnu_unwind_execute+0x174>
    15ca:	2380      	movs	r3, #128	; 0x80
    15cc:	01db      	lsls	r3, r3, #7
    15ce:	431a      	orrs	r2, r3
    15d0:	2300      	movs	r3, #0
    15d2:	2100      	movs	r1, #0
    15d4:	0030      	movs	r0, r6
    15d6:	f7ff fd43 	bl	1060 <_Unwind_VRS_Pop>
    15da:	2800      	cmp	r0, #0
    15dc:	d100      	bne.n	15e0 <__gnu_unwind_execute+0x184>
    15de:	e74f      	b.n	1480 <__gnu_unwind_execute+0x24>
    15e0:	e779      	b.n	14d6 <__gnu_unwind_execute+0x7a>
    15e2:	28c6      	cmp	r0, #198	; 0xc6
    15e4:	d04c      	beq.n	1680 <__gnu_unwind_execute+0x224>
    15e6:	28c7      	cmp	r0, #199	; 0xc7
    15e8:	d05e      	beq.n	16a8 <__gnu_unwind_execute+0x24c>
    15ea:	0003      	movs	r3, r0
    15ec:	464a      	mov	r2, r9
    15ee:	4393      	bics	r3, r2
    15f0:	b2db      	uxtb	r3, r3
    15f2:	2bc0      	cmp	r3, #192	; 0xc0
    15f4:	d06d      	beq.n	16d2 <__gnu_unwind_execute+0x276>
    15f6:	28c8      	cmp	r0, #200	; 0xc8
    15f8:	d072      	beq.n	16e0 <__gnu_unwind_execute+0x284>
    15fa:	28c9      	cmp	r0, #201	; 0xc9
    15fc:	d000      	beq.n	1600 <__gnu_unwind_execute+0x1a4>
    15fe:	e76a      	b.n	14d6 <__gnu_unwind_execute+0x7a>
    1600:	0038      	movs	r0, r7
    1602:	f7ff ff01 	bl	1408 <next_unwind_byte>
    1606:	23f0      	movs	r3, #240	; 0xf0
    1608:	0302      	lsls	r2, r0, #12
    160a:	031b      	lsls	r3, r3, #12
    160c:	4013      	ands	r3, r2
    160e:	4642      	mov	r2, r8
    1610:	4002      	ands	r2, r0
    1612:	3201      	adds	r2, #1
    1614:	e757      	b.n	14c6 <__gnu_unwind_execute+0x6a>
    1616:	9b03      	ldr	r3, [sp, #12]
    1618:	2400      	movs	r4, #0
    161a:	2b00      	cmp	r3, #0
    161c:	d000      	beq.n	1620 <__gnu_unwind_execute+0x1c4>
    161e:	e75b      	b.n	14d8 <__gnu_unwind_execute+0x7c>
    1620:	ad05      	add	r5, sp, #20
    1622:	9500      	str	r5, [sp, #0]
    1624:	220e      	movs	r2, #14
    1626:	2100      	movs	r1, #0
    1628:	0030      	movs	r0, r6
    162a:	f7ff fb17 	bl	c5c <_Unwind_VRS_Get>
    162e:	9500      	str	r5, [sp, #0]
    1630:	2300      	movs	r3, #0
    1632:	220f      	movs	r2, #15
    1634:	2100      	movs	r1, #0
    1636:	0030      	movs	r0, r6
    1638:	f7ff fb34 	bl	ca4 <_Unwind_VRS_Set>
    163c:	e74c      	b.n	14d8 <__gnu_unwind_execute+0x7c>
    163e:	0038      	movs	r0, r7
    1640:	f7ff fee2 	bl	1408 <next_unwind_byte>
    1644:	2800      	cmp	r0, #0
    1646:	d100      	bne.n	164a <__gnu_unwind_execute+0x1ee>
    1648:	e745      	b.n	14d6 <__gnu_unwind_execute+0x7a>
    164a:	0003      	movs	r3, r0
    164c:	4642      	mov	r2, r8
    164e:	4393      	bics	r3, r2
    1650:	b2db      	uxtb	r3, r3
    1652:	2b00      	cmp	r3, #0
    1654:	d000      	beq.n	1658 <__gnu_unwind_execute+0x1fc>
    1656:	e73e      	b.n	14d6 <__gnu_unwind_execute+0x7a>
    1658:	0002      	movs	r2, r0
    165a:	2100      	movs	r1, #0
    165c:	0030      	movs	r0, r6
    165e:	f7ff fcff 	bl	1060 <_Unwind_VRS_Pop>
    1662:	2800      	cmp	r0, #0
    1664:	d100      	bne.n	1668 <__gnu_unwind_execute+0x20c>
    1666:	e70b      	b.n	1480 <__gnu_unwind_execute+0x24>
    1668:	e735      	b.n	14d6 <__gnu_unwind_execute+0x7a>
    166a:	0038      	movs	r0, r7
    166c:	f7ff fecc 	bl	1408 <next_unwind_byte>
    1670:	23f0      	movs	r3, #240	; 0xf0
    1672:	0302      	lsls	r2, r0, #12
    1674:	031b      	lsls	r3, r3, #12
    1676:	4013      	ands	r3, r2
    1678:	4642      	mov	r2, r8
    167a:	4002      	ands	r2, r0
    167c:	3201      	adds	r2, #1
    167e:	e777      	b.n	1570 <__gnu_unwind_execute+0x114>
    1680:	0038      	movs	r0, r7
    1682:	f7ff fec1 	bl	1408 <next_unwind_byte>
    1686:	23f0      	movs	r3, #240	; 0xf0
    1688:	0302      	lsls	r2, r0, #12
    168a:	031b      	lsls	r3, r3, #12
    168c:	4013      	ands	r3, r2
    168e:	4642      	mov	r2, r8
    1690:	4002      	ands	r2, r0
    1692:	3201      	adds	r2, #1
    1694:	431a      	orrs	r2, r3
    1696:	2303      	movs	r3, #3
    1698:	2103      	movs	r1, #3
    169a:	0030      	movs	r0, r6
    169c:	f7ff fce0 	bl	1060 <_Unwind_VRS_Pop>
    16a0:	2800      	cmp	r0, #0
    16a2:	d100      	bne.n	16a6 <__gnu_unwind_execute+0x24a>
    16a4:	e6ec      	b.n	1480 <__gnu_unwind_execute+0x24>
    16a6:	e716      	b.n	14d6 <__gnu_unwind_execute+0x7a>
    16a8:	0038      	movs	r0, r7
    16aa:	f7ff fead 	bl	1408 <next_unwind_byte>
    16ae:	1e02      	subs	r2, r0, #0
    16b0:	d100      	bne.n	16b4 <__gnu_unwind_execute+0x258>
    16b2:	e710      	b.n	14d6 <__gnu_unwind_execute+0x7a>
    16b4:	0003      	movs	r3, r0
    16b6:	4641      	mov	r1, r8
    16b8:	438b      	bics	r3, r1
    16ba:	b2db      	uxtb	r3, r3
    16bc:	2b00      	cmp	r3, #0
    16be:	d000      	beq.n	16c2 <__gnu_unwind_execute+0x266>
    16c0:	e709      	b.n	14d6 <__gnu_unwind_execute+0x7a>
    16c2:	2104      	movs	r1, #4
    16c4:	0030      	movs	r0, r6
    16c6:	f7ff fccb 	bl	1060 <_Unwind_VRS_Pop>
    16ca:	2800      	cmp	r0, #0
    16cc:	d100      	bne.n	16d0 <__gnu_unwind_execute+0x274>
    16ce:	e6d7      	b.n	1480 <__gnu_unwind_execute+0x24>
    16d0:	e701      	b.n	14d6 <__gnu_unwind_execute+0x7a>
    16d2:	4643      	mov	r3, r8
    16d4:	22a0      	movs	r2, #160	; 0xa0
    16d6:	401c      	ands	r4, r3
    16d8:	3401      	adds	r4, #1
    16da:	0312      	lsls	r2, r2, #12
    16dc:	4322      	orrs	r2, r4
    16de:	e7da      	b.n	1696 <__gnu_unwind_execute+0x23a>
    16e0:	0038      	movs	r0, r7
    16e2:	f7ff fe91 	bl	1408 <next_unwind_byte>
    16e6:	4643      	mov	r3, r8
    16e8:	0002      	movs	r2, r0
    16ea:	439a      	bics	r2, r3
    16ec:	b2d2      	uxtb	r2, r2
    16ee:	3210      	adds	r2, #16
    16f0:	4018      	ands	r0, r3
    16f2:	0312      	lsls	r2, r2, #12
    16f4:	3001      	adds	r0, #1
    16f6:	4302      	orrs	r2, r0
    16f8:	e6e6      	b.n	14c8 <__gnu_unwind_execute+0x6c>
    16fa:	ab05      	add	r3, sp, #20
    16fc:	9300      	str	r3, [sp, #0]
    16fe:	469b      	mov	fp, r3
    1700:	220d      	movs	r2, #13
    1702:	2300      	movs	r3, #0
    1704:	2100      	movs	r1, #0
    1706:	0030      	movs	r0, r6
    1708:	f7ff faa8 	bl	c5c <_Unwind_VRS_Get>
    170c:	0038      	movs	r0, r7
    170e:	f7ff fe7b 	bl	1408 <next_unwind_byte>
    1712:	0603      	lsls	r3, r0, #24
    1714:	d518      	bpl.n	1748 <__gnu_unwind_execute+0x2ec>
    1716:	257f      	movs	r5, #127	; 0x7f
    1718:	3cb0      	subs	r4, #176	; 0xb0
    171a:	9b05      	ldr	r3, [sp, #20]
    171c:	4028      	ands	r0, r5
    171e:	40a0      	lsls	r0, r4
    1720:	469c      	mov	ip, r3
    1722:	4460      	add	r0, ip
    1724:	9005      	str	r0, [sp, #20]
    1726:	0038      	movs	r0, r7
    1728:	3407      	adds	r4, #7
    172a:	f7ff fe6d 	bl	1408 <next_unwind_byte>
    172e:	0603      	lsls	r3, r0, #24
    1730:	d4f3      	bmi.n	171a <__gnu_unwind_execute+0x2be>
    1732:	2181      	movs	r1, #129	; 0x81
    1734:	237f      	movs	r3, #127	; 0x7f
    1736:	0089      	lsls	r1, r1, #2
    1738:	4003      	ands	r3, r0
    173a:	468c      	mov	ip, r1
    173c:	40a3      	lsls	r3, r4
    173e:	9a05      	ldr	r2, [sp, #20]
    1740:	4462      	add	r2, ip
    1742:	189b      	adds	r3, r3, r2
    1744:	9305      	str	r3, [sp, #20]
    1746:	e6e2      	b.n	150e <__gnu_unwind_execute+0xb2>
    1748:	2402      	movs	r4, #2
    174a:	e7f2      	b.n	1732 <__gnu_unwind_execute+0x2d6>

0000174c <__gnu_unwind_frame>:
    174c:	0003      	movs	r3, r0
    174e:	b500      	push	{lr}
    1750:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
    1752:	b085      	sub	sp, #20
    1754:	685a      	ldr	r2, [r3, #4]
    1756:	0008      	movs	r0, r1
    1758:	0212      	lsls	r2, r2, #8
    175a:	9201      	str	r2, [sp, #4]
    175c:	001a      	movs	r2, r3
    175e:	a901      	add	r1, sp, #4
    1760:	3208      	adds	r2, #8
    1762:	604a      	str	r2, [r1, #4]
    1764:	2203      	movs	r2, #3
    1766:	720a      	strb	r2, [r1, #8]
    1768:	79db      	ldrb	r3, [r3, #7]
    176a:	724b      	strb	r3, [r1, #9]
    176c:	f7ff fe76 	bl	145c <__gnu_unwind_execute>
    1770:	b005      	add	sp, #20
    1772:	bd00      	pop	{pc}

00001774 <_Unwind_GetRegionStart>:
    1774:	b510      	push	{r4, lr}
    1776:	f7ff fe6d 	bl	1454 <unwind_UCB_from_context>
    177a:	6c80      	ldr	r0, [r0, #72]	; 0x48
    177c:	bd10      	pop	{r4, pc}
    177e:	46c0      	nop			; (mov r8, r8)

00001780 <_Unwind_GetLanguageSpecificData>:
    1780:	b510      	push	{r4, lr}
    1782:	f7ff fe67 	bl	1454 <unwind_UCB_from_context>
    1786:	6cc2      	ldr	r2, [r0, #76]	; 0x4c
    1788:	79d3      	ldrb	r3, [r2, #7]
    178a:	009b      	lsls	r3, r3, #2
    178c:	3308      	adds	r3, #8
    178e:	18d0      	adds	r0, r2, r3
    1790:	bd10      	pop	{r4, pc}
    1792:	46c0      	nop			; (mov r8, r8)

00001794 <_Unwind_GetDataRelBase>:
    1794:	b510      	push	{r4, lr}
    1796:	f020 fd65 	bl	22264 <abort>
    179a:	46c0      	nop			; (mov r8, r8)

0000179c <_Unwind_GetTextRelBase>:
    179c:	b510      	push	{r4, lr}
    179e:	f7ff fff9 	bl	1794 <_Unwind_GetDataRelBase>
    17a2:	46c0      	nop			; (mov r8, r8)

000017a4 <__clzsi2>:
    17a4:	211c      	movs	r1, #28
    17a6:	2301      	movs	r3, #1
    17a8:	041b      	lsls	r3, r3, #16
    17aa:	4298      	cmp	r0, r3
    17ac:	d301      	bcc.n	17b2 <__clzsi2+0xe>
    17ae:	0c00      	lsrs	r0, r0, #16
    17b0:	3910      	subs	r1, #16
    17b2:	0a1b      	lsrs	r3, r3, #8
    17b4:	4298      	cmp	r0, r3
    17b6:	d301      	bcc.n	17bc <__clzsi2+0x18>
    17b8:	0a00      	lsrs	r0, r0, #8
    17ba:	3908      	subs	r1, #8
    17bc:	091b      	lsrs	r3, r3, #4
    17be:	4298      	cmp	r0, r3
    17c0:	d301      	bcc.n	17c6 <__clzsi2+0x22>
    17c2:	0900      	lsrs	r0, r0, #4
    17c4:	3904      	subs	r1, #4
    17c6:	a202      	add	r2, pc, #8	; (adr r2, 17d0 <__clzsi2+0x2c>)
    17c8:	5c10      	ldrb	r0, [r2, r0]
    17ca:	1840      	adds	r0, r0, r1
    17cc:	4770      	bx	lr
    17ce:	46c0      	nop			; (mov r8, r8)
    17d0:	02020304 	.word	0x02020304
    17d4:	01010101 	.word	0x01010101
	...

000017e0 <__clzdi2>:
    17e0:	b510      	push	{r4, lr}
    17e2:	2900      	cmp	r1, #0
    17e4:	d103      	bne.n	17ee <__clzdi2+0xe>
    17e6:	f7ff ffdd 	bl	17a4 <__clzsi2>
    17ea:	3020      	adds	r0, #32
    17ec:	e002      	b.n	17f4 <__clzdi2+0x14>
    17ee:	1c08      	adds	r0, r1, #0
    17f0:	f7ff ffd8 	bl	17a4 <__clzsi2>
    17f4:	bd10      	pop	{r4, pc}
    17f6:	46c0      	nop			; (mov r8, r8)

000017f8 <__gnu_thumb1_case_sqi>:
    17f8:	b402      	push	{r1}
    17fa:	4671      	mov	r1, lr
    17fc:	0849      	lsrs	r1, r1, #1
    17fe:	0049      	lsls	r1, r1, #1
    1800:	5609      	ldrsb	r1, [r1, r0]
    1802:	0049      	lsls	r1, r1, #1
    1804:	448e      	add	lr, r1
    1806:	bc02      	pop	{r1}
    1808:	4770      	bx	lr
    180a:	46c0      	nop			; (mov r8, r8)

0000180c <__gnu_thumb1_case_shi>:
    180c:	b403      	push	{r0, r1}
    180e:	4671      	mov	r1, lr
    1810:	0849      	lsrs	r1, r1, #1
    1812:	0040      	lsls	r0, r0, #1
    1814:	0049      	lsls	r1, r1, #1
    1816:	5e09      	ldrsh	r1, [r1, r0]
    1818:	0049      	lsls	r1, r1, #1
    181a:	448e      	add	lr, r1
    181c:	bc03      	pop	{r0, r1}
    181e:	4770      	bx	lr

00001820 <__gnu_thumb1_case_uhi>:
    1820:	b403      	push	{r0, r1}
    1822:	4671      	mov	r1, lr
    1824:	0849      	lsrs	r1, r1, #1
    1826:	0040      	lsls	r0, r0, #1
    1828:	0049      	lsls	r1, r1, #1
    182a:	5a09      	ldrh	r1, [r1, r0]
    182c:	0049      	lsls	r1, r1, #1
    182e:	448e      	add	lr, r1
    1830:	bc03      	pop	{r0, r1}
    1832:	4770      	bx	lr

00001834 <app_send_to_incoming_queue_from_isr>:
    }
}

static void app_send_to_incoming_queue_from_isr(void)
{
    (void)osMessageQueuePut(app_incoming_queue, (void*)&APP_MAIN_QUEUE_TEMP, 0, osNoWait);
    1834:	2300      	movs	r3, #0
{
    1836:	b510      	push	{r4, lr}
    (void)osMessageQueuePut(app_incoming_queue, (void*)&APP_MAIN_QUEUE_TEMP, 0, osNoWait);
    1838:	4803      	ldr	r0, [pc, #12]	; (1848 <app_send_to_incoming_queue_from_isr+0x14>)
    183a:	001a      	movs	r2, r3
    183c:	4903      	ldr	r1, [pc, #12]	; (184c <app_send_to_incoming_queue_from_isr+0x18>)
    183e:	6800      	ldr	r0, [r0, #0]
    1840:	f013 f97e 	bl	14b40 <osMessageQueuePut>
}
    1844:	bd10      	pop	{r4, pc}
    1846:	46c0      	nop			; (mov r8, r8)
    1848:	01000680 	.word	0x01000680
    184c:	00022aa0 	.word	0x00022aa0

00001850 <app_main>:
    }
}

//lint -sem( app_main, thread_mono )
static void app_main( void *unused )
{
    1850:	b5f0      	push	{r4, r5, r6, r7, lr}
    1852:	b08f      	sub	sp, #60	; 0x3c
    1854:	4674      	mov	r4, lr
    UNUSED(unused);
    io_bank_init();
    1856:	f005 ff81 	bl	775c <io_bank_init>
    // Ensure eFlash is in deep sleep before doing anything else
    (void)eflash_init();
    185a:	f018 fe17 	bl	1a48c <eflash_init>
    (void)flog_init();
    185e:	f005 f81d 	bl	689c <flog_init>
    /* SHOULD enable the log thread after flog initialising OK, or the
     * calling of flog_write() in the log thread may cause trouble
     */
    log_uart_enable();
    1862:	f005 fb6b 	bl	6f3c <log_uart_enable>
    app_incoming_queue = osMessageQueueNew(APP_MAIN_QUEUE_LEN, APP_MAIN_QUEUE_ITEM_SIZE, NULL);
    1866:	2200      	movs	r2, #0
    1868:	2104      	movs	r1, #4
    186a:	2002      	movs	r0, #2
    186c:	f013 f946 	bl	14afc <osMessageQueueNew>
    1870:	4f3c      	ldr	r7, [pc, #240]	; (1964 <app_main+0x114>)
    1872:	6038      	str	r0, [r7, #0]
    if(NULL == app_incoming_queue)
    1874:	2800      	cmp	r0, #0
    1876:	d103      	bne.n	1880 <app_main+0x30>
        assert(false);
    1878:	0021      	movs	r1, r4
    187a:	3016      	adds	r0, #22
    187c:	f000 f948 	bl	1b10 <panic>
    uint64 pin_map = 0;
    1880:	2200      	movs	r2, #0
    1882:	2300      	movs	r3, #0
    1884:	9206      	str	r2, [sp, #24]
    1886:	9307      	str	r3, [sp, #28]
    uint64 pin_state = 0;
    1888:	9208      	str	r2, [sp, #32]
    188a:	9309      	str	r3, [sp, #36]	; 0x24
    if (neul_kv_get( BASE_KEYID_FIXED_PINS, sizeof(pin_map_buf), &pin_map_length, (uint8 *) pin_map_buf ) == NEUL_RET_OK)
    188c:	ab04      	add	r3, sp, #16
    188e:	1d9e      	adds	r6, r3, #6
    1890:	ad0b      	add	r5, sp, #44	; 0x2c
    1892:	002b      	movs	r3, r5
    1894:	0032      	movs	r2, r6
    1896:	210a      	movs	r1, #10
    1898:	2005      	movs	r0, #5
    189a:	f005 fe8a 	bl	75b2 <neul_kv_get>
    189e:	1e04      	subs	r4, r0, #0
    18a0:	d13c      	bne.n	191c <app_main+0xcc>
        memcpy(&pin_state, pin_map_buf + PIN_MAP_BYTES, PIN_STATE_BYTES);
    18a2:	2121      	movs	r1, #33	; 0x21
        memcpy(&pin_map, pin_map_buf, PIN_MAP_BYTES);
    18a4:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
        memcpy(&pin_state, pin_map_buf + PIN_MAP_BYTES, PIN_STATE_BYTES);
    18a6:	a808      	add	r0, sp, #32
        memcpy(&pin_map, pin_map_buf, PIN_MAP_BYTES);
    18a8:	9306      	str	r3, [sp, #24]
    18aa:	792a      	ldrb	r2, [r5, #4]
    18ac:	ab06      	add	r3, sp, #24
    18ae:	711a      	strb	r2, [r3, #4]
        memcpy(&pin_state, pin_map_buf + PIN_MAP_BYTES, PIN_STATE_BYTES);
    18b0:	ab04      	add	r3, sp, #16
    18b2:	18c9      	adds	r1, r1, r3
    18b4:	2205      	movs	r2, #5
    18b6:	f7fe fc9b 	bl	1f0 <memcpy>
        if (pin_map_length == sizeof(pin_map_buf))
    18ba:	8833      	ldrh	r3, [r6, #0]
    18bc:	2b0a      	cmp	r3, #10
    18be:	d12d      	bne.n	191c <app_main+0xcc>
                if ((pin_map & 0x1) == 1 )
    18c0:	2601      	movs	r6, #1
    18c2:	9b06      	ldr	r3, [sp, #24]
    18c4:	9300      	str	r3, [sp, #0]
    18c6:	9b07      	ldr	r3, [sp, #28]
    18c8:	9301      	str	r3, [sp, #4]
    18ca:	9b08      	ldr	r3, [sp, #32]
    18cc:	9302      	str	r3, [sp, #8]
    18ce:	9b09      	ldr	r3, [sp, #36]	; 0x24
    18d0:	9303      	str	r3, [sp, #12]
    18d2:	9b00      	ldr	r3, [sp, #0]
    18d4:	4233      	tst	r3, r6
    18d6:	d00b      	beq.n	18f0 <app_main+0xa0>
                    if (gpio_claim(pin, GPIO_DIRECTION_OUTPUT))
    18d8:	0031      	movs	r1, r6
    18da:	0020      	movs	r0, r4
    18dc:	f015 fc3e 	bl	1715c <gpio_claim>
    18e0:	2800      	cmp	r0, #0
    18e2:	d005      	beq.n	18f0 <app_main+0xa0>
                        if ((pin_state & 0x1) == 1)
    18e4:	9b02      	ldr	r3, [sp, #8]
                            gpio_clear(pin);
    18e6:	0020      	movs	r0, r4
                        if ((pin_state & 0x1) == 1)
    18e8:	4233      	tst	r3, r6
    18ea:	d037      	beq.n	195c <app_main+0x10c>
                            gpio_set(pin);
    18ec:	f015 fcb2 	bl	17254 <gpio_set>
                pin_map >>= 1;
    18f0:	9b01      	ldr	r3, [sp, #4]
            for (PIN pin = PIN_0; pin < PIN_MAX_NUMBER; pin ++)
    18f2:	3401      	adds	r4, #1
                pin_map >>= 1;
    18f4:	07da      	lsls	r2, r3, #31
    18f6:	9b00      	ldr	r3, [sp, #0]
            for (PIN pin = PIN_0; pin < PIN_MAX_NUMBER; pin ++)
    18f8:	b2e4      	uxtb	r4, r4
                pin_map >>= 1;
    18fa:	085b      	lsrs	r3, r3, #1
    18fc:	4313      	orrs	r3, r2
    18fe:	9306      	str	r3, [sp, #24]
    1900:	9b01      	ldr	r3, [sp, #4]
    1902:	085b      	lsrs	r3, r3, #1
    1904:	9307      	str	r3, [sp, #28]
                pin_state >>= 1;
    1906:	9b03      	ldr	r3, [sp, #12]
    1908:	07da      	lsls	r2, r3, #31
    190a:	9b02      	ldr	r3, [sp, #8]
    190c:	085b      	lsrs	r3, r3, #1
    190e:	4313      	orrs	r3, r2
    1910:	9308      	str	r3, [sp, #32]
    1912:	9b03      	ldr	r3, [sp, #12]
    1914:	085b      	lsrs	r3, r3, #1
    1916:	9309      	str	r3, [sp, #36]	; 0x24
            for (PIN pin = PIN_0; pin < PIN_MAX_NUMBER; pin ++)
    1918:	2c28      	cmp	r4, #40	; 0x28
    191a:	d1d2      	bne.n	18c2 <app_main+0x72>
    app_create_queue();
    // set pins that need to be set to a permanent state
    app_set_fixed_pins();
    neul_kv_cache_register();
    191c:	f005 fec2 	bl	76a4 <neul_kv_cache_register>
    network_config_init();
    //This must not return
    for (;;)
    {
        uint32_t temp;
        if(osMessageQueueGet(app_incoming_queue, (void*)&temp, NULL, osWaitForever) == osOK)
    1920:	2401      	movs	r4, #1
    (void) aio_func_set_default_temperature_coefficient();
    1922:	f006 fcb5 	bl	8290 <aio_func_set_default_temperature_coefficient>
    at_init(app_send_to_incoming_queue_from_isr);
    1926:	4810      	ldr	r0, [pc, #64]	; (1968 <app_main+0x118>)
    1928:	f007 f818 	bl	895c <at_init>
    ota_init();
    192c:	f005 fb8c 	bl	7048 <ota_init>
    log_level_init();
    1930:	f004 ff92 	bl	6858 <log_level_init>
    production_at_cmd_init();
    1934:	f010 ff72 	bl	1281c <production_at_cmd_init>
    network_config_init();
    1938:	f006 f800 	bl	793c <network_config_init>
        if(osMessageQueueGet(app_incoming_queue, (void*)&temp, NULL, osWaitForever) == osOK)
    193c:	4264      	negs	r4, r4
    193e:	0023      	movs	r3, r4
    1940:	2200      	movs	r2, #0
    1942:	0029      	movs	r1, r5
    1944:	6838      	ldr	r0, [r7, #0]
    1946:	f013 f927 	bl	14b98 <osMessageQueueGet>
    194a:	2800      	cmp	r0, #0
    194c:	d103      	bne.n	1956 <app_main+0x106>
        {
            at_main();
    194e:	f006 fdd9 	bl	8504 <at_main>
#ifdef LIBOTA
            ota_poll();     //lint !e522
    1952:	f005 fc3d 	bl	71d0 <ota_poll>
#endif
        }
        (void)osThreadYield();
    1956:	f012 ff7b 	bl	14850 <osThreadYield>
    {
    195a:	e7f0      	b.n	193e <app_main+0xee>
                            gpio_clear(pin);
    195c:	f015 fca2 	bl	172a4 <gpio_clear>
    1960:	e7c6      	b.n	18f0 <app_main+0xa0>
    1962:	46c0      	nop			; (mov r8, r8)
    1964:	01000680 	.word	0x01000680
    1968:	00001835 	.word	0x00001835

0000196c <app_os_init>:
{
    196c:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    196e:	2400      	movs	r4, #0
        if (app_tasks[i].create_queue_fn_p)
    1970:	4e11      	ldr	r6, [pc, #68]	; (19b8 <app_os_init+0x4c>)
    1972:	19a3      	adds	r3, r4, r6
    1974:	6adb      	ldr	r3, [r3, #44]	; 0x2c
    1976:	2b00      	cmp	r3, #0
    1978:	d000      	beq.n	197c <app_os_init+0x10>
            app_tasks[i].create_queue_fn_p();
    197a:	4798      	blx	r3
    197c:	3430      	adds	r4, #48	; 0x30
    for (uint8 i = 0; i < M_NUM_TASKS; i++)
    197e:	2cc0      	cmp	r4, #192	; 0xc0
    1980:	d1f6      	bne.n	1970 <app_os_init+0x4>
    1982:	2730      	movs	r7, #48	; 0x30
    1984:	3cbf      	subs	r4, #191	; 0xbf
    1986:	003b      	movs	r3, r7
        app_tasks[i].task_handle = osThreadNew(app_tasks[i].func, NULL, &(app_tasks[i].attr));
    1988:	0032      	movs	r2, r6
    198a:	4363      	muls	r3, r4
    198c:	3a30      	subs	r2, #48	; 0x30
    198e:	18f5      	adds	r5, r6, r3
    1990:	18d2      	adds	r2, r2, r3
    1992:	002b      	movs	r3, r5
    1994:	3b0c      	subs	r3, #12
    1996:	2100      	movs	r1, #0
    1998:	6818      	ldr	r0, [r3, #0]
    199a:	f012 ff25 	bl	147e8 <osThreadNew>
    199e:	3d08      	subs	r5, #8
    19a0:	6028      	str	r0, [r5, #0]
        if(app_tasks[i].task_handle == NULL)
    19a2:	2800      	cmp	r0, #0
    19a4:	d103      	bne.n	19ae <app_os_init+0x42>
            panic(PANIC_TASK_CREATE_FAILED, i);
    19a6:	1e61      	subs	r1, r4, #1
    19a8:	3026      	adds	r0, #38	; 0x26
    19aa:	f000 f8b1 	bl	1b10 <panic>
    19ae:	3401      	adds	r4, #1
    for (uint8 i = 0; i < M_NUM_TASKS; i++)
    19b0:	2c05      	cmp	r4, #5
    19b2:	d1e8      	bne.n	1986 <app_os_init+0x1a>
}
    19b4:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    19b6:	46c0      	nop			; (mov r8, r8)
    19b8:	010004d0 	.word	0x010004d0

000019bc <hw_init>:
 */
#define  WDT_TIMEOUT_S     (30)

void hw_init(void);
void hw_init(void)
{
    19bc:	b510      	push	{r4, lr}
    hal_cpu_init();
    19be:	f017 f9f5 	bl	18dac <hal_cpu_init>
    hal_reboot_init();
    19c2:	f017 fe7b 	bl	196bc <hal_reboot_init>

    // Initialise malloc
    irmalloc_init_default();
    19c6:	f011 f819 	bl	129fc <irmalloc_init_default>

    // Initialise the drivers used.
    gpio_init();
    19ca:	f015 fb9b 	bl	17104 <gpio_init>
    rtc_init();
    19ce:	f016 fd8d 	bl	184ec <rtc_init>
    system_status_init();
    19d2:	f016 fed3 	bl	1877c <system_status_init>
    ipc_init();
    19d6:	f015 fcf7 	bl	173c8 <ipc_init>

#ifndef DISABLE_WDT
    watchdog_init(clocks_get_core_clock()*WDT_TIMEOUT_S, true, true);
    19da:	f015 fb34 	bl	17046 <clocks_get_core_clock>
    19de:	231e      	movs	r3, #30
    19e0:	2201      	movs	r2, #1
    19e2:	4358      	muls	r0, r3
    19e4:	0011      	movs	r1, r2
    19e6:	f016 ff17 	bl	18818 <watchdog_init>
    watchdog_enable();
    19ea:	f016 ff2d 	bl	18848 <watchdog_enable>
#endif
}
    19ee:	bd10      	pop	{r4, pc}

000019f0 <main>:

void main( int argc, int argv[] )
{
    19f0:	b510      	push	{r4, lr}
    UNUSED( argc );
    UNUSED( argv );

    preserve_init();
    19f2:	f019 fec3 	bl	1b77c <preserve_init>
    hw_init();
    19f6:	f7ff ffe1 	bl	19bc <hw_init>
    log_init();
    19fa:	f004 fde9 	bl	65d0 <log_init>

    (void)osKernelInitialize();
    19fe:	f012 fe51 	bl	146a4 <osKernelInitialize>


    dma_init();
    1a02:	f015 f87b 	bl	16afc <dma_init>
    uart_init();
    1a06:	f013 fe65 	bl	156d4 <uart_init>

    // Tell the logging logging consumer/writer to switch to using a mutex (requires RTOS init).
    log_init_after_rtos();
    1a0a:	f004 fe03 	bl	6614 <log_init_after_rtos>
    log_uart_init_after_rtos(false);
    1a0e:	2000      	movs	r0, #0
    1a10:	f005 f81c 	bl	6a4c <log_uart_init_after_rtos>

    socket_init();
    1a14:	f006 f82a 	bl	7a6c <socket_init>

    // Set RPC Mailboxes up
    rpc_init();
    1a18:	f000 f954 	bl	1cc4 <rpc_init>
    
    // Set the KV storage up
    neul_kv_init();
    1a1c:	f005 fe08 	bl	7630 <neul_kv_init>

    (void) aio_manager_init();
    1a20:	f005 fe4a 	bl	76b8 <aio_manager_init>

    // Set the initialisation routine to run immediately as soon as RTOS starts
    // Note the cast, as uint32 and uint32_t are treated as different on some compilers.

    app_os_init(NULL, 0);
    1a24:	2100      	movs	r1, #0
    1a26:	0008      	movs	r0, r1
    1a28:	f7ff ffa0 	bl	196c <app_os_init>

    (void)osKernelStart();
    1a2c:	f012 fe70 	bl	14710 <osKernelStart>
    return;
}
    1a30:	bd10      	pop	{r4, pc}
	...

00001a34 <Reset_Handler>:
        .func           Reset_Handler
Reset_Handler:


        /* Make sure SP is really at the start of the stack */
        ldr     r0, =stack_system
    1a34:	4826      	ldr	r0, [pc, #152]	; (1ad0 <.enter_main+0x8>)
        msr     msp, r0
    1a36:	f380 8808 	msr	MSP, r0

        /* Check Security core version number table for validity */
        /* The table is copied by the Security core to the beginning of SRAM for this core */
        ldr     r1, =__SYSTEM_STACK_BEGIN__
    1a3a:	4926      	ldr	r1, [pc, #152]	; (1ad4 <.enter_main+0xc>)
        ldr     r3, =__SYSTEM_STACK_END__
    1a3c:	4b26      	ldr	r3, [pc, #152]	; (1ad8 <.enter_main+0x10>)
        ldr     r5, [r1, #0]          /* Security core version table content length.  r5 needs preserving for entirety of this routine */
    1a3e:	680d      	ldr	r5, [r1, #0]
        cmp     r5, #16               /* Assume anything over 16 words is invalid */
    1a40:	2d10      	cmp	r5, #16
        bhi     .version_table_invalid
    1a42:	d803      	bhi.n	1a4c <.version_table_invalid>

        ldr     r0, [r1, #4]          /* ~length */
    1a44:	6848      	ldr	r0, [r1, #4]
        mvns    r0, r0
    1a46:	43c0      	mvns	r0, r0
        cmp     r5, r0                /* Simple validation check to ensure we have a proper table and not just random numbers */
    1a48:	4285      	cmp	r5, r0
        beq     .version_table_valid
    1a4a:	d000      	beq.n	1a4e <.version_table_valid>

00001a4c <.version_table_invalid>:

.version_table_invalid:
        ldr     r5, =#0               /* An invalid table, so set the length to zero */
    1a4c:	4d23      	ldr	r5, [pc, #140]	; (1adc <.enter_main+0x14>)

00001a4e <.version_table_valid>:

.version_table_valid:
        cmp     r5, #0                /* Zero length Security core version table? */
    1a4e:	2d00      	cmp	r5, #0
        beq     .stack_fill
    1a50:	d003      	beq.n	1a5a <.stack_fill>

        /* Adjust start of prefill position so as not to overwrite Security core version table */
        mov     r0, r5
    1a52:	4628      	mov	r0, r5
        adds    r0, #2                /* Add table header size to table content length */
    1a54:	3002      	adds	r0, #2
        lsls    r0, r0, #2            /* Convert size in words to bytes */
    1a56:	0080      	lsls	r0, r0, #2
        adds    r1, r0                /* Update prefill start position */
    1a58:	1809      	adds	r1, r1, r0

00001a5a <.stack_fill>:

        /* Prefill the system stack with 0xefbeadde (or deafbeef in little endian) */
.stack_fill:
        subs    r3, r3, r1
    1a5a:	1a5b      	subs	r3, r3, r1
        beq     .stack_fill_loop_end
    1a5c:	d004      	beq.n	1a68 <.stack_fill_loop_end>
        ldr     r2, =0xefbeadde
    1a5e:	4a20      	ldr	r2, [pc, #128]	; (1ae0 <.enter_main+0x18>)

00001a60 <.stack_fill_loop>:
.stack_fill_loop:
        str     r2, [r1, #0]           /* Store the quad octet initialisation value in r2 into address in r1 */
    1a60:	600a      	str	r2, [r1, #0]
        adds    r1, r1, #4             /* Increased address in r1 by a quad octet */
    1a62:	3104      	adds	r1, #4
         subs    r3, r3, #4             /* Decrease the number of bytes to do by a quad octet */
    1a64:	3b04      	subs	r3, #4
        bgt     .stack_fill_loop       /* Keep going until it is all done */
    1a66:	dcfb      	bgt.n	1a60 <.stack_fill_loop>

00001a68 <.stack_fill_loop_end>:
.stack_fill_loop_end:

        /* Clear bss section */
        ldr     r1, =__bss_begin__
    1a68:	491e      	ldr	r1, [pc, #120]	; (1ae4 <.enter_main+0x1c>)
        ldr     r3, =__bss_end__
    1a6a:	4b1f      	ldr	r3, [pc, #124]	; (1ae8 <.enter_main+0x20>)
        subs    r3, r3, r1
    1a6c:	1a5b      	subs	r3, r3, r1

        beq     .end_clear_bss_loop
    1a6e:	d004      	beq.n	1a7a <.end_clear_bss_loop>
        ldr     r2, =#00000000
    1a70:	4a1a      	ldr	r2, [pc, #104]	; (1adc <.enter_main+0x14>)

00001a72 <.clear_bss_loop>:

.clear_bss_loop:
        strb    r2, [r1, #0]           /* Store the octet initialisation value in r2 into address in r1 */
    1a72:	700a      	strb	r2, [r1, #0]
        adds    r1, r1, #1             /* Increased address in r1 by an octet */
    1a74:	3101      	adds	r1, #1
        subs    r3, r3, #1             /* Decrease the number of bytes to do by an octet */
    1a76:	3b01      	subs	r3, #1
        bgt     .clear_bss_loop        /* Keep going until it is all done */
    1a78:	dcfb      	bgt.n	1a72 <.clear_bss_loop>

00001a7a <.end_clear_bss_loop>:
.end_clear_bss_loop:

        /* setup .ramtext section */
        ldr     r1, =__ramtext_begin__
    1a7a:	491c      	ldr	r1, [pc, #112]	; (1aec <.enter_main+0x24>)
        ldr     r2, =__ramtext_load__
    1a7c:	4a1c      	ldr	r2, [pc, #112]	; (1af0 <.enter_main+0x28>)
        ldr     r3, =__ramtext_size__
    1a7e:	4b1d      	ldr	r3, [pc, #116]	; (1af4 <.enter_main+0x2c>)
        cmp     r3, #0
    1a80:	2b00      	cmp	r3, #0
        beq     .end_set_ramtext_loop
    1a82:	d005      	beq.n	1a90 <.end_set_ramtext_loop>

00001a84 <.set_ramtext_loop>:

.set_ramtext_loop:
        ldrb    r4, [r2, #0]           /* Load the octet value into r4 from address in r2 */
    1a84:	7814      	ldrb	r4, [r2, #0]
        strb    r4, [r1, #0]           /* Store the octet value in r4 to address in r1 */
    1a86:	700c      	strb	r4, [r1, #0]
        adds    r2, r2, #1             /* Move onto next octet */
    1a88:	3201      	adds	r2, #1
        adds    r1, r1, #1
    1a8a:	3101      	adds	r1, #1
        subs    r3, r3, #1             /* Decrease the number of bytes to do by an octet */
    1a8c:	3b01      	subs	r3, #1
        bgt     .set_ramtext_loop      /* Keep going until it is all done */
    1a8e:	dcf9      	bgt.n	1a84 <.set_ramtext_loop>

00001a90 <.end_set_ramtext_loop>:
.end_set_ramtext_loop:

        /* setup .data section */
        ldr     r1, =__data_begin__
    1a90:	4919      	ldr	r1, [pc, #100]	; (1af8 <.enter_main+0x30>)
        ldr     r2, =__data_load__
    1a92:	4a1a      	ldr	r2, [pc, #104]	; (1afc <.enter_main+0x34>)
        ldr     r3, =__data_size__
    1a94:	4b1a      	ldr	r3, [pc, #104]	; (1b00 <.enter_main+0x38>)
        cmp     r3, #0
    1a96:	2b00      	cmp	r3, #0
        beq     .end_set_data_loop
    1a98:	d005      	beq.n	1aa6 <.end_set_data_loop>

00001a9a <.set_data_loop>:

.set_data_loop:
        ldrb    r4, [r2, #0]           /* Load the octet value into r4 from address in r2 */
    1a9a:	7814      	ldrb	r4, [r2, #0]
        strb    r4, [r1, #0]           /* Store the octet value in r4 to address in r1 */
    1a9c:	700c      	strb	r4, [r1, #0]
        adds    r2, r2, #1             /* Move onto next octet */
    1a9e:	3201      	adds	r2, #1
        adds    r1, r1, #1
    1aa0:	3101      	adds	r1, #1
        subs    r3, r3, #1             /* Decrease the number of bytes to do by an octet */
    1aa2:	3b01      	subs	r3, #1
        bgt     .set_data_loop              /* Keep going until it is all done */
    1aa4:	dcf9      	bgt.n	1a9a <.set_data_loop>

00001aa6 <.end_set_data_loop>:
.end_set_data_loop:

        /* Call init functions, if they exist */
        ldr     r3, =hardware_init_hook
    1aa6:	4b17      	ldr	r3, [pc, #92]	; (1b04 <.enter_main+0x3c>)
        cmp     r3, #0
    1aa8:	2b00      	cmp	r3, #0
        beq     .hwinitdone
    1aaa:	d001      	beq.n	1ab0 <.hwinitdone>
        mov     lr, pc
    1aac:	46fe      	mov	lr, pc
        mov     pc, r3
    1aae:	469f      	mov	pc, r3

00001ab0 <.hwinitdone>:
.hwinitdone:

        ldr     r3, =software_init_hook
    1ab0:	4b15      	ldr	r3, [pc, #84]	; (1b08 <.enter_main+0x40>)
        cmp     r3, #0
    1ab2:	2b00      	cmp	r3, #0
        beq     .swinitdone
    1ab4:	d001      	beq.n	1aba <.swinitdone>
        mov     lr, pc
    1ab6:	46fe      	mov	lr, pc
        mov     pc, r3
    1ab8:	469f      	mov	pc, r3

00001aba <.swinitdone>:
.swinitdone:

        bl        reboot_notify_security_of_reboot    /* This function notifies the securty core we have rebooted */
    1aba:	f016 fc11 	bl	182e0 <reboot_notify_security_of_reboot>
                                                    /* Then blocks until it is safe for us to continue */
                                                
        /* Call the application's entry point.*/
        ldr     r1, =#0
    1abe:	4907      	ldr	r1, [pc, #28]	; (1adc <.enter_main+0x14>)
        movs    r0, r5           /* argc = length, which will be zero for an invalid table */
    1ac0:	0028      	movs	r0, r5
        beq     .enter_main
    1ac2:	d001      	beq.n	1ac8 <.enter_main>

        ldr     r1, =__SYSTEM_STACK_BEGIN__
    1ac4:	4903      	ldr	r1, [pc, #12]	; (1ad4 <.enter_main+0xc>)
        adds    r1, #8           /* argv[] at beginning of stack + 8, to skip over version table header */
    1ac6:	3108      	adds	r1, #8

00001ac8 <.enter_main>:

.enter_main:
        bl      main
    1ac8:	f7ff ff92 	bl	19f0 <main>
        bl      .
    1acc:	f7ff fffe 	bl	1acc <.enter_main+0x4>
        ldr     r0, =stack_system
    1ad0:	010003fc 	.word	0x010003fc
        ldr     r1, =__SYSTEM_STACK_BEGIN__
    1ad4:	01000000 	.word	0x01000000
        ldr     r3, =__SYSTEM_STACK_END__
    1ad8:	01000400 	.word	0x01000400
        ldr     r5, =#0               /* An invalid table, so set the length to zero */
    1adc:	00000000 	.word	0x00000000
        ldr     r2, =0xefbeadde
    1ae0:	efbeadde 	.word	0xefbeadde
        ldr     r1, =__bss_begin__
    1ae4:	01000680 	.word	0x01000680
        ldr     r3, =__bss_end__
    1ae8:	01002f2c 	.word	0x01002f2c
        ldr     r1, =__ramtext_begin__
    1aec:	01000400 	.word	0x01000400
        ldr     r2, =__ramtext_load__
    1af0:	00026260 	.word	0x00026260
        ldr     r3, =__ramtext_size__
    1af4:	000000d0 	.word	0x000000d0
        ldr     r1, =__data_begin__
    1af8:	010004d0 	.word	0x010004d0
        ldr     r2, =__data_load__
    1afc:	00026330 	.word	0x00026330
        ldr     r3, =__data_size__
    1b00:	00000148 	.word	0x00000148
	...

00001b0c <IRQ_CAP_Handler>:
/**
 * Default interrupt handler, used for when no specific handler has been implemented.
 * Needed for weak aliasing (an aliased function must have static linkage).
 */
static void isr_not_implemented( void )
{
    1b0c:	e7fe      	b.n	1b0c <IRQ_CAP_Handler>
	...

00001b10 <panic>:
}

//lint -function( exit, panic )             Panic doesn't return
//lint -sem( panic, thread_protected )      Panic disables interrupts, so is thread safe
void panic(PANIC_ID origin, uint32 code)
{
    1b10:	b5f0      	push	{r4, r5, r6, r7, lr}
    1b12:	b085      	sub	sp, #20
    //unlike the hardfault handler 'i' does not need to be static, since we trust our stack
    volatile uint8 i = 1;
    1b14:	466b      	mov	r3, sp
    1b16:	2401      	movs	r4, #1
    1b18:	1cdd      	adds	r5, r3, #3
{
    1b1a:	0007      	movs	r7, r0
    1b1c:	000e      	movs	r6, r1
    volatile uint8 i = 1;
    1b1e:	702c      	strb	r4, [r5, #0]
    hal_reboot_sys_reset();
#endif

#if !defined(ROBOT_TEST) && !defined(CXXTEST)
    // Disable interrupts and set barriers - ie RTOS disabled
    non_os_enter_critical();
    1b20:	f016 fb48 	bl	181b4 <non_os_enter_critical>
#endif

    create_error_message = !already_panicking;
    1b24:	4b0e      	ldr	r3, [pc, #56]	; (1b60 <panic+0x50>)
    1b26:	781a      	ldrb	r2, [r3, #0]
    already_panicking = true;
    1b28:	701c      	strb	r4, [r3, #0]

    if (create_error_message)
    1b2a:	2a00      	cmp	r2, #0
    1b2c:	d10c      	bne.n	1b48 <panic+0x38>
    {
        PANIC_DESC panic_desc;
        panic_desc.origin = origin;
    1b2e:	ac01      	add	r4, sp, #4
    1b30:	7027      	strb	r7, [r4, #0]
        panic_desc.code = code;
    1b32:	9602      	str	r6, [sp, #8]
        panic_desc.timestamp_ms = (uint32) rtc_get_time_us(); // Same format as used in logs.
    1b34:	f016 fd62 	bl	185fc <rtc_get_time_us>
        // Preseve the last panic details in case log_object fails.
        set_last_panic(panic_desc);
    1b38:	6861      	ldr	r1, [r4, #4]
        panic_desc.timestamp_ms = (uint32) rtc_get_time_us(); // Same format as used in logs.
    1b3a:	0002      	movs	r2, r0
    1b3c:	60a0      	str	r0, [r4, #8]
        set_last_panic(panic_desc);
    1b3e:	9801      	ldr	r0, [sp, #4]
    1b40:	f019 fdf4 	bl	1b72c <set_last_panic>
#if defined(LIBBACKTRACE) && !defined(ROBOT_TEST) && !defined(CXXTEST)
#if defined (STACKDUMP)
        record_call_stack(trace_get_sp());
#endif

        record_backtrace();
    1b44:	f010 ff26 	bl	12994 <record_backtrace>
#endif
    }

    // Call the registered callback, if it has been registered
    if (panic_registered_callback)
    1b48:	4b06      	ldr	r3, [pc, #24]	; (1b64 <panic+0x54>)
    1b4a:	681b      	ldr	r3, [r3, #0]
    1b4c:	2b00      	cmp	r3, #0
    1b4e:	d000      	beq.n	1b52 <panic+0x42>
    {
        panic_registered_callback();
    1b50:	4798      	blx	r3
    }

    // Loop forever - or until jlink changes i
    while(i)    //lint !e716
    1b52:	782b      	ldrb	r3, [r5, #0]
    1b54:	2b00      	cmp	r3, #0
    1b56:	d1fc      	bne.n	1b52 <panic+0x42>
    {
        // Spin
    }
#if !defined(ROBOT_TEST) && !defined(CXXTEST)
    // Re-enable interrupts
    non_os_exit_critical();
    1b58:	f016 fb40 	bl	181dc <non_os_exit_critical>
#endif
}
    1b5c:	b005      	add	sp, #20
    1b5e:	bdf0      	pop	{r4, r5, r6, r7, pc}
    1b60:	01000684 	.word	0x01000684
    1b64:	01000688 	.word	0x01000688

00001b68 <cmsis_rpc_task_yield>:

/**
 * yield task if sending incompleted.
 */
static void cmsis_rpc_task_yield(void)
{
    1b68:	b510      	push	{r4, lr}
    (void)osDelay(1);
    1b6a:	2001      	movs	r0, #1
    1b6c:	f012 fe7d 	bl	1486a <osDelay>
}
    1b70:	bd10      	pop	{r4, pc}
	...

00001b74 <cmsis_rpc_sent_take_semaphore>:
 * Takes the semaphore
 * @return True if taken, false otherwise
 */
static bool cmsis_rpc_sent_take_semaphore(void)
{
    return (osSemaphoreAcquire(rpc_sent_semaphore, osWaitForever) == osOK);
    1b74:	2101      	movs	r1, #1
{
    1b76:	b510      	push	{r4, lr}
    return (osSemaphoreAcquire(rpc_sent_semaphore, osWaitForever) == osOK);
    1b78:	4b04      	ldr	r3, [pc, #16]	; (1b8c <cmsis_rpc_sent_take_semaphore+0x18>)
    1b7a:	4249      	negs	r1, r1
    1b7c:	6818      	ldr	r0, [r3, #0]
    1b7e:	f012 ff7d 	bl	14a7c <osSemaphoreAcquire>
    1b82:	4243      	negs	r3, r0
    1b84:	4158      	adcs	r0, r3
    1b86:	b2c0      	uxtb	r0, r0
}
    1b88:	bd10      	pop	{r4, pc}
    1b8a:	46c0      	nop			; (mov r8, r8)
    1b8c:	010006a8 	.word	0x010006a8

00001b90 <cmsis_rpc_take_semaphore>:
    return (osSemaphoreAcquire(rpc_semaphores[(int)core], osWaitForever) == osOK);
    1b90:	2101      	movs	r1, #1
{
    1b92:	b510      	push	{r4, lr}
    return (osSemaphoreAcquire(rpc_semaphores[(int)core], osWaitForever) == osOK);
    1b94:	4b04      	ldr	r3, [pc, #16]	; (1ba8 <cmsis_rpc_take_semaphore+0x18>)
    1b96:	0080      	lsls	r0, r0, #2
    1b98:	58c0      	ldr	r0, [r0, r3]
    1b9a:	4249      	negs	r1, r1
    1b9c:	f012 ff6e 	bl	14a7c <osSemaphoreAcquire>
    1ba0:	4243      	negs	r3, r0
    1ba2:	4158      	adcs	r0, r3
    1ba4:	b2c0      	uxtb	r0, r0
}
    1ba6:	bd10      	pop	{r4, pc}
    1ba8:	0100069c 	.word	0x0100069c

00001bac <cmsis_rpc_sent_give_semaphore>:
/**
 * Gives the semaphore
 * @return True if given, false otherwise
 */
static bool cmsis_rpc_sent_give_semaphore(void)
{
    1bac:	b510      	push	{r4, lr}
    return (osSemaphoreRelease(rpc_sent_semaphore) == osOK);
    1bae:	4b04      	ldr	r3, [pc, #16]	; (1bc0 <cmsis_rpc_sent_give_semaphore+0x14>)
    1bb0:	6818      	ldr	r0, [r3, #0]
    1bb2:	f012 ff8f 	bl	14ad4 <osSemaphoreRelease>
    1bb6:	4243      	negs	r3, r0
    1bb8:	4158      	adcs	r0, r3
    1bba:	b2c0      	uxtb	r0, r0
}
    1bbc:	bd10      	pop	{r4, pc}
    1bbe:	46c0      	nop			; (mov r8, r8)
    1bc0:	010006a8 	.word	0x010006a8

00001bc4 <cmsis_rpc_give_semaphore>:
{
    1bc4:	b510      	push	{r4, lr}
    return (osSemaphoreRelease(rpc_semaphores[(int)core]) == osOK);
    1bc6:	4b04      	ldr	r3, [pc, #16]	; (1bd8 <cmsis_rpc_give_semaphore+0x14>)
    1bc8:	0080      	lsls	r0, r0, #2
    1bca:	58c0      	ldr	r0, [r0, r3]
    1bcc:	f012 ff82 	bl	14ad4 <osSemaphoreRelease>
    1bd0:	4243      	negs	r3, r0
    1bd2:	4158      	adcs	r0, r3
    1bd4:	b2c0      	uxtb	r0, r0
}
    1bd6:	bd10      	pop	{r4, pc}
    1bd8:	0100069c 	.word	0x0100069c

00001bdc <send_to_incoming_queue_from_isr>:
{
    1bdc:	b507      	push	{r0, r1, r2, lr}
    uint32 unused = 0;
    1bde:	2200      	movs	r2, #0
    (void)osMessageQueuePut(rpc_incoming_queue, (void*)&unused, 0, osNoWait);
    1be0:	4803      	ldr	r0, [pc, #12]	; (1bf0 <send_to_incoming_queue_from_isr+0x14>)
    1be2:	0013      	movs	r3, r2
    1be4:	a901      	add	r1, sp, #4
    1be6:	6800      	ldr	r0, [r0, #0]
    uint32 unused = 0;
    1be8:	9201      	str	r2, [sp, #4]
    (void)osMessageQueuePut(rpc_incoming_queue, (void*)&unused, 0, osNoWait);
    1bea:	f012 ffa9 	bl	14b40 <osMessageQueuePut>
}
    1bee:	bd07      	pop	{r0, r1, r2, pc}
    1bf0:	0100068c 	.word	0x0100068c

00001bf4 <wait_on_incoming_queue>:
    (void)osMessageQueueGet(rpc_incoming_queue, (void*)&unused, NULL, osWaitForever);
    1bf4:	2301      	movs	r3, #1
{
    1bf6:	b507      	push	{r0, r1, r2, lr}
    (void)osMessageQueueGet(rpc_incoming_queue, (void*)&unused, NULL, osWaitForever);
    1bf8:	4803      	ldr	r0, [pc, #12]	; (1c08 <wait_on_incoming_queue+0x14>)
    1bfa:	425b      	negs	r3, r3
    1bfc:	2200      	movs	r2, #0
    1bfe:	a901      	add	r1, sp, #4
    1c00:	6800      	ldr	r0, [r0, #0]
    1c02:	f012 ffc9 	bl	14b98 <osMessageQueueGet>
}
    1c06:	bd07      	pop	{r0, r1, r2, pc}
    1c08:	0100068c 	.word	0x0100068c

00001c0c <wait_on_outgoing_queue>:
{
    1c0c:	b513      	push	{r0, r1, r4, lr}
    1c0e:	0004      	movs	r4, r0
    assert((core < CORES_MAX_NUMBER_PHYSICAL));
    1c10:	2802      	cmp	r0, #2
    1c12:	d903      	bls.n	1c1c <wait_on_outgoing_queue+0x10>
    1c14:	4671      	mov	r1, lr
    1c16:	2016      	movs	r0, #22
    1c18:	f7ff ff7a 	bl	1b10 <panic>
    if (osMessageQueueGet(*queue, (void*)&unused, NULL, (uint32_t)osMs2Tick(RPC_TIMEOUT_S*1000)) != osOK) //lint !e747
    1c1c:	4b09      	ldr	r3, [pc, #36]	; (1c44 <wait_on_outgoing_queue+0x38>)
    1c1e:	00a4      	lsls	r4, r4, #2
    1c20:	4809      	ldr	r0, [pc, #36]	; (1c48 <wait_on_outgoing_queue+0x3c>)
    1c22:	2100      	movs	r1, #0
    1c24:	58e4      	ldr	r4, [r4, r3]
    1c26:	f012 fddd 	bl	147e4 <osMs2Tick>
    1c2a:	2200      	movs	r2, #0
    1c2c:	0003      	movs	r3, r0
    1c2e:	a901      	add	r1, sp, #4
    1c30:	0020      	movs	r0, r4
    1c32:	f012 ffb1 	bl	14b98 <osMessageQueueGet>
    1c36:	2800      	cmp	r0, #0
    1c38:	d002      	beq.n	1c40 <wait_on_outgoing_queue+0x34>
        reboot_system(REBOOT_CAUSE_APPLICATION_RPC_TIMEOUT);
    1c3a:	4804      	ldr	r0, [pc, #16]	; (1c4c <wait_on_outgoing_queue+0x40>)
    1c3c:	f016 fb36 	bl	182ac <reboot_system>
}
    1c40:	bd13      	pop	{r0, r1, r4, pc}
    1c42:	46c0      	nop			; (mov r8, r8)
    1c44:	01000690 	.word	0x01000690
    1c48:	0000ea60 	.word	0x0000ea60
    1c4c:	00002102 	.word	0x00002102

00001c50 <send_to_outgoing_queue_from_isr>:
    uint32 unused = 0;
    1c50:	2300      	movs	r3, #0
{
    1c52:	b513      	push	{r0, r1, r4, lr}
    1c54:	0004      	movs	r4, r0
    uint32 unused = 0;
    1c56:	9301      	str	r3, [sp, #4]
    assert((core < CORES_MAX_NUMBER_PHYSICAL));
    1c58:	2802      	cmp	r0, #2
    1c5a:	d903      	bls.n	1c64 <send_to_outgoing_queue_from_isr+0x14>
    1c5c:	4671      	mov	r1, lr
    1c5e:	2016      	movs	r0, #22
    1c60:	f7ff ff56 	bl	1b10 <panic>
    (void)osMessageQueuePut(*queue, (void*)&unused, 0, osNoWait);
    1c64:	2300      	movs	r3, #0
    1c66:	4804      	ldr	r0, [pc, #16]	; (1c78 <send_to_outgoing_queue_from_isr+0x28>)
    1c68:	00a4      	lsls	r4, r4, #2
    1c6a:	001a      	movs	r2, r3
    1c6c:	a901      	add	r1, sp, #4
    1c6e:	5820      	ldr	r0, [r4, r0]
    1c70:	f012 ff66 	bl	14b40 <osMessageQueuePut>
}
    1c74:	bd13      	pop	{r0, r1, r4, pc}
    1c76:	46c0      	nop			; (mov r8, r8)
    1c78:	01000690 	.word	0x01000690

00001c7c <rpc_interface_create_queue>:
    rpc_semaphores[2] = osSemaphoreNew(1, 1, NULL);
    rpc_sent_semaphore = osSemaphoreNew(1, 1, NULL);
}

void rpc_interface_create_queue()
{
    1c7c:	b510      	push	{r4, lr}
    rpc_incoming_queue = osMessageQueueNew(RPC_QUEUE_LEN, RPC_QUEUE_ITEM_SIZE, NULL);
    1c7e:	2200      	movs	r2, #0
    1c80:	2104      	movs	r1, #4
    1c82:	2002      	movs	r0, #2
    1c84:	f012 ff3a 	bl	14afc <osMessageQueueNew>
    1c88:	4b0a      	ldr	r3, [pc, #40]	; (1cb4 <rpc_interface_create_queue+0x38>)

    rpc_outgoing_queue[0] = osMessageQueueNew(RPC_QUEUE_LEN, RPC_QUEUE_ITEM_SIZE, NULL);
    1c8a:	2200      	movs	r2, #0
    rpc_incoming_queue = osMessageQueueNew(RPC_QUEUE_LEN, RPC_QUEUE_ITEM_SIZE, NULL);
    1c8c:	6018      	str	r0, [r3, #0]
    rpc_outgoing_queue[0] = osMessageQueueNew(RPC_QUEUE_LEN, RPC_QUEUE_ITEM_SIZE, NULL);
    1c8e:	2104      	movs	r1, #4
    1c90:	2002      	movs	r0, #2
    1c92:	f012 ff33 	bl	14afc <osMessageQueueNew>
    1c96:	4c08      	ldr	r4, [pc, #32]	; (1cb8 <rpc_interface_create_queue+0x3c>)
    rpc_outgoing_queue[1] = osMessageQueueNew(RPC_QUEUE_LEN, RPC_QUEUE_ITEM_SIZE, NULL);
    1c98:	2200      	movs	r2, #0
    rpc_outgoing_queue[0] = osMessageQueueNew(RPC_QUEUE_LEN, RPC_QUEUE_ITEM_SIZE, NULL);
    1c9a:	6020      	str	r0, [r4, #0]
    rpc_outgoing_queue[1] = osMessageQueueNew(RPC_QUEUE_LEN, RPC_QUEUE_ITEM_SIZE, NULL);
    1c9c:	2104      	movs	r1, #4
    1c9e:	2002      	movs	r0, #2
    1ca0:	f012 ff2c 	bl	14afc <osMessageQueueNew>
    rpc_outgoing_queue[2] = osMessageQueueNew(RPC_QUEUE_LEN, RPC_QUEUE_ITEM_SIZE, NULL);
    1ca4:	2200      	movs	r2, #0
    rpc_outgoing_queue[1] = osMessageQueueNew(RPC_QUEUE_LEN, RPC_QUEUE_ITEM_SIZE, NULL);
    1ca6:	6060      	str	r0, [r4, #4]
    rpc_outgoing_queue[2] = osMessageQueueNew(RPC_QUEUE_LEN, RPC_QUEUE_ITEM_SIZE, NULL);
    1ca8:	2104      	movs	r1, #4
    1caa:	2002      	movs	r0, #2
    1cac:	f012 ff26 	bl	14afc <osMessageQueueNew>
    1cb0:	60a0      	str	r0, [r4, #8]
}
    1cb2:	bd10      	pop	{r4, pc}
    1cb4:	0100068c 	.word	0x0100068c
    1cb8:	01000690 	.word	0x01000690

00001cbc <rpc_main>:

//lint -sem( rpc_main, thread_mono )
void rpc_main( void *unused )
{
    1cbc:	b510      	push	{r4, lr}
    UNUSED(unused);
#if CORE == PROTOCOL
    rpc_thread_handle = osThreadGetId();
#endif
    //This function does not return
    rpc_thread_main();
    1cbe:	f000 fb13 	bl	22e8 <rpc_thread_main>
}
    1cc2:	bd10      	pop	{r4, pc}

00001cc4 <rpc_init>:
    rpc_semaphores[0] = osSemaphoreNew(1, 1, NULL);
    1cc4:	2101      	movs	r1, #1

void rpc_init (void)
{
    1cc6:	b510      	push	{r4, lr}
    rpc_semaphores[0] = osSemaphoreNew(1, 1, NULL);
    1cc8:	2200      	movs	r2, #0
{
    1cca:	b08a      	sub	sp, #40	; 0x28
    rpc_semaphores[0] = osSemaphoreNew(1, 1, NULL);
    1ccc:	0008      	movs	r0, r1
    1cce:	f012 feb9 	bl	14a44 <osSemaphoreNew>
    rpc_semaphores[1] = osSemaphoreNew(1, 1, NULL);
    1cd2:	2101      	movs	r1, #1
    rpc_semaphores[0] = osSemaphoreNew(1, 1, NULL);
    1cd4:	4c15      	ldr	r4, [pc, #84]	; (1d2c <rpc_init+0x68>)
    rpc_semaphores[1] = osSemaphoreNew(1, 1, NULL);
    1cd6:	2200      	movs	r2, #0
    rpc_semaphores[0] = osSemaphoreNew(1, 1, NULL);
    1cd8:	6020      	str	r0, [r4, #0]
    rpc_semaphores[1] = osSemaphoreNew(1, 1, NULL);
    1cda:	0008      	movs	r0, r1
    1cdc:	f012 feb2 	bl	14a44 <osSemaphoreNew>
    rpc_semaphores[2] = osSemaphoreNew(1, 1, NULL);
    1ce0:	2101      	movs	r1, #1
    rpc_semaphores[1] = osSemaphoreNew(1, 1, NULL);
    1ce2:	6060      	str	r0, [r4, #4]
    rpc_semaphores[2] = osSemaphoreNew(1, 1, NULL);
    1ce4:	2200      	movs	r2, #0
    1ce6:	0008      	movs	r0, r1
    1ce8:	f012 feac 	bl	14a44 <osSemaphoreNew>
    rpc_sent_semaphore = osSemaphoreNew(1, 1, NULL);
    1cec:	2101      	movs	r1, #1
    rpc_semaphores[2] = osSemaphoreNew(1, 1, NULL);
    1cee:	60a0      	str	r0, [r4, #8]
    rpc_sent_semaphore = osSemaphoreNew(1, 1, NULL);
    1cf0:	2200      	movs	r2, #0
    1cf2:	0008      	movs	r0, r1
    1cf4:	f012 fea6 	bl	14a44 <osSemaphoreNew>
    1cf8:	4b0d      	ldr	r3, [pc, #52]	; (1d30 <rpc_init+0x6c>)
    1cfa:	6018      	str	r0, [r3, #0]
    rpc_interface_create_semaphores();

    rpc_interface_mailboxes mb;
    mb.incoming_command_recieve = wait_on_incoming_queue;
    1cfc:	4b0d      	ldr	r3, [pc, #52]	; (1d34 <rpc_init+0x70>)
    mb.rpc_sent_semaphore_give = cmsis_rpc_sent_give_semaphore;
    mb.rpc_sent_semaphore_take = cmsis_rpc_sent_take_semaphore;

    mb.rpc_task_yield = cmsis_rpc_task_yield;

    rpc_interface_init(&mb);
    1cfe:	a801      	add	r0, sp, #4
    mb.incoming_command_recieve = wait_on_incoming_queue;
    1d00:	9301      	str	r3, [sp, #4]
    mb.incoming_command_send_from_isr = send_to_incoming_queue_from_isr;
    1d02:	4b0d      	ldr	r3, [pc, #52]	; (1d38 <rpc_init+0x74>)
    1d04:	9302      	str	r3, [sp, #8]
    mb.outgoing_command_recieve = wait_on_outgoing_queue;
    1d06:	4b0d      	ldr	r3, [pc, #52]	; (1d3c <rpc_init+0x78>)
    1d08:	9303      	str	r3, [sp, #12]
    mb.outgoing_command_send_from_isr = send_to_outgoing_queue_from_isr;
    1d0a:	4b0d      	ldr	r3, [pc, #52]	; (1d40 <rpc_init+0x7c>)
    1d0c:	9304      	str	r3, [sp, #16]
    mb.rpc_mailbox_semaphore_give = cmsis_rpc_give_semaphore;
    1d0e:	4b0d      	ldr	r3, [pc, #52]	; (1d44 <rpc_init+0x80>)
    1d10:	9306      	str	r3, [sp, #24]
    mb.rpc_mailbox_semaphore_take = cmsis_rpc_take_semaphore;
    1d12:	4b0d      	ldr	r3, [pc, #52]	; (1d48 <rpc_init+0x84>)
    1d14:	9305      	str	r3, [sp, #20]
    mb.rpc_sent_semaphore_give = cmsis_rpc_sent_give_semaphore;
    1d16:	4b0d      	ldr	r3, [pc, #52]	; (1d4c <rpc_init+0x88>)
    1d18:	9308      	str	r3, [sp, #32]
    mb.rpc_sent_semaphore_take = cmsis_rpc_sent_take_semaphore;
    1d1a:	4b0d      	ldr	r3, [pc, #52]	; (1d50 <rpc_init+0x8c>)
    1d1c:	9307      	str	r3, [sp, #28]
    mb.rpc_task_yield = cmsis_rpc_task_yield;
    1d1e:	4b0d      	ldr	r3, [pc, #52]	; (1d54 <rpc_init+0x90>)
    1d20:	9309      	str	r3, [sp, #36]	; 0x24
    rpc_interface_init(&mb);
    1d22:	f000 fa97 	bl	2254 <rpc_interface_init>
}
    1d26:	b00a      	add	sp, #40	; 0x28
    1d28:	bd10      	pop	{r4, pc}
    1d2a:	46c0      	nop			; (mov r8, r8)
    1d2c:	0100069c 	.word	0x0100069c
    1d30:	010006a8 	.word	0x010006a8
    1d34:	00001bf5 	.word	0x00001bf5
    1d38:	00001bdd 	.word	0x00001bdd
    1d3c:	00001c0d 	.word	0x00001c0d
    1d40:	00001c51 	.word	0x00001c51
    1d44:	00001bc5 	.word	0x00001bc5
    1d48:	00001b91 	.word	0x00001b91
    1d4c:	00001bad 	.word	0x00001bad
    1d50:	00001b75 	.word	0x00001b75
    1d54:	00001b69 	.word	0x00001b69

00001d58 <rpc_interface_get_max_command_id>:
        rpc_interface_poll();
    }
}

static uint16 rpc_interface_get_max_command_id(CORES core, bool is_command)
{
    1d58:	b510      	push	{r4, lr}
        {
            return RPC_COMMANDS_PROTOCOL_TO_APPLICATION_MAX_COMMANDS;
        }
    }
#elif CORE == APPS
    assert(core != CORES_APPS_CORE);
    1d5a:	2802      	cmp	r0, #2
    1d5c:	d106      	bne.n	1d6c <rpc_interface_get_max_command_id+0x14>
    1d5e:	4671      	mov	r1, lr
    1d60:	3014      	adds	r0, #20
    1d62:	f7ff fed5 	bl	1b10 <panic>
            return RPC_COMMANDS_APPLICATION_TO_PROTOCOL_MAX_COMMANDS;
        }
    }
    else
    {
        return 0;
    1d66:	2300      	movs	r3, #0
    }
#else
#error "RPC_INTERFACE.C - UNKNOWN CORE"
#endif
}
    1d68:	0018      	movs	r0, r3
    1d6a:	bd10      	pop	{r4, pc}
    if (core == CORES_SECURITY_CORE)
    1d6c:	2800      	cmp	r0, #0
    1d6e:	d104      	bne.n	1d7a <rpc_interface_get_max_command_id+0x22>
            return RPC_COMMANDS_SECURITY_TO_APPLICATION_MAX_COMMANDS;
    1d70:	230b      	movs	r3, #11
        if (is_command)
    1d72:	2900      	cmp	r1, #0
    1d74:	d1f8      	bne.n	1d68 <rpc_interface_get_max_command_id+0x10>
            return RPC_COMMANDS_APPLICATION_TO_SECURITY_MAX_COMMANDS;
    1d76:	331f      	adds	r3, #31
    1d78:	e7f6      	b.n	1d68 <rpc_interface_get_max_command_id+0x10>
        return 0;
    1d7a:	2300      	movs	r3, #0
    else if (core == CORES_PROTOCOL_CORE)
    1d7c:	2801      	cmp	r0, #1
    1d7e:	d1f3      	bne.n	1d68 <rpc_interface_get_max_command_id+0x10>
            return RPC_COMMANDS_PROTOCOL_TO_APPLICATION_MAX_COMMANDS;
    1d80:	3325      	adds	r3, #37	; 0x25
        if (is_command)
    1d82:	2900      	cmp	r1, #0
    1d84:	d1f0      	bne.n	1d68 <rpc_interface_get_max_command_id+0x10>
            return RPC_COMMANDS_APPLICATION_TO_PROTOCOL_MAX_COMMANDS;
    1d86:	3359      	adds	r3, #89	; 0x59
    1d88:	e7ee      	b.n	1d68 <rpc_interface_get_max_command_id+0x10>

00001d8a <rpc_get_core_id>:
{
    1d8a:	b510      	push	{r4, lr}
    1d8c:	0004      	movs	r4, r0
    assert(core < CORES_MAX_NUMBER_PHYSICAL);
    1d8e:	2801      	cmp	r0, #1
    1d90:	d903      	bls.n	1d9a <rpc_get_core_id+0x10>
    1d92:	4671      	mov	r1, lr
    1d94:	2016      	movs	r0, #22
    1d96:	f7ff febb 	bl	1b10 <panic>
}
    1d9a:	0020      	movs	r0, r4
    1d9c:	bd10      	pop	{r4, pc}
	...

00001da0 <set_receive_info>:
{
    1da0:	b510      	push	{r4, lr}
    1da2:	000c      	movs	r4, r1
    receive_info[rpc_get_core_id(src)] = info;
    1da4:	f7ff fff1 	bl	1d8a <rpc_get_core_id>
    1da8:	4b01      	ldr	r3, [pc, #4]	; (1db0 <set_receive_info+0x10>)
    1daa:	0080      	lsls	r0, r0, #2
    1dac:	50c4      	str	r4, [r0, r3]
}
    1dae:	bd10      	pop	{r4, pc}
    1db0:	010006cc 	.word	0x010006cc

00001db4 <rpc_interface_ipc_callback>:
        rpc_interface_state[rpc_core_id] = RPC_STATE_NORMAL;
    }
}

static bool rpc_interface_ipc_callback( IPC_ACTION message, const volatile ipc_payload * payload_p, CORES src, uint32 id )
{
    1db4:	4673      	mov	r3, lr
    1db6:	b5f0      	push	{r4, r5, r6, r7, lr}
    return &receive_state[rpc_get_core_id(src)];
    1db8:	0010      	movs	r0, r2
{
    1dba:	b089      	sub	sp, #36	; 0x24
    1dbc:	9303      	str	r3, [sp, #12]
    1dbe:	9101      	str	r1, [sp, #4]
    1dc0:	9200      	str	r2, [sp, #0]
    return &receive_state[rpc_get_core_id(src)];
    1dc2:	f7ff ffe2 	bl	1d8a <rpc_get_core_id>
    non_os_exit_critical();
#endif

    rpc_core_receive_state = get_receive_state(src);

    if ((*rpc_core_receive_state) == RPC_RECEIVE_STATE_NONE)
    1dc6:	4dbf      	ldr	r5, [pc, #764]	; (20c4 <rpc_interface_ipc_callback+0x310>)
    return &receive_state[rpc_get_core_id(src)];
    1dc8:	0004      	movs	r4, r0
    if ((*rpc_core_receive_state) == RPC_RECEIVE_STATE_NONE)
    1dca:	5c2b      	ldrb	r3, [r5, r0]
    1dcc:	2b00      	cmp	r3, #0
    1dce:	d113      	bne.n	1df8 <rpc_interface_ipc_callback+0x44>
    {
        header = (rpc_command_header*)payload_p;//lint !e826 The buffer_received is bigger than header
        if (header->is_command == true)
    1dd0:	9b01      	ldr	r3, [sp, #4]
    return &received_data[rpc_get_core_id(src)];
    1dd2:	9800      	ldr	r0, [sp, #0]
        if (header->is_command == true)
    1dd4:	791b      	ldrb	r3, [r3, #4]
    1dd6:	2b00      	cmp	r3, #0
    1dd8:	d100      	bne.n	1ddc <rpc_interface_ipc_callback+0x28>
    1dda:	e096      	b.n	1f0a <rpc_interface_ipc_callback+0x156>
    return &received_data[rpc_get_core_id(src)];
    1ddc:	f7ff ffd5 	bl	1d8a <rpc_get_core_id>
        {
            assert((get_receive_command_mailbox(src))->data_received == 0);   //Check that the state internal to this file is correct
    1de0:	4bb9      	ldr	r3, [pc, #740]	; (20c8 <rpc_interface_ipc_callback+0x314>)
    1de2:	4358      	muls	r0, r3
    1de4:	4bb9      	ldr	r3, [pc, #740]	; (20cc <rpc_interface_ipc_callback+0x318>)
    1de6:	5ac3      	ldrh	r3, [r0, r3]
    1de8:	2b00      	cmp	r3, #0
    1dea:	d003      	beq.n	1df4 <rpc_interface_ipc_callback+0x40>
    1dec:	9903      	ldr	r1, [sp, #12]
    1dee:	2016      	movs	r0, #22
    1df0:	f7ff fe8e 	bl	1b10 <panic>
            (*rpc_core_receive_state) = RPC_RECEIVE_STATE_COMMAND;
    1df4:	2301      	movs	r3, #1
        }
        else
        {
            assert((get_receive_response_mailbox(src))->data_received == 0);  //Check that the state internal to this file is correct
            (*rpc_core_receive_state) = RPC_RECEIVE_STATE_RESPONSE;
    1df6:	552b      	strb	r3, [r5, r4]
        }
    }

    if ((*rpc_core_receive_state) == RPC_RECEIVE_STATE_COMMAND)
    1df8:	5d2b      	ldrb	r3, [r5, r4]
    1dfa:	2b01      	cmp	r3, #1
    1dfc:	d000      	beq.n	1e00 <rpc_interface_ipc_callback+0x4c>
    1dfe:	e092      	b.n	1f26 <rpc_interface_ipc_callback+0x172>
    1e00:	4cb1      	ldr	r4, [pc, #708]	; (20c8 <rpc_interface_ipc_callback+0x314>)
    return &received_data[rpc_get_core_id(src)];
    1e02:	9800      	ldr	r0, [sp, #0]
    1e04:	f7ff ffc1 	bl	1d8a <rpc_get_core_id>
    1e08:	0023      	movs	r3, r4
    1e0a:	4343      	muls	r3, r0
    1e0c:	0005      	movs	r5, r0
    return &receive_state[rpc_get_core_id(src)];
    1e0e:	9800      	ldr	r0, [sp, #0]
    1e10:	9302      	str	r3, [sp, #8]
    1e12:	f7ff ffba 	bl	1d8a <rpc_get_core_id>
        remaining = sizeof(ipc_payload);
    1e16:	2240      	movs	r2, #64	; 0x40
    if (received->data_received)
    1e18:	4eac      	ldr	r6, [pc, #688]	; (20cc <rpc_interface_ipc_callback+0x318>)
    1e1a:	9b02      	ldr	r3, [sp, #8]
    return &receive_state[rpc_get_core_id(src)];
    1e1c:	9005      	str	r0, [sp, #20]
    if (received->data_received)
    1e1e:	5b9b      	ldrh	r3, [r3, r6]
        remaining = sizeof(ipc_payload);
    1e20:	9204      	str	r2, [sp, #16]
    if (received->data_received)
    1e22:	2b00      	cmp	r3, #0
    1e24:	d013      	beq.n	1e4e <rpc_interface_ipc_callback+0x9a>
        assert(received->cmd.header.command_length > 0);
    1e26:	9b02      	ldr	r3, [sp, #8]
    1e28:	18f3      	adds	r3, r6, r3
    1e2a:	885b      	ldrh	r3, [r3, #2]
    1e2c:	2b00      	cmp	r3, #0
    1e2e:	d103      	bne.n	1e38 <rpc_interface_ipc_callback+0x84>
    1e30:	9903      	ldr	r1, [sp, #12]
    1e32:	2016      	movs	r0, #22
    1e34:	f7ff fe6c 	bl	1b10 <panic>
        remaining = min(received->cmd.header.command_length - received->data_received, (uint16)sizeof(ipc_payload));
    1e38:	0022      	movs	r2, r4
    1e3a:	436a      	muls	r2, r5
    1e3c:	18b3      	adds	r3, r6, r2
    1e3e:	885b      	ldrh	r3, [r3, #2]
    1e40:	5ab2      	ldrh	r2, [r6, r2]
    1e42:	1a9b      	subs	r3, r3, r2
    1e44:	2b40      	cmp	r3, #64	; 0x40
    1e46:	dd00      	ble.n	1e4a <rpc_interface_ipc_callback+0x96>
    1e48:	2340      	movs	r3, #64	; 0x40
    1e4a:	b29b      	uxth	r3, r3
    1e4c:	9304      	str	r3, [sp, #16]
    assert(received->cmd.header.command_length <= MESSAGE_BUFFER_LENGTH);
    1e4e:	0023      	movs	r3, r4
    1e50:	436b      	muls	r3, r5
    1e52:	4e9e      	ldr	r6, [pc, #632]	; (20cc <rpc_interface_ipc_callback+0x318>)
    1e54:	4a9e      	ldr	r2, [pc, #632]	; (20d0 <rpc_interface_ipc_callback+0x31c>)
    1e56:	18f3      	adds	r3, r6, r3
    1e58:	885b      	ldrh	r3, [r3, #2]
    1e5a:	4293      	cmp	r3, r2
    1e5c:	d903      	bls.n	1e66 <rpc_interface_ipc_callback+0xb2>
    1e5e:	9903      	ldr	r1, [sp, #12]
    1e60:	2016      	movs	r0, #22
    1e62:	f7ff fe55 	bl	1b10 <panic>
    assert(received->cmd.header.rpc_command_id < rpc_interface_get_max_command_id(src, true));
    1e66:	0023      	movs	r3, r4
    1e68:	436b      	muls	r3, r5
    1e6a:	2101      	movs	r1, #1
    1e6c:	18f6      	adds	r6, r6, r3
    1e6e:	9800      	ldr	r0, [sp, #0]
    1e70:	88b6      	ldrh	r6, [r6, #4]
    1e72:	f7ff ff71 	bl	1d58 <rpc_interface_get_max_command_id>
    1e76:	4286      	cmp	r6, r0
    1e78:	d303      	bcc.n	1e82 <rpc_interface_ipc_callback+0xce>
    1e7a:	9903      	ldr	r1, [sp, #12]
    1e7c:	2016      	movs	r0, #22
    1e7e:	f7ff fe47 	bl	1b10 <panic>
    if (received->cmd.header.command_length <= MESSAGE_BUFFER_LENGTH)
    1e82:	0027      	movs	r7, r4
    1e84:	436f      	muls	r7, r5
    1e86:	4e91      	ldr	r6, [pc, #580]	; (20cc <rpc_interface_ipc_callback+0x318>)
    1e88:	4a91      	ldr	r2, [pc, #580]	; (20d0 <rpc_interface_ipc_callback+0x31c>)
    1e8a:	19f3      	adds	r3, r6, r7
    1e8c:	885b      	ldrh	r3, [r3, #2]
    1e8e:	4293      	cmp	r3, r2
    1e90:	d80c      	bhi.n	1eac <rpc_interface_ipc_callback+0xf8>
        memcpy(&(received->cmd.data[received->data_received]), buffer_received, remaining);
    1e92:	9b02      	ldr	r3, [sp, #8]
    1e94:	5bb8      	ldrh	r0, [r7, r6]
    1e96:	3302      	adds	r3, #2
    1e98:	18c0      	adds	r0, r0, r3
    1e9a:	9a04      	ldr	r2, [sp, #16]
    1e9c:	1980      	adds	r0, r0, r6
    1e9e:	9901      	ldr	r1, [sp, #4]
    1ea0:	f7fe f9a6 	bl	1f0 <memcpy>
        received->data_received += remaining;
    1ea4:	5bbb      	ldrh	r3, [r7, r6]
    1ea6:	9a04      	ldr	r2, [sp, #16]
    1ea8:	18d3      	adds	r3, r2, r3
    1eaa:	53bb      	strh	r3, [r7, r6]
    if (received->cmd.header.command_length > received->data_received)
    1eac:	436c      	muls	r4, r5
    1eae:	4e87      	ldr	r6, [pc, #540]	; (20cc <rpc_interface_ipc_callback+0x318>)
    1eb0:	1937      	adds	r7, r6, r4
    1eb2:	887b      	ldrh	r3, [r7, #2]
    1eb4:	5ba2      	ldrh	r2, [r4, r6]
    1eb6:	429a      	cmp	r2, r3
    1eb8:	d324      	bcc.n	1f04 <rpc_interface_ipc_callback+0x150>
    received->data_received = 0;
    1eba:	2200      	movs	r2, #0
    (*rpc_core_receive_state) = RPC_RECEIVE_STATE_NONE;
    1ebc:	4981      	ldr	r1, [pc, #516]	; (20c4 <rpc_interface_ipc_callback+0x310>)
    1ebe:	9805      	ldr	r0, [sp, #20]
    received->data_received = 0;
    1ec0:	53a2      	strh	r2, [r4, r6]
    (*rpc_core_receive_state) = RPC_RECEIVE_STATE_NONE;
    1ec2:	540a      	strb	r2, [r1, r0]
    if ((received->cmd.header.command_length <= MESSAGE_BUFFER_LENGTH) &&
    1ec4:	4a82      	ldr	r2, [pc, #520]	; (20d0 <rpc_interface_ipc_callback+0x31c>)
    1ec6:	4293      	cmp	r3, r2
    1ec8:	d81c      	bhi.n	1f04 <rpc_interface_ipc_callback+0x150>
        (received->cmd.header.rpc_command_id < rpc_interface_get_max_command_id(src, true)))
    1eca:	2101      	movs	r1, #1
    1ecc:	9800      	ldr	r0, [sp, #0]
    1ece:	88bc      	ldrh	r4, [r7, #4]
    1ed0:	f7ff ff42 	bl	1d58 <rpc_interface_get_max_command_id>
    if ((received->cmd.header.command_length <= MESSAGE_BUFFER_LENGTH) &&
    1ed4:	4284      	cmp	r4, r0
    1ed6:	d215      	bcs.n	1f04 <rpc_interface_ipc_callback+0x150>
        rpc_core_id = rpc_get_core_id(src);
    1ed8:	9800      	ldr	r0, [sp, #0]
    1eda:	f7ff ff56 	bl	1d8a <rpc_get_core_id>
        irq_callback[rpc_core_id].src_core = src;
    1ede:	466a      	mov	r2, sp
    1ee0:	4b7c      	ldr	r3, [pc, #496]	; (20d4 <rpc_interface_ipc_callback+0x320>)
    1ee2:	7812      	ldrb	r2, [r2, #0]
    1ee4:	0100      	lsls	r0, r0, #4
    1ee6:	54c2      	strb	r2, [r0, r3]
        irq_callback[rpc_core_id].is_command = true;
    1ee8:	1818      	adds	r0, r3, r0
    1eea:	2301      	movs	r3, #1
    1eec:	7203      	strb	r3, [r0, #8]
        irq_callback[rpc_core_id].rpc_cmd_id = received->cmd.header.rpc_command_id;
    1eee:	88bb      	ldrh	r3, [r7, #4]
    1ef0:	6043      	str	r3, [r0, #4]
    return &received_data[rpc_get_core_id(src)];
    1ef2:	9b02      	ldr	r3, [sp, #8]
    1ef4:	199e      	adds	r6, r3, r6
        if (rpc_mailboxes.incoming_command_send_from_isr)
    1ef6:	4b78      	ldr	r3, [pc, #480]	; (20d8 <rpc_interface_ipc_callback+0x324>)
        irq_callback[rpc_core_id].data = received->cmd.data + MESSAGE_HEADER_SIZE;
    1ef8:	3607      	adds	r6, #7
        if (rpc_mailboxes.incoming_command_send_from_isr)
    1efa:	685b      	ldr	r3, [r3, #4]
        irq_callback[rpc_core_id].data = received->cmd.data + MESSAGE_HEADER_SIZE;
    1efc:	60c6      	str	r6, [r0, #12]
        if (rpc_mailboxes.incoming_command_send_from_isr)
    1efe:	2b00      	cmp	r3, #0
    1f00:	d000      	beq.n	1f04 <rpc_interface_ipc_callback+0x150>
            rpc_mailboxes.incoming_command_send_from_isr();
    1f02:	4798      	blx	r3
    else
    {
        assert(false);//should not be here
    }
    return true;
}
    1f04:	2001      	movs	r0, #1
    1f06:	b009      	add	sp, #36	; 0x24
    1f08:	bdf0      	pop	{r4, r5, r6, r7, pc}
    return &received_response[rpc_get_core_id(src)];
    1f0a:	f7ff ff3e 	bl	1d8a <rpc_get_core_id>
            assert((get_receive_response_mailbox(src))->data_received == 0);  //Check that the state internal to this file is correct
    1f0e:	230c      	movs	r3, #12
    1f10:	4358      	muls	r0, r3
    1f12:	4b72      	ldr	r3, [pc, #456]	; (20dc <rpc_interface_ipc_callback+0x328>)
    1f14:	5ac3      	ldrh	r3, [r0, r3]
    1f16:	2b00      	cmp	r3, #0
    1f18:	d003      	beq.n	1f22 <rpc_interface_ipc_callback+0x16e>
    1f1a:	9903      	ldr	r1, [sp, #12]
    1f1c:	2016      	movs	r0, #22
    1f1e:	f7ff fdf7 	bl	1b10 <panic>
            (*rpc_core_receive_state) = RPC_RECEIVE_STATE_RESPONSE;
    1f22:	2302      	movs	r3, #2
    1f24:	e767      	b.n	1df6 <rpc_interface_ipc_callback+0x42>
    else if ((*rpc_core_receive_state) == RPC_RECEIVE_STATE_RESPONSE)
    1f26:	2b02      	cmp	r3, #2
    1f28:	d000      	beq.n	1f2c <rpc_interface_ipc_callback+0x178>
    1f2a:	e188      	b.n	223e <rpc_interface_ipc_callback+0x48a>
    return &received_response[rpc_get_core_id(src)];
    1f2c:	9800      	ldr	r0, [sp, #0]
    1f2e:	f7ff ff2c 	bl	1d8a <rpc_get_core_id>
    1f32:	9002      	str	r0, [sp, #8]
    return &receive_state[rpc_get_core_id(src)];
    1f34:	9800      	ldr	r0, [sp, #0]
    1f36:	f7ff ff28 	bl	1d8a <rpc_get_core_id>
    1f3a:	9007      	str	r0, [sp, #28]
    rpc_core_id = rpc_get_core_id(src);
    1f3c:	9800      	ldr	r0, [sp, #0]
    1f3e:	f7ff ff24 	bl	1d8a <rpc_get_core_id>
    assert(rpc_interface_state[rpc_core_id] == RPC_STATE_AWAITING_RESPONSE);
    1f42:	4b67      	ldr	r3, [pc, #412]	; (20e0 <rpc_interface_ipc_callback+0x32c>)
    rpc_core_id = rpc_get_core_id(src);
    1f44:	9005      	str	r0, [sp, #20]
    assert(rpc_interface_state[rpc_core_id] == RPC_STATE_AWAITING_RESPONSE);
    1f46:	5c1b      	ldrb	r3, [r3, r0]
    1f48:	2b01      	cmp	r3, #1
    1f4a:	d003      	beq.n	1f54 <rpc_interface_ipc_callback+0x1a0>
    1f4c:	9903      	ldr	r1, [sp, #12]
    1f4e:	2016      	movs	r0, #22
    1f50:	f7ff fdde 	bl	1b10 <panic>
    if (received->data_received)
    1f54:	250c      	movs	r5, #12
    1f56:	9b02      	ldr	r3, [sp, #8]
    1f58:	4c60      	ldr	r4, [pc, #384]	; (20dc <rpc_interface_ipc_callback+0x328>)
    1f5a:	435d      	muls	r5, r3
    1f5c:	5b2b      	ldrh	r3, [r5, r4]
    1f5e:	1966      	adds	r6, r4, r5
    1f60:	2b00      	cmp	r3, #0
    1f62:	d037      	beq.n	1fd4 <rpc_interface_ipc_callback+0x220>
        assert(received->header.command_length > 0);
    1f64:	8873      	ldrh	r3, [r6, #2]
    1f66:	2b00      	cmp	r3, #0
    1f68:	d103      	bne.n	1f72 <rpc_interface_ipc_callback+0x1be>
    1f6a:	9903      	ldr	r1, [sp, #12]
    1f6c:	2016      	movs	r0, #22
    1f6e:	f7ff fdcf 	bl	1b10 <panic>
        remaining = min(received->header.command_length - received->data_received, (uint16)sizeof(ipc_payload));
    1f72:	220c      	movs	r2, #12
    1f74:	9b02      	ldr	r3, [sp, #8]
    1f76:	435a      	muls	r2, r3
    1f78:	18a3      	adds	r3, r4, r2
    1f7a:	885b      	ldrh	r3, [r3, #2]
    1f7c:	5aa2      	ldrh	r2, [r4, r2]
    1f7e:	1a9b      	subs	r3, r3, r2
    1f80:	2b40      	cmp	r3, #64	; 0x40
    1f82:	dd00      	ble.n	1f86 <rpc_interface_ipc_callback+0x1d2>
    1f84:	2340      	movs	r3, #64	; 0x40
    1f86:	b29f      	uxth	r7, r3
    received->data_received += remaining;
    1f88:	230c      	movs	r3, #12
    1f8a:	9a02      	ldr	r2, [sp, #8]
    1f8c:	4c53      	ldr	r4, [pc, #332]	; (20dc <rpc_interface_ipc_callback+0x328>)
    1f8e:	4353      	muls	r3, r2
    1f90:	5b1a      	ldrh	r2, [r3, r4]
    assert(received->header.rpc_command_id < rpc_interface_get_max_command_id(src, false));
    1f92:	2100      	movs	r1, #0
    received->data_received += remaining;
    1f94:	18ba      	adds	r2, r7, r2
    1f96:	531a      	strh	r2, [r3, r4]
    assert(received->header.rpc_command_id < rpc_interface_get_max_command_id(src, false));
    1f98:	9800      	ldr	r0, [sp, #0]
    1f9a:	18e3      	adds	r3, r4, r3
    1f9c:	889d      	ldrh	r5, [r3, #4]
    1f9e:	f7ff fedb 	bl	1d58 <rpc_interface_get_max_command_id>
    1fa2:	4285      	cmp	r5, r0
    1fa4:	d303      	bcc.n	1fae <rpc_interface_ipc_callback+0x1fa>
    1fa6:	9903      	ldr	r1, [sp, #12]
    1fa8:	2016      	movs	r0, #22
    1faa:	f7ff fdb1 	bl	1b10 <panic>
    if (received->header.rpc_command_id >= rpc_interface_get_max_command_id(src, false))
    1fae:	250c      	movs	r5, #12
    1fb0:	9b02      	ldr	r3, [sp, #8]
    1fb2:	2100      	movs	r1, #0
    1fb4:	435d      	muls	r5, r3
    1fb6:	1966      	adds	r6, r4, r5
    1fb8:	88b3      	ldrh	r3, [r6, #4]
    1fba:	9800      	ldr	r0, [sp, #0]
    1fbc:	9304      	str	r3, [sp, #16]
    1fbe:	f7ff fecb 	bl	1d58 <rpc_interface_get_max_command_id>
    1fc2:	9b04      	ldr	r3, [sp, #16]
    1fc4:	4283      	cmp	r3, r0
    1fc6:	d319      	bcc.n	1ffc <rpc_interface_ipc_callback+0x248>
        received->data_received = 0;
    1fc8:	2300      	movs	r3, #0
        (*rpc_core_receive_state) = RPC_RECEIVE_STATE_NONE;
    1fca:	4a3e      	ldr	r2, [pc, #248]	; (20c4 <rpc_interface_ipc_callback+0x310>)
    1fcc:	9907      	ldr	r1, [sp, #28]
        received->data_received = 0;
    1fce:	5363      	strh	r3, [r4, r5]
        (*rpc_core_receive_state) = RPC_RECEIVE_STATE_NONE;
    1fd0:	5453      	strb	r3, [r2, r1]
    1fd2:	e797      	b.n	1f04 <rpc_interface_ipc_callback+0x150>
        memcpy(&(received->header), rpc_response_buffer_received, MESSAGE_HEADER_SIZE);
    1fd4:	2705      	movs	r7, #5
    1fd6:	1ca8      	adds	r0, r5, #2
        received->section_progress = 0;
    1fd8:	8133      	strh	r3, [r6, #8]
        received->current_section = 0;
    1fda:	72b3      	strb	r3, [r6, #10]
        memcpy(&(received->header), rpc_response_buffer_received, MESSAGE_HEADER_SIZE);
    1fdc:	1820      	adds	r0, r4, r0
    1fde:	003a      	movs	r2, r7
    1fe0:	9901      	ldr	r1, [sp, #4]
    1fe2:	f7fe f905 	bl	1f0 <memcpy>
        received->data_received = MESSAGE_HEADER_SIZE;
    1fe6:	532f      	strh	r7, [r5, r4]
        remaining = min((received->header.command_length - MESSAGE_HEADER_SIZE), ((uint16)sizeof(ipc_payload) - MESSAGE_HEADER_SIZE));
    1fe8:	8873      	ldrh	r3, [r6, #2]
    1fea:	3b05      	subs	r3, #5
    1fec:	2b3b      	cmp	r3, #59	; 0x3b
    1fee:	d900      	bls.n	1ff2 <rpc_interface_ipc_callback+0x23e>
    1ff0:	233b      	movs	r3, #59	; 0x3b
    1ff2:	b29f      	uxth	r7, r3
        rpc_response_buffer_received += MESSAGE_HEADER_SIZE;
    1ff4:	9b01      	ldr	r3, [sp, #4]
    1ff6:	3305      	adds	r3, #5
    1ff8:	9301      	str	r3, [sp, #4]
    1ffa:	e7c5      	b.n	1f88 <rpc_interface_ipc_callback+0x1d4>
    return receive_info[rpc_get_core_id(src)];
    1ffc:	9800      	ldr	r0, [sp, #0]
    1ffe:	f7ff fec4 	bl	1d8a <rpc_get_core_id>
    2002:	4b38      	ldr	r3, [pc, #224]	; (20e4 <rpc_interface_ipc_callback+0x330>)
    2004:	0080      	lsls	r0, r0, #2
    2006:	58c3      	ldr	r3, [r0, r3]
    2008:	9304      	str	r3, [sp, #16]
    if (info != NULL)
    200a:	2b00      	cmp	r3, #0
    200c:	d100      	bne.n	2010 <rpc_interface_ipc_callback+0x25c>
    200e:	e079      	b.n	2104 <rpc_interface_ipc_callback+0x350>
        assert(received->current_section < info->num_sections);
    2010:	7ab2      	ldrb	r2, [r6, #10]
    2012:	791b      	ldrb	r3, [r3, #4]
    2014:	429a      	cmp	r2, r3
    2016:	d303      	bcc.n	2020 <rpc_interface_ipc_callback+0x26c>
    2018:	9903      	ldr	r1, [sp, #12]
    201a:	2016      	movs	r0, #22
    201c:	f7ff fd78 	bl	1b10 <panic>
        while (remaining && (received->current_section < info->num_sections))
    2020:	2f00      	cmp	r7, #0
    2022:	d06f      	beq.n	2104 <rpc_interface_ipc_callback+0x350>
    2024:	230c      	movs	r3, #12
    2026:	9a02      	ldr	r2, [sp, #8]
    2028:	9904      	ldr	r1, [sp, #16]
    202a:	4353      	muls	r3, r2
    202c:	4a2b      	ldr	r2, [pc, #172]	; (20dc <rpc_interface_ipc_callback+0x328>)
    202e:	7909      	ldrb	r1, [r1, #4]
    2030:	18d2      	adds	r2, r2, r3
    2032:	7a93      	ldrb	r3, [r2, #10]
    2034:	4299      	cmp	r1, r3
    2036:	d965      	bls.n	2104 <rpc_interface_ipc_callback+0x350>
            section = &(info->sections[received->current_section]);
    2038:	9904      	ldr	r1, [sp, #16]
    203a:	9804      	ldr	r0, [sp, #16]
    203c:	780c      	ldrb	r4, [r1, #0]
    203e:	7849      	ldrb	r1, [r1, #1]
    2040:	8915      	ldrh	r5, [r2, #8]
    2042:	0209      	lsls	r1, r1, #8
    2044:	4321      	orrs	r1, r4
    2046:	7884      	ldrb	r4, [r0, #2]
    2048:	0424      	lsls	r4, r4, #16
    204a:	4321      	orrs	r1, r4
    204c:	78c4      	ldrb	r4, [r0, #3]
    204e:	0624      	lsls	r4, r4, #24
    2050:	430c      	orrs	r4, r1
    2052:	210c      	movs	r1, #12
    2054:	434b      	muls	r3, r1
    2056:	18e4      	adds	r4, r4, r3
            if (section->amount_being_sent == NULL)
    2058:	6860      	ldr	r0, [r4, #4]
    205a:	2800      	cmp	r0, #0
    205c:	d000      	beq.n	2060 <rpc_interface_ipc_callback+0x2ac>
    205e:	e07e      	b.n	215e <rpc_interface_ipc_callback+0x3aa>
                assert(received->section_progress < info->sections[received->current_section].buffer_max);
    2060:	8923      	ldrh	r3, [r4, #8]
    2062:	42ab      	cmp	r3, r5
    2064:	d803      	bhi.n	206e <rpc_interface_ipc_callback+0x2ba>
    2066:	9903      	ldr	r1, [sp, #12]
    2068:	3016      	adds	r0, #22
    206a:	f7ff fd51 	bl	1b10 <panic>
                data_copied = min(remaining, (section->buffer_max - received->section_progress));
    206e:	220c      	movs	r2, #12
    2070:	9b02      	ldr	r3, [sp, #8]
    2072:	8925      	ldrh	r5, [r4, #8]
    2074:	435a      	muls	r2, r3
    2076:	4b19      	ldr	r3, [pc, #100]	; (20dc <rpc_interface_ipc_callback+0x328>)
    2078:	189b      	adds	r3, r3, r2
    207a:	8918      	ldrh	r0, [r3, #8]
    207c:	1a2d      	subs	r5, r5, r0
    207e:	42bd      	cmp	r5, r7
    2080:	dd00      	ble.n	2084 <rpc_interface_ipc_callback+0x2d0>
    2082:	003d      	movs	r5, r7
    2084:	b2ab      	uxth	r3, r5
    2086:	001d      	movs	r5, r3
    2088:	9306      	str	r3, [sp, #24]
                memcpy(section->dst_buffer + received->section_progress, rpc_response_buffer_received, data_copied);
    208a:	6823      	ldr	r3, [r4, #0]
    208c:	002a      	movs	r2, r5
    208e:	1818      	adds	r0, r3, r0
    2090:	9901      	ldr	r1, [sp, #4]
    2092:	f7fe f8ad 	bl	1f0 <memcpy>
                remaining -= data_copied;
    2096:	9b06      	ldr	r3, [sp, #24]
                if (data_copied + received->section_progress == section->buffer_max)
    2098:	9a02      	ldr	r2, [sp, #8]
                remaining -= data_copied;
    209a:	1aff      	subs	r7, r7, r3
                if (data_copied + received->section_progress == section->buffer_max)
    209c:	230c      	movs	r3, #12
    209e:	4353      	muls	r3, r2
    20a0:	4e0e      	ldr	r6, [pc, #56]	; (20dc <rpc_interface_ipc_callback+0x328>)
    20a2:	8921      	ldrh	r1, [r4, #8]
    20a4:	18f3      	adds	r3, r6, r3
    20a6:	891a      	ldrh	r2, [r3, #8]
                remaining -= data_copied;
    20a8:	b2bf      	uxth	r7, r7
                if (data_copied + received->section_progress == section->buffer_max)
    20aa:	1952      	adds	r2, r2, r5
    20ac:	428a      	cmp	r2, r1
    20ae:	d11b      	bne.n	20e8 <rpc_interface_ipc_callback+0x334>
                rpc_response_buffer_received += data_copied;
    20b0:	9a01      	ldr	r2, [sp, #4]
    20b2:	1952      	adds	r2, r2, r5
    20b4:	9201      	str	r2, [sp, #4]
                    received->section_progress = 0;
    20b6:	2200      	movs	r2, #0
    20b8:	811a      	strh	r2, [r3, #8]
                    received->current_section++;
    20ba:	7a9a      	ldrb	r2, [r3, #10]
    20bc:	3201      	adds	r2, #1
    20be:	729a      	strb	r2, [r3, #10]
    20c0:	e7ae      	b.n	2020 <rpc_interface_ipc_callback+0x26c>
    20c2:	46c0      	nop			; (mov r8, r8)
    20c4:	010006d4 	.word	0x010006d4
    20c8:	000006cc 	.word	0x000006cc
    20cc:	010006d6 	.word	0x010006d6
    20d0:	000006ca 	.word	0x000006ca
    20d4:	010006ac 	.word	0x010006ac
    20d8:	01002e10 	.word	0x01002e10
    20dc:	0100146e 	.word	0x0100146e
    20e0:	01001486 	.word	0x01001486
    20e4:	010006cc 	.word	0x010006cc
                assert(remaining == 0);
    20e8:	2f00      	cmp	r7, #0
    20ea:	d003      	beq.n	20f4 <rpc_interface_ipc_callback+0x340>
    20ec:	9903      	ldr	r1, [sp, #12]
    20ee:	2016      	movs	r0, #22
    20f0:	f7ff fd0e 	bl	1b10 <panic>
                received->section_progress += data_copied;
    20f4:	230c      	movs	r3, #12
    20f6:	9a02      	ldr	r2, [sp, #8]
    20f8:	4353      	muls	r3, r2
    20fa:	18f6      	adds	r6, r6, r3
    20fc:	8933      	ldrh	r3, [r6, #8]
    20fe:	9a06      	ldr	r2, [sp, #24]
    2100:	18d3      	adds	r3, r2, r3
    2102:	8133      	strh	r3, [r6, #8]
    if (received->data_received >= received->header.command_length)
    2104:	230c      	movs	r3, #12
    2106:	9a02      	ldr	r2, [sp, #8]
    2108:	4c4f      	ldr	r4, [pc, #316]	; (2248 <rpc_interface_ipc_callback+0x494>)
    210a:	4353      	muls	r3, r2
    210c:	18e2      	adds	r2, r4, r3
    210e:	5b19      	ldrh	r1, [r3, r4]
    2110:	8853      	ldrh	r3, [r2, #2]
    2112:	4299      	cmp	r1, r3
    2114:	d200      	bcs.n	2118 <rpc_interface_ipc_callback+0x364>
    2116:	e6f5      	b.n	1f04 <rpc_interface_ipc_callback+0x150>
        assert(info == NULL || received->current_section == info->num_sections);
    2118:	9b04      	ldr	r3, [sp, #16]
    211a:	2b00      	cmp	r3, #0
    211c:	d007      	beq.n	212e <rpc_interface_ipc_callback+0x37a>
    211e:	7a92      	ldrb	r2, [r2, #10]
    2120:	791b      	ldrb	r3, [r3, #4]
    2122:	429a      	cmp	r2, r3
    2124:	d003      	beq.n	212e <rpc_interface_ipc_callback+0x37a>
    2126:	9903      	ldr	r1, [sp, #12]
    2128:	2016      	movs	r0, #22
    212a:	f7ff fcf1 	bl	1b10 <panic>
        received->data_received = 0;
    212e:	230c      	movs	r3, #12
    2130:	2500      	movs	r5, #0
    2132:	9a02      	ldr	r2, [sp, #8]
        set_receive_info(src, NULL);
    2134:	0029      	movs	r1, r5
        received->data_received = 0;
    2136:	4353      	muls	r3, r2
        set_receive_info(src, NULL);
    2138:	9800      	ldr	r0, [sp, #0]
        received->data_received = 0;
    213a:	52e5      	strh	r5, [r4, r3]
        set_receive_info(src, NULL);
    213c:	f7ff fe30 	bl	1da0 <set_receive_info>
        if (rpc_interface_state[rpc_core_id] != RPC_STATE_AWAITING_RESPONSE)
    2140:	4c42      	ldr	r4, [pc, #264]	; (224c <rpc_interface_ipc_callback+0x498>)
    2142:	9b05      	ldr	r3, [sp, #20]
    2144:	5ce3      	ldrb	r3, [r4, r3]
    2146:	2b01      	cmp	r3, #1
    2148:	d000      	beq.n	214c <rpc_interface_ipc_callback+0x398>
    214a:	e6db      	b.n	1f04 <rpc_interface_ipc_callback+0x150>
        internal_incomming_response_default_blocking_response(src);
    214c:	9800      	ldr	r0, [sp, #0]
    214e:	f004 f9d9 	bl	6504 <internal_incomming_response_default_blocking_response>
        (*rpc_core_receive_state) = RPC_RECEIVE_STATE_NONE;
    2152:	4b3f      	ldr	r3, [pc, #252]	; (2250 <rpc_interface_ipc_callback+0x49c>)
    2154:	9a07      	ldr	r2, [sp, #28]
    2156:	549d      	strb	r5, [r3, r2]
        rpc_interface_state[rpc_core_id] = RPC_STATE_NORMAL;
    2158:	9b05      	ldr	r3, [sp, #20]
    215a:	54e5      	strb	r5, [r4, r3]
    215c:	e6d2      	b.n	1f04 <rpc_interface_ipc_callback+0x150>
                if (received->section_progress < sizeof(uint16))
    215e:	2d01      	cmp	r5, #1
    2160:	d819      	bhi.n	2196 <rpc_interface_ipc_callback+0x3e2>
                    data_copied = min(remaining, (sizeof(uint16) - received->section_progress));
    2162:	2302      	movs	r3, #2
    2164:	1b5d      	subs	r5, r3, r5
    2166:	42bd      	cmp	r5, r7
    2168:	d900      	bls.n	216c <rpc_interface_ipc_callback+0x3b8>
    216a:	003d      	movs	r5, r7
                    memcpy(section->amount_being_sent, rpc_response_buffer_received, data_copied);
    216c:	002a      	movs	r2, r5
    216e:	9901      	ldr	r1, [sp, #4]
    2170:	f7fe f83e 	bl	1f0 <memcpy>
                    received->section_progress += data_copied;
    2174:	220c      	movs	r2, #12
                    rpc_response_buffer_received += data_copied;
    2176:	9b01      	ldr	r3, [sp, #4]
                    data_copied = min(remaining, (sizeof(uint16) - received->section_progress));
    2178:	b2ae      	uxth	r6, r5
                    rpc_response_buffer_received += data_copied;
    217a:	195b      	adds	r3, r3, r5
    217c:	9301      	str	r3, [sp, #4]
                    received->section_progress += data_copied;
    217e:	9b02      	ldr	r3, [sp, #8]
                    remaining -= data_copied;
    2180:	1bbf      	subs	r7, r7, r6
                    received->section_progress += data_copied;
    2182:	435a      	muls	r2, r3
    2184:	4b30      	ldr	r3, [pc, #192]	; (2248 <rpc_interface_ipc_callback+0x494>)
                    remaining -= data_copied;
    2186:	b2bf      	uxth	r7, r7
                    received->section_progress += data_copied;
    2188:	189b      	adds	r3, r3, r2
    218a:	891a      	ldrh	r2, [r3, #8]
    218c:	18b6      	adds	r6, r6, r2
    218e:	b2b6      	uxth	r6, r6
    2190:	811e      	strh	r6, [r3, #8]
                    if (received->section_progress < sizeof(uint16))
    2192:	2e01      	cmp	r6, #1
    2194:	d9b6      	bls.n	2104 <rpc_interface_ipc_callback+0x350>
                if (section->buffer_max > SECTION_BYTES_PROCESSED(received->section_progress))
    2196:	220c      	movs	r2, #12
    2198:	9b02      	ldr	r3, [sp, #8]
    219a:	435a      	muls	r2, r3
    219c:	4b2a      	ldr	r3, [pc, #168]	; (2248 <rpc_interface_ipc_callback+0x494>)
    219e:	189b      	adds	r3, r3, r2
    21a0:	8918      	ldrh	r0, [r3, #8]
    21a2:	8923      	ldrh	r3, [r4, #8]
    21a4:	1e42      	subs	r2, r0, #1
    21a6:	429a      	cmp	r2, r3
    21a8:	dc1f      	bgt.n	21ea <rpc_interface_ipc_callback+0x436>
                    data_copied = min(data_copied, (*section->amount_being_sent - SECTION_BYTES_PROCESSED(received->section_progress)));
    21aa:	6862      	ldr	r2, [r4, #4]
    21ac:	3802      	subs	r0, #2
    21ae:	8815      	ldrh	r5, [r2, #0]
                    data_copied = min(remaining, (section->buffer_max - SECTION_BYTES_PROCESSED(received->section_progress)));
    21b0:	1a1b      	subs	r3, r3, r0
                    data_copied = min(data_copied, (*section->amount_being_sent - SECTION_BYTES_PROCESSED(received->section_progress)));
    21b2:	1a2d      	subs	r5, r5, r0
                    data_copied = min(remaining, (section->buffer_max - SECTION_BYTES_PROCESSED(received->section_progress)));
    21b4:	42bb      	cmp	r3, r7
    21b6:	dd00      	ble.n	21ba <rpc_interface_ipc_callback+0x406>
    21b8:	003b      	movs	r3, r7
                    data_copied = min(data_copied, (*section->amount_being_sent - SECTION_BYTES_PROCESSED(received->section_progress)));
    21ba:	b29b      	uxth	r3, r3
    21bc:	429d      	cmp	r5, r3
    21be:	dd00      	ble.n	21c2 <rpc_interface_ipc_callback+0x40e>
    21c0:	001d      	movs	r5, r3
                    memcpy(section->dst_buffer + SECTION_BYTES_PROCESSED(received->section_progress), rpc_response_buffer_received, data_copied);
    21c2:	6823      	ldr	r3, [r4, #0]
                    data_copied = min(data_copied, (*section->amount_being_sent - SECTION_BYTES_PROCESSED(received->section_progress)));
    21c4:	b2ae      	uxth	r6, r5
                    memcpy(section->dst_buffer + SECTION_BYTES_PROCESSED(received->section_progress), rpc_response_buffer_received, data_copied);
    21c6:	0032      	movs	r2, r6
    21c8:	1818      	adds	r0, r3, r0
    21ca:	9901      	ldr	r1, [sp, #4]
    21cc:	f7fe f810 	bl	1f0 <memcpy>
                    received->section_progress += data_copied;
    21d0:	220c      	movs	r2, #12
                    rpc_response_buffer_received += data_copied;
    21d2:	9b01      	ldr	r3, [sp, #4]
                    remaining -= data_copied;
    21d4:	1bbf      	subs	r7, r7, r6
                    rpc_response_buffer_received += data_copied;
    21d6:	199b      	adds	r3, r3, r6
    21d8:	9301      	str	r3, [sp, #4]
                    received->section_progress += data_copied;
    21da:	9b02      	ldr	r3, [sp, #8]
                    remaining -= data_copied;
    21dc:	b2bf      	uxth	r7, r7
                    received->section_progress += data_copied;
    21de:	435a      	muls	r2, r3
    21e0:	4b19      	ldr	r3, [pc, #100]	; (2248 <rpc_interface_ipc_callback+0x494>)
    21e2:	189b      	adds	r3, r3, r2
    21e4:	891a      	ldrh	r2, [r3, #8]
    21e6:	18b6      	adds	r6, r6, r2
    21e8:	811e      	strh	r6, [r3, #8]
                if (SECTION_BYTES_PROCESSED(received->section_progress) < *section->amount_being_sent)
    21ea:	220c      	movs	r2, #12
    21ec:	9b02      	ldr	r3, [sp, #8]
    21ee:	435a      	muls	r2, r3
    21f0:	4b15      	ldr	r3, [pc, #84]	; (2248 <rpc_interface_ipc_callback+0x494>)
    21f2:	189b      	adds	r3, r3, r2
    21f4:	891a      	ldrh	r2, [r3, #8]
    21f6:	6863      	ldr	r3, [r4, #4]
    21f8:	1e51      	subs	r1, r2, #1
    21fa:	881b      	ldrh	r3, [r3, #0]
    21fc:	4299      	cmp	r1, r3
    21fe:	dc11      	bgt.n	2224 <rpc_interface_ipc_callback+0x470>
                    data_copied = min(remaining, *section->amount_being_sent - SECTION_BYTES_PROCESSED(received->section_progress));
    2200:	1e91      	subs	r1, r2, #2
    2202:	1a5b      	subs	r3, r3, r1
    2204:	42bb      	cmp	r3, r7
    2206:	dd00      	ble.n	220a <rpc_interface_ipc_callback+0x456>
    2208:	003b      	movs	r3, r7
                    received->section_progress += data_copied;
    220a:	250c      	movs	r5, #12
    220c:	9802      	ldr	r0, [sp, #8]
                    data_copied = min(remaining, *section->amount_being_sent - SECTION_BYTES_PROCESSED(received->section_progress));
    220e:	b299      	uxth	r1, r3
                    received->section_progress += data_copied;
    2210:	4345      	muls	r5, r0
    2212:	480d      	ldr	r0, [pc, #52]	; (2248 <rpc_interface_ipc_callback+0x494>)
    2214:	1852      	adds	r2, r2, r1
    2216:	1940      	adds	r0, r0, r5
    2218:	8102      	strh	r2, [r0, #8]
                    rpc_response_buffer_received += data_copied;
    221a:	9a01      	ldr	r2, [sp, #4]
                    remaining -= data_copied;
    221c:	1a7f      	subs	r7, r7, r1
                    rpc_response_buffer_received += data_copied;
    221e:	1853      	adds	r3, r2, r1
    2220:	9301      	str	r3, [sp, #4]
                    remaining -= data_copied;
    2222:	b2bf      	uxth	r7, r7
                if (SECTION_BYTES_PROCESSED(received->section_progress) == *section->amount_being_sent)
    2224:	230c      	movs	r3, #12
    2226:	9a02      	ldr	r2, [sp, #8]
    2228:	6861      	ldr	r1, [r4, #4]
    222a:	4353      	muls	r3, r2
    222c:	4a06      	ldr	r2, [pc, #24]	; (2248 <rpc_interface_ipc_callback+0x494>)
    222e:	8809      	ldrh	r1, [r1, #0]
    2230:	18d3      	adds	r3, r2, r3
    2232:	891a      	ldrh	r2, [r3, #8]
    2234:	3a02      	subs	r2, #2
    2236:	428a      	cmp	r2, r1
    2238:	d000      	beq.n	223c <rpc_interface_ipc_callback+0x488>
    223a:	e6f1      	b.n	2020 <rpc_interface_ipc_callback+0x26c>
    223c:	e73b      	b.n	20b6 <rpc_interface_ipc_callback+0x302>
        assert(false);//should not be here
    223e:	9903      	ldr	r1, [sp, #12]
    2240:	2016      	movs	r0, #22
    2242:	f7ff fc65 	bl	1b10 <panic>
    2246:	e65d      	b.n	1f04 <rpc_interface_ipc_callback+0x150>
    2248:	0100146e 	.word	0x0100146e
    224c:	01001486 	.word	0x01001486
    2250:	010006d4 	.word	0x010006d4

00002254 <rpc_interface_init>:
{
    2254:	b510      	push	{r4, lr}
    2256:	0004      	movs	r4, r0
    rpc_auto_generated_init();
    2258:	f000 ff40 	bl	30dc <rpc_auto_generated_init>
    225c:	4808      	ldr	r0, [pc, #32]	; (2280 <rpc_interface_init+0x2c>)
        memset(&rpc_mailboxes, 0, sizeof(rpc_interface_mailboxes));
    225e:	2224      	movs	r2, #36	; 0x24
    2260:	1e21      	subs	r1, r4, #0
    if (mailboxes == NULL)
    2262:	d10a      	bne.n	227a <rpc_interface_init+0x26>
        memset(&rpc_mailboxes, 0, sizeof(rpc_interface_mailboxes));
    2264:	f7fe f83c 	bl	2e0 <memset>
        irq_callback[i].src_core = CORES_NONE;
    2268:	2203      	movs	r2, #3
    226a:	4b06      	ldr	r3, [pc, #24]	; (2284 <rpc_interface_init+0x30>)
    (void)ipc_register_handler(IPC_ACTION_RPC_COMMAND, rpc_interface_ipc_callback);
    226c:	4906      	ldr	r1, [pc, #24]	; (2288 <rpc_interface_init+0x34>)
        irq_callback[i].src_core = CORES_NONE;
    226e:	701a      	strb	r2, [r3, #0]
    2270:	741a      	strb	r2, [r3, #16]
    (void)ipc_register_handler(IPC_ACTION_RPC_COMMAND, rpc_interface_ipc_callback);
    2272:	2008      	movs	r0, #8
    2274:	f015 f8c4 	bl	17400 <ipc_register_handler>
}
    2278:	bd10      	pop	{r4, pc}
        memcpy(&rpc_mailboxes, mailboxes, sizeof(rpc_interface_mailboxes));
    227a:	f7fd ffb9 	bl	1f0 <memcpy>
    227e:	e7f3      	b.n	2268 <rpc_interface_init+0x14>
    2280:	01002e10 	.word	0x01002e10
    2284:	010006ac 	.word	0x010006ac
    2288:	00001db5 	.word	0x00001db5

0000228c <rpc_interface_poll>:
{
    228c:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    228e:	4676      	mov	r6, lr
            irq_callback[i].src_core = CORES_NONE;
    2290:	2703      	movs	r7, #3
    2292:	4c10      	ldr	r4, [pc, #64]	; (22d4 <rpc_interface_poll+0x48>)
        if (irq_callback[i].src_core != CORES_NONE)
    2294:	7825      	ldrb	r5, [r4, #0]
    2296:	2d03      	cmp	r5, #3
    2298:	d016      	beq.n	22c8 <rpc_interface_poll+0x3c>
            assert(irq_callback[i].is_command);
    229a:	7a23      	ldrb	r3, [r4, #8]
            irq_callback[i].src_core = CORES_NONE;
    229c:	7027      	strb	r7, [r4, #0]
            assert(irq_callback[i].is_command);
    229e:	2b00      	cmp	r3, #0
    22a0:	d103      	bne.n	22aa <rpc_interface_poll+0x1e>
    22a2:	0031      	movs	r1, r6
    22a4:	2016      	movs	r0, #22
    22a6:	f7ff fc33 	bl	1b10 <panic>
    22aa:	6863      	ldr	r3, [r4, #4]
    22ac:	68e2      	ldr	r2, [r4, #12]
    22ae:	b299      	uxth	r1, r3
    22b0:	6863      	ldr	r3, [r4, #4]
                security_incomming_command_table[irq_callback[i].rpc_cmd_id](core, (uint16)irq_callback[i].rpc_cmd_id, irq_callback[i].data);
    22b2:	4809      	ldr	r0, [pc, #36]	; (22d8 <rpc_interface_poll+0x4c>)
    22b4:	009b      	lsls	r3, r3, #2
            if (core == CORES_SECURITY_CORE)
    22b6:	2d00      	cmp	r5, #0
    22b8:	d003      	beq.n	22c2 <rpc_interface_poll+0x36>
                protocol_incomming_command_table[irq_callback[i].rpc_cmd_id](core, (uint16)irq_callback[i].rpc_cmd_id, irq_callback[i].data);
    22ba:	4808      	ldr	r0, [pc, #32]	; (22dc <rpc_interface_poll+0x50>)
            else if (core == CORES_PROTOCOL_CORE)
    22bc:	2d01      	cmp	r5, #1
    22be:	d000      	beq.n	22c2 <rpc_interface_poll+0x36>
                application_incomming_command_table[irq_callback[i].rpc_cmd_id](core, (uint16)irq_callback[i].rpc_cmd_id, irq_callback[i].data);
    22c0:	4807      	ldr	r0, [pc, #28]	; (22e0 <rpc_interface_poll+0x54>)
    22c2:	58c3      	ldr	r3, [r0, r3]
    22c4:	0028      	movs	r0, r5
    22c6:	4798      	blx	r3
    for (int i = 0; i < 2; i++)
    22c8:	4b06      	ldr	r3, [pc, #24]	; (22e4 <rpc_interface_poll+0x58>)
    22ca:	3410      	adds	r4, #16
    22cc:	429c      	cmp	r4, r3
    22ce:	d1e1      	bne.n	2294 <rpc_interface_poll+0x8>
}
    22d0:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    22d2:	46c0      	nop			; (mov r8, r8)
    22d4:	010006ac 	.word	0x010006ac
    22d8:	00022b50 	.word	0x00022b50
    22dc:	00022abc 	.word	0x00022abc
    22e0:	00022ab8 	.word	0x00022ab8
    22e4:	010006cc 	.word	0x010006cc

000022e8 <rpc_thread_main>:
{
    22e8:	b510      	push	{r4, lr}
        if (rpc_mailboxes.incoming_command_recieve)
    22ea:	4b04      	ldr	r3, [pc, #16]	; (22fc <rpc_thread_main+0x14>)
    22ec:	681b      	ldr	r3, [r3, #0]
    22ee:	2b00      	cmp	r3, #0
    22f0:	d000      	beq.n	22f4 <rpc_thread_main+0xc>
            rpc_mailboxes.incoming_command_recieve();
    22f2:	4798      	blx	r3
        rpc_interface_poll();
    22f4:	f7ff ffca 	bl	228c <rpc_interface_poll>
        if (rpc_mailboxes.incoming_command_recieve)
    22f8:	e7f7      	b.n	22ea <rpc_thread_main+0x2>
    22fa:	46c0      	nop			; (mov r8, r8)
    22fc:	01002e10 	.word	0x01002e10

00002300 <rpc_interface_scatter_send>:
                             IPC_PRIORITY_LOWEST, false );            //lint !e826   'Payload' in output_message is an IPC command
}

void rpc_interface_scatter_send(CORES dst_core, uint16 command_id, bool is_command,
                                uint16 segment_count, const rpc_scatter_gather *scattered_data)
{
    2300:	b5f0      	push	{r4, r5, r6, r7, lr}
    2302:	4674      	mov	r4, lr
    2304:	001f      	movs	r7, r3
    uint16 data_offset = 0;
    uint16 partial_copy = 0;
    uint16 total_data_length = 0;
    uint16 i;

    if (rpc_mailboxes.rpc_sent_semaphore_take)
    2306:	4b3a      	ldr	r3, [pc, #232]	; (23f0 <rpc_interface_scatter_send+0xf0>)
{
    2308:	b097      	sub	sp, #92	; 0x5c
    if (rpc_mailboxes.rpc_sent_semaphore_take)
    230a:	699b      	ldr	r3, [r3, #24]
    230c:	9405      	str	r4, [sp, #20]
{
    230e:	9004      	str	r0, [sp, #16]
    2310:	000d      	movs	r5, r1
    2312:	0014      	movs	r4, r2
    if (rpc_mailboxes.rpc_sent_semaphore_take)
    2314:	2b00      	cmp	r3, #0
    2316:	d006      	beq.n	2326 <rpc_interface_scatter_send+0x26>
    {
        if (rpc_mailboxes.rpc_sent_semaphore_take() == false)
    2318:	4798      	blx	r3
    231a:	2800      	cmp	r0, #0
    231c:	d103      	bne.n	2326 <rpc_interface_scatter_send+0x26>
        {
            assert(false);
    231e:	9905      	ldr	r1, [sp, #20]
    2320:	3016      	adds	r0, #22
    2322:	f7ff fbf5 	bl	1b10 <panic>
        }
    }

    if (is_command)
    2326:	2c00      	cmp	r4, #0
    2328:	d005      	beq.n	2336 <rpc_interface_scatter_send+0x36>
    {
        rpc_interface_state[rpc_get_core_id(dst_core)] = RPC_STATE_AWAITING_RESPONSE;
    232a:	9804      	ldr	r0, [sp, #16]
    232c:	f7ff fd2d 	bl	1d8a <rpc_get_core_id>
    2330:	2201      	movs	r2, #1
    2332:	4b30      	ldr	r3, [pc, #192]	; (23f4 <rpc_interface_scatter_send+0xf4>)
    2334:	541a      	strb	r2, [r3, r0]
    2336:	9b1c      	ldr	r3, [sp, #112]	; 0x70
    2338:	00f9      	lsls	r1, r7, #3
    233a:	1d1a      	adds	r2, r3, #4
    uint16 total_data_length = 0;
    233c:	2300      	movs	r3, #0
    233e:	1889      	adds	r1, r1, r2
    }

    for (i = 0; i < segment_count; i++)
    2340:	4291      	cmp	r1, r2
    2342:	d124      	bne.n	238e <rpc_interface_scatter_send+0x8e>
    //The variable length at the end of the structure counts as '1' byte, which is not what we want here
    data_offset += MESSAGE_HEADER_SIZE;

    //The lint exclusions have been added here because this is only called from the auto generated file, so it should not be
    //possible for segment_count to be non-zero at the same time as scattered_data being null, so the check 'i < segment_count is sufficient
    i = 0;
    2344:	2600      	movs	r6, #0
    header->is_command = is_command;
    2346:	aa06      	add	r2, sp, #24
    2348:	7114      	strb	r4, [r2, #4]
    header->rpc_command_id = command_id;
    234a:	8055      	strh	r5, [r2, #2]
    uint16 partial_copy = 0;
    234c:	0034      	movs	r4, r6
    data_offset += MESSAGE_HEADER_SIZE;
    234e:	2505      	movs	r5, #5
    header->command_length = total_data_length + MESSAGE_HEADER_SIZE;
    2350:	3305      	adds	r3, #5
    2352:	8013      	strh	r3, [r2, #0]
    do
    {
        while ((i < segment_count) && (data_offset < sizeof(ipc_payload)))
    2354:	42be      	cmp	r6, r7
    2356:	d201      	bcs.n	235c <rpc_interface_scatter_send+0x5c>
    2358:	2d3f      	cmp	r5, #63	; 0x3f
    235a:	d91d      	bls.n	2398 <rpc_interface_scatter_send+0x98>
    return ipc_send_message( core,
    235c:	2300      	movs	r3, #0
    235e:	aa06      	add	r2, sp, #24
    2360:	9300      	str	r3, [sp, #0]
    2362:	2108      	movs	r1, #8
    2364:	3301      	adds	r3, #1
    2366:	9804      	ldr	r0, [sp, #16]
    2368:	f015 f86c 	bl	17444 <ipc_send_message>
                partial_copy = 0;
                i++;
            }
        }

        while (rpc_interface_send_data(dst_core, data) != IPC_STATUS_OK)
    236c:	2800      	cmp	r0, #0
    236e:	d13a      	bne.n	23e6 <rpc_interface_scatter_send+0xe6>
        {
            rpc_interface_ipc_delay();
        }
        data_offset = 0;
    } while (i < segment_count);
    2370:	42be      	cmp	r6, r7
    2372:	d331      	bcc.n	23d8 <rpc_interface_scatter_send+0xd8>

    if (rpc_mailboxes.rpc_sent_semaphore_give)
    2374:	4b1e      	ldr	r3, [pc, #120]	; (23f0 <rpc_interface_scatter_send+0xf0>)
    2376:	69db      	ldr	r3, [r3, #28]
    2378:	2b00      	cmp	r3, #0
    237a:	d006      	beq.n	238a <rpc_interface_scatter_send+0x8a>
    {
        if (rpc_mailboxes.rpc_sent_semaphore_give() == false)
    237c:	4798      	blx	r3
    237e:	2800      	cmp	r0, #0
    2380:	d103      	bne.n	238a <rpc_interface_scatter_send+0x8a>
        {
            assert(false);
    2382:	9905      	ldr	r1, [sp, #20]
    2384:	3016      	adds	r0, #22
    2386:	f7ff fbc3 	bl	1b10 <panic>
        }
    }
}
    238a:	b017      	add	sp, #92	; 0x5c
    238c:	bdf0      	pop	{r4, r5, r6, r7, pc}
        total_data_length += scattered_data[i].data_length;
    238e:	8810      	ldrh	r0, [r2, #0]
    2390:	3208      	adds	r2, #8
    2392:	181b      	adds	r3, r3, r0
    2394:	b29b      	uxth	r3, r3
    2396:	e7d3      	b.n	2340 <rpc_interface_scatter_send+0x40>
            if (scattered_data[i].data_length - partial_copy > (uint16)sizeof(ipc_payload) - data_offset)   //lint !e413 Likely use of null pointer
    2398:	9a1c      	ldr	r2, [sp, #112]	; 0x70
    239a:	00f3      	lsls	r3, r6, #3
    239c:	18d3      	adds	r3, r2, r3
    239e:	a906      	add	r1, sp, #24
    23a0:	889a      	ldrh	r2, [r3, #4]
    23a2:	1948      	adds	r0, r1, r5
    23a4:	6819      	ldr	r1, [r3, #0]
    23a6:	2340      	movs	r3, #64	; 0x40
    23a8:	9203      	str	r2, [sp, #12]
    23aa:	1909      	adds	r1, r1, r4
    23ac:	1b12      	subs	r2, r2, r4
    23ae:	1b5b      	subs	r3, r3, r5
    23b0:	429a      	cmp	r2, r3
    23b2:	dd07      	ble.n	23c4 <rpc_interface_scatter_send+0xc4>
    23b4:	3440      	adds	r4, #64	; 0x40
                partial_copy += sizeof(ipc_payload) - data_offset;
    23b6:	1b64      	subs	r4, r4, r5
                memcpy(data + data_offset, scattered_data[i].data_location + partial_copy, sizeof(ipc_payload) - data_offset);  //lint !e413 Likely use of null pointer
    23b8:	001a      	movs	r2, r3
    23ba:	f7fd ff19 	bl	1f0 <memcpy>
                partial_copy += sizeof(ipc_payload) - data_offset;
    23be:	b2a4      	uxth	r4, r4
                data_offset = sizeof(ipc_payload);
    23c0:	2540      	movs	r5, #64	; 0x40
    23c2:	e7c7      	b.n	2354 <rpc_interface_scatter_send+0x54>
                memcpy(data + data_offset, scattered_data[i].data_location + partial_copy, scattered_data[i].data_length - partial_copy);  //lint !e413 Likely use of null pointer
    23c4:	f7fd ff14 	bl	1f0 <memcpy>
                data_offset += scattered_data[i].data_length - partial_copy;   //lint !e413 Likely use of null pointer
    23c8:	9b03      	ldr	r3, [sp, #12]
    23ca:	1b2d      	subs	r5, r5, r4
    23cc:	18ed      	adds	r5, r5, r3
                i++;
    23ce:	3601      	adds	r6, #1
                data_offset += scattered_data[i].data_length - partial_copy;   //lint !e413 Likely use of null pointer
    23d0:	b2ad      	uxth	r5, r5
                i++;
    23d2:	b2b6      	uxth	r6, r6
                partial_copy = 0;
    23d4:	2400      	movs	r4, #0
    23d6:	e7bd      	b.n	2354 <rpc_interface_scatter_send+0x54>
        data_offset = 0;
    23d8:	0005      	movs	r5, r0
    23da:	e7bb      	b.n	2354 <rpc_interface_scatter_send+0x54>
        if (rpc_mailboxes.rpc_task_yield != NULL)
    23dc:	4b04      	ldr	r3, [pc, #16]	; (23f0 <rpc_interface_scatter_send+0xf0>)
    23de:	6a1b      	ldr	r3, [r3, #32]
    23e0:	2b00      	cmp	r3, #0
    23e2:	d000      	beq.n	23e6 <rpc_interface_scatter_send+0xe6>
            rpc_mailboxes.rpc_task_yield();
    23e4:	4798      	blx	r3
    while (ipc_check_outbox_free() == false)
    23e6:	f015 f8db 	bl	175a0 <ipc_check_outbox_free>
    23ea:	2800      	cmp	r0, #0
    23ec:	d0f6      	beq.n	23dc <rpc_interface_scatter_send+0xdc>
    23ee:	e7b5      	b.n	235c <rpc_interface_scatter_send+0x5c>
    23f0:	01002e10 	.word	0x01002e10
    23f4:	01001486 	.word	0x01001486

000023f8 <remote_command_get_apps_rpc_version>:
uint32 remote_command_get_apps_rpc_version( CORES core, uint32 *supported_rpc_version )
#endif//BUILD_APPLICATION_UPDATER
#endif
{
    UNUSED(core);
    *supported_rpc_version = SUPPORTED_RPC_VERSION;
    23f8:	2001      	movs	r0, #1
    23fa:	6008      	str	r0, [r1, #0]
    return LOCAL_RPC_VERSION;
}
    23fc:	4770      	bx	lr

000023fe <rpc_init_receive_section>:
    return false;
}

void rpc_init_receive_section(rpc_get_data_section *section, uint8 *dst, uint16 max_size, uint16 *amount_written)
{
    section->dst_buffer = dst;
    23fe:	6001      	str	r1, [r0, #0]
    section->amount_being_sent = amount_written;
    2400:	6043      	str	r3, [r0, #4]
    section->buffer_max = max_size;
    2402:	8102      	strh	r2, [r0, #8]
}
    2404:	4770      	bx	lr
	...

00002408 <rpc_blocking_loop>:
    internal_incomming_command_t3324_t3412_ext_value_changed_ind, 
    internal_incomming_command_rxcalist_response, 
};

static void rpc_blocking_loop( CORES core )
{
    2408:	b570      	push	{r4, r5, r6, lr}
    240a:	0005      	movs	r5, r0
    while (rpc_auto_generated_handles[core].blocking)
    240c:	4c07      	ldr	r4, [pc, #28]	; (242c <rpc_blocking_loop+0x24>)
    240e:	0043      	lsls	r3, r0, #1
    2410:	18e4      	adds	r4, r4, r3
    2412:	3401      	adds	r4, #1
    {
        if (rpc_mailboxes.outgoing_command_recieve)
    2414:	4b06      	ldr	r3, [pc, #24]	; (2430 <rpc_blocking_loop+0x28>)
    2416:	689b      	ldr	r3, [r3, #8]
    while (rpc_auto_generated_handles[core].blocking)
    2418:	7822      	ldrb	r2, [r4, #0]
    241a:	2a00      	cmp	r2, #0
    241c:	d100      	bne.n	2420 <rpc_blocking_loop+0x18>
        {
            rpc_mailboxes.outgoing_command_recieve(core);
        }
    }
}
    241e:	bd70      	pop	{r4, r5, r6, pc}
        if (rpc_mailboxes.outgoing_command_recieve)
    2420:	2b00      	cmp	r3, #0
    2422:	d0f9      	beq.n	2418 <rpc_blocking_loop+0x10>
            rpc_mailboxes.outgoing_command_recieve(core);
    2424:	0028      	movs	r0, r5
    2426:	4798      	blx	r3
    2428:	e7f4      	b.n	2414 <rpc_blocking_loop+0xc>
    242a:	46c0      	nop			; (mov r8, r8)
    242c:	01002e34 	.word	0x01002e34
    2430:	01002e10 	.word	0x01002e10

00002434 <rpc_command_release>:
    return RPC_ERR_OK;
}

static RPC_ERR rpc_command_release(CORES core)
{
    rpc_auto_generated_handles[core].free = true;
    2434:	2101      	movs	r1, #1
{
    2436:	b510      	push	{r4, lr}
    rpc_auto_generated_handles[core].free = true;
    2438:	4b06      	ldr	r3, [pc, #24]	; (2454 <rpc_command_release+0x20>)
    243a:	0042      	lsls	r2, r0, #1
    243c:	54d1      	strb	r1, [r2, r3]
    if (rpc_mailboxes.rpc_mailbox_semaphore_give)
    243e:	4b06      	ldr	r3, [pc, #24]	; (2458 <rpc_command_release+0x24>)
    2440:	695b      	ldr	r3, [r3, #20]
    2442:	2b00      	cmp	r3, #0
    2444:	d003      	beq.n	244e <rpc_command_release+0x1a>
    {
        if (rpc_mailboxes.rpc_mailbox_semaphore_give(core) == false)
    2446:	4798      	blx	r3
        {
            return RPC_ERR_GIVE_SEMAPHORE_FAIL;
    2448:	2302      	movs	r3, #2
        if (rpc_mailboxes.rpc_mailbox_semaphore_give(core) == false)
    244a:	2800      	cmp	r0, #0
    244c:	d000      	beq.n	2450 <rpc_command_release+0x1c>
        }
    }
    return RPC_ERR_OK;
    244e:	2300      	movs	r3, #0
}
    2450:	0018      	movs	r0, r3
    2452:	bd10      	pop	{r4, pc}
    2454:	01002e34 	.word	0x01002e34
    2458:	01002e10 	.word	0x01002e10

0000245c <rpc_command_claim>:
{
    245c:	b510      	push	{r4, lr}
    if (rpc_mailboxes.rpc_mailbox_semaphore_take)
    245e:	4b0f      	ldr	r3, [pc, #60]	; (249c <rpc_command_claim+0x40>)
{
    2460:	0004      	movs	r4, r0
    if (rpc_mailboxes.rpc_mailbox_semaphore_take)
    2462:	691b      	ldr	r3, [r3, #16]
    2464:	2b00      	cmp	r3, #0
    2466:	d10a      	bne.n	247e <rpc_command_claim+0x22>
    non_os_enter_critical();
    2468:	f015 fea4 	bl	181b4 <non_os_enter_critical>
    if (rpc_auto_generated_handles[core].free != true)
    246c:	4b0c      	ldr	r3, [pc, #48]	; (24a0 <rpc_command_claim+0x44>)
    246e:	0060      	lsls	r0, r4, #1
    2470:	5cc2      	ldrb	r2, [r0, r3]
    2472:	2a00      	cmp	r2, #0
    2474:	d108      	bne.n	2488 <rpc_command_claim+0x2c>
        non_os_exit_critical();
    2476:	f015 feb1 	bl	181dc <non_os_exit_critical>
        return RPC_ERR_BUSY;
    247a:	2003      	movs	r0, #3
    247c:	e003      	b.n	2486 <rpc_command_claim+0x2a>
        if (rpc_mailboxes.rpc_mailbox_semaphore_take(core) == false)
    247e:	4798      	blx	r3
    2480:	2800      	cmp	r0, #0
    2482:	d1f1      	bne.n	2468 <rpc_command_claim+0xc>
            return RPC_ERR_TAKE_SEMAPHORE_FAIL;
    2484:	3001      	adds	r0, #1
}
    2486:	bd10      	pop	{r4, pc}
    rpc_auto_generated_handles[core].free = false;
    2488:	2400      	movs	r4, #0
    248a:	54c4      	strb	r4, [r0, r3]
    rpc_auto_generated_handles[core].blocking = true;
    248c:	1818      	adds	r0, r3, r0
    248e:	2301      	movs	r3, #1
    2490:	7043      	strb	r3, [r0, #1]
    non_os_exit_critical();
    2492:	f015 fea3 	bl	181dc <non_os_exit_critical>
    return RPC_ERR_OK;
    2496:	0020      	movs	r0, r4
    2498:	e7f5      	b.n	2486 <rpc_command_claim+0x2a>
    249a:	46c0      	nop			; (mov r8, r8)
    249c:	01002e10 	.word	0x01002e10
    24a0:	01002e34 	.word	0x01002e34

000024a4 <internal_incomming_command_get_apps_rpc_version>:
    return rpc_command_release(CORES_PROTOCOL_CORE);
}


static void internal_incomming_command_get_apps_rpc_version(CORES core, uint16 commandID, uint8 *data)
{
    24a4:	b570      	push	{r4, r5, r6, lr}
    24a6:	b088      	sub	sp, #32
    UNUSED(data);
    rpc_scatter_gather data_to_send[2];
    uint32 local_rpc_version;
    uint32 supported_rpc_version;
    local_rpc_version = remote_command_get_apps_rpc_version(core, &supported_rpc_version);
    24a8:	ad03      	add	r5, sp, #12
{
    24aa:	000e      	movs	r6, r1
    local_rpc_version = remote_command_get_apps_rpc_version(core, &supported_rpc_version);
    24ac:	0029      	movs	r1, r5
{
    24ae:	0004      	movs	r4, r0
    local_rpc_version = remote_command_get_apps_rpc_version(core, &supported_rpc_version);
    24b0:	f7ff ffa2 	bl	23f8 <remote_command_get_apps_rpc_version>
    data_to_send[0].data_location = (uint8 *)&local_rpc_version;
    24b4:	aa02      	add	r2, sp, #8
    24b6:	9204      	str	r2, [sp, #16]
    data_to_send[0].data_length = sizeof(local_rpc_version);
    24b8:	2204      	movs	r2, #4
    data_to_send[0].data_location = (uint8 *)&local_rpc_version;
    24ba:	ab04      	add	r3, sp, #16
    data_to_send[0].data_length = sizeof(local_rpc_version);
    24bc:	809a      	strh	r2, [r3, #4]
    data_to_send[1].data_location = (uint8 *)&supported_rpc_version;
    data_to_send[1].data_length = sizeof(supported_rpc_version);
    24be:	819a      	strh	r2, [r3, #12]
    local_rpc_version = remote_command_get_apps_rpc_version(core, &supported_rpc_version);
    24c0:	9002      	str	r0, [sp, #8]
    rpc_interface_scatter_send(core, commandID, false, 2, data_to_send);
    24c2:	9300      	str	r3, [sp, #0]
    24c4:	2200      	movs	r2, #0
    24c6:	2302      	movs	r3, #2
    24c8:	0031      	movs	r1, r6
    24ca:	0020      	movs	r0, r4
    data_to_send[1].data_location = (uint8 *)&supported_rpc_version;
    24cc:	9506      	str	r5, [sp, #24]
    rpc_interface_scatter_send(core, commandID, false, 2, data_to_send);
    24ce:	f7ff ff17 	bl	2300 <rpc_interface_scatter_send>
}
    24d2:	b008      	add	sp, #32
    24d4:	bd70      	pop	{r4, r5, r6, pc}

000024d6 <internal_incomming_command_get_plmn_results_ind>:

static void internal_incomming_command_get_plmn_results_ind(CORES core, uint16 commandID, uint8 *data)
{
    24d6:	b5f0      	push	{r4, r5, r6, r7, lr}
    uint16 buffer_pos = 0;
    24d8:	250e      	movs	r5, #14
    24da:	2400      	movs	r4, #0
{
    24dc:	b089      	sub	sp, #36	; 0x24
    uint16 buffer_pos = 0;
    24de:	ab04      	add	r3, sp, #16
    24e0:	18ed      	adds	r5, r5, r3
{
    24e2:	0007      	movs	r7, r0
    24e4:	9105      	str	r1, [sp, #20]
    uint16 available_plmn_length;
    uint8 *available_plmn;
    uint8 result;
    available_plmn_length = (uint16)rpc_get_int16(data, &buffer_pos);
    24e6:	0010      	movs	r0, r2
    24e8:	0029      	movs	r1, r5
{
    24ea:	0016      	movs	r6, r2
    uint16 buffer_pos = 0;
    24ec:	802c      	strh	r4, [r5, #0]
    available_plmn_length = (uint16)rpc_get_int16(data, &buffer_pos);
    24ee:	f004 f857 	bl	65a0 <rpc_get_int16>
    24f2:	b283      	uxth	r3, r0
    available_plmn = (uint8 *)rpc_get_buffer(data, &buffer_pos, available_plmn_length);
    24f4:	001a      	movs	r2, r3
    24f6:	0029      	movs	r1, r5
    24f8:	0030      	movs	r0, r6
    available_plmn_length = (uint16)rpc_get_int16(data, &buffer_pos);
    24fa:	9303      	str	r3, [sp, #12]
    available_plmn = (uint8 *)rpc_get_buffer(data, &buffer_pos, available_plmn_length);
    24fc:	f004 f81c 	bl	6538 <rpc_get_buffer>
    result = (uint8)rpc_get_int8(data, &buffer_pos);
    2500:	0029      	movs	r1, r5
    available_plmn = (uint8 *)rpc_get_buffer(data, &buffer_pos, available_plmn_length);
    2502:	9004      	str	r0, [sp, #16]
    result = (uint8)rpc_get_int8(data, &buffer_pos);
    2504:	0030      	movs	r0, r6
    2506:	f004 f85a 	bl	65be <rpc_get_int8>
    remote_command_get_plmn_results_ind(core, available_plmn_length, available_plmn, result);
    250a:	9a04      	ldr	r2, [sp, #16]
    250c:	b2c3      	uxtb	r3, r0
    250e:	9903      	ldr	r1, [sp, #12]
    2510:	0038      	movs	r0, r7
    2512:	f01a f9db 	bl	1c8cc <remote_command_get_plmn_results_ind>
    rpc_interface_scatter_send(core, commandID, false, 0, NULL);
    2516:	9400      	str	r4, [sp, #0]
    2518:	0023      	movs	r3, r4
    251a:	0022      	movs	r2, r4
    251c:	9905      	ldr	r1, [sp, #20]
    251e:	0038      	movs	r0, r7
    2520:	f7ff feee 	bl	2300 <rpc_interface_scatter_send>
}
    2524:	b009      	add	sp, #36	; 0x24
    2526:	bdf0      	pop	{r4, r5, r6, r7, pc}

00002528 <remote_command_app_flash_erase_response>:
{
    2528:	b510      	push	{r4, lr}
    assert(false);
    252a:	4671      	mov	r1, lr
    252c:	2016      	movs	r0, #22
    252e:	f7ff faef 	bl	1b10 <panic>
}
    2532:	bd10      	pop	{r4, pc}

00002534 <internal_incomming_command_attach_status_set_result_ind>:

static void internal_incomming_command_attach_status_set_result_ind(CORES core, uint16 commandID, uint8 *data)
{
    2534:	b57f      	push	{r0, r1, r2, r3, r4, r5, r6, lr}
    2536:	000e      	movs	r6, r1
    uint16 buffer_pos = 0;
    2538:	210e      	movs	r1, #14
    253a:	2400      	movs	r4, #0
{
    253c:	0005      	movs	r5, r0
    uint16 buffer_pos = 0;
    253e:	4469      	add	r1, sp
    uint8 attach_status_set_result;
    attach_status_set_result = (uint8)rpc_get_int8(data, &buffer_pos);
    2540:	0010      	movs	r0, r2
    uint16 buffer_pos = 0;
    2542:	800c      	strh	r4, [r1, #0]
    attach_status_set_result = (uint8)rpc_get_int8(data, &buffer_pos);
    2544:	f004 f83b 	bl	65be <rpc_get_int8>
    remote_command_attach_status_set_result_ind(core, attach_status_set_result);
    2548:	b2c1      	uxtb	r1, r0
    254a:	0028      	movs	r0, r5
    254c:	f019 fda4 	bl	1c098 <remote_command_attach_status_set_result_ind>
    rpc_interface_scatter_send(core, commandID, false, 0, NULL);
    2550:	0031      	movs	r1, r6
    2552:	0028      	movs	r0, r5
    2554:	9400      	str	r4, [sp, #0]
    2556:	0023      	movs	r3, r4
    2558:	0022      	movs	r2, r4
    255a:	f7ff fed1 	bl	2300 <rpc_interface_scatter_send>
}
    255e:	bd7f      	pop	{r0, r1, r2, r3, r4, r5, r6, pc}

00002560 <internal_incomming_command_plmn_select_result_ind>:

static void internal_incomming_command_plmn_select_result_ind(CORES core, uint16 commandID, uint8 *data)
{
    2560:	b57f      	push	{r0, r1, r2, r3, r4, r5, r6, lr}
    2562:	000e      	movs	r6, r1
    uint16 buffer_pos = 0;
    2564:	210e      	movs	r1, #14
    2566:	2400      	movs	r4, #0
{
    2568:	0005      	movs	r5, r0
    uint16 buffer_pos = 0;
    256a:	4469      	add	r1, sp
    uint8 plmn_select_result;
    plmn_select_result = (uint8)rpc_get_int8(data, &buffer_pos);
    256c:	0010      	movs	r0, r2
    uint16 buffer_pos = 0;
    256e:	800c      	strh	r4, [r1, #0]
    plmn_select_result = (uint8)rpc_get_int8(data, &buffer_pos);
    2570:	f004 f825 	bl	65be <rpc_get_int8>
    remote_command_plmn_select_result_ind(core, plmn_select_result);
    2574:	b2c1      	uxtb	r1, r0
    2576:	0028      	movs	r0, r5
    2578:	f019 fd98 	bl	1c0ac <remote_command_plmn_select_result_ind>
    rpc_interface_scatter_send(core, commandID, false, 0, NULL);
    257c:	0031      	movs	r1, r6
    257e:	0028      	movs	r0, r5
    2580:	9400      	str	r4, [sp, #0]
    2582:	0023      	movs	r3, r4
    2584:	0022      	movs	r2, r4
    2586:	f7ff febb 	bl	2300 <rpc_interface_scatter_send>
}
    258a:	bd7f      	pop	{r0, r1, r2, r3, r4, r5, r6, pc}

0000258c <internal_incomming_command_registration_status_ind>:

static void internal_incomming_command_registration_status_ind(CORES core, uint16 commandID, uint8 *data)
{
    258c:	b57f      	push	{r0, r1, r2, r3, r4, r5, r6, lr}
    258e:	000e      	movs	r6, r1
    uint16 buffer_pos = 0;
    2590:	210e      	movs	r1, #14
    2592:	2400      	movs	r4, #0
{
    2594:	0005      	movs	r5, r0
    uint16 buffer_pos = 0;
    2596:	4469      	add	r1, sp
    uint8 registration_status;
    registration_status = (uint8)rpc_get_int8(data, &buffer_pos);
    2598:	0010      	movs	r0, r2
    uint16 buffer_pos = 0;
    259a:	800c      	strh	r4, [r1, #0]
    registration_status = (uint8)rpc_get_int8(data, &buffer_pos);
    259c:	f004 f80f 	bl	65be <rpc_get_int8>
    remote_command_registration_status_ind(core, registration_status);
    25a0:	b2c1      	uxtb	r1, r0
    25a2:	0028      	movs	r0, r5
    25a4:	f019 ff8c 	bl	1c4c0 <remote_command_registration_status_ind>
    rpc_interface_scatter_send(core, commandID, false, 0, NULL);
    25a8:	0031      	movs	r1, r6
    25aa:	0028      	movs	r0, r5
    25ac:	9400      	str	r4, [sp, #0]
    25ae:	0023      	movs	r3, r4
    25b0:	0022      	movs	r2, r4
    25b2:	f7ff fea5 	bl	2300 <rpc_interface_scatter_send>
}
    25b6:	bd7f      	pop	{r0, r1, r2, r3, r4, r5, r6, pc}

000025b8 <internal_incomming_command_connection_status_ind>:

static void internal_incomming_command_connection_status_ind(CORES core, uint16 commandID, uint8 *data)
{
    25b8:	b57f      	push	{r0, r1, r2, r3, r4, r5, r6, lr}
    25ba:	000e      	movs	r6, r1
    uint16 buffer_pos = 0;
    25bc:	210e      	movs	r1, #14
    25be:	2400      	movs	r4, #0
{
    25c0:	0005      	movs	r5, r0
    uint16 buffer_pos = 0;
    25c2:	4469      	add	r1, sp
    uint8 connection_status;
    connection_status = (uint8)rpc_get_int8(data, &buffer_pos);
    25c4:	0010      	movs	r0, r2
    uint16 buffer_pos = 0;
    25c6:	800c      	strh	r4, [r1, #0]
    connection_status = (uint8)rpc_get_int8(data, &buffer_pos);
    25c8:	f003 fff9 	bl	65be <rpc_get_int8>
    remote_command_connection_status_ind(core, connection_status);
    25cc:	b2c1      	uxtb	r1, r0
    25ce:	0028      	movs	r0, r5
    25d0:	f019 ff8c 	bl	1c4ec <remote_command_connection_status_ind>
    rpc_interface_scatter_send(core, commandID, false, 0, NULL);
    25d4:	0031      	movs	r1, r6
    25d6:	0028      	movs	r0, r5
    25d8:	9400      	str	r4, [sp, #0]
    25da:	0023      	movs	r3, r4
    25dc:	0022      	movs	r2, r4
    25de:	f7ff fe8f 	bl	2300 <rpc_interface_scatter_send>
}
    25e2:	bd7f      	pop	{r0, r1, r2, r3, r4, r5, r6, pc}

000025e4 <internal_incomming_command_ip_address_changed>:
    remote_command_non_ip_data_sent(core, data_seq, status);
    rpc_interface_scatter_send(core, commandID, false, 0, NULL);
}

static void internal_incomming_command_ip_address_changed(CORES core, uint16 commandID, uint8 *data)
{
    25e4:	b57f      	push	{r0, r1, r2, r3, r4, r5, r6, lr}
    25e6:	000e      	movs	r6, r1
    uint16 buffer_pos = 0;
    25e8:	210e      	movs	r1, #14
    25ea:	2400      	movs	r4, #0
{
    25ec:	0005      	movs	r5, r0
    uint16 buffer_pos = 0;
    25ee:	4469      	add	r1, sp
    uint8 cid;
    cid = (uint8)rpc_get_int8(data, &buffer_pos);
    25f0:	0010      	movs	r0, r2
    uint16 buffer_pos = 0;
    25f2:	800c      	strh	r4, [r1, #0]
    cid = (uint8)rpc_get_int8(data, &buffer_pos);
    25f4:	f003 ffe3 	bl	65be <rpc_get_int8>
    remote_command_ip_address_changed(core, cid);
    25f8:	b2c1      	uxtb	r1, r0
    25fa:	0028      	movs	r0, r5
    25fc:	f01a fd98 	bl	1d130 <remote_command_ip_address_changed>
    rpc_interface_scatter_send(core, commandID, false, 0, NULL);
    2600:	0031      	movs	r1, r6
    2602:	0028      	movs	r0, r5
    2604:	9400      	str	r4, [sp, #0]
    2606:	0023      	movs	r3, r4
    2608:	0022      	movs	r2, r4
    260a:	f7ff fe79 	bl	2300 <rpc_interface_scatter_send>
}
    260e:	bd7f      	pop	{r0, r1, r2, r3, r4, r5, r6, pc}

00002610 <internal_incomming_command_cfun_result_ind>:
    remote_command_ping_ind(core, remote_addr_length, remote_addr, result, ttl, rtt);
    rpc_interface_scatter_send(core, commandID, false, 0, NULL);
}

static void internal_incomming_command_cfun_result_ind(CORES core, uint16 commandID, uint8 *data)
{
    2610:	b57f      	push	{r0, r1, r2, r3, r4, r5, r6, lr}
    2612:	000e      	movs	r6, r1
    uint16 buffer_pos = 0;
    2614:	210e      	movs	r1, #14
    2616:	2400      	movs	r4, #0
{
    2618:	0005      	movs	r5, r0
    uint16 buffer_pos = 0;
    261a:	4469      	add	r1, sp
    uint8 cfun_result;
    cfun_result = (uint8)rpc_get_int8(data, &buffer_pos);
    261c:	0010      	movs	r0, r2
    uint16 buffer_pos = 0;
    261e:	800c      	strh	r4, [r1, #0]
    cfun_result = (uint8)rpc_get_int8(data, &buffer_pos);
    2620:	f003 ffcd 	bl	65be <rpc_get_int8>
    remote_command_cfun_result_ind(core, cfun_result);
    2624:	b2c1      	uxtb	r1, r0
    2626:	0028      	movs	r0, r5
    2628:	f019 fe10 	bl	1c24c <remote_command_cfun_result_ind>
    rpc_interface_scatter_send(core, commandID, false, 0, NULL);
    262c:	0031      	movs	r1, r6
    262e:	0028      	movs	r0, r5
    2630:	9400      	str	r4, [sp, #0]
    2632:	0023      	movs	r3, r4
    2634:	0022      	movs	r2, r4
    2636:	f7ff fe63 	bl	2300 <rpc_interface_scatter_send>
}
    263a:	bd7f      	pop	{r0, r1, r2, r3, r4, r5, r6, pc}

0000263c <internal_incomming_command_update_package_parse_cnf>:
    remote_command_rf_calibration_rtc_ind(core, rtc_freq_calibrated_by_rf);
    rpc_interface_scatter_send(core, commandID, false, 0, NULL);
}

static void internal_incomming_command_update_package_parse_cnf(CORES core, uint16 commandID, uint8 *data)
{
    263c:	b57f      	push	{r0, r1, r2, r3, r4, r5, r6, lr}
    263e:	000e      	movs	r6, r1
    uint16 buffer_pos = 0;
    2640:	210e      	movs	r1, #14
    2642:	2400      	movs	r4, #0
{
    2644:	0005      	movs	r5, r0
    uint16 buffer_pos = 0;
    2646:	4469      	add	r1, sp
    uint8 status;
    status = (uint8)rpc_get_int8(data, &buffer_pos);
    2648:	0010      	movs	r0, r2
    uint16 buffer_pos = 0;
    264a:	800c      	strh	r4, [r1, #0]
    status = (uint8)rpc_get_int8(data, &buffer_pos);
    264c:	f003 ffb7 	bl	65be <rpc_get_int8>
    remote_command_update_package_parse_cnf(core, status);
    2650:	b2c1      	uxtb	r1, r0
    2652:	0028      	movs	r0, r5
    2654:	f005 f928 	bl	78a8 <remote_command_update_package_parse_cnf>
    rpc_interface_scatter_send(core, commandID, false, 0, NULL);
    2658:	0031      	movs	r1, r6
    265a:	0028      	movs	r0, r5
    265c:	9400      	str	r4, [sp, #0]
    265e:	0023      	movs	r3, r4
    2660:	0022      	movs	r2, r4
    2662:	f7ff fe4d 	bl	2300 <rpc_interface_scatter_send>
}
    2666:	bd7f      	pop	{r0, r1, r2, r3, r4, r5, r6, pc}

00002668 <internal_incomming_command_update_package_process_cnf>:

static void internal_incomming_command_update_package_process_cnf(CORES core, uint16 commandID, uint8 *data)
{
    2668:	b57f      	push	{r0, r1, r2, r3, r4, r5, r6, lr}
    266a:	000e      	movs	r6, r1
    uint16 buffer_pos = 0;
    266c:	210e      	movs	r1, #14
    266e:	2400      	movs	r4, #0
{
    2670:	0005      	movs	r5, r0
    uint16 buffer_pos = 0;
    2672:	4469      	add	r1, sp
    uint8 status;
    status = (uint8)rpc_get_int8(data, &buffer_pos);
    2674:	0010      	movs	r0, r2
    uint16 buffer_pos = 0;
    2676:	800c      	strh	r4, [r1, #0]
    status = (uint8)rpc_get_int8(data, &buffer_pos);
    2678:	f003 ffa1 	bl	65be <rpc_get_int8>
    remote_command_update_package_process_cnf(core, status);
    267c:	b2c1      	uxtb	r1, r0
    267e:	0028      	movs	r0, r5
    2680:	f005 f91c 	bl	78bc <remote_command_update_package_process_cnf>
    rpc_interface_scatter_send(core, commandID, false, 0, NULL);
    2684:	0031      	movs	r1, r6
    2686:	0028      	movs	r0, r5
    2688:	9400      	str	r4, [sp, #0]
    268a:	0023      	movs	r3, r4
    268c:	0022      	movs	r2, r4
    268e:	f7ff fe37 	bl	2300 <rpc_interface_scatter_send>
}
    2692:	bd7f      	pop	{r0, r1, r2, r3, r4, r5, r6, pc}

00002694 <internal_incomming_command_update_package_flash_write_done>:
    remote_command_update_package_flash_erase_done(core, result);
    rpc_interface_scatter_send(core, commandID, false, 0, NULL);
}

static void internal_incomming_command_update_package_flash_write_done(CORES core, uint16 commandID, uint8 *data)
{
    2694:	b57f      	push	{r0, r1, r2, r3, r4, r5, r6, lr}
    2696:	000e      	movs	r6, r1
    uint16 buffer_pos = 0;
    2698:	210e      	movs	r1, #14
    269a:	2400      	movs	r4, #0
{
    269c:	0005      	movs	r5, r0
    uint16 buffer_pos = 0;
    269e:	4469      	add	r1, sp
    uint8 result;
    result = (uint8)rpc_get_int8(data, &buffer_pos);
    26a0:	0010      	movs	r0, r2
    uint16 buffer_pos = 0;
    26a2:	800c      	strh	r4, [r1, #0]
    result = (uint8)rpc_get_int8(data, &buffer_pos);
    26a4:	f003 ff8b 	bl	65be <rpc_get_int8>
    remote_command_update_package_flash_write_done(core, result);
    26a8:	b2c1      	uxtb	r1, r0
    26aa:	0028      	movs	r0, r5
    26ac:	f005 f928 	bl	7900 <remote_command_update_package_flash_write_done>
    rpc_interface_scatter_send(core, commandID, false, 0, NULL);
    26b0:	0031      	movs	r1, r6
    26b2:	0028      	movs	r0, r5
    26b4:	9400      	str	r4, [sp, #0]
    26b6:	0023      	movs	r3, r4
    26b8:	0022      	movs	r2, r4
    26ba:	f7ff fe21 	bl	2300 <rpc_interface_scatter_send>
}
    26be:	bd7f      	pop	{r0, r1, r2, r3, r4, r5, r6, pc}

000026c0 <internal_incomming_command_psm_status_ind>:
    remote_command_kv_apps_cache_flushed(core, kv_cache_start, kv_processed_end, kv_return_code);
    rpc_interface_scatter_send(core, commandID, false, 0, NULL);
}

static void internal_incomming_command_psm_status_ind(CORES core, uint16 commandID, uint8 *data)
{
    26c0:	b57f      	push	{r0, r1, r2, r3, r4, r5, r6, lr}
    26c2:	000e      	movs	r6, r1
    uint16 buffer_pos = 0;
    26c4:	210e      	movs	r1, #14
    26c6:	2400      	movs	r4, #0
{
    26c8:	0005      	movs	r5, r0
    uint16 buffer_pos = 0;
    26ca:	4469      	add	r1, sp
    uint8 psm_status;
    psm_status = (uint8)rpc_get_int8(data, &buffer_pos);
    26cc:	0010      	movs	r0, r2
    uint16 buffer_pos = 0;
    26ce:	800c      	strh	r4, [r1, #0]
    psm_status = (uint8)rpc_get_int8(data, &buffer_pos);
    26d0:	f003 ff75 	bl	65be <rpc_get_int8>
    remote_command_psm_status_ind(core, psm_status);
    26d4:	b2c1      	uxtb	r1, r0
    26d6:	0028      	movs	r0, r5
    26d8:	f01a f8b6 	bl	1c848 <remote_command_psm_status_ind>
    rpc_interface_scatter_send(core, commandID, false, 0, NULL);
    26dc:	0031      	movs	r1, r6
    26de:	0028      	movs	r0, r5
    26e0:	9400      	str	r4, [sp, #0]
    26e2:	0023      	movs	r3, r4
    26e4:	0022      	movs	r2, r4
    26e6:	f7ff fe0b 	bl	2300 <rpc_interface_scatter_send>
}
    26ea:	bd7f      	pop	{r0, r1, r2, r3, r4, r5, r6, pc}

000026ec <internal_incomming_command_radio_command_abort_ind>:
    remote_command_sms_cmt_pdu_ind(core, alpha, pdu_length, pdu);
    rpc_interface_scatter_send(core, commandID, false, 0, NULL);
}

static void internal_incomming_command_radio_command_abort_ind(CORES core, uint16 commandID, uint8 *data)
{
    26ec:	b57f      	push	{r0, r1, r2, r3, r4, r5, r6, lr}
    26ee:	000e      	movs	r6, r1
    uint16 buffer_pos = 0;
    26f0:	210e      	movs	r1, #14
    26f2:	2400      	movs	r4, #0
{
    26f4:	0005      	movs	r5, r0
    uint16 buffer_pos = 0;
    26f6:	4469      	add	r1, sp
    uint8 result;
    result = (uint8)rpc_get_int8(data, &buffer_pos);
    26f8:	0010      	movs	r0, r2
    uint16 buffer_pos = 0;
    26fa:	800c      	strh	r4, [r1, #0]
    result = (uint8)rpc_get_int8(data, &buffer_pos);
    26fc:	f003 ff5f 	bl	65be <rpc_get_int8>
    remote_command_radio_command_abort_ind(core, result);
    2700:	b2c1      	uxtb	r1, r0
    2702:	0028      	movs	r0, r5
    2704:	f01a f8fc 	bl	1c900 <remote_command_radio_command_abort_ind>
    rpc_interface_scatter_send(core, commandID, false, 0, NULL);
    2708:	0031      	movs	r1, r6
    270a:	0028      	movs	r0, r5
    270c:	9400      	str	r4, [sp, #0]
    270e:	0023      	movs	r3, r4
    2710:	0022      	movs	r2, r4
    2712:	f7ff fdf5 	bl	2300 <rpc_interface_scatter_send>
}
    2716:	bd7f      	pop	{r0, r1, r2, r3, r4, r5, r6, pc}

00002718 <internal_incomming_command_flowcontrol_status>:
    remote_command_ip_info(core, cid, current_ip_type, requested_ip_type, failure_cause);
    rpc_interface_scatter_send(core, commandID, false, 0, NULL);
}

static void internal_incomming_command_flowcontrol_status(CORES core, uint16 commandID, uint8 *data)
{
    2718:	b57f      	push	{r0, r1, r2, r3, r4, r5, r6, lr}
    271a:	000e      	movs	r6, r1
    uint16 buffer_pos = 0;
    271c:	210e      	movs	r1, #14
    271e:	2400      	movs	r4, #0
{
    2720:	0005      	movs	r5, r0
    uint16 buffer_pos = 0;
    2722:	4469      	add	r1, sp
    uint8 status;
    status = (uint8)rpc_get_int8(data, &buffer_pos);
    2724:	0010      	movs	r0, r2
    uint16 buffer_pos = 0;
    2726:	800c      	strh	r4, [r1, #0]
    status = (uint8)rpc_get_int8(data, &buffer_pos);
    2728:	f003 ff49 	bl	65be <rpc_get_int8>
    remote_command_flowcontrol_status(core, status);
    272c:	b2c1      	uxtb	r1, r0
    272e:	0028      	movs	r0, r5
    2730:	f005 fa78 	bl	7c24 <remote_command_flowcontrol_status>
    rpc_interface_scatter_send(core, commandID, false, 0, NULL);
    2734:	0031      	movs	r1, r6
    2736:	0028      	movs	r0, r5
    2738:	9400      	str	r4, [sp, #0]
    273a:	0023      	movs	r3, r4
    273c:	0022      	movs	r2, r4
    273e:	f7ff fddf 	bl	2300 <rpc_interface_scatter_send>
}
    2742:	bd7f      	pop	{r0, r1, r2, r3, r4, r5, r6, pc}

00002744 <internal_incomming_command_pdp_modify_result>:
    remote_command_ciot_opt_status_ind(core, cplane_opt_supported, uplane_opt_supported);
    rpc_interface_scatter_send(core, commandID, false, 0, NULL);
}

static void internal_incomming_command_pdp_modify_result(CORES core, uint16 commandID, uint8 *data)
{
    2744:	b57f      	push	{r0, r1, r2, r3, r4, r5, r6, lr}
    2746:	000e      	movs	r6, r1
    uint16 buffer_pos = 0;
    2748:	210e      	movs	r1, #14
    274a:	2400      	movs	r4, #0
{
    274c:	0005      	movs	r5, r0
    uint16 buffer_pos = 0;
    274e:	4469      	add	r1, sp
    uint8 ret;
    ret = (uint8)rpc_get_int8(data, &buffer_pos);
    2750:	0010      	movs	r0, r2
    uint16 buffer_pos = 0;
    2752:	800c      	strh	r4, [r1, #0]
    ret = (uint8)rpc_get_int8(data, &buffer_pos);
    2754:	f003 ff33 	bl	65be <rpc_get_int8>
    remote_command_pdp_modify_result(core, ret);
    2758:	b2c1      	uxtb	r1, r0
    275a:	0028      	movs	r0, r5
    275c:	f01a f928 	bl	1c9b0 <remote_command_pdp_modify_result>
    rpc_interface_scatter_send(core, commandID, false, 0, NULL);
    2760:	0031      	movs	r1, r6
    2762:	0028      	movs	r0, r5
    2764:	9400      	str	r4, [sp, #0]
    2766:	0023      	movs	r3, r4
    2768:	0022      	movs	r2, r4
    276a:	f7ff fdc9 	bl	2300 <rpc_interface_scatter_send>
}
    276e:	bd7f      	pop	{r0, r1, r2, r3, r4, r5, r6, pc}

00002770 <internal_incomming_command_driver_adc_action_response>:
    remote_command_driver_adc_read_response(core, reading, ret_value);
    rpc_interface_scatter_send(core, commandID, false, 0, NULL);
}

static void internal_incomming_command_driver_adc_action_response(CORES core, uint16 commandID, uint8 *data)
{
    2770:	b57f      	push	{r0, r1, r2, r3, r4, r5, r6, lr}
    2772:	000e      	movs	r6, r1
    uint16 buffer_pos = 0;
    2774:	210e      	movs	r1, #14
    2776:	2400      	movs	r4, #0
{
    2778:	0005      	movs	r5, r0
    uint16 buffer_pos = 0;
    277a:	4469      	add	r1, sp
    uint8 ret_value;
    ret_value = (uint8)rpc_get_int8(data, &buffer_pos);
    277c:	0010      	movs	r0, r2
    uint16 buffer_pos = 0;
    277e:	800c      	strh	r4, [r1, #0]
    ret_value = (uint8)rpc_get_int8(data, &buffer_pos);
    2780:	f003 ff1d 	bl	65be <rpc_get_int8>
    remote_command_driver_adc_action_response(core, ret_value);
    2784:	b2c1      	uxtb	r1, r0
    2786:	0028      	movs	r0, r5
    2788:	f019 f838 	bl	1b7fc <remote_command_driver_adc_action_response>
    rpc_interface_scatter_send(core, commandID, false, 0, NULL);
    278c:	0031      	movs	r1, r6
    278e:	0028      	movs	r0, r5
    2790:	9400      	str	r4, [sp, #0]
    2792:	0023      	movs	r3, r4
    2794:	0022      	movs	r2, r4
    2796:	f7ff fdb3 	bl	2300 <rpc_interface_scatter_send>
}
    279a:	bd7f      	pop	{r0, r1, r2, r3, r4, r5, r6, pc}

0000279c <internal_incomming_command_app_flash_erase_response>:

static void internal_incomming_command_app_flash_erase_response(CORES core, uint16 commandID, uint8 *data)
{
    279c:	b57f      	push	{r0, r1, r2, r3, r4, r5, r6, lr}
    279e:	000e      	movs	r6, r1
    uint16 buffer_pos = 0;
    27a0:	210e      	movs	r1, #14
    27a2:	2400      	movs	r4, #0
{
    27a4:	0005      	movs	r5, r0
    uint16 buffer_pos = 0;
    27a6:	4469      	add	r1, sp
    uint8 ret_val;
    ret_val = (uint8)rpc_get_int8(data, &buffer_pos);
    27a8:	0010      	movs	r0, r2
    uint16 buffer_pos = 0;
    27aa:	800c      	strh	r4, [r1, #0]
    ret_val = (uint8)rpc_get_int8(data, &buffer_pos);
    27ac:	f003 ff07 	bl	65be <rpc_get_int8>
    remote_command_app_flash_erase_response(core, ret_val);
    27b0:	b2c1      	uxtb	r1, r0
    27b2:	0028      	movs	r0, r5
    27b4:	f7ff feb8 	bl	2528 <remote_command_app_flash_erase_response>
    rpc_interface_scatter_send(core, commandID, false, 0, NULL);
    27b8:	0031      	movs	r1, r6
    27ba:	0028      	movs	r0, r5
    27bc:	9400      	str	r4, [sp, #0]
    27be:	0023      	movs	r3, r4
    27c0:	0022      	movs	r2, r4
    27c2:	f7ff fd9d 	bl	2300 <rpc_interface_scatter_send>
}
    27c6:	bd7f      	pop	{r0, r1, r2, r3, r4, r5, r6, pc}

000027c8 <internal_incomming_command_app_flash_write_response>:

static void internal_incomming_command_app_flash_write_response(CORES core, uint16 commandID, uint8 *data)
{
    27c8:	b57f      	push	{r0, r1, r2, r3, r4, r5, r6, lr}
    27ca:	000e      	movs	r6, r1
    uint16 buffer_pos = 0;
    27cc:	210e      	movs	r1, #14
    27ce:	2400      	movs	r4, #0
{
    27d0:	0005      	movs	r5, r0
    uint16 buffer_pos = 0;
    27d2:	4469      	add	r1, sp
    uint8 ret_val;
    ret_val = (uint8)rpc_get_int8(data, &buffer_pos);
    27d4:	0010      	movs	r0, r2
    uint16 buffer_pos = 0;
    27d6:	800c      	strh	r4, [r1, #0]
    ret_val = (uint8)rpc_get_int8(data, &buffer_pos);
    27d8:	f003 fef1 	bl	65be <rpc_get_int8>
    remote_command_app_flash_write_response(core, ret_val);
    27dc:	b2c1      	uxtb	r1, r0
    27de:	0028      	movs	r0, r5
    27e0:	f7ff fea2 	bl	2528 <remote_command_app_flash_erase_response>
    rpc_interface_scatter_send(core, commandID, false, 0, NULL);
    27e4:	0031      	movs	r1, r6
    27e6:	0028      	movs	r0, r5
    27e8:	9400      	str	r4, [sp, #0]
    27ea:	0023      	movs	r3, r4
    27ec:	0022      	movs	r2, r4
    27ee:	f7ff fd87 	bl	2300 <rpc_interface_scatter_send>
}
    27f2:	bd7f      	pop	{r0, r1, r2, r3, r4, r5, r6, pc}

000027f4 <internal_incomming_command_pin_status_ind>:

static void internal_incomming_command_pin_status_ind(CORES core, uint16 commandID, uint8 *data)
{
    27f4:	b57f      	push	{r0, r1, r2, r3, r4, r5, r6, lr}
    27f6:	000e      	movs	r6, r1
    uint16 buffer_pos = 0;
    27f8:	210e      	movs	r1, #14
    27fa:	2400      	movs	r4, #0
{
    27fc:	0005      	movs	r5, r0
    uint16 buffer_pos = 0;
    27fe:	4469      	add	r1, sp
    uint8 pin_status;
    pin_status = (uint8)rpc_get_int8(data, &buffer_pos);
    2800:	0010      	movs	r0, r2
    uint16 buffer_pos = 0;
    2802:	800c      	strh	r4, [r1, #0]
    pin_status = (uint8)rpc_get_int8(data, &buffer_pos);
    2804:	f003 fedb 	bl	65be <rpc_get_int8>
    remote_command_pin_status_ind(core, pin_status);
    2808:	b2c1      	uxtb	r1, r0
    280a:	0028      	movs	r0, r5
    280c:	f019 fc64 	bl	1c0d8 <remote_command_pin_status_ind>
    rpc_interface_scatter_send(core, commandID, false, 0, NULL);
    2810:	0031      	movs	r1, r6
    2812:	0028      	movs	r0, r5
    2814:	9400      	str	r4, [sp, #0]
    2816:	0023      	movs	r3, r4
    2818:	0022      	movs	r2, r4
    281a:	f7ff fd71 	bl	2300 <rpc_interface_scatter_send>
}
    281e:	bd7f      	pop	{r0, r1, r2, r3, r4, r5, r6, pc}

00002820 <internal_incomming_command_socket_data_sent>:
{
    2820:	b5f0      	push	{r4, r5, r6, r7, lr}
    uint16 buffer_pos = 0;
    2822:	250e      	movs	r5, #14
    2824:	2400      	movs	r4, #0
{
    2826:	b087      	sub	sp, #28
    uint16 buffer_pos = 0;
    2828:	ab02      	add	r3, sp, #8
    282a:	18ed      	adds	r5, r5, r3
{
    282c:	0006      	movs	r6, r0
    282e:	9102      	str	r1, [sp, #8]
    data_seq = (uint16)rpc_get_int16(data, &buffer_pos);
    2830:	0010      	movs	r0, r2
    2832:	0029      	movs	r1, r5
{
    2834:	0017      	movs	r7, r2
    uint16 buffer_pos = 0;
    2836:	802c      	strh	r4, [r5, #0]
    data_seq = (uint16)rpc_get_int16(data, &buffer_pos);
    2838:	f003 feb2 	bl	65a0 <rpc_get_int16>
    status = (bool)rpc_get_int8(data, &buffer_pos);
    283c:	0029      	movs	r1, r5
    data_seq = (uint16)rpc_get_int16(data, &buffer_pos);
    283e:	9003      	str	r0, [sp, #12]
    status = (bool)rpc_get_int8(data, &buffer_pos);
    2840:	0038      	movs	r0, r7
    2842:	f003 febc 	bl	65be <rpc_get_int8>
    remote_command_socket_data_sent(core, data_seq, status);
    2846:	466b      	mov	r3, sp
    status = (bool)rpc_get_int8(data, &buffer_pos);
    2848:	1e42      	subs	r2, r0, #1
    284a:	4190      	sbcs	r0, r2
    remote_command_socket_data_sent(core, data_seq, status);
    284c:	8999      	ldrh	r1, [r3, #12]
    284e:	b2c2      	uxtb	r2, r0
    2850:	0030      	movs	r0, r6
    2852:	f005 fc09 	bl	8068 <remote_command_socket_data_sent>
    rpc_interface_scatter_send(core, commandID, false, 0, NULL);
    2856:	9400      	str	r4, [sp, #0]
    2858:	0023      	movs	r3, r4
    285a:	0022      	movs	r2, r4
    285c:	9902      	ldr	r1, [sp, #8]
    285e:	0030      	movs	r0, r6
    2860:	f7ff fd4e 	bl	2300 <rpc_interface_scatter_send>
}
    2864:	b007      	add	sp, #28
    2866:	bdf0      	pop	{r4, r5, r6, r7, pc}

00002868 <internal_incomming_command_non_ip_data_sent>:
{
    2868:	b5f0      	push	{r4, r5, r6, r7, lr}
    uint16 buffer_pos = 0;
    286a:	250e      	movs	r5, #14
    286c:	2400      	movs	r4, #0
{
    286e:	b087      	sub	sp, #28
    uint16 buffer_pos = 0;
    2870:	ab02      	add	r3, sp, #8
    2872:	18ed      	adds	r5, r5, r3
{
    2874:	0006      	movs	r6, r0
    2876:	9102      	str	r1, [sp, #8]
    data_seq = (uint16)rpc_get_int16(data, &buffer_pos);
    2878:	0010      	movs	r0, r2
    287a:	0029      	movs	r1, r5
{
    287c:	0017      	movs	r7, r2
    uint16 buffer_pos = 0;
    287e:	802c      	strh	r4, [r5, #0]
    data_seq = (uint16)rpc_get_int16(data, &buffer_pos);
    2880:	f003 fe8e 	bl	65a0 <rpc_get_int16>
    status = (bool)rpc_get_int8(data, &buffer_pos);
    2884:	0029      	movs	r1, r5
    data_seq = (uint16)rpc_get_int16(data, &buffer_pos);
    2886:	9003      	str	r0, [sp, #12]
    status = (bool)rpc_get_int8(data, &buffer_pos);
    2888:	0038      	movs	r0, r7
    288a:	f003 fe98 	bl	65be <rpc_get_int8>
    remote_command_non_ip_data_sent(core, data_seq, status);
    288e:	466b      	mov	r3, sp
    status = (bool)rpc_get_int8(data, &buffer_pos);
    2890:	1e42      	subs	r2, r0, #1
    2892:	4190      	sbcs	r0, r2
    remote_command_non_ip_data_sent(core, data_seq, status);
    2894:	8999      	ldrh	r1, [r3, #12]
    2896:	b2c2      	uxtb	r2, r0
    2898:	0030      	movs	r0, r6
    289a:	f019 f9f7 	bl	1bc8c <remote_command_non_ip_data_sent>
    rpc_interface_scatter_send(core, commandID, false, 0, NULL);
    289e:	9400      	str	r4, [sp, #0]
    28a0:	0023      	movs	r3, r4
    28a2:	0022      	movs	r2, r4
    28a4:	9902      	ldr	r1, [sp, #8]
    28a6:	0030      	movs	r0, r6
    28a8:	f7ff fd2a 	bl	2300 <rpc_interface_scatter_send>
}
    28ac:	b007      	add	sp, #28
    28ae:	bdf0      	pop	{r4, r5, r6, r7, pc}

000028b0 <internal_incomming_command_recvfrom>:
{
    28b0:	b5f0      	push	{r4, r5, r6, r7, lr}
    uint16 buffer_pos = 0;
    28b2:	240e      	movs	r4, #14
    28b4:	2600      	movs	r6, #0
{
    28b6:	b08b      	sub	sp, #44	; 0x2c
    uint16 buffer_pos = 0;
    28b8:	ab06      	add	r3, sp, #24
    28ba:	18e4      	adds	r4, r4, r3
{
    28bc:	0007      	movs	r7, r0
    28be:	9106      	str	r1, [sp, #24]
    socket = (uint16)rpc_get_int16(data, &buffer_pos);
    28c0:	0010      	movs	r0, r2
    28c2:	0021      	movs	r1, r4
{
    28c4:	0015      	movs	r5, r2
    uint16 buffer_pos = 0;
    28c6:	8026      	strh	r6, [r4, #0]
    socket = (uint16)rpc_get_int16(data, &buffer_pos);
    28c8:	f003 fe6a 	bl	65a0 <rpc_get_int16>
    buffer_length = (uint16)rpc_get_int16(data, &buffer_pos);
    28cc:	0021      	movs	r1, r4
    socket = (uint16)rpc_get_int16(data, &buffer_pos);
    28ce:	9007      	str	r0, [sp, #28]
    buffer_length = (uint16)rpc_get_int16(data, &buffer_pos);
    28d0:	0028      	movs	r0, r5
    28d2:	f003 fe65 	bl	65a0 <rpc_get_int16>
    28d6:	b283      	uxth	r3, r0
    buffer = (uint8 *)rpc_get_buffer(data, &buffer_pos, buffer_length);
    28d8:	001a      	movs	r2, r3
    28da:	0021      	movs	r1, r4
    28dc:	0028      	movs	r0, r5
    buffer_length = (uint16)rpc_get_int16(data, &buffer_pos);
    28de:	9303      	str	r3, [sp, #12]
    buffer = (uint8 *)rpc_get_buffer(data, &buffer_pos, buffer_length);
    28e0:	f003 fe2a 	bl	6538 <rpc_get_buffer>
    sock_address_length = (uint16)rpc_get_int16(data, &buffer_pos);
    28e4:	0021      	movs	r1, r4
    buffer = (uint8 *)rpc_get_buffer(data, &buffer_pos, buffer_length);
    28e6:	9005      	str	r0, [sp, #20]
    sock_address_length = (uint16)rpc_get_int16(data, &buffer_pos);
    28e8:	0028      	movs	r0, r5
    28ea:	f003 fe59 	bl	65a0 <rpc_get_int16>
    28ee:	b283      	uxth	r3, r0
    sock_address = (uint8 *)rpc_get_buffer(data, &buffer_pos, sock_address_length);
    28f0:	001a      	movs	r2, r3
    28f2:	0021      	movs	r1, r4
    28f4:	0028      	movs	r0, r5
    sock_address_length = (uint16)rpc_get_int16(data, &buffer_pos);
    28f6:	9304      	str	r3, [sp, #16]
    sock_address = (uint8 *)rpc_get_buffer(data, &buffer_pos, sock_address_length);
    28f8:	f003 fe1e 	bl	6538 <rpc_get_buffer>
    remote_command_recvfrom(core, socket, buffer_length, buffer, sock_address_length, sock_address);
    28fc:	466b      	mov	r3, sp
    28fe:	8b99      	ldrh	r1, [r3, #28]
    2900:	9b04      	ldr	r3, [sp, #16]
    2902:	9001      	str	r0, [sp, #4]
    2904:	9300      	str	r3, [sp, #0]
    2906:	9a03      	ldr	r2, [sp, #12]
    2908:	9b05      	ldr	r3, [sp, #20]
    290a:	0038      	movs	r0, r7
    290c:	f005 f8fc 	bl	7b08 <remote_command_recvfrom>
    rpc_interface_scatter_send(core, commandID, false, 0, NULL);
    2910:	9600      	str	r6, [sp, #0]
    2912:	0033      	movs	r3, r6
    2914:	0032      	movs	r2, r6
    2916:	9906      	ldr	r1, [sp, #24]
    2918:	0038      	movs	r0, r7
    291a:	f7ff fcf1 	bl	2300 <rpc_interface_scatter_send>
}
    291e:	b00b      	add	sp, #44	; 0x2c
    2920:	bdf0      	pop	{r4, r5, r6, r7, pc}

00002922 <internal_incomming_command_socket_recv>:
{
    2922:	b5f0      	push	{r4, r5, r6, r7, lr}
    uint16 buffer_pos = 0;
    2924:	2416      	movs	r4, #22
    2926:	2600      	movs	r6, #0
{
    2928:	b08d      	sub	sp, #52	; 0x34
    uint16 buffer_pos = 0;
    292a:	ab06      	add	r3, sp, #24
    292c:	18e4      	adds	r4, r4, r3
{
    292e:	0007      	movs	r7, r0
    2930:	9108      	str	r1, [sp, #32]
    socket = (uint16)rpc_get_int16(data, &buffer_pos);
    2932:	0010      	movs	r0, r2
    2934:	0021      	movs	r1, r4
{
    2936:	0015      	movs	r5, r2
    uint16 buffer_pos = 0;
    2938:	8026      	strh	r6, [r4, #0]
    socket = (uint16)rpc_get_int16(data, &buffer_pos);
    293a:	f003 fe31 	bl	65a0 <rpc_get_int16>
    buffer_length = (uint16)rpc_get_int16(data, &buffer_pos);
    293e:	0021      	movs	r1, r4
    socket = (uint16)rpc_get_int16(data, &buffer_pos);
    2940:	9009      	str	r0, [sp, #36]	; 0x24
    buffer_length = (uint16)rpc_get_int16(data, &buffer_pos);
    2942:	0028      	movs	r0, r5
    2944:	f003 fe2c 	bl	65a0 <rpc_get_int16>
    2948:	b283      	uxth	r3, r0
    buffer = (uint8 *)rpc_get_buffer(data, &buffer_pos, buffer_length);
    294a:	001a      	movs	r2, r3
    294c:	0021      	movs	r1, r4
    294e:	0028      	movs	r0, r5
    buffer_length = (uint16)rpc_get_int16(data, &buffer_pos);
    2950:	9304      	str	r3, [sp, #16]
    buffer = (uint8 *)rpc_get_buffer(data, &buffer_pos, buffer_length);
    2952:	f003 fdf1 	bl	6538 <rpc_get_buffer>
    sock_address_length = (uint16)rpc_get_int16(data, &buffer_pos);
    2956:	0021      	movs	r1, r4
    buffer = (uint8 *)rpc_get_buffer(data, &buffer_pos, buffer_length);
    2958:	9006      	str	r0, [sp, #24]
    sock_address_length = (uint16)rpc_get_int16(data, &buffer_pos);
    295a:	0028      	movs	r0, r5
    295c:	f003 fe20 	bl	65a0 <rpc_get_int16>
    2960:	b283      	uxth	r3, r0
    sock_address = (uint8 *)rpc_get_buffer(data, &buffer_pos, sock_address_length);
    2962:	001a      	movs	r2, r3
    2964:	0021      	movs	r1, r4
    2966:	0028      	movs	r0, r5
    sock_address_length = (uint16)rpc_get_int16(data, &buffer_pos);
    2968:	9305      	str	r3, [sp, #20]
    sock_address = (uint8 *)rpc_get_buffer(data, &buffer_pos, sock_address_length);
    296a:	f003 fde5 	bl	6538 <rpc_get_buffer>
    flags = (uint16)rpc_get_int16(data, &buffer_pos);
    296e:	0021      	movs	r1, r4
    sock_address = (uint8 *)rpc_get_buffer(data, &buffer_pos, sock_address_length);
    2970:	9007      	str	r0, [sp, #28]
    flags = (uint16)rpc_get_int16(data, &buffer_pos);
    2972:	0028      	movs	r0, r5
    2974:	f003 fe14 	bl	65a0 <rpc_get_int16>
    remote_command_socket_recv(core, socket, buffer_length, buffer, sock_address_length, sock_address, flags);
    2978:	466b      	mov	r3, sp
    297a:	8c99      	ldrh	r1, [r3, #36]	; 0x24
    297c:	9b07      	ldr	r3, [sp, #28]
    297e:	b280      	uxth	r0, r0
    2980:	9301      	str	r3, [sp, #4]
    2982:	9b05      	ldr	r3, [sp, #20]
    2984:	9002      	str	r0, [sp, #8]
    2986:	9300      	str	r3, [sp, #0]
    2988:	9a04      	ldr	r2, [sp, #16]
    298a:	9b06      	ldr	r3, [sp, #24]
    298c:	0038      	movs	r0, r7
    298e:	f005 f93f 	bl	7c10 <remote_command_socket_recv>
    rpc_interface_scatter_send(core, commandID, false, 0, NULL);
    2992:	9600      	str	r6, [sp, #0]
    2994:	0033      	movs	r3, r6
    2996:	0032      	movs	r2, r6
    2998:	9908      	ldr	r1, [sp, #32]
    299a:	0038      	movs	r0, r7
    299c:	f7ff fcb0 	bl	2300 <rpc_interface_scatter_send>
}
    29a0:	b00d      	add	sp, #52	; 0x34
    29a2:	bdf0      	pop	{r4, r5, r6, r7, pc}

000029a4 <internal_incomming_command_socket_notify>:
{
    29a4:	b5f0      	push	{r4, r5, r6, r7, lr}
    uint16 buffer_pos = 0;
    29a6:	250e      	movs	r5, #14
    29a8:	2400      	movs	r4, #0
{
    29aa:	b089      	sub	sp, #36	; 0x24
    uint16 buffer_pos = 0;
    29ac:	ab04      	add	r3, sp, #16
    29ae:	18ed      	adds	r5, r5, r3
{
    29b0:	0007      	movs	r7, r0
    29b2:	9103      	str	r1, [sp, #12]
    socket = (uint16)rpc_get_int16(data, &buffer_pos);
    29b4:	0010      	movs	r0, r2
    29b6:	0029      	movs	r1, r5
{
    29b8:	0016      	movs	r6, r2
    uint16 buffer_pos = 0;
    29ba:	802c      	strh	r4, [r5, #0]
    socket = (uint16)rpc_get_int16(data, &buffer_pos);
    29bc:	f003 fdf0 	bl	65a0 <rpc_get_int16>
    notify = (uint16)rpc_get_int16(data, &buffer_pos);
    29c0:	0029      	movs	r1, r5
    socket = (uint16)rpc_get_int16(data, &buffer_pos);
    29c2:	9004      	str	r0, [sp, #16]
    notify = (uint16)rpc_get_int16(data, &buffer_pos);
    29c4:	0030      	movs	r0, r6
    29c6:	f003 fdeb 	bl	65a0 <rpc_get_int16>
    arg = (int)rpc_get_int32(data, &buffer_pos);
    29ca:	0029      	movs	r1, r5
    notify = (uint16)rpc_get_int16(data, &buffer_pos);
    29cc:	9005      	str	r0, [sp, #20]
    arg = (int)rpc_get_int32(data, &buffer_pos);
    29ce:	0030      	movs	r0, r6
    29d0:	f003 fdd3 	bl	657a <rpc_get_int32>
    remote_command_socket_notify(core, socket, notify, arg);
    29d4:	466a      	mov	r2, sp
    29d6:	4669      	mov	r1, sp
    arg = (int)rpc_get_int32(data, &buffer_pos);
    29d8:	0003      	movs	r3, r0
    remote_command_socket_notify(core, socket, notify, arg);
    29da:	8a92      	ldrh	r2, [r2, #20]
    29dc:	0038      	movs	r0, r7
    29de:	8a09      	ldrh	r1, [r1, #16]
    29e0:	f005 f92a 	bl	7c38 <remote_command_socket_notify>
    rpc_interface_scatter_send(core, commandID, false, 0, NULL);
    29e4:	9400      	str	r4, [sp, #0]
    29e6:	0023      	movs	r3, r4
    29e8:	0022      	movs	r2, r4
    29ea:	9903      	ldr	r1, [sp, #12]
    29ec:	0038      	movs	r0, r7
    29ee:	f7ff fc87 	bl	2300 <rpc_interface_scatter_send>
}
    29f2:	b009      	add	sp, #36	; 0x24
    29f4:	bdf0      	pop	{r4, r5, r6, r7, pc}

000029f6 <internal_incomming_command_ping_ind>:
{
    29f6:	b5f0      	push	{r4, r5, r6, r7, lr}
    uint16 buffer_pos = 0;
    29f8:	240e      	movs	r4, #14
    29fa:	2600      	movs	r6, #0
{
    29fc:	b08b      	sub	sp, #44	; 0x2c
    uint16 buffer_pos = 0;
    29fe:	ab06      	add	r3, sp, #24
    2a00:	18e4      	adds	r4, r4, r3
{
    2a02:	9004      	str	r0, [sp, #16]
    2a04:	9106      	str	r1, [sp, #24]
    remote_addr_length = (uint16)rpc_get_int16(data, &buffer_pos);
    2a06:	0010      	movs	r0, r2
    2a08:	0021      	movs	r1, r4
{
    2a0a:	0015      	movs	r5, r2
    uint16 buffer_pos = 0;
    2a0c:	8026      	strh	r6, [r4, #0]
    remote_addr_length = (uint16)rpc_get_int16(data, &buffer_pos);
    2a0e:	f003 fdc7 	bl	65a0 <rpc_get_int16>
    2a12:	b283      	uxth	r3, r0
    remote_addr = (uint8 *)rpc_get_buffer(data, &buffer_pos, remote_addr_length);
    2a14:	001a      	movs	r2, r3
    2a16:	0021      	movs	r1, r4
    2a18:	0028      	movs	r0, r5
    remote_addr_length = (uint16)rpc_get_int16(data, &buffer_pos);
    2a1a:	9303      	str	r3, [sp, #12]
    remote_addr = (uint8 *)rpc_get_buffer(data, &buffer_pos, remote_addr_length);
    2a1c:	f003 fd8c 	bl	6538 <rpc_get_buffer>
    result = (uint8)rpc_get_int8(data, &buffer_pos);
    2a20:	0021      	movs	r1, r4
    remote_addr = (uint8 *)rpc_get_buffer(data, &buffer_pos, remote_addr_length);
    2a22:	9005      	str	r0, [sp, #20]
    result = (uint8)rpc_get_int8(data, &buffer_pos);
    2a24:	0028      	movs	r0, r5
    2a26:	f003 fdca 	bl	65be <rpc_get_int8>
    ttl = (uint8)rpc_get_int8(data, &buffer_pos);
    2a2a:	0021      	movs	r1, r4
    result = (uint8)rpc_get_int8(data, &buffer_pos);
    2a2c:	9007      	str	r0, [sp, #28]
    ttl = (uint8)rpc_get_int8(data, &buffer_pos);
    2a2e:	0028      	movs	r0, r5
    2a30:	f003 fdc5 	bl	65be <rpc_get_int8>
    rtt = (uint32)rpc_get_int32(data, &buffer_pos);
    2a34:	0021      	movs	r1, r4
    ttl = (uint8)rpc_get_int8(data, &buffer_pos);
    2a36:	0007      	movs	r7, r0
    rtt = (uint32)rpc_get_int32(data, &buffer_pos);
    2a38:	0028      	movs	r0, r5
    2a3a:	f003 fd9e 	bl	657a <rpc_get_int32>
    remote_command_ping_ind(core, remote_addr_length, remote_addr, result, ttl, rtt);
    2a3e:	466b      	mov	r3, sp
    2a40:	b2ff      	uxtb	r7, r7
    2a42:	7f1b      	ldrb	r3, [r3, #28]
    2a44:	9a05      	ldr	r2, [sp, #20]
    2a46:	9001      	str	r0, [sp, #4]
    2a48:	9903      	ldr	r1, [sp, #12]
    2a4a:	9804      	ldr	r0, [sp, #16]
    2a4c:	9700      	str	r7, [sp, #0]
    2a4e:	f01a fba1 	bl	1d194 <remote_command_ping_ind>
    rpc_interface_scatter_send(core, commandID, false, 0, NULL);
    2a52:	9600      	str	r6, [sp, #0]
    2a54:	0033      	movs	r3, r6
    2a56:	0032      	movs	r2, r6
    2a58:	9906      	ldr	r1, [sp, #24]
    2a5a:	9804      	ldr	r0, [sp, #16]
    2a5c:	f7ff fc50 	bl	2300 <rpc_interface_scatter_send>
}
    2a60:	b00b      	add	sp, #44	; 0x2c
    2a62:	bdf0      	pop	{r4, r5, r6, r7, pc}

00002a64 <internal_incomming_command_sms_mgs_result_ind>:
{
    2a64:	b5f0      	push	{r4, r5, r6, r7, lr}
    uint16 buffer_pos = 0;
    2a66:	240e      	movs	r4, #14
    2a68:	2500      	movs	r5, #0
{
    2a6a:	b089      	sub	sp, #36	; 0x24
    uint16 buffer_pos = 0;
    2a6c:	ab04      	add	r3, sp, #16
    2a6e:	18e4      	adds	r4, r4, r3
{
    2a70:	0007      	movs	r7, r0
    2a72:	9103      	str	r1, [sp, #12]
    sms_mgs_result = (uint8)rpc_get_int8(data, &buffer_pos);
    2a74:	0010      	movs	r0, r2
    2a76:	0021      	movs	r1, r4
{
    2a78:	0016      	movs	r6, r2
    uint16 buffer_pos = 0;
    2a7a:	8025      	strh	r5, [r4, #0]
    sms_mgs_result = (uint8)rpc_get_int8(data, &buffer_pos);
    2a7c:	f003 fd9f 	bl	65be <rpc_get_int8>
    mr = (uint8)rpc_get_int8(data, &buffer_pos);
    2a80:	0021      	movs	r1, r4
    sms_mgs_result = (uint8)rpc_get_int8(data, &buffer_pos);
    2a82:	9004      	str	r0, [sp, #16]
    mr = (uint8)rpc_get_int8(data, &buffer_pos);
    2a84:	0030      	movs	r0, r6
    2a86:	f003 fd9a 	bl	65be <rpc_get_int8>
    ackpdu_length = (uint16)rpc_get_int16(data, &buffer_pos);
    2a8a:	0021      	movs	r1, r4
    mr = (uint8)rpc_get_int8(data, &buffer_pos);
    2a8c:	9005      	str	r0, [sp, #20]
    ackpdu_length = (uint16)rpc_get_int16(data, &buffer_pos);
    2a8e:	0030      	movs	r0, r6
    2a90:	f003 fd86 	bl	65a0 <rpc_get_int16>
    2a94:	b283      	uxth	r3, r0
    ackpdu = (uint8 *)rpc_get_buffer(data, &buffer_pos, ackpdu_length);
    2a96:	001a      	movs	r2, r3
    2a98:	0021      	movs	r1, r4
    2a9a:	0030      	movs	r0, r6
    ackpdu_length = (uint16)rpc_get_int16(data, &buffer_pos);
    2a9c:	9302      	str	r3, [sp, #8]
    ackpdu = (uint8 *)rpc_get_buffer(data, &buffer_pos, ackpdu_length);
    2a9e:	f003 fd4b 	bl	6538 <rpc_get_buffer>
    remote_command_sms_mgs_result_ind(core, sms_mgs_result, mr, ackpdu_length, ackpdu);
    2aa2:	466b      	mov	r3, sp
    2aa4:	7d1a      	ldrb	r2, [r3, #20]
    2aa6:	7c19      	ldrb	r1, [r3, #16]
    2aa8:	9000      	str	r0, [sp, #0]
    2aaa:	9b02      	ldr	r3, [sp, #8]
    2aac:	0038      	movs	r0, r7
    2aae:	f01a f901 	bl	1ccb4 <remote_command_sms_mgs_result_ind>
    rpc_interface_scatter_send(core, commandID, false, 0, NULL);
    2ab2:	9500      	str	r5, [sp, #0]
    2ab4:	002b      	movs	r3, r5
    2ab6:	002a      	movs	r2, r5
    2ab8:	9903      	ldr	r1, [sp, #12]
    2aba:	0038      	movs	r0, r7
    2abc:	f7ff fc20 	bl	2300 <rpc_interface_scatter_send>
}
    2ac0:	b009      	add	sp, #36	; 0x24
    2ac2:	bdf0      	pop	{r4, r5, r6, r7, pc}

00002ac4 <internal_incomming_command_sms_cmd_result_ind>:
{
    2ac4:	b5f0      	push	{r4, r5, r6, r7, lr}
    uint16 buffer_pos = 0;
    2ac6:	240e      	movs	r4, #14
    2ac8:	2500      	movs	r5, #0
{
    2aca:	b089      	sub	sp, #36	; 0x24
    uint16 buffer_pos = 0;
    2acc:	ab04      	add	r3, sp, #16
    2ace:	18e4      	adds	r4, r4, r3
{
    2ad0:	0007      	movs	r7, r0
    2ad2:	9103      	str	r1, [sp, #12]
    sms_cmd_result = (uint8)rpc_get_int8(data, &buffer_pos);
    2ad4:	0010      	movs	r0, r2
    2ad6:	0021      	movs	r1, r4
{
    2ad8:	0016      	movs	r6, r2
    uint16 buffer_pos = 0;
    2ada:	8025      	strh	r5, [r4, #0]
    sms_cmd_result = (uint8)rpc_get_int8(data, &buffer_pos);
    2adc:	f003 fd6f 	bl	65be <rpc_get_int8>
    mr = (uint8)rpc_get_int8(data, &buffer_pos);
    2ae0:	0021      	movs	r1, r4
    sms_cmd_result = (uint8)rpc_get_int8(data, &buffer_pos);
    2ae2:	9004      	str	r0, [sp, #16]
    mr = (uint8)rpc_get_int8(data, &buffer_pos);
    2ae4:	0030      	movs	r0, r6
    2ae6:	f003 fd6a 	bl	65be <rpc_get_int8>
    ackpdu_length = (uint16)rpc_get_int16(data, &buffer_pos);
    2aea:	0021      	movs	r1, r4
    mr = (uint8)rpc_get_int8(data, &buffer_pos);
    2aec:	9005      	str	r0, [sp, #20]
    ackpdu_length = (uint16)rpc_get_int16(data, &buffer_pos);
    2aee:	0030      	movs	r0, r6
    2af0:	f003 fd56 	bl	65a0 <rpc_get_int16>
    2af4:	b283      	uxth	r3, r0
    ackpdu = (uint8 *)rpc_get_buffer(data, &buffer_pos, ackpdu_length);
    2af6:	001a      	movs	r2, r3
    2af8:	0021      	movs	r1, r4
    2afa:	0030      	movs	r0, r6
    ackpdu_length = (uint16)rpc_get_int16(data, &buffer_pos);
    2afc:	9302      	str	r3, [sp, #8]
    ackpdu = (uint8 *)rpc_get_buffer(data, &buffer_pos, ackpdu_length);
    2afe:	f003 fd1b 	bl	6538 <rpc_get_buffer>
    remote_command_sms_cmd_result_ind(core, sms_cmd_result, mr, ackpdu_length, ackpdu);
    2b02:	466b      	mov	r3, sp
    2b04:	7d1a      	ldrb	r2, [r3, #20]
    2b06:	7c19      	ldrb	r1, [r3, #16]
    2b08:	9000      	str	r0, [sp, #0]
    2b0a:	9b02      	ldr	r3, [sp, #8]
    2b0c:	0038      	movs	r0, r7
    2b0e:	f01a f8df 	bl	1ccd0 <remote_command_sms_cmd_result_ind>
    rpc_interface_scatter_send(core, commandID, false, 0, NULL);
    2b12:	9500      	str	r5, [sp, #0]
    2b14:	002b      	movs	r3, r5
    2b16:	002a      	movs	r2, r5
    2b18:	9903      	ldr	r1, [sp, #12]
    2b1a:	0038      	movs	r0, r7
    2b1c:	f7ff fbf0 	bl	2300 <rpc_interface_scatter_send>
}
    2b20:	b009      	add	sp, #36	; 0x24
    2b22:	bdf0      	pop	{r4, r5, r6, r7, pc}

00002b24 <internal_incomming_command_current_time_ind>:
{
    2b24:	b5f0      	push	{r4, r5, r6, r7, lr}
    uint16 buffer_pos = 0;
    2b26:	2416      	movs	r4, #22
    2b28:	2500      	movs	r5, #0
{
    2b2a:	b08d      	sub	sp, #52	; 0x34
    uint16 buffer_pos = 0;
    2b2c:	ab06      	add	r3, sp, #24
    2b2e:	18e4      	adds	r4, r4, r3
{
    2b30:	9005      	str	r0, [sp, #20]
    2b32:	9108      	str	r1, [sp, #32]
    current_time = (uint64)rpc_get_int64(data, &buffer_pos);
    2b34:	0010      	movs	r0, r2
    2b36:	0021      	movs	r1, r4
{
    2b38:	0016      	movs	r6, r2
    uint16 buffer_pos = 0;
    2b3a:	8025      	strh	r5, [r4, #0]
    current_time = (uint64)rpc_get_int64(data, &buffer_pos);
    2b3c:	f003 fd04 	bl	6548 <rpc_get_int64>
    2b40:	9006      	str	r0, [sp, #24]
    2b42:	9107      	str	r1, [sp, #28]
    time_zone = (int8)rpc_get_int8(data, &buffer_pos);
    2b44:	0021      	movs	r1, r4
    2b46:	0030      	movs	r0, r6
    2b48:	f003 fd39 	bl	65be <rpc_get_int8>
    daylight_saving_time = (uint8)rpc_get_int8(data, &buffer_pos);
    2b4c:	0021      	movs	r1, r4
    time_zone = (int8)rpc_get_int8(data, &buffer_pos);
    2b4e:	9009      	str	r0, [sp, #36]	; 0x24
    daylight_saving_time = (uint8)rpc_get_int8(data, &buffer_pos);
    2b50:	0030      	movs	r0, r6
    2b52:	f003 fd34 	bl	65be <rpc_get_int8>
    updated_time_fields = (uint8)rpc_get_int8(data, &buffer_pos);
    2b56:	0021      	movs	r1, r4
    daylight_saving_time = (uint8)rpc_get_int8(data, &buffer_pos);
    2b58:	0007      	movs	r7, r0
    updated_time_fields = (uint8)rpc_get_int8(data, &buffer_pos);
    2b5a:	0030      	movs	r0, r6
    2b5c:	f003 fd2f 	bl	65be <rpc_get_int8>
    remote_command_current_time_ind(core, current_time, time_zone, daylight_saving_time, updated_time_fields);
    2b60:	9b09      	ldr	r3, [sp, #36]	; 0x24
    2b62:	b2c0      	uxtb	r0, r0
    2b64:	b2ff      	uxtb	r7, r7
    2b66:	9002      	str	r0, [sp, #8]
    2b68:	9300      	str	r3, [sp, #0]
    2b6a:	9805      	ldr	r0, [sp, #20]
    2b6c:	9a06      	ldr	r2, [sp, #24]
    2b6e:	9b07      	ldr	r3, [sp, #28]
    2b70:	9701      	str	r7, [sp, #4]
    2b72:	f018 ffd7 	bl	1bb24 <remote_command_current_time_ind>
    rpc_interface_scatter_send(core, commandID, false, 0, NULL);
    2b76:	9500      	str	r5, [sp, #0]
    2b78:	002b      	movs	r3, r5
    2b7a:	002a      	movs	r2, r5
    2b7c:	9908      	ldr	r1, [sp, #32]
    2b7e:	9805      	ldr	r0, [sp, #20]
    2b80:	f7ff fbbe 	bl	2300 <rpc_interface_scatter_send>
}
    2b84:	b00d      	add	sp, #52	; 0x34
    2b86:	bdf0      	pop	{r4, r5, r6, r7, pc}

00002b88 <internal_incomming_command_rf_calibration_rtc_ind>:
{
    2b88:	b57f      	push	{r0, r1, r2, r3, r4, r5, r6, lr}
    2b8a:	000e      	movs	r6, r1
    uint16 buffer_pos = 0;
    2b8c:	210e      	movs	r1, #14
    2b8e:	2400      	movs	r4, #0
{
    2b90:	0005      	movs	r5, r0
    uint16 buffer_pos = 0;
    2b92:	4469      	add	r1, sp
    rtc_freq_calibrated_by_rf = (uint32)rpc_get_int32(data, &buffer_pos);
    2b94:	0010      	movs	r0, r2
    uint16 buffer_pos = 0;
    2b96:	800c      	strh	r4, [r1, #0]
    rtc_freq_calibrated_by_rf = (uint32)rpc_get_int32(data, &buffer_pos);
    2b98:	f003 fcef 	bl	657a <rpc_get_int32>
    2b9c:	0001      	movs	r1, r0
    remote_command_rf_calibration_rtc_ind(core, rtc_freq_calibrated_by_rf);
    2b9e:	0028      	movs	r0, r5
    2ba0:	f018 fff4 	bl	1bb8c <remote_command_rf_calibration_rtc_ind>
    rpc_interface_scatter_send(core, commandID, false, 0, NULL);
    2ba4:	0031      	movs	r1, r6
    2ba6:	0028      	movs	r0, r5
    2ba8:	9400      	str	r4, [sp, #0]
    2baa:	0023      	movs	r3, r4
    2bac:	0022      	movs	r2, r4
    2bae:	f7ff fba7 	bl	2300 <rpc_interface_scatter_send>
}
    2bb2:	bd7f      	pop	{r0, r1, r2, r3, r4, r5, r6, pc}

00002bb4 <internal_incomming_command_update_package_get_package_version_cnf>:
{
    2bb4:	b5f0      	push	{r4, r5, r6, r7, lr}
    uint16 buffer_pos = 0;
    2bb6:	250e      	movs	r5, #14
    2bb8:	2400      	movs	r4, #0
{
    2bba:	b087      	sub	sp, #28
    uint16 buffer_pos = 0;
    2bbc:	ab02      	add	r3, sp, #8
    2bbe:	18ed      	adds	r5, r5, r3
{
    2bc0:	0006      	movs	r6, r0
    2bc2:	9103      	str	r1, [sp, #12]
    version_length = (uint16)rpc_get_int16(data, &buffer_pos);
    2bc4:	0010      	movs	r0, r2
    2bc6:	0029      	movs	r1, r5
{
    2bc8:	0017      	movs	r7, r2
    uint16 buffer_pos = 0;
    2bca:	802c      	strh	r4, [r5, #0]
    version_length = (uint16)rpc_get_int16(data, &buffer_pos);
    2bcc:	f003 fce8 	bl	65a0 <rpc_get_int16>
    2bd0:	b283      	uxth	r3, r0
    version = (uint8 *)rpc_get_buffer(data, &buffer_pos, version_length);
    2bd2:	001a      	movs	r2, r3
    2bd4:	0029      	movs	r1, r5
    2bd6:	0038      	movs	r0, r7
    version_length = (uint16)rpc_get_int16(data, &buffer_pos);
    2bd8:	9302      	str	r3, [sp, #8]
    version = (uint8 *)rpc_get_buffer(data, &buffer_pos, version_length);
    2bda:	f003 fcad 	bl	6538 <rpc_get_buffer>
    remote_command_update_package_get_package_version_cnf(core, version_length, version);
    2bde:	9902      	ldr	r1, [sp, #8]
    version = (uint8 *)rpc_get_buffer(data, &buffer_pos, version_length);
    2be0:	0002      	movs	r2, r0
    remote_command_update_package_get_package_version_cnf(core, version_length, version);
    2be2:	0030      	movs	r0, r6
    2be4:	f004 fe80 	bl	78e8 <remote_command_update_package_get_package_version_cnf>
    rpc_interface_scatter_send(core, commandID, false, 0, NULL);
    2be8:	9400      	str	r4, [sp, #0]
    2bea:	0023      	movs	r3, r4
    2bec:	0022      	movs	r2, r4
    2bee:	9903      	ldr	r1, [sp, #12]
    2bf0:	0030      	movs	r0, r6
    2bf2:	f7ff fb85 	bl	2300 <rpc_interface_scatter_send>
}
    2bf6:	b007      	add	sp, #28
    2bf8:	bdf0      	pop	{r4, r5, r6, r7, pc}

00002bfa <internal_incomming_command_update_package_get_package_name_cnf>:
{
    2bfa:	b5f0      	push	{r4, r5, r6, r7, lr}
    uint16 buffer_pos = 0;
    2bfc:	250e      	movs	r5, #14
    2bfe:	2400      	movs	r4, #0
{
    2c00:	b087      	sub	sp, #28
    uint16 buffer_pos = 0;
    2c02:	ab02      	add	r3, sp, #8
    2c04:	18ed      	adds	r5, r5, r3
{
    2c06:	0006      	movs	r6, r0
    2c08:	9103      	str	r1, [sp, #12]
    pkgname_length = (uint16)rpc_get_int16(data, &buffer_pos);
    2c0a:	0010      	movs	r0, r2
    2c0c:	0029      	movs	r1, r5
{
    2c0e:	0017      	movs	r7, r2
    uint16 buffer_pos = 0;
    2c10:	802c      	strh	r4, [r5, #0]
    pkgname_length = (uint16)rpc_get_int16(data, &buffer_pos);
    2c12:	f003 fcc5 	bl	65a0 <rpc_get_int16>
    2c16:	b283      	uxth	r3, r0
    pkgname = (uint8 *)rpc_get_buffer(data, &buffer_pos, pkgname_length);
    2c18:	001a      	movs	r2, r3
    2c1a:	0029      	movs	r1, r5
    2c1c:	0038      	movs	r0, r7
    pkgname_length = (uint16)rpc_get_int16(data, &buffer_pos);
    2c1e:	9302      	str	r3, [sp, #8]
    pkgname = (uint8 *)rpc_get_buffer(data, &buffer_pos, pkgname_length);
    2c20:	f003 fc8a 	bl	6538 <rpc_get_buffer>
    remote_command_update_package_get_package_name_cnf(core, pkgname_length, pkgname);
    2c24:	9902      	ldr	r1, [sp, #8]
    pkgname = (uint8 *)rpc_get_buffer(data, &buffer_pos, pkgname_length);
    2c26:	0002      	movs	r2, r0
    remote_command_update_package_get_package_name_cnf(core, pkgname_length, pkgname);
    2c28:	0030      	movs	r0, r6
    2c2a:	f004 fe51 	bl	78d0 <remote_command_update_package_get_package_name_cnf>
    rpc_interface_scatter_send(core, commandID, false, 0, NULL);
    2c2e:	9400      	str	r4, [sp, #0]
    2c30:	0023      	movs	r3, r4
    2c32:	0022      	movs	r2, r4
    2c34:	9903      	ldr	r1, [sp, #12]
    2c36:	0030      	movs	r0, r6
    2c38:	f7ff fb62 	bl	2300 <rpc_interface_scatter_send>
}
    2c3c:	b007      	add	sp, #28
    2c3e:	bdf0      	pop	{r4, r5, r6, r7, pc}

00002c40 <remote_command_update_package_data_req>:
{
    2c40:	b510      	push	{r4, lr}
    assert(false);
    2c42:	4671      	mov	r1, lr
    2c44:	2016      	movs	r0, #22
    2c46:	f7fe ff63 	bl	1b10 <panic>
}
    2c4a:	bd10      	pop	{r4, pc}

00002c4c <internal_incomming_command_update_package_data_req>:
{
    2c4c:	b5f0      	push	{r4, r5, r6, r7, lr}
    uint16 buffer_pos = 0;
    2c4e:	250e      	movs	r5, #14
    2c50:	2400      	movs	r4, #0
{
    2c52:	b087      	sub	sp, #28
    uint16 buffer_pos = 0;
    2c54:	ab02      	add	r3, sp, #8
    2c56:	18ed      	adds	r5, r5, r3
{
    2c58:	0006      	movs	r6, r0
    2c5a:	9103      	str	r1, [sp, #12]
    offset = (uint32)rpc_get_int32(data, &buffer_pos);
    2c5c:	0010      	movs	r0, r2
    2c5e:	0029      	movs	r1, r5
{
    2c60:	0017      	movs	r7, r2
    uint16 buffer_pos = 0;
    2c62:	802c      	strh	r4, [r5, #0]
    offset = (uint32)rpc_get_int32(data, &buffer_pos);
    2c64:	f003 fc89 	bl	657a <rpc_get_int32>
    length = (uint16)rpc_get_int16(data, &buffer_pos);
    2c68:	0029      	movs	r1, r5
    offset = (uint32)rpc_get_int32(data, &buffer_pos);
    2c6a:	9002      	str	r0, [sp, #8]
    length = (uint16)rpc_get_int16(data, &buffer_pos);
    2c6c:	0038      	movs	r0, r7
    2c6e:	f003 fc97 	bl	65a0 <rpc_get_int16>
    remote_command_update_package_data_req(core, offset, length);
    2c72:	9902      	ldr	r1, [sp, #8]
    2c74:	b282      	uxth	r2, r0
    2c76:	0030      	movs	r0, r6
    2c78:	f7ff ffe2 	bl	2c40 <remote_command_update_package_data_req>
    rpc_interface_scatter_send(core, commandID, false, 0, NULL);
    2c7c:	9400      	str	r4, [sp, #0]
    2c7e:	0023      	movs	r3, r4
    2c80:	0022      	movs	r2, r4
    2c82:	9903      	ldr	r1, [sp, #12]
    2c84:	0030      	movs	r0, r6
    2c86:	f7ff fb3b 	bl	2300 <rpc_interface_scatter_send>
}
    2c8a:	b007      	add	sp, #28
    2c8c:	bdf0      	pop	{r4, r5, r6, r7, pc}

00002c8e <internal_incomming_command_update_package_flash_erase_done>:
{
    2c8e:	b57f      	push	{r0, r1, r2, r3, r4, r5, r6, lr}
    2c90:	000e      	movs	r6, r1
    uint16 buffer_pos = 0;
    2c92:	210e      	movs	r1, #14
    2c94:	2400      	movs	r4, #0
{
    2c96:	0005      	movs	r5, r0
    uint16 buffer_pos = 0;
    2c98:	4469      	add	r1, sp
    result = (bool)rpc_get_int8(data, &buffer_pos);
    2c9a:	0010      	movs	r0, r2
    uint16 buffer_pos = 0;
    2c9c:	800c      	strh	r4, [r1, #0]
    result = (bool)rpc_get_int8(data, &buffer_pos);
    2c9e:	f003 fc8e 	bl	65be <rpc_get_int8>
    2ca2:	1e41      	subs	r1, r0, #1
    2ca4:	4188      	sbcs	r0, r1
    remote_command_update_package_flash_erase_done(core, result);
    2ca6:	b2c1      	uxtb	r1, r0
    2ca8:	0028      	movs	r0, r5
    2caa:	f004 fdf3 	bl	7894 <remote_command_update_package_flash_erase_done>
    rpc_interface_scatter_send(core, commandID, false, 0, NULL);
    2cae:	0031      	movs	r1, r6
    2cb0:	0028      	movs	r0, r5
    2cb2:	9400      	str	r4, [sp, #0]
    2cb4:	0023      	movs	r3, r4
    2cb6:	0022      	movs	r2, r4
    2cb8:	f7ff fb22 	bl	2300 <rpc_interface_scatter_send>
}
    2cbc:	bd7f      	pop	{r0, r1, r2, r3, r4, r5, r6, pc}

00002cbe <internal_incomming_command_service_recovery>:
{
    2cbe:	b537      	push	{r0, r1, r2, r4, r5, lr}
    2cc0:	000d      	movs	r5, r1
    2cc2:	0004      	movs	r4, r0
    remote_command_service_recovery(core);
    2cc4:	f019 fcaa 	bl	1c61c <remote_command_service_recovery>
    rpc_interface_scatter_send(core, commandID, false, 0, NULL);
    2cc8:	2200      	movs	r2, #0
    2cca:	0029      	movs	r1, r5
    2ccc:	9200      	str	r2, [sp, #0]
    2cce:	0013      	movs	r3, r2
    2cd0:	0020      	movs	r0, r4
    2cd2:	f7ff fb15 	bl	2300 <rpc_interface_scatter_send>
}
    2cd6:	bd37      	pop	{r0, r1, r2, r4, r5, pc}

00002cd8 <internal_incomming_command_cring_ind>:
{
    2cd8:	b537      	push	{r0, r1, r2, r4, r5, lr}
    2cda:	000d      	movs	r5, r1
    2cdc:	0004      	movs	r4, r0
    remote_command_cring_ind(core);
    2cde:	f019 fd8d 	bl	1c7fc <remote_command_cring_ind>
    rpc_interface_scatter_send(core, commandID, false, 0, NULL);
    2ce2:	2200      	movs	r2, #0
    2ce4:	0029      	movs	r1, r5
    2ce6:	9200      	str	r2, [sp, #0]
    2ce8:	0013      	movs	r3, r2
    2cea:	0020      	movs	r0, r4
    2cec:	f7ff fb08 	bl	2300 <rpc_interface_scatter_send>
}
    2cf0:	bd37      	pop	{r0, r1, r2, r4, r5, pc}

00002cf2 <internal_incomming_command_pdp_act_or_deact_result_ind>:
{
    2cf2:	b5f0      	push	{r4, r5, r6, r7, lr}
    uint16 buffer_pos = 0;
    2cf4:	250e      	movs	r5, #14
    2cf6:	2400      	movs	r4, #0
{
    2cf8:	b089      	sub	sp, #36	; 0x24
    uint16 buffer_pos = 0;
    2cfa:	ab04      	add	r3, sp, #16
    2cfc:	18ed      	adds	r5, r5, r3
{
    2cfe:	0007      	movs	r7, r0
    2d00:	9103      	str	r1, [sp, #12]
    cid = (uint8)rpc_get_int8(data, &buffer_pos);
    2d02:	0010      	movs	r0, r2
    2d04:	0029      	movs	r1, r5
{
    2d06:	0016      	movs	r6, r2
    uint16 buffer_pos = 0;
    2d08:	802c      	strh	r4, [r5, #0]
    cid = (uint8)rpc_get_int8(data, &buffer_pos);
    2d0a:	f003 fc58 	bl	65be <rpc_get_int8>
    state = (uint8)rpc_get_int8(data, &buffer_pos);
    2d0e:	0029      	movs	r1, r5
    cid = (uint8)rpc_get_int8(data, &buffer_pos);
    2d10:	9004      	str	r0, [sp, #16]
    state = (uint8)rpc_get_int8(data, &buffer_pos);
    2d12:	0030      	movs	r0, r6
    2d14:	f003 fc53 	bl	65be <rpc_get_int8>
    result = (uint8)rpc_get_int8(data, &buffer_pos);
    2d18:	0029      	movs	r1, r5
    state = (uint8)rpc_get_int8(data, &buffer_pos);
    2d1a:	9005      	str	r0, [sp, #20]
    result = (uint8)rpc_get_int8(data, &buffer_pos);
    2d1c:	0030      	movs	r0, r6
    2d1e:	f003 fc4e 	bl	65be <rpc_get_int8>
    remote_command_pdp_act_or_deact_result_ind(core, cid, state, result);
    2d22:	466a      	mov	r2, sp
    2d24:	4669      	mov	r1, sp
    2d26:	b2c3      	uxtb	r3, r0
    2d28:	7d12      	ldrb	r2, [r2, #20]
    2d2a:	0038      	movs	r0, r7
    2d2c:	7c09      	ldrb	r1, [r1, #16]
    2d2e:	f019 fc9f 	bl	1c670 <remote_command_pdp_act_or_deact_result_ind>
    rpc_interface_scatter_send(core, commandID, false, 0, NULL);
    2d32:	9400      	str	r4, [sp, #0]
    2d34:	0023      	movs	r3, r4
    2d36:	0022      	movs	r2, r4
    2d38:	9903      	ldr	r1, [sp, #12]
    2d3a:	0038      	movs	r0, r7
    2d3c:	f7ff fae0 	bl	2300 <rpc_interface_scatter_send>
}
    2d40:	b009      	add	sp, #36	; 0x24
    2d42:	bdf0      	pop	{r4, r5, r6, r7, pc}

00002d44 <internal_incomming_command_edrx_changed_ind>:
{
    2d44:	b5f0      	push	{r4, r5, r6, r7, lr}
    uint16 buffer_pos = 0;
    2d46:	240e      	movs	r4, #14
    2d48:	2600      	movs	r6, #0
{
    2d4a:	b08b      	sub	sp, #44	; 0x2c
    uint16 buffer_pos = 0;
    2d4c:	ab06      	add	r3, sp, #24
    2d4e:	18e4      	adds	r4, r4, r3
{
    2d50:	9003      	str	r0, [sp, #12]
    2d52:	9104      	str	r1, [sp, #16]
    type = (uint8)rpc_get_int8(data, &buffer_pos);
    2d54:	0010      	movs	r0, r2
    2d56:	0021      	movs	r1, r4
{
    2d58:	0015      	movs	r5, r2
    uint16 buffer_pos = 0;
    2d5a:	8026      	strh	r6, [r4, #0]
    type = (uint8)rpc_get_int8(data, &buffer_pos);
    2d5c:	f003 fc2f 	bl	65be <rpc_get_int8>
    requested_edrx_value = (uint8)rpc_get_int8(data, &buffer_pos);
    2d60:	0021      	movs	r1, r4
    type = (uint8)rpc_get_int8(data, &buffer_pos);
    2d62:	9005      	str	r0, [sp, #20]
    requested_edrx_value = (uint8)rpc_get_int8(data, &buffer_pos);
    2d64:	0028      	movs	r0, r5
    2d66:	f003 fc2a 	bl	65be <rpc_get_int8>
    nw_provided_edrx_value = (uint8)rpc_get_int8(data, &buffer_pos);
    2d6a:	0021      	movs	r1, r4
    requested_edrx_value = (uint8)rpc_get_int8(data, &buffer_pos);
    2d6c:	9006      	str	r0, [sp, #24]
    nw_provided_edrx_value = (uint8)rpc_get_int8(data, &buffer_pos);
    2d6e:	0028      	movs	r0, r5
    2d70:	f003 fc25 	bl	65be <rpc_get_int8>
    paging_time_window = (uint8)rpc_get_int8(data, &buffer_pos);
    2d74:	0021      	movs	r1, r4
    nw_provided_edrx_value = (uint8)rpc_get_int8(data, &buffer_pos);
    2d76:	9007      	str	r0, [sp, #28]
    paging_time_window = (uint8)rpc_get_int8(data, &buffer_pos);
    2d78:	0028      	movs	r0, r5
    2d7a:	f003 fc20 	bl	65be <rpc_get_int8>
    requested_paging_time_window = (uint8)rpc_get_int8(data, &buffer_pos);
    2d7e:	0021      	movs	r1, r4
    paging_time_window = (uint8)rpc_get_int8(data, &buffer_pos);
    2d80:	0007      	movs	r7, r0
    requested_paging_time_window = (uint8)rpc_get_int8(data, &buffer_pos);
    2d82:	0028      	movs	r0, r5
    2d84:	f003 fc1b 	bl	65be <rpc_get_int8>
    remote_command_edrx_changed_ind(core, type, requested_edrx_value, nw_provided_edrx_value, paging_time_window, requested_paging_time_window);
    2d88:	466b      	mov	r3, sp
    2d8a:	466a      	mov	r2, sp
    2d8c:	4669      	mov	r1, sp
    2d8e:	b2c0      	uxtb	r0, r0
    2d90:	b2ff      	uxtb	r7, r7
    2d92:	7f1b      	ldrb	r3, [r3, #28]
    2d94:	7e12      	ldrb	r2, [r2, #24]
    2d96:	7d09      	ldrb	r1, [r1, #20]
    2d98:	9001      	str	r0, [sp, #4]
    2d9a:	9700      	str	r7, [sp, #0]
    2d9c:	9803      	ldr	r0, [sp, #12]
    2d9e:	f019 fcbd 	bl	1c71c <remote_command_edrx_changed_ind>
    rpc_interface_scatter_send(core, commandID, false, 0, NULL);
    2da2:	9600      	str	r6, [sp, #0]
    2da4:	0033      	movs	r3, r6
    2da6:	0032      	movs	r2, r6
    2da8:	9904      	ldr	r1, [sp, #16]
    2daa:	9803      	ldr	r0, [sp, #12]
    2dac:	f7ff faa8 	bl	2300 <rpc_interface_scatter_send>
}
    2db0:	b00b      	add	sp, #44	; 0x2c
    2db2:	bdf0      	pop	{r4, r5, r6, r7, pc}

00002db4 <internal_incomming_command_radiotest_response>:
{
    2db4:	b5f0      	push	{r4, r5, r6, r7, lr}
    uint16 buffer_pos = 0;
    2db6:	250e      	movs	r5, #14
    2db8:	2400      	movs	r4, #0
{
    2dba:	b089      	sub	sp, #36	; 0x24
    uint16 buffer_pos = 0;
    2dbc:	ab04      	add	r3, sp, #16
    2dbe:	18ed      	adds	r5, r5, r3
{
    2dc0:	0007      	movs	r7, r0
    2dc2:	9104      	str	r1, [sp, #16]
    retcode = (uint8)rpc_get_int8(data, &buffer_pos);
    2dc4:	0010      	movs	r0, r2
    2dc6:	0029      	movs	r1, r5
{
    2dc8:	0016      	movs	r6, r2
    uint16 buffer_pos = 0;
    2dca:	802c      	strh	r4, [r5, #0]
    retcode = (uint8)rpc_get_int8(data, &buffer_pos);
    2dcc:	f003 fbf7 	bl	65be <rpc_get_int8>
    retdata_length = (uint16)rpc_get_int16(data, &buffer_pos);
    2dd0:	0029      	movs	r1, r5
    retcode = (uint8)rpc_get_int8(data, &buffer_pos);
    2dd2:	9005      	str	r0, [sp, #20]
    retdata_length = (uint16)rpc_get_int16(data, &buffer_pos);
    2dd4:	0030      	movs	r0, r6
    2dd6:	f003 fbe3 	bl	65a0 <rpc_get_int16>
    2dda:	b283      	uxth	r3, r0
    retdata = (uint8 *)rpc_get_buffer(data, &buffer_pos, retdata_length);
    2ddc:	001a      	movs	r2, r3
    2dde:	0029      	movs	r1, r5
    2de0:	0030      	movs	r0, r6
    retdata_length = (uint16)rpc_get_int16(data, &buffer_pos);
    2de2:	9303      	str	r3, [sp, #12]
    retdata = (uint8 *)rpc_get_buffer(data, &buffer_pos, retdata_length);
    2de4:	f003 fba8 	bl	6538 <rpc_get_buffer>
    remote_command_radiotest_response(core, retcode, retdata_length, retdata);
    2de8:	466a      	mov	r2, sp
    retdata = (uint8 *)rpc_get_buffer(data, &buffer_pos, retdata_length);
    2dea:	0003      	movs	r3, r0
    remote_command_radiotest_response(core, retcode, retdata_length, retdata);
    2dec:	7d11      	ldrb	r1, [r2, #20]
    2dee:	0038      	movs	r0, r7
    2df0:	9a03      	ldr	r2, [sp, #12]
    2df2:	f018 ff73 	bl	1bcdc <remote_command_radiotest_response>
    rpc_interface_scatter_send(core, commandID, false, 0, NULL);
    2df6:	9400      	str	r4, [sp, #0]
    2df8:	0023      	movs	r3, r4
    2dfa:	0022      	movs	r2, r4
    2dfc:	9904      	ldr	r1, [sp, #16]
    2dfe:	0038      	movs	r0, r7
    2e00:	f7ff fa7e 	bl	2300 <rpc_interface_scatter_send>
}
    2e04:	b009      	add	sp, #36	; 0x24
    2e06:	bdf0      	pop	{r4, r5, r6, r7, pc}

00002e08 <internal_incomming_command_sms_cmt_pdu_ind>:
{
    2e08:	b5f0      	push	{r4, r5, r6, r7, lr}
    uint16 buffer_pos = 0;
    2e0a:	250e      	movs	r5, #14
    2e0c:	2400      	movs	r4, #0
{
    2e0e:	b089      	sub	sp, #36	; 0x24
    uint16 buffer_pos = 0;
    2e10:	ab04      	add	r3, sp, #16
    2e12:	18ed      	adds	r5, r5, r3
{
    2e14:	0007      	movs	r7, r0
    2e16:	9104      	str	r1, [sp, #16]
    alpha = (uint8)rpc_get_int8(data, &buffer_pos);
    2e18:	0010      	movs	r0, r2
    2e1a:	0029      	movs	r1, r5
{
    2e1c:	0016      	movs	r6, r2
    uint16 buffer_pos = 0;
    2e1e:	802c      	strh	r4, [r5, #0]
    alpha = (uint8)rpc_get_int8(data, &buffer_pos);
    2e20:	f003 fbcd 	bl	65be <rpc_get_int8>
    pdu_length = (uint16)rpc_get_int16(data, &buffer_pos);
    2e24:	0029      	movs	r1, r5
    alpha = (uint8)rpc_get_int8(data, &buffer_pos);
    2e26:	9005      	str	r0, [sp, #20]
    pdu_length = (uint16)rpc_get_int16(data, &buffer_pos);
    2e28:	0030      	movs	r0, r6
    2e2a:	f003 fbb9 	bl	65a0 <rpc_get_int16>
    2e2e:	b283      	uxth	r3, r0
    pdu = (uint8 *)rpc_get_buffer(data, &buffer_pos, pdu_length);
    2e30:	001a      	movs	r2, r3
    2e32:	0029      	movs	r1, r5
    2e34:	0030      	movs	r0, r6
    pdu_length = (uint16)rpc_get_int16(data, &buffer_pos);
    2e36:	9303      	str	r3, [sp, #12]
    pdu = (uint8 *)rpc_get_buffer(data, &buffer_pos, pdu_length);
    2e38:	f003 fb7e 	bl	6538 <rpc_get_buffer>
    remote_command_sms_cmt_pdu_ind(core, alpha, pdu_length, pdu);
    2e3c:	466a      	mov	r2, sp
    pdu = (uint8 *)rpc_get_buffer(data, &buffer_pos, pdu_length);
    2e3e:	0003      	movs	r3, r0
    remote_command_sms_cmt_pdu_ind(core, alpha, pdu_length, pdu);
    2e40:	7d11      	ldrb	r1, [r2, #20]
    2e42:	0038      	movs	r0, r7
    2e44:	9a03      	ldr	r2, [sp, #12]
    2e46:	f019 ff29 	bl	1cc9c <remote_command_sms_cmt_pdu_ind>
    rpc_interface_scatter_send(core, commandID, false, 0, NULL);
    2e4a:	9400      	str	r4, [sp, #0]
    2e4c:	0023      	movs	r3, r4
    2e4e:	0022      	movs	r2, r4
    2e50:	9904      	ldr	r1, [sp, #16]
    2e52:	0038      	movs	r0, r7
    2e54:	f7ff fa54 	bl	2300 <rpc_interface_scatter_send>
}
    2e58:	b009      	add	sp, #36	; 0x24
    2e5a:	bdf0      	pop	{r4, r5, r6, r7, pc}

00002e5c <internal_incomming_command_rxcalist_response>:
    remote_command_t3324_t3412_ext_value_changed_ind(core, t3324, t3412_ext);
    rpc_interface_scatter_send(core, commandID, false, 0, NULL);
}

static void internal_incomming_command_rxcalist_response(CORES core, uint16 commandID, uint8 *data)
{
    2e5c:	b5f0      	push	{r4, r5, r6, r7, lr}
    uint16 buffer_pos = 0;
    2e5e:	250e      	movs	r5, #14
    2e60:	2400      	movs	r4, #0
{
    2e62:	b089      	sub	sp, #36	; 0x24
    uint16 buffer_pos = 0;
    2e64:	ab04      	add	r3, sp, #16
    2e66:	18ed      	adds	r5, r5, r3
{
    2e68:	0007      	movs	r7, r0
    2e6a:	9104      	str	r1, [sp, #16]
    uint8 retcode;
    uint16 retdata_length;
    uint8 *retdata;
    retcode = (uint8)rpc_get_int8(data, &buffer_pos);
    2e6c:	0010      	movs	r0, r2
    2e6e:	0029      	movs	r1, r5
{
    2e70:	0016      	movs	r6, r2
    uint16 buffer_pos = 0;
    2e72:	802c      	strh	r4, [r5, #0]
    retcode = (uint8)rpc_get_int8(data, &buffer_pos);
    2e74:	f003 fba3 	bl	65be <rpc_get_int8>
    retdata_length = (uint16)rpc_get_int16(data, &buffer_pos);
    2e78:	0029      	movs	r1, r5
    retcode = (uint8)rpc_get_int8(data, &buffer_pos);
    2e7a:	9005      	str	r0, [sp, #20]
    retdata_length = (uint16)rpc_get_int16(data, &buffer_pos);
    2e7c:	0030      	movs	r0, r6
    2e7e:	f003 fb8f 	bl	65a0 <rpc_get_int16>
    2e82:	b283      	uxth	r3, r0
    retdata = (uint8 *)rpc_get_buffer(data, &buffer_pos, retdata_length);
    2e84:	001a      	movs	r2, r3
    2e86:	0029      	movs	r1, r5
    2e88:	0030      	movs	r0, r6
    retdata_length = (uint16)rpc_get_int16(data, &buffer_pos);
    2e8a:	9303      	str	r3, [sp, #12]
    retdata = (uint8 *)rpc_get_buffer(data, &buffer_pos, retdata_length);
    2e8c:	f003 fb54 	bl	6538 <rpc_get_buffer>
    remote_command_rxcalist_response(core, retcode, retdata_length, retdata);
    2e90:	466a      	mov	r2, sp
    retdata = (uint8 *)rpc_get_buffer(data, &buffer_pos, retdata_length);
    2e92:	0003      	movs	r3, r0
    remote_command_rxcalist_response(core, retcode, retdata_length, retdata);
    2e94:	7d11      	ldrb	r1, [r2, #20]
    2e96:	0038      	movs	r0, r7
    2e98:	9a03      	ldr	r2, [sp, #12]
    2e9a:	f019 f841 	bl	1bf20 <remote_command_rxcalist_response>
    rpc_interface_scatter_send(core, commandID, false, 0, NULL);
    2e9e:	9400      	str	r4, [sp, #0]
    2ea0:	0023      	movs	r3, r4
    2ea2:	0022      	movs	r2, r4
    2ea4:	9904      	ldr	r1, [sp, #16]
    2ea6:	0038      	movs	r0, r7
    2ea8:	f7ff fa2a 	bl	2300 <rpc_interface_scatter_send>
}
    2eac:	b009      	add	sp, #36	; 0x24
    2eae:	bdf0      	pop	{r4, r5, r6, r7, pc}

00002eb0 <internal_incomming_command_nonip_recvfrom>:
{
    2eb0:	b5f0      	push	{r4, r5, r6, r7, lr}
    uint16 buffer_pos = 0;
    2eb2:	240e      	movs	r4, #14
    2eb4:	2500      	movs	r5, #0
{
    2eb6:	b089      	sub	sp, #36	; 0x24
    uint16 buffer_pos = 0;
    2eb8:	ab04      	add	r3, sp, #16
    2eba:	18e4      	adds	r4, r4, r3
{
    2ebc:	0007      	movs	r7, r0
    2ebe:	9104      	str	r1, [sp, #16]
    cid = (uint8)rpc_get_int8(data, &buffer_pos);
    2ec0:	0010      	movs	r0, r2
    2ec2:	0021      	movs	r1, r4
{
    2ec4:	0016      	movs	r6, r2
    uint16 buffer_pos = 0;
    2ec6:	8025      	strh	r5, [r4, #0]
    cid = (uint8)rpc_get_int8(data, &buffer_pos);
    2ec8:	f003 fb79 	bl	65be <rpc_get_int8>
    message_length = (uint16)rpc_get_int16(data, &buffer_pos);
    2ecc:	0021      	movs	r1, r4
    cid = (uint8)rpc_get_int8(data, &buffer_pos);
    2ece:	9005      	str	r0, [sp, #20]
    message_length = (uint16)rpc_get_int16(data, &buffer_pos);
    2ed0:	0030      	movs	r0, r6
    2ed2:	f003 fb65 	bl	65a0 <rpc_get_int16>
    2ed6:	b283      	uxth	r3, r0
    message = (uint8 *)rpc_get_buffer(data, &buffer_pos, message_length);
    2ed8:	001a      	movs	r2, r3
    2eda:	0021      	movs	r1, r4
    2edc:	0030      	movs	r0, r6
    message_length = (uint16)rpc_get_int16(data, &buffer_pos);
    2ede:	9302      	str	r3, [sp, #8]
    message = (uint8 *)rpc_get_buffer(data, &buffer_pos, message_length);
    2ee0:	f003 fb2a 	bl	6538 <rpc_get_buffer>
    cplane_pdu = (bool)rpc_get_int8(data, &buffer_pos);
    2ee4:	0021      	movs	r1, r4
    message = (uint8 *)rpc_get_buffer(data, &buffer_pos, message_length);
    2ee6:	9003      	str	r0, [sp, #12]
    cplane_pdu = (bool)rpc_get_int8(data, &buffer_pos);
    2ee8:	0030      	movs	r0, r6
    2eea:	f003 fb68 	bl	65be <rpc_get_int8>
    remote_command_nonip_recvfrom(core, cid, message_length, message, cplane_pdu);
    2eee:	466b      	mov	r3, sp
    2ef0:	7d19      	ldrb	r1, [r3, #20]
    cplane_pdu = (bool)rpc_get_int8(data, &buffer_pos);
    2ef2:	1e43      	subs	r3, r0, #1
    2ef4:	4198      	sbcs	r0, r3
    remote_command_nonip_recvfrom(core, cid, message_length, message, cplane_pdu);
    2ef6:	9a02      	ldr	r2, [sp, #8]
    2ef8:	9000      	str	r0, [sp, #0]
    2efa:	9b03      	ldr	r3, [sp, #12]
    2efc:	0038      	movs	r0, r7
    2efe:	f018 fe83 	bl	1bc08 <remote_command_nonip_recvfrom>
    rpc_interface_scatter_send(core, commandID, false, 0, NULL);
    2f02:	9500      	str	r5, [sp, #0]
    2f04:	002b      	movs	r3, r5
    2f06:	002a      	movs	r2, r5
    2f08:	9904      	ldr	r1, [sp, #16]
    2f0a:	0038      	movs	r0, r7
    2f0c:	f7ff f9f8 	bl	2300 <rpc_interface_scatter_send>
}
    2f10:	b009      	add	sp, #36	; 0x24
    2f12:	bdf0      	pop	{r4, r5, r6, r7, pc}

00002f14 <internal_incomming_command_pin_result_ind>:
{
    2f14:	b5f0      	push	{r4, r5, r6, r7, lr}
    uint16 buffer_pos = 0;
    2f16:	250e      	movs	r5, #14
    2f18:	2400      	movs	r4, #0
{
    2f1a:	b087      	sub	sp, #28
    uint16 buffer_pos = 0;
    2f1c:	ab02      	add	r3, sp, #8
    2f1e:	18ed      	adds	r5, r5, r3
{
    2f20:	0006      	movs	r6, r0
    2f22:	9102      	str	r1, [sp, #8]
    pin_result = (uint8)rpc_get_int8(data, &buffer_pos);
    2f24:	0010      	movs	r0, r2
    2f26:	0029      	movs	r1, r5
{
    2f28:	0017      	movs	r7, r2
    uint16 buffer_pos = 0;
    2f2a:	802c      	strh	r4, [r5, #0]
    pin_result = (uint8)rpc_get_int8(data, &buffer_pos);
    2f2c:	f003 fb47 	bl	65be <rpc_get_int8>
    retries_remaining = (uint8)rpc_get_int8(data, &buffer_pos);
    2f30:	0029      	movs	r1, r5
    pin_result = (uint8)rpc_get_int8(data, &buffer_pos);
    2f32:	9003      	str	r0, [sp, #12]
    retries_remaining = (uint8)rpc_get_int8(data, &buffer_pos);
    2f34:	0038      	movs	r0, r7
    2f36:	f003 fb42 	bl	65be <rpc_get_int8>
    remote_command_pin_result_ind(core, pin_result, retries_remaining);
    2f3a:	466b      	mov	r3, sp
    2f3c:	b2c2      	uxtb	r2, r0
    2f3e:	7b19      	ldrb	r1, [r3, #12]
    2f40:	0030      	movs	r0, r6
    2f42:	f019 f8bd 	bl	1c0c0 <remote_command_pin_result_ind>
    rpc_interface_scatter_send(core, commandID, false, 0, NULL);
    2f46:	9400      	str	r4, [sp, #0]
    2f48:	0023      	movs	r3, r4
    2f4a:	0022      	movs	r2, r4
    2f4c:	9902      	ldr	r1, [sp, #8]
    2f4e:	0030      	movs	r0, r6
    2f50:	f7ff f9d6 	bl	2300 <rpc_interface_scatter_send>
}
    2f54:	b007      	add	sp, #28
    2f56:	bdf0      	pop	{r4, r5, r6, r7, pc}

00002f58 <internal_incomming_command_kv_apps_cache_flushed>:
{
    2f58:	b5f0      	push	{r4, r5, r6, r7, lr}
    uint16 buffer_pos = 0;
    2f5a:	250e      	movs	r5, #14
    2f5c:	2400      	movs	r4, #0
{
    2f5e:	b089      	sub	sp, #36	; 0x24
    uint16 buffer_pos = 0;
    2f60:	ab04      	add	r3, sp, #16
    2f62:	18ed      	adds	r5, r5, r3
{
    2f64:	0007      	movs	r7, r0
    2f66:	9105      	str	r1, [sp, #20]
    kv_cache_start = (uint32)rpc_get_int32(data, &buffer_pos);
    2f68:	0010      	movs	r0, r2
    2f6a:	0029      	movs	r1, r5
{
    2f6c:	0016      	movs	r6, r2
    uint16 buffer_pos = 0;
    2f6e:	802c      	strh	r4, [r5, #0]
    kv_cache_start = (uint32)rpc_get_int32(data, &buffer_pos);
    2f70:	f003 fb03 	bl	657a <rpc_get_int32>
    kv_processed_end = (uint32)rpc_get_int32(data, &buffer_pos);
    2f74:	0029      	movs	r1, r5
    kv_cache_start = (uint32)rpc_get_int32(data, &buffer_pos);
    2f76:	9003      	str	r0, [sp, #12]
    kv_processed_end = (uint32)rpc_get_int32(data, &buffer_pos);
    2f78:	0030      	movs	r0, r6
    2f7a:	f003 fafe 	bl	657a <rpc_get_int32>
    kv_return_code = (uint16)rpc_get_int16(data, &buffer_pos);
    2f7e:	0029      	movs	r1, r5
    kv_processed_end = (uint32)rpc_get_int32(data, &buffer_pos);
    2f80:	9004      	str	r0, [sp, #16]
    kv_return_code = (uint16)rpc_get_int16(data, &buffer_pos);
    2f82:	0030      	movs	r0, r6
    2f84:	f003 fb0c 	bl	65a0 <rpc_get_int16>
    remote_command_kv_apps_cache_flushed(core, kv_cache_start, kv_processed_end, kv_return_code);
    2f88:	9a04      	ldr	r2, [sp, #16]
    2f8a:	b283      	uxth	r3, r0
    2f8c:	9903      	ldr	r1, [sp, #12]
    2f8e:	0038      	movs	r0, r7
    2f90:	f004 fb4c 	bl	762c <remote_command_kv_apps_cache_flushed>
    rpc_interface_scatter_send(core, commandID, false, 0, NULL);
    2f94:	9400      	str	r4, [sp, #0]
    2f96:	0023      	movs	r3, r4
    2f98:	0022      	movs	r2, r4
    2f9a:	9905      	ldr	r1, [sp, #20]
    2f9c:	0038      	movs	r0, r7
    2f9e:	f7ff f9af 	bl	2300 <rpc_interface_scatter_send>
}
    2fa2:	b009      	add	sp, #36	; 0x24
    2fa4:	bdf0      	pop	{r4, r5, r6, r7, pc}

00002fa6 <internal_incomming_command_ip_info>:
{
    2fa6:	b5f0      	push	{r4, r5, r6, r7, lr}
    uint16 buffer_pos = 0;
    2fa8:	240e      	movs	r4, #14
    2faa:	2500      	movs	r5, #0
{
    2fac:	b089      	sub	sp, #36	; 0x24
    uint16 buffer_pos = 0;
    2fae:	ab04      	add	r3, sp, #16
    2fb0:	18e4      	adds	r4, r4, r3
{
    2fb2:	0007      	movs	r7, r0
    2fb4:	9102      	str	r1, [sp, #8]
    cid = (uint8)rpc_get_int8(data, &buffer_pos);
    2fb6:	0010      	movs	r0, r2
    2fb8:	0021      	movs	r1, r4
{
    2fba:	0016      	movs	r6, r2
    uint16 buffer_pos = 0;
    2fbc:	8025      	strh	r5, [r4, #0]
    cid = (uint8)rpc_get_int8(data, &buffer_pos);
    2fbe:	f003 fafe 	bl	65be <rpc_get_int8>
    current_ip_type = (uint8)rpc_get_int8(data, &buffer_pos);
    2fc2:	0021      	movs	r1, r4
    cid = (uint8)rpc_get_int8(data, &buffer_pos);
    2fc4:	9003      	str	r0, [sp, #12]
    current_ip_type = (uint8)rpc_get_int8(data, &buffer_pos);
    2fc6:	0030      	movs	r0, r6
    2fc8:	f003 faf9 	bl	65be <rpc_get_int8>
    requested_ip_type = (uint8)rpc_get_int8(data, &buffer_pos);
    2fcc:	0021      	movs	r1, r4
    current_ip_type = (uint8)rpc_get_int8(data, &buffer_pos);
    2fce:	9004      	str	r0, [sp, #16]
    requested_ip_type = (uint8)rpc_get_int8(data, &buffer_pos);
    2fd0:	0030      	movs	r0, r6
    2fd2:	f003 faf4 	bl	65be <rpc_get_int8>
    failure_cause = (uint8)rpc_get_int8(data, &buffer_pos);
    2fd6:	0021      	movs	r1, r4
    requested_ip_type = (uint8)rpc_get_int8(data, &buffer_pos);
    2fd8:	9005      	str	r0, [sp, #20]
    failure_cause = (uint8)rpc_get_int8(data, &buffer_pos);
    2fda:	0030      	movs	r0, r6
    2fdc:	f003 faef 	bl	65be <rpc_get_int8>
    remote_command_ip_info(core, cid, current_ip_type, requested_ip_type, failure_cause);
    2fe0:	466b      	mov	r3, sp
    2fe2:	466a      	mov	r2, sp
    2fe4:	4669      	mov	r1, sp
    2fe6:	b2c0      	uxtb	r0, r0
    2fe8:	7d1b      	ldrb	r3, [r3, #20]
    2fea:	7c12      	ldrb	r2, [r2, #16]
    2fec:	7b09      	ldrb	r1, [r1, #12]
    2fee:	9000      	str	r0, [sp, #0]
    2ff0:	0038      	movs	r0, r7
    2ff2:	f019 fc9b 	bl	1c92c <remote_command_ip_info>
    rpc_interface_scatter_send(core, commandID, false, 0, NULL);
    2ff6:	9500      	str	r5, [sp, #0]
    2ff8:	002b      	movs	r3, r5
    2ffa:	002a      	movs	r2, r5
    2ffc:	9902      	ldr	r1, [sp, #8]
    2ffe:	0038      	movs	r0, r7
    3000:	f7ff f97e 	bl	2300 <rpc_interface_scatter_send>
}
    3004:	b009      	add	sp, #36	; 0x24
    3006:	bdf0      	pop	{r4, r5, r6, r7, pc}

00003008 <internal_incomming_command_ciot_opt_status_ind>:
{
    3008:	b5f0      	push	{r4, r5, r6, r7, lr}
    uint16 buffer_pos = 0;
    300a:	250e      	movs	r5, #14
    300c:	2400      	movs	r4, #0
{
    300e:	b087      	sub	sp, #28
    uint16 buffer_pos = 0;
    3010:	ab02      	add	r3, sp, #8
    3012:	18ed      	adds	r5, r5, r3
{
    3014:	0006      	movs	r6, r0
    3016:	9102      	str	r1, [sp, #8]
    cplane_opt_supported = (bool)rpc_get_int8(data, &buffer_pos);
    3018:	0010      	movs	r0, r2
    301a:	0029      	movs	r1, r5
{
    301c:	0017      	movs	r7, r2
    uint16 buffer_pos = 0;
    301e:	802c      	strh	r4, [r5, #0]
    cplane_opt_supported = (bool)rpc_get_int8(data, &buffer_pos);
    3020:	f003 facd 	bl	65be <rpc_get_int8>
    uplane_opt_supported = (bool)rpc_get_int8(data, &buffer_pos);
    3024:	0029      	movs	r1, r5
    cplane_opt_supported = (bool)rpc_get_int8(data, &buffer_pos);
    3026:	9003      	str	r0, [sp, #12]
    uplane_opt_supported = (bool)rpc_get_int8(data, &buffer_pos);
    3028:	0038      	movs	r0, r7
    302a:	f003 fac8 	bl	65be <rpc_get_int8>
    cplane_opt_supported = (bool)rpc_get_int8(data, &buffer_pos);
    302e:	9903      	ldr	r1, [sp, #12]
    uplane_opt_supported = (bool)rpc_get_int8(data, &buffer_pos);
    3030:	1e42      	subs	r2, r0, #1
    3032:	4190      	sbcs	r0, r2
    cplane_opt_supported = (bool)rpc_get_int8(data, &buffer_pos);
    3034:	1e4b      	subs	r3, r1, #1
    3036:	4199      	sbcs	r1, r3
    remote_command_ciot_opt_status_ind(core, cplane_opt_supported, uplane_opt_supported);
    3038:	b2c2      	uxtb	r2, r0
    303a:	b2c9      	uxtb	r1, r1
    303c:	0030      	movs	r0, r6
    303e:	f019 fcc1 	bl	1c9c4 <remote_command_ciot_opt_status_ind>
    rpc_interface_scatter_send(core, commandID, false, 0, NULL);
    3042:	9400      	str	r4, [sp, #0]
    3044:	0023      	movs	r3, r4
    3046:	0022      	movs	r2, r4
    3048:	9902      	ldr	r1, [sp, #8]
    304a:	0030      	movs	r0, r6
    304c:	f7ff f958 	bl	2300 <rpc_interface_scatter_send>
}
    3050:	b007      	add	sp, #28
    3052:	bdf0      	pop	{r4, r5, r6, r7, pc}

00003054 <internal_incomming_command_driver_adc_read_response>:
{
    3054:	b5f0      	push	{r4, r5, r6, r7, lr}
    uint16 buffer_pos = 0;
    3056:	250e      	movs	r5, #14
    3058:	2400      	movs	r4, #0
{
    305a:	b087      	sub	sp, #28
    uint16 buffer_pos = 0;
    305c:	ab02      	add	r3, sp, #8
    305e:	18ed      	adds	r5, r5, r3
{
    3060:	0006      	movs	r6, r0
    3062:	9103      	str	r1, [sp, #12]
    reading = (uint32)rpc_get_int32(data, &buffer_pos);
    3064:	0010      	movs	r0, r2
    3066:	0029      	movs	r1, r5
{
    3068:	0017      	movs	r7, r2
    uint16 buffer_pos = 0;
    306a:	802c      	strh	r4, [r5, #0]
    reading = (uint32)rpc_get_int32(data, &buffer_pos);
    306c:	f003 fa85 	bl	657a <rpc_get_int32>
    ret_value = (uint8)rpc_get_int8(data, &buffer_pos);
    3070:	0029      	movs	r1, r5
    reading = (uint32)rpc_get_int32(data, &buffer_pos);
    3072:	9002      	str	r0, [sp, #8]
    ret_value = (uint8)rpc_get_int8(data, &buffer_pos);
    3074:	0038      	movs	r0, r7
    3076:	f003 faa2 	bl	65be <rpc_get_int8>
    remote_command_driver_adc_read_response(core, reading, ret_value);
    307a:	9902      	ldr	r1, [sp, #8]
    307c:	b2c2      	uxtb	r2, r0
    307e:	0030      	movs	r0, r6
    3080:	f018 fbac 	bl	1b7dc <remote_command_driver_adc_read_response>
    rpc_interface_scatter_send(core, commandID, false, 0, NULL);
    3084:	9400      	str	r4, [sp, #0]
    3086:	0023      	movs	r3, r4
    3088:	0022      	movs	r2, r4
    308a:	9903      	ldr	r1, [sp, #12]
    308c:	0030      	movs	r0, r6
    308e:	f7ff f937 	bl	2300 <rpc_interface_scatter_send>
}
    3092:	b007      	add	sp, #28
    3094:	bdf0      	pop	{r4, r5, r6, r7, pc}

00003096 <internal_incomming_command_t3324_t3412_ext_value_changed_ind>:
{
    3096:	b5f0      	push	{r4, r5, r6, r7, lr}
    uint16 buffer_pos = 0;
    3098:	250e      	movs	r5, #14
    309a:	2400      	movs	r4, #0
{
    309c:	b087      	sub	sp, #28
    uint16 buffer_pos = 0;
    309e:	ab02      	add	r3, sp, #8
    30a0:	18ed      	adds	r5, r5, r3
{
    30a2:	0006      	movs	r6, r0
    30a4:	9102      	str	r1, [sp, #8]
    t3324 = (uint16)rpc_get_int16(data, &buffer_pos);
    30a6:	0010      	movs	r0, r2
    30a8:	0029      	movs	r1, r5
{
    30aa:	0017      	movs	r7, r2
    uint16 buffer_pos = 0;
    30ac:	802c      	strh	r4, [r5, #0]
    t3324 = (uint16)rpc_get_int16(data, &buffer_pos);
    30ae:	f003 fa77 	bl	65a0 <rpc_get_int16>
    t3412_ext = (uint16)rpc_get_int16(data, &buffer_pos);
    30b2:	0029      	movs	r1, r5
    t3324 = (uint16)rpc_get_int16(data, &buffer_pos);
    30b4:	9003      	str	r0, [sp, #12]
    t3412_ext = (uint16)rpc_get_int16(data, &buffer_pos);
    30b6:	0038      	movs	r0, r7
    30b8:	f003 fa72 	bl	65a0 <rpc_get_int16>
    remote_command_t3324_t3412_ext_value_changed_ind(core, t3324, t3412_ext);
    30bc:	466b      	mov	r3, sp
    30be:	b282      	uxth	r2, r0
    30c0:	8999      	ldrh	r1, [r3, #12]
    30c2:	0030      	movs	r0, r6
    30c4:	f019 fa06 	bl	1c4d4 <remote_command_t3324_t3412_ext_value_changed_ind>
    rpc_interface_scatter_send(core, commandID, false, 0, NULL);
    30c8:	9400      	str	r4, [sp, #0]
    30ca:	0023      	movs	r3, r4
    30cc:	0022      	movs	r2, r4
    30ce:	9902      	ldr	r1, [sp, #8]
    30d0:	0030      	movs	r0, r6
    30d2:	f7ff f915 	bl	2300 <rpc_interface_scatter_send>
}
    30d6:	b007      	add	sp, #28
    30d8:	bdf0      	pop	{r4, r5, r6, r7, pc}
	...

000030dc <rpc_auto_generated_init>:
        rpc_auto_generated_handles[i].free = true;
    30dc:	2201      	movs	r2, #1
    30de:	4b02      	ldr	r3, [pc, #8]	; (30e8 <rpc_auto_generated_init+0xc>)
    30e0:	701a      	strb	r2, [r3, #0]
    30e2:	709a      	strb	r2, [r3, #2]
    30e4:	711a      	strb	r2, [r3, #4]
}
    30e6:	4770      	bx	lr
    30e8:	01002e34 	.word	0x01002e34

000030ec <command_get_dieid>:
{
    30ec:	b5f0      	push	{r4, r5, r6, r7, lr}
    30ee:	4684      	mov	ip, r0
    30f0:	001c      	movs	r4, r3
    info.num_sections = 2;
    30f2:	2302      	movs	r3, #2
{
    30f4:	000e      	movs	r6, r1
    30f6:	0017      	movs	r7, r2
    30f8:	b08b      	sub	sp, #44	; 0x2c
    info.num_sections = 2;
    30fa:	ad02      	add	r5, sp, #8
    rpc_init_receive_section(&get_sections[0], (uint8 *)get_dieid_result, sizeof(uint8), NULL);
    30fc:	4661      	mov	r1, ip
    info.sections = get_sections;
    30fe:	a804      	add	r0, sp, #16
    info.num_sections = 2;
    3100:	712b      	strb	r3, [r5, #4]
    rpc_init_receive_section(&get_sections[0], (uint8 *)get_dieid_result, sizeof(uint8), NULL);
    3102:	2201      	movs	r2, #1
    3104:	2300      	movs	r3, #0
    info.sections = get_sections;
    3106:	9002      	str	r0, [sp, #8]
    rpc_init_receive_section(&get_sections[0], (uint8 *)get_dieid_result, sizeof(uint8), NULL);
    3108:	f7ff f979 	bl	23fe <rpc_init_receive_section>
    rpc_init_receive_section(&get_sections[1], (uint8 *)dieid, dieid_max_length, dieid_length);
    310c:	0021      	movs	r1, r4
    310e:	003b      	movs	r3, r7
    3110:	0032      	movs	r2, r6
    3112:	a807      	add	r0, sp, #28
    3114:	f7ff f973 	bl	23fe <rpc_init_receive_section>
    RPC_ERR rpc_return = rpc_command_claim(CORES_SECURITY_CORE);
    3118:	2000      	movs	r0, #0
    311a:	f7ff f99f 	bl	245c <rpc_command_claim>
    311e:	1e04      	subs	r4, r0, #0
    if (rpc_return != RPC_ERR_OK)
    3120:	d110      	bne.n	3144 <command_get_dieid+0x58>
    set_receive_info(CORES_SECURITY_CORE, &info);
    3122:	0029      	movs	r1, r5
    3124:	f7fe fe3c 	bl	1da0 <set_receive_info>
    rpc_interface_scatter_send(CORES_SECURITY_CORE, RPC_APPLICATION_TO_SECURITY_GET_DIEID, true, 0, NULL);
    3128:	0023      	movs	r3, r4
    312a:	0021      	movs	r1, r4
    312c:	2201      	movs	r2, #1
    312e:	0020      	movs	r0, r4
    3130:	9400      	str	r4, [sp, #0]
    3132:	f7ff f8e5 	bl	2300 <rpc_interface_scatter_send>
    rpc_blocking_loop(CORES_SECURITY_CORE);
    3136:	0020      	movs	r0, r4
    3138:	f7ff f966 	bl	2408 <rpc_blocking_loop>
    return rpc_command_release(CORES_SECURITY_CORE);
    313c:	0020      	movs	r0, r4
    313e:	f7ff f979 	bl	2434 <rpc_command_release>
    3142:	0004      	movs	r4, r0
}
    3144:	0020      	movs	r0, r4
    3146:	b00b      	add	sp, #44	; 0x2c
    3148:	bdf0      	pop	{r4, r5, r6, r7, pc}

0000314a <command_set_protocol_log_level>:
{
    314a:	b5f0      	push	{r4, r5, r6, r7, lr}
    314c:	270f      	movs	r7, #15
    info.num_sections = 1;
    314e:	2401      	movs	r4, #1
{
    3150:	b08d      	sub	sp, #52	; 0x34
    3152:	446f      	add	r7, sp
    3154:	7038      	strb	r0, [r7, #0]
    info.num_sections = 1;
    3156:	ae05      	add	r6, sp, #20
    info.sections = get_sections;
    3158:	a809      	add	r0, sp, #36	; 0x24
    rpc_init_receive_section(&get_sections[0], (uint8 *)ret_code, sizeof(uint8), NULL);
    315a:	2300      	movs	r3, #0
    315c:	0022      	movs	r2, r4
    info.sections = get_sections;
    315e:	9005      	str	r0, [sp, #20]
    info.num_sections = 1;
    3160:	7134      	strb	r4, [r6, #4]
    data_to_send[0].data_location = (uint8 *)&level;
    3162:	ad07      	add	r5, sp, #28
    rpc_init_receive_section(&get_sections[0], (uint8 *)ret_code, sizeof(uint8), NULL);
    3164:	f7ff f94b 	bl	23fe <rpc_init_receive_section>
    RPC_ERR rpc_return = rpc_command_claim(CORES_PROTOCOL_CORE);
    3168:	0020      	movs	r0, r4
    data_to_send[0].data_location = (uint8 *)&level;
    316a:	9707      	str	r7, [sp, #28]
    data_to_send[0].data_length = sizeof(level);
    316c:	80ac      	strh	r4, [r5, #4]
    RPC_ERR rpc_return = rpc_command_claim(CORES_PROTOCOL_CORE);
    316e:	f7ff f975 	bl	245c <rpc_command_claim>
    if (rpc_return != RPC_ERR_OK)
    3172:	2800      	cmp	r0, #0
    3174:	d110      	bne.n	3198 <command_set_protocol_log_level+0x4e>
    set_receive_info(CORES_PROTOCOL_CORE, &info);
    3176:	0031      	movs	r1, r6
    3178:	0020      	movs	r0, r4
    317a:	f7fe fe11 	bl	1da0 <set_receive_info>
    rpc_interface_scatter_send(CORES_PROTOCOL_CORE, RPC_APPLICATION_TO_PROTOCOL_SET_PROTOCOL_LOG_LEVEL, true, 1, data_to_send);
    317e:	0023      	movs	r3, r4
    3180:	0022      	movs	r2, r4
    3182:	0021      	movs	r1, r4
    3184:	0020      	movs	r0, r4
    3186:	9500      	str	r5, [sp, #0]
    3188:	f7ff f8ba 	bl	2300 <rpc_interface_scatter_send>
    rpc_blocking_loop(CORES_PROTOCOL_CORE);
    318c:	0020      	movs	r0, r4
    318e:	f7ff f93b 	bl	2408 <rpc_blocking_loop>
    return rpc_command_release(CORES_PROTOCOL_CORE);
    3192:	0020      	movs	r0, r4
    3194:	f7ff f94e 	bl	2434 <rpc_command_release>
}
    3198:	b00d      	add	sp, #52	; 0x34
    319a:	bdf0      	pop	{r4, r5, r6, r7, pc}

0000319c <command_set_vdd_io_level>:
{
    319c:	b5f0      	push	{r4, r5, r6, r7, lr}
    319e:	270f      	movs	r7, #15
    31a0:	b08f      	sub	sp, #60	; 0x3c
    info.num_sections = 1;
    31a2:	2401      	movs	r4, #1
{
    31a4:	000b      	movs	r3, r1
    31a6:	0011      	movs	r1, r2
    31a8:	466a      	mov	r2, sp
    31aa:	446f      	add	r7, sp
    31ac:	7038      	strb	r0, [r7, #0]
    31ae:	7393      	strb	r3, [r2, #14]
    info.sections = get_sections;
    31b0:	a807      	add	r0, sp, #28
    rpc_init_receive_section(&get_sections[0], (uint8 *)ret_code, sizeof(uint8), NULL);
    31b2:	2300      	movs	r3, #0
    31b4:	0022      	movs	r2, r4
    info.num_sections = 1;
    31b6:	ae05      	add	r6, sp, #20
    info.sections = get_sections;
    31b8:	9005      	str	r0, [sp, #20]
    info.num_sections = 1;
    31ba:	7134      	strb	r4, [r6, #4]
    rpc_init_receive_section(&get_sections[0], (uint8 *)ret_code, sizeof(uint8), NULL);
    31bc:	f7ff f91f 	bl	23fe <rpc_init_receive_section>
    data_to_send[1].data_location = (uint8 *)&level;
    31c0:	230e      	movs	r3, #14
    data_to_send[0].data_location = (uint8 *)&bank;
    31c2:	ad0a      	add	r5, sp, #40	; 0x28
    data_to_send[1].data_location = (uint8 *)&level;
    31c4:	446b      	add	r3, sp
    RPC_ERR rpc_return = rpc_command_claim(CORES_SECURITY_CORE);
    31c6:	2000      	movs	r0, #0
    data_to_send[0].data_location = (uint8 *)&bank;
    31c8:	970a      	str	r7, [sp, #40]	; 0x28
    data_to_send[0].data_length = sizeof(bank);
    31ca:	80ac      	strh	r4, [r5, #4]
    data_to_send[1].data_location = (uint8 *)&level;
    31cc:	930c      	str	r3, [sp, #48]	; 0x30
    data_to_send[1].data_length = sizeof(level);
    31ce:	81ac      	strh	r4, [r5, #12]
    RPC_ERR rpc_return = rpc_command_claim(CORES_SECURITY_CORE);
    31d0:	f7ff f944 	bl	245c <rpc_command_claim>
    31d4:	1e07      	subs	r7, r0, #0
    if (rpc_return != RPC_ERR_OK)
    31d6:	d110      	bne.n	31fa <command_set_vdd_io_level+0x5e>
    set_receive_info(CORES_SECURITY_CORE, &info);
    31d8:	0031      	movs	r1, r6
    31da:	f7fe fde1 	bl	1da0 <set_receive_info>
    rpc_interface_scatter_send(CORES_SECURITY_CORE, RPC_APPLICATION_TO_SECURITY_SET_VDD_IO_LEVEL, true, 2, data_to_send);
    31de:	2302      	movs	r3, #2
    31e0:	0022      	movs	r2, r4
    31e2:	0019      	movs	r1, r3
    31e4:	0038      	movs	r0, r7
    31e6:	9500      	str	r5, [sp, #0]
    31e8:	f7ff f88a 	bl	2300 <rpc_interface_scatter_send>
    rpc_blocking_loop(CORES_SECURITY_CORE);
    31ec:	0038      	movs	r0, r7
    31ee:	f7ff f90b 	bl	2408 <rpc_blocking_loop>
    return rpc_command_release(CORES_SECURITY_CORE);
    31f2:	0038      	movs	r0, r7
    31f4:	f7ff f91e 	bl	2434 <rpc_command_release>
    31f8:	0007      	movs	r7, r0
}
    31fa:	0038      	movs	r0, r7
    31fc:	b00f      	add	sp, #60	; 0x3c
    31fe:	bdf0      	pop	{r4, r5, r6, r7, pc}

00003200 <command_set_security_log_level>:
{
    3200:	b5f0      	push	{r4, r5, r6, r7, lr}
    3202:	240f      	movs	r4, #15
    info.num_sections = 1;
    3204:	2501      	movs	r5, #1
{
    3206:	b08d      	sub	sp, #52	; 0x34
    3208:	446c      	add	r4, sp
    320a:	7020      	strb	r0, [r4, #0]
    rpc_init_receive_section(&get_sections[0], (uint8 *)ret_code, sizeof(uint8), NULL);
    320c:	2300      	movs	r3, #0
    info.sections = get_sections;
    320e:	a809      	add	r0, sp, #36	; 0x24
    rpc_init_receive_section(&get_sections[0], (uint8 *)ret_code, sizeof(uint8), NULL);
    3210:	002a      	movs	r2, r5
    info.num_sections = 1;
    3212:	af05      	add	r7, sp, #20
    info.sections = get_sections;
    3214:	9005      	str	r0, [sp, #20]
    info.num_sections = 1;
    3216:	713d      	strb	r5, [r7, #4]
    data_to_send[0].data_location = (uint8 *)&level;
    3218:	ae07      	add	r6, sp, #28
    rpc_init_receive_section(&get_sections[0], (uint8 *)ret_code, sizeof(uint8), NULL);
    321a:	f7ff f8f0 	bl	23fe <rpc_init_receive_section>
    RPC_ERR rpc_return = rpc_command_claim(CORES_SECURITY_CORE);
    321e:	2000      	movs	r0, #0
    data_to_send[0].data_location = (uint8 *)&level;
    3220:	9407      	str	r4, [sp, #28]
    data_to_send[0].data_length = sizeof(level);
    3222:	80b5      	strh	r5, [r6, #4]
    RPC_ERR rpc_return = rpc_command_claim(CORES_SECURITY_CORE);
    3224:	f7ff f91a 	bl	245c <rpc_command_claim>
    3228:	1e04      	subs	r4, r0, #0
    if (rpc_return != RPC_ERR_OK)
    322a:	d110      	bne.n	324e <command_set_security_log_level+0x4e>
    set_receive_info(CORES_SECURITY_CORE, &info);
    322c:	0039      	movs	r1, r7
    322e:	f7fe fdb7 	bl	1da0 <set_receive_info>
    rpc_interface_scatter_send(CORES_SECURITY_CORE, RPC_APPLICATION_TO_SECURITY_SET_SECURITY_LOG_LEVEL, true, 1, data_to_send);
    3232:	002b      	movs	r3, r5
    3234:	002a      	movs	r2, r5
    3236:	2103      	movs	r1, #3
    3238:	0020      	movs	r0, r4
    323a:	9600      	str	r6, [sp, #0]
    323c:	f7ff f860 	bl	2300 <rpc_interface_scatter_send>
    rpc_blocking_loop(CORES_SECURITY_CORE);
    3240:	0020      	movs	r0, r4
    3242:	f7ff f8e1 	bl	2408 <rpc_blocking_loop>
    return rpc_command_release(CORES_SECURITY_CORE);
    3246:	0020      	movs	r0, r4
    3248:	f7ff f8f4 	bl	2434 <rpc_command_release>
    324c:	0004      	movs	r4, r0
}
    324e:	0020      	movs	r0, r4
    3250:	b00d      	add	sp, #52	; 0x34
    3252:	bdf0      	pop	{r4, r5, r6, r7, pc}

00003254 <command_get_protocol_log_level>:
{
    3254:	b570      	push	{r4, r5, r6, lr}
    info.num_sections = 1;
    3256:	2401      	movs	r4, #1
{
    3258:	b088      	sub	sp, #32
    325a:	0001      	movs	r1, r0
    rpc_init_receive_section(&get_sections[0], (uint8 *)level, sizeof(uint8), NULL);
    325c:	2300      	movs	r3, #0
    info.sections = get_sections;
    325e:	a805      	add	r0, sp, #20
    rpc_init_receive_section(&get_sections[0], (uint8 *)level, sizeof(uint8), NULL);
    3260:	0022      	movs	r2, r4
    info.num_sections = 1;
    3262:	ae03      	add	r6, sp, #12
    info.sections = get_sections;
    3264:	9003      	str	r0, [sp, #12]
    info.num_sections = 1;
    3266:	7134      	strb	r4, [r6, #4]
    rpc_init_receive_section(&get_sections[0], (uint8 *)level, sizeof(uint8), NULL);
    3268:	f7ff f8c9 	bl	23fe <rpc_init_receive_section>
    RPC_ERR rpc_return = rpc_command_claim(CORES_PROTOCOL_CORE);
    326c:	0020      	movs	r0, r4
    326e:	f7ff f8f5 	bl	245c <rpc_command_claim>
    3272:	1e05      	subs	r5, r0, #0
    if (rpc_return != RPC_ERR_OK)
    3274:	d111      	bne.n	329a <command_get_protocol_log_level+0x46>
    set_receive_info(CORES_PROTOCOL_CORE, &info);
    3276:	0031      	movs	r1, r6
    3278:	0020      	movs	r0, r4
    327a:	f7fe fd91 	bl	1da0 <set_receive_info>
    rpc_interface_scatter_send(CORES_PROTOCOL_CORE, RPC_APPLICATION_TO_PROTOCOL_GET_PROTOCOL_LOG_LEVEL, true, 0, NULL);
    327e:	002b      	movs	r3, r5
    3280:	0022      	movs	r2, r4
    3282:	2102      	movs	r1, #2
    3284:	9500      	str	r5, [sp, #0]
    3286:	0020      	movs	r0, r4
    3288:	f7ff f83a 	bl	2300 <rpc_interface_scatter_send>
    rpc_blocking_loop(CORES_PROTOCOL_CORE);
    328c:	0020      	movs	r0, r4
    328e:	f7ff f8bb 	bl	2408 <rpc_blocking_loop>
    return rpc_command_release(CORES_PROTOCOL_CORE);
    3292:	0020      	movs	r0, r4
    3294:	f7ff f8ce 	bl	2434 <rpc_command_release>
    3298:	0005      	movs	r5, r0
}
    329a:	0028      	movs	r0, r5
    329c:	b008      	add	sp, #32
    329e:	bd70      	pop	{r4, r5, r6, pc}

000032a0 <command_get_security_log_level>:
{
    32a0:	b570      	push	{r4, r5, r6, lr}
    info.num_sections = 1;
    32a2:	2501      	movs	r5, #1
{
    32a4:	b088      	sub	sp, #32
    32a6:	0001      	movs	r1, r0
    rpc_init_receive_section(&get_sections[0], (uint8 *)level, sizeof(uint8), NULL);
    32a8:	2300      	movs	r3, #0
    info.sections = get_sections;
    32aa:	a805      	add	r0, sp, #20
    rpc_init_receive_section(&get_sections[0], (uint8 *)level, sizeof(uint8), NULL);
    32ac:	002a      	movs	r2, r5
    info.num_sections = 1;
    32ae:	ae03      	add	r6, sp, #12
    info.sections = get_sections;
    32b0:	9003      	str	r0, [sp, #12]
    info.num_sections = 1;
    32b2:	7135      	strb	r5, [r6, #4]
    rpc_init_receive_section(&get_sections[0], (uint8 *)level, sizeof(uint8), NULL);
    32b4:	f7ff f8a3 	bl	23fe <rpc_init_receive_section>
    RPC_ERR rpc_return = rpc_command_claim(CORES_SECURITY_CORE);
    32b8:	2000      	movs	r0, #0
    32ba:	f7ff f8cf 	bl	245c <rpc_command_claim>
    32be:	1e04      	subs	r4, r0, #0
    if (rpc_return != RPC_ERR_OK)
    32c0:	d110      	bne.n	32e4 <command_get_security_log_level+0x44>
    set_receive_info(CORES_SECURITY_CORE, &info);
    32c2:	0031      	movs	r1, r6
    32c4:	f7fe fd6c 	bl	1da0 <set_receive_info>
    rpc_interface_scatter_send(CORES_SECURITY_CORE, RPC_APPLICATION_TO_SECURITY_GET_SECURITY_LOG_LEVEL, true, 0, NULL);
    32c8:	0023      	movs	r3, r4
    32ca:	002a      	movs	r2, r5
    32cc:	2104      	movs	r1, #4
    32ce:	0020      	movs	r0, r4
    32d0:	9400      	str	r4, [sp, #0]
    32d2:	f7ff f815 	bl	2300 <rpc_interface_scatter_send>
    rpc_blocking_loop(CORES_SECURITY_CORE);
    32d6:	0020      	movs	r0, r4
    32d8:	f7ff f896 	bl	2408 <rpc_blocking_loop>
    return rpc_command_release(CORES_SECURITY_CORE);
    32dc:	0020      	movs	r0, r4
    32de:	f7ff f8a9 	bl	2434 <rpc_command_release>
    32e2:	0004      	movs	r4, r0
}
    32e4:	0020      	movs	r0, r4
    32e6:	b008      	add	sp, #32
    32e8:	bd70      	pop	{r4, r5, r6, pc}

000032ea <command_kv_get>:
{
    32ea:	b5f0      	push	{r4, r5, r6, r7, lr}
    32ec:	240e      	movs	r4, #14
    32ee:	001f      	movs	r7, r3
    info.num_sections = 3;
    32f0:	2303      	movs	r3, #3
{
    32f2:	0015      	movs	r5, r2
    32f4:	b093      	sub	sp, #76	; 0x4c
    32f6:	446c      	add	r4, sp
    info.num_sections = 3;
    32f8:	ae05      	add	r6, sp, #20
{
    32fa:	8020      	strh	r0, [r4, #0]
    info.num_sections = 3;
    32fc:	7133      	strb	r3, [r6, #4]
    info.sections = get_sections;
    32fe:	a809      	add	r0, sp, #36	; 0x24
    rpc_init_receive_section(&get_sections[0], (uint8 *)kv_ret_code, sizeof(uint8), NULL);
    3300:	2300      	movs	r3, #0
    3302:	2201      	movs	r2, #1
    info.sections = get_sections;
    3304:	9005      	str	r0, [sp, #20]
    rpc_init_receive_section(&get_sections[0], (uint8 *)kv_ret_code, sizeof(uint8), NULL);
    3306:	f7ff f87a 	bl	23fe <rpc_init_receive_section>
    rpc_init_receive_section(&get_sections[1], (uint8 *)kvalue, kvalue_max_length, kvalue_length);
    330a:	002a      	movs	r2, r5
    330c:	003b      	movs	r3, r7
    330e:	9918      	ldr	r1, [sp, #96]	; 0x60
    3310:	a80c      	add	r0, sp, #48	; 0x30
    3312:	f7ff f874 	bl	23fe <rpc_init_receive_section>
    rpc_init_receive_section(&get_sections[2], (uint8 *)permanent, sizeof(bool), NULL);
    3316:	2300      	movs	r3, #0
    3318:	2201      	movs	r2, #1
    331a:	9919      	ldr	r1, [sp, #100]	; 0x64
    331c:	a80f      	add	r0, sp, #60	; 0x3c
    331e:	f7ff f86e 	bl	23fe <rpc_init_receive_section>
    data_to_send[0].data_length = sizeof(key);
    3322:	2302      	movs	r3, #2
    data_to_send[0].data_location = (uint8 *)&key;
    3324:	ad07      	add	r5, sp, #28
    data_to_send[0].data_length = sizeof(key);
    3326:	80ab      	strh	r3, [r5, #4]
    RPC_ERR rpc_return = rpc_command_claim(CORES_SECURITY_CORE);
    3328:	2000      	movs	r0, #0
    data_to_send[0].data_location = (uint8 *)&key;
    332a:	9407      	str	r4, [sp, #28]
    RPC_ERR rpc_return = rpc_command_claim(CORES_SECURITY_CORE);
    332c:	f7ff f896 	bl	245c <rpc_command_claim>
    3330:	1e04      	subs	r4, r0, #0
    if (rpc_return != RPC_ERR_OK)
    3332:	d110      	bne.n	3356 <command_kv_get+0x6c>
    set_receive_info(CORES_SECURITY_CORE, &info);
    3334:	0031      	movs	r1, r6
    3336:	f7fe fd33 	bl	1da0 <set_receive_info>
    rpc_interface_scatter_send(CORES_SECURITY_CORE, RPC_APPLICATION_TO_SECURITY_KV_GET, true, 1, data_to_send);
    333a:	2301      	movs	r3, #1
    333c:	2105      	movs	r1, #5
    333e:	001a      	movs	r2, r3
    3340:	0020      	movs	r0, r4
    3342:	9500      	str	r5, [sp, #0]
    3344:	f7fe ffdc 	bl	2300 <rpc_interface_scatter_send>
    rpc_blocking_loop(CORES_SECURITY_CORE);
    3348:	0020      	movs	r0, r4
    334a:	f7ff f85d 	bl	2408 <rpc_blocking_loop>
    return rpc_command_release(CORES_SECURITY_CORE);
    334e:	0020      	movs	r0, r4
    3350:	f7ff f870 	bl	2434 <rpc_command_release>
    3354:	0004      	movs	r4, r0
}
    3356:	0020      	movs	r0, r4
    3358:	b013      	add	sp, #76	; 0x4c
    335a:	bdf0      	pop	{r4, r5, r6, r7, pc}

0000335c <command_set_id>:
{
    335c:	b5f0      	push	{r4, r5, r6, r7, lr}
    335e:	260e      	movs	r6, #14
    3360:	b091      	sub	sp, #68	; 0x44
    info.num_sections = 1;
    3362:	2501      	movs	r5, #1
{
    3364:	9102      	str	r1, [sp, #8]
    3366:	0019      	movs	r1, r3
    3368:	466b      	mov	r3, sp
    336a:	446e      	add	r6, sp
    336c:	8030      	strh	r0, [r6, #0]
    336e:	735a      	strb	r2, [r3, #13]
    info.sections = get_sections;
    3370:	a807      	add	r0, sp, #28
    rpc_init_receive_section(&get_sections[0], (uint8 *)ret_code, sizeof(uint8), NULL);
    3372:	2300      	movs	r3, #0
    3374:	002a      	movs	r2, r5
    info.num_sections = 1;
    3376:	af05      	add	r7, sp, #20
    info.sections = get_sections;
    3378:	9005      	str	r0, [sp, #20]
    info.num_sections = 1;
    337a:	713d      	strb	r5, [r7, #4]
    rpc_init_receive_section(&get_sections[0], (uint8 *)ret_code, sizeof(uint8), NULL);
    337c:	f7ff f83f 	bl	23fe <rpc_init_receive_section>
    data_to_send[0].data_length = sizeof(id_length);
    3380:	2302      	movs	r3, #2
    data_to_send[0].data_location = (uint8 *)&id_length;
    3382:	ac0a      	add	r4, sp, #40	; 0x28
    data_to_send[0].data_length = sizeof(id_length);
    3384:	80a3      	strh	r3, [r4, #4]
    data_to_send[1].data_location = (uint8 *)id;
    3386:	9b02      	ldr	r3, [sp, #8]
    RPC_ERR rpc_return = rpc_command_claim(CORES_SECURITY_CORE);
    3388:	2000      	movs	r0, #0
    data_to_send[1].data_location = (uint8 *)id;
    338a:	930c      	str	r3, [sp, #48]	; 0x30
    data_to_send[1].data_length = id_length;
    338c:	8833      	ldrh	r3, [r6, #0]
    data_to_send[0].data_location = (uint8 *)&id_length;
    338e:	960a      	str	r6, [sp, #40]	; 0x28
    data_to_send[1].data_length = id_length;
    3390:	81a3      	strh	r3, [r4, #12]
    data_to_send[2].data_location = (uint8 *)&id_type;
    3392:	230d      	movs	r3, #13
    3394:	446b      	add	r3, sp
    3396:	930e      	str	r3, [sp, #56]	; 0x38
    data_to_send[2].data_length = sizeof(id_type);
    3398:	82a5      	strh	r5, [r4, #20]
    RPC_ERR rpc_return = rpc_command_claim(CORES_SECURITY_CORE);
    339a:	f7ff f85f 	bl	245c <rpc_command_claim>
    339e:	1e06      	subs	r6, r0, #0
    if (rpc_return != RPC_ERR_OK)
    33a0:	d110      	bne.n	33c4 <command_set_id+0x68>
    set_receive_info(CORES_SECURITY_CORE, &info);
    33a2:	0039      	movs	r1, r7
    33a4:	f7fe fcfc 	bl	1da0 <set_receive_info>
    rpc_interface_scatter_send(CORES_SECURITY_CORE, RPC_APPLICATION_TO_SECURITY_SET_ID, true, 3, data_to_send);
    33a8:	2303      	movs	r3, #3
    33aa:	002a      	movs	r2, r5
    33ac:	2107      	movs	r1, #7
    33ae:	0030      	movs	r0, r6
    33b0:	9400      	str	r4, [sp, #0]
    33b2:	f7fe ffa5 	bl	2300 <rpc_interface_scatter_send>
    rpc_blocking_loop(CORES_SECURITY_CORE);
    33b6:	0030      	movs	r0, r6
    33b8:	f7ff f826 	bl	2408 <rpc_blocking_loop>
    return rpc_command_release(CORES_SECURITY_CORE);
    33bc:	0030      	movs	r0, r6
    33be:	f7ff f839 	bl	2434 <rpc_command_release>
    33c2:	0006      	movs	r6, r0
}
    33c4:	0030      	movs	r0, r6
    33c6:	b011      	add	sp, #68	; 0x44
    33c8:	bdf0      	pop	{r4, r5, r6, r7, pc}

000033ca <command_set_id_permanence>:
{
    33ca:	b5f0      	push	{r4, r5, r6, r7, lr}
    33cc:	270f      	movs	r7, #15
    33ce:	b08f      	sub	sp, #60	; 0x3c
    info.num_sections = 1;
    33d0:	2401      	movs	r4, #1
{
    33d2:	000b      	movs	r3, r1
    33d4:	0011      	movs	r1, r2
    33d6:	466a      	mov	r2, sp
    33d8:	446f      	add	r7, sp
    33da:	7038      	strb	r0, [r7, #0]
    33dc:	7393      	strb	r3, [r2, #14]
    info.sections = get_sections;
    33de:	a807      	add	r0, sp, #28
    rpc_init_receive_section(&get_sections[0], (uint8 *)ret_code, sizeof(uint8), NULL);
    33e0:	2300      	movs	r3, #0
    33e2:	0022      	movs	r2, r4
    info.num_sections = 1;
    33e4:	ae05      	add	r6, sp, #20
    info.sections = get_sections;
    33e6:	9005      	str	r0, [sp, #20]
    info.num_sections = 1;
    33e8:	7134      	strb	r4, [r6, #4]
    rpc_init_receive_section(&get_sections[0], (uint8 *)ret_code, sizeof(uint8), NULL);
    33ea:	f7ff f808 	bl	23fe <rpc_init_receive_section>
    data_to_send[1].data_location = (uint8 *)&set_dest;
    33ee:	230e      	movs	r3, #14
    data_to_send[0].data_location = (uint8 *)&id_type;
    33f0:	ad0a      	add	r5, sp, #40	; 0x28
    data_to_send[1].data_location = (uint8 *)&set_dest;
    33f2:	446b      	add	r3, sp
    RPC_ERR rpc_return = rpc_command_claim(CORES_SECURITY_CORE);
    33f4:	2000      	movs	r0, #0
    data_to_send[0].data_location = (uint8 *)&id_type;
    33f6:	970a      	str	r7, [sp, #40]	; 0x28
    data_to_send[0].data_length = sizeof(id_type);
    33f8:	80ac      	strh	r4, [r5, #4]
    data_to_send[1].data_location = (uint8 *)&set_dest;
    33fa:	930c      	str	r3, [sp, #48]	; 0x30
    data_to_send[1].data_length = sizeof(set_dest);
    33fc:	81ac      	strh	r4, [r5, #12]
    RPC_ERR rpc_return = rpc_command_claim(CORES_SECURITY_CORE);
    33fe:	f7ff f82d 	bl	245c <rpc_command_claim>
    3402:	1e07      	subs	r7, r0, #0
    if (rpc_return != RPC_ERR_OK)
    3404:	d110      	bne.n	3428 <command_set_id_permanence+0x5e>
    set_receive_info(CORES_SECURITY_CORE, &info);
    3406:	0031      	movs	r1, r6
    3408:	f7fe fcca 	bl	1da0 <set_receive_info>
    rpc_interface_scatter_send(CORES_SECURITY_CORE, RPC_APPLICATION_TO_SECURITY_SET_ID_PERMANENCE, true, 2, data_to_send);
    340c:	2302      	movs	r3, #2
    340e:	0022      	movs	r2, r4
    3410:	2108      	movs	r1, #8
    3412:	0038      	movs	r0, r7
    3414:	9500      	str	r5, [sp, #0]
    3416:	f7fe ff73 	bl	2300 <rpc_interface_scatter_send>
    rpc_blocking_loop(CORES_SECURITY_CORE);
    341a:	0038      	movs	r0, r7
    341c:	f7fe fff4 	bl	2408 <rpc_blocking_loop>
    return rpc_command_release(CORES_SECURITY_CORE);
    3420:	0038      	movs	r0, r7
    3422:	f7ff f807 	bl	2434 <rpc_command_release>
    3426:	0007      	movs	r7, r0
}
    3428:	0038      	movs	r0, r7
    342a:	b00f      	add	sp, #60	; 0x3c
    342c:	bdf0      	pop	{r4, r5, r6, r7, pc}

0000342e <command_get_id>:
{
    342e:	b5f0      	push	{r4, r5, r6, r7, lr}
    3430:	000d      	movs	r5, r1
    3432:	0019      	movs	r1, r3
    info.num_sections = 2;
    3434:	2302      	movs	r3, #2
{
    3436:	240f      	movs	r4, #15
    3438:	b08f      	sub	sp, #60	; 0x3c
    info.num_sections = 2;
    343a:	af04      	add	r7, sp, #16
    343c:	713b      	strb	r3, [r7, #4]
    rpc_init_receive_section(&get_sections[0], (uint8 *)id, id_max_length, id_length);
    343e:	0013      	movs	r3, r2
    3440:	002a      	movs	r2, r5
    data_to_send[0].data_length = sizeof(id_type);
    3442:	2501      	movs	r5, #1
{
    3444:	446c      	add	r4, sp
    3446:	7020      	strb	r0, [r4, #0]
    info.sections = get_sections;
    3448:	a808      	add	r0, sp, #32
    344a:	9004      	str	r0, [sp, #16]
    rpc_init_receive_section(&get_sections[0], (uint8 *)id, id_max_length, id_length);
    344c:	f7fe ffd7 	bl	23fe <rpc_init_receive_section>
    rpc_init_receive_section(&get_sections[1], (uint8 *)neul_ret_code, sizeof(uint8), NULL);
    3450:	2300      	movs	r3, #0
    3452:	2201      	movs	r2, #1
    3454:	9914      	ldr	r1, [sp, #80]	; 0x50
    3456:	a80b      	add	r0, sp, #44	; 0x2c
    3458:	f7fe ffd1 	bl	23fe <rpc_init_receive_section>
    data_to_send[0].data_location = (uint8 *)&id_type;
    345c:	ae06      	add	r6, sp, #24
    RPC_ERR rpc_return = rpc_command_claim(CORES_SECURITY_CORE);
    345e:	2000      	movs	r0, #0
    data_to_send[0].data_location = (uint8 *)&id_type;
    3460:	9406      	str	r4, [sp, #24]
    data_to_send[0].data_length = sizeof(id_type);
    3462:	80b5      	strh	r5, [r6, #4]
    RPC_ERR rpc_return = rpc_command_claim(CORES_SECURITY_CORE);
    3464:	f7fe fffa 	bl	245c <rpc_command_claim>
    3468:	1e04      	subs	r4, r0, #0
    if (rpc_return != RPC_ERR_OK)
    346a:	d110      	bne.n	348e <command_get_id+0x60>
    set_receive_info(CORES_SECURITY_CORE, &info);
    346c:	0039      	movs	r1, r7
    346e:	f7fe fc97 	bl	1da0 <set_receive_info>
    rpc_interface_scatter_send(CORES_SECURITY_CORE, RPC_APPLICATION_TO_SECURITY_GET_ID, true, 1, data_to_send);
    3472:	002b      	movs	r3, r5
    3474:	002a      	movs	r2, r5
    3476:	210a      	movs	r1, #10
    3478:	0020      	movs	r0, r4
    347a:	9600      	str	r6, [sp, #0]
    347c:	f7fe ff40 	bl	2300 <rpc_interface_scatter_send>
    rpc_blocking_loop(CORES_SECURITY_CORE);
    3480:	0020      	movs	r0, r4
    3482:	f7fe ffc1 	bl	2408 <rpc_blocking_loop>
    return rpc_command_release(CORES_SECURITY_CORE);
    3486:	0020      	movs	r0, r4
    3488:	f7fe ffd4 	bl	2434 <rpc_command_release>
    348c:	0004      	movs	r4, r0
}
    348e:	0020      	movs	r0, r4
    3490:	b00f      	add	sp, #60	; 0x3c
    3492:	bdf0      	pop	{r4, r5, r6, r7, pc}

00003494 <command_getifaddr>:
{
    3494:	b570      	push	{r4, r5, r6, lr}
    3496:	240f      	movs	r4, #15
    3498:	000d      	movs	r5, r1
    349a:	0019      	movs	r1, r3
    info.num_sections = 2;
    349c:	2302      	movs	r3, #2
{
    349e:	b08e      	sub	sp, #56	; 0x38
    34a0:	446c      	add	r4, sp
    info.num_sections = 2;
    34a2:	ae04      	add	r6, sp, #16
{
    34a4:	7020      	strb	r0, [r4, #0]
    info.num_sections = 2;
    34a6:	7133      	strb	r3, [r6, #4]
    info.sections = get_sections;
    34a8:	a808      	add	r0, sp, #32
    rpc_init_receive_section(&get_sections[0], (uint8 *)ifaddr_data, ifaddr_data_max_length, ifaddr_data_length);
    34aa:	0013      	movs	r3, r2
    34ac:	002a      	movs	r2, r5
    info.sections = get_sections;
    34ae:	9004      	str	r0, [sp, #16]
    rpc_init_receive_section(&get_sections[0], (uint8 *)ifaddr_data, ifaddr_data_max_length, ifaddr_data_length);
    34b0:	f7fe ffa5 	bl	23fe <rpc_init_receive_section>
    rpc_init_receive_section(&get_sections[1], (uint8 *)err, sizeof(uint8), NULL);
    34b4:	a80b      	add	r0, sp, #44	; 0x2c
    34b6:	2300      	movs	r3, #0
    34b8:	2201      	movs	r2, #1
    34ba:	9912      	ldr	r1, [sp, #72]	; 0x48
    34bc:	f7fe ff9f 	bl	23fe <rpc_init_receive_section>
    data_to_send[0].data_location = (uint8 *)&cid;
    34c0:	9406      	str	r4, [sp, #24]
    data_to_send[0].data_length = sizeof(cid);
    34c2:	2401      	movs	r4, #1
    data_to_send[0].data_location = (uint8 *)&cid;
    34c4:	ad06      	add	r5, sp, #24
    data_to_send[0].data_length = sizeof(cid);
    34c6:	80ac      	strh	r4, [r5, #4]
    RPC_ERR rpc_return = rpc_command_claim(CORES_PROTOCOL_CORE);
    34c8:	0020      	movs	r0, r4
    34ca:	f7fe ffc7 	bl	245c <rpc_command_claim>
    if (rpc_return != RPC_ERR_OK)
    34ce:	2800      	cmp	r0, #0
    34d0:	d110      	bne.n	34f4 <command_getifaddr+0x60>
    set_receive_info(CORES_PROTOCOL_CORE, &info);
    34d2:	0031      	movs	r1, r6
    34d4:	0020      	movs	r0, r4
    34d6:	f7fe fc63 	bl	1da0 <set_receive_info>
    rpc_interface_scatter_send(CORES_PROTOCOL_CORE, RPC_APPLICATION_TO_PROTOCOL_GETIFADDR, true, 1, data_to_send);
    34da:	0023      	movs	r3, r4
    34dc:	0022      	movs	r2, r4
    34de:	2103      	movs	r1, #3
    34e0:	0020      	movs	r0, r4
    34e2:	9500      	str	r5, [sp, #0]
    34e4:	f7fe ff0c 	bl	2300 <rpc_interface_scatter_send>
    rpc_blocking_loop(CORES_PROTOCOL_CORE);
    34e8:	0020      	movs	r0, r4
    34ea:	f7fe ff8d 	bl	2408 <rpc_blocking_loop>
    return rpc_command_release(CORES_PROTOCOL_CORE);
    34ee:	0020      	movs	r0, r4
    34f0:	f7fe ffa0 	bl	2434 <rpc_command_release>
}
    34f4:	b00e      	add	sp, #56	; 0x38
    34f6:	bd70      	pop	{r4, r5, r6, pc}

000034f8 <command_set_earfcn_range>:
{
    34f8:	b5f0      	push	{r4, r5, r6, r7, lr}
    34fa:	2616      	movs	r6, #22
    34fc:	b095      	sub	sp, #84	; 0x54
    info.num_sections = 1;
    34fe:	2401      	movs	r4, #1
{
    3500:	9203      	str	r2, [sp, #12]
    3502:	466a      	mov	r2, sp
    3504:	446e      	add	r6, sp
    3506:	8030      	strh	r0, [r6, #0]
    3508:	8293      	strh	r3, [r2, #20]
    info.sections = get_sections;
    350a:	a809      	add	r0, sp, #36	; 0x24
{
    350c:	9104      	str	r1, [sp, #16]
    rpc_init_receive_section(&get_sections[0], (uint8 *)plmn_search_result, sizeof(uint8), NULL);
    350e:	2300      	movs	r3, #0
    3510:	0022      	movs	r2, r4
    info.num_sections = 1;
    3512:	af07      	add	r7, sp, #28
    rpc_init_receive_section(&get_sections[0], (uint8 *)plmn_search_result, sizeof(uint8), NULL);
    3514:	991a      	ldr	r1, [sp, #104]	; 0x68
    info.sections = get_sections;
    3516:	9007      	str	r0, [sp, #28]
    info.num_sections = 1;
    3518:	713c      	strb	r4, [r7, #4]
    rpc_init_receive_section(&get_sections[0], (uint8 *)plmn_search_result, sizeof(uint8), NULL);
    351a:	f7fe ff70 	bl	23fe <rpc_init_receive_section>
    data_to_send[0].data_length = sizeof(mode);
    351e:	2302      	movs	r3, #2
    data_to_send[0].data_location = (uint8 *)&mode;
    3520:	960c      	str	r6, [sp, #48]	; 0x30
    data_to_send[1].data_length = sizeof(earfcn_start);
    3522:	2604      	movs	r6, #4
    data_to_send[1].data_location = (uint8 *)&earfcn_start;
    3524:	aa04      	add	r2, sp, #16
    3526:	920e      	str	r2, [sp, #56]	; 0x38
    data_to_send[2].data_location = (uint8 *)&earfcn_end;
    3528:	aa03      	add	r2, sp, #12
    data_to_send[0].data_location = (uint8 *)&mode;
    352a:	ad0c      	add	r5, sp, #48	; 0x30
    data_to_send[2].data_location = (uint8 *)&earfcn_end;
    352c:	9210      	str	r2, [sp, #64]	; 0x40
    RPC_ERR rpc_return = rpc_command_claim(CORES_PROTOCOL_CORE);
    352e:	0020      	movs	r0, r4
    data_to_send[3].data_location = (uint8 *)&pci;
    3530:	aa05      	add	r2, sp, #20
    data_to_send[0].data_length = sizeof(mode);
    3532:	80ab      	strh	r3, [r5, #4]
    data_to_send[1].data_length = sizeof(earfcn_start);
    3534:	81ae      	strh	r6, [r5, #12]
    data_to_send[2].data_length = sizeof(earfcn_end);
    3536:	82ae      	strh	r6, [r5, #20]
    data_to_send[3].data_location = (uint8 *)&pci;
    3538:	9212      	str	r2, [sp, #72]	; 0x48
    data_to_send[3].data_length = sizeof(pci);
    353a:	83ab      	strh	r3, [r5, #28]
    RPC_ERR rpc_return = rpc_command_claim(CORES_PROTOCOL_CORE);
    353c:	f7fe ff8e 	bl	245c <rpc_command_claim>
    if (rpc_return != RPC_ERR_OK)
    3540:	2800      	cmp	r0, #0
    3542:	d110      	bne.n	3566 <command_set_earfcn_range+0x6e>
    set_receive_info(CORES_PROTOCOL_CORE, &info);
    3544:	0039      	movs	r1, r7
    3546:	0020      	movs	r0, r4
    3548:	f7fe fc2a 	bl	1da0 <set_receive_info>
    rpc_interface_scatter_send(CORES_PROTOCOL_CORE, RPC_APPLICATION_TO_PROTOCOL_SET_EARFCN_RANGE, true, 4, data_to_send);
    354c:	0033      	movs	r3, r6
    354e:	0022      	movs	r2, r4
    3550:	0031      	movs	r1, r6
    3552:	0020      	movs	r0, r4
    3554:	9500      	str	r5, [sp, #0]
    3556:	f7fe fed3 	bl	2300 <rpc_interface_scatter_send>
    rpc_blocking_loop(CORES_PROTOCOL_CORE);
    355a:	0020      	movs	r0, r4
    355c:	f7fe ff54 	bl	2408 <rpc_blocking_loop>
    return rpc_command_release(CORES_PROTOCOL_CORE);
    3560:	0020      	movs	r0, r4
    3562:	f7fe ff67 	bl	2434 <rpc_command_release>
}
    3566:	b015      	add	sp, #84	; 0x54
    3568:	bdf0      	pop	{r4, r5, r6, r7, pc}

0000356a <command_clear_stored_earfcn>:
{
    356a:	b570      	push	{r4, r5, r6, lr}
    info.num_sections = 1;
    356c:	2401      	movs	r4, #1
{
    356e:	b088      	sub	sp, #32
    3570:	0001      	movs	r1, r0
    rpc_init_receive_section(&get_sections[0], (uint8 *)result, sizeof(uint8), NULL);
    3572:	2300      	movs	r3, #0
    info.sections = get_sections;
    3574:	a805      	add	r0, sp, #20
    rpc_init_receive_section(&get_sections[0], (uint8 *)result, sizeof(uint8), NULL);
    3576:	0022      	movs	r2, r4
    info.num_sections = 1;
    3578:	ae03      	add	r6, sp, #12
    info.sections = get_sections;
    357a:	9003      	str	r0, [sp, #12]
    info.num_sections = 1;
    357c:	7134      	strb	r4, [r6, #4]
    rpc_init_receive_section(&get_sections[0], (uint8 *)result, sizeof(uint8), NULL);
    357e:	f7fe ff3e 	bl	23fe <rpc_init_receive_section>
    RPC_ERR rpc_return = rpc_command_claim(CORES_PROTOCOL_CORE);
    3582:	0020      	movs	r0, r4
    3584:	f7fe ff6a 	bl	245c <rpc_command_claim>
    3588:	1e05      	subs	r5, r0, #0
    if (rpc_return != RPC_ERR_OK)
    358a:	d111      	bne.n	35b0 <command_clear_stored_earfcn+0x46>
    set_receive_info(CORES_PROTOCOL_CORE, &info);
    358c:	0031      	movs	r1, r6
    358e:	0020      	movs	r0, r4
    3590:	f7fe fc06 	bl	1da0 <set_receive_info>
    rpc_interface_scatter_send(CORES_PROTOCOL_CORE, RPC_APPLICATION_TO_PROTOCOL_CLEAR_STORED_EARFCN, true, 0, NULL);
    3594:	002b      	movs	r3, r5
    3596:	0022      	movs	r2, r4
    3598:	2105      	movs	r1, #5
    359a:	9500      	str	r5, [sp, #0]
    359c:	0020      	movs	r0, r4
    359e:	f7fe feaf 	bl	2300 <rpc_interface_scatter_send>
    rpc_blocking_loop(CORES_PROTOCOL_CORE);
    35a2:	0020      	movs	r0, r4
    35a4:	f7fe ff30 	bl	2408 <rpc_blocking_loop>
    return rpc_command_release(CORES_PROTOCOL_CORE);
    35a8:	0020      	movs	r0, r4
    35aa:	f7fe ff43 	bl	2434 <rpc_command_release>
    35ae:	0005      	movs	r5, r0
}
    35b0:	0028      	movs	r0, r5
    35b2:	b008      	add	sp, #32
    35b4:	bd70      	pop	{r4, r5, r6, pc}

000035b6 <command_set_band>:
{
    35b6:	b5f0      	push	{r4, r5, r6, r7, lr}
    35b8:	260e      	movs	r6, #14
    info.num_sections = 1;
    35ba:	2401      	movs	r4, #1
{
    35bc:	b08f      	sub	sp, #60	; 0x3c
    35be:	446e      	add	r6, sp
    35c0:	9102      	str	r1, [sp, #8]
    35c2:	8030      	strh	r0, [r6, #0]
    35c4:	0011      	movs	r1, r2
    info.sections = get_sections;
    35c6:	a807      	add	r0, sp, #28
    rpc_init_receive_section(&get_sections[0], (uint8 *)band_result, sizeof(uint8), NULL);
    35c8:	2300      	movs	r3, #0
    info.num_sections = 1;
    35ca:	af05      	add	r7, sp, #20
    rpc_init_receive_section(&get_sections[0], (uint8 *)band_result, sizeof(uint8), NULL);
    35cc:	0022      	movs	r2, r4
    info.sections = get_sections;
    35ce:	9005      	str	r0, [sp, #20]
    info.num_sections = 1;
    35d0:	713c      	strb	r4, [r7, #4]
    rpc_init_receive_section(&get_sections[0], (uint8 *)band_result, sizeof(uint8), NULL);
    35d2:	f7fe ff14 	bl	23fe <rpc_init_receive_section>
    data_to_send[0].data_length = sizeof(band_length);
    35d6:	2302      	movs	r3, #2
    data_to_send[0].data_location = (uint8 *)&band_length;
    35d8:	ad0a      	add	r5, sp, #40	; 0x28
    data_to_send[0].data_length = sizeof(band_length);
    35da:	80ab      	strh	r3, [r5, #4]
    data_to_send[1].data_location = (uint8 *)band;
    35dc:	9b02      	ldr	r3, [sp, #8]
    RPC_ERR rpc_return = rpc_command_claim(CORES_PROTOCOL_CORE);
    35de:	0020      	movs	r0, r4
    data_to_send[1].data_location = (uint8 *)band;
    35e0:	930c      	str	r3, [sp, #48]	; 0x30
    data_to_send[1].data_length = band_length;
    35e2:	8833      	ldrh	r3, [r6, #0]
    data_to_send[0].data_location = (uint8 *)&band_length;
    35e4:	960a      	str	r6, [sp, #40]	; 0x28
    data_to_send[1].data_length = band_length;
    35e6:	81ab      	strh	r3, [r5, #12]
    RPC_ERR rpc_return = rpc_command_claim(CORES_PROTOCOL_CORE);
    35e8:	f7fe ff38 	bl	245c <rpc_command_claim>
    if (rpc_return != RPC_ERR_OK)
    35ec:	2800      	cmp	r0, #0
    35ee:	d110      	bne.n	3612 <command_set_band+0x5c>
    set_receive_info(CORES_PROTOCOL_CORE, &info);
    35f0:	0039      	movs	r1, r7
    35f2:	0020      	movs	r0, r4
    35f4:	f7fe fbd4 	bl	1da0 <set_receive_info>
    rpc_interface_scatter_send(CORES_PROTOCOL_CORE, RPC_APPLICATION_TO_PROTOCOL_SET_BAND, true, 2, data_to_send);
    35f8:	2302      	movs	r3, #2
    35fa:	0022      	movs	r2, r4
    35fc:	2106      	movs	r1, #6
    35fe:	0020      	movs	r0, r4
    3600:	9500      	str	r5, [sp, #0]
    3602:	f7fe fe7d 	bl	2300 <rpc_interface_scatter_send>
    rpc_blocking_loop(CORES_PROTOCOL_CORE);
    3606:	0020      	movs	r0, r4
    3608:	f7fe fefe 	bl	2408 <rpc_blocking_loop>
    return rpc_command_release(CORES_PROTOCOL_CORE);
    360c:	0020      	movs	r0, r4
    360e:	f7fe ff11 	bl	2434 <rpc_command_release>
}
    3612:	b00f      	add	sp, #60	; 0x3c
    3614:	bdf0      	pop	{r4, r5, r6, r7, pc}

00003616 <command_get_band>:
{
    3616:	b5f0      	push	{r4, r5, r6, r7, lr}
    3618:	4684      	mov	ip, r0
    361a:	001c      	movs	r4, r3
    info.num_sections = 2;
    361c:	2302      	movs	r3, #2
{
    361e:	000e      	movs	r6, r1
    3620:	0017      	movs	r7, r2
    3622:	b08b      	sub	sp, #44	; 0x2c
    info.num_sections = 2;
    3624:	ad02      	add	r5, sp, #8
    rpc_init_receive_section(&get_sections[0], (uint8 *)band_result, sizeof(uint8), NULL);
    3626:	4661      	mov	r1, ip
    info.sections = get_sections;
    3628:	a804      	add	r0, sp, #16
    info.num_sections = 2;
    362a:	712b      	strb	r3, [r5, #4]
    rpc_init_receive_section(&get_sections[0], (uint8 *)band_result, sizeof(uint8), NULL);
    362c:	2201      	movs	r2, #1
    362e:	2300      	movs	r3, #0
    info.sections = get_sections;
    3630:	9002      	str	r0, [sp, #8]
    rpc_init_receive_section(&get_sections[0], (uint8 *)band_result, sizeof(uint8), NULL);
    3632:	f7fe fee4 	bl	23fe <rpc_init_receive_section>
    rpc_init_receive_section(&get_sections[1], (uint8 *)band, band_max_length, band_length);
    3636:	0021      	movs	r1, r4
    3638:	003b      	movs	r3, r7
    363a:	0032      	movs	r2, r6
    363c:	a807      	add	r0, sp, #28
    363e:	f7fe fede 	bl	23fe <rpc_init_receive_section>
    RPC_ERR rpc_return = rpc_command_claim(CORES_PROTOCOL_CORE);
    3642:	2001      	movs	r0, #1
    3644:	f7fe ff0a 	bl	245c <rpc_command_claim>
    3648:	1e04      	subs	r4, r0, #0
    if (rpc_return != RPC_ERR_OK)
    364a:	d111      	bne.n	3670 <command_get_band+0x5a>
    set_receive_info(CORES_PROTOCOL_CORE, &info);
    364c:	0029      	movs	r1, r5
    364e:	2001      	movs	r0, #1
    3650:	f7fe fba6 	bl	1da0 <set_receive_info>
    rpc_interface_scatter_send(CORES_PROTOCOL_CORE, RPC_APPLICATION_TO_PROTOCOL_GET_BAND, true, 0, NULL);
    3654:	2201      	movs	r2, #1
    3656:	0023      	movs	r3, r4
    3658:	0010      	movs	r0, r2
    365a:	2107      	movs	r1, #7
    365c:	9400      	str	r4, [sp, #0]
    365e:	f7fe fe4f 	bl	2300 <rpc_interface_scatter_send>
    rpc_blocking_loop(CORES_PROTOCOL_CORE);
    3662:	2001      	movs	r0, #1
    3664:	f7fe fed0 	bl	2408 <rpc_blocking_loop>
    return rpc_command_release(CORES_PROTOCOL_CORE);
    3668:	2001      	movs	r0, #1
    366a:	f7fe fee3 	bl	2434 <rpc_command_release>
    366e:	0004      	movs	r4, r0
}
    3670:	0020      	movs	r0, r4
    3672:	b00b      	add	sp, #44	; 0x2c
    3674:	bdf0      	pop	{r4, r5, r6, r7, pc}

00003676 <command_get_supported_bands>:
{
    3676:	b5f0      	push	{r4, r5, r6, r7, lr}
    3678:	4684      	mov	ip, r0
    367a:	001c      	movs	r4, r3
    info.num_sections = 2;
    367c:	2302      	movs	r3, #2
{
    367e:	000e      	movs	r6, r1
    3680:	0017      	movs	r7, r2
    3682:	b08b      	sub	sp, #44	; 0x2c
    info.num_sections = 2;
    3684:	ad02      	add	r5, sp, #8
    rpc_init_receive_section(&get_sections[0], (uint8 *)band_result, sizeof(uint8), NULL);
    3686:	4661      	mov	r1, ip
    info.sections = get_sections;
    3688:	a804      	add	r0, sp, #16
    info.num_sections = 2;
    368a:	712b      	strb	r3, [r5, #4]
    rpc_init_receive_section(&get_sections[0], (uint8 *)band_result, sizeof(uint8), NULL);
    368c:	2201      	movs	r2, #1
    368e:	2300      	movs	r3, #0
    info.sections = get_sections;
    3690:	9002      	str	r0, [sp, #8]
    rpc_init_receive_section(&get_sections[0], (uint8 *)band_result, sizeof(uint8), NULL);
    3692:	f7fe feb4 	bl	23fe <rpc_init_receive_section>
    rpc_init_receive_section(&get_sections[1], (uint8 *)band, band_max_length, band_length);
    3696:	0021      	movs	r1, r4
    3698:	003b      	movs	r3, r7
    369a:	0032      	movs	r2, r6
    369c:	a807      	add	r0, sp, #28
    369e:	f7fe feae 	bl	23fe <rpc_init_receive_section>
    RPC_ERR rpc_return = rpc_command_claim(CORES_PROTOCOL_CORE);
    36a2:	2001      	movs	r0, #1
    36a4:	f7fe feda 	bl	245c <rpc_command_claim>
    36a8:	1e04      	subs	r4, r0, #0
    if (rpc_return != RPC_ERR_OK)
    36aa:	d111      	bne.n	36d0 <command_get_supported_bands+0x5a>
    set_receive_info(CORES_PROTOCOL_CORE, &info);
    36ac:	0029      	movs	r1, r5
    36ae:	2001      	movs	r0, #1
    36b0:	f7fe fb76 	bl	1da0 <set_receive_info>
    rpc_interface_scatter_send(CORES_PROTOCOL_CORE, RPC_APPLICATION_TO_PROTOCOL_GET_SUPPORTED_BANDS, true, 0, NULL);
    36b4:	2201      	movs	r2, #1
    36b6:	0023      	movs	r3, r4
    36b8:	0010      	movs	r0, r2
    36ba:	2108      	movs	r1, #8
    36bc:	9400      	str	r4, [sp, #0]
    36be:	f7fe fe1f 	bl	2300 <rpc_interface_scatter_send>
    rpc_blocking_loop(CORES_PROTOCOL_CORE);
    36c2:	2001      	movs	r0, #1
    36c4:	f7fe fea0 	bl	2408 <rpc_blocking_loop>
    return rpc_command_release(CORES_PROTOCOL_CORE);
    36c8:	2001      	movs	r0, #1
    36ca:	f7fe feb3 	bl	2434 <rpc_command_release>
    36ce:	0004      	movs	r4, r0
}
    36d0:	0020      	movs	r0, r4
    36d2:	b00b      	add	sp, #44	; 0x2c
    36d4:	bdf0      	pop	{r4, r5, r6, r7, pc}

000036d6 <command_execute_radiotest>:
{
    36d6:	b5f0      	push	{r4, r5, r6, r7, lr}
    36d8:	260e      	movs	r6, #14
    info.num_sections = 1;
    36da:	2401      	movs	r4, #1
{
    36dc:	b08f      	sub	sp, #60	; 0x3c
    36de:	446e      	add	r6, sp
    36e0:	9102      	str	r1, [sp, #8]
    36e2:	8030      	strh	r0, [r6, #0]
    36e4:	0011      	movs	r1, r2
    info.sections = get_sections;
    36e6:	a807      	add	r0, sp, #28
    rpc_init_receive_section(&get_sections[0], (uint8 *)test_result, sizeof(uint8), NULL);
    36e8:	2300      	movs	r3, #0
    info.num_sections = 1;
    36ea:	af05      	add	r7, sp, #20
    rpc_init_receive_section(&get_sections[0], (uint8 *)test_result, sizeof(uint8), NULL);
    36ec:	0022      	movs	r2, r4
    info.sections = get_sections;
    36ee:	9005      	str	r0, [sp, #20]
    info.num_sections = 1;
    36f0:	713c      	strb	r4, [r7, #4]
    rpc_init_receive_section(&get_sections[0], (uint8 *)test_result, sizeof(uint8), NULL);
    36f2:	f7fe fe84 	bl	23fe <rpc_init_receive_section>
    data_to_send[0].data_length = sizeof(test_data_length);
    36f6:	2302      	movs	r3, #2
    data_to_send[0].data_location = (uint8 *)&test_data_length;
    36f8:	ad0a      	add	r5, sp, #40	; 0x28
    data_to_send[0].data_length = sizeof(test_data_length);
    36fa:	80ab      	strh	r3, [r5, #4]
    data_to_send[1].data_location = (uint8 *)test_data;
    36fc:	9b02      	ldr	r3, [sp, #8]
    RPC_ERR rpc_return = rpc_command_claim(CORES_PROTOCOL_CORE);
    36fe:	0020      	movs	r0, r4
    data_to_send[1].data_location = (uint8 *)test_data;
    3700:	930c      	str	r3, [sp, #48]	; 0x30
    data_to_send[1].data_length = test_data_length;
    3702:	8833      	ldrh	r3, [r6, #0]
    data_to_send[0].data_location = (uint8 *)&test_data_length;
    3704:	960a      	str	r6, [sp, #40]	; 0x28
    data_to_send[1].data_length = test_data_length;
    3706:	81ab      	strh	r3, [r5, #12]
    RPC_ERR rpc_return = rpc_command_claim(CORES_PROTOCOL_CORE);
    3708:	f7fe fea8 	bl	245c <rpc_command_claim>
    if (rpc_return != RPC_ERR_OK)
    370c:	2800      	cmp	r0, #0
    370e:	d110      	bne.n	3732 <command_execute_radiotest+0x5c>
    set_receive_info(CORES_PROTOCOL_CORE, &info);
    3710:	0039      	movs	r1, r7
    3712:	0020      	movs	r0, r4
    3714:	f7fe fb44 	bl	1da0 <set_receive_info>
    rpc_interface_scatter_send(CORES_PROTOCOL_CORE, RPC_APPLICATION_TO_PROTOCOL_EXECUTE_RADIOTEST, true, 2, data_to_send);
    3718:	2302      	movs	r3, #2
    371a:	0022      	movs	r2, r4
    371c:	2109      	movs	r1, #9
    371e:	0020      	movs	r0, r4
    3720:	9500      	str	r5, [sp, #0]
    3722:	f7fe fded 	bl	2300 <rpc_interface_scatter_send>
    rpc_blocking_loop(CORES_PROTOCOL_CORE);
    3726:	0020      	movs	r0, r4
    3728:	f7fe fe6e 	bl	2408 <rpc_blocking_loop>
    return rpc_command_release(CORES_PROTOCOL_CORE);
    372c:	0020      	movs	r0, r4
    372e:	f7fe fe81 	bl	2434 <rpc_command_release>
}
    3732:	b00f      	add	sp, #60	; 0x3c
    3734:	bdf0      	pop	{r4, r5, r6, r7, pc}

00003736 <command_execute_plmn_select>:
{
    3736:	b5f0      	push	{r4, r5, r6, r7, lr}
    3738:	270e      	movs	r7, #14
    info.num_sections = 1;
    373a:	2401      	movs	r4, #1
{
    373c:	b08f      	sub	sp, #60	; 0x3c
    373e:	446f      	add	r7, sp
    3740:	8038      	strh	r0, [r7, #0]
    3742:	9102      	str	r1, [sp, #8]
    info.sections = get_sections;
    3744:	a807      	add	r0, sp, #28
{
    3746:	0011      	movs	r1, r2
    rpc_init_receive_section(&get_sections[0], (uint8 *)plmn_select_result, sizeof(uint8), NULL);
    3748:	2300      	movs	r3, #0
    info.num_sections = 1;
    374a:	ae05      	add	r6, sp, #20
    rpc_init_receive_section(&get_sections[0], (uint8 *)plmn_select_result, sizeof(uint8), NULL);
    374c:	0022      	movs	r2, r4
    info.sections = get_sections;
    374e:	9005      	str	r0, [sp, #20]
    info.num_sections = 1;
    3750:	7134      	strb	r4, [r6, #4]
    rpc_init_receive_section(&get_sections[0], (uint8 *)plmn_select_result, sizeof(uint8), NULL);
    3752:	f7fe fe54 	bl	23fe <rpc_init_receive_section>
    data_to_send[1].data_location = (uint8 *)plmn;
    3756:	9b02      	ldr	r3, [sp, #8]
    data_to_send[0].data_location = (uint8 *)&plmn_mode;
    3758:	970a      	str	r7, [sp, #40]	; 0x28
    data_to_send[1].data_location = (uint8 *)plmn;
    375a:	930c      	str	r3, [sp, #48]	; 0x30
    data_to_send[0].data_length = sizeof(plmn_mode);
    375c:	2702      	movs	r7, #2
    data_to_send[1].data_length = sizeof(uint8) * 3;
    375e:	2303      	movs	r3, #3
    data_to_send[0].data_location = (uint8 *)&plmn_mode;
    3760:	ad0a      	add	r5, sp, #40	; 0x28
    RPC_ERR rpc_return = rpc_command_claim(CORES_PROTOCOL_CORE);
    3762:	0020      	movs	r0, r4
    data_to_send[0].data_length = sizeof(plmn_mode);
    3764:	80af      	strh	r7, [r5, #4]
    data_to_send[1].data_length = sizeof(uint8) * 3;
    3766:	81ab      	strh	r3, [r5, #12]
    RPC_ERR rpc_return = rpc_command_claim(CORES_PROTOCOL_CORE);
    3768:	f7fe fe78 	bl	245c <rpc_command_claim>
    if (rpc_return != RPC_ERR_OK)
    376c:	2800      	cmp	r0, #0
    376e:	d110      	bne.n	3792 <command_execute_plmn_select+0x5c>
    set_receive_info(CORES_PROTOCOL_CORE, &info);
    3770:	0031      	movs	r1, r6
    3772:	0020      	movs	r0, r4
    3774:	f7fe fb14 	bl	1da0 <set_receive_info>
    rpc_interface_scatter_send(CORES_PROTOCOL_CORE, RPC_APPLICATION_TO_PROTOCOL_EXECUTE_PLMN_SELECT, true, 2, data_to_send);
    3778:	003b      	movs	r3, r7
    377a:	0022      	movs	r2, r4
    377c:	210a      	movs	r1, #10
    377e:	0020      	movs	r0, r4
    3780:	9500      	str	r5, [sp, #0]
    3782:	f7fe fdbd 	bl	2300 <rpc_interface_scatter_send>
    rpc_blocking_loop(CORES_PROTOCOL_CORE);
    3786:	0020      	movs	r0, r4
    3788:	f7fe fe3e 	bl	2408 <rpc_blocking_loop>
    return rpc_command_release(CORES_PROTOCOL_CORE);
    378c:	0020      	movs	r0, r4
    378e:	f7fe fe51 	bl	2434 <rpc_command_release>
}
    3792:	b00f      	add	sp, #60	; 0x3c
    3794:	bdf0      	pop	{r4, r5, r6, r7, pc}

00003796 <command_get_plmn_status>:
{
    3796:	b570      	push	{r4, r5, r6, lr}
    info.num_sections = 2;
    3798:	2302      	movs	r3, #2
{
    379a:	0006      	movs	r6, r0
    379c:	000c      	movs	r4, r1
    379e:	b08a      	sub	sp, #40	; 0x28
    info.num_sections = 2;
    37a0:	ad02      	add	r5, sp, #8
    info.sections = get_sections;
    37a2:	a804      	add	r0, sp, #16
    info.num_sections = 2;
    37a4:	712b      	strb	r3, [r5, #4]
    rpc_init_receive_section(&get_sections[0], (uint8 *)current_mode, sizeof(uint8), NULL);
    37a6:	2201      	movs	r2, #1
    37a8:	2300      	movs	r3, #0
    37aa:	0031      	movs	r1, r6
    info.sections = get_sections;
    37ac:	9002      	str	r0, [sp, #8]
    rpc_init_receive_section(&get_sections[0], (uint8 *)current_mode, sizeof(uint8), NULL);
    37ae:	f7fe fe26 	bl	23fe <rpc_init_receive_section>
    rpc_init_receive_section(&get_sections[1], (uint8 *)current_plmn, sizeof(uint8) * 3, NULL);
    37b2:	0021      	movs	r1, r4
    37b4:	2300      	movs	r3, #0
    37b6:	2203      	movs	r2, #3
    37b8:	a807      	add	r0, sp, #28
    37ba:	f7fe fe20 	bl	23fe <rpc_init_receive_section>
    RPC_ERR rpc_return = rpc_command_claim(CORES_PROTOCOL_CORE);
    37be:	2001      	movs	r0, #1
    37c0:	f7fe fe4c 	bl	245c <rpc_command_claim>
    37c4:	1e04      	subs	r4, r0, #0
    if (rpc_return != RPC_ERR_OK)
    37c6:	d111      	bne.n	37ec <command_get_plmn_status+0x56>
    set_receive_info(CORES_PROTOCOL_CORE, &info);
    37c8:	0029      	movs	r1, r5
    37ca:	2001      	movs	r0, #1
    37cc:	f7fe fae8 	bl	1da0 <set_receive_info>
    rpc_interface_scatter_send(CORES_PROTOCOL_CORE, RPC_APPLICATION_TO_PROTOCOL_GET_PLMN_STATUS, true, 0, NULL);
    37d0:	2201      	movs	r2, #1
    37d2:	0023      	movs	r3, r4
    37d4:	0010      	movs	r0, r2
    37d6:	210b      	movs	r1, #11
    37d8:	9400      	str	r4, [sp, #0]
    37da:	f7fe fd91 	bl	2300 <rpc_interface_scatter_send>
    rpc_blocking_loop(CORES_PROTOCOL_CORE);
    37de:	2001      	movs	r0, #1
    37e0:	f7fe fe12 	bl	2408 <rpc_blocking_loop>
    return rpc_command_release(CORES_PROTOCOL_CORE);
    37e4:	2001      	movs	r0, #1
    37e6:	f7fe fe25 	bl	2434 <rpc_command_release>
    37ea:	0004      	movs	r4, r0
}
    37ec:	0020      	movs	r0, r4
    37ee:	b00a      	add	sp, #40	; 0x28
    37f0:	bd70      	pop	{r4, r5, r6, pc}

000037f2 <command_get_available_plmn>:
{
    37f2:	b570      	push	{r4, r5, r6, lr}
    info.num_sections = 1;
    37f4:	2401      	movs	r4, #1
{
    37f6:	b088      	sub	sp, #32
    37f8:	0001      	movs	r1, r0
    rpc_init_receive_section(&get_sections[0], (uint8 *)get_available_plmn_result, sizeof(uint8), NULL);
    37fa:	2300      	movs	r3, #0
    info.sections = get_sections;
    37fc:	a805      	add	r0, sp, #20
    rpc_init_receive_section(&get_sections[0], (uint8 *)get_available_plmn_result, sizeof(uint8), NULL);
    37fe:	0022      	movs	r2, r4
    info.num_sections = 1;
    3800:	ae03      	add	r6, sp, #12
    info.sections = get_sections;
    3802:	9003      	str	r0, [sp, #12]
    info.num_sections = 1;
    3804:	7134      	strb	r4, [r6, #4]
    rpc_init_receive_section(&get_sections[0], (uint8 *)get_available_plmn_result, sizeof(uint8), NULL);
    3806:	f7fe fdfa 	bl	23fe <rpc_init_receive_section>
    RPC_ERR rpc_return = rpc_command_claim(CORES_PROTOCOL_CORE);
    380a:	0020      	movs	r0, r4
    380c:	f7fe fe26 	bl	245c <rpc_command_claim>
    3810:	1e05      	subs	r5, r0, #0
    if (rpc_return != RPC_ERR_OK)
    3812:	d111      	bne.n	3838 <command_get_available_plmn+0x46>
    set_receive_info(CORES_PROTOCOL_CORE, &info);
    3814:	0031      	movs	r1, r6
    3816:	0020      	movs	r0, r4
    3818:	f7fe fac2 	bl	1da0 <set_receive_info>
    rpc_interface_scatter_send(CORES_PROTOCOL_CORE, RPC_APPLICATION_TO_PROTOCOL_GET_AVAILABLE_PLMN, true, 0, NULL);
    381c:	002b      	movs	r3, r5
    381e:	0022      	movs	r2, r4
    3820:	210c      	movs	r1, #12
    3822:	9500      	str	r5, [sp, #0]
    3824:	0020      	movs	r0, r4
    3826:	f7fe fd6b 	bl	2300 <rpc_interface_scatter_send>
    rpc_blocking_loop(CORES_PROTOCOL_CORE);
    382a:	0020      	movs	r0, r4
    382c:	f7fe fdec 	bl	2408 <rpc_blocking_loop>
    return rpc_command_release(CORES_PROTOCOL_CORE);
    3830:	0020      	movs	r0, r4
    3832:	f7fe fdff 	bl	2434 <rpc_command_release>
    3836:	0005      	movs	r5, r0
}
    3838:	0028      	movs	r0, r5
    383a:	b008      	add	sp, #32
    383c:	bd70      	pop	{r4, r5, r6, pc}

0000383e <command_set_attach_state>:
{
    383e:	b5f0      	push	{r4, r5, r6, r7, lr}
    3840:	270e      	movs	r7, #14
    info.num_sections = 1;
    3842:	2401      	movs	r4, #1
{
    3844:	b08d      	sub	sp, #52	; 0x34
    3846:	446f      	add	r7, sp
    3848:	8038      	strh	r0, [r7, #0]
    rpc_init_receive_section(&get_sections[0], (uint8 *)set_result, sizeof(uint8), NULL);
    384a:	2300      	movs	r3, #0
    info.sections = get_sections;
    384c:	a809      	add	r0, sp, #36	; 0x24
    info.num_sections = 1;
    384e:	ae05      	add	r6, sp, #20
    rpc_init_receive_section(&get_sections[0], (uint8 *)set_result, sizeof(uint8), NULL);
    3850:	0022      	movs	r2, r4
    info.sections = get_sections;
    3852:	9005      	str	r0, [sp, #20]
    info.num_sections = 1;
    3854:	7134      	strb	r4, [r6, #4]
    rpc_init_receive_section(&get_sections[0], (uint8 *)set_result, sizeof(uint8), NULL);
    3856:	f7fe fdd2 	bl	23fe <rpc_init_receive_section>
    data_to_send[0].data_length = sizeof(state);
    385a:	2302      	movs	r3, #2
    data_to_send[0].data_location = (uint8 *)&state;
    385c:	ad07      	add	r5, sp, #28
    RPC_ERR rpc_return = rpc_command_claim(CORES_PROTOCOL_CORE);
    385e:	0020      	movs	r0, r4
    data_to_send[0].data_location = (uint8 *)&state;
    3860:	9707      	str	r7, [sp, #28]
    data_to_send[0].data_length = sizeof(state);
    3862:	80ab      	strh	r3, [r5, #4]
    RPC_ERR rpc_return = rpc_command_claim(CORES_PROTOCOL_CORE);
    3864:	f7fe fdfa 	bl	245c <rpc_command_claim>
    if (rpc_return != RPC_ERR_OK)
    3868:	2800      	cmp	r0, #0
    386a:	d110      	bne.n	388e <command_set_attach_state+0x50>
    set_receive_info(CORES_PROTOCOL_CORE, &info);
    386c:	0031      	movs	r1, r6
    386e:	0020      	movs	r0, r4
    3870:	f7fe fa96 	bl	1da0 <set_receive_info>
    rpc_interface_scatter_send(CORES_PROTOCOL_CORE, RPC_APPLICATION_TO_PROTOCOL_SET_ATTACH_STATE, true, 1, data_to_send);
    3874:	0023      	movs	r3, r4
    3876:	0022      	movs	r2, r4
    3878:	210e      	movs	r1, #14
    387a:	0020      	movs	r0, r4
    387c:	9500      	str	r5, [sp, #0]
    387e:	f7fe fd3f 	bl	2300 <rpc_interface_scatter_send>
    rpc_blocking_loop(CORES_PROTOCOL_CORE);
    3882:	0020      	movs	r0, r4
    3884:	f7fe fdc0 	bl	2408 <rpc_blocking_loop>
    return rpc_command_release(CORES_PROTOCOL_CORE);
    3888:	0020      	movs	r0, r4
    388a:	f7fe fdd3 	bl	2434 <rpc_command_release>
}
    388e:	b00d      	add	sp, #52	; 0x34
    3890:	bdf0      	pop	{r4, r5, r6, r7, pc}

00003892 <command_get_imsi>:
{
    3892:	b5f0      	push	{r4, r5, r6, r7, lr}
    3894:	001c      	movs	r4, r3
    3896:	0006      	movs	r6, r0
    3898:	000f      	movs	r7, r1
    info.num_sections = 2;
    389a:	2302      	movs	r3, #2
{
    389c:	b08b      	sub	sp, #44	; 0x2c
    info.num_sections = 2;
    389e:	ad02      	add	r5, sp, #8
{
    38a0:	0011      	movs	r1, r2
    info.sections = get_sections;
    38a2:	a804      	add	r0, sp, #16
    info.num_sections = 2;
    38a4:	712b      	strb	r3, [r5, #4]
    rpc_init_receive_section(&get_sections[0], (uint8 *)imsi, imsi_max_length, imsi_length);
    38a6:	0032      	movs	r2, r6
    38a8:	003b      	movs	r3, r7
    info.sections = get_sections;
    38aa:	9002      	str	r0, [sp, #8]
    rpc_init_receive_section(&get_sections[0], (uint8 *)imsi, imsi_max_length, imsi_length);
    38ac:	f7fe fda7 	bl	23fe <rpc_init_receive_section>
    rpc_init_receive_section(&get_sections[1], (uint8 *)result, sizeof(uint8), NULL);
    38b0:	0021      	movs	r1, r4
    38b2:	2300      	movs	r3, #0
    38b4:	2201      	movs	r2, #1
    38b6:	a807      	add	r0, sp, #28
    38b8:	f7fe fda1 	bl	23fe <rpc_init_receive_section>
    RPC_ERR rpc_return = rpc_command_claim(CORES_PROTOCOL_CORE);
    38bc:	2001      	movs	r0, #1
    38be:	f7fe fdcd 	bl	245c <rpc_command_claim>
    38c2:	1e04      	subs	r4, r0, #0
    if (rpc_return != RPC_ERR_OK)
    38c4:	d111      	bne.n	38ea <command_get_imsi+0x58>
    set_receive_info(CORES_PROTOCOL_CORE, &info);
    38c6:	0029      	movs	r1, r5
    38c8:	2001      	movs	r0, #1
    38ca:	f7fe fa69 	bl	1da0 <set_receive_info>
    rpc_interface_scatter_send(CORES_PROTOCOL_CORE, RPC_APPLICATION_TO_PROTOCOL_GET_IMSI, true, 0, NULL);
    38ce:	2201      	movs	r2, #1
    38d0:	0023      	movs	r3, r4
    38d2:	0010      	movs	r0, r2
    38d4:	210f      	movs	r1, #15
    38d6:	9400      	str	r4, [sp, #0]
    38d8:	f7fe fd12 	bl	2300 <rpc_interface_scatter_send>
    rpc_blocking_loop(CORES_PROTOCOL_CORE);
    38dc:	2001      	movs	r0, #1
    38de:	f7fe fd93 	bl	2408 <rpc_blocking_loop>
    return rpc_command_release(CORES_PROTOCOL_CORE);
    38e2:	2001      	movs	r0, #1
    38e4:	f7fe fda6 	bl	2434 <rpc_command_release>
    38e8:	0004      	movs	r4, r0
}
    38ea:	0020      	movs	r0, r4
    38ec:	b00b      	add	sp, #44	; 0x2c
    38ee:	bdf0      	pop	{r4, r5, r6, r7, pc}

000038f0 <command_get_registration_status>:
{
    38f0:	b5f0      	push	{r4, r5, r6, r7, lr}
    38f2:	4684      	mov	ip, r0
    38f4:	001c      	movs	r4, r3
    info.num_sections = 7;
    38f6:	2307      	movs	r3, #7
{
    38f8:	000f      	movs	r7, r1
    38fa:	0016      	movs	r6, r2
    38fc:	b09b      	sub	sp, #108	; 0x6c
    info.num_sections = 7;
    38fe:	ad03      	add	r5, sp, #12
    rpc_init_receive_section(&get_sections[0], (uint8 *)state, sizeof(uint8), NULL);
    3900:	4661      	mov	r1, ip
    info.sections = get_sections;
    3902:	a805      	add	r0, sp, #20
    info.num_sections = 7;
    3904:	712b      	strb	r3, [r5, #4]
    rpc_init_receive_section(&get_sections[0], (uint8 *)state, sizeof(uint8), NULL);
    3906:	2201      	movs	r2, #1
    3908:	2300      	movs	r3, #0
    info.sections = get_sections;
    390a:	9003      	str	r0, [sp, #12]
    rpc_init_receive_section(&get_sections[0], (uint8 *)state, sizeof(uint8), NULL);
    390c:	f7fe fd77 	bl	23fe <rpc_init_receive_section>
    rpc_init_receive_section(&get_sections[1], (uint8 *)tac, sizeof(uint16), NULL);
    3910:	2300      	movs	r3, #0
    3912:	2202      	movs	r2, #2
    3914:	0039      	movs	r1, r7
    3916:	a808      	add	r0, sp, #32
    3918:	f7fe fd71 	bl	23fe <rpc_init_receive_section>
    rpc_init_receive_section(&get_sections[2], (uint8 *)ci, sizeof(uint32), NULL);
    391c:	2300      	movs	r3, #0
    391e:	2204      	movs	r2, #4
    3920:	0031      	movs	r1, r6
    3922:	a80b      	add	r0, sp, #44	; 0x2c
    3924:	f7fe fd6b 	bl	23fe <rpc_init_receive_section>
    rpc_init_receive_section(&get_sections[3], (uint8 *)reject_flag, sizeof(bool), NULL);
    3928:	0021      	movs	r1, r4
    392a:	2300      	movs	r3, #0
    392c:	2201      	movs	r2, #1
    392e:	a80e      	add	r0, sp, #56	; 0x38
    3930:	f7fe fd65 	bl	23fe <rpc_init_receive_section>
    rpc_init_receive_section(&get_sections[4], (uint8 *)reject_cause, sizeof(uint8), NULL);
    3934:	2300      	movs	r3, #0
    3936:	2201      	movs	r2, #1
    3938:	9920      	ldr	r1, [sp, #128]	; 0x80
    393a:	a811      	add	r0, sp, #68	; 0x44
    393c:	f7fe fd5f 	bl	23fe <rpc_init_receive_section>
    rpc_init_receive_section(&get_sections[5], (uint8 *)active_time, sizeof(uint16), NULL);
    3940:	2300      	movs	r3, #0
    3942:	2202      	movs	r2, #2
    3944:	9921      	ldr	r1, [sp, #132]	; 0x84
    3946:	a814      	add	r0, sp, #80	; 0x50
    3948:	f7fe fd59 	bl	23fe <rpc_init_receive_section>
    rpc_init_receive_section(&get_sections[6], (uint8 *)periodic_tau, sizeof(uint16), NULL);
    394c:	2300      	movs	r3, #0
    394e:	2202      	movs	r2, #2
    3950:	9922      	ldr	r1, [sp, #136]	; 0x88
    3952:	a817      	add	r0, sp, #92	; 0x5c
    3954:	f7fe fd53 	bl	23fe <rpc_init_receive_section>
    RPC_ERR rpc_return = rpc_command_claim(CORES_PROTOCOL_CORE);
    3958:	2001      	movs	r0, #1
    395a:	f7fe fd7f 	bl	245c <rpc_command_claim>
    395e:	1e04      	subs	r4, r0, #0
    if (rpc_return != RPC_ERR_OK)
    3960:	d111      	bne.n	3986 <command_get_registration_status+0x96>
    set_receive_info(CORES_PROTOCOL_CORE, &info);
    3962:	0029      	movs	r1, r5
    3964:	2001      	movs	r0, #1
    3966:	f7fe fa1b 	bl	1da0 <set_receive_info>
    rpc_interface_scatter_send(CORES_PROTOCOL_CORE, RPC_APPLICATION_TO_PROTOCOL_GET_REGISTRATION_STATUS, true, 0, NULL);
    396a:	2201      	movs	r2, #1
    396c:	0023      	movs	r3, r4
    396e:	0010      	movs	r0, r2
    3970:	2110      	movs	r1, #16
    3972:	9400      	str	r4, [sp, #0]
    3974:	f7fe fcc4 	bl	2300 <rpc_interface_scatter_send>
    rpc_blocking_loop(CORES_PROTOCOL_CORE);
    3978:	2001      	movs	r0, #1
    397a:	f7fe fd45 	bl	2408 <rpc_blocking_loop>
    return rpc_command_release(CORES_PROTOCOL_CORE);
    397e:	2001      	movs	r0, #1
    3980:	f7fe fd58 	bl	2434 <rpc_command_release>
    3984:	0004      	movs	r4, r0
}
    3986:	0020      	movs	r0, r4
    3988:	b01b      	add	sp, #108	; 0x6c
    398a:	bdf0      	pop	{r4, r5, r6, r7, pc}

0000398c <command_get_connection_status>:
{
    398c:	b570      	push	{r4, r5, r6, lr}
    info.num_sections = 1;
    398e:	2401      	movs	r4, #1
{
    3990:	b088      	sub	sp, #32
    3992:	0001      	movs	r1, r0
    rpc_init_receive_section(&get_sections[0], (uint8 *)status, sizeof(uint8), NULL);
    3994:	2300      	movs	r3, #0
    info.sections = get_sections;
    3996:	a805      	add	r0, sp, #20
    rpc_init_receive_section(&get_sections[0], (uint8 *)status, sizeof(uint8), NULL);
    3998:	0022      	movs	r2, r4
    info.num_sections = 1;
    399a:	ae03      	add	r6, sp, #12
    info.sections = get_sections;
    399c:	9003      	str	r0, [sp, #12]
    info.num_sections = 1;
    399e:	7134      	strb	r4, [r6, #4]
    rpc_init_receive_section(&get_sections[0], (uint8 *)status, sizeof(uint8), NULL);
    39a0:	f7fe fd2d 	bl	23fe <rpc_init_receive_section>
    RPC_ERR rpc_return = rpc_command_claim(CORES_PROTOCOL_CORE);
    39a4:	0020      	movs	r0, r4
    39a6:	f7fe fd59 	bl	245c <rpc_command_claim>
    39aa:	1e05      	subs	r5, r0, #0
    if (rpc_return != RPC_ERR_OK)
    39ac:	d111      	bne.n	39d2 <command_get_connection_status+0x46>
    set_receive_info(CORES_PROTOCOL_CORE, &info);
    39ae:	0031      	movs	r1, r6
    39b0:	0020      	movs	r0, r4
    39b2:	f7fe f9f5 	bl	1da0 <set_receive_info>
    rpc_interface_scatter_send(CORES_PROTOCOL_CORE, RPC_APPLICATION_TO_PROTOCOL_GET_CONNECTION_STATUS, true, 0, NULL);
    39b6:	002b      	movs	r3, r5
    39b8:	0022      	movs	r2, r4
    39ba:	2111      	movs	r1, #17
    39bc:	9500      	str	r5, [sp, #0]
    39be:	0020      	movs	r0, r4
    39c0:	f7fe fc9e 	bl	2300 <rpc_interface_scatter_send>
    rpc_blocking_loop(CORES_PROTOCOL_CORE);
    39c4:	0020      	movs	r0, r4
    39c6:	f7fe fd1f 	bl	2408 <rpc_blocking_loop>
    return rpc_command_release(CORES_PROTOCOL_CORE);
    39ca:	0020      	movs	r0, r4
    39cc:	f7fe fd32 	bl	2434 <rpc_command_release>
    39d0:	0005      	movs	r5, r0
}
    39d2:	0028      	movs	r0, r5
    39d4:	b008      	add	sp, #32
    39d6:	bd70      	pop	{r4, r5, r6, pc}

000039d8 <command_set_pdp_context>:
{
    39d8:	b5f0      	push	{r4, r5, r6, r7, lr}
    39da:	b09f      	sub	sp, #124	; 0x7c
    info.num_sections = 1;
    39dc:	2501      	movs	r5, #1
{
    39de:	9302      	str	r3, [sp, #8]
    39e0:	466b      	mov	r3, sp
    39e2:	ae03      	add	r6, sp, #12
    39e4:	73d8      	strb	r0, [r3, #15]
    39e6:	7399      	strb	r1, [r3, #14]
    info.sections = get_sections;
    39e8:	a807      	add	r0, sp, #28
{
    39ea:	8032      	strh	r2, [r6, #0]
    rpc_init_receive_section(&get_sections[0], (uint8 *)result, sizeof(uint8), NULL);
    39ec:	2300      	movs	r3, #0
    info.num_sections = 1;
    39ee:	af05      	add	r7, sp, #20
    rpc_init_receive_section(&get_sections[0], (uint8 *)result, sizeof(uint8), NULL);
    39f0:	002a      	movs	r2, r5
    39f2:	992a      	ldr	r1, [sp, #168]	; 0xa8
    info.sections = get_sections;
    39f4:	9005      	str	r0, [sp, #20]
    info.num_sections = 1;
    39f6:	713d      	strb	r5, [r7, #4]
    rpc_init_receive_section(&get_sections[0], (uint8 *)result, sizeof(uint8), NULL);
    39f8:	f7fe fd01 	bl	23fe <rpc_init_receive_section>
    data_to_send[0].data_location = (uint8 *)&cid;
    39fc:	230f      	movs	r3, #15
    39fe:	446b      	add	r3, sp
    3a00:	930a      	str	r3, [sp, #40]	; 0x28
    data_to_send[1].data_location = (uint8 *)&pdp_type;
    3a02:	230e      	movs	r3, #14
    data_to_send[0].data_location = (uint8 *)&cid;
    3a04:	ac0a      	add	r4, sp, #40	; 0x28
    data_to_send[1].data_location = (uint8 *)&pdp_type;
    3a06:	446b      	add	r3, sp
    3a08:	60a3      	str	r3, [r4, #8]
    data_to_send[2].data_length = sizeof(p_apn_str_length);
    3a0a:	2302      	movs	r3, #2
    3a0c:	82a3      	strh	r3, [r4, #20]
    data_to_send[3].data_location = (uint8 *)p_apn_str;
    3a0e:	9b02      	ldr	r3, [sp, #8]
    RPC_ERR rpc_return = rpc_command_claim(CORES_PROTOCOL_CORE);
    3a10:	0028      	movs	r0, r5
    data_to_send[3].data_location = (uint8 *)p_apn_str;
    3a12:	61a3      	str	r3, [r4, #24]
    data_to_send[3].data_length = p_apn_str_length;
    3a14:	8833      	ldrh	r3, [r6, #0]
    data_to_send[0].data_length = sizeof(cid);
    3a16:	80a5      	strh	r5, [r4, #4]
    data_to_send[3].data_length = p_apn_str_length;
    3a18:	83a3      	strh	r3, [r4, #28]
    data_to_send[4].data_location = (uint8 *)&d_comp;
    3a1a:	ab24      	add	r3, sp, #144	; 0x90
    3a1c:	6223      	str	r3, [r4, #32]
    data_to_send[5].data_location = (uint8 *)&h_comp;
    3a1e:	ab25      	add	r3, sp, #148	; 0x94
    3a20:	62a3      	str	r3, [r4, #40]	; 0x28
    data_to_send[6].data_location = (uint8 *)&p_emergency;
    3a22:	ab26      	add	r3, sp, #152	; 0x98
    3a24:	6323      	str	r3, [r4, #48]	; 0x30
    data_to_send[7].data_location = (uint8 *)&addr_alloc;
    3a26:	ab27      	add	r3, sp, #156	; 0x9c
    3a28:	63a3      	str	r3, [r4, #56]	; 0x38
    data_to_send[8].data_location = (uint8 *)&nslpi;
    3a2a:	ab28      	add	r3, sp, #160	; 0xa0
    3a2c:	6423      	str	r3, [r4, #64]	; 0x40
    data_to_send[8].data_length = sizeof(nslpi);
    3a2e:	232e      	movs	r3, #46	; 0x2e
    3a30:	446b      	add	r3, sp
    3a32:	87dd      	strh	r5, [r3, #62]	; 0x3e
    data_to_send[9].data_location = (uint8 *)&secure_pco;
    3a34:	ab29      	add	r3, sp, #164	; 0xa4
    3a36:	64a3      	str	r3, [r4, #72]	; 0x48
    data_to_send[9].data_length = sizeof(secure_pco);
    3a38:	ab1d      	add	r3, sp, #116	; 0x74
    3a3a:	801d      	strh	r5, [r3, #0]
    data_to_send[1].data_length = sizeof(pdp_type);
    3a3c:	81a5      	strh	r5, [r4, #12]
    data_to_send[2].data_location = (uint8 *)&p_apn_str_length;
    3a3e:	6126      	str	r6, [r4, #16]
    data_to_send[4].data_length = sizeof(d_comp);
    3a40:	84a5      	strh	r5, [r4, #36]	; 0x24
    data_to_send[5].data_length = sizeof(h_comp);
    3a42:	85a5      	strh	r5, [r4, #44]	; 0x2c
    data_to_send[6].data_length = sizeof(p_emergency);
    3a44:	86a5      	strh	r5, [r4, #52]	; 0x34
    data_to_send[7].data_length = sizeof(addr_alloc);
    3a46:	87a5      	strh	r5, [r4, #60]	; 0x3c
    RPC_ERR rpc_return = rpc_command_claim(CORES_PROTOCOL_CORE);
    3a48:	f7fe fd08 	bl	245c <rpc_command_claim>
    if (rpc_return != RPC_ERR_OK)
    3a4c:	2800      	cmp	r0, #0
    3a4e:	d110      	bne.n	3a72 <command_set_pdp_context+0x9a>
    set_receive_info(CORES_PROTOCOL_CORE, &info);
    3a50:	0039      	movs	r1, r7
    3a52:	0028      	movs	r0, r5
    3a54:	f7fe f9a4 	bl	1da0 <set_receive_info>
    rpc_interface_scatter_send(CORES_PROTOCOL_CORE, RPC_APPLICATION_TO_PROTOCOL_SET_PDP_CONTEXT, true, 10, data_to_send);
    3a58:	230a      	movs	r3, #10
    3a5a:	002a      	movs	r2, r5
    3a5c:	2112      	movs	r1, #18
    3a5e:	0028      	movs	r0, r5
    3a60:	9400      	str	r4, [sp, #0]
    3a62:	f7fe fc4d 	bl	2300 <rpc_interface_scatter_send>
    rpc_blocking_loop(CORES_PROTOCOL_CORE);
    3a66:	0028      	movs	r0, r5
    3a68:	f7fe fcce 	bl	2408 <rpc_blocking_loop>
    return rpc_command_release(CORES_PROTOCOL_CORE);
    3a6c:	0028      	movs	r0, r5
    3a6e:	f7fe fce1 	bl	2434 <rpc_command_release>
}
    3a72:	b01f      	add	sp, #124	; 0x7c
    3a74:	bdf0      	pop	{r4, r5, r6, r7, pc}

00003a76 <command_delete_pdp_context>:
{
    3a76:	b5f0      	push	{r4, r5, r6, r7, lr}
    3a78:	270e      	movs	r7, #14
    info.num_sections = 1;
    3a7a:	2401      	movs	r4, #1
{
    3a7c:	b08d      	sub	sp, #52	; 0x34
    3a7e:	446f      	add	r7, sp
    3a80:	8038      	strh	r0, [r7, #0]
    rpc_init_receive_section(&get_sections[0], (uint8 *)delete_pdp_context_result, sizeof(uint8), NULL);
    3a82:	2300      	movs	r3, #0
    info.sections = get_sections;
    3a84:	a809      	add	r0, sp, #36	; 0x24
    info.num_sections = 1;
    3a86:	ae05      	add	r6, sp, #20
    rpc_init_receive_section(&get_sections[0], (uint8 *)delete_pdp_context_result, sizeof(uint8), NULL);
    3a88:	0022      	movs	r2, r4
    info.sections = get_sections;
    3a8a:	9005      	str	r0, [sp, #20]
    info.num_sections = 1;
    3a8c:	7134      	strb	r4, [r6, #4]
    rpc_init_receive_section(&get_sections[0], (uint8 *)delete_pdp_context_result, sizeof(uint8), NULL);
    3a8e:	f7fe fcb6 	bl	23fe <rpc_init_receive_section>
    data_to_send[0].data_length = sizeof(cid);
    3a92:	2302      	movs	r3, #2
    data_to_send[0].data_location = (uint8 *)&cid;
    3a94:	ad07      	add	r5, sp, #28
    RPC_ERR rpc_return = rpc_command_claim(CORES_PROTOCOL_CORE);
    3a96:	0020      	movs	r0, r4
    data_to_send[0].data_location = (uint8 *)&cid;
    3a98:	9707      	str	r7, [sp, #28]
    data_to_send[0].data_length = sizeof(cid);
    3a9a:	80ab      	strh	r3, [r5, #4]
    RPC_ERR rpc_return = rpc_command_claim(CORES_PROTOCOL_CORE);
    3a9c:	f7fe fcde 	bl	245c <rpc_command_claim>
    if (rpc_return != RPC_ERR_OK)
    3aa0:	2800      	cmp	r0, #0
    3aa2:	d110      	bne.n	3ac6 <command_delete_pdp_context+0x50>
    set_receive_info(CORES_PROTOCOL_CORE, &info);
    3aa4:	0031      	movs	r1, r6
    3aa6:	0020      	movs	r0, r4
    3aa8:	f7fe f97a 	bl	1da0 <set_receive_info>
    rpc_interface_scatter_send(CORES_PROTOCOL_CORE, RPC_APPLICATION_TO_PROTOCOL_DELETE_PDP_CONTEXT, true, 1, data_to_send);
    3aac:	0023      	movs	r3, r4
    3aae:	0022      	movs	r2, r4
    3ab0:	2113      	movs	r1, #19
    3ab2:	0020      	movs	r0, r4
    3ab4:	9500      	str	r5, [sp, #0]
    3ab6:	f7fe fc23 	bl	2300 <rpc_interface_scatter_send>
    rpc_blocking_loop(CORES_PROTOCOL_CORE);
    3aba:	0020      	movs	r0, r4
    3abc:	f7fe fca4 	bl	2408 <rpc_blocking_loop>
    return rpc_command_release(CORES_PROTOCOL_CORE);
    3ac0:	0020      	movs	r0, r4
    3ac2:	f7fe fcb7 	bl	2434 <rpc_command_release>
}
    3ac6:	b00d      	add	sp, #52	; 0x34
    3ac8:	bdf0      	pop	{r4, r5, r6, r7, pc}

00003aca <command_get_pdp_context>:
{
    3aca:	b5f0      	push	{r4, r5, r6, r7, lr}
    3acc:	250f      	movs	r5, #15
    3ace:	b095      	sub	sp, #84	; 0x54
    3ad0:	001f      	movs	r7, r3
    3ad2:	ab1a      	add	r3, sp, #104	; 0x68
    3ad4:	0016      	movs	r6, r2
    3ad6:	cb04      	ldmia	r3!, {r2}
    info.num_sections = 3;
    3ad8:	ac07      	add	r4, sp, #28
{
    3ada:	881b      	ldrh	r3, [r3, #0]
    3adc:	9203      	str	r2, [sp, #12]
    3ade:	9304      	str	r3, [sp, #16]
    3ae0:	ab02      	add	r3, sp, #8
    3ae2:	18ed      	adds	r5, r5, r3
    info.num_sections = 3;
    3ae4:	2303      	movs	r3, #3
{
    3ae6:	7028      	strb	r0, [r5, #0]
    info.num_sections = 3;
    3ae8:	7123      	strb	r3, [r4, #4]
    info.sections = get_sections;
    3aea:	a80b      	add	r0, sp, #44	; 0x2c
    rpc_init_receive_section(&get_sections[0], (uint8 *)result, sizeof(uint8), NULL);
    3aec:	2300      	movs	r3, #0
    3aee:	2201      	movs	r2, #1
    info.sections = get_sections;
    3af0:	9007      	str	r0, [sp, #28]
    rpc_init_receive_section(&get_sections[0], (uint8 *)result, sizeof(uint8), NULL);
    3af2:	f7fe fc84 	bl	23fe <rpc_init_receive_section>
    rpc_init_receive_section(&get_sections[1], (uint8 *)apn, apn_max_length, apn_length);
    3af6:	0032      	movs	r2, r6
    3af8:	003b      	movs	r3, r7
    3afa:	9903      	ldr	r1, [sp, #12]
    3afc:	a80e      	add	r0, sp, #56	; 0x38
    3afe:	f7fe fc7e 	bl	23fe <rpc_init_receive_section>
    rpc_init_receive_section(&get_sections[2], (uint8 *)context, context_max_length, context_length);
    3b02:	a811      	add	r0, sp, #68	; 0x44
    3b04:	9b1c      	ldr	r3, [sp, #112]	; 0x70
    3b06:	9a04      	ldr	r2, [sp, #16]
    3b08:	991d      	ldr	r1, [sp, #116]	; 0x74
    3b0a:	f7fe fc78 	bl	23fe <rpc_init_receive_section>
    data_to_send[0].data_location = (uint8 *)&cid_requested;
    3b0e:	9509      	str	r5, [sp, #36]	; 0x24
    data_to_send[0].data_length = sizeof(cid_requested);
    3b10:	2501      	movs	r5, #1
    data_to_send[0].data_location = (uint8 *)&cid_requested;
    3b12:	ae09      	add	r6, sp, #36	; 0x24
    data_to_send[0].data_length = sizeof(cid_requested);
    3b14:	80b5      	strh	r5, [r6, #4]
    RPC_ERR rpc_return = rpc_command_claim(CORES_PROTOCOL_CORE);
    3b16:	0028      	movs	r0, r5
    3b18:	f7fe fca0 	bl	245c <rpc_command_claim>
    if (rpc_return != RPC_ERR_OK)
    3b1c:	2800      	cmp	r0, #0
    3b1e:	d110      	bne.n	3b42 <command_get_pdp_context+0x78>
    set_receive_info(CORES_PROTOCOL_CORE, &info);
    3b20:	0021      	movs	r1, r4
    3b22:	0028      	movs	r0, r5
    3b24:	f7fe f93c 	bl	1da0 <set_receive_info>
    rpc_interface_scatter_send(CORES_PROTOCOL_CORE, RPC_APPLICATION_TO_PROTOCOL_GET_PDP_CONTEXT, true, 1, data_to_send);
    3b28:	002b      	movs	r3, r5
    3b2a:	002a      	movs	r2, r5
    3b2c:	2114      	movs	r1, #20
    3b2e:	0028      	movs	r0, r5
    3b30:	9600      	str	r6, [sp, #0]
    3b32:	f7fe fbe5 	bl	2300 <rpc_interface_scatter_send>
    rpc_blocking_loop(CORES_PROTOCOL_CORE);
    3b36:	0028      	movs	r0, r5
    3b38:	f7fe fc66 	bl	2408 <rpc_blocking_loop>
    return rpc_command_release(CORES_PROTOCOL_CORE);
    3b3c:	0028      	movs	r0, r5
    3b3e:	f7fe fc79 	bl	2434 <rpc_command_release>
}
    3b42:	b015      	add	sp, #84	; 0x54
    3b44:	bdf0      	pop	{r4, r5, r6, r7, pc}

00003b46 <command_set_pdp_context_auth_param>:
{
    3b46:	b5f0      	push	{r4, r5, r6, r7, lr}
    3b48:	b097      	sub	sp, #92	; 0x5c
    info.num_sections = 1;
    3b4a:	2501      	movs	r5, #1
{
    3b4c:	9302      	str	r3, [sp, #8]
    3b4e:	466b      	mov	r3, sp
    3b50:	ae03      	add	r6, sp, #12
    3b52:	73d8      	strb	r0, [r3, #15]
    3b54:	7399      	strb	r1, [r3, #14]
    info.sections = get_sections;
    3b56:	a807      	add	r0, sp, #28
{
    3b58:	8032      	strh	r2, [r6, #0]
    rpc_init_receive_section(&get_sections[0], (uint8 *)result, sizeof(uint8), NULL);
    3b5a:	2300      	movs	r3, #0
    3b5c:	002a      	movs	r2, r5
    info.num_sections = 1;
    3b5e:	af05      	add	r7, sp, #20
    rpc_init_receive_section(&get_sections[0], (uint8 *)result, sizeof(uint8), NULL);
    3b60:	991e      	ldr	r1, [sp, #120]	; 0x78
    info.sections = get_sections;
    3b62:	9005      	str	r0, [sp, #20]
    info.num_sections = 1;
    3b64:	713d      	strb	r5, [r7, #4]
    rpc_init_receive_section(&get_sections[0], (uint8 *)result, sizeof(uint8), NULL);
    3b66:	f7fe fc4a 	bl	23fe <rpc_init_receive_section>
    data_to_send[0].data_location = (uint8 *)&cid;
    3b6a:	230f      	movs	r3, #15
    3b6c:	446b      	add	r3, sp
    3b6e:	930a      	str	r3, [sp, #40]	; 0x28
    data_to_send[1].data_location = (uint8 *)&auth_prot;
    3b70:	230e      	movs	r3, #14
    3b72:	446b      	add	r3, sp
    3b74:	930c      	str	r3, [sp, #48]	; 0x30
    data_to_send[2].data_length = sizeof(login_str_length);
    3b76:	2302      	movs	r3, #2
    data_to_send[3].data_location = (uint8 *)login_str;
    3b78:	9a02      	ldr	r2, [sp, #8]
    data_to_send[0].data_location = (uint8 *)&cid;
    3b7a:	ac0a      	add	r4, sp, #40	; 0x28
    data_to_send[3].data_location = (uint8 *)login_str;
    3b7c:	9210      	str	r2, [sp, #64]	; 0x40
    data_to_send[3].data_length = login_str_length;
    3b7e:	8832      	ldrh	r2, [r6, #0]
    data_to_send[2].data_length = sizeof(login_str_length);
    3b80:	82a3      	strh	r3, [r4, #20]
    data_to_send[4].data_length = sizeof(password_str_length);
    3b82:	84a3      	strh	r3, [r4, #36]	; 0x24
    data_to_send[5].data_location = (uint8 *)password_str;
    3b84:	9b1d      	ldr	r3, [sp, #116]	; 0x74
    data_to_send[3].data_length = login_str_length;
    3b86:	83a2      	strh	r2, [r4, #28]
    data_to_send[4].data_location = (uint8 *)&password_str_length;
    3b88:	aa1c      	add	r2, sp, #112	; 0x70
    data_to_send[5].data_location = (uint8 *)password_str;
    3b8a:	9314      	str	r3, [sp, #80]	; 0x50
    data_to_send[5].data_length = password_str_length;
    3b8c:	8813      	ldrh	r3, [r2, #0]
    RPC_ERR rpc_return = rpc_command_claim(CORES_PROTOCOL_CORE);
    3b8e:	0028      	movs	r0, r5
    data_to_send[0].data_length = sizeof(cid);
    3b90:	80a5      	strh	r5, [r4, #4]
    data_to_send[1].data_length = sizeof(auth_prot);
    3b92:	81a5      	strh	r5, [r4, #12]
    data_to_send[2].data_location = (uint8 *)&login_str_length;
    3b94:	960e      	str	r6, [sp, #56]	; 0x38
    data_to_send[4].data_location = (uint8 *)&password_str_length;
    3b96:	9212      	str	r2, [sp, #72]	; 0x48
    data_to_send[5].data_length = password_str_length;
    3b98:	85a3      	strh	r3, [r4, #44]	; 0x2c
    RPC_ERR rpc_return = rpc_command_claim(CORES_PROTOCOL_CORE);
    3b9a:	f7fe fc5f 	bl	245c <rpc_command_claim>
    if (rpc_return != RPC_ERR_OK)
    3b9e:	2800      	cmp	r0, #0
    3ba0:	d110      	bne.n	3bc4 <command_set_pdp_context_auth_param+0x7e>
    set_receive_info(CORES_PROTOCOL_CORE, &info);
    3ba2:	0039      	movs	r1, r7
    3ba4:	0028      	movs	r0, r5
    3ba6:	f7fe f8fb 	bl	1da0 <set_receive_info>
    rpc_interface_scatter_send(CORES_PROTOCOL_CORE, RPC_APPLICATION_TO_PROTOCOL_SET_PDP_CONTEXT_AUTH_PARAM, true, 6, data_to_send);
    3baa:	2306      	movs	r3, #6
    3bac:	002a      	movs	r2, r5
    3bae:	2115      	movs	r1, #21
    3bb0:	0028      	movs	r0, r5
    3bb2:	9400      	str	r4, [sp, #0]
    3bb4:	f7fe fba4 	bl	2300 <rpc_interface_scatter_send>
    rpc_blocking_loop(CORES_PROTOCOL_CORE);
    3bb8:	0028      	movs	r0, r5
    3bba:	f7fe fc25 	bl	2408 <rpc_blocking_loop>
    return rpc_command_release(CORES_PROTOCOL_CORE);
    3bbe:	0028      	movs	r0, r5
    3bc0:	f7fe fc38 	bl	2434 <rpc_command_release>
}
    3bc4:	b017      	add	sp, #92	; 0x5c
    3bc6:	bdf0      	pop	{r4, r5, r6, r7, pc}

00003bc8 <command_get_pdp_context_auth_param>:
{
    3bc8:	b5f0      	push	{r4, r5, r6, r7, lr}
    3bca:	b095      	sub	sp, #84	; 0x54
    3bcc:	001e      	movs	r6, r3
    3bce:	ab1c      	add	r3, sp, #112	; 0x70
    3bd0:	881b      	ldrh	r3, [r3, #0]
    3bd2:	250f      	movs	r5, #15
    3bd4:	9302      	str	r3, [sp, #8]
    info.num_sections = 4;
    3bd6:	2304      	movs	r3, #4
{
    3bd8:	0017      	movs	r7, r2
    3bda:	446d      	add	r5, sp
    info.num_sections = 4;
    3bdc:	ac04      	add	r4, sp, #16
{
    3bde:	7028      	strb	r0, [r5, #0]
    info.num_sections = 4;
    3be0:	7123      	strb	r3, [r4, #4]
    info.sections = get_sections;
    3be2:	a808      	add	r0, sp, #32
    rpc_init_receive_section(&get_sections[0], (uint8 *)result, sizeof(uint8), NULL);
    3be4:	2300      	movs	r3, #0
    3be6:	2201      	movs	r2, #1
    info.sections = get_sections;
    3be8:	9004      	str	r0, [sp, #16]
    rpc_init_receive_section(&get_sections[0], (uint8 *)result, sizeof(uint8), NULL);
    3bea:	f7fe fc08 	bl	23fe <rpc_init_receive_section>
    rpc_init_receive_section(&get_sections[1], (uint8 *)auth_prot, sizeof(uint8), NULL);
    3bee:	2300      	movs	r3, #0
    3bf0:	2201      	movs	r2, #1
    3bf2:	0039      	movs	r1, r7
    3bf4:	a80b      	add	r0, sp, #44	; 0x2c
    3bf6:	f7fe fc02 	bl	23fe <rpc_init_receive_section>
    rpc_init_receive_section(&get_sections[2], (uint8 *)login_str, login_str_max_length, login_str_length);
    3bfa:	0032      	movs	r2, r6
    3bfc:	9b1a      	ldr	r3, [sp, #104]	; 0x68
    3bfe:	991b      	ldr	r1, [sp, #108]	; 0x6c
    3c00:	a80e      	add	r0, sp, #56	; 0x38
    3c02:	f7fe fbfc 	bl	23fe <rpc_init_receive_section>
    rpc_init_receive_section(&get_sections[3], (uint8 *)password_str, password_str_max_length, password_str_length);
    3c06:	a811      	add	r0, sp, #68	; 0x44
    3c08:	9b1d      	ldr	r3, [sp, #116]	; 0x74
    3c0a:	9a02      	ldr	r2, [sp, #8]
    3c0c:	991e      	ldr	r1, [sp, #120]	; 0x78
    3c0e:	f7fe fbf6 	bl	23fe <rpc_init_receive_section>
    data_to_send[0].data_location = (uint8 *)&cid;
    3c12:	9506      	str	r5, [sp, #24]
    data_to_send[0].data_length = sizeof(cid);
    3c14:	2501      	movs	r5, #1
    data_to_send[0].data_location = (uint8 *)&cid;
    3c16:	ae06      	add	r6, sp, #24
    data_to_send[0].data_length = sizeof(cid);
    3c18:	80b5      	strh	r5, [r6, #4]
    RPC_ERR rpc_return = rpc_command_claim(CORES_PROTOCOL_CORE);
    3c1a:	0028      	movs	r0, r5
    3c1c:	f7fe fc1e 	bl	245c <rpc_command_claim>
    if (rpc_return != RPC_ERR_OK)
    3c20:	2800      	cmp	r0, #0
    3c22:	d110      	bne.n	3c46 <command_get_pdp_context_auth_param+0x7e>
    set_receive_info(CORES_PROTOCOL_CORE, &info);
    3c24:	0021      	movs	r1, r4
    3c26:	0028      	movs	r0, r5
    3c28:	f7fe f8ba 	bl	1da0 <set_receive_info>
    rpc_interface_scatter_send(CORES_PROTOCOL_CORE, RPC_APPLICATION_TO_PROTOCOL_GET_PDP_CONTEXT_AUTH_PARAM, true, 1, data_to_send);
    3c2c:	002b      	movs	r3, r5
    3c2e:	002a      	movs	r2, r5
    3c30:	2116      	movs	r1, #22
    3c32:	0028      	movs	r0, r5
    3c34:	9600      	str	r6, [sp, #0]
    3c36:	f7fe fb63 	bl	2300 <rpc_interface_scatter_send>
    rpc_blocking_loop(CORES_PROTOCOL_CORE);
    3c3a:	0028      	movs	r0, r5
    3c3c:	f7fe fbe4 	bl	2408 <rpc_blocking_loop>
    return rpc_command_release(CORES_PROTOCOL_CORE);
    3c40:	0028      	movs	r0, r5
    3c42:	f7fe fbf7 	bl	2434 <rpc_command_release>
}
    3c46:	b015      	add	sp, #84	; 0x54
    3c48:	bdf0      	pop	{r4, r5, r6, r7, pc}

00003c4a <command_set_nconfig>:
{
    3c4a:	b5f0      	push	{r4, r5, r6, r7, lr}
    3c4c:	270f      	movs	r7, #15
    3c4e:	b08f      	sub	sp, #60	; 0x3c
    info.num_sections = 1;
    3c50:	2401      	movs	r4, #1
{
    3c52:	000b      	movs	r3, r1
    3c54:	0011      	movs	r1, r2
    3c56:	466a      	mov	r2, sp
    3c58:	446f      	add	r7, sp
    3c5a:	7038      	strb	r0, [r7, #0]
    3c5c:	8193      	strh	r3, [r2, #12]
    info.sections = get_sections;
    3c5e:	a807      	add	r0, sp, #28
    rpc_init_receive_section(&get_sections[0], (uint8 *)result, sizeof(uint8), NULL);
    3c60:	2300      	movs	r3, #0
    info.num_sections = 1;
    3c62:	ae05      	add	r6, sp, #20
    rpc_init_receive_section(&get_sections[0], (uint8 *)result, sizeof(uint8), NULL);
    3c64:	0022      	movs	r2, r4
    info.sections = get_sections;
    3c66:	9005      	str	r0, [sp, #20]
    info.num_sections = 1;
    3c68:	7134      	strb	r4, [r6, #4]
    rpc_init_receive_section(&get_sections[0], (uint8 *)result, sizeof(uint8), NULL);
    3c6a:	f7fe fbc8 	bl	23fe <rpc_init_receive_section>
    data_to_send[0].data_location = (uint8 *)&function;
    3c6e:	970a      	str	r7, [sp, #40]	; 0x28
    data_to_send[1].data_length = sizeof(value);
    3c70:	2702      	movs	r7, #2
    data_to_send[0].data_location = (uint8 *)&function;
    3c72:	ad0a      	add	r5, sp, #40	; 0x28
    data_to_send[1].data_location = (uint8 *)&value;
    3c74:	ab03      	add	r3, sp, #12
    RPC_ERR rpc_return = rpc_command_claim(CORES_PROTOCOL_CORE);
    3c76:	0020      	movs	r0, r4
    data_to_send[0].data_length = sizeof(function);
    3c78:	80ac      	strh	r4, [r5, #4]
    data_to_send[1].data_location = (uint8 *)&value;
    3c7a:	930c      	str	r3, [sp, #48]	; 0x30
    data_to_send[1].data_length = sizeof(value);
    3c7c:	81af      	strh	r7, [r5, #12]
    RPC_ERR rpc_return = rpc_command_claim(CORES_PROTOCOL_CORE);
    3c7e:	f7fe fbed 	bl	245c <rpc_command_claim>
    if (rpc_return != RPC_ERR_OK)
    3c82:	2800      	cmp	r0, #0
    3c84:	d110      	bne.n	3ca8 <command_set_nconfig+0x5e>
    set_receive_info(CORES_PROTOCOL_CORE, &info);
    3c86:	0031      	movs	r1, r6
    3c88:	0020      	movs	r0, r4
    3c8a:	f7fe f889 	bl	1da0 <set_receive_info>
    rpc_interface_scatter_send(CORES_PROTOCOL_CORE, RPC_APPLICATION_TO_PROTOCOL_SET_NCONFIG, true, 2, data_to_send);
    3c8e:	003b      	movs	r3, r7
    3c90:	0022      	movs	r2, r4
    3c92:	2117      	movs	r1, #23
    3c94:	0020      	movs	r0, r4
    3c96:	9500      	str	r5, [sp, #0]
    3c98:	f7fe fb32 	bl	2300 <rpc_interface_scatter_send>
    rpc_blocking_loop(CORES_PROTOCOL_CORE);
    3c9c:	0020      	movs	r0, r4
    3c9e:	f7fe fbb3 	bl	2408 <rpc_blocking_loop>
    return rpc_command_release(CORES_PROTOCOL_CORE);
    3ca2:	0020      	movs	r0, r4
    3ca4:	f7fe fbc6 	bl	2434 <rpc_command_release>
}
    3ca8:	b00f      	add	sp, #60	; 0x3c
    3caa:	bdf0      	pop	{r4, r5, r6, r7, pc}

00003cac <command_get_nconfig>:
{
    3cac:	b5f0      	push	{r4, r5, r6, r7, lr}
    3cae:	240f      	movs	r4, #15
    info.num_sections = 2;
    3cb0:	2502      	movs	r5, #2
{
    3cb2:	0017      	movs	r7, r2
    3cb4:	b08f      	sub	sp, #60	; 0x3c
    3cb6:	446c      	add	r4, sp
    3cb8:	7020      	strb	r0, [r4, #0]
    rpc_init_receive_section(&get_sections[0], (uint8 *)result, sizeof(uint8), NULL);
    3cba:	2300      	movs	r3, #0
    info.sections = get_sections;
    3cbc:	a808      	add	r0, sp, #32
    rpc_init_receive_section(&get_sections[0], (uint8 *)result, sizeof(uint8), NULL);
    3cbe:	2201      	movs	r2, #1
    info.num_sections = 2;
    3cc0:	ae04      	add	r6, sp, #16
    3cc2:	7135      	strb	r5, [r6, #4]
    info.sections = get_sections;
    3cc4:	9004      	str	r0, [sp, #16]
    rpc_init_receive_section(&get_sections[0], (uint8 *)result, sizeof(uint8), NULL);
    3cc6:	f7fe fb9a 	bl	23fe <rpc_init_receive_section>
    rpc_init_receive_section(&get_sections[1], (uint8 *)value, sizeof(uint16), NULL);
    3cca:	002a      	movs	r2, r5
    3ccc:	a80b      	add	r0, sp, #44	; 0x2c
    3cce:	2300      	movs	r3, #0
    3cd0:	0039      	movs	r1, r7
    3cd2:	f7fe fb94 	bl	23fe <rpc_init_receive_section>
    data_to_send[0].data_location = (uint8 *)&function;
    3cd6:	9406      	str	r4, [sp, #24]
    data_to_send[0].data_length = sizeof(function);
    3cd8:	2401      	movs	r4, #1
    data_to_send[0].data_location = (uint8 *)&function;
    3cda:	ad06      	add	r5, sp, #24
    data_to_send[0].data_length = sizeof(function);
    3cdc:	80ac      	strh	r4, [r5, #4]
    RPC_ERR rpc_return = rpc_command_claim(CORES_PROTOCOL_CORE);
    3cde:	0020      	movs	r0, r4
    3ce0:	f7fe fbbc 	bl	245c <rpc_command_claim>
    if (rpc_return != RPC_ERR_OK)
    3ce4:	2800      	cmp	r0, #0
    3ce6:	d110      	bne.n	3d0a <command_get_nconfig+0x5e>
    set_receive_info(CORES_PROTOCOL_CORE, &info);
    3ce8:	0031      	movs	r1, r6
    3cea:	0020      	movs	r0, r4
    3cec:	f7fe f858 	bl	1da0 <set_receive_info>
    rpc_interface_scatter_send(CORES_PROTOCOL_CORE, RPC_APPLICATION_TO_PROTOCOL_GET_NCONFIG, true, 1, data_to_send);
    3cf0:	0023      	movs	r3, r4
    3cf2:	0022      	movs	r2, r4
    3cf4:	2118      	movs	r1, #24
    3cf6:	0020      	movs	r0, r4
    3cf8:	9500      	str	r5, [sp, #0]
    3cfa:	f7fe fb01 	bl	2300 <rpc_interface_scatter_send>
    rpc_blocking_loop(CORES_PROTOCOL_CORE);
    3cfe:	0020      	movs	r0, r4
    3d00:	f7fe fb82 	bl	2408 <rpc_blocking_loop>
    return rpc_command_release(CORES_PROTOCOL_CORE);
    3d04:	0020      	movs	r0, r4
    3d06:	f7fe fb95 	bl	2434 <rpc_command_release>
}
    3d0a:	b00f      	add	sp, #60	; 0x3c
    3d0c:	bdf0      	pop	{r4, r5, r6, r7, pc}

00003d0e <command_query_ue_stats>:
{
    3d0e:	b570      	push	{r4, r5, r6, lr}
    3d10:	0005      	movs	r5, r0
    info.num_sections = 1;
    3d12:	2401      	movs	r4, #1
{
    3d14:	b088      	sub	sp, #32
    3d16:	000b      	movs	r3, r1
    info.sections = get_sections;
    3d18:	a805      	add	r0, sp, #20
{
    3d1a:	0011      	movs	r1, r2
    info.num_sections = 1;
    3d1c:	ae03      	add	r6, sp, #12
    rpc_init_receive_section(&get_sections[0], (uint8 *)ue_status, ue_status_max_length, ue_status_length);
    3d1e:	002a      	movs	r2, r5
    info.sections = get_sections;
    3d20:	9003      	str	r0, [sp, #12]
    info.num_sections = 1;
    3d22:	7134      	strb	r4, [r6, #4]
    rpc_init_receive_section(&get_sections[0], (uint8 *)ue_status, ue_status_max_length, ue_status_length);
    3d24:	f7fe fb6b 	bl	23fe <rpc_init_receive_section>
    RPC_ERR rpc_return = rpc_command_claim(CORES_PROTOCOL_CORE);
    3d28:	0020      	movs	r0, r4
    3d2a:	f7fe fb97 	bl	245c <rpc_command_claim>
    3d2e:	1e05      	subs	r5, r0, #0
    if (rpc_return != RPC_ERR_OK)
    3d30:	d111      	bne.n	3d56 <command_query_ue_stats+0x48>
    set_receive_info(CORES_PROTOCOL_CORE, &info);
    3d32:	0031      	movs	r1, r6
    3d34:	0020      	movs	r0, r4
    3d36:	f7fe f833 	bl	1da0 <set_receive_info>
    rpc_interface_scatter_send(CORES_PROTOCOL_CORE, RPC_APPLICATION_TO_PROTOCOL_QUERY_UE_STATS, true, 0, NULL);
    3d3a:	002b      	movs	r3, r5
    3d3c:	0022      	movs	r2, r4
    3d3e:	211b      	movs	r1, #27
    3d40:	9500      	str	r5, [sp, #0]
    3d42:	0020      	movs	r0, r4
    3d44:	f7fe fadc 	bl	2300 <rpc_interface_scatter_send>
    rpc_blocking_loop(CORES_PROTOCOL_CORE);
    3d48:	0020      	movs	r0, r4
    3d4a:	f7fe fb5d 	bl	2408 <rpc_blocking_loop>
    return rpc_command_release(CORES_PROTOCOL_CORE);
    3d4e:	0020      	movs	r0, r4
    3d50:	f7fe fb70 	bl	2434 <rpc_command_release>
    3d54:	0005      	movs	r5, r0
}
    3d56:	0028      	movs	r0, r5
    3d58:	b008      	add	sp, #32
    3d5a:	bd70      	pop	{r4, r5, r6, pc}

00003d5c <command_set_ue_cfun>:
{
    3d5c:	b5f0      	push	{r4, r5, r6, r7, lr}
    3d5e:	270e      	movs	r7, #14
    info.num_sections = 1;
    3d60:	2401      	movs	r4, #1
{
    3d62:	b08d      	sub	sp, #52	; 0x34
    3d64:	446f      	add	r7, sp
    3d66:	8038      	strh	r0, [r7, #0]
    rpc_init_receive_section(&get_sections[0], (uint8 *)cfun_set_result, sizeof(uint8), NULL);
    3d68:	2300      	movs	r3, #0
    info.sections = get_sections;
    3d6a:	a809      	add	r0, sp, #36	; 0x24
    info.num_sections = 1;
    3d6c:	ae05      	add	r6, sp, #20
    rpc_init_receive_section(&get_sections[0], (uint8 *)cfun_set_result, sizeof(uint8), NULL);
    3d6e:	0022      	movs	r2, r4
    info.sections = get_sections;
    3d70:	9005      	str	r0, [sp, #20]
    info.num_sections = 1;
    3d72:	7134      	strb	r4, [r6, #4]
    rpc_init_receive_section(&get_sections[0], (uint8 *)cfun_set_result, sizeof(uint8), NULL);
    3d74:	f7fe fb43 	bl	23fe <rpc_init_receive_section>
    data_to_send[0].data_length = sizeof(cfun);
    3d78:	2302      	movs	r3, #2
    data_to_send[0].data_location = (uint8 *)&cfun;
    3d7a:	ad07      	add	r5, sp, #28
    RPC_ERR rpc_return = rpc_command_claim(CORES_PROTOCOL_CORE);
    3d7c:	0020      	movs	r0, r4
    data_to_send[0].data_location = (uint8 *)&cfun;
    3d7e:	9707      	str	r7, [sp, #28]
    data_to_send[0].data_length = sizeof(cfun);
    3d80:	80ab      	strh	r3, [r5, #4]
    RPC_ERR rpc_return = rpc_command_claim(CORES_PROTOCOL_CORE);
    3d82:	f7fe fb6b 	bl	245c <rpc_command_claim>
    if (rpc_return != RPC_ERR_OK)
    3d86:	2800      	cmp	r0, #0
    3d88:	d110      	bne.n	3dac <command_set_ue_cfun+0x50>
    set_receive_info(CORES_PROTOCOL_CORE, &info);
    3d8a:	0031      	movs	r1, r6
    3d8c:	0020      	movs	r0, r4
    3d8e:	f7fe f807 	bl	1da0 <set_receive_info>
    rpc_interface_scatter_send(CORES_PROTOCOL_CORE, RPC_APPLICATION_TO_PROTOCOL_SET_UE_CFUN, true, 1, data_to_send);
    3d92:	0023      	movs	r3, r4
    3d94:	0022      	movs	r2, r4
    3d96:	211c      	movs	r1, #28
    3d98:	0020      	movs	r0, r4
    3d9a:	9500      	str	r5, [sp, #0]
    3d9c:	f7fe fab0 	bl	2300 <rpc_interface_scatter_send>
    rpc_blocking_loop(CORES_PROTOCOL_CORE);
    3da0:	0020      	movs	r0, r4
    3da2:	f7fe fb31 	bl	2408 <rpc_blocking_loop>
    return rpc_command_release(CORES_PROTOCOL_CORE);
    3da6:	0020      	movs	r0, r4
    3da8:	f7fe fb44 	bl	2434 <rpc_command_release>
}
    3dac:	b00d      	add	sp, #52	; 0x34
    3dae:	bdf0      	pop	{r4, r5, r6, r7, pc}

00003db0 <command_read_service_status>:
{
    3db0:	b570      	push	{r4, r5, r6, lr}
    info.num_sections = 1;
    3db2:	2401      	movs	r4, #1
{
    3db4:	b088      	sub	sp, #32
    3db6:	0001      	movs	r1, r0
    rpc_init_receive_section(&get_sections[0], (uint8 *)service_status, sizeof(uint8), NULL);
    3db8:	2300      	movs	r3, #0
    info.sections = get_sections;
    3dba:	a805      	add	r0, sp, #20
    rpc_init_receive_section(&get_sections[0], (uint8 *)service_status, sizeof(uint8), NULL);
    3dbc:	0022      	movs	r2, r4
    info.num_sections = 1;
    3dbe:	ae03      	add	r6, sp, #12
    info.sections = get_sections;
    3dc0:	9003      	str	r0, [sp, #12]
    info.num_sections = 1;
    3dc2:	7134      	strb	r4, [r6, #4]
    rpc_init_receive_section(&get_sections[0], (uint8 *)service_status, sizeof(uint8), NULL);
    3dc4:	f7fe fb1b 	bl	23fe <rpc_init_receive_section>
    RPC_ERR rpc_return = rpc_command_claim(CORES_PROTOCOL_CORE);
    3dc8:	0020      	movs	r0, r4
    3dca:	f7fe fb47 	bl	245c <rpc_command_claim>
    3dce:	1e05      	subs	r5, r0, #0
    if (rpc_return != RPC_ERR_OK)
    3dd0:	d111      	bne.n	3df6 <command_read_service_status+0x46>
    set_receive_info(CORES_PROTOCOL_CORE, &info);
    3dd2:	0031      	movs	r1, r6
    3dd4:	0020      	movs	r0, r4
    3dd6:	f7fd ffe3 	bl	1da0 <set_receive_info>
    rpc_interface_scatter_send(CORES_PROTOCOL_CORE, RPC_APPLICATION_TO_PROTOCOL_READ_SERVICE_STATUS, true, 0, NULL);
    3dda:	002b      	movs	r3, r5
    3ddc:	0022      	movs	r2, r4
    3dde:	211d      	movs	r1, #29
    3de0:	9500      	str	r5, [sp, #0]
    3de2:	0020      	movs	r0, r4
    3de4:	f7fe fa8c 	bl	2300 <rpc_interface_scatter_send>
    rpc_blocking_loop(CORES_PROTOCOL_CORE);
    3de8:	0020      	movs	r0, r4
    3dea:	f7fe fb0d 	bl	2408 <rpc_blocking_loop>
    return rpc_command_release(CORES_PROTOCOL_CORE);
    3dee:	0020      	movs	r0, r4
    3df0:	f7fe fb20 	bl	2434 <rpc_command_release>
    3df4:	0005      	movs	r5, r0
}
    3df6:	0028      	movs	r0, r5
    3df8:	b008      	add	sp, #32
    3dfa:	bd70      	pop	{r4, r5, r6, pc}

00003dfc <command_read_ue_cfun>:
{
    3dfc:	b570      	push	{r4, r5, r6, lr}
    info.num_sections = 1;
    3dfe:	2401      	movs	r4, #1
{
    3e00:	b088      	sub	sp, #32
    3e02:	0001      	movs	r1, r0
    rpc_init_receive_section(&get_sections[0], (uint8 *)c_fun, sizeof(uint8), NULL);
    3e04:	2300      	movs	r3, #0
    info.sections = get_sections;
    3e06:	a805      	add	r0, sp, #20
    rpc_init_receive_section(&get_sections[0], (uint8 *)c_fun, sizeof(uint8), NULL);
    3e08:	0022      	movs	r2, r4
    info.num_sections = 1;
    3e0a:	ae03      	add	r6, sp, #12
    info.sections = get_sections;
    3e0c:	9003      	str	r0, [sp, #12]
    info.num_sections = 1;
    3e0e:	7134      	strb	r4, [r6, #4]
    rpc_init_receive_section(&get_sections[0], (uint8 *)c_fun, sizeof(uint8), NULL);
    3e10:	f7fe faf5 	bl	23fe <rpc_init_receive_section>
    RPC_ERR rpc_return = rpc_command_claim(CORES_PROTOCOL_CORE);
    3e14:	0020      	movs	r0, r4
    3e16:	f7fe fb21 	bl	245c <rpc_command_claim>
    3e1a:	1e05      	subs	r5, r0, #0
    if (rpc_return != RPC_ERR_OK)
    3e1c:	d111      	bne.n	3e42 <command_read_ue_cfun+0x46>
    set_receive_info(CORES_PROTOCOL_CORE, &info);
    3e1e:	0031      	movs	r1, r6
    3e20:	0020      	movs	r0, r4
    3e22:	f7fd ffbd 	bl	1da0 <set_receive_info>
    rpc_interface_scatter_send(CORES_PROTOCOL_CORE, RPC_APPLICATION_TO_PROTOCOL_READ_UE_CFUN, true, 0, NULL);
    3e26:	002b      	movs	r3, r5
    3e28:	0022      	movs	r2, r4
    3e2a:	211e      	movs	r1, #30
    3e2c:	9500      	str	r5, [sp, #0]
    3e2e:	0020      	movs	r0, r4
    3e30:	f7fe fa66 	bl	2300 <rpc_interface_scatter_send>
    rpc_blocking_loop(CORES_PROTOCOL_CORE);
    3e34:	0020      	movs	r0, r4
    3e36:	f7fe fae7 	bl	2408 <rpc_blocking_loop>
    return rpc_command_release(CORES_PROTOCOL_CORE);
    3e3a:	0020      	movs	r0, r4
    3e3c:	f7fe fafa 	bl	2434 <rpc_command_release>
    3e40:	0005      	movs	r5, r0
}
    3e42:	0028      	movs	r0, r5
    3e44:	b008      	add	sp, #32
    3e46:	bd70      	pop	{r4, r5, r6, pc}

00003e48 <command_get_defined_cids>:
{
    3e48:	b570      	push	{r4, r5, r6, lr}
    3e4a:	0005      	movs	r5, r0
    info.num_sections = 1;
    3e4c:	2401      	movs	r4, #1
{
    3e4e:	b088      	sub	sp, #32
    3e50:	000b      	movs	r3, r1
    info.sections = get_sections;
    3e52:	a805      	add	r0, sp, #20
{
    3e54:	0011      	movs	r1, r2
    info.num_sections = 1;
    3e56:	ae03      	add	r6, sp, #12
    rpc_init_receive_section(&get_sections[0], (uint8 *)cids, cids_max_length, cids_length);
    3e58:	002a      	movs	r2, r5
    info.sections = get_sections;
    3e5a:	9003      	str	r0, [sp, #12]
    info.num_sections = 1;
    3e5c:	7134      	strb	r4, [r6, #4]
    rpc_init_receive_section(&get_sections[0], (uint8 *)cids, cids_max_length, cids_length);
    3e5e:	f7fe face 	bl	23fe <rpc_init_receive_section>
    RPC_ERR rpc_return = rpc_command_claim(CORES_PROTOCOL_CORE);
    3e62:	0020      	movs	r0, r4
    3e64:	f7fe fafa 	bl	245c <rpc_command_claim>
    3e68:	1e05      	subs	r5, r0, #0
    if (rpc_return != RPC_ERR_OK)
    3e6a:	d111      	bne.n	3e90 <command_get_defined_cids+0x48>
    set_receive_info(CORES_PROTOCOL_CORE, &info);
    3e6c:	0031      	movs	r1, r6
    3e6e:	0020      	movs	r0, r4
    3e70:	f7fd ff96 	bl	1da0 <set_receive_info>
    rpc_interface_scatter_send(CORES_PROTOCOL_CORE, RPC_APPLICATION_TO_PROTOCOL_GET_DEFINED_CIDS, true, 0, NULL);
    3e74:	002b      	movs	r3, r5
    3e76:	0022      	movs	r2, r4
    3e78:	211f      	movs	r1, #31
    3e7a:	9500      	str	r5, [sp, #0]
    3e7c:	0020      	movs	r0, r4
    3e7e:	f7fe fa3f 	bl	2300 <rpc_interface_scatter_send>
    rpc_blocking_loop(CORES_PROTOCOL_CORE);
    3e82:	0020      	movs	r0, r4
    3e84:	f7fe fac0 	bl	2408 <rpc_blocking_loop>
    return rpc_command_release(CORES_PROTOCOL_CORE);
    3e88:	0020      	movs	r0, r4
    3e8a:	f7fe fad3 	bl	2434 <rpc_command_release>
    3e8e:	0005      	movs	r5, r0
}
    3e90:	0028      	movs	r0, r5
    3e92:	b008      	add	sp, #32
    3e94:	bd70      	pop	{r4, r5, r6, pc}

00003e96 <command_allocate_socket>:
{
    3e96:	b5f0      	push	{r4, r5, r6, r7, lr}
    3e98:	270e      	movs	r7, #14
    3e9a:	000d      	movs	r5, r1
    3e9c:	b093      	sub	sp, #76	; 0x4c
    3e9e:	240f      	movs	r4, #15
    3ea0:	0019      	movs	r1, r3
    3ea2:	446f      	add	r7, sp
    3ea4:	466b      	mov	r3, sp
    3ea6:	703d      	strb	r5, [r7, #0]
    info.num_sections = 2;
    3ea8:	2502      	movs	r5, #2
{
    3eaa:	446c      	add	r4, sp
    3eac:	7020      	strb	r0, [r4, #0]
    3eae:	735a      	strb	r2, [r3, #13]
    info.sections = get_sections;
    3eb0:	a80c      	add	r0, sp, #48	; 0x30
    rpc_init_receive_section(&get_sections[0], (uint8 *)ret, sizeof(uint8), NULL);
    3eb2:	2300      	movs	r3, #0
    3eb4:	2201      	movs	r2, #1
    info.num_sections = 2;
    3eb6:	ae04      	add	r6, sp, #16
    3eb8:	7135      	strb	r5, [r6, #4]
    info.sections = get_sections;
    3eba:	9004      	str	r0, [sp, #16]
    rpc_init_receive_section(&get_sections[0], (uint8 *)ret, sizeof(uint8), NULL);
    3ebc:	f7fe fa9f 	bl	23fe <rpc_init_receive_section>
    rpc_init_receive_section(&get_sections[1], (uint8 *)socknum, sizeof(uint16), NULL);
    3ec0:	2300      	movs	r3, #0
    3ec2:	002a      	movs	r2, r5
    3ec4:	a80f      	add	r0, sp, #60	; 0x3c
    3ec6:	9918      	ldr	r1, [sp, #96]	; 0x60
    3ec8:	f7fe fa99 	bl	23fe <rpc_init_receive_section>
    data_to_send[0].data_location = (uint8 *)&domain;
    3ecc:	9406      	str	r4, [sp, #24]
    data_to_send[2].data_location = (uint8 *)&protocol;
    3ece:	230d      	movs	r3, #13
    data_to_send[0].data_length = sizeof(domain);
    3ed0:	2401      	movs	r4, #1
    data_to_send[0].data_location = (uint8 *)&domain;
    3ed2:	ad06      	add	r5, sp, #24
    data_to_send[2].data_location = (uint8 *)&protocol;
    3ed4:	446b      	add	r3, sp
    data_to_send[0].data_length = sizeof(domain);
    3ed6:	80ac      	strh	r4, [r5, #4]
    data_to_send[1].data_length = sizeof(type);
    3ed8:	81ac      	strh	r4, [r5, #12]
    data_to_send[2].data_length = sizeof(protocol);
    3eda:	82ac      	strh	r4, [r5, #20]
    RPC_ERR rpc_return = rpc_command_claim(CORES_PROTOCOL_CORE);
    3edc:	0020      	movs	r0, r4
    data_to_send[1].data_location = (uint8 *)&type;
    3ede:	9708      	str	r7, [sp, #32]
    data_to_send[2].data_location = (uint8 *)&protocol;
    3ee0:	930a      	str	r3, [sp, #40]	; 0x28
    RPC_ERR rpc_return = rpc_command_claim(CORES_PROTOCOL_CORE);
    3ee2:	f7fe fabb 	bl	245c <rpc_command_claim>
    if (rpc_return != RPC_ERR_OK)
    3ee6:	2800      	cmp	r0, #0
    3ee8:	d110      	bne.n	3f0c <command_allocate_socket+0x76>
    set_receive_info(CORES_PROTOCOL_CORE, &info);
    3eea:	0031      	movs	r1, r6
    3eec:	0020      	movs	r0, r4
    3eee:	f7fd ff57 	bl	1da0 <set_receive_info>
    rpc_interface_scatter_send(CORES_PROTOCOL_CORE, RPC_APPLICATION_TO_PROTOCOL_ALLOCATE_SOCKET, true, 3, data_to_send);
    3ef2:	2303      	movs	r3, #3
    3ef4:	0022      	movs	r2, r4
    3ef6:	2120      	movs	r1, #32
    3ef8:	0020      	movs	r0, r4
    3efa:	9500      	str	r5, [sp, #0]
    3efc:	f7fe fa00 	bl	2300 <rpc_interface_scatter_send>
    rpc_blocking_loop(CORES_PROTOCOL_CORE);
    3f00:	0020      	movs	r0, r4
    3f02:	f7fe fa81 	bl	2408 <rpc_blocking_loop>
    return rpc_command_release(CORES_PROTOCOL_CORE);
    3f06:	0020      	movs	r0, r4
    3f08:	f7fe fa94 	bl	2434 <rpc_command_release>
}
    3f0c:	b013      	add	sp, #76	; 0x4c
    3f0e:	bdf0      	pop	{r4, r5, r6, r7, pc}

00003f10 <command_close_socket>:
{
    3f10:	b5f0      	push	{r4, r5, r6, r7, lr}
    3f12:	270e      	movs	r7, #14
    info.num_sections = 1;
    3f14:	2401      	movs	r4, #1
{
    3f16:	b08d      	sub	sp, #52	; 0x34
    3f18:	446f      	add	r7, sp
    3f1a:	8038      	strh	r0, [r7, #0]
    rpc_init_receive_section(&get_sections[0], (uint8 *)ret, sizeof(uint8), NULL);
    3f1c:	2300      	movs	r3, #0
    info.sections = get_sections;
    3f1e:	a809      	add	r0, sp, #36	; 0x24
    info.num_sections = 1;
    3f20:	ae05      	add	r6, sp, #20
    rpc_init_receive_section(&get_sections[0], (uint8 *)ret, sizeof(uint8), NULL);
    3f22:	0022      	movs	r2, r4
    info.sections = get_sections;
    3f24:	9005      	str	r0, [sp, #20]
    info.num_sections = 1;
    3f26:	7134      	strb	r4, [r6, #4]
    rpc_init_receive_section(&get_sections[0], (uint8 *)ret, sizeof(uint8), NULL);
    3f28:	f7fe fa69 	bl	23fe <rpc_init_receive_section>
    data_to_send[0].data_length = sizeof(socket);
    3f2c:	2302      	movs	r3, #2
    data_to_send[0].data_location = (uint8 *)&socket;
    3f2e:	ad07      	add	r5, sp, #28
    RPC_ERR rpc_return = rpc_command_claim(CORES_PROTOCOL_CORE);
    3f30:	0020      	movs	r0, r4
    data_to_send[0].data_location = (uint8 *)&socket;
    3f32:	9707      	str	r7, [sp, #28]
    data_to_send[0].data_length = sizeof(socket);
    3f34:	80ab      	strh	r3, [r5, #4]
    RPC_ERR rpc_return = rpc_command_claim(CORES_PROTOCOL_CORE);
    3f36:	f7fe fa91 	bl	245c <rpc_command_claim>
    if (rpc_return != RPC_ERR_OK)
    3f3a:	2800      	cmp	r0, #0
    3f3c:	d110      	bne.n	3f60 <command_close_socket+0x50>
    set_receive_info(CORES_PROTOCOL_CORE, &info);
    3f3e:	0031      	movs	r1, r6
    3f40:	0020      	movs	r0, r4
    3f42:	f7fd ff2d 	bl	1da0 <set_receive_info>
    rpc_interface_scatter_send(CORES_PROTOCOL_CORE, RPC_APPLICATION_TO_PROTOCOL_CLOSE_SOCKET, true, 1, data_to_send);
    3f46:	0023      	movs	r3, r4
    3f48:	0022      	movs	r2, r4
    3f4a:	2121      	movs	r1, #33	; 0x21
    3f4c:	0020      	movs	r0, r4
    3f4e:	9500      	str	r5, [sp, #0]
    3f50:	f7fe f9d6 	bl	2300 <rpc_interface_scatter_send>
    rpc_blocking_loop(CORES_PROTOCOL_CORE);
    3f54:	0020      	movs	r0, r4
    3f56:	f7fe fa57 	bl	2408 <rpc_blocking_loop>
    return rpc_command_release(CORES_PROTOCOL_CORE);
    3f5a:	0020      	movs	r0, r4
    3f5c:	f7fe fa6a 	bl	2434 <rpc_command_release>
}
    3f60:	b00d      	add	sp, #52	; 0x34
    3f62:	bdf0      	pop	{r4, r5, r6, r7, pc}

00003f64 <command_neul_bind>:
{
    3f64:	b5f0      	push	{r4, r5, r6, r7, lr}
    3f66:	000c      	movs	r4, r1
    3f68:	b091      	sub	sp, #68	; 0x44
    3f6a:	ae03      	add	r6, sp, #12
    3f6c:	0019      	movs	r1, r3
    3f6e:	8034      	strh	r4, [r6, #0]
    3f70:	466b      	mov	r3, sp
    info.num_sections = 1;
    3f72:	2401      	movs	r4, #1
{
    3f74:	81d8      	strh	r0, [r3, #14]
    3f76:	9202      	str	r2, [sp, #8]
    info.sections = get_sections;
    3f78:	a807      	add	r0, sp, #28
    rpc_init_receive_section(&get_sections[0], (uint8 *)ret, sizeof(uint8), NULL);
    3f7a:	2300      	movs	r3, #0
    info.num_sections = 1;
    3f7c:	af05      	add	r7, sp, #20
    rpc_init_receive_section(&get_sections[0], (uint8 *)ret, sizeof(uint8), NULL);
    3f7e:	0022      	movs	r2, r4
    info.sections = get_sections;
    3f80:	9005      	str	r0, [sp, #20]
    info.num_sections = 1;
    3f82:	713c      	strb	r4, [r7, #4]
    rpc_init_receive_section(&get_sections[0], (uint8 *)ret, sizeof(uint8), NULL);
    3f84:	f7fe fa3b 	bl	23fe <rpc_init_receive_section>
    data_to_send[0].data_location = (uint8 *)&socket;
    3f88:	230e      	movs	r3, #14
    3f8a:	446b      	add	r3, sp
    3f8c:	930a      	str	r3, [sp, #40]	; 0x28
    data_to_send[0].data_length = sizeof(socket);
    3f8e:	2302      	movs	r3, #2
    data_to_send[0].data_location = (uint8 *)&socket;
    3f90:	ad0a      	add	r5, sp, #40	; 0x28
    data_to_send[0].data_length = sizeof(socket);
    3f92:	80ab      	strh	r3, [r5, #4]
    data_to_send[1].data_length = sizeof(sock_address_length);
    3f94:	81ab      	strh	r3, [r5, #12]
    data_to_send[2].data_location = (uint8 *)sock_address;
    3f96:	9b02      	ldr	r3, [sp, #8]
    RPC_ERR rpc_return = rpc_command_claim(CORES_PROTOCOL_CORE);
    3f98:	0020      	movs	r0, r4
    data_to_send[2].data_location = (uint8 *)sock_address;
    3f9a:	930e      	str	r3, [sp, #56]	; 0x38
    data_to_send[2].data_length = sock_address_length;
    3f9c:	8833      	ldrh	r3, [r6, #0]
    data_to_send[1].data_location = (uint8 *)&sock_address_length;
    3f9e:	960c      	str	r6, [sp, #48]	; 0x30
    data_to_send[2].data_length = sock_address_length;
    3fa0:	82ab      	strh	r3, [r5, #20]
    RPC_ERR rpc_return = rpc_command_claim(CORES_PROTOCOL_CORE);
    3fa2:	f7fe fa5b 	bl	245c <rpc_command_claim>
    if (rpc_return != RPC_ERR_OK)
    3fa6:	2800      	cmp	r0, #0
    3fa8:	d110      	bne.n	3fcc <command_neul_bind+0x68>
    set_receive_info(CORES_PROTOCOL_CORE, &info);
    3faa:	0039      	movs	r1, r7
    3fac:	0020      	movs	r0, r4
    3fae:	f7fd fef7 	bl	1da0 <set_receive_info>
    rpc_interface_scatter_send(CORES_PROTOCOL_CORE, RPC_APPLICATION_TO_PROTOCOL_NEUL_BIND, true, 3, data_to_send);
    3fb2:	2303      	movs	r3, #3
    3fb4:	0022      	movs	r2, r4
    3fb6:	2122      	movs	r1, #34	; 0x22
    3fb8:	0020      	movs	r0, r4
    3fba:	9500      	str	r5, [sp, #0]
    3fbc:	f7fe f9a0 	bl	2300 <rpc_interface_scatter_send>
    rpc_blocking_loop(CORES_PROTOCOL_CORE);
    3fc0:	0020      	movs	r0, r4
    3fc2:	f7fe fa21 	bl	2408 <rpc_blocking_loop>
    return rpc_command_release(CORES_PROTOCOL_CORE);
    3fc6:	0020      	movs	r0, r4
    3fc8:	f7fe fa34 	bl	2434 <rpc_command_release>
}
    3fcc:	b011      	add	sp, #68	; 0x44
    3fce:	bdf0      	pop	{r4, r5, r6, r7, pc}

00003fd0 <command_sendto>:
{
    3fd0:	b5f0      	push	{r4, r5, r6, r7, lr}
    info.num_sections = 1;
    3fd2:	2501      	movs	r5, #1
{
    3fd4:	b09b      	sub	sp, #108	; 0x6c
    3fd6:	ae05      	add	r6, sp, #20
    3fd8:	9203      	str	r2, [sp, #12]
    3fda:	aa02      	add	r2, sp, #8
    3fdc:	81d0      	strh	r0, [r2, #14]
    3fde:	72d3      	strb	r3, [r2, #11]
    info.sections = get_sections;
    3fe0:	a809      	add	r0, sp, #36	; 0x24
{
    3fe2:	8031      	strh	r1, [r6, #0]
    rpc_init_receive_section(&get_sections[0], (uint8 *)ret, sizeof(uint8), NULL);
    3fe4:	2300      	movs	r3, #0
    3fe6:	002a      	movs	r2, r5
    3fe8:	9923      	ldr	r1, [sp, #140]	; 0x8c
    info.num_sections = 1;
    3fea:	af07      	add	r7, sp, #28
    info.sections = get_sections;
    3fec:	9007      	str	r0, [sp, #28]
    info.num_sections = 1;
    3fee:	713d      	strb	r5, [r7, #4]
    rpc_init_receive_section(&get_sections[0], (uint8 *)ret, sizeof(uint8), NULL);
    3ff0:	f7fe fa05 	bl	23fe <rpc_init_receive_section>
    data_to_send[0].data_location = (uint8 *)&socket;
    3ff4:	230e      	movs	r3, #14
    3ff6:	aa02      	add	r2, sp, #8
    3ff8:	189b      	adds	r3, r3, r2
    data_to_send[2].data_location = (uint8 *)message;
    3ffa:	9a03      	ldr	r2, [sp, #12]
    data_to_send[0].data_location = (uint8 *)&socket;
    3ffc:	ac0c      	add	r4, sp, #48	; 0x30
    data_to_send[2].data_location = (uint8 *)message;
    3ffe:	9210      	str	r2, [sp, #64]	; 0x40
    data_to_send[2].data_length = message_length;
    4000:	8832      	ldrh	r2, [r6, #0]
    data_to_send[0].data_location = (uint8 *)&socket;
    4002:	930c      	str	r3, [sp, #48]	; 0x30
    data_to_send[2].data_length = message_length;
    4004:	82a2      	strh	r2, [r4, #20]
    data_to_send[3].data_location = (uint8 *)&seq_num;
    4006:	220b      	movs	r2, #11
    data_to_send[0].data_length = sizeof(socket);
    4008:	2302      	movs	r3, #2
    data_to_send[3].data_location = (uint8 *)&seq_num;
    400a:	a902      	add	r1, sp, #8
    400c:	1852      	adds	r2, r2, r1
    data_to_send[0].data_length = sizeof(socket);
    400e:	80a3      	strh	r3, [r4, #4]
    data_to_send[1].data_length = sizeof(message_length);
    4010:	81a3      	strh	r3, [r4, #12]
    data_to_send[3].data_location = (uint8 *)&seq_num;
    4012:	9212      	str	r2, [sp, #72]	; 0x48
    data_to_send[4].data_length = sizeof(flags);
    4014:	84a3      	strh	r3, [r4, #36]	; 0x24
    data_to_send[4].data_location = (uint8 *)&flags;
    4016:	aa20      	add	r2, sp, #128	; 0x80
    data_to_send[5].data_length = sizeof(sock_address_length);
    4018:	85a3      	strh	r3, [r4, #44]	; 0x2c
    data_to_send[6].data_location = (uint8 *)sock_address;
    401a:	9b22      	ldr	r3, [sp, #136]	; 0x88
    data_to_send[4].data_location = (uint8 *)&flags;
    401c:	9214      	str	r2, [sp, #80]	; 0x50
    data_to_send[5].data_location = (uint8 *)&sock_address_length;
    401e:	aa21      	add	r2, sp, #132	; 0x84
    data_to_send[6].data_location = (uint8 *)sock_address;
    4020:	9318      	str	r3, [sp, #96]	; 0x60
    data_to_send[6].data_length = sock_address_length;
    4022:	8813      	ldrh	r3, [r2, #0]
    RPC_ERR rpc_return = rpc_command_claim(CORES_PROTOCOL_CORE);
    4024:	0028      	movs	r0, r5
    data_to_send[1].data_location = (uint8 *)&message_length;
    4026:	960e      	str	r6, [sp, #56]	; 0x38
    data_to_send[3].data_length = sizeof(seq_num);
    4028:	83a5      	strh	r5, [r4, #28]
    data_to_send[5].data_location = (uint8 *)&sock_address_length;
    402a:	9216      	str	r2, [sp, #88]	; 0x58
    data_to_send[6].data_length = sock_address_length;
    402c:	86a3      	strh	r3, [r4, #52]	; 0x34
    RPC_ERR rpc_return = rpc_command_claim(CORES_PROTOCOL_CORE);
    402e:	f7fe fa15 	bl	245c <rpc_command_claim>
    if (rpc_return != RPC_ERR_OK)
    4032:	2800      	cmp	r0, #0
    4034:	d110      	bne.n	4058 <command_sendto+0x88>
    set_receive_info(CORES_PROTOCOL_CORE, &info);
    4036:	0039      	movs	r1, r7
    4038:	0028      	movs	r0, r5
    403a:	f7fd feb1 	bl	1da0 <set_receive_info>
    rpc_interface_scatter_send(CORES_PROTOCOL_CORE, RPC_APPLICATION_TO_PROTOCOL_SENDTO, true, 7, data_to_send);
    403e:	2307      	movs	r3, #7
    4040:	002a      	movs	r2, r5
    4042:	2123      	movs	r1, #35	; 0x23
    4044:	0028      	movs	r0, r5
    4046:	9400      	str	r4, [sp, #0]
    4048:	f7fe f95a 	bl	2300 <rpc_interface_scatter_send>
    rpc_blocking_loop(CORES_PROTOCOL_CORE);
    404c:	0028      	movs	r0, r5
    404e:	f7fe f9db 	bl	2408 <rpc_blocking_loop>
    return rpc_command_release(CORES_PROTOCOL_CORE);
    4052:	0028      	movs	r0, r5
    4054:	f7fe f9ee 	bl	2434 <rpc_command_release>
}
    4058:	b01b      	add	sp, #108	; 0x6c
    405a:	bdf0      	pop	{r4, r5, r6, r7, pc}

0000405c <command_get_pending_data_seqs>:
{
    405c:	b5f0      	push	{r4, r5, r6, r7, lr}
    405e:	270f      	movs	r7, #15
    4060:	000d      	movs	r5, r1
    info.num_sections = 1;
    4062:	2401      	movs	r4, #1
{
    4064:	b08d      	sub	sp, #52	; 0x34
    4066:	446f      	add	r7, sp
    4068:	0019      	movs	r1, r3
    406a:	7038      	strb	r0, [r7, #0]
    rpc_init_receive_section(&get_sections[0], (uint8 *)data_seqs, data_seqs_max_length, data_seqs_length);
    406c:	0013      	movs	r3, r2
    info.sections = get_sections;
    406e:	a809      	add	r0, sp, #36	; 0x24
    rpc_init_receive_section(&get_sections[0], (uint8 *)data_seqs, data_seqs_max_length, data_seqs_length);
    4070:	002a      	movs	r2, r5
    info.num_sections = 1;
    4072:	ae05      	add	r6, sp, #20
    data_to_send[0].data_location = (uint8 *)&socket_num;
    4074:	ad07      	add	r5, sp, #28
    info.sections = get_sections;
    4076:	9005      	str	r0, [sp, #20]
    info.num_sections = 1;
    4078:	7134      	strb	r4, [r6, #4]
    rpc_init_receive_section(&get_sections[0], (uint8 *)data_seqs, data_seqs_max_length, data_seqs_length);
    407a:	f7fe f9c0 	bl	23fe <rpc_init_receive_section>
    data_to_send[0].data_length = sizeof(socket_num);
    407e:	80ac      	strh	r4, [r5, #4]
    RPC_ERR rpc_return = rpc_command_claim(CORES_PROTOCOL_CORE);
    4080:	0020      	movs	r0, r4
    data_to_send[0].data_location = (uint8 *)&socket_num;
    4082:	9707      	str	r7, [sp, #28]
    RPC_ERR rpc_return = rpc_command_claim(CORES_PROTOCOL_CORE);
    4084:	f7fe f9ea 	bl	245c <rpc_command_claim>
    if (rpc_return != RPC_ERR_OK)
    4088:	2800      	cmp	r0, #0
    408a:	d110      	bne.n	40ae <command_get_pending_data_seqs+0x52>
    set_receive_info(CORES_PROTOCOL_CORE, &info);
    408c:	0031      	movs	r1, r6
    408e:	0020      	movs	r0, r4
    4090:	f7fd fe86 	bl	1da0 <set_receive_info>
    rpc_interface_scatter_send(CORES_PROTOCOL_CORE, RPC_APPLICATION_TO_PROTOCOL_GET_PENDING_DATA_SEQS, true, 1, data_to_send);
    4094:	0023      	movs	r3, r4
    4096:	0022      	movs	r2, r4
    4098:	2124      	movs	r1, #36	; 0x24
    409a:	0020      	movs	r0, r4
    409c:	9500      	str	r5, [sp, #0]
    409e:	f7fe f92f 	bl	2300 <rpc_interface_scatter_send>
    rpc_blocking_loop(CORES_PROTOCOL_CORE);
    40a2:	0020      	movs	r0, r4
    40a4:	f7fe f9b0 	bl	2408 <rpc_blocking_loop>
    return rpc_command_release(CORES_PROTOCOL_CORE);
    40a8:	0020      	movs	r0, r4
    40aa:	f7fe f9c3 	bl	2434 <rpc_command_release>
}
    40ae:	b00d      	add	sp, #52	; 0x34
    40b0:	bdf0      	pop	{r4, r5, r6, r7, pc}

000040b2 <command_socket_send>:
{
    40b2:	b5f0      	push	{r4, r5, r6, r7, lr}
    info.num_sections = 1;
    40b4:	2401      	movs	r4, #1
{
    40b6:	b095      	sub	sp, #84	; 0x54
    40b8:	ae05      	add	r6, sp, #20
    40ba:	9203      	str	r2, [sp, #12]
    40bc:	aa02      	add	r2, sp, #8
    40be:	81d0      	strh	r0, [r2, #14]
    40c0:	8153      	strh	r3, [r2, #10]
    info.sections = get_sections;
    40c2:	a809      	add	r0, sp, #36	; 0x24
{
    40c4:	8031      	strh	r1, [r6, #0]
    rpc_init_receive_section(&get_sections[0], (uint8 *)ret, sizeof(uint8), NULL);
    40c6:	2300      	movs	r3, #0
    40c8:	0022      	movs	r2, r4
    40ca:	991a      	ldr	r1, [sp, #104]	; 0x68
    info.num_sections = 1;
    40cc:	af07      	add	r7, sp, #28
    info.sections = get_sections;
    40ce:	9007      	str	r0, [sp, #28]
    info.num_sections = 1;
    40d0:	713c      	strb	r4, [r7, #4]
    rpc_init_receive_section(&get_sections[0], (uint8 *)ret, sizeof(uint8), NULL);
    40d2:	f7fe f994 	bl	23fe <rpc_init_receive_section>
    data_to_send[0].data_location = (uint8 *)&socket;
    40d6:	230e      	movs	r3, #14
    40d8:	aa02      	add	r2, sp, #8
    40da:	189b      	adds	r3, r3, r2
    data_to_send[2].data_location = (uint8 *)message;
    40dc:	9a03      	ldr	r2, [sp, #12]
    data_to_send[0].data_location = (uint8 *)&socket;
    40de:	ad0c      	add	r5, sp, #48	; 0x30
    data_to_send[2].data_location = (uint8 *)message;
    40e0:	9210      	str	r2, [sp, #64]	; 0x40
    data_to_send[2].data_length = message_length;
    40e2:	8832      	ldrh	r2, [r6, #0]
    data_to_send[0].data_location = (uint8 *)&socket;
    40e4:	930c      	str	r3, [sp, #48]	; 0x30
    data_to_send[2].data_length = message_length;
    40e6:	82aa      	strh	r2, [r5, #20]
    data_to_send[3].data_location = (uint8 *)&flags;
    40e8:	220a      	movs	r2, #10
    data_to_send[0].data_length = sizeof(socket);
    40ea:	2302      	movs	r3, #2
    data_to_send[3].data_location = (uint8 *)&flags;
    40ec:	a902      	add	r1, sp, #8
    40ee:	1852      	adds	r2, r2, r1
    RPC_ERR rpc_return = rpc_command_claim(CORES_PROTOCOL_CORE);
    40f0:	0020      	movs	r0, r4
    data_to_send[0].data_length = sizeof(socket);
    40f2:	80ab      	strh	r3, [r5, #4]
    data_to_send[1].data_location = (uint8 *)&message_length;
    40f4:	960e      	str	r6, [sp, #56]	; 0x38
    data_to_send[1].data_length = sizeof(message_length);
    40f6:	81ab      	strh	r3, [r5, #12]
    data_to_send[3].data_location = (uint8 *)&flags;
    40f8:	9212      	str	r2, [sp, #72]	; 0x48
    data_to_send[3].data_length = sizeof(flags);
    40fa:	83ab      	strh	r3, [r5, #28]
    RPC_ERR rpc_return = rpc_command_claim(CORES_PROTOCOL_CORE);
    40fc:	f7fe f9ae 	bl	245c <rpc_command_claim>
    if (rpc_return != RPC_ERR_OK)
    4100:	2800      	cmp	r0, #0
    4102:	d110      	bne.n	4126 <command_socket_send+0x74>
    set_receive_info(CORES_PROTOCOL_CORE, &info);
    4104:	0039      	movs	r1, r7
    4106:	0020      	movs	r0, r4
    4108:	f7fd fe4a 	bl	1da0 <set_receive_info>
    rpc_interface_scatter_send(CORES_PROTOCOL_CORE, RPC_APPLICATION_TO_PROTOCOL_SOCKET_SEND, true, 4, data_to_send);
    410c:	2304      	movs	r3, #4
    410e:	0022      	movs	r2, r4
    4110:	2125      	movs	r1, #37	; 0x25
    4112:	0020      	movs	r0, r4
    4114:	9500      	str	r5, [sp, #0]
    4116:	f7fe f8f3 	bl	2300 <rpc_interface_scatter_send>
    rpc_blocking_loop(CORES_PROTOCOL_CORE);
    411a:	0020      	movs	r0, r4
    411c:	f7fe f974 	bl	2408 <rpc_blocking_loop>
    return rpc_command_release(CORES_PROTOCOL_CORE);
    4120:	0020      	movs	r0, r4
    4122:	f7fe f987 	bl	2434 <rpc_command_release>
}
    4126:	b015      	add	sp, #84	; 0x54
    4128:	bdf0      	pop	{r4, r5, r6, r7, pc}

0000412a <command_socket_connect>:
{
    412a:	b5f0      	push	{r4, r5, r6, r7, lr}
    412c:	000c      	movs	r4, r1
    412e:	b091      	sub	sp, #68	; 0x44
    4130:	ae03      	add	r6, sp, #12
    4132:	0019      	movs	r1, r3
    4134:	8034      	strh	r4, [r6, #0]
    4136:	466b      	mov	r3, sp
    info.num_sections = 1;
    4138:	2401      	movs	r4, #1
{
    413a:	81d8      	strh	r0, [r3, #14]
    413c:	9202      	str	r2, [sp, #8]
    info.sections = get_sections;
    413e:	a807      	add	r0, sp, #28
    rpc_init_receive_section(&get_sections[0], (uint8 *)ret, sizeof(uint8), NULL);
    4140:	2300      	movs	r3, #0
    info.num_sections = 1;
    4142:	af05      	add	r7, sp, #20
    rpc_init_receive_section(&get_sections[0], (uint8 *)ret, sizeof(uint8), NULL);
    4144:	0022      	movs	r2, r4
    info.sections = get_sections;
    4146:	9005      	str	r0, [sp, #20]
    info.num_sections = 1;
    4148:	713c      	strb	r4, [r7, #4]
    rpc_init_receive_section(&get_sections[0], (uint8 *)ret, sizeof(uint8), NULL);
    414a:	f7fe f958 	bl	23fe <rpc_init_receive_section>
    data_to_send[0].data_location = (uint8 *)&socket;
    414e:	230e      	movs	r3, #14
    4150:	446b      	add	r3, sp
    4152:	930a      	str	r3, [sp, #40]	; 0x28
    data_to_send[0].data_length = sizeof(socket);
    4154:	2302      	movs	r3, #2
    data_to_send[0].data_location = (uint8 *)&socket;
    4156:	ad0a      	add	r5, sp, #40	; 0x28
    data_to_send[0].data_length = sizeof(socket);
    4158:	80ab      	strh	r3, [r5, #4]
    data_to_send[1].data_length = sizeof(sock_address_length);
    415a:	81ab      	strh	r3, [r5, #12]
    data_to_send[2].data_location = (uint8 *)sock_address;
    415c:	9b02      	ldr	r3, [sp, #8]
    RPC_ERR rpc_return = rpc_command_claim(CORES_PROTOCOL_CORE);
    415e:	0020      	movs	r0, r4
    data_to_send[2].data_location = (uint8 *)sock_address;
    4160:	930e      	str	r3, [sp, #56]	; 0x38
    data_to_send[2].data_length = sock_address_length;
    4162:	8833      	ldrh	r3, [r6, #0]
    data_to_send[1].data_location = (uint8 *)&sock_address_length;
    4164:	960c      	str	r6, [sp, #48]	; 0x30
    data_to_send[2].data_length = sock_address_length;
    4166:	82ab      	strh	r3, [r5, #20]
    RPC_ERR rpc_return = rpc_command_claim(CORES_PROTOCOL_CORE);
    4168:	f7fe f978 	bl	245c <rpc_command_claim>
    if (rpc_return != RPC_ERR_OK)
    416c:	2800      	cmp	r0, #0
    416e:	d110      	bne.n	4192 <command_socket_connect+0x68>
    set_receive_info(CORES_PROTOCOL_CORE, &info);
    4170:	0039      	movs	r1, r7
    4172:	0020      	movs	r0, r4
    4174:	f7fd fe14 	bl	1da0 <set_receive_info>
    rpc_interface_scatter_send(CORES_PROTOCOL_CORE, RPC_APPLICATION_TO_PROTOCOL_SOCKET_CONNECT, true, 3, data_to_send);
    4178:	2303      	movs	r3, #3
    417a:	0022      	movs	r2, r4
    417c:	2126      	movs	r1, #38	; 0x26
    417e:	0020      	movs	r0, r4
    4180:	9500      	str	r5, [sp, #0]
    4182:	f7fe f8bd 	bl	2300 <rpc_interface_scatter_send>
    rpc_blocking_loop(CORES_PROTOCOL_CORE);
    4186:	0020      	movs	r0, r4
    4188:	f7fe f93e 	bl	2408 <rpc_blocking_loop>
    return rpc_command_release(CORES_PROTOCOL_CORE);
    418c:	0020      	movs	r0, r4
    418e:	f7fe f951 	bl	2434 <rpc_command_release>
}
    4192:	b011      	add	sp, #68	; 0x44
    4194:	bdf0      	pop	{r4, r5, r6, r7, pc}

00004196 <command_set_ping>:
{
    4196:	b5f0      	push	{r4, r5, r6, r7, lr}
    4198:	260e      	movs	r6, #14
    info.num_sections = 1;
    419a:	2401      	movs	r4, #1
{
    419c:	b095      	sub	sp, #84	; 0x54
    419e:	9304      	str	r3, [sp, #16]
    41a0:	ab02      	add	r3, sp, #8
    41a2:	18f6      	adds	r6, r6, r3
    41a4:	8030      	strh	r0, [r6, #0]
    41a6:	819a      	strh	r2, [r3, #12]
    info.sections = get_sections;
    41a8:	a809      	add	r0, sp, #36	; 0x24
{
    41aa:	9103      	str	r1, [sp, #12]
    rpc_init_receive_section(&get_sections[0], (uint8 *)result, sizeof(uint8), NULL);
    41ac:	2300      	movs	r3, #0
    41ae:	0022      	movs	r2, r4
    info.num_sections = 1;
    41b0:	af07      	add	r7, sp, #28
    rpc_init_receive_section(&get_sections[0], (uint8 *)result, sizeof(uint8), NULL);
    41b2:	991a      	ldr	r1, [sp, #104]	; 0x68
    info.sections = get_sections;
    41b4:	9007      	str	r0, [sp, #28]
    info.num_sections = 1;
    41b6:	713c      	strb	r4, [r7, #4]
    rpc_init_receive_section(&get_sections[0], (uint8 *)result, sizeof(uint8), NULL);
    41b8:	f7fe f921 	bl	23fe <rpc_init_receive_section>
    data_to_send[1].data_location = (uint8 *)remote_addr;
    41bc:	9a03      	ldr	r2, [sp, #12]
    data_to_send[0].data_length = sizeof(remote_addr_length);
    41be:	2302      	movs	r3, #2
    data_to_send[0].data_location = (uint8 *)&remote_addr_length;
    41c0:	960c      	str	r6, [sp, #48]	; 0x30
    data_to_send[1].data_location = (uint8 *)remote_addr;
    41c2:	920e      	str	r2, [sp, #56]	; 0x38
    data_to_send[1].data_length = remote_addr_length;
    41c4:	8832      	ldrh	r2, [r6, #0]
    data_to_send[3].data_length = sizeof(timeout);
    41c6:	2604      	movs	r6, #4
    data_to_send[0].data_location = (uint8 *)&remote_addr_length;
    41c8:	ad0c      	add	r5, sp, #48	; 0x30
    data_to_send[0].data_length = sizeof(remote_addr_length);
    41ca:	80ab      	strh	r3, [r5, #4]
    data_to_send[1].data_length = remote_addr_length;
    41cc:	81aa      	strh	r2, [r5, #12]
    data_to_send[2].data_length = sizeof(p_size);
    41ce:	82ab      	strh	r3, [r5, #20]
    data_to_send[2].data_location = (uint8 *)&p_size;
    41d0:	aa05      	add	r2, sp, #20
    data_to_send[3].data_location = (uint8 *)&timeout;
    41d2:	ab04      	add	r3, sp, #16
    RPC_ERR rpc_return = rpc_command_claim(CORES_PROTOCOL_CORE);
    41d4:	0020      	movs	r0, r4
    data_to_send[2].data_location = (uint8 *)&p_size;
    41d6:	9210      	str	r2, [sp, #64]	; 0x40
    data_to_send[3].data_location = (uint8 *)&timeout;
    41d8:	9312      	str	r3, [sp, #72]	; 0x48
    data_to_send[3].data_length = sizeof(timeout);
    41da:	83ae      	strh	r6, [r5, #28]
    RPC_ERR rpc_return = rpc_command_claim(CORES_PROTOCOL_CORE);
    41dc:	f7fe f93e 	bl	245c <rpc_command_claim>
    if (rpc_return != RPC_ERR_OK)
    41e0:	2800      	cmp	r0, #0
    41e2:	d110      	bne.n	4206 <command_set_ping+0x70>
    set_receive_info(CORES_PROTOCOL_CORE, &info);
    41e4:	0039      	movs	r1, r7
    41e6:	0020      	movs	r0, r4
    41e8:	f7fd fdda 	bl	1da0 <set_receive_info>
    rpc_interface_scatter_send(CORES_PROTOCOL_CORE, RPC_APPLICATION_TO_PROTOCOL_SET_PING, true, 4, data_to_send);
    41ec:	0033      	movs	r3, r6
    41ee:	0022      	movs	r2, r4
    41f0:	2127      	movs	r1, #39	; 0x27
    41f2:	0020      	movs	r0, r4
    41f4:	9500      	str	r5, [sp, #0]
    41f6:	f7fe f883 	bl	2300 <rpc_interface_scatter_send>
    rpc_blocking_loop(CORES_PROTOCOL_CORE);
    41fa:	0020      	movs	r0, r4
    41fc:	f7fe f904 	bl	2408 <rpc_blocking_loop>
    return rpc_command_release(CORES_PROTOCOL_CORE);
    4200:	0020      	movs	r0, r4
    4202:	f7fe f917 	bl	2434 <rpc_command_release>
}
    4206:	b015      	add	sp, #84	; 0x54
    4208:	bdf0      	pop	{r4, r5, r6, r7, pc}

0000420a <command_set_system_time_from_apps>:
{
    420a:	b5f0      	push	{r4, r5, r6, r7, lr}
    420c:	270f      	movs	r7, #15
    420e:	b095      	sub	sp, #84	; 0x54
    4210:	446f      	add	r7, sp
    info.num_sections = 1;
    4212:	2401      	movs	r4, #1
{
    4214:	703a      	strb	r2, [r7, #0]
    4216:	466a      	mov	r2, sp
    4218:	9004      	str	r0, [sp, #16]
    421a:	9105      	str	r1, [sp, #20]
    421c:	7393      	strb	r3, [r2, #14]
    info.sections = get_sections;
    421e:	a809      	add	r0, sp, #36	; 0x24
    rpc_init_receive_section(&get_sections[0], (uint8 *)result, sizeof(uint8), NULL);
    4220:	2300      	movs	r3, #0
    info.num_sections = 1;
    4222:	ae07      	add	r6, sp, #28
    rpc_init_receive_section(&get_sections[0], (uint8 *)result, sizeof(uint8), NULL);
    4224:	0022      	movs	r2, r4
    4226:	991b      	ldr	r1, [sp, #108]	; 0x6c
    info.sections = get_sections;
    4228:	9007      	str	r0, [sp, #28]
    info.num_sections = 1;
    422a:	7134      	strb	r4, [r6, #4]
    rpc_init_receive_section(&get_sections[0], (uint8 *)result, sizeof(uint8), NULL);
    422c:	f7fe f8e7 	bl	23fe <rpc_init_receive_section>
    data_to_send[0].data_location = (uint8 *)&current_time;
    4230:	ab04      	add	r3, sp, #16
    4232:	930c      	str	r3, [sp, #48]	; 0x30
    data_to_send[0].data_length = sizeof(current_time);
    4234:	2308      	movs	r3, #8
    data_to_send[0].data_location = (uint8 *)&current_time;
    4236:	ad0c      	add	r5, sp, #48	; 0x30
    data_to_send[0].data_length = sizeof(current_time);
    4238:	80ab      	strh	r3, [r5, #4]
    data_to_send[2].data_location = (uint8 *)&daylight_saving_time;
    423a:	3306      	adds	r3, #6
    423c:	446b      	add	r3, sp
    423e:	9310      	str	r3, [sp, #64]	; 0x40
    RPC_ERR rpc_return = rpc_command_claim(CORES_PROTOCOL_CORE);
    4240:	0020      	movs	r0, r4
    data_to_send[3].data_location = (uint8 *)&updated_time_fields;
    4242:	ab1a      	add	r3, sp, #104	; 0x68
    data_to_send[1].data_location = (uint8 *)&time_zone;
    4244:	970e      	str	r7, [sp, #56]	; 0x38
    data_to_send[1].data_length = sizeof(time_zone);
    4246:	81ac      	strh	r4, [r5, #12]
    data_to_send[2].data_length = sizeof(daylight_saving_time);
    4248:	82ac      	strh	r4, [r5, #20]
    data_to_send[3].data_location = (uint8 *)&updated_time_fields;
    424a:	9312      	str	r3, [sp, #72]	; 0x48
    data_to_send[3].data_length = sizeof(updated_time_fields);
    424c:	83ac      	strh	r4, [r5, #28]
    RPC_ERR rpc_return = rpc_command_claim(CORES_PROTOCOL_CORE);
    424e:	f7fe f905 	bl	245c <rpc_command_claim>
    if (rpc_return != RPC_ERR_OK)
    4252:	2800      	cmp	r0, #0
    4254:	d110      	bne.n	4278 <command_set_system_time_from_apps+0x6e>
    set_receive_info(CORES_PROTOCOL_CORE, &info);
    4256:	0031      	movs	r1, r6
    4258:	0020      	movs	r0, r4
    425a:	f7fd fda1 	bl	1da0 <set_receive_info>
    rpc_interface_scatter_send(CORES_PROTOCOL_CORE, RPC_APPLICATION_TO_PROTOCOL_SET_SYSTEM_TIME_FROM_APPS, true, 4, data_to_send);
    425e:	2304      	movs	r3, #4
    4260:	0022      	movs	r2, r4
    4262:	2128      	movs	r1, #40	; 0x28
    4264:	0020      	movs	r0, r4
    4266:	9500      	str	r5, [sp, #0]
    4268:	f7fe f84a 	bl	2300 <rpc_interface_scatter_send>
    rpc_blocking_loop(CORES_PROTOCOL_CORE);
    426c:	0020      	movs	r0, r4
    426e:	f7fe f8cb 	bl	2408 <rpc_blocking_loop>
    return rpc_command_release(CORES_PROTOCOL_CORE);
    4272:	0020      	movs	r0, r4
    4274:	f7fe f8de 	bl	2434 <rpc_command_release>
}
    4278:	b015      	add	sp, #84	; 0x54
    427a:	bdf0      	pop	{r4, r5, r6, r7, pc}

0000427c <command_set_time_update_mode>:
{
    427c:	230f      	movs	r3, #15
    427e:	b530      	push	{r4, r5, lr}
    data_to_send[0].data_length = sizeof(time_update_mode);
    4280:	2401      	movs	r4, #1
{
    4282:	b087      	sub	sp, #28
    4284:	446b      	add	r3, sp
    4286:	7018      	strb	r0, [r3, #0]
    data_to_send[0].data_location = (uint8 *)&time_update_mode;
    4288:	ad04      	add	r5, sp, #16
    RPC_ERR rpc_return = rpc_command_claim(CORES_PROTOCOL_CORE);
    428a:	0020      	movs	r0, r4
    data_to_send[0].data_location = (uint8 *)&time_update_mode;
    428c:	9304      	str	r3, [sp, #16]
    data_to_send[0].data_length = sizeof(time_update_mode);
    428e:	80ac      	strh	r4, [r5, #4]
    RPC_ERR rpc_return = rpc_command_claim(CORES_PROTOCOL_CORE);
    4290:	f7fe f8e4 	bl	245c <rpc_command_claim>
    if (rpc_return != RPC_ERR_OK)
    4294:	2800      	cmp	r0, #0
    4296:	d10c      	bne.n	42b2 <command_set_time_update_mode+0x36>
    rpc_interface_scatter_send(CORES_PROTOCOL_CORE, RPC_APPLICATION_TO_PROTOCOL_SET_TIME_UPDATE_MODE, true, 1, data_to_send);
    4298:	0023      	movs	r3, r4
    429a:	0022      	movs	r2, r4
    429c:	2129      	movs	r1, #41	; 0x29
    429e:	0020      	movs	r0, r4
    42a0:	9500      	str	r5, [sp, #0]
    42a2:	f7fe f82d 	bl	2300 <rpc_interface_scatter_send>
    rpc_blocking_loop(CORES_PROTOCOL_CORE);
    42a6:	0020      	movs	r0, r4
    42a8:	f7fe f8ae 	bl	2408 <rpc_blocking_loop>
    return rpc_command_release(CORES_PROTOCOL_CORE);
    42ac:	0020      	movs	r0, r4
    42ae:	f7fe f8c1 	bl	2434 <rpc_command_release>
}
    42b2:	b007      	add	sp, #28
    42b4:	bd30      	pop	{r4, r5, pc}

000042b6 <command_get_time_update_mode>:
{
    42b6:	b570      	push	{r4, r5, r6, lr}
    info.num_sections = 1;
    42b8:	2401      	movs	r4, #1
{
    42ba:	b088      	sub	sp, #32
    42bc:	0001      	movs	r1, r0
    rpc_init_receive_section(&get_sections[0], (uint8 *)time_update_mode, sizeof(uint8), NULL);
    42be:	2300      	movs	r3, #0
    info.sections = get_sections;
    42c0:	a805      	add	r0, sp, #20
    rpc_init_receive_section(&get_sections[0], (uint8 *)time_update_mode, sizeof(uint8), NULL);
    42c2:	0022      	movs	r2, r4
    info.num_sections = 1;
    42c4:	ae03      	add	r6, sp, #12
    info.sections = get_sections;
    42c6:	9003      	str	r0, [sp, #12]
    info.num_sections = 1;
    42c8:	7134      	strb	r4, [r6, #4]
    rpc_init_receive_section(&get_sections[0], (uint8 *)time_update_mode, sizeof(uint8), NULL);
    42ca:	f7fe f898 	bl	23fe <rpc_init_receive_section>
    RPC_ERR rpc_return = rpc_command_claim(CORES_PROTOCOL_CORE);
    42ce:	0020      	movs	r0, r4
    42d0:	f7fe f8c4 	bl	245c <rpc_command_claim>
    42d4:	1e05      	subs	r5, r0, #0
    if (rpc_return != RPC_ERR_OK)
    42d6:	d111      	bne.n	42fc <command_get_time_update_mode+0x46>
    set_receive_info(CORES_PROTOCOL_CORE, &info);
    42d8:	0031      	movs	r1, r6
    42da:	0020      	movs	r0, r4
    42dc:	f7fd fd60 	bl	1da0 <set_receive_info>
    rpc_interface_scatter_send(CORES_PROTOCOL_CORE, RPC_APPLICATION_TO_PROTOCOL_GET_TIME_UPDATE_MODE, true, 0, NULL);
    42e0:	002b      	movs	r3, r5
    42e2:	0022      	movs	r2, r4
    42e4:	212a      	movs	r1, #42	; 0x2a
    42e6:	9500      	str	r5, [sp, #0]
    42e8:	0020      	movs	r0, r4
    42ea:	f7fe f809 	bl	2300 <rpc_interface_scatter_send>
    rpc_blocking_loop(CORES_PROTOCOL_CORE);
    42ee:	0020      	movs	r0, r4
    42f0:	f7fe f88a 	bl	2408 <rpc_blocking_loop>
    return rpc_command_release(CORES_PROTOCOL_CORE);
    42f4:	0020      	movs	r0, r4
    42f6:	f7fe f89d 	bl	2434 <rpc_command_release>
    42fa:	0005      	movs	r5, r0
}
    42fc:	0028      	movs	r0, r5
    42fe:	b008      	add	sp, #32
    4300:	bd70      	pop	{r4, r5, r6, pc}

00004302 <command_update_package_parse_req>:
{
    4302:	b570      	push	{r4, r5, r6, lr}
    info.num_sections = 1;
    4304:	2501      	movs	r5, #1
{
    4306:	b088      	sub	sp, #32
    4308:	0001      	movs	r1, r0
    rpc_init_receive_section(&get_sections[0], (uint8 *)result, sizeof(uint8), NULL);
    430a:	2300      	movs	r3, #0
    info.sections = get_sections;
    430c:	a805      	add	r0, sp, #20
    rpc_init_receive_section(&get_sections[0], (uint8 *)result, sizeof(uint8), NULL);
    430e:	002a      	movs	r2, r5
    info.num_sections = 1;
    4310:	ae03      	add	r6, sp, #12
    info.sections = get_sections;
    4312:	9003      	str	r0, [sp, #12]
    info.num_sections = 1;
    4314:	7135      	strb	r5, [r6, #4]
    rpc_init_receive_section(&get_sections[0], (uint8 *)result, sizeof(uint8), NULL);
    4316:	f7fe f872 	bl	23fe <rpc_init_receive_section>
    RPC_ERR rpc_return = rpc_command_claim(CORES_SECURITY_CORE);
    431a:	2000      	movs	r0, #0
    431c:	f7fe f89e 	bl	245c <rpc_command_claim>
    4320:	1e04      	subs	r4, r0, #0
    if (rpc_return != RPC_ERR_OK)
    4322:	d110      	bne.n	4346 <command_update_package_parse_req+0x44>
    set_receive_info(CORES_SECURITY_CORE, &info);
    4324:	0031      	movs	r1, r6
    4326:	f7fd fd3b 	bl	1da0 <set_receive_info>
    rpc_interface_scatter_send(CORES_SECURITY_CORE, RPC_APPLICATION_TO_SECURITY_UPDATE_PACKAGE_PARSE_REQ, true, 0, NULL);
    432a:	0023      	movs	r3, r4
    432c:	002a      	movs	r2, r5
    432e:	210b      	movs	r1, #11
    4330:	0020      	movs	r0, r4
    4332:	9400      	str	r4, [sp, #0]
    4334:	f7fd ffe4 	bl	2300 <rpc_interface_scatter_send>
    rpc_blocking_loop(CORES_SECURITY_CORE);
    4338:	0020      	movs	r0, r4
    433a:	f7fe f865 	bl	2408 <rpc_blocking_loop>
    return rpc_command_release(CORES_SECURITY_CORE);
    433e:	0020      	movs	r0, r4
    4340:	f7fe f878 	bl	2434 <rpc_command_release>
    4344:	0004      	movs	r4, r0
}
    4346:	0020      	movs	r0, r4
    4348:	b008      	add	sp, #32
    434a:	bd70      	pop	{r4, r5, r6, pc}

0000434c <command_update_package_get_package_version_req>:
{
    434c:	b570      	push	{r4, r5, r6, lr}
    info.num_sections = 1;
    434e:	2501      	movs	r5, #1
{
    4350:	b088      	sub	sp, #32
    4352:	0001      	movs	r1, r0
    rpc_init_receive_section(&get_sections[0], (uint8 *)result, sizeof(uint8), NULL);
    4354:	2300      	movs	r3, #0
    info.sections = get_sections;
    4356:	a805      	add	r0, sp, #20
    rpc_init_receive_section(&get_sections[0], (uint8 *)result, sizeof(uint8), NULL);
    4358:	002a      	movs	r2, r5
    info.num_sections = 1;
    435a:	ae03      	add	r6, sp, #12
    info.sections = get_sections;
    435c:	9003      	str	r0, [sp, #12]
    info.num_sections = 1;
    435e:	7135      	strb	r5, [r6, #4]
    rpc_init_receive_section(&get_sections[0], (uint8 *)result, sizeof(uint8), NULL);
    4360:	f7fe f84d 	bl	23fe <rpc_init_receive_section>
    RPC_ERR rpc_return = rpc_command_claim(CORES_SECURITY_CORE);
    4364:	2000      	movs	r0, #0
    4366:	f7fe f879 	bl	245c <rpc_command_claim>
    436a:	1e04      	subs	r4, r0, #0
    if (rpc_return != RPC_ERR_OK)
    436c:	d110      	bne.n	4390 <command_update_package_get_package_version_req+0x44>
    set_receive_info(CORES_SECURITY_CORE, &info);
    436e:	0031      	movs	r1, r6
    4370:	f7fd fd16 	bl	1da0 <set_receive_info>
    rpc_interface_scatter_send(CORES_SECURITY_CORE, RPC_APPLICATION_TO_SECURITY_UPDATE_PACKAGE_GET_PACKAGE_VERSION_REQ, true, 0, NULL);
    4374:	0023      	movs	r3, r4
    4376:	002a      	movs	r2, r5
    4378:	210d      	movs	r1, #13
    437a:	0020      	movs	r0, r4
    437c:	9400      	str	r4, [sp, #0]
    437e:	f7fd ffbf 	bl	2300 <rpc_interface_scatter_send>
    rpc_blocking_loop(CORES_SECURITY_CORE);
    4382:	0020      	movs	r0, r4
    4384:	f7fe f840 	bl	2408 <rpc_blocking_loop>
    return rpc_command_release(CORES_SECURITY_CORE);
    4388:	0020      	movs	r0, r4
    438a:	f7fe f853 	bl	2434 <rpc_command_release>
    438e:	0004      	movs	r4, r0
}
    4390:	0020      	movs	r0, r4
    4392:	b008      	add	sp, #32
    4394:	bd70      	pop	{r4, r5, r6, pc}

00004396 <command_update_package_get_package_name_req>:
{
    4396:	b570      	push	{r4, r5, r6, lr}
    info.num_sections = 1;
    4398:	2501      	movs	r5, #1
{
    439a:	b088      	sub	sp, #32
    439c:	0001      	movs	r1, r0
    rpc_init_receive_section(&get_sections[0], (uint8 *)result, sizeof(uint8), NULL);
    439e:	2300      	movs	r3, #0
    info.sections = get_sections;
    43a0:	a805      	add	r0, sp, #20
    rpc_init_receive_section(&get_sections[0], (uint8 *)result, sizeof(uint8), NULL);
    43a2:	002a      	movs	r2, r5
    info.num_sections = 1;
    43a4:	ae03      	add	r6, sp, #12
    info.sections = get_sections;
    43a6:	9003      	str	r0, [sp, #12]
    info.num_sections = 1;
    43a8:	7135      	strb	r5, [r6, #4]
    rpc_init_receive_section(&get_sections[0], (uint8 *)result, sizeof(uint8), NULL);
    43aa:	f7fe f828 	bl	23fe <rpc_init_receive_section>
    RPC_ERR rpc_return = rpc_command_claim(CORES_SECURITY_CORE);
    43ae:	2000      	movs	r0, #0
    43b0:	f7fe f854 	bl	245c <rpc_command_claim>
    43b4:	1e04      	subs	r4, r0, #0
    if (rpc_return != RPC_ERR_OK)
    43b6:	d110      	bne.n	43da <command_update_package_get_package_name_req+0x44>
    set_receive_info(CORES_SECURITY_CORE, &info);
    43b8:	0031      	movs	r1, r6
    43ba:	f7fd fcf1 	bl	1da0 <set_receive_info>
    rpc_interface_scatter_send(CORES_SECURITY_CORE, RPC_APPLICATION_TO_SECURITY_UPDATE_PACKAGE_GET_PACKAGE_NAME_REQ, true, 0, NULL);
    43be:	0023      	movs	r3, r4
    43c0:	002a      	movs	r2, r5
    43c2:	210e      	movs	r1, #14
    43c4:	0020      	movs	r0, r4
    43c6:	9400      	str	r4, [sp, #0]
    43c8:	f7fd ff9a 	bl	2300 <rpc_interface_scatter_send>
    rpc_blocking_loop(CORES_SECURITY_CORE);
    43cc:	0020      	movs	r0, r4
    43ce:	f7fe f81b 	bl	2408 <rpc_blocking_loop>
    return rpc_command_release(CORES_SECURITY_CORE);
    43d2:	0020      	movs	r0, r4
    43d4:	f7fe f82e 	bl	2434 <rpc_command_release>
    43d8:	0004      	movs	r4, r0
}
    43da:	0020      	movs	r0, r4
    43dc:	b008      	add	sp, #32
    43de:	bd70      	pop	{r4, r5, r6, pc}

000043e0 <command_firmware_upgrade_req>:
{
    43e0:	b570      	push	{r4, r5, r6, lr}
    info.num_sections = 2;
    43e2:	2302      	movs	r3, #2
{
    43e4:	0006      	movs	r6, r0
    43e6:	000c      	movs	r4, r1
    43e8:	b08a      	sub	sp, #40	; 0x28
    info.num_sections = 2;
    43ea:	ad02      	add	r5, sp, #8
    info.sections = get_sections;
    43ec:	a804      	add	r0, sp, #16
    info.num_sections = 2;
    43ee:	712b      	strb	r3, [r5, #4]
    rpc_init_receive_section(&get_sections[0], (uint8 *)result, sizeof(uint8), NULL);
    43f0:	2201      	movs	r2, #1
    43f2:	2300      	movs	r3, #0
    43f4:	0031      	movs	r1, r6
    info.sections = get_sections;
    43f6:	9002      	str	r0, [sp, #8]
    rpc_init_receive_section(&get_sections[0], (uint8 *)result, sizeof(uint8), NULL);
    43f8:	f7fe f801 	bl	23fe <rpc_init_receive_section>
    rpc_init_receive_section(&get_sections[1], (uint8 *)status, sizeof(uint8), NULL);
    43fc:	0021      	movs	r1, r4
    43fe:	2300      	movs	r3, #0
    4400:	2201      	movs	r2, #1
    4402:	a807      	add	r0, sp, #28
    4404:	f7fd fffb 	bl	23fe <rpc_init_receive_section>
    RPC_ERR rpc_return = rpc_command_claim(CORES_SECURITY_CORE);
    4408:	2000      	movs	r0, #0
    440a:	f7fe f827 	bl	245c <rpc_command_claim>
    440e:	1e04      	subs	r4, r0, #0
    if (rpc_return != RPC_ERR_OK)
    4410:	d110      	bne.n	4434 <command_firmware_upgrade_req+0x54>
    set_receive_info(CORES_SECURITY_CORE, &info);
    4412:	0029      	movs	r1, r5
    4414:	f7fd fcc4 	bl	1da0 <set_receive_info>
    rpc_interface_scatter_send(CORES_SECURITY_CORE, RPC_APPLICATION_TO_SECURITY_FIRMWARE_UPGRADE_REQ, true, 0, NULL);
    4418:	0023      	movs	r3, r4
    441a:	2201      	movs	r2, #1
    441c:	210f      	movs	r1, #15
    441e:	0020      	movs	r0, r4
    4420:	9400      	str	r4, [sp, #0]
    4422:	f7fd ff6d 	bl	2300 <rpc_interface_scatter_send>
    rpc_blocking_loop(CORES_SECURITY_CORE);
    4426:	0020      	movs	r0, r4
    4428:	f7fd ffee 	bl	2408 <rpc_blocking_loop>
    return rpc_command_release(CORES_SECURITY_CORE);
    442c:	0020      	movs	r0, r4
    442e:	f7fe f801 	bl	2434 <rpc_command_release>
    4432:	0004      	movs	r4, r0
}
    4434:	0020      	movs	r0, r4
    4436:	b00a      	add	sp, #40	; 0x28
    4438:	bd70      	pop	{r4, r5, r6, pc}

0000443a <command_update_package_flash_erase>:
{
    443a:	b570      	push	{r4, r5, r6, lr}
    info.num_sections = 1;
    443c:	2501      	movs	r5, #1
{
    443e:	b088      	sub	sp, #32
    4440:	0001      	movs	r1, r0
    rpc_init_receive_section(&get_sections[0], (uint8 *)buffered, sizeof(bool), NULL);
    4442:	2300      	movs	r3, #0
    info.sections = get_sections;
    4444:	a805      	add	r0, sp, #20
    rpc_init_receive_section(&get_sections[0], (uint8 *)buffered, sizeof(bool), NULL);
    4446:	002a      	movs	r2, r5
    info.num_sections = 1;
    4448:	ae03      	add	r6, sp, #12
    info.sections = get_sections;
    444a:	9003      	str	r0, [sp, #12]
    info.num_sections = 1;
    444c:	7135      	strb	r5, [r6, #4]
    rpc_init_receive_section(&get_sections[0], (uint8 *)buffered, sizeof(bool), NULL);
    444e:	f7fd ffd6 	bl	23fe <rpc_init_receive_section>
    RPC_ERR rpc_return = rpc_command_claim(CORES_SECURITY_CORE);
    4452:	2000      	movs	r0, #0
    4454:	f7fe f802 	bl	245c <rpc_command_claim>
    4458:	1e04      	subs	r4, r0, #0
    if (rpc_return != RPC_ERR_OK)
    445a:	d110      	bne.n	447e <command_update_package_flash_erase+0x44>
    set_receive_info(CORES_SECURITY_CORE, &info);
    445c:	0031      	movs	r1, r6
    445e:	f7fd fc9f 	bl	1da0 <set_receive_info>
    rpc_interface_scatter_send(CORES_SECURITY_CORE, RPC_APPLICATION_TO_SECURITY_UPDATE_PACKAGE_FLASH_ERASE, true, 0, NULL);
    4462:	0023      	movs	r3, r4
    4464:	002a      	movs	r2, r5
    4466:	2113      	movs	r1, #19
    4468:	0020      	movs	r0, r4
    446a:	9400      	str	r4, [sp, #0]
    446c:	f7fd ff48 	bl	2300 <rpc_interface_scatter_send>
    rpc_blocking_loop(CORES_SECURITY_CORE);
    4470:	0020      	movs	r0, r4
    4472:	f7fd ffc9 	bl	2408 <rpc_blocking_loop>
    return rpc_command_release(CORES_SECURITY_CORE);
    4476:	0020      	movs	r0, r4
    4478:	f7fd ffdc 	bl	2434 <rpc_command_release>
    447c:	0004      	movs	r4, r0
}
    447e:	0020      	movs	r0, r4
    4480:	b008      	add	sp, #32
    4482:	bd70      	pop	{r4, r5, r6, pc}

00004484 <command_update_package_flash_write>:
{
    4484:	b5f0      	push	{r4, r5, r6, r7, lr}
    info.num_sections = 1;
    4486:	2601      	movs	r6, #1
{
    4488:	b093      	sub	sp, #76	; 0x4c
    448a:	9005      	str	r0, [sp, #20]
    448c:	9104      	str	r1, [sp, #16]
    info.sections = get_sections;
    448e:	a809      	add	r0, sp, #36	; 0x24
{
    4490:	0019      	movs	r1, r3
    4492:	9203      	str	r2, [sp, #12]
    rpc_init_receive_section(&get_sections[0], (uint8 *)buffered, sizeof(bool), NULL);
    4494:	2300      	movs	r3, #0
    4496:	0032      	movs	r2, r6
    info.num_sections = 1;
    4498:	af07      	add	r7, sp, #28
    info.sections = get_sections;
    449a:	9007      	str	r0, [sp, #28]
    info.num_sections = 1;
    449c:	713e      	strb	r6, [r7, #4]
    rpc_init_receive_section(&get_sections[0], (uint8 *)buffered, sizeof(bool), NULL);
    449e:	f7fd ffae 	bl	23fe <rpc_init_receive_section>
    data_to_send[0].data_location = (uint8 *)&buffer_length;
    44a2:	ab05      	add	r3, sp, #20
    44a4:	930c      	str	r3, [sp, #48]	; 0x30
    data_to_send[0].data_length = sizeof(buffer_length);
    44a6:	2304      	movs	r3, #4
    data_to_send[1].data_location = (uint8 *)&buffer;
    44a8:	aa04      	add	r2, sp, #16
    data_to_send[0].data_location = (uint8 *)&buffer_length;
    44aa:	ad0c      	add	r5, sp, #48	; 0x30
    data_to_send[1].data_location = (uint8 *)&buffer;
    44ac:	920e      	str	r2, [sp, #56]	; 0x38
    RPC_ERR rpc_return = rpc_command_claim(CORES_SECURITY_CORE);
    44ae:	2000      	movs	r0, #0
    data_to_send[2].data_location = (uint8 *)&offset;
    44b0:	aa03      	add	r2, sp, #12
    data_to_send[0].data_length = sizeof(buffer_length);
    44b2:	80ab      	strh	r3, [r5, #4]
    data_to_send[1].data_length = sizeof(buffer);
    44b4:	81ab      	strh	r3, [r5, #12]
    data_to_send[2].data_location = (uint8 *)&offset;
    44b6:	9210      	str	r2, [sp, #64]	; 0x40
    data_to_send[2].data_length = sizeof(offset);
    44b8:	82ab      	strh	r3, [r5, #20]
    RPC_ERR rpc_return = rpc_command_claim(CORES_SECURITY_CORE);
    44ba:	f7fd ffcf 	bl	245c <rpc_command_claim>
    44be:	1e04      	subs	r4, r0, #0
    if (rpc_return != RPC_ERR_OK)
    44c0:	d110      	bne.n	44e4 <command_update_package_flash_write+0x60>
    set_receive_info(CORES_SECURITY_CORE, &info);
    44c2:	0039      	movs	r1, r7
    44c4:	f7fd fc6c 	bl	1da0 <set_receive_info>
    rpc_interface_scatter_send(CORES_SECURITY_CORE, RPC_APPLICATION_TO_SECURITY_UPDATE_PACKAGE_FLASH_WRITE, true, 3, data_to_send);
    44c8:	2303      	movs	r3, #3
    44ca:	0032      	movs	r2, r6
    44cc:	2114      	movs	r1, #20
    44ce:	0020      	movs	r0, r4
    44d0:	9500      	str	r5, [sp, #0]
    44d2:	f7fd ff15 	bl	2300 <rpc_interface_scatter_send>
    rpc_blocking_loop(CORES_SECURITY_CORE);
    44d6:	0020      	movs	r0, r4
    44d8:	f7fd ff96 	bl	2408 <rpc_blocking_loop>
    return rpc_command_release(CORES_SECURITY_CORE);
    44dc:	0020      	movs	r0, r4
    44de:	f7fd ffa9 	bl	2434 <rpc_command_release>
    44e2:	0004      	movs	r4, r0
}
    44e4:	0020      	movs	r0, r4
    44e6:	b013      	add	sp, #76	; 0x4c
    44e8:	bdf0      	pop	{r4, r5, r6, r7, pc}

000044ea <command_rf_config_ctrl>:
{
    44ea:	b5f0      	push	{r4, r5, r6, r7, lr}
    44ec:	270f      	movs	r7, #15
    info.num_sections = 1;
    44ee:	2401      	movs	r4, #1
{
    44f0:	b08d      	sub	sp, #52	; 0x34
    44f2:	446f      	add	r7, sp
    44f4:	7038      	strb	r0, [r7, #0]
    info.num_sections = 1;
    44f6:	ae05      	add	r6, sp, #20
    info.sections = get_sections;
    44f8:	a809      	add	r0, sp, #36	; 0x24
    rpc_init_receive_section(&get_sections[0], (uint8 *)result, sizeof(uint8), NULL);
    44fa:	2300      	movs	r3, #0
    44fc:	0022      	movs	r2, r4
    info.sections = get_sections;
    44fe:	9005      	str	r0, [sp, #20]
    info.num_sections = 1;
    4500:	7134      	strb	r4, [r6, #4]
    data_to_send[0].data_location = (uint8 *)&ctrl_command;
    4502:	ad07      	add	r5, sp, #28
    rpc_init_receive_section(&get_sections[0], (uint8 *)result, sizeof(uint8), NULL);
    4504:	f7fd ff7b 	bl	23fe <rpc_init_receive_section>
    RPC_ERR rpc_return = rpc_command_claim(CORES_PROTOCOL_CORE);
    4508:	0020      	movs	r0, r4
    data_to_send[0].data_location = (uint8 *)&ctrl_command;
    450a:	9707      	str	r7, [sp, #28]
    data_to_send[0].data_length = sizeof(ctrl_command);
    450c:	80ac      	strh	r4, [r5, #4]
    RPC_ERR rpc_return = rpc_command_claim(CORES_PROTOCOL_CORE);
    450e:	f7fd ffa5 	bl	245c <rpc_command_claim>
    if (rpc_return != RPC_ERR_OK)
    4512:	2800      	cmp	r0, #0
    4514:	d110      	bne.n	4538 <command_rf_config_ctrl+0x4e>
    set_receive_info(CORES_PROTOCOL_CORE, &info);
    4516:	0031      	movs	r1, r6
    4518:	0020      	movs	r0, r4
    451a:	f7fd fc41 	bl	1da0 <set_receive_info>
    rpc_interface_scatter_send(CORES_PROTOCOL_CORE, RPC_APPLICATION_TO_PROTOCOL_RF_CONFIG_CTRL, true, 1, data_to_send);
    451e:	0023      	movs	r3, r4
    4520:	0022      	movs	r2, r4
    4522:	212b      	movs	r1, #43	; 0x2b
    4524:	0020      	movs	r0, r4
    4526:	9500      	str	r5, [sp, #0]
    4528:	f7fd feea 	bl	2300 <rpc_interface_scatter_send>
    rpc_blocking_loop(CORES_PROTOCOL_CORE);
    452c:	0020      	movs	r0, r4
    452e:	f7fd ff6b 	bl	2408 <rpc_blocking_loop>
    return rpc_command_release(CORES_PROTOCOL_CORE);
    4532:	0020      	movs	r0, r4
    4534:	f7fd ff7e 	bl	2434 <rpc_command_release>
}
    4538:	b00d      	add	sp, #52	; 0x34
    453a:	bdf0      	pop	{r4, r5, r6, r7, pc}

0000453c <command_radio_config_meas_rssi>:
{
    453c:	b5f0      	push	{r4, r5, r6, r7, lr}
    453e:	240b      	movs	r4, #11
    4540:	b097      	sub	sp, #92	; 0x5c
    4542:	9003      	str	r0, [sp, #12]
    4544:	0008      	movs	r0, r1
    4546:	0019      	movs	r1, r3
    4548:	466b      	mov	r3, sp
    info.num_sections = 3;
    454a:	2603      	movs	r6, #3
{
    454c:	446c      	add	r4, sp
    454e:	7020      	strb	r0, [r4, #0]
    4550:	729a      	strb	r2, [r3, #10]
    info.sections = get_sections;
    4552:	a80d      	add	r0, sp, #52	; 0x34
    rpc_init_receive_section(&get_sections[0], (uint8 *)result, sizeof(uint8), NULL);
    4554:	2300      	movs	r3, #0
    4556:	2201      	movs	r2, #1
    info.num_sections = 3;
    4558:	af05      	add	r7, sp, #20
    info.sections = get_sections;
    455a:	9005      	str	r0, [sp, #20]
    info.num_sections = 3;
    455c:	713e      	strb	r6, [r7, #4]
    rpc_init_receive_section(&get_sections[0], (uint8 *)result, sizeof(uint8), NULL);
    455e:	f7fd ff4e 	bl	23fe <rpc_init_receive_section>
    rpc_init_receive_section(&get_sections[1], (uint8 *)rssi, sizeof(int16), NULL);
    4562:	2300      	movs	r3, #0
    4564:	2202      	movs	r2, #2
    4566:	991c      	ldr	r1, [sp, #112]	; 0x70
    4568:	a810      	add	r0, sp, #64	; 0x40
    456a:	f7fd ff48 	bl	23fe <rpc_init_receive_section>
    rpc_init_receive_section(&get_sections[2], (uint8 *)snr, sizeof(int16), NULL);
    456e:	2300      	movs	r3, #0
    4570:	a813      	add	r0, sp, #76	; 0x4c
    4572:	2202      	movs	r2, #2
    4574:	991d      	ldr	r1, [sp, #116]	; 0x74
    4576:	f7fd ff42 	bl	23fe <rpc_init_receive_section>
    data_to_send[0].data_location = (uint8 *)&frequency;
    457a:	ab03      	add	r3, sp, #12
    457c:	9307      	str	r3, [sp, #28]
    data_to_send[0].data_length = sizeof(frequency);
    457e:	2304      	movs	r3, #4
    data_to_send[1].data_location = (uint8 *)&gain_index;
    4580:	9409      	str	r4, [sp, #36]	; 0x24
    data_to_send[1].data_length = sizeof(gain_index);
    4582:	2401      	movs	r4, #1
    data_to_send[0].data_location = (uint8 *)&frequency;
    4584:	ad07      	add	r5, sp, #28
    data_to_send[0].data_length = sizeof(frequency);
    4586:	80ab      	strh	r3, [r5, #4]
    data_to_send[2].data_location = (uint8 *)&port;
    4588:	3306      	adds	r3, #6
    458a:	446b      	add	r3, sp
    RPC_ERR rpc_return = rpc_command_claim(CORES_PROTOCOL_CORE);
    458c:	0020      	movs	r0, r4
    data_to_send[1].data_length = sizeof(gain_index);
    458e:	81ac      	strh	r4, [r5, #12]
    data_to_send[2].data_location = (uint8 *)&port;
    4590:	930b      	str	r3, [sp, #44]	; 0x2c
    data_to_send[2].data_length = sizeof(port);
    4592:	82ac      	strh	r4, [r5, #20]
    RPC_ERR rpc_return = rpc_command_claim(CORES_PROTOCOL_CORE);
    4594:	f7fd ff62 	bl	245c <rpc_command_claim>
    if (rpc_return != RPC_ERR_OK)
    4598:	2800      	cmp	r0, #0
    459a:	d110      	bne.n	45be <command_radio_config_meas_rssi+0x82>
    set_receive_info(CORES_PROTOCOL_CORE, &info);
    459c:	0039      	movs	r1, r7
    459e:	0020      	movs	r0, r4
    45a0:	f7fd fbfe 	bl	1da0 <set_receive_info>
    rpc_interface_scatter_send(CORES_PROTOCOL_CORE, RPC_APPLICATION_TO_PROTOCOL_RADIO_CONFIG_MEAS_RSSI, true, 3, data_to_send);
    45a4:	0033      	movs	r3, r6
    45a6:	0022      	movs	r2, r4
    45a8:	212c      	movs	r1, #44	; 0x2c
    45aa:	0020      	movs	r0, r4
    45ac:	9500      	str	r5, [sp, #0]
    45ae:	f7fd fea7 	bl	2300 <rpc_interface_scatter_send>
    rpc_blocking_loop(CORES_PROTOCOL_CORE);
    45b2:	0020      	movs	r0, r4
    45b4:	f7fd ff28 	bl	2408 <rpc_blocking_loop>
    return rpc_command_release(CORES_PROTOCOL_CORE);
    45b8:	0020      	movs	r0, r4
    45ba:	f7fd ff3b 	bl	2434 <rpc_command_release>
}
    45be:	b017      	add	sp, #92	; 0x5c
    45c0:	bdf0      	pop	{r4, r5, r6, r7, pc}

000045c2 <command_radio_config_read_mipi_word>:
{
    45c2:	b5f0      	push	{r4, r5, r6, r7, lr}
    45c4:	b091      	sub	sp, #68	; 0x44
    45c6:	000e      	movs	r6, r1
    45c8:	001d      	movs	r5, r3
    45ca:	466b      	mov	r3, sp
    45cc:	240f      	movs	r4, #15
    45ce:	739e      	strb	r6, [r3, #14]
    info.num_sections = 2;
    45d0:	2602      	movs	r6, #2
{
    45d2:	446c      	add	r4, sp
    45d4:	0011      	movs	r1, r2
    45d6:	7020      	strb	r0, [r4, #0]
    rpc_init_receive_section(&get_sections[0], (uint8 *)result, sizeof(uint8), NULL);
    45d8:	2300      	movs	r3, #0
    info.sections = get_sections;
    45da:	a80a      	add	r0, sp, #40	; 0x28
    rpc_init_receive_section(&get_sections[0], (uint8 *)result, sizeof(uint8), NULL);
    45dc:	2201      	movs	r2, #1
    info.num_sections = 2;
    45de:	af04      	add	r7, sp, #16
    info.sections = get_sections;
    45e0:	9004      	str	r0, [sp, #16]
    info.num_sections = 2;
    45e2:	713e      	strb	r6, [r7, #4]
    rpc_init_receive_section(&get_sections[0], (uint8 *)result, sizeof(uint8), NULL);
    45e4:	f7fd ff0b 	bl	23fe <rpc_init_receive_section>
    rpc_init_receive_section(&get_sections[1], (uint8 *)mipi_data, sizeof(uint8), NULL);
    45e8:	2300      	movs	r3, #0
    45ea:	0029      	movs	r1, r5
    45ec:	a80d      	add	r0, sp, #52	; 0x34
    45ee:	2201      	movs	r2, #1
    45f0:	f7fd ff05 	bl	23fe <rpc_init_receive_section>
    data_to_send[0].data_location = (uint8 *)&slave_addr;
    45f4:	9406      	str	r4, [sp, #24]
    data_to_send[1].data_location = (uint8 *)&data_addr;
    45f6:	230e      	movs	r3, #14
    data_to_send[0].data_length = sizeof(slave_addr);
    45f8:	2401      	movs	r4, #1
    data_to_send[0].data_location = (uint8 *)&slave_addr;
    45fa:	ad06      	add	r5, sp, #24
    data_to_send[1].data_location = (uint8 *)&data_addr;
    45fc:	446b      	add	r3, sp
    data_to_send[0].data_length = sizeof(slave_addr);
    45fe:	80ac      	strh	r4, [r5, #4]
    data_to_send[1].data_length = sizeof(data_addr);
    4600:	81ac      	strh	r4, [r5, #12]
    RPC_ERR rpc_return = rpc_command_claim(CORES_PROTOCOL_CORE);
    4602:	0020      	movs	r0, r4
    data_to_send[1].data_location = (uint8 *)&data_addr;
    4604:	9308      	str	r3, [sp, #32]
    RPC_ERR rpc_return = rpc_command_claim(CORES_PROTOCOL_CORE);
    4606:	f7fd ff29 	bl	245c <rpc_command_claim>
    if (rpc_return != RPC_ERR_OK)
    460a:	2800      	cmp	r0, #0
    460c:	d110      	bne.n	4630 <command_radio_config_read_mipi_word+0x6e>
    set_receive_info(CORES_PROTOCOL_CORE, &info);
    460e:	0039      	movs	r1, r7
    4610:	0020      	movs	r0, r4
    4612:	f7fd fbc5 	bl	1da0 <set_receive_info>
    rpc_interface_scatter_send(CORES_PROTOCOL_CORE, RPC_APPLICATION_TO_PROTOCOL_RADIO_CONFIG_READ_MIPI_WORD, true, 2, data_to_send);
    4616:	0033      	movs	r3, r6
    4618:	0022      	movs	r2, r4
    461a:	212d      	movs	r1, #45	; 0x2d
    461c:	0020      	movs	r0, r4
    461e:	9500      	str	r5, [sp, #0]
    4620:	f7fd fe6e 	bl	2300 <rpc_interface_scatter_send>
    rpc_blocking_loop(CORES_PROTOCOL_CORE);
    4624:	0020      	movs	r0, r4
    4626:	f7fd feef 	bl	2408 <rpc_blocking_loop>
    return rpc_command_release(CORES_PROTOCOL_CORE);
    462a:	0020      	movs	r0, r4
    462c:	f7fd ff02 	bl	2434 <rpc_command_release>
}
    4630:	b011      	add	sp, #68	; 0x44
    4632:	bdf0      	pop	{r4, r5, r6, r7, pc}

00004634 <command_radio_config_write_mipi_word>:
{
    4634:	b5f0      	push	{r4, r5, r6, r7, lr}
    4636:	b091      	sub	sp, #68	; 0x44
    4638:	000c      	movs	r4, r1
    463a:	0019      	movs	r1, r3
    463c:	466b      	mov	r3, sp
    463e:	270f      	movs	r7, #15
    4640:	739c      	strb	r4, [r3, #14]
    info.num_sections = 1;
    4642:	2401      	movs	r4, #1
{
    4644:	446f      	add	r7, sp
    4646:	735a      	strb	r2, [r3, #13]
    4648:	7038      	strb	r0, [r7, #0]
    rpc_init_receive_section(&get_sections[0], (uint8 *)result, sizeof(uint8), NULL);
    464a:	2300      	movs	r3, #0
    info.sections = get_sections;
    464c:	a807      	add	r0, sp, #28
    info.num_sections = 1;
    464e:	ae05      	add	r6, sp, #20
    rpc_init_receive_section(&get_sections[0], (uint8 *)result, sizeof(uint8), NULL);
    4650:	0022      	movs	r2, r4
    info.sections = get_sections;
    4652:	9005      	str	r0, [sp, #20]
    info.num_sections = 1;
    4654:	7134      	strb	r4, [r6, #4]
    rpc_init_receive_section(&get_sections[0], (uint8 *)result, sizeof(uint8), NULL);
    4656:	f7fd fed2 	bl	23fe <rpc_init_receive_section>
    data_to_send[1].data_location = (uint8 *)&data_addr;
    465a:	230e      	movs	r3, #14
    465c:	446b      	add	r3, sp
    465e:	930c      	str	r3, [sp, #48]	; 0x30
    data_to_send[2].data_location = (uint8 *)&mipi_data;
    4660:	230d      	movs	r3, #13
    data_to_send[0].data_location = (uint8 *)&slave_addr;
    4662:	ad0a      	add	r5, sp, #40	; 0x28
    data_to_send[2].data_location = (uint8 *)&mipi_data;
    4664:	446b      	add	r3, sp
    RPC_ERR rpc_return = rpc_command_claim(CORES_PROTOCOL_CORE);
    4666:	0020      	movs	r0, r4
    data_to_send[0].data_location = (uint8 *)&slave_addr;
    4668:	970a      	str	r7, [sp, #40]	; 0x28
    data_to_send[0].data_length = sizeof(slave_addr);
    466a:	80ac      	strh	r4, [r5, #4]
    data_to_send[1].data_length = sizeof(data_addr);
    466c:	81ac      	strh	r4, [r5, #12]
    data_to_send[2].data_location = (uint8 *)&mipi_data;
    466e:	930e      	str	r3, [sp, #56]	; 0x38
    data_to_send[2].data_length = sizeof(mipi_data);
    4670:	82ac      	strh	r4, [r5, #20]
    RPC_ERR rpc_return = rpc_command_claim(CORES_PROTOCOL_CORE);
    4672:	f7fd fef3 	bl	245c <rpc_command_claim>
    if (rpc_return != RPC_ERR_OK)
    4676:	2800      	cmp	r0, #0
    4678:	d110      	bne.n	469c <command_radio_config_write_mipi_word+0x68>
    set_receive_info(CORES_PROTOCOL_CORE, &info);
    467a:	0031      	movs	r1, r6
    467c:	0020      	movs	r0, r4
    467e:	f7fd fb8f 	bl	1da0 <set_receive_info>
    rpc_interface_scatter_send(CORES_PROTOCOL_CORE, RPC_APPLICATION_TO_PROTOCOL_RADIO_CONFIG_WRITE_MIPI_WORD, true, 3, data_to_send);
    4682:	2303      	movs	r3, #3
    4684:	0022      	movs	r2, r4
    4686:	212e      	movs	r1, #46	; 0x2e
    4688:	0020      	movs	r0, r4
    468a:	9500      	str	r5, [sp, #0]
    468c:	f7fd fe38 	bl	2300 <rpc_interface_scatter_send>
    rpc_blocking_loop(CORES_PROTOCOL_CORE);
    4690:	0020      	movs	r0, r4
    4692:	f7fd feb9 	bl	2408 <rpc_blocking_loop>
    return rpc_command_release(CORES_PROTOCOL_CORE);
    4696:	0020      	movs	r0, r4
    4698:	f7fd fecc 	bl	2434 <rpc_command_release>
}
    469c:	b011      	add	sp, #68	; 0x44
    469e:	bdf0      	pop	{r4, r5, r6, r7, pc}

000046a0 <command_radio_config_tx_tone>:
{
    46a0:	b570      	push	{r4, r5, r6, lr}
    info.num_sections = 1;
    46a2:	2401      	movs	r4, #1
{
    46a4:	b08c      	sub	sp, #48	; 0x30
    46a6:	9003      	str	r0, [sp, #12]
    rpc_init_receive_section(&get_sections[0], (uint8 *)result, sizeof(uint8), NULL);
    46a8:	2300      	movs	r3, #0
    info.sections = get_sections;
    46aa:	a809      	add	r0, sp, #36	; 0x24
    info.num_sections = 1;
    46ac:	ae05      	add	r6, sp, #20
    rpc_init_receive_section(&get_sections[0], (uint8 *)result, sizeof(uint8), NULL);
    46ae:	0022      	movs	r2, r4
    info.sections = get_sections;
    46b0:	9005      	str	r0, [sp, #20]
    info.num_sections = 1;
    46b2:	7134      	strb	r4, [r6, #4]
    rpc_init_receive_section(&get_sections[0], (uint8 *)result, sizeof(uint8), NULL);
    46b4:	f7fd fea3 	bl	23fe <rpc_init_receive_section>
    data_to_send[0].data_location = (uint8 *)&frequency;
    46b8:	ab03      	add	r3, sp, #12
    46ba:	9307      	str	r3, [sp, #28]
    data_to_send[0].data_length = sizeof(frequency);
    46bc:	2304      	movs	r3, #4
    data_to_send[0].data_location = (uint8 *)&frequency;
    46be:	ad07      	add	r5, sp, #28
    RPC_ERR rpc_return = rpc_command_claim(CORES_PROTOCOL_CORE);
    46c0:	0020      	movs	r0, r4
    data_to_send[0].data_length = sizeof(frequency);
    46c2:	80ab      	strh	r3, [r5, #4]
    RPC_ERR rpc_return = rpc_command_claim(CORES_PROTOCOL_CORE);
    46c4:	f7fd feca 	bl	245c <rpc_command_claim>
    if (rpc_return != RPC_ERR_OK)
    46c8:	2800      	cmp	r0, #0
    46ca:	d110      	bne.n	46ee <command_radio_config_tx_tone+0x4e>
    set_receive_info(CORES_PROTOCOL_CORE, &info);
    46cc:	0031      	movs	r1, r6
    46ce:	0020      	movs	r0, r4
    46d0:	f7fd fb66 	bl	1da0 <set_receive_info>
    rpc_interface_scatter_send(CORES_PROTOCOL_CORE, RPC_APPLICATION_TO_PROTOCOL_RADIO_CONFIG_TX_TONE, true, 1, data_to_send);
    46d4:	0023      	movs	r3, r4
    46d6:	0022      	movs	r2, r4
    46d8:	212f      	movs	r1, #47	; 0x2f
    46da:	0020      	movs	r0, r4
    46dc:	9500      	str	r5, [sp, #0]
    46de:	f7fd fe0f 	bl	2300 <rpc_interface_scatter_send>
    rpc_blocking_loop(CORES_PROTOCOL_CORE);
    46e2:	0020      	movs	r0, r4
    46e4:	f7fd fe90 	bl	2408 <rpc_blocking_loop>
    return rpc_command_release(CORES_PROTOCOL_CORE);
    46e8:	0020      	movs	r0, r4
    46ea:	f7fd fea3 	bl	2434 <rpc_command_release>
}
    46ee:	b00c      	add	sp, #48	; 0x30
    46f0:	bd70      	pop	{r4, r5, r6, pc}

000046f2 <command_radio_config_set_tx_gains>:
{
    46f2:	b5f0      	push	{r4, r5, r6, r7, lr}
    46f4:	270e      	movs	r7, #14
    46f6:	b093      	sub	sp, #76	; 0x4c
    46f8:	446f      	add	r7, sp
    info.num_sections = 1;
    46fa:	2401      	movs	r4, #1
{
    46fc:	8038      	strh	r0, [r7, #0]
    46fe:	4668      	mov	r0, sp
    info.num_sections = 1;
    4700:	ae05      	add	r6, sp, #20
{
    4702:	7341      	strb	r1, [r0, #13]
    4704:	7302      	strb	r2, [r0, #12]
    4706:	8143      	strh	r3, [r0, #10]
    rpc_init_receive_section(&get_sections[0], (uint8 *)result, sizeof(uint8), NULL);
    4708:	0022      	movs	r2, r4
    info.sections = get_sections;
    470a:	a807      	add	r0, sp, #28
    rpc_init_receive_section(&get_sections[0], (uint8 *)result, sizeof(uint8), NULL);
    470c:	2300      	movs	r3, #0
    470e:	9918      	ldr	r1, [sp, #96]	; 0x60
    info.sections = get_sections;
    4710:	9005      	str	r0, [sp, #20]
    info.num_sections = 1;
    4712:	7134      	strb	r4, [r6, #4]
    rpc_init_receive_section(&get_sections[0], (uint8 *)result, sizeof(uint8), NULL);
    4714:	f7fd fe73 	bl	23fe <rpc_init_receive_section>
    data_to_send[1].data_location = (uint8 *)&tx_coarse_gain;
    4718:	220d      	movs	r2, #13
    471a:	446a      	add	r2, sp
    471c:	920c      	str	r2, [sp, #48]	; 0x30
    data_to_send[2].data_location = (uint8 *)&rf_gain;
    471e:	aa03      	add	r2, sp, #12
    4720:	920e      	str	r2, [sp, #56]	; 0x38
    data_to_send[3].data_location = (uint8 *)&mv;
    4722:	220a      	movs	r2, #10
    data_to_send[0].data_length = sizeof(tx_drive_level);
    4724:	2302      	movs	r3, #2
    data_to_send[0].data_location = (uint8 *)&tx_drive_level;
    4726:	ad0a      	add	r5, sp, #40	; 0x28
    data_to_send[3].data_location = (uint8 *)&mv;
    4728:	446a      	add	r2, sp
    RPC_ERR rpc_return = rpc_command_claim(CORES_PROTOCOL_CORE);
    472a:	0020      	movs	r0, r4
    data_to_send[0].data_location = (uint8 *)&tx_drive_level;
    472c:	970a      	str	r7, [sp, #40]	; 0x28
    data_to_send[0].data_length = sizeof(tx_drive_level);
    472e:	80ab      	strh	r3, [r5, #4]
    data_to_send[1].data_length = sizeof(tx_coarse_gain);
    4730:	81ac      	strh	r4, [r5, #12]
    data_to_send[2].data_length = sizeof(rf_gain);
    4732:	82ac      	strh	r4, [r5, #20]
    data_to_send[3].data_location = (uint8 *)&mv;
    4734:	9210      	str	r2, [sp, #64]	; 0x40
    data_to_send[3].data_length = sizeof(mv);
    4736:	83ab      	strh	r3, [r5, #28]
    RPC_ERR rpc_return = rpc_command_claim(CORES_PROTOCOL_CORE);
    4738:	f7fd fe90 	bl	245c <rpc_command_claim>
    if (rpc_return != RPC_ERR_OK)
    473c:	2800      	cmp	r0, #0
    473e:	d110      	bne.n	4762 <command_radio_config_set_tx_gains+0x70>
    set_receive_info(CORES_PROTOCOL_CORE, &info);
    4740:	0031      	movs	r1, r6
    4742:	0020      	movs	r0, r4
    4744:	f7fd fb2c 	bl	1da0 <set_receive_info>
    rpc_interface_scatter_send(CORES_PROTOCOL_CORE, RPC_APPLICATION_TO_PROTOCOL_RADIO_CONFIG_SET_TX_GAINS, true, 4, data_to_send);
    4748:	2304      	movs	r3, #4
    474a:	0022      	movs	r2, r4
    474c:	2130      	movs	r1, #48	; 0x30
    474e:	0020      	movs	r0, r4
    4750:	9500      	str	r5, [sp, #0]
    4752:	f7fd fdd5 	bl	2300 <rpc_interface_scatter_send>
    rpc_blocking_loop(CORES_PROTOCOL_CORE);
    4756:	0020      	movs	r0, r4
    4758:	f7fd fe56 	bl	2408 <rpc_blocking_loop>
    return rpc_command_release(CORES_PROTOCOL_CORE);
    475c:	0020      	movs	r0, r4
    475e:	f7fd fe69 	bl	2434 <rpc_command_release>
}
    4762:	b013      	add	sp, #76	; 0x4c
    4764:	bdf0      	pop	{r4, r5, r6, r7, pc}

00004766 <command_radio_config_get_tx_gains>:
{
    4766:	b5f0      	push	{r4, r5, r6, r7, lr}
    4768:	4684      	mov	ip, r0
    476a:	001c      	movs	r4, r3
    info.num_sections = 5;
    476c:	2305      	movs	r3, #5
{
    476e:	000f      	movs	r7, r1
    4770:	0016      	movs	r6, r2
    4772:	b095      	sub	sp, #84	; 0x54
    info.num_sections = 5;
    4774:	ad03      	add	r5, sp, #12
    rpc_init_receive_section(&get_sections[0], (uint8 *)result, sizeof(uint8), NULL);
    4776:	4661      	mov	r1, ip
    info.sections = get_sections;
    4778:	a805      	add	r0, sp, #20
    info.num_sections = 5;
    477a:	712b      	strb	r3, [r5, #4]
    rpc_init_receive_section(&get_sections[0], (uint8 *)result, sizeof(uint8), NULL);
    477c:	2201      	movs	r2, #1
    477e:	2300      	movs	r3, #0
    info.sections = get_sections;
    4780:	9003      	str	r0, [sp, #12]
    rpc_init_receive_section(&get_sections[0], (uint8 *)result, sizeof(uint8), NULL);
    4782:	f7fd fe3c 	bl	23fe <rpc_init_receive_section>
    rpc_init_receive_section(&get_sections[1], (uint8 *)tx_drive_level, sizeof(uint16), NULL);
    4786:	2300      	movs	r3, #0
    4788:	2202      	movs	r2, #2
    478a:	0039      	movs	r1, r7
    478c:	a808      	add	r0, sp, #32
    478e:	f7fd fe36 	bl	23fe <rpc_init_receive_section>
    rpc_init_receive_section(&get_sections[2], (uint8 *)tx_coarse_gain, sizeof(uint8), NULL);
    4792:	2300      	movs	r3, #0
    4794:	2201      	movs	r2, #1
    4796:	0031      	movs	r1, r6
    4798:	a80b      	add	r0, sp, #44	; 0x2c
    479a:	f7fd fe30 	bl	23fe <rpc_init_receive_section>
    rpc_init_receive_section(&get_sections[3], (uint8 *)rf_gain, sizeof(uint8), NULL);
    479e:	0021      	movs	r1, r4
    47a0:	2300      	movs	r3, #0
    47a2:	2201      	movs	r2, #1
    47a4:	a80e      	add	r0, sp, #56	; 0x38
    47a6:	f7fd fe2a 	bl	23fe <rpc_init_receive_section>
    rpc_init_receive_section(&get_sections[4], (uint8 *)ext_pa_gain, sizeof(uint16), NULL);
    47aa:	2300      	movs	r3, #0
    47ac:	2202      	movs	r2, #2
    47ae:	991a      	ldr	r1, [sp, #104]	; 0x68
    47b0:	a811      	add	r0, sp, #68	; 0x44
    47b2:	f7fd fe24 	bl	23fe <rpc_init_receive_section>
    RPC_ERR rpc_return = rpc_command_claim(CORES_PROTOCOL_CORE);
    47b6:	2001      	movs	r0, #1
    47b8:	f7fd fe50 	bl	245c <rpc_command_claim>
    47bc:	1e04      	subs	r4, r0, #0
    if (rpc_return != RPC_ERR_OK)
    47be:	d111      	bne.n	47e4 <command_radio_config_get_tx_gains+0x7e>
    set_receive_info(CORES_PROTOCOL_CORE, &info);
    47c0:	0029      	movs	r1, r5
    47c2:	2001      	movs	r0, #1
    47c4:	f7fd faec 	bl	1da0 <set_receive_info>
    rpc_interface_scatter_send(CORES_PROTOCOL_CORE, RPC_APPLICATION_TO_PROTOCOL_RADIO_CONFIG_GET_TX_GAINS, true, 0, NULL);
    47c8:	2201      	movs	r2, #1
    47ca:	0023      	movs	r3, r4
    47cc:	0010      	movs	r0, r2
    47ce:	2131      	movs	r1, #49	; 0x31
    47d0:	9400      	str	r4, [sp, #0]
    47d2:	f7fd fd95 	bl	2300 <rpc_interface_scatter_send>
    rpc_blocking_loop(CORES_PROTOCOL_CORE);
    47d6:	2001      	movs	r0, #1
    47d8:	f7fd fe16 	bl	2408 <rpc_blocking_loop>
    return rpc_command_release(CORES_PROTOCOL_CORE);
    47dc:	2001      	movs	r0, #1
    47de:	f7fd fe29 	bl	2434 <rpc_command_release>
    47e2:	0004      	movs	r4, r0
}
    47e4:	0020      	movs	r0, r4
    47e6:	b015      	add	sp, #84	; 0x54
    47e8:	bdf0      	pop	{r4, r5, r6, r7, pc}

000047ea <command_radio_config_set_rio_v>:
{
    47ea:	b5f0      	push	{r4, r5, r6, r7, lr}
    47ec:	270f      	movs	r7, #15
    47ee:	b08f      	sub	sp, #60	; 0x3c
    info.num_sections = 1;
    47f0:	2401      	movs	r4, #1
{
    47f2:	000b      	movs	r3, r1
    47f4:	0011      	movs	r1, r2
    47f6:	466a      	mov	r2, sp
    47f8:	446f      	add	r7, sp
    47fa:	7038      	strb	r0, [r7, #0]
    47fc:	8193      	strh	r3, [r2, #12]
    info.sections = get_sections;
    47fe:	a807      	add	r0, sp, #28
    rpc_init_receive_section(&get_sections[0], (uint8 *)ret_value, sizeof(uint8), NULL);
    4800:	2300      	movs	r3, #0
    info.num_sections = 1;
    4802:	ae05      	add	r6, sp, #20
    rpc_init_receive_section(&get_sections[0], (uint8 *)ret_value, sizeof(uint8), NULL);
    4804:	0022      	movs	r2, r4
    info.sections = get_sections;
    4806:	9005      	str	r0, [sp, #20]
    info.num_sections = 1;
    4808:	7134      	strb	r4, [r6, #4]
    rpc_init_receive_section(&get_sections[0], (uint8 *)ret_value, sizeof(uint8), NULL);
    480a:	f7fd fdf8 	bl	23fe <rpc_init_receive_section>
    data_to_send[0].data_location = (uint8 *)&rio;
    480e:	970a      	str	r7, [sp, #40]	; 0x28
    data_to_send[1].data_length = sizeof(mv);
    4810:	2702      	movs	r7, #2
    data_to_send[0].data_location = (uint8 *)&rio;
    4812:	ad0a      	add	r5, sp, #40	; 0x28
    data_to_send[1].data_location = (uint8 *)&mv;
    4814:	ab03      	add	r3, sp, #12
    RPC_ERR rpc_return = rpc_command_claim(CORES_PROTOCOL_CORE);
    4816:	0020      	movs	r0, r4
    data_to_send[0].data_length = sizeof(rio);
    4818:	80ac      	strh	r4, [r5, #4]
    data_to_send[1].data_location = (uint8 *)&mv;
    481a:	930c      	str	r3, [sp, #48]	; 0x30
    data_to_send[1].data_length = sizeof(mv);
    481c:	81af      	strh	r7, [r5, #12]
    RPC_ERR rpc_return = rpc_command_claim(CORES_PROTOCOL_CORE);
    481e:	f7fd fe1d 	bl	245c <rpc_command_claim>
    if (rpc_return != RPC_ERR_OK)
    4822:	2800      	cmp	r0, #0
    4824:	d110      	bne.n	4848 <command_radio_config_set_rio_v+0x5e>
    set_receive_info(CORES_PROTOCOL_CORE, &info);
    4826:	0031      	movs	r1, r6
    4828:	0020      	movs	r0, r4
    482a:	f7fd fab9 	bl	1da0 <set_receive_info>
    rpc_interface_scatter_send(CORES_PROTOCOL_CORE, RPC_APPLICATION_TO_PROTOCOL_RADIO_CONFIG_SET_RIO_V, true, 2, data_to_send);
    482e:	003b      	movs	r3, r7
    4830:	0022      	movs	r2, r4
    4832:	2132      	movs	r1, #50	; 0x32
    4834:	0020      	movs	r0, r4
    4836:	9500      	str	r5, [sp, #0]
    4838:	f7fd fd62 	bl	2300 <rpc_interface_scatter_send>
    rpc_blocking_loop(CORES_PROTOCOL_CORE);
    483c:	0020      	movs	r0, r4
    483e:	f7fd fde3 	bl	2408 <rpc_blocking_loop>
    return rpc_command_release(CORES_PROTOCOL_CORE);
    4842:	0020      	movs	r0, r4
    4844:	f7fd fdf6 	bl	2434 <rpc_command_release>
}
    4848:	b00f      	add	sp, #60	; 0x3c
    484a:	bdf0      	pop	{r4, r5, r6, r7, pc}

0000484c <command_radio_config_set_gpio>:
{
    484c:	b570      	push	{r4, r5, r6, lr}
    info.num_sections = 1;
    484e:	2401      	movs	r4, #1
{
    4850:	b08c      	sub	sp, #48	; 0x30
    4852:	9002      	str	r0, [sp, #8]
    4854:	9103      	str	r1, [sp, #12]
    rpc_init_receive_section(&get_sections[0], (uint8 *)result, sizeof(uint8), NULL);
    4856:	2300      	movs	r3, #0
    info.sections = get_sections;
    4858:	a809      	add	r0, sp, #36	; 0x24
{
    485a:	0011      	movs	r1, r2
    info.num_sections = 1;
    485c:	ae05      	add	r6, sp, #20
    rpc_init_receive_section(&get_sections[0], (uint8 *)result, sizeof(uint8), NULL);
    485e:	0022      	movs	r2, r4
    info.sections = get_sections;
    4860:	9005      	str	r0, [sp, #20]
    info.num_sections = 1;
    4862:	7134      	strb	r4, [r6, #4]
    rpc_init_receive_section(&get_sections[0], (uint8 *)result, sizeof(uint8), NULL);
    4864:	f7fd fdcb 	bl	23fe <rpc_init_receive_section>
    data_to_send[0].data_location = (uint8 *)&pio;
    4868:	ab02      	add	r3, sp, #8
    486a:	9307      	str	r3, [sp, #28]
    data_to_send[0].data_length = sizeof(pio);
    486c:	2308      	movs	r3, #8
    data_to_send[0].data_location = (uint8 *)&pio;
    486e:	ad07      	add	r5, sp, #28
    RPC_ERR rpc_return = rpc_command_claim(CORES_PROTOCOL_CORE);
    4870:	0020      	movs	r0, r4
    data_to_send[0].data_length = sizeof(pio);
    4872:	80ab      	strh	r3, [r5, #4]
    RPC_ERR rpc_return = rpc_command_claim(CORES_PROTOCOL_CORE);
    4874:	f7fd fdf2 	bl	245c <rpc_command_claim>
    if (rpc_return != RPC_ERR_OK)
    4878:	2800      	cmp	r0, #0
    487a:	d110      	bne.n	489e <command_radio_config_set_gpio+0x52>
    set_receive_info(CORES_PROTOCOL_CORE, &info);
    487c:	0031      	movs	r1, r6
    487e:	0020      	movs	r0, r4
    4880:	f7fd fa8e 	bl	1da0 <set_receive_info>
    rpc_interface_scatter_send(CORES_PROTOCOL_CORE, RPC_APPLICATION_TO_PROTOCOL_RADIO_CONFIG_SET_GPIO, true, 1, data_to_send);
    4884:	0023      	movs	r3, r4
    4886:	0022      	movs	r2, r4
    4888:	2133      	movs	r1, #51	; 0x33
    488a:	0020      	movs	r0, r4
    488c:	9500      	str	r5, [sp, #0]
    488e:	f7fd fd37 	bl	2300 <rpc_interface_scatter_send>
    rpc_blocking_loop(CORES_PROTOCOL_CORE);
    4892:	0020      	movs	r0, r4
    4894:	f7fd fdb8 	bl	2408 <rpc_blocking_loop>
    return rpc_command_release(CORES_PROTOCOL_CORE);
    4898:	0020      	movs	r0, r4
    489a:	f7fd fdcb 	bl	2434 <rpc_command_release>
}
    489e:	b00c      	add	sp, #48	; 0x30
    48a0:	bd70      	pop	{r4, r5, r6, pc}

000048a2 <command_radio_config_get_gpio>:
{
    48a2:	b570      	push	{r4, r5, r6, lr}
    info.num_sections = 2;
    48a4:	2302      	movs	r3, #2
{
    48a6:	0006      	movs	r6, r0
    48a8:	000c      	movs	r4, r1
    48aa:	b08a      	sub	sp, #40	; 0x28
    info.num_sections = 2;
    48ac:	ad02      	add	r5, sp, #8
    info.sections = get_sections;
    48ae:	a804      	add	r0, sp, #16
    info.num_sections = 2;
    48b0:	712b      	strb	r3, [r5, #4]
    rpc_init_receive_section(&get_sections[0], (uint8 *)ret_value, sizeof(uint8), NULL);
    48b2:	2201      	movs	r2, #1
    48b4:	2300      	movs	r3, #0
    48b6:	0031      	movs	r1, r6
    info.sections = get_sections;
    48b8:	9002      	str	r0, [sp, #8]
    rpc_init_receive_section(&get_sections[0], (uint8 *)ret_value, sizeof(uint8), NULL);
    48ba:	f7fd fda0 	bl	23fe <rpc_init_receive_section>
    rpc_init_receive_section(&get_sections[1], (uint8 *)pio, sizeof(uint64), NULL);
    48be:	0021      	movs	r1, r4
    48c0:	2300      	movs	r3, #0
    48c2:	2208      	movs	r2, #8
    48c4:	a807      	add	r0, sp, #28
    48c6:	f7fd fd9a 	bl	23fe <rpc_init_receive_section>
    RPC_ERR rpc_return = rpc_command_claim(CORES_PROTOCOL_CORE);
    48ca:	2001      	movs	r0, #1
    48cc:	f7fd fdc6 	bl	245c <rpc_command_claim>
    48d0:	1e04      	subs	r4, r0, #0
    if (rpc_return != RPC_ERR_OK)
    48d2:	d111      	bne.n	48f8 <command_radio_config_get_gpio+0x56>
    set_receive_info(CORES_PROTOCOL_CORE, &info);
    48d4:	0029      	movs	r1, r5
    48d6:	2001      	movs	r0, #1
    48d8:	f7fd fa62 	bl	1da0 <set_receive_info>
    rpc_interface_scatter_send(CORES_PROTOCOL_CORE, RPC_APPLICATION_TO_PROTOCOL_RADIO_CONFIG_GET_GPIO, true, 0, NULL);
    48dc:	2201      	movs	r2, #1
    48de:	0023      	movs	r3, r4
    48e0:	0010      	movs	r0, r2
    48e2:	2134      	movs	r1, #52	; 0x34
    48e4:	9400      	str	r4, [sp, #0]
    48e6:	f7fd fd0b 	bl	2300 <rpc_interface_scatter_send>
    rpc_blocking_loop(CORES_PROTOCOL_CORE);
    48ea:	2001      	movs	r0, #1
    48ec:	f7fd fd8c 	bl	2408 <rpc_blocking_loop>
    return rpc_command_release(CORES_PROTOCOL_CORE);
    48f0:	2001      	movs	r0, #1
    48f2:	f7fd fd9f 	bl	2434 <rpc_command_release>
    48f6:	0004      	movs	r4, r0
}
    48f8:	0020      	movs	r0, r4
    48fa:	b00a      	add	sp, #40	; 0x28
    48fc:	bd70      	pop	{r4, r5, r6, pc}

000048fe <command_prepare_for_powerdown>:
{
    48fe:	b507      	push	{r0, r1, r2, lr}
    RPC_ERR rpc_return = rpc_command_claim(CORES_PROTOCOL_CORE);
    4900:	2001      	movs	r0, #1
    4902:	f7fd fdab 	bl	245c <rpc_command_claim>
    if (rpc_return != RPC_ERR_OK)
    4906:	2800      	cmp	r0, #0
    4908:	d10c      	bne.n	4924 <command_prepare_for_powerdown+0x26>
    rpc_interface_scatter_send(CORES_PROTOCOL_CORE, RPC_APPLICATION_TO_PROTOCOL_PREPARE_FOR_POWERDOWN, true, 0, NULL);
    490a:	2201      	movs	r2, #1
    490c:	0003      	movs	r3, r0
    490e:	9000      	str	r0, [sp, #0]
    4910:	2136      	movs	r1, #54	; 0x36
    4912:	0010      	movs	r0, r2
    4914:	f7fd fcf4 	bl	2300 <rpc_interface_scatter_send>
    rpc_blocking_loop(CORES_PROTOCOL_CORE);
    4918:	2001      	movs	r0, #1
    491a:	f7fd fd75 	bl	2408 <rpc_blocking_loop>
    return rpc_command_release(CORES_PROTOCOL_CORE);
    491e:	2001      	movs	r0, #1
    4920:	f7fd fd88 	bl	2434 <rpc_command_release>
}
    4924:	bd0e      	pop	{r1, r2, r3, pc}

00004926 <command_pdp_activate_req>:
{
    4926:	b5f0      	push	{r4, r5, r6, r7, lr}
    4928:	270e      	movs	r7, #14
    info.num_sections = 1;
    492a:	2401      	movs	r4, #1
{
    492c:	b08d      	sub	sp, #52	; 0x34
    492e:	446f      	add	r7, sp
    4930:	8038      	strh	r0, [r7, #0]
    rpc_init_receive_section(&get_sections[0], (uint8 *)ret, sizeof(uint8), NULL);
    4932:	2300      	movs	r3, #0
    info.sections = get_sections;
    4934:	a809      	add	r0, sp, #36	; 0x24
    info.num_sections = 1;
    4936:	ae05      	add	r6, sp, #20
    rpc_init_receive_section(&get_sections[0], (uint8 *)ret, sizeof(uint8), NULL);
    4938:	0022      	movs	r2, r4
    info.sections = get_sections;
    493a:	9005      	str	r0, [sp, #20]
    info.num_sections = 1;
    493c:	7134      	strb	r4, [r6, #4]
    rpc_init_receive_section(&get_sections[0], (uint8 *)ret, sizeof(uint8), NULL);
    493e:	f7fd fd5e 	bl	23fe <rpc_init_receive_section>
    data_to_send[0].data_length = sizeof(cid);
    4942:	2302      	movs	r3, #2
    data_to_send[0].data_location = (uint8 *)&cid;
    4944:	ad07      	add	r5, sp, #28
    RPC_ERR rpc_return = rpc_command_claim(CORES_PROTOCOL_CORE);
    4946:	0020      	movs	r0, r4
    data_to_send[0].data_location = (uint8 *)&cid;
    4948:	9707      	str	r7, [sp, #28]
    data_to_send[0].data_length = sizeof(cid);
    494a:	80ab      	strh	r3, [r5, #4]
    RPC_ERR rpc_return = rpc_command_claim(CORES_PROTOCOL_CORE);
    494c:	f7fd fd86 	bl	245c <rpc_command_claim>
    if (rpc_return != RPC_ERR_OK)
    4950:	2800      	cmp	r0, #0
    4952:	d110      	bne.n	4976 <command_pdp_activate_req+0x50>
    set_receive_info(CORES_PROTOCOL_CORE, &info);
    4954:	0031      	movs	r1, r6
    4956:	0020      	movs	r0, r4
    4958:	f7fd fa22 	bl	1da0 <set_receive_info>
    rpc_interface_scatter_send(CORES_PROTOCOL_CORE, RPC_APPLICATION_TO_PROTOCOL_PDP_ACTIVATE_REQ, true, 1, data_to_send);
    495c:	0023      	movs	r3, r4
    495e:	0022      	movs	r2, r4
    4960:	2137      	movs	r1, #55	; 0x37
    4962:	0020      	movs	r0, r4
    4964:	9500      	str	r5, [sp, #0]
    4966:	f7fd fccb 	bl	2300 <rpc_interface_scatter_send>
    rpc_blocking_loop(CORES_PROTOCOL_CORE);
    496a:	0020      	movs	r0, r4
    496c:	f7fd fd4c 	bl	2408 <rpc_blocking_loop>
    return rpc_command_release(CORES_PROTOCOL_CORE);
    4970:	0020      	movs	r0, r4
    4972:	f7fd fd5f 	bl	2434 <rpc_command_release>
}
    4976:	b00d      	add	sp, #52	; 0x34
    4978:	bdf0      	pop	{r4, r5, r6, r7, pc}

0000497a <command_pdp_deactivate_req>:
{
    497a:	b5f0      	push	{r4, r5, r6, r7, lr}
    497c:	270e      	movs	r7, #14
    info.num_sections = 1;
    497e:	2401      	movs	r4, #1
{
    4980:	b08d      	sub	sp, #52	; 0x34
    4982:	446f      	add	r7, sp
    4984:	8038      	strh	r0, [r7, #0]
    rpc_init_receive_section(&get_sections[0], (uint8 *)ret, sizeof(uint8), NULL);
    4986:	2300      	movs	r3, #0
    info.sections = get_sections;
    4988:	a809      	add	r0, sp, #36	; 0x24
    info.num_sections = 1;
    498a:	ae05      	add	r6, sp, #20
    rpc_init_receive_section(&get_sections[0], (uint8 *)ret, sizeof(uint8), NULL);
    498c:	0022      	movs	r2, r4
    info.sections = get_sections;
    498e:	9005      	str	r0, [sp, #20]
    info.num_sections = 1;
    4990:	7134      	strb	r4, [r6, #4]
    rpc_init_receive_section(&get_sections[0], (uint8 *)ret, sizeof(uint8), NULL);
    4992:	f7fd fd34 	bl	23fe <rpc_init_receive_section>
    data_to_send[0].data_length = sizeof(cid);
    4996:	2302      	movs	r3, #2
    data_to_send[0].data_location = (uint8 *)&cid;
    4998:	ad07      	add	r5, sp, #28
    RPC_ERR rpc_return = rpc_command_claim(CORES_PROTOCOL_CORE);
    499a:	0020      	movs	r0, r4
    data_to_send[0].data_location = (uint8 *)&cid;
    499c:	9707      	str	r7, [sp, #28]
    data_to_send[0].data_length = sizeof(cid);
    499e:	80ab      	strh	r3, [r5, #4]
    RPC_ERR rpc_return = rpc_command_claim(CORES_PROTOCOL_CORE);
    49a0:	f7fd fd5c 	bl	245c <rpc_command_claim>
    if (rpc_return != RPC_ERR_OK)
    49a4:	2800      	cmp	r0, #0
    49a6:	d110      	bne.n	49ca <command_pdp_deactivate_req+0x50>
    set_receive_info(CORES_PROTOCOL_CORE, &info);
    49a8:	0031      	movs	r1, r6
    49aa:	0020      	movs	r0, r4
    49ac:	f7fd f9f8 	bl	1da0 <set_receive_info>
    rpc_interface_scatter_send(CORES_PROTOCOL_CORE, RPC_APPLICATION_TO_PROTOCOL_PDP_DEACTIVATE_REQ, true, 1, data_to_send);
    49b0:	0023      	movs	r3, r4
    49b2:	0022      	movs	r2, r4
    49b4:	2138      	movs	r1, #56	; 0x38
    49b6:	0020      	movs	r0, r4
    49b8:	9500      	str	r5, [sp, #0]
    49ba:	f7fd fca1 	bl	2300 <rpc_interface_scatter_send>
    rpc_blocking_loop(CORES_PROTOCOL_CORE);
    49be:	0020      	movs	r0, r4
    49c0:	f7fd fd22 	bl	2408 <rpc_blocking_loop>
    return rpc_command_release(CORES_PROTOCOL_CORE);
    49c4:	0020      	movs	r0, r4
    49c6:	f7fd fd35 	bl	2434 <rpc_command_release>
}
    49ca:	b00d      	add	sp, #52	; 0x34
    49cc:	bdf0      	pop	{r4, r5, r6, r7, pc}

000049ce <command_sms_set_short_message_service>:
{
    49ce:	b5f0      	push	{r4, r5, r6, r7, lr}
    49d0:	260e      	movs	r6, #14
    49d2:	001c      	movs	r4, r3
    info.num_sections = 4;
    49d4:	2304      	movs	r3, #4
{
    49d6:	0017      	movs	r7, r2
    49d8:	b095      	sub	sp, #84	; 0x54
    49da:	446e      	add	r6, sp
    info.num_sections = 4;
    49dc:	ad04      	add	r5, sp, #16
{
    49de:	8030      	strh	r0, [r6, #0]
    info.num_sections = 4;
    49e0:	712b      	strb	r3, [r5, #4]
    info.sections = get_sections;
    49e2:	a808      	add	r0, sp, #32
    rpc_init_receive_section(&get_sections[0], (uint8 *)state, sizeof(uint8), NULL);
    49e4:	2300      	movs	r3, #0
    49e6:	2201      	movs	r2, #1
    info.sections = get_sections;
    49e8:	9004      	str	r0, [sp, #16]
    rpc_init_receive_section(&get_sections[0], (uint8 *)state, sizeof(uint8), NULL);
    49ea:	f7fd fd08 	bl	23fe <rpc_init_receive_section>
    rpc_init_receive_section(&get_sections[1], (uint8 *)mt, sizeof(uint8), NULL);
    49ee:	2300      	movs	r3, #0
    49f0:	2201      	movs	r2, #1
    49f2:	0039      	movs	r1, r7
    49f4:	a80b      	add	r0, sp, #44	; 0x2c
    49f6:	f7fd fd02 	bl	23fe <rpc_init_receive_section>
    rpc_init_receive_section(&get_sections[2], (uint8 *)mo, sizeof(uint8), NULL);
    49fa:	0021      	movs	r1, r4
    49fc:	2300      	movs	r3, #0
    49fe:	2201      	movs	r2, #1
    4a00:	a80e      	add	r0, sp, #56	; 0x38
    4a02:	f7fd fcfc 	bl	23fe <rpc_init_receive_section>
    rpc_init_receive_section(&get_sections[3], (uint8 *)bm, sizeof(uint8), NULL);
    4a06:	2300      	movs	r3, #0
    4a08:	a811      	add	r0, sp, #68	; 0x44
    4a0a:	2201      	movs	r2, #1
    4a0c:	991a      	ldr	r1, [sp, #104]	; 0x68
    4a0e:	f7fd fcf6 	bl	23fe <rpc_init_receive_section>
    data_to_send[0].data_length = sizeof(service);
    4a12:	2302      	movs	r3, #2
    data_to_send[0].data_location = (uint8 *)&service;
    4a14:	ac06      	add	r4, sp, #24
    data_to_send[0].data_length = sizeof(service);
    4a16:	80a3      	strh	r3, [r4, #4]
    RPC_ERR rpc_return = rpc_command_claim(CORES_PROTOCOL_CORE);
    4a18:	2001      	movs	r0, #1
    data_to_send[0].data_location = (uint8 *)&service;
    4a1a:	9606      	str	r6, [sp, #24]
    RPC_ERR rpc_return = rpc_command_claim(CORES_PROTOCOL_CORE);
    4a1c:	f7fd fd1e 	bl	245c <rpc_command_claim>
    if (rpc_return != RPC_ERR_OK)
    4a20:	2800      	cmp	r0, #0
    4a22:	d110      	bne.n	4a46 <command_sms_set_short_message_service+0x78>
    set_receive_info(CORES_PROTOCOL_CORE, &info);
    4a24:	0029      	movs	r1, r5
    4a26:	3001      	adds	r0, #1
    4a28:	f7fd f9ba 	bl	1da0 <set_receive_info>
    rpc_interface_scatter_send(CORES_PROTOCOL_CORE, RPC_APPLICATION_TO_PROTOCOL_SMS_SET_SHORT_MESSAGE_SERVICE, true, 1, data_to_send);
    4a2c:	2301      	movs	r3, #1
    4a2e:	2139      	movs	r1, #57	; 0x39
    4a30:	0018      	movs	r0, r3
    4a32:	001a      	movs	r2, r3
    4a34:	9400      	str	r4, [sp, #0]
    4a36:	f7fd fc63 	bl	2300 <rpc_interface_scatter_send>
    rpc_blocking_loop(CORES_PROTOCOL_CORE);
    4a3a:	2001      	movs	r0, #1
    4a3c:	f7fd fce4 	bl	2408 <rpc_blocking_loop>
    return rpc_command_release(CORES_PROTOCOL_CORE);
    4a40:	2001      	movs	r0, #1
    4a42:	f7fd fcf7 	bl	2434 <rpc_command_release>
}
    4a46:	b015      	add	sp, #84	; 0x54
    4a48:	bdf0      	pop	{r4, r5, r6, r7, pc}

00004a4a <command_sms_read_short_message_service>:
{
    4a4a:	b5f0      	push	{r4, r5, r6, r7, lr}
    4a4c:	4684      	mov	ip, r0
    4a4e:	001c      	movs	r4, r3
    info.num_sections = 5;
    4a50:	2305      	movs	r3, #5
{
    4a52:	000f      	movs	r7, r1
    4a54:	0016      	movs	r6, r2
    4a56:	b095      	sub	sp, #84	; 0x54
    info.num_sections = 5;
    4a58:	ad03      	add	r5, sp, #12
    rpc_init_receive_section(&get_sections[0], (uint8 *)state, sizeof(uint8), NULL);
    4a5a:	4661      	mov	r1, ip
    info.sections = get_sections;
    4a5c:	a805      	add	r0, sp, #20
    info.num_sections = 5;
    4a5e:	712b      	strb	r3, [r5, #4]
    rpc_init_receive_section(&get_sections[0], (uint8 *)state, sizeof(uint8), NULL);
    4a60:	2201      	movs	r2, #1
    4a62:	2300      	movs	r3, #0
    info.sections = get_sections;
    4a64:	9003      	str	r0, [sp, #12]
    rpc_init_receive_section(&get_sections[0], (uint8 *)state, sizeof(uint8), NULL);
    4a66:	f7fd fcca 	bl	23fe <rpc_init_receive_section>
    rpc_init_receive_section(&get_sections[1], (uint8 *)service, sizeof(uint8), NULL);
    4a6a:	2300      	movs	r3, #0
    4a6c:	2201      	movs	r2, #1
    4a6e:	0039      	movs	r1, r7
    4a70:	a808      	add	r0, sp, #32
    4a72:	f7fd fcc4 	bl	23fe <rpc_init_receive_section>
    rpc_init_receive_section(&get_sections[2], (uint8 *)mt, sizeof(uint8), NULL);
    4a76:	2300      	movs	r3, #0
    4a78:	2201      	movs	r2, #1
    4a7a:	0031      	movs	r1, r6
    4a7c:	a80b      	add	r0, sp, #44	; 0x2c
    4a7e:	f7fd fcbe 	bl	23fe <rpc_init_receive_section>
    rpc_init_receive_section(&get_sections[3], (uint8 *)mo, sizeof(uint8), NULL);
    4a82:	0021      	movs	r1, r4
    4a84:	2300      	movs	r3, #0
    4a86:	2201      	movs	r2, #1
    4a88:	a80e      	add	r0, sp, #56	; 0x38
    4a8a:	f7fd fcb8 	bl	23fe <rpc_init_receive_section>
    rpc_init_receive_section(&get_sections[4], (uint8 *)bm, sizeof(uint8), NULL);
    4a8e:	2300      	movs	r3, #0
    4a90:	2201      	movs	r2, #1
    4a92:	991a      	ldr	r1, [sp, #104]	; 0x68
    4a94:	a811      	add	r0, sp, #68	; 0x44
    4a96:	f7fd fcb2 	bl	23fe <rpc_init_receive_section>
    RPC_ERR rpc_return = rpc_command_claim(CORES_PROTOCOL_CORE);
    4a9a:	2001      	movs	r0, #1
    4a9c:	f7fd fcde 	bl	245c <rpc_command_claim>
    4aa0:	1e04      	subs	r4, r0, #0
    if (rpc_return != RPC_ERR_OK)
    4aa2:	d111      	bne.n	4ac8 <command_sms_read_short_message_service+0x7e>
    set_receive_info(CORES_PROTOCOL_CORE, &info);
    4aa4:	0029      	movs	r1, r5
    4aa6:	2001      	movs	r0, #1
    4aa8:	f7fd f97a 	bl	1da0 <set_receive_info>
    rpc_interface_scatter_send(CORES_PROTOCOL_CORE, RPC_APPLICATION_TO_PROTOCOL_SMS_READ_SHORT_MESSAGE_SERVICE, true, 0, NULL);
    4aac:	2201      	movs	r2, #1
    4aae:	0023      	movs	r3, r4
    4ab0:	0010      	movs	r0, r2
    4ab2:	213a      	movs	r1, #58	; 0x3a
    4ab4:	9400      	str	r4, [sp, #0]
    4ab6:	f7fd fc23 	bl	2300 <rpc_interface_scatter_send>
    rpc_blocking_loop(CORES_PROTOCOL_CORE);
    4aba:	2001      	movs	r0, #1
    4abc:	f7fd fca4 	bl	2408 <rpc_blocking_loop>
    return rpc_command_release(CORES_PROTOCOL_CORE);
    4ac0:	2001      	movs	r0, #1
    4ac2:	f7fd fcb7 	bl	2434 <rpc_command_release>
    4ac6:	0004      	movs	r4, r0
}
    4ac8:	0020      	movs	r0, r4
    4aca:	b015      	add	sp, #84	; 0x54
    4acc:	bdf0      	pop	{r4, r5, r6, r7, pc}

00004ace <command_sms_set_more_message_to_send>:
{
    4ace:	b5f0      	push	{r4, r5, r6, r7, lr}
    4ad0:	270f      	movs	r7, #15
    info.num_sections = 1;
    4ad2:	2401      	movs	r4, #1
{
    4ad4:	b08d      	sub	sp, #52	; 0x34
    4ad6:	446f      	add	r7, sp
    4ad8:	7038      	strb	r0, [r7, #0]
    info.num_sections = 1;
    4ada:	ae05      	add	r6, sp, #20
    info.sections = get_sections;
    4adc:	a809      	add	r0, sp, #36	; 0x24
    rpc_init_receive_section(&get_sections[0], (uint8 *)state, sizeof(uint8), NULL);
    4ade:	2300      	movs	r3, #0
    4ae0:	0022      	movs	r2, r4
    info.sections = get_sections;
    4ae2:	9005      	str	r0, [sp, #20]
    info.num_sections = 1;
    4ae4:	7134      	strb	r4, [r6, #4]
    data_to_send[0].data_location = (uint8 *)&mode;
    4ae6:	ad07      	add	r5, sp, #28
    rpc_init_receive_section(&get_sections[0], (uint8 *)state, sizeof(uint8), NULL);
    4ae8:	f7fd fc89 	bl	23fe <rpc_init_receive_section>
    RPC_ERR rpc_return = rpc_command_claim(CORES_PROTOCOL_CORE);
    4aec:	0020      	movs	r0, r4
    data_to_send[0].data_location = (uint8 *)&mode;
    4aee:	9707      	str	r7, [sp, #28]
    data_to_send[0].data_length = sizeof(mode);
    4af0:	80ac      	strh	r4, [r5, #4]
    RPC_ERR rpc_return = rpc_command_claim(CORES_PROTOCOL_CORE);
    4af2:	f7fd fcb3 	bl	245c <rpc_command_claim>
    if (rpc_return != RPC_ERR_OK)
    4af6:	2800      	cmp	r0, #0
    4af8:	d110      	bne.n	4b1c <command_sms_set_more_message_to_send+0x4e>
    set_receive_info(CORES_PROTOCOL_CORE, &info);
    4afa:	0031      	movs	r1, r6
    4afc:	0020      	movs	r0, r4
    4afe:	f7fd f94f 	bl	1da0 <set_receive_info>
    rpc_interface_scatter_send(CORES_PROTOCOL_CORE, RPC_APPLICATION_TO_PROTOCOL_SMS_SET_MORE_MESSAGE_TO_SEND, true, 1, data_to_send);
    4b02:	0023      	movs	r3, r4
    4b04:	0022      	movs	r2, r4
    4b06:	213b      	movs	r1, #59	; 0x3b
    4b08:	0020      	movs	r0, r4
    4b0a:	9500      	str	r5, [sp, #0]
    4b0c:	f7fd fbf8 	bl	2300 <rpc_interface_scatter_send>
    rpc_blocking_loop(CORES_PROTOCOL_CORE);
    4b10:	0020      	movs	r0, r4
    4b12:	f7fd fc79 	bl	2408 <rpc_blocking_loop>
    return rpc_command_release(CORES_PROTOCOL_CORE);
    4b16:	0020      	movs	r0, r4
    4b18:	f7fd fc8c 	bl	2434 <rpc_command_release>
}
    4b1c:	b00d      	add	sp, #52	; 0x34
    4b1e:	bdf0      	pop	{r4, r5, r6, r7, pc}

00004b20 <command_sms_read_more_message_to_send>:
{
    4b20:	b570      	push	{r4, r5, r6, lr}
    info.num_sections = 2;
    4b22:	2302      	movs	r3, #2
{
    4b24:	0006      	movs	r6, r0
    4b26:	000c      	movs	r4, r1
    4b28:	b08a      	sub	sp, #40	; 0x28
    info.num_sections = 2;
    4b2a:	ad02      	add	r5, sp, #8
    info.sections = get_sections;
    4b2c:	a804      	add	r0, sp, #16
    info.num_sections = 2;
    4b2e:	712b      	strb	r3, [r5, #4]
    rpc_init_receive_section(&get_sections[0], (uint8 *)state, sizeof(uint8), NULL);
    4b30:	2201      	movs	r2, #1
    4b32:	2300      	movs	r3, #0
    4b34:	0031      	movs	r1, r6
    info.sections = get_sections;
    4b36:	9002      	str	r0, [sp, #8]
    rpc_init_receive_section(&get_sections[0], (uint8 *)state, sizeof(uint8), NULL);
    4b38:	f7fd fc61 	bl	23fe <rpc_init_receive_section>
    rpc_init_receive_section(&get_sections[1], (uint8 *)mode, sizeof(uint8), NULL);
    4b3c:	0021      	movs	r1, r4
    4b3e:	2300      	movs	r3, #0
    4b40:	2201      	movs	r2, #1
    4b42:	a807      	add	r0, sp, #28
    4b44:	f7fd fc5b 	bl	23fe <rpc_init_receive_section>
    RPC_ERR rpc_return = rpc_command_claim(CORES_PROTOCOL_CORE);
    4b48:	2001      	movs	r0, #1
    4b4a:	f7fd fc87 	bl	245c <rpc_command_claim>
    4b4e:	1e04      	subs	r4, r0, #0
    if (rpc_return != RPC_ERR_OK)
    4b50:	d111      	bne.n	4b76 <command_sms_read_more_message_to_send+0x56>
    set_receive_info(CORES_PROTOCOL_CORE, &info);
    4b52:	0029      	movs	r1, r5
    4b54:	2001      	movs	r0, #1
    4b56:	f7fd f923 	bl	1da0 <set_receive_info>
    rpc_interface_scatter_send(CORES_PROTOCOL_CORE, RPC_APPLICATION_TO_PROTOCOL_SMS_READ_MORE_MESSAGE_TO_SEND, true, 0, NULL);
    4b5a:	2201      	movs	r2, #1
    4b5c:	0023      	movs	r3, r4
    4b5e:	0010      	movs	r0, r2
    4b60:	213c      	movs	r1, #60	; 0x3c
    4b62:	9400      	str	r4, [sp, #0]
    4b64:	f7fd fbcc 	bl	2300 <rpc_interface_scatter_send>
    rpc_blocking_loop(CORES_PROTOCOL_CORE);
    4b68:	2001      	movs	r0, #1
    4b6a:	f7fd fc4d 	bl	2408 <rpc_blocking_loop>
    return rpc_command_release(CORES_PROTOCOL_CORE);
    4b6e:	2001      	movs	r0, #1
    4b70:	f7fd fc60 	bl	2434 <rpc_command_release>
    4b74:	0004      	movs	r4, r0
}
    4b76:	0020      	movs	r0, r4
    4b78:	b00a      	add	sp, #40	; 0x28
    4b7a:	bd70      	pop	{r4, r5, r6, pc}

00004b7c <command_sms_set_short_message_service_address>:
{
    4b7c:	b5f0      	push	{r4, r5, r6, r7, lr}
    4b7e:	000c      	movs	r4, r1
    4b80:	b091      	sub	sp, #68	; 0x44
    4b82:	ae03      	add	r6, sp, #12
    4b84:	0019      	movs	r1, r3
    4b86:	8034      	strh	r4, [r6, #0]
    4b88:	466b      	mov	r3, sp
    info.num_sections = 1;
    4b8a:	2401      	movs	r4, #1
{
    4b8c:	73d8      	strb	r0, [r3, #15]
    4b8e:	9202      	str	r2, [sp, #8]
    info.sections = get_sections;
    4b90:	a807      	add	r0, sp, #28
    rpc_init_receive_section(&get_sections[0], (uint8 *)state, sizeof(uint8), NULL);
    4b92:	2300      	movs	r3, #0
    info.num_sections = 1;
    4b94:	af05      	add	r7, sp, #20
    rpc_init_receive_section(&get_sections[0], (uint8 *)state, sizeof(uint8), NULL);
    4b96:	0022      	movs	r2, r4
    info.sections = get_sections;
    4b98:	9005      	str	r0, [sp, #20]
    info.num_sections = 1;
    4b9a:	713c      	strb	r4, [r7, #4]
    rpc_init_receive_section(&get_sections[0], (uint8 *)state, sizeof(uint8), NULL);
    4b9c:	f7fd fc2f 	bl	23fe <rpc_init_receive_section>
    data_to_send[0].data_location = (uint8 *)&type;
    4ba0:	230f      	movs	r3, #15
    4ba2:	446b      	add	r3, sp
    4ba4:	930a      	str	r3, [sp, #40]	; 0x28
    data_to_send[1].data_length = sizeof(address_length);
    4ba6:	2302      	movs	r3, #2
    data_to_send[0].data_location = (uint8 *)&type;
    4ba8:	ad0a      	add	r5, sp, #40	; 0x28
    data_to_send[1].data_length = sizeof(address_length);
    4baa:	81ab      	strh	r3, [r5, #12]
    data_to_send[2].data_location = (uint8 *)address;
    4bac:	9b02      	ldr	r3, [sp, #8]
    RPC_ERR rpc_return = rpc_command_claim(CORES_PROTOCOL_CORE);
    4bae:	0020      	movs	r0, r4
    data_to_send[2].data_location = (uint8 *)address;
    4bb0:	930e      	str	r3, [sp, #56]	; 0x38
    data_to_send[2].data_length = address_length;
    4bb2:	8833      	ldrh	r3, [r6, #0]
    data_to_send[0].data_length = sizeof(type);
    4bb4:	80ac      	strh	r4, [r5, #4]
    data_to_send[1].data_location = (uint8 *)&address_length;
    4bb6:	960c      	str	r6, [sp, #48]	; 0x30
    data_to_send[2].data_length = address_length;
    4bb8:	82ab      	strh	r3, [r5, #20]
    RPC_ERR rpc_return = rpc_command_claim(CORES_PROTOCOL_CORE);
    4bba:	f7fd fc4f 	bl	245c <rpc_command_claim>
    if (rpc_return != RPC_ERR_OK)
    4bbe:	2800      	cmp	r0, #0
    4bc0:	d110      	bne.n	4be4 <command_sms_set_short_message_service_address+0x68>
    set_receive_info(CORES_PROTOCOL_CORE, &info);
    4bc2:	0039      	movs	r1, r7
    4bc4:	0020      	movs	r0, r4
    4bc6:	f7fd f8eb 	bl	1da0 <set_receive_info>
    rpc_interface_scatter_send(CORES_PROTOCOL_CORE, RPC_APPLICATION_TO_PROTOCOL_SMS_SET_SHORT_MESSAGE_SERVICE_ADDRESS, true, 3, data_to_send);
    4bca:	2303      	movs	r3, #3
    4bcc:	0022      	movs	r2, r4
    4bce:	213d      	movs	r1, #61	; 0x3d
    4bd0:	0020      	movs	r0, r4
    4bd2:	9500      	str	r5, [sp, #0]
    4bd4:	f7fd fb94 	bl	2300 <rpc_interface_scatter_send>
    rpc_blocking_loop(CORES_PROTOCOL_CORE);
    4bd8:	0020      	movs	r0, r4
    4bda:	f7fd fc15 	bl	2408 <rpc_blocking_loop>
    return rpc_command_release(CORES_PROTOCOL_CORE);
    4bde:	0020      	movs	r0, r4
    4be0:	f7fd fc28 	bl	2434 <rpc_command_release>
}
    4be4:	b011      	add	sp, #68	; 0x44
    4be6:	bdf0      	pop	{r4, r5, r6, r7, pc}

00004be8 <command_sms_read_short_message_service_address>:
{
    4be8:	b5f0      	push	{r4, r5, r6, r7, lr}
    4bea:	4684      	mov	ip, r0
    4bec:	001e      	movs	r6, r3
    info.num_sections = 3;
    4bee:	2303      	movs	r3, #3
{
    4bf0:	000f      	movs	r7, r1
    4bf2:	0014      	movs	r4, r2
    4bf4:	b08f      	sub	sp, #60	; 0x3c
    info.num_sections = 3;
    4bf6:	ad03      	add	r5, sp, #12
    rpc_init_receive_section(&get_sections[0], (uint8 *)state, sizeof(uint8), NULL);
    4bf8:	4661      	mov	r1, ip
    info.sections = get_sections;
    4bfa:	a805      	add	r0, sp, #20
    info.num_sections = 3;
    4bfc:	712b      	strb	r3, [r5, #4]
    rpc_init_receive_section(&get_sections[0], (uint8 *)state, sizeof(uint8), NULL);
    4bfe:	2201      	movs	r2, #1
    4c00:	2300      	movs	r3, #0
    info.sections = get_sections;
    4c02:	9003      	str	r0, [sp, #12]
    rpc_init_receive_section(&get_sections[0], (uint8 *)state, sizeof(uint8), NULL);
    4c04:	f7fd fbfb 	bl	23fe <rpc_init_receive_section>
    rpc_init_receive_section(&get_sections[1], (uint8 *)type, sizeof(uint8), NULL);
    4c08:	2300      	movs	r3, #0
    4c0a:	2201      	movs	r2, #1
    4c0c:	0039      	movs	r1, r7
    4c0e:	a808      	add	r0, sp, #32
    4c10:	f7fd fbf5 	bl	23fe <rpc_init_receive_section>
    rpc_init_receive_section(&get_sections[2], (uint8 *)address, address_max_length, address_length);
    4c14:	0022      	movs	r2, r4
    4c16:	0033      	movs	r3, r6
    4c18:	9914      	ldr	r1, [sp, #80]	; 0x50
    4c1a:	a80b      	add	r0, sp, #44	; 0x2c
    4c1c:	f7fd fbef 	bl	23fe <rpc_init_receive_section>
    RPC_ERR rpc_return = rpc_command_claim(CORES_PROTOCOL_CORE);
    4c20:	2001      	movs	r0, #1
    4c22:	f7fd fc1b 	bl	245c <rpc_command_claim>
    4c26:	1e04      	subs	r4, r0, #0
    if (rpc_return != RPC_ERR_OK)
    4c28:	d111      	bne.n	4c4e <command_sms_read_short_message_service_address+0x66>
    set_receive_info(CORES_PROTOCOL_CORE, &info);
    4c2a:	0029      	movs	r1, r5
    4c2c:	2001      	movs	r0, #1
    4c2e:	f7fd f8b7 	bl	1da0 <set_receive_info>
    rpc_interface_scatter_send(CORES_PROTOCOL_CORE, RPC_APPLICATION_TO_PROTOCOL_SMS_READ_SHORT_MESSAGE_SERVICE_ADDRESS, true, 0, NULL);
    4c32:	2201      	movs	r2, #1
    4c34:	0023      	movs	r3, r4
    4c36:	0010      	movs	r0, r2
    4c38:	213e      	movs	r1, #62	; 0x3e
    4c3a:	9400      	str	r4, [sp, #0]
    4c3c:	f7fd fb60 	bl	2300 <rpc_interface_scatter_send>
    rpc_blocking_loop(CORES_PROTOCOL_CORE);
    4c40:	2001      	movs	r0, #1
    4c42:	f7fd fbe1 	bl	2408 <rpc_blocking_loop>
    return rpc_command_release(CORES_PROTOCOL_CORE);
    4c46:	2001      	movs	r0, #1
    4c48:	f7fd fbf4 	bl	2434 <rpc_command_release>
    4c4c:	0004      	movs	r4, r0
}
    4c4e:	0020      	movs	r0, r4
    4c50:	b00f      	add	sp, #60	; 0x3c
    4c52:	bdf0      	pop	{r4, r5, r6, r7, pc}

00004c54 <command_sms_send_short_message>:
{
    4c54:	b5f0      	push	{r4, r5, r6, r7, lr}
    4c56:	000c      	movs	r4, r1
    4c58:	b091      	sub	sp, #68	; 0x44
    4c5a:	ae03      	add	r6, sp, #12
    4c5c:	0019      	movs	r1, r3
    4c5e:	8034      	strh	r4, [r6, #0]
    4c60:	466b      	mov	r3, sp
    info.num_sections = 1;
    4c62:	2401      	movs	r4, #1
{
    4c64:	73d8      	strb	r0, [r3, #15]
    4c66:	9202      	str	r2, [sp, #8]
    info.sections = get_sections;
    4c68:	a807      	add	r0, sp, #28
    rpc_init_receive_section(&get_sections[0], (uint8 *)state, sizeof(uint8), NULL);
    4c6a:	2300      	movs	r3, #0
    info.num_sections = 1;
    4c6c:	af05      	add	r7, sp, #20
    rpc_init_receive_section(&get_sections[0], (uint8 *)state, sizeof(uint8), NULL);
    4c6e:	0022      	movs	r2, r4
    info.sections = get_sections;
    4c70:	9005      	str	r0, [sp, #20]
    info.num_sections = 1;
    4c72:	713c      	strb	r4, [r7, #4]
    rpc_init_receive_section(&get_sections[0], (uint8 *)state, sizeof(uint8), NULL);
    4c74:	f7fd fbc3 	bl	23fe <rpc_init_receive_section>
    data_to_send[0].data_location = (uint8 *)&data_len;
    4c78:	230f      	movs	r3, #15
    4c7a:	446b      	add	r3, sp
    4c7c:	930a      	str	r3, [sp, #40]	; 0x28
    data_to_send[1].data_length = sizeof(tpdu_length);
    4c7e:	2302      	movs	r3, #2
    data_to_send[0].data_location = (uint8 *)&data_len;
    4c80:	ad0a      	add	r5, sp, #40	; 0x28
    data_to_send[1].data_length = sizeof(tpdu_length);
    4c82:	81ab      	strh	r3, [r5, #12]
    data_to_send[2].data_location = (uint8 *)tpdu;
    4c84:	9b02      	ldr	r3, [sp, #8]
    RPC_ERR rpc_return = rpc_command_claim(CORES_PROTOCOL_CORE);
    4c86:	0020      	movs	r0, r4
    data_to_send[2].data_location = (uint8 *)tpdu;
    4c88:	930e      	str	r3, [sp, #56]	; 0x38
    data_to_send[2].data_length = tpdu_length;
    4c8a:	8833      	ldrh	r3, [r6, #0]
    data_to_send[0].data_length = sizeof(data_len);
    4c8c:	80ac      	strh	r4, [r5, #4]
    data_to_send[1].data_location = (uint8 *)&tpdu_length;
    4c8e:	960c      	str	r6, [sp, #48]	; 0x30
    data_to_send[2].data_length = tpdu_length;
    4c90:	82ab      	strh	r3, [r5, #20]
    RPC_ERR rpc_return = rpc_command_claim(CORES_PROTOCOL_CORE);
    4c92:	f7fd fbe3 	bl	245c <rpc_command_claim>
    if (rpc_return != RPC_ERR_OK)
    4c96:	2800      	cmp	r0, #0
    4c98:	d110      	bne.n	4cbc <command_sms_send_short_message+0x68>
    set_receive_info(CORES_PROTOCOL_CORE, &info);
    4c9a:	0039      	movs	r1, r7
    4c9c:	0020      	movs	r0, r4
    4c9e:	f7fd f87f 	bl	1da0 <set_receive_info>
    rpc_interface_scatter_send(CORES_PROTOCOL_CORE, RPC_APPLICATION_TO_PROTOCOL_SMS_SEND_SHORT_MESSAGE, true, 3, data_to_send);
    4ca2:	2303      	movs	r3, #3
    4ca4:	0022      	movs	r2, r4
    4ca6:	213f      	movs	r1, #63	; 0x3f
    4ca8:	0020      	movs	r0, r4
    4caa:	9500      	str	r5, [sp, #0]
    4cac:	f7fd fb28 	bl	2300 <rpc_interface_scatter_send>
    rpc_blocking_loop(CORES_PROTOCOL_CORE);
    4cb0:	0020      	movs	r0, r4
    4cb2:	f7fd fba9 	bl	2408 <rpc_blocking_loop>
    return rpc_command_release(CORES_PROTOCOL_CORE);
    4cb6:	0020      	movs	r0, r4
    4cb8:	f7fd fbbc 	bl	2434 <rpc_command_release>
}
    4cbc:	b011      	add	sp, #68	; 0x44
    4cbe:	bdf0      	pop	{r4, r5, r6, r7, pc}

00004cc0 <command_sms_send_command>:
{
    4cc0:	b5f0      	push	{r4, r5, r6, r7, lr}
    4cc2:	000c      	movs	r4, r1
    4cc4:	b091      	sub	sp, #68	; 0x44
    4cc6:	ae03      	add	r6, sp, #12
    4cc8:	0019      	movs	r1, r3
    4cca:	8034      	strh	r4, [r6, #0]
    4ccc:	466b      	mov	r3, sp
    info.num_sections = 1;
    4cce:	2401      	movs	r4, #1
{
    4cd0:	73d8      	strb	r0, [r3, #15]
    4cd2:	9202      	str	r2, [sp, #8]
    info.sections = get_sections;
    4cd4:	a807      	add	r0, sp, #28
    rpc_init_receive_section(&get_sections[0], (uint8 *)state, sizeof(uint8), NULL);
    4cd6:	2300      	movs	r3, #0
    info.num_sections = 1;
    4cd8:	af05      	add	r7, sp, #20
    rpc_init_receive_section(&get_sections[0], (uint8 *)state, sizeof(uint8), NULL);
    4cda:	0022      	movs	r2, r4
    info.sections = get_sections;
    4cdc:	9005      	str	r0, [sp, #20]
    info.num_sections = 1;
    4cde:	713c      	strb	r4, [r7, #4]
    rpc_init_receive_section(&get_sections[0], (uint8 *)state, sizeof(uint8), NULL);
    4ce0:	f7fd fb8d 	bl	23fe <rpc_init_receive_section>
    data_to_send[0].data_location = (uint8 *)&data_len;
    4ce4:	230f      	movs	r3, #15
    4ce6:	446b      	add	r3, sp
    4ce8:	930a      	str	r3, [sp, #40]	; 0x28
    data_to_send[1].data_length = sizeof(tpdu_length);
    4cea:	2302      	movs	r3, #2
    data_to_send[0].data_location = (uint8 *)&data_len;
    4cec:	ad0a      	add	r5, sp, #40	; 0x28
    data_to_send[1].data_length = sizeof(tpdu_length);
    4cee:	81ab      	strh	r3, [r5, #12]
    data_to_send[2].data_location = (uint8 *)tpdu;
    4cf0:	9b02      	ldr	r3, [sp, #8]
    RPC_ERR rpc_return = rpc_command_claim(CORES_PROTOCOL_CORE);
    4cf2:	0020      	movs	r0, r4
    data_to_send[2].data_location = (uint8 *)tpdu;
    4cf4:	930e      	str	r3, [sp, #56]	; 0x38
    data_to_send[2].data_length = tpdu_length;
    4cf6:	8833      	ldrh	r3, [r6, #0]
    data_to_send[0].data_length = sizeof(data_len);
    4cf8:	80ac      	strh	r4, [r5, #4]
    data_to_send[1].data_location = (uint8 *)&tpdu_length;
    4cfa:	960c      	str	r6, [sp, #48]	; 0x30
    data_to_send[2].data_length = tpdu_length;
    4cfc:	82ab      	strh	r3, [r5, #20]
    RPC_ERR rpc_return = rpc_command_claim(CORES_PROTOCOL_CORE);
    4cfe:	f7fd fbad 	bl	245c <rpc_command_claim>
    if (rpc_return != RPC_ERR_OK)
    4d02:	2800      	cmp	r0, #0
    4d04:	d110      	bne.n	4d28 <command_sms_send_command+0x68>
    set_receive_info(CORES_PROTOCOL_CORE, &info);
    4d06:	0039      	movs	r1, r7
    4d08:	0020      	movs	r0, r4
    4d0a:	f7fd f849 	bl	1da0 <set_receive_info>
    rpc_interface_scatter_send(CORES_PROTOCOL_CORE, RPC_APPLICATION_TO_PROTOCOL_SMS_SEND_COMMAND, true, 3, data_to_send);
    4d0e:	2303      	movs	r3, #3
    4d10:	0022      	movs	r2, r4
    4d12:	2140      	movs	r1, #64	; 0x40
    4d14:	0020      	movs	r0, r4
    4d16:	9500      	str	r5, [sp, #0]
    4d18:	f7fd faf2 	bl	2300 <rpc_interface_scatter_send>
    rpc_blocking_loop(CORES_PROTOCOL_CORE);
    4d1c:	0020      	movs	r0, r4
    4d1e:	f7fd fb73 	bl	2408 <rpc_blocking_loop>
    return rpc_command_release(CORES_PROTOCOL_CORE);
    4d22:	0020      	movs	r0, r4
    4d24:	f7fd fb86 	bl	2434 <rpc_command_release>
}
    4d28:	b011      	add	sp, #68	; 0x44
    4d2a:	bdf0      	pop	{r4, r5, r6, r7, pc}

00004d2c <command_sms_set_new_msg_ack>:
{
    4d2c:	b5f0      	push	{r4, r5, r6, r7, lr}
    4d2e:	000c      	movs	r4, r1
    4d30:	b091      	sub	sp, #68	; 0x44
    4d32:	ae03      	add	r6, sp, #12
    4d34:	0019      	movs	r1, r3
    4d36:	8034      	strh	r4, [r6, #0]
    4d38:	466b      	mov	r3, sp
    info.num_sections = 1;
    4d3a:	2401      	movs	r4, #1
{
    4d3c:	73d8      	strb	r0, [r3, #15]
    4d3e:	9202      	str	r2, [sp, #8]
    info.sections = get_sections;
    4d40:	a807      	add	r0, sp, #28
    rpc_init_receive_section(&get_sections[0], (uint8 *)state, sizeof(uint8), NULL);
    4d42:	2300      	movs	r3, #0
    info.num_sections = 1;
    4d44:	af05      	add	r7, sp, #20
    rpc_init_receive_section(&get_sections[0], (uint8 *)state, sizeof(uint8), NULL);
    4d46:	0022      	movs	r2, r4
    info.sections = get_sections;
    4d48:	9005      	str	r0, [sp, #20]
    info.num_sections = 1;
    4d4a:	713c      	strb	r4, [r7, #4]
    rpc_init_receive_section(&get_sections[0], (uint8 *)state, sizeof(uint8), NULL);
    4d4c:	f7fd fb57 	bl	23fe <rpc_init_receive_section>
    data_to_send[0].data_location = (uint8 *)&report_type;
    4d50:	230f      	movs	r3, #15
    4d52:	446b      	add	r3, sp
    4d54:	930a      	str	r3, [sp, #40]	; 0x28
    data_to_send[1].data_length = sizeof(tpdu_length);
    4d56:	2302      	movs	r3, #2
    data_to_send[0].data_location = (uint8 *)&report_type;
    4d58:	ad0a      	add	r5, sp, #40	; 0x28
    data_to_send[1].data_length = sizeof(tpdu_length);
    4d5a:	81ab      	strh	r3, [r5, #12]
    data_to_send[2].data_location = (uint8 *)tpdu;
    4d5c:	9b02      	ldr	r3, [sp, #8]
    RPC_ERR rpc_return = rpc_command_claim(CORES_PROTOCOL_CORE);
    4d5e:	0020      	movs	r0, r4
    data_to_send[2].data_location = (uint8 *)tpdu;
    4d60:	930e      	str	r3, [sp, #56]	; 0x38
    data_to_send[2].data_length = tpdu_length;
    4d62:	8833      	ldrh	r3, [r6, #0]
    data_to_send[0].data_length = sizeof(report_type);
    4d64:	80ac      	strh	r4, [r5, #4]
    data_to_send[1].data_location = (uint8 *)&tpdu_length;
    4d66:	960c      	str	r6, [sp, #48]	; 0x30
    data_to_send[2].data_length = tpdu_length;
    4d68:	82ab      	strh	r3, [r5, #20]
    RPC_ERR rpc_return = rpc_command_claim(CORES_PROTOCOL_CORE);
    4d6a:	f7fd fb77 	bl	245c <rpc_command_claim>
    if (rpc_return != RPC_ERR_OK)
    4d6e:	2800      	cmp	r0, #0
    4d70:	d110      	bne.n	4d94 <command_sms_set_new_msg_ack+0x68>
    set_receive_info(CORES_PROTOCOL_CORE, &info);
    4d72:	0039      	movs	r1, r7
    4d74:	0020      	movs	r0, r4
    4d76:	f7fd f813 	bl	1da0 <set_receive_info>
    rpc_interface_scatter_send(CORES_PROTOCOL_CORE, RPC_APPLICATION_TO_PROTOCOL_SMS_SET_NEW_MSG_ACK, true, 3, data_to_send);
    4d7a:	2303      	movs	r3, #3
    4d7c:	0022      	movs	r2, r4
    4d7e:	2141      	movs	r1, #65	; 0x41
    4d80:	0020      	movs	r0, r4
    4d82:	9500      	str	r5, [sp, #0]
    4d84:	f7fd fabc 	bl	2300 <rpc_interface_scatter_send>
    rpc_blocking_loop(CORES_PROTOCOL_CORE);
    4d88:	0020      	movs	r0, r4
    4d8a:	f7fd fb3d 	bl	2408 <rpc_blocking_loop>
    return rpc_command_release(CORES_PROTOCOL_CORE);
    4d8e:	0020      	movs	r0, r4
    4d90:	f7fd fb50 	bl	2434 <rpc_command_release>
}
    4d94:	b011      	add	sp, #68	; 0x44
    4d96:	bdf0      	pop	{r4, r5, r6, r7, pc}

00004d98 <command_get_cnma_acknowledgement_expected>:
{
    4d98:	b570      	push	{r4, r5, r6, lr}
    info.num_sections = 1;
    4d9a:	2401      	movs	r4, #1
{
    4d9c:	b088      	sub	sp, #32
    4d9e:	0001      	movs	r1, r0
    rpc_init_receive_section(&get_sections[0], (uint8 *)result, sizeof(uint8), NULL);
    4da0:	2300      	movs	r3, #0
    info.sections = get_sections;
    4da2:	a805      	add	r0, sp, #20
    rpc_init_receive_section(&get_sections[0], (uint8 *)result, sizeof(uint8), NULL);
    4da4:	0022      	movs	r2, r4
    info.num_sections = 1;
    4da6:	ae03      	add	r6, sp, #12
    info.sections = get_sections;
    4da8:	9003      	str	r0, [sp, #12]
    info.num_sections = 1;
    4daa:	7134      	strb	r4, [r6, #4]
    rpc_init_receive_section(&get_sections[0], (uint8 *)result, sizeof(uint8), NULL);
    4dac:	f7fd fb27 	bl	23fe <rpc_init_receive_section>
    RPC_ERR rpc_return = rpc_command_claim(CORES_PROTOCOL_CORE);
    4db0:	0020      	movs	r0, r4
    4db2:	f7fd fb53 	bl	245c <rpc_command_claim>
    4db6:	1e05      	subs	r5, r0, #0
    if (rpc_return != RPC_ERR_OK)
    4db8:	d111      	bne.n	4dde <command_get_cnma_acknowledgement_expected+0x46>
    set_receive_info(CORES_PROTOCOL_CORE, &info);
    4dba:	0031      	movs	r1, r6
    4dbc:	0020      	movs	r0, r4
    4dbe:	f7fc ffef 	bl	1da0 <set_receive_info>
    rpc_interface_scatter_send(CORES_PROTOCOL_CORE, RPC_APPLICATION_TO_PROTOCOL_GET_CNMA_ACKNOWLEDGEMENT_EXPECTED, true, 0, NULL);
    4dc2:	002b      	movs	r3, r5
    4dc4:	0022      	movs	r2, r4
    4dc6:	2142      	movs	r1, #66	; 0x42
    4dc8:	9500      	str	r5, [sp, #0]
    4dca:	0020      	movs	r0, r4
    4dcc:	f7fd fa98 	bl	2300 <rpc_interface_scatter_send>
    rpc_blocking_loop(CORES_PROTOCOL_CORE);
    4dd0:	0020      	movs	r0, r4
    4dd2:	f7fd fb19 	bl	2408 <rpc_blocking_loop>
    return rpc_command_release(CORES_PROTOCOL_CORE);
    4dd6:	0020      	movs	r0, r4
    4dd8:	f7fd fb2c 	bl	2434 <rpc_command_release>
    4ddc:	0005      	movs	r5, r0
}
    4dde:	0028      	movs	r0, r5
    4de0:	b008      	add	sp, #32
    4de2:	bd70      	pop	{r4, r5, r6, pc}

00004de4 <command_get_iccid>:
{
    4de4:	b5f0      	push	{r4, r5, r6, r7, lr}
    4de6:	001c      	movs	r4, r3
    4de8:	0006      	movs	r6, r0
    4dea:	000f      	movs	r7, r1
    info.num_sections = 2;
    4dec:	2302      	movs	r3, #2
{
    4dee:	b08b      	sub	sp, #44	; 0x2c
    info.num_sections = 2;
    4df0:	ad02      	add	r5, sp, #8
{
    4df2:	0011      	movs	r1, r2
    info.sections = get_sections;
    4df4:	a804      	add	r0, sp, #16
    info.num_sections = 2;
    4df6:	712b      	strb	r3, [r5, #4]
    rpc_init_receive_section(&get_sections[0], (uint8 *)iccid, iccid_max_length, iccid_length);
    4df8:	0032      	movs	r2, r6
    4dfa:	003b      	movs	r3, r7
    info.sections = get_sections;
    4dfc:	9002      	str	r0, [sp, #8]
    rpc_init_receive_section(&get_sections[0], (uint8 *)iccid, iccid_max_length, iccid_length);
    4dfe:	f7fd fafe 	bl	23fe <rpc_init_receive_section>
    rpc_init_receive_section(&get_sections[1], (uint8 *)result, sizeof(uint8), NULL);
    4e02:	0021      	movs	r1, r4
    4e04:	2300      	movs	r3, #0
    4e06:	2201      	movs	r2, #1
    4e08:	a807      	add	r0, sp, #28
    4e0a:	f7fd faf8 	bl	23fe <rpc_init_receive_section>
    RPC_ERR rpc_return = rpc_command_claim(CORES_PROTOCOL_CORE);
    4e0e:	2001      	movs	r0, #1
    4e10:	f7fd fb24 	bl	245c <rpc_command_claim>
    4e14:	1e04      	subs	r4, r0, #0
    if (rpc_return != RPC_ERR_OK)
    4e16:	d111      	bne.n	4e3c <command_get_iccid+0x58>
    set_receive_info(CORES_PROTOCOL_CORE, &info);
    4e18:	0029      	movs	r1, r5
    4e1a:	2001      	movs	r0, #1
    4e1c:	f7fc ffc0 	bl	1da0 <set_receive_info>
    rpc_interface_scatter_send(CORES_PROTOCOL_CORE, RPC_APPLICATION_TO_PROTOCOL_GET_ICCID, true, 0, NULL);
    4e20:	2201      	movs	r2, #1
    4e22:	0023      	movs	r3, r4
    4e24:	0010      	movs	r0, r2
    4e26:	2143      	movs	r1, #67	; 0x43
    4e28:	9400      	str	r4, [sp, #0]
    4e2a:	f7fd fa69 	bl	2300 <rpc_interface_scatter_send>
    rpc_blocking_loop(CORES_PROTOCOL_CORE);
    4e2e:	2001      	movs	r0, #1
    4e30:	f7fd faea 	bl	2408 <rpc_blocking_loop>
    return rpc_command_release(CORES_PROTOCOL_CORE);
    4e34:	2001      	movs	r0, #1
    4e36:	f7fd fafd 	bl	2434 <rpc_command_release>
    4e3a:	0004      	movs	r4, r0
}
    4e3c:	0020      	movs	r0, r4
    4e3e:	b00b      	add	sp, #44	; 0x2c
    4e40:	bdf0      	pop	{r4, r5, r6, r7, pc}

00004e42 <command_set_power_saving_mode>:
{
    4e42:	b5f0      	push	{r4, r5, r6, r7, lr}
    4e44:	b091      	sub	sp, #68	; 0x44
    4e46:	000c      	movs	r4, r1
    4e48:	0019      	movs	r1, r3
    4e4a:	466b      	mov	r3, sp
    4e4c:	270f      	movs	r7, #15
    4e4e:	819c      	strh	r4, [r3, #12]
    info.num_sections = 1;
    4e50:	2401      	movs	r4, #1
{
    4e52:	446f      	add	r7, sp
    4e54:	815a      	strh	r2, [r3, #10]
    4e56:	7038      	strb	r0, [r7, #0]
    rpc_init_receive_section(&get_sections[0], (uint8 *)result, sizeof(uint8), NULL);
    4e58:	2300      	movs	r3, #0
    info.sections = get_sections;
    4e5a:	a807      	add	r0, sp, #28
    rpc_init_receive_section(&get_sections[0], (uint8 *)result, sizeof(uint8), NULL);
    4e5c:	0022      	movs	r2, r4
    info.num_sections = 1;
    4e5e:	ae05      	add	r6, sp, #20
    info.sections = get_sections;
    4e60:	9005      	str	r0, [sp, #20]
    info.num_sections = 1;
    4e62:	7134      	strb	r4, [r6, #4]
    rpc_init_receive_section(&get_sections[0], (uint8 *)result, sizeof(uint8), NULL);
    4e64:	f7fd facb 	bl	23fe <rpc_init_receive_section>
    data_to_send[1].data_location = (uint8 *)&requested_periodic_tau;
    4e68:	ab03      	add	r3, sp, #12
    data_to_send[2].data_location = (uint8 *)&requested_active_time;
    4e6a:	220a      	movs	r2, #10
    data_to_send[1].data_location = (uint8 *)&requested_periodic_tau;
    4e6c:	930c      	str	r3, [sp, #48]	; 0x30
    data_to_send[1].data_length = sizeof(requested_periodic_tau);
    4e6e:	2302      	movs	r3, #2
    data_to_send[0].data_location = (uint8 *)&mode;
    4e70:	ad0a      	add	r5, sp, #40	; 0x28
    data_to_send[2].data_location = (uint8 *)&requested_active_time;
    4e72:	446a      	add	r2, sp
    RPC_ERR rpc_return = rpc_command_claim(CORES_PROTOCOL_CORE);
    4e74:	0020      	movs	r0, r4
    data_to_send[0].data_location = (uint8 *)&mode;
    4e76:	970a      	str	r7, [sp, #40]	; 0x28
    data_to_send[0].data_length = sizeof(mode);
    4e78:	80ac      	strh	r4, [r5, #4]
    data_to_send[1].data_length = sizeof(requested_periodic_tau);
    4e7a:	81ab      	strh	r3, [r5, #12]
    data_to_send[2].data_location = (uint8 *)&requested_active_time;
    4e7c:	920e      	str	r2, [sp, #56]	; 0x38
    data_to_send[2].data_length = sizeof(requested_active_time);
    4e7e:	82ab      	strh	r3, [r5, #20]
    RPC_ERR rpc_return = rpc_command_claim(CORES_PROTOCOL_CORE);
    4e80:	f7fd faec 	bl	245c <rpc_command_claim>
    if (rpc_return != RPC_ERR_OK)
    4e84:	2800      	cmp	r0, #0
    4e86:	d110      	bne.n	4eaa <command_set_power_saving_mode+0x68>
    set_receive_info(CORES_PROTOCOL_CORE, &info);
    4e88:	0031      	movs	r1, r6
    4e8a:	0020      	movs	r0, r4
    4e8c:	f7fc ff88 	bl	1da0 <set_receive_info>
    rpc_interface_scatter_send(CORES_PROTOCOL_CORE, RPC_APPLICATION_TO_PROTOCOL_SET_POWER_SAVING_MODE, true, 3, data_to_send);
    4e90:	2303      	movs	r3, #3
    4e92:	0022      	movs	r2, r4
    4e94:	2144      	movs	r1, #68	; 0x44
    4e96:	0020      	movs	r0, r4
    4e98:	9500      	str	r5, [sp, #0]
    4e9a:	f7fd fa31 	bl	2300 <rpc_interface_scatter_send>
    rpc_blocking_loop(CORES_PROTOCOL_CORE);
    4e9e:	0020      	movs	r0, r4
    4ea0:	f7fd fab2 	bl	2408 <rpc_blocking_loop>
    return rpc_command_release(CORES_PROTOCOL_CORE);
    4ea4:	0020      	movs	r0, r4
    4ea6:	f7fd fac5 	bl	2434 <rpc_command_release>
}
    4eaa:	b011      	add	sp, #68	; 0x44
    4eac:	bdf0      	pop	{r4, r5, r6, r7, pc}

00004eae <command_get_power_saving_mode>:
{
    4eae:	b5f0      	push	{r4, r5, r6, r7, lr}
    4eb0:	4684      	mov	ip, r0
    4eb2:	001c      	movs	r4, r3
    info.num_sections = 4;
    4eb4:	2304      	movs	r3, #4
{
    4eb6:	000f      	movs	r7, r1
    4eb8:	0016      	movs	r6, r2
    4eba:	b091      	sub	sp, #68	; 0x44
    info.num_sections = 4;
    4ebc:	ad02      	add	r5, sp, #8
    rpc_init_receive_section(&get_sections[0], (uint8 *)ret_value, sizeof(uint8), NULL);
    4ebe:	4661      	mov	r1, ip
    info.sections = get_sections;
    4ec0:	a804      	add	r0, sp, #16
    info.num_sections = 4;
    4ec2:	712b      	strb	r3, [r5, #4]
    rpc_init_receive_section(&get_sections[0], (uint8 *)ret_value, sizeof(uint8), NULL);
    4ec4:	2201      	movs	r2, #1
    4ec6:	2300      	movs	r3, #0
    info.sections = get_sections;
    4ec8:	9002      	str	r0, [sp, #8]
    rpc_init_receive_section(&get_sections[0], (uint8 *)ret_value, sizeof(uint8), NULL);
    4eca:	f7fd fa98 	bl	23fe <rpc_init_receive_section>
    rpc_init_receive_section(&get_sections[1], (uint8 *)mode, sizeof(uint8), NULL);
    4ece:	2300      	movs	r3, #0
    4ed0:	2201      	movs	r2, #1
    4ed2:	0039      	movs	r1, r7
    4ed4:	a807      	add	r0, sp, #28
    4ed6:	f7fd fa92 	bl	23fe <rpc_init_receive_section>
    rpc_init_receive_section(&get_sections[2], (uint8 *)requested_periodic_tau, sizeof(uint8), NULL);
    4eda:	2300      	movs	r3, #0
    4edc:	2201      	movs	r2, #1
    4ede:	0031      	movs	r1, r6
    4ee0:	a80a      	add	r0, sp, #40	; 0x28
    4ee2:	f7fd fa8c 	bl	23fe <rpc_init_receive_section>
    rpc_init_receive_section(&get_sections[3], (uint8 *)requested_active_time, sizeof(uint8), NULL);
    4ee6:	0021      	movs	r1, r4
    4ee8:	2300      	movs	r3, #0
    4eea:	2201      	movs	r2, #1
    4eec:	a80d      	add	r0, sp, #52	; 0x34
    4eee:	f7fd fa86 	bl	23fe <rpc_init_receive_section>
    RPC_ERR rpc_return = rpc_command_claim(CORES_PROTOCOL_CORE);
    4ef2:	2001      	movs	r0, #1
    4ef4:	f7fd fab2 	bl	245c <rpc_command_claim>
    4ef8:	1e04      	subs	r4, r0, #0
    if (rpc_return != RPC_ERR_OK)
    4efa:	d111      	bne.n	4f20 <command_get_power_saving_mode+0x72>
    set_receive_info(CORES_PROTOCOL_CORE, &info);
    4efc:	0029      	movs	r1, r5
    4efe:	2001      	movs	r0, #1
    4f00:	f7fc ff4e 	bl	1da0 <set_receive_info>
    rpc_interface_scatter_send(CORES_PROTOCOL_CORE, RPC_APPLICATION_TO_PROTOCOL_GET_POWER_SAVING_MODE, true, 0, NULL);
    4f04:	2201      	movs	r2, #1
    4f06:	0023      	movs	r3, r4
    4f08:	0010      	movs	r0, r2
    4f0a:	2145      	movs	r1, #69	; 0x45
    4f0c:	9400      	str	r4, [sp, #0]
    4f0e:	f7fd f9f7 	bl	2300 <rpc_interface_scatter_send>
    rpc_blocking_loop(CORES_PROTOCOL_CORE);
    4f12:	2001      	movs	r0, #1
    4f14:	f7fd fa78 	bl	2408 <rpc_blocking_loop>
    return rpc_command_release(CORES_PROTOCOL_CORE);
    4f18:	2001      	movs	r0, #1
    4f1a:	f7fd fa8b 	bl	2434 <rpc_command_release>
    4f1e:	0004      	movs	r4, r0
}
    4f20:	0020      	movs	r0, r4
    4f22:	b011      	add	sp, #68	; 0x44
    4f24:	bdf0      	pop	{r4, r5, r6, r7, pc}

00004f26 <command_set_edrxs_and_ptw>:
{
    4f26:	b5f0      	push	{r4, r5, r6, r7, lr}
    4f28:	270f      	movs	r7, #15
    4f2a:	b093      	sub	sp, #76	; 0x4c
    4f2c:	446f      	add	r7, sp
    info.num_sections = 1;
    4f2e:	2401      	movs	r4, #1
{
    4f30:	7038      	strb	r0, [r7, #0]
    4f32:	4668      	mov	r0, sp
    info.num_sections = 1;
    4f34:	ae05      	add	r6, sp, #20
{
    4f36:	7381      	strb	r1, [r0, #14]
    4f38:	7342      	strb	r2, [r0, #13]
    4f3a:	7303      	strb	r3, [r0, #12]
    rpc_init_receive_section(&get_sections[0], (uint8 *)result, sizeof(uint8), NULL);
    4f3c:	0022      	movs	r2, r4
    info.sections = get_sections;
    4f3e:	a807      	add	r0, sp, #28
    rpc_init_receive_section(&get_sections[0], (uint8 *)result, sizeof(uint8), NULL);
    4f40:	2300      	movs	r3, #0
    4f42:	9918      	ldr	r1, [sp, #96]	; 0x60
    info.sections = get_sections;
    4f44:	9005      	str	r0, [sp, #20]
    info.num_sections = 1;
    4f46:	7134      	strb	r4, [r6, #4]
    rpc_init_receive_section(&get_sections[0], (uint8 *)result, sizeof(uint8), NULL);
    4f48:	f7fd fa59 	bl	23fe <rpc_init_receive_section>
    data_to_send[1].data_location = (uint8 *)&type;
    4f4c:	230e      	movs	r3, #14
    4f4e:	446b      	add	r3, sp
    4f50:	930c      	str	r3, [sp, #48]	; 0x30
    data_to_send[2].data_location = (uint8 *)&edrx_value;
    4f52:	230d      	movs	r3, #13
    4f54:	446b      	add	r3, sp
    data_to_send[0].data_location = (uint8 *)&mode;
    4f56:	ad0a      	add	r5, sp, #40	; 0x28
    data_to_send[2].data_location = (uint8 *)&edrx_value;
    4f58:	930e      	str	r3, [sp, #56]	; 0x38
    RPC_ERR rpc_return = rpc_command_claim(CORES_PROTOCOL_CORE);
    4f5a:	0020      	movs	r0, r4
    data_to_send[3].data_location = (uint8 *)&paging_time_window;
    4f5c:	ab03      	add	r3, sp, #12
    data_to_send[0].data_location = (uint8 *)&mode;
    4f5e:	970a      	str	r7, [sp, #40]	; 0x28
    data_to_send[0].data_length = sizeof(mode);
    4f60:	80ac      	strh	r4, [r5, #4]
    data_to_send[1].data_length = sizeof(type);
    4f62:	81ac      	strh	r4, [r5, #12]
    data_to_send[2].data_length = sizeof(edrx_value);
    4f64:	82ac      	strh	r4, [r5, #20]
    data_to_send[3].data_location = (uint8 *)&paging_time_window;
    4f66:	9310      	str	r3, [sp, #64]	; 0x40
    data_to_send[3].data_length = sizeof(paging_time_window);
    4f68:	83ac      	strh	r4, [r5, #28]
    RPC_ERR rpc_return = rpc_command_claim(CORES_PROTOCOL_CORE);
    4f6a:	f7fd fa77 	bl	245c <rpc_command_claim>
    if (rpc_return != RPC_ERR_OK)
    4f6e:	2800      	cmp	r0, #0
    4f70:	d110      	bne.n	4f94 <command_set_edrxs_and_ptw+0x6e>
    set_receive_info(CORES_PROTOCOL_CORE, &info);
    4f72:	0031      	movs	r1, r6
    4f74:	0020      	movs	r0, r4
    4f76:	f7fc ff13 	bl	1da0 <set_receive_info>
    rpc_interface_scatter_send(CORES_PROTOCOL_CORE, RPC_APPLICATION_TO_PROTOCOL_SET_EDRXS_AND_PTW, true, 4, data_to_send);
    4f7a:	2304      	movs	r3, #4
    4f7c:	0022      	movs	r2, r4
    4f7e:	2146      	movs	r1, #70	; 0x46
    4f80:	0020      	movs	r0, r4
    4f82:	9500      	str	r5, [sp, #0]
    4f84:	f7fd f9bc 	bl	2300 <rpc_interface_scatter_send>
    rpc_blocking_loop(CORES_PROTOCOL_CORE);
    4f88:	0020      	movs	r0, r4
    4f8a:	f7fd fa3d 	bl	2408 <rpc_blocking_loop>
    return rpc_command_release(CORES_PROTOCOL_CORE);
    4f8e:	0020      	movs	r0, r4
    4f90:	f7fd fa50 	bl	2434 <rpc_command_release>
}
    4f94:	b013      	add	sp, #76	; 0x4c
    4f96:	bdf0      	pop	{r4, r5, r6, r7, pc}

00004f98 <command_get_edrxs_and_ptw>:
{
    4f98:	b5f0      	push	{r4, r5, r6, r7, lr}
    4f9a:	4684      	mov	ip, r0
    4f9c:	001c      	movs	r4, r3
    info.num_sections = 4;
    4f9e:	2304      	movs	r3, #4
{
    4fa0:	000f      	movs	r7, r1
    4fa2:	0016      	movs	r6, r2
    4fa4:	b091      	sub	sp, #68	; 0x44
    info.num_sections = 4;
    4fa6:	ad02      	add	r5, sp, #8
    rpc_init_receive_section(&get_sections[0], (uint8 *)result, sizeof(uint8), NULL);
    4fa8:	4661      	mov	r1, ip
    info.sections = get_sections;
    4faa:	a804      	add	r0, sp, #16
    info.num_sections = 4;
    4fac:	712b      	strb	r3, [r5, #4]
    rpc_init_receive_section(&get_sections[0], (uint8 *)result, sizeof(uint8), NULL);
    4fae:	2201      	movs	r2, #1
    4fb0:	2300      	movs	r3, #0
    info.sections = get_sections;
    4fb2:	9002      	str	r0, [sp, #8]
    rpc_init_receive_section(&get_sections[0], (uint8 *)result, sizeof(uint8), NULL);
    4fb4:	f7fd fa23 	bl	23fe <rpc_init_receive_section>
    rpc_init_receive_section(&get_sections[1], (uint8 *)type, sizeof(uint8), NULL);
    4fb8:	2300      	movs	r3, #0
    4fba:	2201      	movs	r2, #1
    4fbc:	0039      	movs	r1, r7
    4fbe:	a807      	add	r0, sp, #28
    4fc0:	f7fd fa1d 	bl	23fe <rpc_init_receive_section>
    rpc_init_receive_section(&get_sections[2], (uint8 *)edrx_value, sizeof(uint8), NULL);
    4fc4:	2300      	movs	r3, #0
    4fc6:	2201      	movs	r2, #1
    4fc8:	0031      	movs	r1, r6
    4fca:	a80a      	add	r0, sp, #40	; 0x28
    4fcc:	f7fd fa17 	bl	23fe <rpc_init_receive_section>
    rpc_init_receive_section(&get_sections[3], (uint8 *)paging_time_window, sizeof(uint8), NULL);
    4fd0:	0021      	movs	r1, r4
    4fd2:	2300      	movs	r3, #0
    4fd4:	2201      	movs	r2, #1
    4fd6:	a80d      	add	r0, sp, #52	; 0x34
    4fd8:	f7fd fa11 	bl	23fe <rpc_init_receive_section>
    RPC_ERR rpc_return = rpc_command_claim(CORES_PROTOCOL_CORE);
    4fdc:	2001      	movs	r0, #1
    4fde:	f7fd fa3d 	bl	245c <rpc_command_claim>
    4fe2:	1e04      	subs	r4, r0, #0
    if (rpc_return != RPC_ERR_OK)
    4fe4:	d111      	bne.n	500a <command_get_edrxs_and_ptw+0x72>
    set_receive_info(CORES_PROTOCOL_CORE, &info);
    4fe6:	0029      	movs	r1, r5
    4fe8:	2001      	movs	r0, #1
    4fea:	f7fc fed9 	bl	1da0 <set_receive_info>
    rpc_interface_scatter_send(CORES_PROTOCOL_CORE, RPC_APPLICATION_TO_PROTOCOL_GET_EDRXS_AND_PTW, true, 0, NULL);
    4fee:	2201      	movs	r2, #1
    4ff0:	0023      	movs	r3, r4
    4ff2:	0010      	movs	r0, r2
    4ff4:	2147      	movs	r1, #71	; 0x47
    4ff6:	9400      	str	r4, [sp, #0]
    4ff8:	f7fd f982 	bl	2300 <rpc_interface_scatter_send>
    rpc_blocking_loop(CORES_PROTOCOL_CORE);
    4ffc:	2001      	movs	r0, #1
    4ffe:	f7fd fa03 	bl	2408 <rpc_blocking_loop>
    return rpc_command_release(CORES_PROTOCOL_CORE);
    5002:	2001      	movs	r0, #1
    5004:	f7fd fa16 	bl	2434 <rpc_command_release>
    5008:	0004      	movs	r4, r0
}
    500a:	0020      	movs	r0, r4
    500c:	b011      	add	sp, #68	; 0x44
    500e:	bdf0      	pop	{r4, r5, r6, r7, pc}

00005010 <command_get_cell_info>:
{
    5010:	b5f0      	push	{r4, r5, r6, r7, lr}
    5012:	4684      	mov	ip, r0
    5014:	001c      	movs	r4, r3
    info.num_sections = 3;
    5016:	2303      	movs	r3, #3
{
    5018:	000e      	movs	r6, r1
    501a:	0017      	movs	r7, r2
    501c:	b08f      	sub	sp, #60	; 0x3c
    info.num_sections = 3;
    501e:	ad03      	add	r5, sp, #12
    rpc_init_receive_section(&get_sections[0], (uint8 *)result, sizeof(uint8), NULL);
    5020:	4661      	mov	r1, ip
    info.sections = get_sections;
    5022:	a805      	add	r0, sp, #20
    info.num_sections = 3;
    5024:	712b      	strb	r3, [r5, #4]
    rpc_init_receive_section(&get_sections[0], (uint8 *)result, sizeof(uint8), NULL);
    5026:	2201      	movs	r2, #1
    5028:	2300      	movs	r3, #0
    info.sections = get_sections;
    502a:	9003      	str	r0, [sp, #12]
    rpc_init_receive_section(&get_sections[0], (uint8 *)result, sizeof(uint8), NULL);
    502c:	f7fd f9e7 	bl	23fe <rpc_init_receive_section>
    rpc_init_receive_section(&get_sections[1], (uint8 *)cell_info_buffer, cell_info_buffer_max_length, cell_info_buffer_length);
    5030:	0021      	movs	r1, r4
    5032:	003b      	movs	r3, r7
    5034:	0032      	movs	r2, r6
    5036:	a808      	add	r0, sp, #32
    5038:	f7fd f9e1 	bl	23fe <rpc_init_receive_section>
    rpc_init_receive_section(&get_sections[2], (uint8 *)vaild_cell_info_num, sizeof(uint8), NULL);
    503c:	2300      	movs	r3, #0
    503e:	2201      	movs	r2, #1
    5040:	9914      	ldr	r1, [sp, #80]	; 0x50
    5042:	a80b      	add	r0, sp, #44	; 0x2c
    5044:	f7fd f9db 	bl	23fe <rpc_init_receive_section>
    RPC_ERR rpc_return = rpc_command_claim(CORES_PROTOCOL_CORE);
    5048:	2001      	movs	r0, #1
    504a:	f7fd fa07 	bl	245c <rpc_command_claim>
    504e:	1e04      	subs	r4, r0, #0
    if (rpc_return != RPC_ERR_OK)
    5050:	d111      	bne.n	5076 <command_get_cell_info+0x66>
    set_receive_info(CORES_PROTOCOL_CORE, &info);
    5052:	0029      	movs	r1, r5
    5054:	2001      	movs	r0, #1
    5056:	f7fc fea3 	bl	1da0 <set_receive_info>
    rpc_interface_scatter_send(CORES_PROTOCOL_CORE, RPC_APPLICATION_TO_PROTOCOL_GET_CELL_INFO, true, 0, NULL);
    505a:	2201      	movs	r2, #1
    505c:	0023      	movs	r3, r4
    505e:	0010      	movs	r0, r2
    5060:	2148      	movs	r1, #72	; 0x48
    5062:	9400      	str	r4, [sp, #0]
    5064:	f7fd f94c 	bl	2300 <rpc_interface_scatter_send>
    rpc_blocking_loop(CORES_PROTOCOL_CORE);
    5068:	2001      	movs	r0, #1
    506a:	f7fd f9cd 	bl	2408 <rpc_blocking_loop>
    return rpc_command_release(CORES_PROTOCOL_CORE);
    506e:	2001      	movs	r0, #1
    5070:	f7fd f9e0 	bl	2434 <rpc_command_release>
    5074:	0004      	movs	r4, r0
}
    5076:	0020      	movs	r0, r4
    5078:	b00f      	add	sp, #60	; 0x3c
    507a:	bdf0      	pop	{r4, r5, r6, r7, pc}

0000507c <command_get_extended_error_cause>:
{
    507c:	b570      	push	{r4, r5, r6, lr}
    info.num_sections = 2;
    507e:	2302      	movs	r3, #2
{
    5080:	0006      	movs	r6, r0
    5082:	000c      	movs	r4, r1
    5084:	b08a      	sub	sp, #40	; 0x28
    info.num_sections = 2;
    5086:	ad02      	add	r5, sp, #8
    info.sections = get_sections;
    5088:	a804      	add	r0, sp, #16
    info.num_sections = 2;
    508a:	712b      	strb	r3, [r5, #4]
    rpc_init_receive_section(&get_sections[0], (uint8 *)reject_flag, sizeof(uint8), NULL);
    508c:	2201      	movs	r2, #1
    508e:	2300      	movs	r3, #0
    5090:	0031      	movs	r1, r6
    info.sections = get_sections;
    5092:	9002      	str	r0, [sp, #8]
    rpc_init_receive_section(&get_sections[0], (uint8 *)reject_flag, sizeof(uint8), NULL);
    5094:	f7fd f9b3 	bl	23fe <rpc_init_receive_section>
    rpc_init_receive_section(&get_sections[1], (uint8 *)cause, sizeof(uint8), NULL);
    5098:	0021      	movs	r1, r4
    509a:	2300      	movs	r3, #0
    509c:	2201      	movs	r2, #1
    509e:	a807      	add	r0, sp, #28
    50a0:	f7fd f9ad 	bl	23fe <rpc_init_receive_section>
    RPC_ERR rpc_return = rpc_command_claim(CORES_PROTOCOL_CORE);
    50a4:	2001      	movs	r0, #1
    50a6:	f7fd f9d9 	bl	245c <rpc_command_claim>
    50aa:	1e04      	subs	r4, r0, #0
    if (rpc_return != RPC_ERR_OK)
    50ac:	d111      	bne.n	50d2 <command_get_extended_error_cause+0x56>
    set_receive_info(CORES_PROTOCOL_CORE, &info);
    50ae:	0029      	movs	r1, r5
    50b0:	2001      	movs	r0, #1
    50b2:	f7fc fe75 	bl	1da0 <set_receive_info>
    rpc_interface_scatter_send(CORES_PROTOCOL_CORE, RPC_APPLICATION_TO_PROTOCOL_GET_EXTENDED_ERROR_CAUSE, true, 0, NULL);
    50b6:	2201      	movs	r2, #1
    50b8:	0023      	movs	r3, r4
    50ba:	0010      	movs	r0, r2
    50bc:	2149      	movs	r1, #73	; 0x49
    50be:	9400      	str	r4, [sp, #0]
    50c0:	f7fd f91e 	bl	2300 <rpc_interface_scatter_send>
    rpc_blocking_loop(CORES_PROTOCOL_CORE);
    50c4:	2001      	movs	r0, #1
    50c6:	f7fd f99f 	bl	2408 <rpc_blocking_loop>
    return rpc_command_release(CORES_PROTOCOL_CORE);
    50ca:	2001      	movs	r0, #1
    50cc:	f7fd f9b2 	bl	2434 <rpc_command_release>
    50d0:	0004      	movs	r4, r0
}
    50d2:	0020      	movs	r0, r4
    50d4:	b00a      	add	sp, #40	; 0x28
    50d6:	bd70      	pop	{r4, r5, r6, pc}

000050d8 <command_get_edrxrdp>:
{
    50d8:	b5f0      	push	{r4, r5, r6, r7, lr}
    50da:	4684      	mov	ip, r0
    50dc:	001c      	movs	r4, r3
    info.num_sections = 7;
    50de:	2307      	movs	r3, #7
{
    50e0:	000f      	movs	r7, r1
    50e2:	0016      	movs	r6, r2
    50e4:	b09b      	sub	sp, #108	; 0x6c
    info.num_sections = 7;
    50e6:	ad03      	add	r5, sp, #12
    rpc_init_receive_section(&get_sections[0], (uint8 *)result, sizeof(uint8), NULL);
    50e8:	4661      	mov	r1, ip
    info.sections = get_sections;
    50ea:	a805      	add	r0, sp, #20
    info.num_sections = 7;
    50ec:	712b      	strb	r3, [r5, #4]
    rpc_init_receive_section(&get_sections[0], (uint8 *)result, sizeof(uint8), NULL);
    50ee:	2201      	movs	r2, #1
    50f0:	2300      	movs	r3, #0
    info.sections = get_sections;
    50f2:	9003      	str	r0, [sp, #12]
    rpc_init_receive_section(&get_sections[0], (uint8 *)result, sizeof(uint8), NULL);
    50f4:	f7fd f983 	bl	23fe <rpc_init_receive_section>
    rpc_init_receive_section(&get_sections[1], (uint8 *)registered_state, sizeof(uint8), NULL);
    50f8:	2300      	movs	r3, #0
    50fa:	2201      	movs	r2, #1
    50fc:	0039      	movs	r1, r7
    50fe:	a808      	add	r0, sp, #32
    5100:	f7fd f97d 	bl	23fe <rpc_init_receive_section>
    rpc_init_receive_section(&get_sections[2], (uint8 *)act_type, sizeof(uint8), NULL);
    5104:	2300      	movs	r3, #0
    5106:	2201      	movs	r2, #1
    5108:	0031      	movs	r1, r6
    510a:	a80b      	add	r0, sp, #44	; 0x2c
    510c:	f7fd f977 	bl	23fe <rpc_init_receive_section>
    rpc_init_receive_section(&get_sections[3], (uint8 *)edrx_info_valid, sizeof(uint8), NULL);
    5110:	0021      	movs	r1, r4
    5112:	2300      	movs	r3, #0
    5114:	2201      	movs	r2, #1
    5116:	a80e      	add	r0, sp, #56	; 0x38
    5118:	f7fd f971 	bl	23fe <rpc_init_receive_section>
    rpc_init_receive_section(&get_sections[4], (uint8 *)request_edrx, sizeof(uint8), NULL);
    511c:	2300      	movs	r3, #0
    511e:	2201      	movs	r2, #1
    5120:	9920      	ldr	r1, [sp, #128]	; 0x80
    5122:	a811      	add	r0, sp, #68	; 0x44
    5124:	f7fd f96b 	bl	23fe <rpc_init_receive_section>
    rpc_init_receive_section(&get_sections[5], (uint8 *)nw_provided_edrx, sizeof(uint8), NULL);
    5128:	2300      	movs	r3, #0
    512a:	2201      	movs	r2, #1
    512c:	9921      	ldr	r1, [sp, #132]	; 0x84
    512e:	a814      	add	r0, sp, #80	; 0x50
    5130:	f7fd f965 	bl	23fe <rpc_init_receive_section>
    rpc_init_receive_section(&get_sections[6], (uint8 *)paging_time, sizeof(uint8), NULL);
    5134:	2300      	movs	r3, #0
    5136:	2201      	movs	r2, #1
    5138:	9922      	ldr	r1, [sp, #136]	; 0x88
    513a:	a817      	add	r0, sp, #92	; 0x5c
    513c:	f7fd f95f 	bl	23fe <rpc_init_receive_section>
    RPC_ERR rpc_return = rpc_command_claim(CORES_PROTOCOL_CORE);
    5140:	2001      	movs	r0, #1
    5142:	f7fd f98b 	bl	245c <rpc_command_claim>
    5146:	1e04      	subs	r4, r0, #0
    if (rpc_return != RPC_ERR_OK)
    5148:	d111      	bne.n	516e <command_get_edrxrdp+0x96>
    set_receive_info(CORES_PROTOCOL_CORE, &info);
    514a:	0029      	movs	r1, r5
    514c:	2001      	movs	r0, #1
    514e:	f7fc fe27 	bl	1da0 <set_receive_info>
    rpc_interface_scatter_send(CORES_PROTOCOL_CORE, RPC_APPLICATION_TO_PROTOCOL_GET_EDRXRDP, true, 0, NULL);
    5152:	2201      	movs	r2, #1
    5154:	0023      	movs	r3, r4
    5156:	0010      	movs	r0, r2
    5158:	214a      	movs	r1, #74	; 0x4a
    515a:	9400      	str	r4, [sp, #0]
    515c:	f7fd f8d0 	bl	2300 <rpc_interface_scatter_send>
    rpc_blocking_loop(CORES_PROTOCOL_CORE);
    5160:	2001      	movs	r0, #1
    5162:	f7fd f951 	bl	2408 <rpc_blocking_loop>
    return rpc_command_release(CORES_PROTOCOL_CORE);
    5166:	2001      	movs	r0, #1
    5168:	f7fd f964 	bl	2434 <rpc_command_release>
    516c:	0004      	movs	r4, r0
}
    516e:	0020      	movs	r0, r4
    5170:	b01b      	add	sp, #108	; 0x6c
    5172:	bdf0      	pop	{r4, r5, r6, r7, pc}

00005174 <command_get_firmware_version>:
{
    5174:	b5f0      	push	{r4, r5, r6, r7, lr}
    5176:	240f      	movs	r4, #15
    5178:	001d      	movs	r5, r3
    info.num_sections = 3;
    517a:	2303      	movs	r3, #3
{
    517c:	0016      	movs	r6, r2
    517e:	b093      	sub	sp, #76	; 0x4c
    5180:	446c      	add	r4, sp
    info.num_sections = 3;
    5182:	af05      	add	r7, sp, #20
{
    5184:	7020      	strb	r0, [r4, #0]
    info.num_sections = 3;
    5186:	713b      	strb	r3, [r7, #4]
    info.sections = get_sections;
    5188:	a809      	add	r0, sp, #36	; 0x24
    rpc_init_receive_section(&get_sections[0], (uint8 *)result, sizeof(uint8), NULL);
    518a:	2300      	movs	r3, #0
    518c:	2201      	movs	r2, #1
    info.sections = get_sections;
    518e:	9005      	str	r0, [sp, #20]
    rpc_init_receive_section(&get_sections[0], (uint8 *)result, sizeof(uint8), NULL);
    5190:	f7fd f935 	bl	23fe <rpc_init_receive_section>
    rpc_init_receive_section(&get_sections[1], (uint8 *)version_string_length, sizeof(uint16), NULL);
    5194:	0031      	movs	r1, r6
    5196:	2300      	movs	r3, #0
    5198:	2202      	movs	r2, #2
    519a:	a80c      	add	r0, sp, #48	; 0x30
    519c:	f7fd f92f 	bl	23fe <rpc_init_receive_section>
    rpc_init_receive_section(&get_sections[2], (uint8 *)version_string, sizeof(char) * 48, NULL);
    51a0:	0029      	movs	r1, r5
    data_to_send[0].data_length = sizeof(version_core);
    51a2:	2501      	movs	r5, #1
    rpc_init_receive_section(&get_sections[2], (uint8 *)version_string, sizeof(char) * 48, NULL);
    51a4:	2300      	movs	r3, #0
    51a6:	2230      	movs	r2, #48	; 0x30
    51a8:	a80f      	add	r0, sp, #60	; 0x3c
    data_to_send[0].data_location = (uint8 *)&version_core;
    51aa:	ae07      	add	r6, sp, #28
    rpc_init_receive_section(&get_sections[2], (uint8 *)version_string, sizeof(char) * 48, NULL);
    51ac:	f7fd f927 	bl	23fe <rpc_init_receive_section>
    data_to_send[0].data_length = sizeof(version_core);
    51b0:	80b5      	strh	r5, [r6, #4]
    RPC_ERR rpc_return = rpc_command_claim(CORES_SECURITY_CORE);
    51b2:	2000      	movs	r0, #0
    data_to_send[0].data_location = (uint8 *)&version_core;
    51b4:	9407      	str	r4, [sp, #28]
    RPC_ERR rpc_return = rpc_command_claim(CORES_SECURITY_CORE);
    51b6:	f7fd f951 	bl	245c <rpc_command_claim>
    51ba:	1e04      	subs	r4, r0, #0
    if (rpc_return != RPC_ERR_OK)
    51bc:	d110      	bne.n	51e0 <command_get_firmware_version+0x6c>
    set_receive_info(CORES_SECURITY_CORE, &info);
    51be:	0039      	movs	r1, r7
    51c0:	f7fc fdee 	bl	1da0 <set_receive_info>
    rpc_interface_scatter_send(CORES_SECURITY_CORE, RPC_APPLICATION_TO_SECURITY_GET_FIRMWARE_VERSION, true, 1, data_to_send);
    51c4:	002b      	movs	r3, r5
    51c6:	002a      	movs	r2, r5
    51c8:	2115      	movs	r1, #21
    51ca:	0020      	movs	r0, r4
    51cc:	9600      	str	r6, [sp, #0]
    51ce:	f7fd f897 	bl	2300 <rpc_interface_scatter_send>
    rpc_blocking_loop(CORES_SECURITY_CORE);
    51d2:	0020      	movs	r0, r4
    51d4:	f7fd f918 	bl	2408 <rpc_blocking_loop>
    return rpc_command_release(CORES_SECURITY_CORE);
    51d8:	0020      	movs	r0, r4
    51da:	f7fd f92b 	bl	2434 <rpc_command_release>
    51de:	0004      	movs	r4, r0
}
    51e0:	0020      	movs	r0, r4
    51e2:	b013      	add	sp, #76	; 0x4c
    51e4:	bdf0      	pop	{r4, r5, r6, r7, pc}

000051e6 <command_get_ssb_version>:
{
    51e6:	b5f0      	push	{r4, r5, r6, r7, lr}
    info.num_sections = 3;
    51e8:	2303      	movs	r3, #3
{
    51ea:	0007      	movs	r7, r0
    51ec:	000e      	movs	r6, r1
    51ee:	0014      	movs	r4, r2
    51f0:	b08f      	sub	sp, #60	; 0x3c
    info.num_sections = 3;
    51f2:	ad03      	add	r5, sp, #12
    info.sections = get_sections;
    51f4:	a805      	add	r0, sp, #20
    info.num_sections = 3;
    51f6:	712b      	strb	r3, [r5, #4]
    rpc_init_receive_section(&get_sections[0], (uint8 *)result, sizeof(uint8), NULL);
    51f8:	2201      	movs	r2, #1
    51fa:	2300      	movs	r3, #0
    51fc:	0039      	movs	r1, r7
    info.sections = get_sections;
    51fe:	9003      	str	r0, [sp, #12]
    rpc_init_receive_section(&get_sections[0], (uint8 *)result, sizeof(uint8), NULL);
    5200:	f7fd f8fd 	bl	23fe <rpc_init_receive_section>
    rpc_init_receive_section(&get_sections[1], (uint8 *)version_string_length, sizeof(uint16), NULL);
    5204:	2300      	movs	r3, #0
    5206:	2202      	movs	r2, #2
    5208:	0031      	movs	r1, r6
    520a:	a808      	add	r0, sp, #32
    520c:	f7fd f8f7 	bl	23fe <rpc_init_receive_section>
    rpc_init_receive_section(&get_sections[2], (uint8 *)version_string, sizeof(char) * 48, NULL);
    5210:	0021      	movs	r1, r4
    5212:	2300      	movs	r3, #0
    5214:	2230      	movs	r2, #48	; 0x30
    5216:	a80b      	add	r0, sp, #44	; 0x2c
    5218:	f7fd f8f1 	bl	23fe <rpc_init_receive_section>
    RPC_ERR rpc_return = rpc_command_claim(CORES_SECURITY_CORE);
    521c:	2000      	movs	r0, #0
    521e:	f7fd f91d 	bl	245c <rpc_command_claim>
    5222:	1e04      	subs	r4, r0, #0
    if (rpc_return != RPC_ERR_OK)
    5224:	d110      	bne.n	5248 <command_get_ssb_version+0x62>
    set_receive_info(CORES_SECURITY_CORE, &info);
    5226:	0029      	movs	r1, r5
    5228:	f7fc fdba 	bl	1da0 <set_receive_info>
    rpc_interface_scatter_send(CORES_SECURITY_CORE, RPC_APPLICATION_TO_SECURITY_GET_SSB_VERSION, true, 0, NULL);
    522c:	0023      	movs	r3, r4
    522e:	2201      	movs	r2, #1
    5230:	2116      	movs	r1, #22
    5232:	0020      	movs	r0, r4
    5234:	9400      	str	r4, [sp, #0]
    5236:	f7fd f863 	bl	2300 <rpc_interface_scatter_send>
    rpc_blocking_loop(CORES_SECURITY_CORE);
    523a:	0020      	movs	r0, r4
    523c:	f7fd f8e4 	bl	2408 <rpc_blocking_loop>
    return rpc_command_release(CORES_SECURITY_CORE);
    5240:	0020      	movs	r0, r4
    5242:	f7fd f8f7 	bl	2434 <rpc_command_release>
    5246:	0004      	movs	r4, r0
}
    5248:	0020      	movs	r0, r4
    524a:	b00f      	add	sp, #60	; 0x3c
    524c:	bdf0      	pop	{r4, r5, r6, r7, pc}

0000524e <command_get_rfconfig_version>:
{
    524e:	b570      	push	{r4, r5, r6, lr}
    info.num_sections = 2;
    5250:	2302      	movs	r3, #2
{
    5252:	0006      	movs	r6, r0
    5254:	000c      	movs	r4, r1
    5256:	b08a      	sub	sp, #40	; 0x28
    info.num_sections = 2;
    5258:	ad02      	add	r5, sp, #8
    info.sections = get_sections;
    525a:	a804      	add	r0, sp, #16
    info.num_sections = 2;
    525c:	712b      	strb	r3, [r5, #4]
    rpc_init_receive_section(&get_sections[0], (uint8 *)result, sizeof(uint8), NULL);
    525e:	2201      	movs	r2, #1
    5260:	2300      	movs	r3, #0
    5262:	0031      	movs	r1, r6
    info.sections = get_sections;
    5264:	9002      	str	r0, [sp, #8]
    rpc_init_receive_section(&get_sections[0], (uint8 *)result, sizeof(uint8), NULL);
    5266:	f7fd f8ca 	bl	23fe <rpc_init_receive_section>
    rpc_init_receive_section(&get_sections[1], (uint8 *)version_string, sizeof(char) * 48, NULL);
    526a:	0021      	movs	r1, r4
    526c:	2300      	movs	r3, #0
    526e:	2230      	movs	r2, #48	; 0x30
    5270:	a807      	add	r0, sp, #28
    5272:	f7fd f8c4 	bl	23fe <rpc_init_receive_section>
    RPC_ERR rpc_return = rpc_command_claim(CORES_SECURITY_CORE);
    5276:	2000      	movs	r0, #0
    5278:	f7fd f8f0 	bl	245c <rpc_command_claim>
    527c:	1e04      	subs	r4, r0, #0
    if (rpc_return != RPC_ERR_OK)
    527e:	d110      	bne.n	52a2 <command_get_rfconfig_version+0x54>
    set_receive_info(CORES_SECURITY_CORE, &info);
    5280:	0029      	movs	r1, r5
    5282:	f7fc fd8d 	bl	1da0 <set_receive_info>
    rpc_interface_scatter_send(CORES_SECURITY_CORE, RPC_APPLICATION_TO_SECURITY_GET_RFCONFIG_VERSION, true, 0, NULL);
    5286:	0023      	movs	r3, r4
    5288:	2201      	movs	r2, #1
    528a:	2117      	movs	r1, #23
    528c:	0020      	movs	r0, r4
    528e:	9400      	str	r4, [sp, #0]
    5290:	f7fd f836 	bl	2300 <rpc_interface_scatter_send>
    rpc_blocking_loop(CORES_SECURITY_CORE);
    5294:	0020      	movs	r0, r4
    5296:	f7fd f8b7 	bl	2408 <rpc_blocking_loop>
    return rpc_command_release(CORES_SECURITY_CORE);
    529a:	0020      	movs	r0, r4
    529c:	f7fd f8ca 	bl	2434 <rpc_command_release>
    52a0:	0004      	movs	r4, r0
}
    52a2:	0020      	movs	r0, r4
    52a4:	b00a      	add	sp, #40	; 0x28
    52a6:	bd70      	pop	{r4, r5, r6, pc}

000052a8 <command_get_temp_coefficient>:
{
    52a8:	b570      	push	{r4, r5, r6, lr}
    info.num_sections = 1;
    52aa:	2501      	movs	r5, #1
{
    52ac:	b088      	sub	sp, #32
    52ae:	0001      	movs	r1, r0
    rpc_init_receive_section(&get_sections[0], (uint8 *)temp_coefficient, sizeof(uint16), NULL);
    52b0:	2300      	movs	r3, #0
    info.sections = get_sections;
    52b2:	a805      	add	r0, sp, #20
    rpc_init_receive_section(&get_sections[0], (uint8 *)temp_coefficient, sizeof(uint16), NULL);
    52b4:	2202      	movs	r2, #2
    info.num_sections = 1;
    52b6:	ae03      	add	r6, sp, #12
    info.sections = get_sections;
    52b8:	9003      	str	r0, [sp, #12]
    info.num_sections = 1;
    52ba:	7135      	strb	r5, [r6, #4]
    rpc_init_receive_section(&get_sections[0], (uint8 *)temp_coefficient, sizeof(uint16), NULL);
    52bc:	f7fd f89f 	bl	23fe <rpc_init_receive_section>
    RPC_ERR rpc_return = rpc_command_claim(CORES_SECURITY_CORE);
    52c0:	2000      	movs	r0, #0
    52c2:	f7fd f8cb 	bl	245c <rpc_command_claim>
    52c6:	1e04      	subs	r4, r0, #0
    if (rpc_return != RPC_ERR_OK)
    52c8:	d110      	bne.n	52ec <command_get_temp_coefficient+0x44>
    set_receive_info(CORES_SECURITY_CORE, &info);
    52ca:	0031      	movs	r1, r6
    52cc:	f7fc fd68 	bl	1da0 <set_receive_info>
    rpc_interface_scatter_send(CORES_SECURITY_CORE, RPC_APPLICATION_TO_SECURITY_GET_TEMP_COEFFICIENT, true, 0, NULL);
    52d0:	0023      	movs	r3, r4
    52d2:	002a      	movs	r2, r5
    52d4:	2118      	movs	r1, #24
    52d6:	0020      	movs	r0, r4
    52d8:	9400      	str	r4, [sp, #0]
    52da:	f7fd f811 	bl	2300 <rpc_interface_scatter_send>
    rpc_blocking_loop(CORES_SECURITY_CORE);
    52de:	0020      	movs	r0, r4
    52e0:	f7fd f892 	bl	2408 <rpc_blocking_loop>
    return rpc_command_release(CORES_SECURITY_CORE);
    52e4:	0020      	movs	r0, r4
    52e6:	f7fd f8a5 	bl	2434 <rpc_command_release>
    52ea:	0004      	movs	r4, r0
}
    52ec:	0020      	movs	r0, r4
    52ee:	b008      	add	sp, #32
    52f0:	bd70      	pop	{r4, r5, r6, pc}

000052f2 <command_get_chipinfo>:
{
    52f2:	b5f0      	push	{r4, r5, r6, r7, lr}
    52f4:	4684      	mov	ip, r0
    52f6:	001c      	movs	r4, r3
    info.num_sections = 2;
    52f8:	2302      	movs	r3, #2
{
    52fa:	000e      	movs	r6, r1
    52fc:	0017      	movs	r7, r2
    52fe:	b08b      	sub	sp, #44	; 0x2c
    info.num_sections = 2;
    5300:	ad02      	add	r5, sp, #8
    rpc_init_receive_section(&get_sections[0], (uint8 *)result, sizeof(uint8), NULL);
    5302:	4661      	mov	r1, ip
    info.sections = get_sections;
    5304:	a804      	add	r0, sp, #16
    info.num_sections = 2;
    5306:	712b      	strb	r3, [r5, #4]
    rpc_init_receive_section(&get_sections[0], (uint8 *)result, sizeof(uint8), NULL);
    5308:	2201      	movs	r2, #1
    530a:	2300      	movs	r3, #0
    info.sections = get_sections;
    530c:	9002      	str	r0, [sp, #8]
    rpc_init_receive_section(&get_sections[0], (uint8 *)result, sizeof(uint8), NULL);
    530e:	f7fd f876 	bl	23fe <rpc_init_receive_section>
    rpc_init_receive_section(&get_sections[1], (uint8 *)chipinfo, chipinfo_max_length, chipinfo_length);
    5312:	0021      	movs	r1, r4
    5314:	003b      	movs	r3, r7
    5316:	0032      	movs	r2, r6
    5318:	a807      	add	r0, sp, #28
    531a:	f7fd f870 	bl	23fe <rpc_init_receive_section>
    RPC_ERR rpc_return = rpc_command_claim(CORES_PROTOCOL_CORE);
    531e:	2001      	movs	r0, #1
    5320:	f7fd f89c 	bl	245c <rpc_command_claim>
    5324:	1e04      	subs	r4, r0, #0
    if (rpc_return != RPC_ERR_OK)
    5326:	d111      	bne.n	534c <command_get_chipinfo+0x5a>
    set_receive_info(CORES_PROTOCOL_CORE, &info);
    5328:	0029      	movs	r1, r5
    532a:	2001      	movs	r0, #1
    532c:	f7fc fd38 	bl	1da0 <set_receive_info>
    rpc_interface_scatter_send(CORES_PROTOCOL_CORE, RPC_APPLICATION_TO_PROTOCOL_GET_CHIPINFO, true, 0, NULL);
    5330:	2201      	movs	r2, #1
    5332:	0023      	movs	r3, r4
    5334:	0010      	movs	r0, r2
    5336:	214b      	movs	r1, #75	; 0x4b
    5338:	9400      	str	r4, [sp, #0]
    533a:	f7fc ffe1 	bl	2300 <rpc_interface_scatter_send>
    rpc_blocking_loop(CORES_PROTOCOL_CORE);
    533e:	2001      	movs	r0, #1
    5340:	f7fd f862 	bl	2408 <rpc_blocking_loop>
    return rpc_command_release(CORES_PROTOCOL_CORE);
    5344:	2001      	movs	r0, #1
    5346:	f7fd f875 	bl	2434 <rpc_command_release>
    534a:	0004      	movs	r4, r0
}
    534c:	0020      	movs	r0, r4
    534e:	b00b      	add	sp, #44	; 0x2c
    5350:	bdf0      	pop	{r4, r5, r6, r7, pc}

00005352 <command_radio_config_tx_verify>:
{
    5352:	b5f0      	push	{r4, r5, r6, r7, lr}
    5354:	2717      	movs	r7, #23
    5356:	b09d      	sub	sp, #116	; 0x74
    info.num_sections = 1;
    5358:	2501      	movs	r5, #1
{
    535a:	9203      	str	r2, [sp, #12]
    535c:	466a      	mov	r2, sp
    535e:	446f      	add	r7, sp
    5360:	7593      	strb	r3, [r2, #22]
    5362:	9104      	str	r1, [sp, #16]
    5364:	7038      	strb	r0, [r7, #0]
    rpc_init_receive_section(&get_sections[0], (uint8 *)result, sizeof(uint8), NULL);
    5366:	2300      	movs	r3, #0
    info.sections = get_sections;
    5368:	a809      	add	r0, sp, #36	; 0x24
    rpc_init_receive_section(&get_sections[0], (uint8 *)result, sizeof(uint8), NULL);
    536a:	002a      	movs	r2, r5
    info.num_sections = 1;
    536c:	ae07      	add	r6, sp, #28
    rpc_init_receive_section(&get_sections[0], (uint8 *)result, sizeof(uint8), NULL);
    536e:	9926      	ldr	r1, [sp, #152]	; 0x98
    info.sections = get_sections;
    5370:	9007      	str	r0, [sp, #28]
    info.num_sections = 1;
    5372:	7135      	strb	r5, [r6, #4]
    rpc_init_receive_section(&get_sections[0], (uint8 *)result, sizeof(uint8), NULL);
    5374:	f7fd f843 	bl	23fe <rpc_init_receive_section>
    data_to_send[1].data_location = (uint8 *)&tx_frequency;
    5378:	ab04      	add	r3, sp, #16
    537a:	930e      	str	r3, [sp, #56]	; 0x38
    data_to_send[1].data_length = sizeof(tx_frequency);
    537c:	2304      	movs	r3, #4
    data_to_send[0].data_location = (uint8 *)&tx_power;
    537e:	ac0c      	add	r4, sp, #48	; 0x30
    data_to_send[1].data_length = sizeof(tx_frequency);
    5380:	81a3      	strh	r3, [r4, #12]
    data_to_send[2].data_length = sizeof(tx_duration);
    5382:	82a3      	strh	r3, [r4, #20]
    data_to_send[3].data_location = (uint8 *)&tx_band;
    5384:	3312      	adds	r3, #18
    5386:	446b      	add	r3, sp
    5388:	9312      	str	r3, [sp, #72]	; 0x48
    data_to_send[4].data_location = (uint8 *)&temperature;
    538a:	ab22      	add	r3, sp, #136	; 0x88
    538c:	9314      	str	r3, [sp, #80]	; 0x50
    data_to_send[4].data_length = sizeof(temperature);
    538e:	2302      	movs	r3, #2
    data_to_send[2].data_location = (uint8 *)&tx_duration;
    5390:	aa03      	add	r2, sp, #12
    data_to_send[4].data_length = sizeof(temperature);
    5392:	84a3      	strh	r3, [r4, #36]	; 0x24
    data_to_send[5].data_length = sizeof(voltage);
    5394:	85a3      	strh	r3, [r4, #44]	; 0x2c
    data_to_send[6].data_location = (uint8 *)&num_subcarrier;
    5396:	ab24      	add	r3, sp, #144	; 0x90
    data_to_send[2].data_location = (uint8 *)&tx_duration;
    5398:	9210      	str	r2, [sp, #64]	; 0x40
    data_to_send[6].data_location = (uint8 *)&num_subcarrier;
    539a:	9318      	str	r3, [sp, #96]	; 0x60
    data_to_send[5].data_location = (uint8 *)&voltage;
    539c:	aa23      	add	r2, sp, #140	; 0x8c
    data_to_send[7].data_location = (uint8 *)&subcarrier_index;
    539e:	ab25      	add	r3, sp, #148	; 0x94
    RPC_ERR rpc_return = rpc_command_claim(CORES_PROTOCOL_CORE);
    53a0:	0028      	movs	r0, r5
    data_to_send[0].data_location = (uint8 *)&tx_power;
    53a2:	970c      	str	r7, [sp, #48]	; 0x30
    data_to_send[0].data_length = sizeof(tx_power);
    53a4:	80a5      	strh	r5, [r4, #4]
    data_to_send[3].data_length = sizeof(tx_band);
    53a6:	83a5      	strh	r5, [r4, #28]
    data_to_send[5].data_location = (uint8 *)&voltage;
    53a8:	9216      	str	r2, [sp, #88]	; 0x58
    data_to_send[6].data_length = sizeof(num_subcarrier);
    53aa:	86a5      	strh	r5, [r4, #52]	; 0x34
    data_to_send[7].data_location = (uint8 *)&subcarrier_index;
    53ac:	931a      	str	r3, [sp, #104]	; 0x68
    data_to_send[7].data_length = sizeof(subcarrier_index);
    53ae:	87a5      	strh	r5, [r4, #60]	; 0x3c
    RPC_ERR rpc_return = rpc_command_claim(CORES_PROTOCOL_CORE);
    53b0:	f7fd f854 	bl	245c <rpc_command_claim>
    if (rpc_return != RPC_ERR_OK)
    53b4:	2800      	cmp	r0, #0
    53b6:	d110      	bne.n	53da <command_radio_config_tx_verify+0x88>
    set_receive_info(CORES_PROTOCOL_CORE, &info);
    53b8:	0031      	movs	r1, r6
    53ba:	0028      	movs	r0, r5
    53bc:	f7fc fcf0 	bl	1da0 <set_receive_info>
    rpc_interface_scatter_send(CORES_PROTOCOL_CORE, RPC_APPLICATION_TO_PROTOCOL_RADIO_CONFIG_TX_VERIFY, true, 8, data_to_send);
    53c0:	2308      	movs	r3, #8
    53c2:	002a      	movs	r2, r5
    53c4:	214c      	movs	r1, #76	; 0x4c
    53c6:	0028      	movs	r0, r5
    53c8:	9400      	str	r4, [sp, #0]
    53ca:	f7fc ff99 	bl	2300 <rpc_interface_scatter_send>
    rpc_blocking_loop(CORES_PROTOCOL_CORE);
    53ce:	0028      	movs	r0, r5
    53d0:	f7fd f81a 	bl	2408 <rpc_blocking_loop>
    return rpc_command_release(CORES_PROTOCOL_CORE);
    53d4:	0028      	movs	r0, r5
    53d6:	f7fd f82d 	bl	2434 <rpc_command_release>
}
    53da:	b01d      	add	sp, #116	; 0x74
    53dc:	bdf0      	pop	{r4, r5, r6, r7, pc}

000053de <command_radio_config_rx_verify>:
{
    53de:	b5f0      	push	{r4, r5, r6, r7, lr}
    53e0:	260b      	movs	r6, #11
    53e2:	b09d      	sub	sp, #116	; 0x74
    53e4:	446e      	add	r6, sp
    53e6:	7031      	strb	r1, [r6, #0]
    53e8:	4669      	mov	r1, sp
    info.num_sections = 4;
    53ea:	2704      	movs	r7, #4
{
    53ec:	728a      	strb	r2, [r1, #10]
    53ee:	810b      	strh	r3, [r1, #8]
    53f0:	9003      	str	r0, [sp, #12]
    rpc_init_receive_section(&get_sections[0], (uint8 *)result, sizeof(uint8), NULL);
    53f2:	2300      	movs	r3, #0
    info.sections = get_sections;
    53f4:	a810      	add	r0, sp, #64	; 0x40
    rpc_init_receive_section(&get_sections[0], (uint8 *)result, sizeof(uint8), NULL);
    53f6:	2201      	movs	r2, #1
    53f8:	9923      	ldr	r1, [sp, #140]	; 0x8c
    info.num_sections = 4;
    53fa:	ad04      	add	r5, sp, #16
    info.sections = get_sections;
    53fc:	9004      	str	r0, [sp, #16]
    info.num_sections = 4;
    53fe:	712f      	strb	r7, [r5, #4]
    rpc_init_receive_section(&get_sections[0], (uint8 *)result, sizeof(uint8), NULL);
    5400:	f7fc fffd 	bl	23fe <rpc_init_receive_section>
    rpc_init_receive_section(&get_sections[1], (uint8 *)rssi, sizeof(int16), NULL);
    5404:	2300      	movs	r3, #0
    5406:	2202      	movs	r2, #2
    5408:	9924      	ldr	r1, [sp, #144]	; 0x90
    540a:	a813      	add	r0, sp, #76	; 0x4c
    540c:	f7fc fff7 	bl	23fe <rpc_init_receive_section>
    rpc_init_receive_section(&get_sections[2], (uint8 *)snr, sizeof(int16), NULL);
    5410:	2300      	movs	r3, #0
    5412:	2202      	movs	r2, #2
    5414:	9925      	ldr	r1, [sp, #148]	; 0x94
    5416:	a816      	add	r0, sp, #88	; 0x58
    5418:	f7fc fff1 	bl	23fe <rpc_init_receive_section>
    rpc_init_receive_section(&get_sections[3], (uint8 *)cbm, sizeof(int16), NULL);
    541c:	2300      	movs	r3, #0
    541e:	2202      	movs	r2, #2
    5420:	a819      	add	r0, sp, #100	; 0x64
    5422:	9926      	ldr	r1, [sp, #152]	; 0x98
    5424:	f7fc ffeb 	bl	23fe <rpc_init_receive_section>
    data_to_send[0].data_location = (uint8 *)&frequency;
    5428:	ab03      	add	r3, sp, #12
    542a:	9306      	str	r3, [sp, #24]
    data_to_send[2].data_location = (uint8 *)&band;
    542c:	230a      	movs	r3, #10
    542e:	446b      	add	r3, sp
    data_to_send[1].data_location = (uint8 *)&gain_index;
    5430:	9608      	str	r6, [sp, #32]
    data_to_send[2].data_location = (uint8 *)&band;
    5432:	930a      	str	r3, [sp, #40]	; 0x28
    data_to_send[1].data_length = sizeof(gain_index);
    5434:	2601      	movs	r6, #1
    data_to_send[3].data_location = (uint8 *)&temperature;
    5436:	ab02      	add	r3, sp, #8
    5438:	930c      	str	r3, [sp, #48]	; 0x30
    data_to_send[3].data_length = sizeof(temperature);
    543a:	2302      	movs	r3, #2
    data_to_send[0].data_location = (uint8 *)&frequency;
    543c:	ac06      	add	r4, sp, #24
    data_to_send[4].data_location = (uint8 *)&voltage;
    543e:	aa22      	add	r2, sp, #136	; 0x88
    RPC_ERR rpc_return = rpc_command_claim(CORES_PROTOCOL_CORE);
    5440:	0030      	movs	r0, r6
    data_to_send[0].data_length = sizeof(frequency);
    5442:	80a7      	strh	r7, [r4, #4]
    data_to_send[1].data_length = sizeof(gain_index);
    5444:	81a6      	strh	r6, [r4, #12]
    data_to_send[2].data_length = sizeof(band);
    5446:	82a6      	strh	r6, [r4, #20]
    data_to_send[3].data_length = sizeof(temperature);
    5448:	83a3      	strh	r3, [r4, #28]
    data_to_send[4].data_location = (uint8 *)&voltage;
    544a:	920e      	str	r2, [sp, #56]	; 0x38
    data_to_send[4].data_length = sizeof(voltage);
    544c:	84a3      	strh	r3, [r4, #36]	; 0x24
    RPC_ERR rpc_return = rpc_command_claim(CORES_PROTOCOL_CORE);
    544e:	f7fd f805 	bl	245c <rpc_command_claim>
    if (rpc_return != RPC_ERR_OK)
    5452:	2800      	cmp	r0, #0
    5454:	d110      	bne.n	5478 <command_radio_config_rx_verify+0x9a>
    set_receive_info(CORES_PROTOCOL_CORE, &info);
    5456:	0029      	movs	r1, r5
    5458:	0030      	movs	r0, r6
    545a:	f7fc fca1 	bl	1da0 <set_receive_info>
    rpc_interface_scatter_send(CORES_PROTOCOL_CORE, RPC_APPLICATION_TO_PROTOCOL_RADIO_CONFIG_RX_VERIFY, true, 5, data_to_send);
    545e:	2305      	movs	r3, #5
    5460:	0032      	movs	r2, r6
    5462:	214d      	movs	r1, #77	; 0x4d
    5464:	0030      	movs	r0, r6
    5466:	9400      	str	r4, [sp, #0]
    5468:	f7fc ff4a 	bl	2300 <rpc_interface_scatter_send>
    rpc_blocking_loop(CORES_PROTOCOL_CORE);
    546c:	0030      	movs	r0, r6
    546e:	f7fc ffcb 	bl	2408 <rpc_blocking_loop>
    return rpc_command_release(CORES_PROTOCOL_CORE);
    5472:	0030      	movs	r0, r6
    5474:	f7fc ffde 	bl	2434 <rpc_command_release>
}
    5478:	b01d      	add	sp, #116	; 0x74
    547a:	bdf0      	pop	{r4, r5, r6, r7, pc}

0000547c <command_nonip_sendto>:
{
    547c:	b5f0      	push	{r4, r5, r6, r7, lr}
    info.num_sections = 1;
    547e:	2401      	movs	r4, #1
{
    5480:	b095      	sub	sp, #84	; 0x54
    5482:	ae05      	add	r6, sp, #20
    5484:	9304      	str	r3, [sp, #16]
    5486:	ab02      	add	r3, sp, #8
    5488:	73d8      	strb	r0, [r3, #15]
    548a:	8031      	strh	r1, [r6, #0]
    info.sections = get_sections;
    548c:	a809      	add	r0, sp, #36	; 0x24
{
    548e:	9203      	str	r2, [sp, #12]
    rpc_init_receive_section(&get_sections[0], (uint8 *)ret, sizeof(uint8), NULL);
    5490:	2300      	movs	r3, #0
    5492:	0022      	movs	r2, r4
    info.num_sections = 1;
    5494:	af07      	add	r7, sp, #28
    rpc_init_receive_section(&get_sections[0], (uint8 *)ret, sizeof(uint8), NULL);
    5496:	991a      	ldr	r1, [sp, #104]	; 0x68
    info.sections = get_sections;
    5498:	9007      	str	r0, [sp, #28]
    info.num_sections = 1;
    549a:	713c      	strb	r4, [r7, #4]
    rpc_init_receive_section(&get_sections[0], (uint8 *)ret, sizeof(uint8), NULL);
    549c:	f7fc ffaf 	bl	23fe <rpc_init_receive_section>
    data_to_send[0].data_location = (uint8 *)&cid;
    54a0:	230f      	movs	r3, #15
    54a2:	aa02      	add	r2, sp, #8
    54a4:	189b      	adds	r3, r3, r2
    54a6:	930c      	str	r3, [sp, #48]	; 0x30
    data_to_send[1].data_length = sizeof(message_length);
    54a8:	2302      	movs	r3, #2
    data_to_send[0].data_location = (uint8 *)&cid;
    54aa:	ad0c      	add	r5, sp, #48	; 0x30
    data_to_send[1].data_length = sizeof(message_length);
    54ac:	81ab      	strh	r3, [r5, #12]
    data_to_send[2].data_location = (uint8 *)message;
    54ae:	9b03      	ldr	r3, [sp, #12]
    data_to_send[1].data_location = (uint8 *)&message_length;
    54b0:	960e      	str	r6, [sp, #56]	; 0x38
    data_to_send[2].data_location = (uint8 *)message;
    54b2:	9310      	str	r3, [sp, #64]	; 0x40
    data_to_send[2].data_length = message_length;
    54b4:	8833      	ldrh	r3, [r6, #0]
    data_to_send[3].data_length = sizeof(flags);
    54b6:	2604      	movs	r6, #4
    data_to_send[2].data_length = message_length;
    54b8:	82ab      	strh	r3, [r5, #20]
    RPC_ERR rpc_return = rpc_command_claim(CORES_PROTOCOL_CORE);
    54ba:	0020      	movs	r0, r4
    data_to_send[3].data_location = (uint8 *)&flags;
    54bc:	ab04      	add	r3, sp, #16
    data_to_send[0].data_length = sizeof(cid);
    54be:	80ac      	strh	r4, [r5, #4]
    data_to_send[3].data_location = (uint8 *)&flags;
    54c0:	9312      	str	r3, [sp, #72]	; 0x48
    data_to_send[3].data_length = sizeof(flags);
    54c2:	83ae      	strh	r6, [r5, #28]
    RPC_ERR rpc_return = rpc_command_claim(CORES_PROTOCOL_CORE);
    54c4:	f7fc ffca 	bl	245c <rpc_command_claim>
    if (rpc_return != RPC_ERR_OK)
    54c8:	2800      	cmp	r0, #0
    54ca:	d110      	bne.n	54ee <command_nonip_sendto+0x72>
    set_receive_info(CORES_PROTOCOL_CORE, &info);
    54cc:	0039      	movs	r1, r7
    54ce:	0020      	movs	r0, r4
    54d0:	f7fc fc66 	bl	1da0 <set_receive_info>
    rpc_interface_scatter_send(CORES_PROTOCOL_CORE, RPC_APPLICATION_TO_PROTOCOL_NONIP_SENDTO, true, 4, data_to_send);
    54d4:	0033      	movs	r3, r6
    54d6:	0022      	movs	r2, r4
    54d8:	214e      	movs	r1, #78	; 0x4e
    54da:	0020      	movs	r0, r4
    54dc:	9500      	str	r5, [sp, #0]
    54de:	f7fc ff0f 	bl	2300 <rpc_interface_scatter_send>
    rpc_blocking_loop(CORES_PROTOCOL_CORE);
    54e2:	0020      	movs	r0, r4
    54e4:	f7fc ff90 	bl	2408 <rpc_blocking_loop>
    return rpc_command_release(CORES_PROTOCOL_CORE);
    54e8:	0020      	movs	r0, r4
    54ea:	f7fc ffa3 	bl	2434 <rpc_command_release>
}
    54ee:	b015      	add	sp, #84	; 0x54
    54f0:	bdf0      	pop	{r4, r5, r6, r7, pc}

000054f2 <command_get_mtu_size>:
{
    54f2:	b5f0      	push	{r4, r5, r6, r7, lr}
    54f4:	240f      	movs	r4, #15
    54f6:	001d      	movs	r5, r3
    info.num_sections = 3;
    54f8:	2303      	movs	r3, #3
{
    54fa:	0017      	movs	r7, r2
    54fc:	b093      	sub	sp, #76	; 0x4c
    54fe:	446c      	add	r4, sp
    info.num_sections = 3;
    5500:	ae05      	add	r6, sp, #20
{
    5502:	7020      	strb	r0, [r4, #0]
    info.num_sections = 3;
    5504:	7133      	strb	r3, [r6, #4]
    info.sections = get_sections;
    5506:	a809      	add	r0, sp, #36	; 0x24
    rpc_init_receive_section(&get_sections[0], (uint8 *)result, sizeof(uint8), NULL);
    5508:	2300      	movs	r3, #0
    550a:	2201      	movs	r2, #1
    info.sections = get_sections;
    550c:	9005      	str	r0, [sp, #20]
    rpc_init_receive_section(&get_sections[0], (uint8 *)result, sizeof(uint8), NULL);
    550e:	f7fc ff76 	bl	23fe <rpc_init_receive_section>
    rpc_init_receive_section(&get_sections[1], (uint8 *)ip_mtu, sizeof(uint16), NULL);
    5512:	2300      	movs	r3, #0
    5514:	2202      	movs	r2, #2
    5516:	0039      	movs	r1, r7
    5518:	a80c      	add	r0, sp, #48	; 0x30
    551a:	f7fc ff70 	bl	23fe <rpc_init_receive_section>
    rpc_init_receive_section(&get_sections[2], (uint8 *)non_ip_mtu, sizeof(uint16), NULL);
    551e:	0029      	movs	r1, r5
    5520:	a80f      	add	r0, sp, #60	; 0x3c
    5522:	2300      	movs	r3, #0
    5524:	2202      	movs	r2, #2
    5526:	f7fc ff6a 	bl	23fe <rpc_init_receive_section>
    data_to_send[0].data_location = (uint8 *)&cid;
    552a:	9407      	str	r4, [sp, #28]
    data_to_send[0].data_length = sizeof(cid);
    552c:	2401      	movs	r4, #1
    data_to_send[0].data_location = (uint8 *)&cid;
    552e:	ad07      	add	r5, sp, #28
    data_to_send[0].data_length = sizeof(cid);
    5530:	80ac      	strh	r4, [r5, #4]
    RPC_ERR rpc_return = rpc_command_claim(CORES_PROTOCOL_CORE);
    5532:	0020      	movs	r0, r4
    5534:	f7fc ff92 	bl	245c <rpc_command_claim>
    if (rpc_return != RPC_ERR_OK)
    5538:	2800      	cmp	r0, #0
    553a:	d110      	bne.n	555e <command_get_mtu_size+0x6c>
    set_receive_info(CORES_PROTOCOL_CORE, &info);
    553c:	0031      	movs	r1, r6
    553e:	0020      	movs	r0, r4
    5540:	f7fc fc2e 	bl	1da0 <set_receive_info>
    rpc_interface_scatter_send(CORES_PROTOCOL_CORE, RPC_APPLICATION_TO_PROTOCOL_GET_MTU_SIZE, true, 1, data_to_send);
    5544:	0023      	movs	r3, r4
    5546:	0022      	movs	r2, r4
    5548:	214f      	movs	r1, #79	; 0x4f
    554a:	0020      	movs	r0, r4
    554c:	9500      	str	r5, [sp, #0]
    554e:	f7fc fed7 	bl	2300 <rpc_interface_scatter_send>
    rpc_blocking_loop(CORES_PROTOCOL_CORE);
    5552:	0020      	movs	r0, r4
    5554:	f7fc ff58 	bl	2408 <rpc_blocking_loop>
    return rpc_command_release(CORES_PROTOCOL_CORE);
    5558:	0020      	movs	r0, r4
    555a:	f7fc ff6b 	bl	2434 <rpc_command_release>
}
    555e:	b013      	add	sp, #76	; 0x4c
    5560:	bdf0      	pop	{r4, r5, r6, r7, pc}

00005562 <command_execute_pin_command>:
{
    5562:	b5f0      	push	{r4, r5, r6, r7, lr}
    5564:	270f      	movs	r7, #15
    info.num_sections = 1;
    5566:	2401      	movs	r4, #1
{
    5568:	b093      	sub	sp, #76	; 0x4c
    556a:	9103      	str	r1, [sp, #12]
    556c:	0019      	movs	r1, r3
    556e:	ab02      	add	r3, sp, #8
    5570:	18ff      	adds	r7, r7, r3
    5572:	9204      	str	r2, [sp, #16]
    5574:	7038      	strb	r0, [r7, #0]
    rpc_init_receive_section(&get_sections[0], (uint8 *)ret, sizeof(uint8), NULL);
    5576:	2300      	movs	r3, #0
    info.sections = get_sections;
    5578:	a809      	add	r0, sp, #36	; 0x24
    rpc_init_receive_section(&get_sections[0], (uint8 *)ret, sizeof(uint8), NULL);
    557a:	0022      	movs	r2, r4
    info.num_sections = 1;
    557c:	ae07      	add	r6, sp, #28
    info.sections = get_sections;
    557e:	9007      	str	r0, [sp, #28]
    info.num_sections = 1;
    5580:	7134      	strb	r4, [r6, #4]
    rpc_init_receive_section(&get_sections[0], (uint8 *)ret, sizeof(uint8), NULL);
    5582:	f7fc ff3c 	bl	23fe <rpc_init_receive_section>
    data_to_send[1].data_location = (uint8 *)pin1;
    5586:	9b03      	ldr	r3, [sp, #12]
    data_to_send[2].data_location = (uint8 *)pin2;
    5588:	9a04      	ldr	r2, [sp, #16]
    data_to_send[1].data_location = (uint8 *)pin1;
    558a:	930e      	str	r3, [sp, #56]	; 0x38
    data_to_send[1].data_length = sizeof(uint8) * 9;
    558c:	2309      	movs	r3, #9
    data_to_send[0].data_location = (uint8 *)&command;
    558e:	ad0c      	add	r5, sp, #48	; 0x30
    RPC_ERR rpc_return = rpc_command_claim(CORES_PROTOCOL_CORE);
    5590:	0020      	movs	r0, r4
    data_to_send[0].data_location = (uint8 *)&command;
    5592:	970c      	str	r7, [sp, #48]	; 0x30
    data_to_send[0].data_length = sizeof(command);
    5594:	80ac      	strh	r4, [r5, #4]
    data_to_send[1].data_length = sizeof(uint8) * 9;
    5596:	81ab      	strh	r3, [r5, #12]
    data_to_send[2].data_location = (uint8 *)pin2;
    5598:	9210      	str	r2, [sp, #64]	; 0x40
    data_to_send[2].data_length = sizeof(uint8) * 9;
    559a:	82ab      	strh	r3, [r5, #20]
    RPC_ERR rpc_return = rpc_command_claim(CORES_PROTOCOL_CORE);
    559c:	f7fc ff5e 	bl	245c <rpc_command_claim>
    if (rpc_return != RPC_ERR_OK)
    55a0:	2800      	cmp	r0, #0
    55a2:	d110      	bne.n	55c6 <command_execute_pin_command+0x64>
    set_receive_info(CORES_PROTOCOL_CORE, &info);
    55a4:	0031      	movs	r1, r6
    55a6:	0020      	movs	r0, r4
    55a8:	f7fc fbfa 	bl	1da0 <set_receive_info>
    rpc_interface_scatter_send(CORES_PROTOCOL_CORE, RPC_APPLICATION_TO_PROTOCOL_EXECUTE_PIN_COMMAND, true, 3, data_to_send);
    55ac:	2303      	movs	r3, #3
    55ae:	0022      	movs	r2, r4
    55b0:	2150      	movs	r1, #80	; 0x50
    55b2:	0020      	movs	r0, r4
    55b4:	9500      	str	r5, [sp, #0]
    55b6:	f7fc fea3 	bl	2300 <rpc_interface_scatter_send>
    rpc_blocking_loop(CORES_PROTOCOL_CORE);
    55ba:	0020      	movs	r0, r4
    55bc:	f7fc ff24 	bl	2408 <rpc_blocking_loop>
    return rpc_command_release(CORES_PROTOCOL_CORE);
    55c0:	0020      	movs	r0, r4
    55c2:	f7fc ff37 	bl	2434 <rpc_command_release>
}
    55c6:	b013      	add	sp, #76	; 0x4c
    55c8:	bdf0      	pop	{r4, r5, r6, r7, pc}

000055ca <command_register_kvcache>:
{
    55ca:	b5f0      	push	{r4, r5, r6, r7, lr}
    info.num_sections = 1;
    55cc:	2501      	movs	r5, #1
{
    55ce:	b08d      	sub	sp, #52	; 0x34
    55d0:	9003      	str	r0, [sp, #12]
    rpc_init_receive_section(&get_sections[0], (uint8 *)kv_ret_code, sizeof(uint8), NULL);
    55d2:	2300      	movs	r3, #0
    info.sections = get_sections;
    55d4:	a809      	add	r0, sp, #36	; 0x24
    rpc_init_receive_section(&get_sections[0], (uint8 *)kv_ret_code, sizeof(uint8), NULL);
    55d6:	002a      	movs	r2, r5
    info.num_sections = 1;
    55d8:	af05      	add	r7, sp, #20
    info.sections = get_sections;
    55da:	9005      	str	r0, [sp, #20]
    info.num_sections = 1;
    55dc:	713d      	strb	r5, [r7, #4]
    rpc_init_receive_section(&get_sections[0], (uint8 *)kv_ret_code, sizeof(uint8), NULL);
    55de:	f7fc ff0e 	bl	23fe <rpc_init_receive_section>
    data_to_send[0].data_location = (uint8 *)&kv_cache;
    55e2:	ab03      	add	r3, sp, #12
    55e4:	9307      	str	r3, [sp, #28]
    data_to_send[0].data_length = sizeof(kv_cache);
    55e6:	2304      	movs	r3, #4
    data_to_send[0].data_location = (uint8 *)&kv_cache;
    55e8:	ae07      	add	r6, sp, #28
    RPC_ERR rpc_return = rpc_command_claim(CORES_SECURITY_CORE);
    55ea:	2000      	movs	r0, #0
    data_to_send[0].data_length = sizeof(kv_cache);
    55ec:	80b3      	strh	r3, [r6, #4]
    RPC_ERR rpc_return = rpc_command_claim(CORES_SECURITY_CORE);
    55ee:	f7fc ff35 	bl	245c <rpc_command_claim>
    55f2:	1e04      	subs	r4, r0, #0
    if (rpc_return != RPC_ERR_OK)
    55f4:	d110      	bne.n	5618 <command_register_kvcache+0x4e>
    set_receive_info(CORES_SECURITY_CORE, &info);
    55f6:	0039      	movs	r1, r7
    55f8:	f7fc fbd2 	bl	1da0 <set_receive_info>
    rpc_interface_scatter_send(CORES_SECURITY_CORE, RPC_APPLICATION_TO_SECURITY_REGISTER_KVCACHE, true, 1, data_to_send);
    55fc:	002b      	movs	r3, r5
    55fe:	002a      	movs	r2, r5
    5600:	2119      	movs	r1, #25
    5602:	0020      	movs	r0, r4
    5604:	9600      	str	r6, [sp, #0]
    5606:	f7fc fe7b 	bl	2300 <rpc_interface_scatter_send>
    rpc_blocking_loop(CORES_SECURITY_CORE);
    560a:	0020      	movs	r0, r4
    560c:	f7fc fefc 	bl	2408 <rpc_blocking_loop>
    return rpc_command_release(CORES_SECURITY_CORE);
    5610:	0020      	movs	r0, r4
    5612:	f7fc ff0f 	bl	2434 <rpc_command_release>
    5616:	0004      	movs	r4, r0
}
    5618:	0020      	movs	r0, r4
    561a:	b00d      	add	sp, #52	; 0x34
    561c:	bdf0      	pop	{r4, r5, r6, r7, pc}

0000561e <command_kv_queue_cache_for_write>:
{
    561e:	b570      	push	{r4, r5, r6, lr}
    info.num_sections = 1;
    5620:	2501      	movs	r5, #1
{
    5622:	b088      	sub	sp, #32
    5624:	0001      	movs	r1, r0
    rpc_init_receive_section(&get_sections[0], (uint8 *)kv_ret_code, sizeof(uint8), NULL);
    5626:	2300      	movs	r3, #0
    info.sections = get_sections;
    5628:	a805      	add	r0, sp, #20
    rpc_init_receive_section(&get_sections[0], (uint8 *)kv_ret_code, sizeof(uint8), NULL);
    562a:	002a      	movs	r2, r5
    info.num_sections = 1;
    562c:	ae03      	add	r6, sp, #12
    info.sections = get_sections;
    562e:	9003      	str	r0, [sp, #12]
    info.num_sections = 1;
    5630:	7135      	strb	r5, [r6, #4]
    rpc_init_receive_section(&get_sections[0], (uint8 *)kv_ret_code, sizeof(uint8), NULL);
    5632:	f7fc fee4 	bl	23fe <rpc_init_receive_section>
    RPC_ERR rpc_return = rpc_command_claim(CORES_SECURITY_CORE);
    5636:	2000      	movs	r0, #0
    5638:	f7fc ff10 	bl	245c <rpc_command_claim>
    563c:	1e04      	subs	r4, r0, #0
    if (rpc_return != RPC_ERR_OK)
    563e:	d110      	bne.n	5662 <command_kv_queue_cache_for_write+0x44>
    set_receive_info(CORES_SECURITY_CORE, &info);
    5640:	0031      	movs	r1, r6
    5642:	f7fc fbad 	bl	1da0 <set_receive_info>
    rpc_interface_scatter_send(CORES_SECURITY_CORE, RPC_APPLICATION_TO_SECURITY_KV_QUEUE_CACHE_FOR_WRITE, true, 0, NULL);
    5646:	0023      	movs	r3, r4
    5648:	002a      	movs	r2, r5
    564a:	211a      	movs	r1, #26
    564c:	0020      	movs	r0, r4
    564e:	9400      	str	r4, [sp, #0]
    5650:	f7fc fe56 	bl	2300 <rpc_interface_scatter_send>
    rpc_blocking_loop(CORES_SECURITY_CORE);
    5654:	0020      	movs	r0, r4
    5656:	f7fc fed7 	bl	2408 <rpc_blocking_loop>
    return rpc_command_release(CORES_SECURITY_CORE);
    565a:	0020      	movs	r0, r4
    565c:	f7fc feea 	bl	2434 <rpc_command_release>
    5660:	0004      	movs	r4, r0
}
    5662:	0020      	movs	r0, r4
    5664:	b008      	add	sp, #32
    5666:	bd70      	pop	{r4, r5, r6, pc}

00005668 <command_get_apn_rate_control_context>:
{
    5668:	b5f0      	push	{r4, r5, r6, r7, lr}
    566a:	240f      	movs	r4, #15
    566c:	001d      	movs	r5, r3
    info.num_sections = 6;
    566e:	2306      	movs	r3, #6
{
    5670:	0017      	movs	r7, r2
    5672:	b09b      	sub	sp, #108	; 0x6c
    5674:	446c      	add	r4, sp
    info.num_sections = 6;
    5676:	ae04      	add	r6, sp, #16
{
    5678:	7020      	strb	r0, [r4, #0]
    info.num_sections = 6;
    567a:	7133      	strb	r3, [r6, #4]
    info.sections = get_sections;
    567c:	a808      	add	r0, sp, #32
    rpc_init_receive_section(&get_sections[0], (uint8 *)result, sizeof(uint8), NULL);
    567e:	2300      	movs	r3, #0
    5680:	2201      	movs	r2, #1
    info.sections = get_sections;
    5682:	9004      	str	r0, [sp, #16]
    rpc_init_receive_section(&get_sections[0], (uint8 *)result, sizeof(uint8), NULL);
    5684:	f7fc febb 	bl	23fe <rpc_init_receive_section>
    rpc_init_receive_section(&get_sections[1], (uint8 *)additional_exception_reports, sizeof(uint8), NULL);
    5688:	2300      	movs	r3, #0
    568a:	2201      	movs	r2, #1
    568c:	0039      	movs	r1, r7
    568e:	a80b      	add	r0, sp, #44	; 0x2c
    5690:	f7fc feb5 	bl	23fe <rpc_init_receive_section>
    rpc_init_receive_section(&get_sections[2], (uint8 *)uplink_time_unit, sizeof(uint8), NULL);
    5694:	0029      	movs	r1, r5
    5696:	2300      	movs	r3, #0
    5698:	2201      	movs	r2, #1
    569a:	a80e      	add	r0, sp, #56	; 0x38
    569c:	f7fc feaf 	bl	23fe <rpc_init_receive_section>
    rpc_init_receive_section(&get_sections[3], (uint8 *)maximum_uplink_rate, sizeof(uint32), NULL);
    56a0:	2300      	movs	r3, #0
    56a2:	2204      	movs	r2, #4
    56a4:	9920      	ldr	r1, [sp, #128]	; 0x80
    56a6:	a811      	add	r0, sp, #68	; 0x44
    56a8:	f7fc fea9 	bl	23fe <rpc_init_receive_section>
    rpc_init_receive_section(&get_sections[4], (uint8 *)except_uplink_time_unit, sizeof(uint8), NULL);
    56ac:	2300      	movs	r3, #0
    56ae:	2201      	movs	r2, #1
    56b0:	9921      	ldr	r1, [sp, #132]	; 0x84
    56b2:	a814      	add	r0, sp, #80	; 0x50
    56b4:	f7fc fea3 	bl	23fe <rpc_init_receive_section>
    rpc_init_receive_section(&get_sections[5], (uint8 *)except_maximum_uplink_rate, sizeof(uint32), NULL);
    56b8:	a817      	add	r0, sp, #92	; 0x5c
    56ba:	2300      	movs	r3, #0
    56bc:	2204      	movs	r2, #4
    56be:	9922      	ldr	r1, [sp, #136]	; 0x88
    56c0:	f7fc fe9d 	bl	23fe <rpc_init_receive_section>
    data_to_send[0].data_location = (uint8 *)&cid;
    56c4:	9406      	str	r4, [sp, #24]
    data_to_send[0].data_length = sizeof(cid);
    56c6:	2401      	movs	r4, #1
    data_to_send[0].data_location = (uint8 *)&cid;
    56c8:	ad06      	add	r5, sp, #24
    data_to_send[0].data_length = sizeof(cid);
    56ca:	80ac      	strh	r4, [r5, #4]
    RPC_ERR rpc_return = rpc_command_claim(CORES_PROTOCOL_CORE);
    56cc:	0020      	movs	r0, r4
    56ce:	f7fc fec5 	bl	245c <rpc_command_claim>
    if (rpc_return != RPC_ERR_OK)
    56d2:	2800      	cmp	r0, #0
    56d4:	d110      	bne.n	56f8 <command_get_apn_rate_control_context+0x90>
    set_receive_info(CORES_PROTOCOL_CORE, &info);
    56d6:	0031      	movs	r1, r6
    56d8:	0020      	movs	r0, r4
    56da:	f7fc fb61 	bl	1da0 <set_receive_info>
    rpc_interface_scatter_send(CORES_PROTOCOL_CORE, RPC_APPLICATION_TO_PROTOCOL_GET_APN_RATE_CONTROL_CONTEXT, true, 1, data_to_send);
    56de:	0023      	movs	r3, r4
    56e0:	0022      	movs	r2, r4
    56e2:	2151      	movs	r1, #81	; 0x51
    56e4:	0020      	movs	r0, r4
    56e6:	9500      	str	r5, [sp, #0]
    56e8:	f7fc fe0a 	bl	2300 <rpc_interface_scatter_send>
    rpc_blocking_loop(CORES_PROTOCOL_CORE);
    56ec:	0020      	movs	r0, r4
    56ee:	f7fc fe8b 	bl	2408 <rpc_blocking_loop>
    return rpc_command_release(CORES_PROTOCOL_CORE);
    56f2:	0020      	movs	r0, r4
    56f4:	f7fc fe9e 	bl	2434 <rpc_command_release>
}
    56f8:	b01b      	add	sp, #108	; 0x6c
    56fa:	bdf0      	pop	{r4, r5, r6, r7, pc}

000056fc <command_set_power_band_class>:
{
    56fc:	b5f0      	push	{r4, r5, r6, r7, lr}
    56fe:	270f      	movs	r7, #15
    5700:	b08f      	sub	sp, #60	; 0x3c
    info.num_sections = 1;
    5702:	2401      	movs	r4, #1
{
    5704:	000b      	movs	r3, r1
    5706:	0011      	movs	r1, r2
    5708:	466a      	mov	r2, sp
    570a:	446f      	add	r7, sp
    570c:	7393      	strb	r3, [r2, #14]
    570e:	7038      	strb	r0, [r7, #0]
    rpc_init_receive_section(&get_sections[0], (uint8 *)set_result, sizeof(uint8), NULL);
    5710:	2300      	movs	r3, #0
    info.sections = get_sections;
    5712:	a807      	add	r0, sp, #28
    info.num_sections = 1;
    5714:	ae05      	add	r6, sp, #20
    rpc_init_receive_section(&get_sections[0], (uint8 *)set_result, sizeof(uint8), NULL);
    5716:	0022      	movs	r2, r4
    info.sections = get_sections;
    5718:	9005      	str	r0, [sp, #20]
    info.num_sections = 1;
    571a:	7134      	strb	r4, [r6, #4]
    rpc_init_receive_section(&get_sections[0], (uint8 *)set_result, sizeof(uint8), NULL);
    571c:	f7fc fe6f 	bl	23fe <rpc_init_receive_section>
    data_to_send[1].data_location = (uint8 *)&power_class;
    5720:	230e      	movs	r3, #14
    data_to_send[0].data_location = (uint8 *)&band;
    5722:	ad0a      	add	r5, sp, #40	; 0x28
    data_to_send[1].data_location = (uint8 *)&power_class;
    5724:	446b      	add	r3, sp
    RPC_ERR rpc_return = rpc_command_claim(CORES_PROTOCOL_CORE);
    5726:	0020      	movs	r0, r4
    data_to_send[0].data_location = (uint8 *)&band;
    5728:	970a      	str	r7, [sp, #40]	; 0x28
    data_to_send[0].data_length = sizeof(band);
    572a:	80ac      	strh	r4, [r5, #4]
    data_to_send[1].data_location = (uint8 *)&power_class;
    572c:	930c      	str	r3, [sp, #48]	; 0x30
    data_to_send[1].data_length = sizeof(power_class);
    572e:	81ac      	strh	r4, [r5, #12]
    RPC_ERR rpc_return = rpc_command_claim(CORES_PROTOCOL_CORE);
    5730:	f7fc fe94 	bl	245c <rpc_command_claim>
    if (rpc_return != RPC_ERR_OK)
    5734:	2800      	cmp	r0, #0
    5736:	d110      	bne.n	575a <command_set_power_band_class+0x5e>
    set_receive_info(CORES_PROTOCOL_CORE, &info);
    5738:	0031      	movs	r1, r6
    573a:	0020      	movs	r0, r4
    573c:	f7fc fb30 	bl	1da0 <set_receive_info>
    rpc_interface_scatter_send(CORES_PROTOCOL_CORE, RPC_APPLICATION_TO_PROTOCOL_SET_POWER_BAND_CLASS, true, 2, data_to_send);
    5740:	2302      	movs	r3, #2
    5742:	0022      	movs	r2, r4
    5744:	2152      	movs	r1, #82	; 0x52
    5746:	0020      	movs	r0, r4
    5748:	9500      	str	r5, [sp, #0]
    574a:	f7fc fdd9 	bl	2300 <rpc_interface_scatter_send>
    rpc_blocking_loop(CORES_PROTOCOL_CORE);
    574e:	0020      	movs	r0, r4
    5750:	f7fc fe5a 	bl	2408 <rpc_blocking_loop>
    return rpc_command_release(CORES_PROTOCOL_CORE);
    5754:	0020      	movs	r0, r4
    5756:	f7fc fe6d 	bl	2434 <rpc_command_release>
}
    575a:	b00f      	add	sp, #60	; 0x3c
    575c:	bdf0      	pop	{r4, r5, r6, r7, pc}

0000575e <command_get_power_band_class>:
{
    575e:	b570      	push	{r4, r5, r6, lr}
    5760:	240f      	movs	r4, #15
    info.num_sections = 2;
    5762:	2302      	movs	r3, #2
{
    5764:	0015      	movs	r5, r2
    5766:	b08e      	sub	sp, #56	; 0x38
    5768:	446c      	add	r4, sp
    info.num_sections = 2;
    576a:	ae04      	add	r6, sp, #16
{
    576c:	7020      	strb	r0, [r4, #0]
    info.num_sections = 2;
    576e:	7133      	strb	r3, [r6, #4]
    info.sections = get_sections;
    5770:	a808      	add	r0, sp, #32
    rpc_init_receive_section(&get_sections[0], (uint8 *)get_result, sizeof(uint8), NULL);
    5772:	2300      	movs	r3, #0
    5774:	2201      	movs	r2, #1
    info.sections = get_sections;
    5776:	9004      	str	r0, [sp, #16]
    rpc_init_receive_section(&get_sections[0], (uint8 *)get_result, sizeof(uint8), NULL);
    5778:	f7fc fe41 	bl	23fe <rpc_init_receive_section>
    rpc_init_receive_section(&get_sections[1], (uint8 *)power_class, sizeof(uint8), NULL);
    577c:	0029      	movs	r1, r5
    577e:	a80b      	add	r0, sp, #44	; 0x2c
    5780:	2300      	movs	r3, #0
    5782:	2201      	movs	r2, #1
    5784:	f7fc fe3b 	bl	23fe <rpc_init_receive_section>
    data_to_send[0].data_location = (uint8 *)&band;
    5788:	9406      	str	r4, [sp, #24]
    data_to_send[0].data_length = sizeof(band);
    578a:	2401      	movs	r4, #1
    data_to_send[0].data_location = (uint8 *)&band;
    578c:	ad06      	add	r5, sp, #24
    data_to_send[0].data_length = sizeof(band);
    578e:	80ac      	strh	r4, [r5, #4]
    RPC_ERR rpc_return = rpc_command_claim(CORES_PROTOCOL_CORE);
    5790:	0020      	movs	r0, r4
    5792:	f7fc fe63 	bl	245c <rpc_command_claim>
    if (rpc_return != RPC_ERR_OK)
    5796:	2800      	cmp	r0, #0
    5798:	d110      	bne.n	57bc <command_get_power_band_class+0x5e>
    set_receive_info(CORES_PROTOCOL_CORE, &info);
    579a:	0031      	movs	r1, r6
    579c:	0020      	movs	r0, r4
    579e:	f7fc faff 	bl	1da0 <set_receive_info>
    rpc_interface_scatter_send(CORES_PROTOCOL_CORE, RPC_APPLICATION_TO_PROTOCOL_GET_POWER_BAND_CLASS, true, 1, data_to_send);
    57a2:	0023      	movs	r3, r4
    57a4:	0022      	movs	r2, r4
    57a6:	2153      	movs	r1, #83	; 0x53
    57a8:	0020      	movs	r0, r4
    57aa:	9500      	str	r5, [sp, #0]
    57ac:	f7fc fda8 	bl	2300 <rpc_interface_scatter_send>
    rpc_blocking_loop(CORES_PROTOCOL_CORE);
    57b0:	0020      	movs	r0, r4
    57b2:	f7fc fe29 	bl	2408 <rpc_blocking_loop>
    return rpc_command_release(CORES_PROTOCOL_CORE);
    57b6:	0020      	movs	r0, r4
    57b8:	f7fc fe3c 	bl	2434 <rpc_command_release>
}
    57bc:	b00e      	add	sp, #56	; 0x38
    57be:	bd70      	pop	{r4, r5, r6, pc}

000057c0 <command_get_update_status>:
{
    57c0:	b570      	push	{r4, r5, r6, lr}
    info.num_sections = 1;
    57c2:	2501      	movs	r5, #1
{
    57c4:	b088      	sub	sp, #32
    57c6:	0001      	movs	r1, r0
    rpc_init_receive_section(&get_sections[0], (uint8 *)status, sizeof(uint8), NULL);
    57c8:	2300      	movs	r3, #0
    info.sections = get_sections;
    57ca:	a805      	add	r0, sp, #20
    rpc_init_receive_section(&get_sections[0], (uint8 *)status, sizeof(uint8), NULL);
    57cc:	002a      	movs	r2, r5
    info.num_sections = 1;
    57ce:	ae03      	add	r6, sp, #12
    info.sections = get_sections;
    57d0:	9003      	str	r0, [sp, #12]
    info.num_sections = 1;
    57d2:	7135      	strb	r5, [r6, #4]
    rpc_init_receive_section(&get_sections[0], (uint8 *)status, sizeof(uint8), NULL);
    57d4:	f7fc fe13 	bl	23fe <rpc_init_receive_section>
    RPC_ERR rpc_return = rpc_command_claim(CORES_SECURITY_CORE);
    57d8:	2000      	movs	r0, #0
    57da:	f7fc fe3f 	bl	245c <rpc_command_claim>
    57de:	1e04      	subs	r4, r0, #0
    if (rpc_return != RPC_ERR_OK)
    57e0:	d110      	bne.n	5804 <command_get_update_status+0x44>
    set_receive_info(CORES_SECURITY_CORE, &info);
    57e2:	0031      	movs	r1, r6
    57e4:	f7fc fadc 	bl	1da0 <set_receive_info>
    rpc_interface_scatter_send(CORES_SECURITY_CORE, RPC_APPLICATION_TO_SECURITY_GET_UPDATE_STATUS, true, 0, NULL);
    57e8:	0023      	movs	r3, r4
    57ea:	002a      	movs	r2, r5
    57ec:	211d      	movs	r1, #29
    57ee:	0020      	movs	r0, r4
    57f0:	9400      	str	r4, [sp, #0]
    57f2:	f7fc fd85 	bl	2300 <rpc_interface_scatter_send>
    rpc_blocking_loop(CORES_SECURITY_CORE);
    57f6:	0020      	movs	r0, r4
    57f8:	f7fc fe06 	bl	2408 <rpc_blocking_loop>
    return rpc_command_release(CORES_SECURITY_CORE);
    57fc:	0020      	movs	r0, r4
    57fe:	f7fc fe19 	bl	2434 <rpc_command_release>
    5802:	0004      	movs	r4, r0
}
    5804:	0020      	movs	r0, r4
    5806:	b008      	add	sp, #32
    5808:	bd70      	pop	{r4, r5, r6, pc}

0000580a <command_set_initial_pdp_context>:
{
    580a:	b5f0      	push	{r4, r5, r6, r7, lr}
    580c:	270f      	movs	r7, #15
    info.num_sections = 1;
    580e:	2401      	movs	r4, #1
{
    5810:	b08d      	sub	sp, #52	; 0x34
    5812:	446f      	add	r7, sp
    5814:	7038      	strb	r0, [r7, #0]
    info.num_sections = 1;
    5816:	ae05      	add	r6, sp, #20
    info.sections = get_sections;
    5818:	a809      	add	r0, sp, #36	; 0x24
    rpc_init_receive_section(&get_sections[0], (uint8 *)result, sizeof(uint8), NULL);
    581a:	2300      	movs	r3, #0
    581c:	0022      	movs	r2, r4
    info.sections = get_sections;
    581e:	9005      	str	r0, [sp, #20]
    info.num_sections = 1;
    5820:	7134      	strb	r4, [r6, #4]
    data_to_send[0].data_location = (uint8 *)&attach_without_pdn;
    5822:	ad07      	add	r5, sp, #28
    rpc_init_receive_section(&get_sections[0], (uint8 *)result, sizeof(uint8), NULL);
    5824:	f7fc fdeb 	bl	23fe <rpc_init_receive_section>
    RPC_ERR rpc_return = rpc_command_claim(CORES_PROTOCOL_CORE);
    5828:	0020      	movs	r0, r4
    data_to_send[0].data_location = (uint8 *)&attach_without_pdn;
    582a:	9707      	str	r7, [sp, #28]
    data_to_send[0].data_length = sizeof(attach_without_pdn);
    582c:	80ac      	strh	r4, [r5, #4]
    RPC_ERR rpc_return = rpc_command_claim(CORES_PROTOCOL_CORE);
    582e:	f7fc fe15 	bl	245c <rpc_command_claim>
    if (rpc_return != RPC_ERR_OK)
    5832:	2800      	cmp	r0, #0
    5834:	d110      	bne.n	5858 <command_set_initial_pdp_context+0x4e>
    set_receive_info(CORES_PROTOCOL_CORE, &info);
    5836:	0031      	movs	r1, r6
    5838:	0020      	movs	r0, r4
    583a:	f7fc fab1 	bl	1da0 <set_receive_info>
    rpc_interface_scatter_send(CORES_PROTOCOL_CORE, RPC_APPLICATION_TO_PROTOCOL_SET_INITIAL_PDP_CONTEXT, true, 1, data_to_send);
    583e:	0023      	movs	r3, r4
    5840:	0022      	movs	r2, r4
    5842:	2154      	movs	r1, #84	; 0x54
    5844:	0020      	movs	r0, r4
    5846:	9500      	str	r5, [sp, #0]
    5848:	f7fc fd5a 	bl	2300 <rpc_interface_scatter_send>
    rpc_blocking_loop(CORES_PROTOCOL_CORE);
    584c:	0020      	movs	r0, r4
    584e:	f7fc fddb 	bl	2408 <rpc_blocking_loop>
    return rpc_command_release(CORES_PROTOCOL_CORE);
    5852:	0020      	movs	r0, r4
    5854:	f7fc fdee 	bl	2434 <rpc_command_release>
}
    5858:	b00d      	add	sp, #52	; 0x34
    585a:	bdf0      	pop	{r4, r5, r6, r7, pc}

0000585c <command_get_initial_pdp_context>:
{
    585c:	b570      	push	{r4, r5, r6, lr}
    info.num_sections = 2;
    585e:	2302      	movs	r3, #2
{
    5860:	0006      	movs	r6, r0
    5862:	000c      	movs	r4, r1
    5864:	b08a      	sub	sp, #40	; 0x28
    info.num_sections = 2;
    5866:	ad02      	add	r5, sp, #8
    info.sections = get_sections;
    5868:	a804      	add	r0, sp, #16
    info.num_sections = 2;
    586a:	712b      	strb	r3, [r5, #4]
    rpc_init_receive_section(&get_sections[0], (uint8 *)result, sizeof(uint8), NULL);
    586c:	2201      	movs	r2, #1
    586e:	2300      	movs	r3, #0
    5870:	0031      	movs	r1, r6
    info.sections = get_sections;
    5872:	9002      	str	r0, [sp, #8]
    rpc_init_receive_section(&get_sections[0], (uint8 *)result, sizeof(uint8), NULL);
    5874:	f7fc fdc3 	bl	23fe <rpc_init_receive_section>
    rpc_init_receive_section(&get_sections[1], (uint8 *)attach_without_pdn, sizeof(uint8), NULL);
    5878:	0021      	movs	r1, r4
    587a:	2300      	movs	r3, #0
    587c:	2201      	movs	r2, #1
    587e:	a807      	add	r0, sp, #28
    5880:	f7fc fdbd 	bl	23fe <rpc_init_receive_section>
    RPC_ERR rpc_return = rpc_command_claim(CORES_PROTOCOL_CORE);
    5884:	2001      	movs	r0, #1
    5886:	f7fc fde9 	bl	245c <rpc_command_claim>
    588a:	1e04      	subs	r4, r0, #0
    if (rpc_return != RPC_ERR_OK)
    588c:	d111      	bne.n	58b2 <command_get_initial_pdp_context+0x56>
    set_receive_info(CORES_PROTOCOL_CORE, &info);
    588e:	0029      	movs	r1, r5
    5890:	2001      	movs	r0, #1
    5892:	f7fc fa85 	bl	1da0 <set_receive_info>
    rpc_interface_scatter_send(CORES_PROTOCOL_CORE, RPC_APPLICATION_TO_PROTOCOL_GET_INITIAL_PDP_CONTEXT, true, 0, NULL);
    5896:	2201      	movs	r2, #1
    5898:	0023      	movs	r3, r4
    589a:	0010      	movs	r0, r2
    589c:	2155      	movs	r1, #85	; 0x55
    589e:	9400      	str	r4, [sp, #0]
    58a0:	f7fc fd2e 	bl	2300 <rpc_interface_scatter_send>
    rpc_blocking_loop(CORES_PROTOCOL_CORE);
    58a4:	2001      	movs	r0, #1
    58a6:	f7fc fdaf 	bl	2408 <rpc_blocking_loop>
    return rpc_command_release(CORES_PROTOCOL_CORE);
    58aa:	2001      	movs	r0, #1
    58ac:	f7fc fdc2 	bl	2434 <rpc_command_release>
    58b0:	0004      	movs	r4, r0
}
    58b2:	0020      	movs	r0, r4
    58b4:	b00a      	add	sp, #40	; 0x28
    58b6:	bd70      	pop	{r4, r5, r6, pc}

000058b8 <command_radio_config_tx_test>:
{
    58b8:	b5f0      	push	{r4, r5, r6, r7, lr}
    58ba:	b093      	sub	sp, #76	; 0x4c
    info.num_sections = 1;
    58bc:	2401      	movs	r4, #1
{
    58be:	9003      	str	r0, [sp, #12]
    58c0:	4668      	mov	r0, sp
    info.num_sections = 1;
    58c2:	af05      	add	r7, sp, #20
{
    58c4:	72c1      	strb	r1, [r0, #11]
    58c6:	7282      	strb	r2, [r0, #10]
    58c8:	7243      	strb	r3, [r0, #9]
    rpc_init_receive_section(&get_sections[0], (uint8 *)result, sizeof(uint8), NULL);
    58ca:	0022      	movs	r2, r4
    info.sections = get_sections;
    58cc:	a807      	add	r0, sp, #28
    rpc_init_receive_section(&get_sections[0], (uint8 *)result, sizeof(uint8), NULL);
    58ce:	2300      	movs	r3, #0
    58d0:	9918      	ldr	r1, [sp, #96]	; 0x60
    info.sections = get_sections;
    58d2:	9005      	str	r0, [sp, #20]
    info.num_sections = 1;
    58d4:	713c      	strb	r4, [r7, #4]
    rpc_init_receive_section(&get_sections[0], (uint8 *)result, sizeof(uint8), NULL);
    58d6:	f7fc fd92 	bl	23fe <rpc_init_receive_section>
    data_to_send[0].data_location = (uint8 *)&tx_frequency;
    58da:	ab03      	add	r3, sp, #12
    58dc:	930a      	str	r3, [sp, #40]	; 0x28
    data_to_send[1].data_location = (uint8 *)&tx_band;
    58de:	230b      	movs	r3, #11
    58e0:	446b      	add	r3, sp
    58e2:	930c      	str	r3, [sp, #48]	; 0x30
    data_to_send[2].data_location = (uint8 *)&num_subcarrier;
    58e4:	230a      	movs	r3, #10
    58e6:	446b      	add	r3, sp
    58e8:	930e      	str	r3, [sp, #56]	; 0x38
    data_to_send[3].data_location = (uint8 *)&subcarrier_index;
    58ea:	2309      	movs	r3, #9
    data_to_send[0].data_length = sizeof(tx_frequency);
    58ec:	2604      	movs	r6, #4
    data_to_send[0].data_location = (uint8 *)&tx_frequency;
    58ee:	ad0a      	add	r5, sp, #40	; 0x28
    data_to_send[3].data_location = (uint8 *)&subcarrier_index;
    58f0:	446b      	add	r3, sp
    RPC_ERR rpc_return = rpc_command_claim(CORES_PROTOCOL_CORE);
    58f2:	0020      	movs	r0, r4
    data_to_send[0].data_length = sizeof(tx_frequency);
    58f4:	80ae      	strh	r6, [r5, #4]
    data_to_send[1].data_length = sizeof(tx_band);
    58f6:	81ac      	strh	r4, [r5, #12]
    data_to_send[2].data_length = sizeof(num_subcarrier);
    58f8:	82ac      	strh	r4, [r5, #20]
    data_to_send[3].data_location = (uint8 *)&subcarrier_index;
    58fa:	9310      	str	r3, [sp, #64]	; 0x40
    data_to_send[3].data_length = sizeof(subcarrier_index);
    58fc:	83ac      	strh	r4, [r5, #28]
    RPC_ERR rpc_return = rpc_command_claim(CORES_PROTOCOL_CORE);
    58fe:	f7fc fdad 	bl	245c <rpc_command_claim>
    if (rpc_return != RPC_ERR_OK)
    5902:	2800      	cmp	r0, #0
    5904:	d110      	bne.n	5928 <command_radio_config_tx_test+0x70>
    set_receive_info(CORES_PROTOCOL_CORE, &info);
    5906:	0039      	movs	r1, r7
    5908:	0020      	movs	r0, r4
    590a:	f7fc fa49 	bl	1da0 <set_receive_info>
    rpc_interface_scatter_send(CORES_PROTOCOL_CORE, RPC_APPLICATION_TO_PROTOCOL_RADIO_CONFIG_TX_TEST, true, 4, data_to_send);
    590e:	0033      	movs	r3, r6
    5910:	0022      	movs	r2, r4
    5912:	2156      	movs	r1, #86	; 0x56
    5914:	0020      	movs	r0, r4
    5916:	9500      	str	r5, [sp, #0]
    5918:	f7fc fcf2 	bl	2300 <rpc_interface_scatter_send>
    rpc_blocking_loop(CORES_PROTOCOL_CORE);
    591c:	0020      	movs	r0, r4
    591e:	f7fc fd73 	bl	2408 <rpc_blocking_loop>
    return rpc_command_release(CORES_PROTOCOL_CORE);
    5922:	0020      	movs	r0, r4
    5924:	f7fc fd86 	bl	2434 <rpc_command_release>
}
    5928:	b013      	add	sp, #76	; 0x4c
    592a:	bdf0      	pop	{r4, r5, r6, r7, pc}

0000592c <command_iflog_cache_register>:
{
    592c:	b5f0      	push	{r4, r5, r6, r7, lr}
    info.num_sections = 1;
    592e:	2501      	movs	r5, #1
{
    5930:	b08d      	sub	sp, #52	; 0x34
    5932:	9003      	str	r0, [sp, #12]
    rpc_init_receive_section(&get_sections[0], (uint8 *)result, sizeof(uint8), NULL);
    5934:	2300      	movs	r3, #0
    info.sections = get_sections;
    5936:	a809      	add	r0, sp, #36	; 0x24
    rpc_init_receive_section(&get_sections[0], (uint8 *)result, sizeof(uint8), NULL);
    5938:	002a      	movs	r2, r5
    info.num_sections = 1;
    593a:	af05      	add	r7, sp, #20
    info.sections = get_sections;
    593c:	9005      	str	r0, [sp, #20]
    info.num_sections = 1;
    593e:	713d      	strb	r5, [r7, #4]
    rpc_init_receive_section(&get_sections[0], (uint8 *)result, sizeof(uint8), NULL);
    5940:	f7fc fd5d 	bl	23fe <rpc_init_receive_section>
    data_to_send[0].data_location = (uint8 *)&cache;
    5944:	ab03      	add	r3, sp, #12
    5946:	9307      	str	r3, [sp, #28]
    data_to_send[0].data_length = sizeof(cache);
    5948:	2304      	movs	r3, #4
    data_to_send[0].data_location = (uint8 *)&cache;
    594a:	ae07      	add	r6, sp, #28
    RPC_ERR rpc_return = rpc_command_claim(CORES_SECURITY_CORE);
    594c:	2000      	movs	r0, #0
    data_to_send[0].data_length = sizeof(cache);
    594e:	80b3      	strh	r3, [r6, #4]
    RPC_ERR rpc_return = rpc_command_claim(CORES_SECURITY_CORE);
    5950:	f7fc fd84 	bl	245c <rpc_command_claim>
    5954:	1e04      	subs	r4, r0, #0
    if (rpc_return != RPC_ERR_OK)
    5956:	d110      	bne.n	597a <command_iflog_cache_register+0x4e>
    set_receive_info(CORES_SECURITY_CORE, &info);
    5958:	0039      	movs	r1, r7
    595a:	f7fc fa21 	bl	1da0 <set_receive_info>
    rpc_interface_scatter_send(CORES_SECURITY_CORE, RPC_APPLICATION_TO_SECURITY_IFLOG_CACHE_REGISTER, true, 1, data_to_send);
    595e:	002b      	movs	r3, r5
    5960:	002a      	movs	r2, r5
    5962:	211f      	movs	r1, #31
    5964:	0020      	movs	r0, r4
    5966:	9600      	str	r6, [sp, #0]
    5968:	f7fc fcca 	bl	2300 <rpc_interface_scatter_send>
    rpc_blocking_loop(CORES_SECURITY_CORE);
    596c:	0020      	movs	r0, r4
    596e:	f7fc fd4b 	bl	2408 <rpc_blocking_loop>
    return rpc_command_release(CORES_SECURITY_CORE);
    5972:	0020      	movs	r0, r4
    5974:	f7fc fd5e 	bl	2434 <rpc_command_release>
    5978:	0004      	movs	r4, r0
}
    597a:	0020      	movs	r0, r4
    597c:	b00d      	add	sp, #52	; 0x34
    597e:	bdf0      	pop	{r4, r5, r6, r7, pc}

00005980 <command_iflog_iflash_write>:
{
    5980:	b5f0      	push	{r4, r5, r6, r7, lr}
    5982:	240e      	movs	r4, #14
    5984:	b08f      	sub	sp, #60	; 0x3c
    5986:	000b      	movs	r3, r1
    info.num_sections = 1;
    5988:	2601      	movs	r6, #1
{
    598a:	0011      	movs	r1, r2
    598c:	466a      	mov	r2, sp
    data_to_send[0].data_length = sizeof(index);
    598e:	2702      	movs	r7, #2
{
    5990:	446c      	add	r4, sp
    5992:	8020      	strh	r0, [r4, #0]
    5994:	8193      	strh	r3, [r2, #12]
    info.sections = get_sections;
    5996:	a807      	add	r0, sp, #28
    info.num_sections = 1;
    5998:	7616      	strb	r6, [r2, #24]
    rpc_init_receive_section(&get_sections[0], (uint8 *)result, sizeof(uint8), NULL);
    599a:	2300      	movs	r3, #0
    599c:	0032      	movs	r2, r6
    info.sections = get_sections;
    599e:	9005      	str	r0, [sp, #20]
    data_to_send[0].data_location = (uint8 *)&index;
    59a0:	ad0a      	add	r5, sp, #40	; 0x28
    rpc_init_receive_section(&get_sections[0], (uint8 *)result, sizeof(uint8), NULL);
    59a2:	f7fc fd2c 	bl	23fe <rpc_init_receive_section>
    data_to_send[1].data_location = (uint8 *)&len;
    59a6:	ab03      	add	r3, sp, #12
    RPC_ERR rpc_return = rpc_command_claim(CORES_SECURITY_CORE);
    59a8:	2000      	movs	r0, #0
    data_to_send[0].data_location = (uint8 *)&index;
    59aa:	940a      	str	r4, [sp, #40]	; 0x28
    data_to_send[0].data_length = sizeof(index);
    59ac:	80af      	strh	r7, [r5, #4]
    data_to_send[1].data_location = (uint8 *)&len;
    59ae:	930c      	str	r3, [sp, #48]	; 0x30
    data_to_send[1].data_length = sizeof(len);
    59b0:	81af      	strh	r7, [r5, #12]
    RPC_ERR rpc_return = rpc_command_claim(CORES_SECURITY_CORE);
    59b2:	f7fc fd53 	bl	245c <rpc_command_claim>
    59b6:	1e04      	subs	r4, r0, #0
    if (rpc_return != RPC_ERR_OK)
    59b8:	d110      	bne.n	59dc <command_iflog_iflash_write+0x5c>
    set_receive_info(CORES_SECURITY_CORE, &info);
    59ba:	a905      	add	r1, sp, #20
    59bc:	f7fc f9f0 	bl	1da0 <set_receive_info>
    rpc_interface_scatter_send(CORES_SECURITY_CORE, RPC_APPLICATION_TO_SECURITY_IFLOG_IFLASH_WRITE, true, 2, data_to_send);
    59c0:	003b      	movs	r3, r7
    59c2:	0032      	movs	r2, r6
    59c4:	2120      	movs	r1, #32
    59c6:	0020      	movs	r0, r4
    59c8:	9500      	str	r5, [sp, #0]
    59ca:	f7fc fc99 	bl	2300 <rpc_interface_scatter_send>
    rpc_blocking_loop(CORES_SECURITY_CORE);
    59ce:	0020      	movs	r0, r4
    59d0:	f7fc fd1a 	bl	2408 <rpc_blocking_loop>
    return rpc_command_release(CORES_SECURITY_CORE);
    59d4:	0020      	movs	r0, r4
    59d6:	f7fc fd2d 	bl	2434 <rpc_command_release>
    59da:	0004      	movs	r4, r0
}
    59dc:	0020      	movs	r0, r4
    59de:	b00f      	add	sp, #60	; 0x3c
    59e0:	bdf0      	pop	{r4, r5, r6, r7, pc}

000059e2 <command_iflog_iflash_read>:
{
    59e2:	b5f0      	push	{r4, r5, r6, r7, lr}
    59e4:	240a      	movs	r4, #10
    59e6:	b091      	sub	sp, #68	; 0x44
    59e8:	9003      	str	r0, [sp, #12]
    59ea:	0008      	movs	r0, r1
    59ec:	001e      	movs	r6, r3
    info.num_sections = 2;
    59ee:	2502      	movs	r5, #2
{
    59f0:	446c      	add	r4, sp
    59f2:	0011      	movs	r1, r2
    59f4:	8020      	strh	r0, [r4, #0]
    rpc_init_receive_section(&get_sections[0], (uint8 *)result, sizeof(uint8), NULL);
    59f6:	2300      	movs	r3, #0
    info.sections = get_sections;
    59f8:	a80a      	add	r0, sp, #40	; 0x28
    rpc_init_receive_section(&get_sections[0], (uint8 *)result, sizeof(uint8), NULL);
    59fa:	2201      	movs	r2, #1
    info.num_sections = 2;
    59fc:	af04      	add	r7, sp, #16
    info.sections = get_sections;
    59fe:	9004      	str	r0, [sp, #16]
    info.num_sections = 2;
    5a00:	713d      	strb	r5, [r7, #4]
    rpc_init_receive_section(&get_sections[0], (uint8 *)result, sizeof(uint8), NULL);
    5a02:	f7fc fcfc 	bl	23fe <rpc_init_receive_section>
    rpc_init_receive_section(&get_sections[1], (uint8 *)len, sizeof(uint16), NULL);
    5a06:	0031      	movs	r1, r6
    5a08:	2300      	movs	r3, #0
    5a0a:	002a      	movs	r2, r5
    5a0c:	a80d      	add	r0, sp, #52	; 0x34
    5a0e:	f7fc fcf6 	bl	23fe <rpc_init_receive_section>
    data_to_send[0].data_location = (uint8 *)&buff;
    5a12:	ab03      	add	r3, sp, #12
    5a14:	9306      	str	r3, [sp, #24]
    data_to_send[0].data_length = sizeof(buff);
    5a16:	2304      	movs	r3, #4
    data_to_send[0].data_location = (uint8 *)&buff;
    5a18:	ae06      	add	r6, sp, #24
    data_to_send[0].data_length = sizeof(buff);
    5a1a:	80b3      	strh	r3, [r6, #4]
    data_to_send[1].data_length = sizeof(buff_size);
    5a1c:	81b5      	strh	r5, [r6, #12]
    RPC_ERR rpc_return = rpc_command_claim(CORES_SECURITY_CORE);
    5a1e:	2000      	movs	r0, #0
    data_to_send[1].data_location = (uint8 *)&buff_size;
    5a20:	9408      	str	r4, [sp, #32]
    RPC_ERR rpc_return = rpc_command_claim(CORES_SECURITY_CORE);
    5a22:	f7fc fd1b 	bl	245c <rpc_command_claim>
    5a26:	1e04      	subs	r4, r0, #0
    if (rpc_return != RPC_ERR_OK)
    5a28:	d110      	bne.n	5a4c <command_iflog_iflash_read+0x6a>
    set_receive_info(CORES_SECURITY_CORE, &info);
    5a2a:	0039      	movs	r1, r7
    5a2c:	f7fc f9b8 	bl	1da0 <set_receive_info>
    rpc_interface_scatter_send(CORES_SECURITY_CORE, RPC_APPLICATION_TO_SECURITY_IFLOG_IFLASH_READ, true, 2, data_to_send);
    5a30:	002b      	movs	r3, r5
    5a32:	2201      	movs	r2, #1
    5a34:	2121      	movs	r1, #33	; 0x21
    5a36:	0020      	movs	r0, r4
    5a38:	9600      	str	r6, [sp, #0]
    5a3a:	f7fc fc61 	bl	2300 <rpc_interface_scatter_send>
    rpc_blocking_loop(CORES_SECURITY_CORE);
    5a3e:	0020      	movs	r0, r4
    5a40:	f7fc fce2 	bl	2408 <rpc_blocking_loop>
    return rpc_command_release(CORES_SECURITY_CORE);
    5a44:	0020      	movs	r0, r4
    5a46:	f7fc fcf5 	bl	2434 <rpc_command_release>
    5a4a:	0004      	movs	r4, r0
}
    5a4c:	0020      	movs	r0, r4
    5a4e:	b011      	add	sp, #68	; 0x44
    5a50:	bdf0      	pop	{r4, r5, r6, r7, pc}

00005a52 <command_update_package_allocate_flash>:
{
    5a52:	b5f0      	push	{r4, r5, r6, r7, lr}
    info.num_sections = 1;
    5a54:	2501      	movs	r5, #1
{
    5a56:	b08d      	sub	sp, #52	; 0x34
    5a58:	9003      	str	r0, [sp, #12]
    rpc_init_receive_section(&get_sections[0], (uint8 *)allocated, sizeof(bool), NULL);
    5a5a:	2300      	movs	r3, #0
    info.sections = get_sections;
    5a5c:	a809      	add	r0, sp, #36	; 0x24
    rpc_init_receive_section(&get_sections[0], (uint8 *)allocated, sizeof(bool), NULL);
    5a5e:	002a      	movs	r2, r5
    info.num_sections = 1;
    5a60:	af05      	add	r7, sp, #20
    info.sections = get_sections;
    5a62:	9005      	str	r0, [sp, #20]
    info.num_sections = 1;
    5a64:	713d      	strb	r5, [r7, #4]
    rpc_init_receive_section(&get_sections[0], (uint8 *)allocated, sizeof(bool), NULL);
    5a66:	f7fc fcca 	bl	23fe <rpc_init_receive_section>
    data_to_send[0].data_location = (uint8 *)&update_package_size;
    5a6a:	ab03      	add	r3, sp, #12
    5a6c:	9307      	str	r3, [sp, #28]
    data_to_send[0].data_length = sizeof(update_package_size);
    5a6e:	2304      	movs	r3, #4
    data_to_send[0].data_location = (uint8 *)&update_package_size;
    5a70:	ae07      	add	r6, sp, #28
    RPC_ERR rpc_return = rpc_command_claim(CORES_SECURITY_CORE);
    5a72:	2000      	movs	r0, #0
    data_to_send[0].data_length = sizeof(update_package_size);
    5a74:	80b3      	strh	r3, [r6, #4]
    RPC_ERR rpc_return = rpc_command_claim(CORES_SECURITY_CORE);
    5a76:	f7fc fcf1 	bl	245c <rpc_command_claim>
    5a7a:	1e04      	subs	r4, r0, #0
    if (rpc_return != RPC_ERR_OK)
    5a7c:	d110      	bne.n	5aa0 <command_update_package_allocate_flash+0x4e>
    set_receive_info(CORES_SECURITY_CORE, &info);
    5a7e:	0039      	movs	r1, r7
    5a80:	f7fc f98e 	bl	1da0 <set_receive_info>
    rpc_interface_scatter_send(CORES_SECURITY_CORE, RPC_APPLICATION_TO_SECURITY_UPDATE_PACKAGE_ALLOCATE_FLASH, true, 1, data_to_send);
    5a84:	002b      	movs	r3, r5
    5a86:	002a      	movs	r2, r5
    5a88:	2122      	movs	r1, #34	; 0x22
    5a8a:	0020      	movs	r0, r4
    5a8c:	9600      	str	r6, [sp, #0]
    5a8e:	f7fc fc37 	bl	2300 <rpc_interface_scatter_send>
    rpc_blocking_loop(CORES_SECURITY_CORE);
    5a92:	0020      	movs	r0, r4
    5a94:	f7fc fcb8 	bl	2408 <rpc_blocking_loop>
    return rpc_command_release(CORES_SECURITY_CORE);
    5a98:	0020      	movs	r0, r4
    5a9a:	f7fc fccb 	bl	2434 <rpc_command_release>
    5a9e:	0004      	movs	r4, r0
}
    5aa0:	0020      	movs	r0, r4
    5aa2:	b00d      	add	sp, #52	; 0x34
    5aa4:	bdf0      	pop	{r4, r5, r6, r7, pc}

00005aa6 <command_abort_processing_command>:
{
    5aa6:	b570      	push	{r4, r5, r6, lr}
    info.num_sections = 1;
    5aa8:	2401      	movs	r4, #1
{
    5aaa:	b088      	sub	sp, #32
    5aac:	0001      	movs	r1, r0
    rpc_init_receive_section(&get_sections[0], (uint8 *)result, sizeof(uint8), NULL);
    5aae:	2300      	movs	r3, #0
    info.sections = get_sections;
    5ab0:	a805      	add	r0, sp, #20
    rpc_init_receive_section(&get_sections[0], (uint8 *)result, sizeof(uint8), NULL);
    5ab2:	0022      	movs	r2, r4
    info.num_sections = 1;
    5ab4:	ae03      	add	r6, sp, #12
    info.sections = get_sections;
    5ab6:	9003      	str	r0, [sp, #12]
    info.num_sections = 1;
    5ab8:	7134      	strb	r4, [r6, #4]
    rpc_init_receive_section(&get_sections[0], (uint8 *)result, sizeof(uint8), NULL);
    5aba:	f7fc fca0 	bl	23fe <rpc_init_receive_section>
    RPC_ERR rpc_return = rpc_command_claim(CORES_PROTOCOL_CORE);
    5abe:	0020      	movs	r0, r4
    5ac0:	f7fc fccc 	bl	245c <rpc_command_claim>
    5ac4:	1e05      	subs	r5, r0, #0
    if (rpc_return != RPC_ERR_OK)
    5ac6:	d111      	bne.n	5aec <command_abort_processing_command+0x46>
    set_receive_info(CORES_PROTOCOL_CORE, &info);
    5ac8:	0031      	movs	r1, r6
    5aca:	0020      	movs	r0, r4
    5acc:	f7fc f968 	bl	1da0 <set_receive_info>
    rpc_interface_scatter_send(CORES_PROTOCOL_CORE, RPC_APPLICATION_TO_PROTOCOL_ABORT_PROCESSING_COMMAND, true, 0, NULL);
    5ad0:	002b      	movs	r3, r5
    5ad2:	0022      	movs	r2, r4
    5ad4:	2157      	movs	r1, #87	; 0x57
    5ad6:	9500      	str	r5, [sp, #0]
    5ad8:	0020      	movs	r0, r4
    5ada:	f7fc fc11 	bl	2300 <rpc_interface_scatter_send>
    rpc_blocking_loop(CORES_PROTOCOL_CORE);
    5ade:	0020      	movs	r0, r4
    5ae0:	f7fc fc92 	bl	2408 <rpc_blocking_loop>
    return rpc_command_release(CORES_PROTOCOL_CORE);
    5ae4:	0020      	movs	r0, r4
    5ae6:	f7fc fca5 	bl	2434 <rpc_command_release>
    5aea:	0005      	movs	r5, r0
}
    5aec:	0028      	movs	r0, r5
    5aee:	b008      	add	sp, #32
    5af0:	bd70      	pop	{r4, r5, r6, pc}

00005af2 <command_set_network_config>:
{
    5af2:	b5f0      	push	{r4, r5, r6, r7, lr}
    5af4:	260e      	movs	r6, #14
    5af6:	b08f      	sub	sp, #60	; 0x3c
    5af8:	000b      	movs	r3, r1
    info.num_sections = 1;
    5afa:	2401      	movs	r4, #1
{
    5afc:	0011      	movs	r1, r2
    5afe:	466a      	mov	r2, sp
    5b00:	446e      	add	r6, sp
    5b02:	8030      	strh	r0, [r6, #0]
    5b04:	8193      	strh	r3, [r2, #12]
    info.sections = get_sections;
    5b06:	a807      	add	r0, sp, #28
    rpc_init_receive_section(&get_sections[0], (uint8 *)result, sizeof(uint8), NULL);
    5b08:	2300      	movs	r3, #0
    info.num_sections = 1;
    5b0a:	af05      	add	r7, sp, #20
    rpc_init_receive_section(&get_sections[0], (uint8 *)result, sizeof(uint8), NULL);
    5b0c:	0022      	movs	r2, r4
    info.sections = get_sections;
    5b0e:	9005      	str	r0, [sp, #20]
    info.num_sections = 1;
    5b10:	713c      	strb	r4, [r7, #4]
    rpc_init_receive_section(&get_sections[0], (uint8 *)result, sizeof(uint8), NULL);
    5b12:	f7fc fc74 	bl	23fe <rpc_init_receive_section>
    data_to_send[0].data_location = (uint8 *)&config;
    5b16:	960a      	str	r6, [sp, #40]	; 0x28
    data_to_send[0].data_length = sizeof(config);
    5b18:	2602      	movs	r6, #2
    data_to_send[0].data_location = (uint8 *)&config;
    5b1a:	ad0a      	add	r5, sp, #40	; 0x28
    data_to_send[1].data_location = (uint8 *)&value;
    5b1c:	ab03      	add	r3, sp, #12
    RPC_ERR rpc_return = rpc_command_claim(CORES_PROTOCOL_CORE);
    5b1e:	0020      	movs	r0, r4
    data_to_send[0].data_length = sizeof(config);
    5b20:	80ae      	strh	r6, [r5, #4]
    data_to_send[1].data_location = (uint8 *)&value;
    5b22:	930c      	str	r3, [sp, #48]	; 0x30
    data_to_send[1].data_length = sizeof(value);
    5b24:	81ae      	strh	r6, [r5, #12]
    RPC_ERR rpc_return = rpc_command_claim(CORES_PROTOCOL_CORE);
    5b26:	f7fc fc99 	bl	245c <rpc_command_claim>
    if (rpc_return != RPC_ERR_OK)
    5b2a:	2800      	cmp	r0, #0
    5b2c:	d110      	bne.n	5b50 <command_set_network_config+0x5e>
    set_receive_info(CORES_PROTOCOL_CORE, &info);
    5b2e:	0039      	movs	r1, r7
    5b30:	0020      	movs	r0, r4
    5b32:	f7fc f935 	bl	1da0 <set_receive_info>
    rpc_interface_scatter_send(CORES_PROTOCOL_CORE, RPC_APPLICATION_TO_PROTOCOL_SET_NETWORK_CONFIG, true, 2, data_to_send);
    5b36:	0033      	movs	r3, r6
    5b38:	0022      	movs	r2, r4
    5b3a:	215a      	movs	r1, #90	; 0x5a
    5b3c:	0020      	movs	r0, r4
    5b3e:	9500      	str	r5, [sp, #0]
    5b40:	f7fc fbde 	bl	2300 <rpc_interface_scatter_send>
    rpc_blocking_loop(CORES_PROTOCOL_CORE);
    5b44:	0020      	movs	r0, r4
    5b46:	f7fc fc5f 	bl	2408 <rpc_blocking_loop>
    return rpc_command_release(CORES_PROTOCOL_CORE);
    5b4a:	0020      	movs	r0, r4
    5b4c:	f7fc fc72 	bl	2434 <rpc_command_release>
}
    5b50:	b00f      	add	sp, #60	; 0x3c
    5b52:	bdf0      	pop	{r4, r5, r6, r7, pc}

00005b54 <command_rai_req>:
{
    5b54:	b507      	push	{r0, r1, r2, lr}
    RPC_ERR rpc_return = rpc_command_claim(CORES_PROTOCOL_CORE);
    5b56:	2001      	movs	r0, #1
    5b58:	f7fc fc80 	bl	245c <rpc_command_claim>
    if (rpc_return != RPC_ERR_OK)
    5b5c:	2800      	cmp	r0, #0
    5b5e:	d10c      	bne.n	5b7a <command_rai_req+0x26>
    rpc_interface_scatter_send(CORES_PROTOCOL_CORE, RPC_APPLICATION_TO_PROTOCOL_RAI_REQ, true, 0, NULL);
    5b60:	2201      	movs	r2, #1
    5b62:	0003      	movs	r3, r0
    5b64:	9000      	str	r0, [sp, #0]
    5b66:	215b      	movs	r1, #91	; 0x5b
    5b68:	0010      	movs	r0, r2
    5b6a:	f7fc fbc9 	bl	2300 <rpc_interface_scatter_send>
    rpc_blocking_loop(CORES_PROTOCOL_CORE);
    5b6e:	2001      	movs	r0, #1
    5b70:	f7fc fc4a 	bl	2408 <rpc_blocking_loop>
    return rpc_command_release(CORES_PROTOCOL_CORE);
    5b74:	2001      	movs	r0, #1
    5b76:	f7fc fc5d 	bl	2434 <rpc_command_release>
}
    5b7a:	bd0e      	pop	{r1, r2, r3, pc}

00005b7c <command_get_dns_server_ip_address>:
{
    5b7c:	b5f0      	push	{r4, r5, r6, r7, lr}
    5b7e:	240f      	movs	r4, #15
    5b80:	001f      	movs	r7, r3
    info.num_sections = 2;
    5b82:	2302      	movs	r3, #2
{
    5b84:	0015      	movs	r5, r2
    5b86:	b08f      	sub	sp, #60	; 0x3c
    5b88:	446c      	add	r4, sp
    info.num_sections = 2;
    5b8a:	ae04      	add	r6, sp, #16
{
    5b8c:	7020      	strb	r0, [r4, #0]
    info.num_sections = 2;
    5b8e:	7133      	strb	r3, [r6, #4]
    info.sections = get_sections;
    5b90:	a808      	add	r0, sp, #32
    rpc_init_receive_section(&get_sections[0], (uint8 *)result, sizeof(uint8), NULL);
    5b92:	2300      	movs	r3, #0
    5b94:	2201      	movs	r2, #1
    info.sections = get_sections;
    5b96:	9004      	str	r0, [sp, #16]
    rpc_init_receive_section(&get_sections[0], (uint8 *)result, sizeof(uint8), NULL);
    5b98:	f7fc fc31 	bl	23fe <rpc_init_receive_section>
    rpc_init_receive_section(&get_sections[1], (uint8 *)dns_server_ip_address_value, dns_server_ip_address_value_max_length, dns_server_ip_address_value_length);
    5b9c:	002a      	movs	r2, r5
    5b9e:	a80b      	add	r0, sp, #44	; 0x2c
    5ba0:	003b      	movs	r3, r7
    5ba2:	9914      	ldr	r1, [sp, #80]	; 0x50
    5ba4:	f7fc fc2b 	bl	23fe <rpc_init_receive_section>
    data_to_send[0].data_location = (uint8 *)&cid;
    5ba8:	9406      	str	r4, [sp, #24]
    data_to_send[0].data_length = sizeof(cid);
    5baa:	2401      	movs	r4, #1
    data_to_send[0].data_location = (uint8 *)&cid;
    5bac:	ad06      	add	r5, sp, #24
    data_to_send[0].data_length = sizeof(cid);
    5bae:	80ac      	strh	r4, [r5, #4]
    RPC_ERR rpc_return = rpc_command_claim(CORES_PROTOCOL_CORE);
    5bb0:	0020      	movs	r0, r4
    5bb2:	f7fc fc53 	bl	245c <rpc_command_claim>
    if (rpc_return != RPC_ERR_OK)
    5bb6:	2800      	cmp	r0, #0
    5bb8:	d110      	bne.n	5bdc <command_get_dns_server_ip_address+0x60>
    set_receive_info(CORES_PROTOCOL_CORE, &info);
    5bba:	0031      	movs	r1, r6
    5bbc:	0020      	movs	r0, r4
    5bbe:	f7fc f8ef 	bl	1da0 <set_receive_info>
    rpc_interface_scatter_send(CORES_PROTOCOL_CORE, RPC_APPLICATION_TO_PROTOCOL_GET_DNS_SERVER_IP_ADDRESS, true, 1, data_to_send);
    5bc2:	0023      	movs	r3, r4
    5bc4:	0022      	movs	r2, r4
    5bc6:	215c      	movs	r1, #92	; 0x5c
    5bc8:	0020      	movs	r0, r4
    5bca:	9500      	str	r5, [sp, #0]
    5bcc:	f7fc fb98 	bl	2300 <rpc_interface_scatter_send>
    rpc_blocking_loop(CORES_PROTOCOL_CORE);
    5bd0:	0020      	movs	r0, r4
    5bd2:	f7fc fc19 	bl	2408 <rpc_blocking_loop>
    return rpc_command_release(CORES_PROTOCOL_CORE);
    5bd6:	0020      	movs	r0, r4
    5bd8:	f7fc fc2c 	bl	2434 <rpc_command_release>
}
    5bdc:	b00f      	add	sp, #60	; 0x3c
    5bde:	bdf0      	pop	{r4, r5, r6, r7, pc}

00005be0 <command_set_pdp_context_dynamic_param_request_state>:
{
    5be0:	b5f0      	push	{r4, r5, r6, r7, lr}
    5be2:	270f      	movs	r7, #15
    5be4:	b08f      	sub	sp, #60	; 0x3c
    info.num_sections = 1;
    5be6:	2401      	movs	r4, #1
{
    5be8:	000b      	movs	r3, r1
    5bea:	0011      	movs	r1, r2
    5bec:	466a      	mov	r2, sp
    5bee:	446f      	add	r7, sp
    5bf0:	7393      	strb	r3, [r2, #14]
    5bf2:	7038      	strb	r0, [r7, #0]
    rpc_init_receive_section(&get_sections[0], (uint8 *)result, sizeof(uint8), NULL);
    5bf4:	2300      	movs	r3, #0
    info.sections = get_sections;
    5bf6:	a807      	add	r0, sp, #28
    info.num_sections = 1;
    5bf8:	ae05      	add	r6, sp, #20
    rpc_init_receive_section(&get_sections[0], (uint8 *)result, sizeof(uint8), NULL);
    5bfa:	0022      	movs	r2, r4
    info.sections = get_sections;
    5bfc:	9005      	str	r0, [sp, #20]
    info.num_sections = 1;
    5bfe:	7134      	strb	r4, [r6, #4]
    rpc_init_receive_section(&get_sections[0], (uint8 *)result, sizeof(uint8), NULL);
    5c00:	f7fc fbfd 	bl	23fe <rpc_init_receive_section>
    data_to_send[1].data_location = (uint8 *)&state;
    5c04:	230e      	movs	r3, #14
    data_to_send[0].data_location = (uint8 *)&param_item;
    5c06:	ad0a      	add	r5, sp, #40	; 0x28
    data_to_send[1].data_location = (uint8 *)&state;
    5c08:	446b      	add	r3, sp
    RPC_ERR rpc_return = rpc_command_claim(CORES_PROTOCOL_CORE);
    5c0a:	0020      	movs	r0, r4
    data_to_send[0].data_location = (uint8 *)&param_item;
    5c0c:	970a      	str	r7, [sp, #40]	; 0x28
    data_to_send[0].data_length = sizeof(param_item);
    5c0e:	80ac      	strh	r4, [r5, #4]
    data_to_send[1].data_location = (uint8 *)&state;
    5c10:	930c      	str	r3, [sp, #48]	; 0x30
    data_to_send[1].data_length = sizeof(state);
    5c12:	81ac      	strh	r4, [r5, #12]
    RPC_ERR rpc_return = rpc_command_claim(CORES_PROTOCOL_CORE);
    5c14:	f7fc fc22 	bl	245c <rpc_command_claim>
    if (rpc_return != RPC_ERR_OK)
    5c18:	2800      	cmp	r0, #0
    5c1a:	d110      	bne.n	5c3e <command_set_pdp_context_dynamic_param_request_state+0x5e>
    set_receive_info(CORES_PROTOCOL_CORE, &info);
    5c1c:	0031      	movs	r1, r6
    5c1e:	0020      	movs	r0, r4
    5c20:	f7fc f8be 	bl	1da0 <set_receive_info>
    rpc_interface_scatter_send(CORES_PROTOCOL_CORE, RPC_APPLICATION_TO_PROTOCOL_SET_PDP_CONTEXT_DYNAMIC_PARAM_REQUEST_STATE, true, 2, data_to_send);
    5c24:	2302      	movs	r3, #2
    5c26:	0022      	movs	r2, r4
    5c28:	215d      	movs	r1, #93	; 0x5d
    5c2a:	0020      	movs	r0, r4
    5c2c:	9500      	str	r5, [sp, #0]
    5c2e:	f7fc fb67 	bl	2300 <rpc_interface_scatter_send>
    rpc_blocking_loop(CORES_PROTOCOL_CORE);
    5c32:	0020      	movs	r0, r4
    5c34:	f7fc fbe8 	bl	2408 <rpc_blocking_loop>
    return rpc_command_release(CORES_PROTOCOL_CORE);
    5c38:	0020      	movs	r0, r4
    5c3a:	f7fc fbfb 	bl	2434 <rpc_command_release>
}
    5c3e:	b00f      	add	sp, #60	; 0x3c
    5c40:	bdf0      	pop	{r4, r5, r6, r7, pc}

00005c42 <command_get_pdp_context_dynamic_param_request_state>:
{
    5c42:	b5f0      	push	{r4, r5, r6, r7, lr}
    5c44:	270f      	movs	r7, #15
    info.num_sections = 1;
    5c46:	2401      	movs	r4, #1
{
    5c48:	b08d      	sub	sp, #52	; 0x34
    5c4a:	446f      	add	r7, sp
    5c4c:	7038      	strb	r0, [r7, #0]
    info.num_sections = 1;
    5c4e:	ae05      	add	r6, sp, #20
    info.sections = get_sections;
    5c50:	a809      	add	r0, sp, #36	; 0x24
    rpc_init_receive_section(&get_sections[0], (uint8 *)state, sizeof(bool), NULL);
    5c52:	2300      	movs	r3, #0
    5c54:	0022      	movs	r2, r4
    info.sections = get_sections;
    5c56:	9005      	str	r0, [sp, #20]
    info.num_sections = 1;
    5c58:	7134      	strb	r4, [r6, #4]
    data_to_send[0].data_location = (uint8 *)&param_item;
    5c5a:	ad07      	add	r5, sp, #28
    rpc_init_receive_section(&get_sections[0], (uint8 *)state, sizeof(bool), NULL);
    5c5c:	f7fc fbcf 	bl	23fe <rpc_init_receive_section>
    RPC_ERR rpc_return = rpc_command_claim(CORES_PROTOCOL_CORE);
    5c60:	0020      	movs	r0, r4
    data_to_send[0].data_location = (uint8 *)&param_item;
    5c62:	9707      	str	r7, [sp, #28]
    data_to_send[0].data_length = sizeof(param_item);
    5c64:	80ac      	strh	r4, [r5, #4]
    RPC_ERR rpc_return = rpc_command_claim(CORES_PROTOCOL_CORE);
    5c66:	f7fc fbf9 	bl	245c <rpc_command_claim>
    if (rpc_return != RPC_ERR_OK)
    5c6a:	2800      	cmp	r0, #0
    5c6c:	d110      	bne.n	5c90 <command_get_pdp_context_dynamic_param_request_state+0x4e>
    set_receive_info(CORES_PROTOCOL_CORE, &info);
    5c6e:	0031      	movs	r1, r6
    5c70:	0020      	movs	r0, r4
    5c72:	f7fc f895 	bl	1da0 <set_receive_info>
    rpc_interface_scatter_send(CORES_PROTOCOL_CORE, RPC_APPLICATION_TO_PROTOCOL_GET_PDP_CONTEXT_DYNAMIC_PARAM_REQUEST_STATE, true, 1, data_to_send);
    5c76:	0023      	movs	r3, r4
    5c78:	0022      	movs	r2, r4
    5c7a:	215e      	movs	r1, #94	; 0x5e
    5c7c:	0020      	movs	r0, r4
    5c7e:	9500      	str	r5, [sp, #0]
    5c80:	f7fc fb3e 	bl	2300 <rpc_interface_scatter_send>
    rpc_blocking_loop(CORES_PROTOCOL_CORE);
    5c84:	0020      	movs	r0, r4
    5c86:	f7fc fbbf 	bl	2408 <rpc_blocking_loop>
    return rpc_command_release(CORES_PROTOCOL_CORE);
    5c8a:	0020      	movs	r0, r4
    5c8c:	f7fc fbd2 	bl	2434 <rpc_command_release>
}
    5c90:	b00d      	add	sp, #52	; 0x34
    5c92:	bdf0      	pop	{r4, r5, r6, r7, pc}

00005c94 <command_calibrate_temperature>:
{
    5c94:	b5f0      	push	{r4, r5, r6, r7, lr}
    5c96:	270e      	movs	r7, #14
    info.num_sections = 1;
    5c98:	2401      	movs	r4, #1
{
    5c9a:	b08d      	sub	sp, #52	; 0x34
    5c9c:	446f      	add	r7, sp
    5c9e:	8038      	strh	r0, [r7, #0]
    rpc_init_receive_section(&get_sections[0], (uint8 *)result, sizeof(uint8), NULL);
    5ca0:	2300      	movs	r3, #0
    info.sections = get_sections;
    5ca2:	a809      	add	r0, sp, #36	; 0x24
    info.num_sections = 1;
    5ca4:	ae05      	add	r6, sp, #20
    rpc_init_receive_section(&get_sections[0], (uint8 *)result, sizeof(uint8), NULL);
    5ca6:	0022      	movs	r2, r4
    info.sections = get_sections;
    5ca8:	9005      	str	r0, [sp, #20]
    info.num_sections = 1;
    5caa:	7134      	strb	r4, [r6, #4]
    rpc_init_receive_section(&get_sections[0], (uint8 *)result, sizeof(uint8), NULL);
    5cac:	f7fc fba7 	bl	23fe <rpc_init_receive_section>
    data_to_send[0].data_length = sizeof(temperature);
    5cb0:	2302      	movs	r3, #2
    data_to_send[0].data_location = (uint8 *)&temperature;
    5cb2:	ad07      	add	r5, sp, #28
    RPC_ERR rpc_return = rpc_command_claim(CORES_PROTOCOL_CORE);
    5cb4:	0020      	movs	r0, r4
    data_to_send[0].data_location = (uint8 *)&temperature;
    5cb6:	9707      	str	r7, [sp, #28]
    data_to_send[0].data_length = sizeof(temperature);
    5cb8:	80ab      	strh	r3, [r5, #4]
    RPC_ERR rpc_return = rpc_command_claim(CORES_PROTOCOL_CORE);
    5cba:	f7fc fbcf 	bl	245c <rpc_command_claim>
    if (rpc_return != RPC_ERR_OK)
    5cbe:	2800      	cmp	r0, #0
    5cc0:	d110      	bne.n	5ce4 <command_calibrate_temperature+0x50>
    set_receive_info(CORES_PROTOCOL_CORE, &info);
    5cc2:	0031      	movs	r1, r6
    5cc4:	0020      	movs	r0, r4
    5cc6:	f7fc f86b 	bl	1da0 <set_receive_info>
    rpc_interface_scatter_send(CORES_PROTOCOL_CORE, RPC_APPLICATION_TO_PROTOCOL_CALIBRATE_TEMPERATURE, true, 1, data_to_send);
    5cca:	0023      	movs	r3, r4
    5ccc:	0022      	movs	r2, r4
    5cce:	215f      	movs	r1, #95	; 0x5f
    5cd0:	0020      	movs	r0, r4
    5cd2:	9500      	str	r5, [sp, #0]
    5cd4:	f7fc fb14 	bl	2300 <rpc_interface_scatter_send>
    rpc_blocking_loop(CORES_PROTOCOL_CORE);
    5cd8:	0020      	movs	r0, r4
    5cda:	f7fc fb95 	bl	2408 <rpc_blocking_loop>
    return rpc_command_release(CORES_PROTOCOL_CORE);
    5cde:	0020      	movs	r0, r4
    5ce0:	f7fc fba8 	bl	2434 <rpc_command_release>
}
    5ce4:	b00d      	add	sp, #52	; 0x34
    5ce6:	bdf0      	pop	{r4, r5, r6, r7, pc}

00005ce8 <command_open_logical_channel>:
{
    5ce8:	b5f0      	push	{r4, r5, r6, r7, lr}
    5cea:	260e      	movs	r6, #14
    5cec:	001c      	movs	r4, r3
    info.num_sections = 2;
    5cee:	2502      	movs	r5, #2
{
    5cf0:	b091      	sub	sp, #68	; 0x44
    5cf2:	446e      	add	r6, sp
    5cf4:	9102      	str	r1, [sp, #8]
    5cf6:	8030      	strh	r0, [r6, #0]
    5cf8:	0011      	movs	r1, r2
    info.sections = get_sections;
    5cfa:	a80a      	add	r0, sp, #40	; 0x28
    rpc_init_receive_section(&get_sections[0], (uint8 *)result, sizeof(uint8), NULL);
    5cfc:	2300      	movs	r3, #0
    5cfe:	2201      	movs	r2, #1
    info.num_sections = 2;
    5d00:	af04      	add	r7, sp, #16
    info.sections = get_sections;
    5d02:	9004      	str	r0, [sp, #16]
    info.num_sections = 2;
    5d04:	713d      	strb	r5, [r7, #4]
    rpc_init_receive_section(&get_sections[0], (uint8 *)result, sizeof(uint8), NULL);
    5d06:	f7fc fb7a 	bl	23fe <rpc_init_receive_section>
    rpc_init_receive_section(&get_sections[1], (uint8 *)channel_num, sizeof(uint8), NULL);
    5d0a:	2300      	movs	r3, #0
    5d0c:	0021      	movs	r1, r4
    5d0e:	a80d      	add	r0, sp, #52	; 0x34
    5d10:	2201      	movs	r2, #1
    5d12:	f7fc fb74 	bl	23fe <rpc_init_receive_section>
    data_to_send[1].data_location = (uint8 *)app_id;
    5d16:	9b02      	ldr	r3, [sp, #8]
    data_to_send[0].data_location = (uint8 *)&app_id_length;
    5d18:	ac06      	add	r4, sp, #24
    data_to_send[1].data_location = (uint8 *)app_id;
    5d1a:	9308      	str	r3, [sp, #32]
    data_to_send[1].data_length = app_id_length;
    5d1c:	8833      	ldrh	r3, [r6, #0]
    data_to_send[0].data_length = sizeof(app_id_length);
    5d1e:	80a5      	strh	r5, [r4, #4]
    data_to_send[1].data_length = app_id_length;
    5d20:	81a3      	strh	r3, [r4, #12]
    RPC_ERR rpc_return = rpc_command_claim(CORES_PROTOCOL_CORE);
    5d22:	2001      	movs	r0, #1
    data_to_send[0].data_location = (uint8 *)&app_id_length;
    5d24:	9606      	str	r6, [sp, #24]
    RPC_ERR rpc_return = rpc_command_claim(CORES_PROTOCOL_CORE);
    5d26:	f7fc fb99 	bl	245c <rpc_command_claim>
    if (rpc_return != RPC_ERR_OK)
    5d2a:	2800      	cmp	r0, #0
    5d2c:	d110      	bne.n	5d50 <command_open_logical_channel+0x68>
    set_receive_info(CORES_PROTOCOL_CORE, &info);
    5d2e:	0039      	movs	r1, r7
    5d30:	3001      	adds	r0, #1
    5d32:	f7fc f835 	bl	1da0 <set_receive_info>
    rpc_interface_scatter_send(CORES_PROTOCOL_CORE, RPC_APPLICATION_TO_PROTOCOL_OPEN_LOGICAL_CHANNEL, true, 2, data_to_send);
    5d36:	2201      	movs	r2, #1
    5d38:	002b      	movs	r3, r5
    5d3a:	0010      	movs	r0, r2
    5d3c:	2160      	movs	r1, #96	; 0x60
    5d3e:	9400      	str	r4, [sp, #0]
    5d40:	f7fc fade 	bl	2300 <rpc_interface_scatter_send>
    rpc_blocking_loop(CORES_PROTOCOL_CORE);
    5d44:	2001      	movs	r0, #1
    5d46:	f7fc fb5f 	bl	2408 <rpc_blocking_loop>
    return rpc_command_release(CORES_PROTOCOL_CORE);
    5d4a:	2001      	movs	r0, #1
    5d4c:	f7fc fb72 	bl	2434 <rpc_command_release>
}
    5d50:	b011      	add	sp, #68	; 0x44
    5d52:	bdf0      	pop	{r4, r5, r6, r7, pc}

00005d54 <command_close_logical_channel>:
{
    5d54:	b5f0      	push	{r4, r5, r6, r7, lr}
    5d56:	270f      	movs	r7, #15
    info.num_sections = 1;
    5d58:	2401      	movs	r4, #1
{
    5d5a:	b08d      	sub	sp, #52	; 0x34
    5d5c:	446f      	add	r7, sp
    5d5e:	7038      	strb	r0, [r7, #0]
    info.num_sections = 1;
    5d60:	ae05      	add	r6, sp, #20
    info.sections = get_sections;
    5d62:	a809      	add	r0, sp, #36	; 0x24
    rpc_init_receive_section(&get_sections[0], (uint8 *)result, sizeof(uint8), NULL);
    5d64:	2300      	movs	r3, #0
    5d66:	0022      	movs	r2, r4
    info.sections = get_sections;
    5d68:	9005      	str	r0, [sp, #20]
    info.num_sections = 1;
    5d6a:	7134      	strb	r4, [r6, #4]
    data_to_send[0].data_location = (uint8 *)&channel_num;
    5d6c:	ad07      	add	r5, sp, #28
    rpc_init_receive_section(&get_sections[0], (uint8 *)result, sizeof(uint8), NULL);
    5d6e:	f7fc fb46 	bl	23fe <rpc_init_receive_section>
    RPC_ERR rpc_return = rpc_command_claim(CORES_PROTOCOL_CORE);
    5d72:	0020      	movs	r0, r4
    data_to_send[0].data_location = (uint8 *)&channel_num;
    5d74:	9707      	str	r7, [sp, #28]
    data_to_send[0].data_length = sizeof(channel_num);
    5d76:	80ac      	strh	r4, [r5, #4]
    RPC_ERR rpc_return = rpc_command_claim(CORES_PROTOCOL_CORE);
    5d78:	f7fc fb70 	bl	245c <rpc_command_claim>
    if (rpc_return != RPC_ERR_OK)
    5d7c:	2800      	cmp	r0, #0
    5d7e:	d110      	bne.n	5da2 <command_close_logical_channel+0x4e>
    set_receive_info(CORES_PROTOCOL_CORE, &info);
    5d80:	0031      	movs	r1, r6
    5d82:	0020      	movs	r0, r4
    5d84:	f7fc f80c 	bl	1da0 <set_receive_info>
    rpc_interface_scatter_send(CORES_PROTOCOL_CORE, RPC_APPLICATION_TO_PROTOCOL_CLOSE_LOGICAL_CHANNEL, true, 1, data_to_send);
    5d88:	0023      	movs	r3, r4
    5d8a:	0022      	movs	r2, r4
    5d8c:	2161      	movs	r1, #97	; 0x61
    5d8e:	0020      	movs	r0, r4
    5d90:	9500      	str	r5, [sp, #0]
    5d92:	f7fc fab5 	bl	2300 <rpc_interface_scatter_send>
    rpc_blocking_loop(CORES_PROTOCOL_CORE);
    5d96:	0020      	movs	r0, r4
    5d98:	f7fc fb36 	bl	2408 <rpc_blocking_loop>
    return rpc_command_release(CORES_PROTOCOL_CORE);
    5d9c:	0020      	movs	r0, r4
    5d9e:	f7fc fb49 	bl	2434 <rpc_command_release>
}
    5da2:	b00d      	add	sp, #52	; 0x34
    5da4:	bdf0      	pop	{r4, r5, r6, r7, pc}

00005da6 <command_generic_uicc_logical_channel_access>:
{
    5da6:	b5f0      	push	{r4, r5, r6, r7, lr}
    5da8:	b093      	sub	sp, #76	; 0x4c
    5daa:	000f      	movs	r7, r1
    5dac:	240f      	movs	r4, #15
    5dae:	0019      	movs	r1, r3
    5db0:	ab18      	add	r3, sp, #96	; 0x60
    5db2:	881d      	ldrh	r5, [r3, #0]
    info.num_sections = 2;
    5db4:	2302      	movs	r3, #2
{
    5db6:	ae03      	add	r6, sp, #12
    5db8:	446c      	add	r4, sp
    5dba:	8037      	strh	r7, [r6, #0]
    info.num_sections = 2;
    5dbc:	af04      	add	r7, sp, #16
{
    5dbe:	7020      	strb	r0, [r4, #0]
    5dc0:	9202      	str	r2, [sp, #8]
    info.sections = get_sections;
    5dc2:	a80c      	add	r0, sp, #48	; 0x30
    info.num_sections = 2;
    5dc4:	713b      	strb	r3, [r7, #4]
    rpc_init_receive_section(&get_sections[0], (uint8 *)result, sizeof(uint8), NULL);
    5dc6:	2201      	movs	r2, #1
    5dc8:	2300      	movs	r3, #0
    info.sections = get_sections;
    5dca:	9004      	str	r0, [sp, #16]
    rpc_init_receive_section(&get_sections[0], (uint8 *)result, sizeof(uint8), NULL);
    5dcc:	f7fc fb17 	bl	23fe <rpc_init_receive_section>
    rpc_init_receive_section(&get_sections[1], (uint8 *)response, response_max_length, response_length);
    5dd0:	9b19      	ldr	r3, [sp, #100]	; 0x64
    5dd2:	002a      	movs	r2, r5
    5dd4:	a80f      	add	r0, sp, #60	; 0x3c
    5dd6:	991a      	ldr	r1, [sp, #104]	; 0x68
    5dd8:	f7fc fb11 	bl	23fe <rpc_init_receive_section>
    data_to_send[1].data_length = sizeof(command_length);
    5ddc:	2302      	movs	r3, #2
    data_to_send[0].data_location = (uint8 *)&channel_num;
    5dde:	9406      	str	r4, [sp, #24]
    data_to_send[0].data_length = sizeof(channel_num);
    5de0:	2401      	movs	r4, #1
    data_to_send[0].data_location = (uint8 *)&channel_num;
    5de2:	ad06      	add	r5, sp, #24
    data_to_send[1].data_length = sizeof(command_length);
    5de4:	81ab      	strh	r3, [r5, #12]
    data_to_send[2].data_location = (uint8 *)command;
    5de6:	9b02      	ldr	r3, [sp, #8]
    data_to_send[0].data_length = sizeof(channel_num);
    5de8:	80ac      	strh	r4, [r5, #4]
    data_to_send[2].data_location = (uint8 *)command;
    5dea:	930a      	str	r3, [sp, #40]	; 0x28
    data_to_send[2].data_length = command_length;
    5dec:	8833      	ldrh	r3, [r6, #0]
    RPC_ERR rpc_return = rpc_command_claim(CORES_PROTOCOL_CORE);
    5dee:	0020      	movs	r0, r4
    data_to_send[2].data_length = command_length;
    5df0:	82ab      	strh	r3, [r5, #20]
    data_to_send[1].data_location = (uint8 *)&command_length;
    5df2:	9608      	str	r6, [sp, #32]
    RPC_ERR rpc_return = rpc_command_claim(CORES_PROTOCOL_CORE);
    5df4:	f7fc fb32 	bl	245c <rpc_command_claim>
    if (rpc_return != RPC_ERR_OK)
    5df8:	2800      	cmp	r0, #0
    5dfa:	d110      	bne.n	5e1e <command_generic_uicc_logical_channel_access+0x78>
    set_receive_info(CORES_PROTOCOL_CORE, &info);
    5dfc:	0039      	movs	r1, r7
    5dfe:	0020      	movs	r0, r4
    5e00:	f7fb ffce 	bl	1da0 <set_receive_info>
    rpc_interface_scatter_send(CORES_PROTOCOL_CORE, RPC_APPLICATION_TO_PROTOCOL_GENERIC_UICC_LOGICAL_CHANNEL_ACCESS, true, 3, data_to_send);
    5e04:	2303      	movs	r3, #3
    5e06:	0022      	movs	r2, r4
    5e08:	2162      	movs	r1, #98	; 0x62
    5e0a:	0020      	movs	r0, r4
    5e0c:	9500      	str	r5, [sp, #0]
    5e0e:	f7fc fa77 	bl	2300 <rpc_interface_scatter_send>
    rpc_blocking_loop(CORES_PROTOCOL_CORE);
    5e12:	0020      	movs	r0, r4
    5e14:	f7fc faf8 	bl	2408 <rpc_blocking_loop>
    return rpc_command_release(CORES_PROTOCOL_CORE);
    5e18:	0020      	movs	r0, r4
    5e1a:	f7fc fb0b 	bl	2434 <rpc_command_release>
}
    5e1e:	b013      	add	sp, #76	; 0x4c
    5e20:	bdf0      	pop	{r4, r5, r6, r7, pc}

00005e22 <command_pdp_modify_req>:
{
    5e22:	b5f0      	push	{r4, r5, r6, r7, lr}
    5e24:	270e      	movs	r7, #14
    info.num_sections = 1;
    5e26:	2401      	movs	r4, #1
{
    5e28:	b08d      	sub	sp, #52	; 0x34
    5e2a:	446f      	add	r7, sp
    5e2c:	8038      	strh	r0, [r7, #0]
    rpc_init_receive_section(&get_sections[0], (uint8 *)ret, sizeof(uint8), NULL);
    5e2e:	2300      	movs	r3, #0
    info.sections = get_sections;
    5e30:	a809      	add	r0, sp, #36	; 0x24
    info.num_sections = 1;
    5e32:	ae05      	add	r6, sp, #20
    rpc_init_receive_section(&get_sections[0], (uint8 *)ret, sizeof(uint8), NULL);
    5e34:	0022      	movs	r2, r4
    info.sections = get_sections;
    5e36:	9005      	str	r0, [sp, #20]
    info.num_sections = 1;
    5e38:	7134      	strb	r4, [r6, #4]
    rpc_init_receive_section(&get_sections[0], (uint8 *)ret, sizeof(uint8), NULL);
    5e3a:	f7fc fae0 	bl	23fe <rpc_init_receive_section>
    data_to_send[0].data_length = sizeof(cid);
    5e3e:	2302      	movs	r3, #2
    data_to_send[0].data_location = (uint8 *)&cid;
    5e40:	ad07      	add	r5, sp, #28
    RPC_ERR rpc_return = rpc_command_claim(CORES_PROTOCOL_CORE);
    5e42:	0020      	movs	r0, r4
    data_to_send[0].data_location = (uint8 *)&cid;
    5e44:	9707      	str	r7, [sp, #28]
    data_to_send[0].data_length = sizeof(cid);
    5e46:	80ab      	strh	r3, [r5, #4]
    RPC_ERR rpc_return = rpc_command_claim(CORES_PROTOCOL_CORE);
    5e48:	f7fc fb08 	bl	245c <rpc_command_claim>
    if (rpc_return != RPC_ERR_OK)
    5e4c:	2800      	cmp	r0, #0
    5e4e:	d110      	bne.n	5e72 <command_pdp_modify_req+0x50>
    set_receive_info(CORES_PROTOCOL_CORE, &info);
    5e50:	0031      	movs	r1, r6
    5e52:	0020      	movs	r0, r4
    5e54:	f7fb ffa4 	bl	1da0 <set_receive_info>
    rpc_interface_scatter_send(CORES_PROTOCOL_CORE, RPC_APPLICATION_TO_PROTOCOL_PDP_MODIFY_REQ, true, 1, data_to_send);
    5e58:	0023      	movs	r3, r4
    5e5a:	0022      	movs	r2, r4
    5e5c:	2163      	movs	r1, #99	; 0x63
    5e5e:	0020      	movs	r0, r4
    5e60:	9500      	str	r5, [sp, #0]
    5e62:	f7fc fa4d 	bl	2300 <rpc_interface_scatter_send>
    rpc_blocking_loop(CORES_PROTOCOL_CORE);
    5e66:	0020      	movs	r0, r4
    5e68:	f7fc face 	bl	2408 <rpc_blocking_loop>
    return rpc_command_release(CORES_PROTOCOL_CORE);
    5e6c:	0020      	movs	r0, r4
    5e6e:	f7fc fae1 	bl	2434 <rpc_command_release>
}
    5e72:	b00d      	add	sp, #52	; 0x34
    5e74:	bdf0      	pop	{r4, r5, r6, r7, pc}

00005e76 <command_set_ciot_opt>:
{
    5e76:	b5f0      	push	{r4, r5, r6, r7, lr}
    5e78:	270f      	movs	r7, #15
    5e7a:	b08f      	sub	sp, #60	; 0x3c
    info.num_sections = 1;
    5e7c:	2401      	movs	r4, #1
{
    5e7e:	000b      	movs	r3, r1
    5e80:	0011      	movs	r1, r2
    5e82:	466a      	mov	r2, sp
    5e84:	446f      	add	r7, sp
    5e86:	7393      	strb	r3, [r2, #14]
    5e88:	7038      	strb	r0, [r7, #0]
    rpc_init_receive_section(&get_sections[0], (uint8 *)result, sizeof(uint8), NULL);
    5e8a:	2300      	movs	r3, #0
    info.sections = get_sections;
    5e8c:	a807      	add	r0, sp, #28
    info.num_sections = 1;
    5e8e:	ae05      	add	r6, sp, #20
    rpc_init_receive_section(&get_sections[0], (uint8 *)result, sizeof(uint8), NULL);
    5e90:	0022      	movs	r2, r4
    info.sections = get_sections;
    5e92:	9005      	str	r0, [sp, #20]
    info.num_sections = 1;
    5e94:	7134      	strb	r4, [r6, #4]
    rpc_init_receive_section(&get_sections[0], (uint8 *)result, sizeof(uint8), NULL);
    5e96:	f7fc fab2 	bl	23fe <rpc_init_receive_section>
    data_to_send[1].data_location = (uint8 *)&preferred_ue_opt;
    5e9a:	230e      	movs	r3, #14
    data_to_send[0].data_location = (uint8 *)&supported_ue_opt;
    5e9c:	ad0a      	add	r5, sp, #40	; 0x28
    data_to_send[1].data_location = (uint8 *)&preferred_ue_opt;
    5e9e:	446b      	add	r3, sp
    RPC_ERR rpc_return = rpc_command_claim(CORES_PROTOCOL_CORE);
    5ea0:	0020      	movs	r0, r4
    data_to_send[0].data_location = (uint8 *)&supported_ue_opt;
    5ea2:	970a      	str	r7, [sp, #40]	; 0x28
    data_to_send[0].data_length = sizeof(supported_ue_opt);
    5ea4:	80ac      	strh	r4, [r5, #4]
    data_to_send[1].data_location = (uint8 *)&preferred_ue_opt;
    5ea6:	930c      	str	r3, [sp, #48]	; 0x30
    data_to_send[1].data_length = sizeof(preferred_ue_opt);
    5ea8:	81ac      	strh	r4, [r5, #12]
    RPC_ERR rpc_return = rpc_command_claim(CORES_PROTOCOL_CORE);
    5eaa:	f7fc fad7 	bl	245c <rpc_command_claim>
    if (rpc_return != RPC_ERR_OK)
    5eae:	2800      	cmp	r0, #0
    5eb0:	d110      	bne.n	5ed4 <command_set_ciot_opt+0x5e>
    set_receive_info(CORES_PROTOCOL_CORE, &info);
    5eb2:	0031      	movs	r1, r6
    5eb4:	0020      	movs	r0, r4
    5eb6:	f7fb ff73 	bl	1da0 <set_receive_info>
    rpc_interface_scatter_send(CORES_PROTOCOL_CORE, RPC_APPLICATION_TO_PROTOCOL_SET_CIOT_OPT, true, 2, data_to_send);
    5eba:	2302      	movs	r3, #2
    5ebc:	0022      	movs	r2, r4
    5ebe:	2164      	movs	r1, #100	; 0x64
    5ec0:	0020      	movs	r0, r4
    5ec2:	9500      	str	r5, [sp, #0]
    5ec4:	f7fc fa1c 	bl	2300 <rpc_interface_scatter_send>
    rpc_blocking_loop(CORES_PROTOCOL_CORE);
    5ec8:	0020      	movs	r0, r4
    5eca:	f7fc fa9d 	bl	2408 <rpc_blocking_loop>
    return rpc_command_release(CORES_PROTOCOL_CORE);
    5ece:	0020      	movs	r0, r4
    5ed0:	f7fc fab0 	bl	2434 <rpc_command_release>
}
    5ed4:	b00f      	add	sp, #60	; 0x3c
    5ed6:	bdf0      	pop	{r4, r5, r6, r7, pc}

00005ed8 <command_get_ciot_opt>:
{
    5ed8:	b5f0      	push	{r4, r5, r6, r7, lr}
    info.num_sections = 3;
    5eda:	2303      	movs	r3, #3
{
    5edc:	0007      	movs	r7, r0
    5ede:	000e      	movs	r6, r1
    5ee0:	0014      	movs	r4, r2
    5ee2:	b08f      	sub	sp, #60	; 0x3c
    info.num_sections = 3;
    5ee4:	ad03      	add	r5, sp, #12
    info.sections = get_sections;
    5ee6:	a805      	add	r0, sp, #20
    info.num_sections = 3;
    5ee8:	712b      	strb	r3, [r5, #4]
    rpc_init_receive_section(&get_sections[0], (uint8 *)result, sizeof(uint8), NULL);
    5eea:	2201      	movs	r2, #1
    5eec:	2300      	movs	r3, #0
    5eee:	0039      	movs	r1, r7
    info.sections = get_sections;
    5ef0:	9003      	str	r0, [sp, #12]
    rpc_init_receive_section(&get_sections[0], (uint8 *)result, sizeof(uint8), NULL);
    5ef2:	f7fc fa84 	bl	23fe <rpc_init_receive_section>
    rpc_init_receive_section(&get_sections[1], (uint8 *)supported_ue_opt, sizeof(uint8), NULL);
    5ef6:	2300      	movs	r3, #0
    5ef8:	2201      	movs	r2, #1
    5efa:	0031      	movs	r1, r6
    5efc:	a808      	add	r0, sp, #32
    5efe:	f7fc fa7e 	bl	23fe <rpc_init_receive_section>
    rpc_init_receive_section(&get_sections[2], (uint8 *)preferred_ue_opt, sizeof(uint8), NULL);
    5f02:	0021      	movs	r1, r4
    5f04:	2300      	movs	r3, #0
    5f06:	2201      	movs	r2, #1
    5f08:	a80b      	add	r0, sp, #44	; 0x2c
    5f0a:	f7fc fa78 	bl	23fe <rpc_init_receive_section>
    RPC_ERR rpc_return = rpc_command_claim(CORES_PROTOCOL_CORE);
    5f0e:	2001      	movs	r0, #1
    5f10:	f7fc faa4 	bl	245c <rpc_command_claim>
    5f14:	1e04      	subs	r4, r0, #0
    if (rpc_return != RPC_ERR_OK)
    5f16:	d111      	bne.n	5f3c <command_get_ciot_opt+0x64>
    set_receive_info(CORES_PROTOCOL_CORE, &info);
    5f18:	0029      	movs	r1, r5
    5f1a:	2001      	movs	r0, #1
    5f1c:	f7fb ff40 	bl	1da0 <set_receive_info>
    rpc_interface_scatter_send(CORES_PROTOCOL_CORE, RPC_APPLICATION_TO_PROTOCOL_GET_CIOT_OPT, true, 0, NULL);
    5f20:	2201      	movs	r2, #1
    5f22:	0023      	movs	r3, r4
    5f24:	0010      	movs	r0, r2
    5f26:	2165      	movs	r1, #101	; 0x65
    5f28:	9400      	str	r4, [sp, #0]
    5f2a:	f7fc f9e9 	bl	2300 <rpc_interface_scatter_send>
    rpc_blocking_loop(CORES_PROTOCOL_CORE);
    5f2e:	2001      	movs	r0, #1
    5f30:	f7fc fa6a 	bl	2408 <rpc_blocking_loop>
    return rpc_command_release(CORES_PROTOCOL_CORE);
    5f34:	2001      	movs	r0, #1
    5f36:	f7fc fa7d 	bl	2434 <rpc_command_release>
    5f3a:	0004      	movs	r4, r0
}
    5f3c:	0020      	movs	r0, r4
    5f3e:	b00f      	add	sp, #60	; 0x3c
    5f40:	bdf0      	pop	{r4, r5, r6, r7, pc}

00005f42 <command_set_qos_req>:
{
    5f42:	b5f0      	push	{r4, r5, r6, r7, lr}
    5f44:	270e      	movs	r7, #14
    5f46:	b08f      	sub	sp, #60	; 0x3c
    info.num_sections = 1;
    5f48:	2401      	movs	r4, #1
{
    5f4a:	000b      	movs	r3, r1
    5f4c:	0011      	movs	r1, r2
    5f4e:	466a      	mov	r2, sp
    5f50:	446f      	add	r7, sp
    5f52:	8038      	strh	r0, [r7, #0]
    5f54:	7353      	strb	r3, [r2, #13]
    info.sections = get_sections;
    5f56:	a807      	add	r0, sp, #28
    rpc_init_receive_section(&get_sections[0], (uint8 *)ret, sizeof(uint8), NULL);
    5f58:	2300      	movs	r3, #0
    info.num_sections = 1;
    5f5a:	ae05      	add	r6, sp, #20
    rpc_init_receive_section(&get_sections[0], (uint8 *)ret, sizeof(uint8), NULL);
    5f5c:	0022      	movs	r2, r4
    info.sections = get_sections;
    5f5e:	9005      	str	r0, [sp, #20]
    info.num_sections = 1;
    5f60:	7134      	strb	r4, [r6, #4]
    rpc_init_receive_section(&get_sections[0], (uint8 *)ret, sizeof(uint8), NULL);
    5f62:	f7fc fa4c 	bl	23fe <rpc_init_receive_section>
    data_to_send[1].data_location = (uint8 *)&qci;
    5f66:	230d      	movs	r3, #13
    data_to_send[0].data_location = (uint8 *)&cid;
    5f68:	970a      	str	r7, [sp, #40]	; 0x28
    data_to_send[0].data_length = sizeof(cid);
    5f6a:	2702      	movs	r7, #2
    data_to_send[0].data_location = (uint8 *)&cid;
    5f6c:	ad0a      	add	r5, sp, #40	; 0x28
    data_to_send[1].data_location = (uint8 *)&qci;
    5f6e:	446b      	add	r3, sp
    RPC_ERR rpc_return = rpc_command_claim(CORES_PROTOCOL_CORE);
    5f70:	0020      	movs	r0, r4
    data_to_send[0].data_length = sizeof(cid);
    5f72:	80af      	strh	r7, [r5, #4]
    data_to_send[1].data_location = (uint8 *)&qci;
    5f74:	930c      	str	r3, [sp, #48]	; 0x30
    data_to_send[1].data_length = sizeof(qci);
    5f76:	81ac      	strh	r4, [r5, #12]
    RPC_ERR rpc_return = rpc_command_claim(CORES_PROTOCOL_CORE);
    5f78:	f7fc fa70 	bl	245c <rpc_command_claim>
    if (rpc_return != RPC_ERR_OK)
    5f7c:	2800      	cmp	r0, #0
    5f7e:	d110      	bne.n	5fa2 <command_set_qos_req+0x60>
    set_receive_info(CORES_PROTOCOL_CORE, &info);
    5f80:	0031      	movs	r1, r6
    5f82:	0020      	movs	r0, r4
    5f84:	f7fb ff0c 	bl	1da0 <set_receive_info>
    rpc_interface_scatter_send(CORES_PROTOCOL_CORE, RPC_APPLICATION_TO_PROTOCOL_SET_QOS_REQ, true, 2, data_to_send);
    5f88:	003b      	movs	r3, r7
    5f8a:	0022      	movs	r2, r4
    5f8c:	2166      	movs	r1, #102	; 0x66
    5f8e:	0020      	movs	r0, r4
    5f90:	9500      	str	r5, [sp, #0]
    5f92:	f7fc f9b5 	bl	2300 <rpc_interface_scatter_send>
    rpc_blocking_loop(CORES_PROTOCOL_CORE);
    5f96:	0020      	movs	r0, r4
    5f98:	f7fc fa36 	bl	2408 <rpc_blocking_loop>
    return rpc_command_release(CORES_PROTOCOL_CORE);
    5f9c:	0020      	movs	r0, r4
    5f9e:	f7fc fa49 	bl	2434 <rpc_command_release>
}
    5fa2:	b00f      	add	sp, #60	; 0x3c
    5fa4:	bdf0      	pop	{r4, r5, r6, r7, pc}

00005fa6 <command_get_qos>:
{
    5fa6:	b5f0      	push	{r4, r5, r6, r7, lr}
    5fa8:	270e      	movs	r7, #14
    5faa:	0014      	movs	r4, r2
    info.num_sections = 2;
    5fac:	2602      	movs	r6, #2
{
    5fae:	b08f      	sub	sp, #60	; 0x3c
    5fb0:	446f      	add	r7, sp
    5fb2:	8038      	strh	r0, [r7, #0]
    rpc_init_receive_section(&get_sections[0], (uint8 *)ret, sizeof(uint8), NULL);
    5fb4:	2300      	movs	r3, #0
    info.sections = get_sections;
    5fb6:	a808      	add	r0, sp, #32
    rpc_init_receive_section(&get_sections[0], (uint8 *)ret, sizeof(uint8), NULL);
    5fb8:	2201      	movs	r2, #1
    info.num_sections = 2;
    5fba:	ad04      	add	r5, sp, #16
    info.sections = get_sections;
    5fbc:	9004      	str	r0, [sp, #16]
    info.num_sections = 2;
    5fbe:	712e      	strb	r6, [r5, #4]
    rpc_init_receive_section(&get_sections[0], (uint8 *)ret, sizeof(uint8), NULL);
    5fc0:	f7fc fa1d 	bl	23fe <rpc_init_receive_section>
    rpc_init_receive_section(&get_sections[1], (uint8 *)qci, sizeof(uint8), NULL);
    5fc4:	0021      	movs	r1, r4
    5fc6:	a80b      	add	r0, sp, #44	; 0x2c
    5fc8:	2300      	movs	r3, #0
    5fca:	2201      	movs	r2, #1
    data_to_send[0].data_location = (uint8 *)&cid;
    5fcc:	ac06      	add	r4, sp, #24
    rpc_init_receive_section(&get_sections[1], (uint8 *)qci, sizeof(uint8), NULL);
    5fce:	f7fc fa16 	bl	23fe <rpc_init_receive_section>
    data_to_send[0].data_length = sizeof(cid);
    5fd2:	80a6      	strh	r6, [r4, #4]
    RPC_ERR rpc_return = rpc_command_claim(CORES_PROTOCOL_CORE);
    5fd4:	2001      	movs	r0, #1
    data_to_send[0].data_location = (uint8 *)&cid;
    5fd6:	9706      	str	r7, [sp, #24]
    RPC_ERR rpc_return = rpc_command_claim(CORES_PROTOCOL_CORE);
    5fd8:	f7fc fa40 	bl	245c <rpc_command_claim>
    if (rpc_return != RPC_ERR_OK)
    5fdc:	2800      	cmp	r0, #0
    5fde:	d110      	bne.n	6002 <command_get_qos+0x5c>
    set_receive_info(CORES_PROTOCOL_CORE, &info);
    5fe0:	0029      	movs	r1, r5
    5fe2:	3001      	adds	r0, #1
    5fe4:	f7fb fedc 	bl	1da0 <set_receive_info>
    rpc_interface_scatter_send(CORES_PROTOCOL_CORE, RPC_APPLICATION_TO_PROTOCOL_GET_QOS, true, 1, data_to_send);
    5fe8:	2301      	movs	r3, #1
    5fea:	2167      	movs	r1, #103	; 0x67
    5fec:	0018      	movs	r0, r3
    5fee:	001a      	movs	r2, r3
    5ff0:	9400      	str	r4, [sp, #0]
    5ff2:	f7fc f985 	bl	2300 <rpc_interface_scatter_send>
    rpc_blocking_loop(CORES_PROTOCOL_CORE);
    5ff6:	2001      	movs	r0, #1
    5ff8:	f7fc fa06 	bl	2408 <rpc_blocking_loop>
    return rpc_command_release(CORES_PROTOCOL_CORE);
    5ffc:	2001      	movs	r0, #1
    5ffe:	f7fc fa19 	bl	2434 <rpc_command_release>
}
    6002:	b00f      	add	sp, #60	; 0x3c
    6004:	bdf0      	pop	{r4, r5, r6, r7, pc}

00006006 <command_delete_qos>:
{
    6006:	b5f0      	push	{r4, r5, r6, r7, lr}
    6008:	270e      	movs	r7, #14
    info.num_sections = 1;
    600a:	2401      	movs	r4, #1
{
    600c:	b08d      	sub	sp, #52	; 0x34
    600e:	446f      	add	r7, sp
    6010:	8038      	strh	r0, [r7, #0]
    rpc_init_receive_section(&get_sections[0], (uint8 *)ret, sizeof(uint8), NULL);
    6012:	2300      	movs	r3, #0
    info.sections = get_sections;
    6014:	a809      	add	r0, sp, #36	; 0x24
    info.num_sections = 1;
    6016:	ae05      	add	r6, sp, #20
    rpc_init_receive_section(&get_sections[0], (uint8 *)ret, sizeof(uint8), NULL);
    6018:	0022      	movs	r2, r4
    info.sections = get_sections;
    601a:	9005      	str	r0, [sp, #20]
    info.num_sections = 1;
    601c:	7134      	strb	r4, [r6, #4]
    rpc_init_receive_section(&get_sections[0], (uint8 *)ret, sizeof(uint8), NULL);
    601e:	f7fc f9ee 	bl	23fe <rpc_init_receive_section>
    data_to_send[0].data_length = sizeof(cid);
    6022:	2302      	movs	r3, #2
    data_to_send[0].data_location = (uint8 *)&cid;
    6024:	ad07      	add	r5, sp, #28
    RPC_ERR rpc_return = rpc_command_claim(CORES_PROTOCOL_CORE);
    6026:	0020      	movs	r0, r4
    data_to_send[0].data_location = (uint8 *)&cid;
    6028:	9707      	str	r7, [sp, #28]
    data_to_send[0].data_length = sizeof(cid);
    602a:	80ab      	strh	r3, [r5, #4]
    RPC_ERR rpc_return = rpc_command_claim(CORES_PROTOCOL_CORE);
    602c:	f7fc fa16 	bl	245c <rpc_command_claim>
    if (rpc_return != RPC_ERR_OK)
    6030:	2800      	cmp	r0, #0
    6032:	d110      	bne.n	6056 <command_delete_qos+0x50>
    set_receive_info(CORES_PROTOCOL_CORE, &info);
    6034:	0031      	movs	r1, r6
    6036:	0020      	movs	r0, r4
    6038:	f7fb feb2 	bl	1da0 <set_receive_info>
    rpc_interface_scatter_send(CORES_PROTOCOL_CORE, RPC_APPLICATION_TO_PROTOCOL_DELETE_QOS, true, 1, data_to_send);
    603c:	0023      	movs	r3, r4
    603e:	0022      	movs	r2, r4
    6040:	2168      	movs	r1, #104	; 0x68
    6042:	0020      	movs	r0, r4
    6044:	9500      	str	r5, [sp, #0]
    6046:	f7fc f95b 	bl	2300 <rpc_interface_scatter_send>
    rpc_blocking_loop(CORES_PROTOCOL_CORE);
    604a:	0020      	movs	r0, r4
    604c:	f7fc f9dc 	bl	2408 <rpc_blocking_loop>
    return rpc_command_release(CORES_PROTOCOL_CORE);
    6050:	0020      	movs	r0, r4
    6052:	f7fc f9ef 	bl	2434 <rpc_command_release>
}
    6056:	b00d      	add	sp, #52	; 0x34
    6058:	bdf0      	pop	{r4, r5, r6, r7, pc}

0000605a <command_delete_tft_req>:
{
    605a:	b5f0      	push	{r4, r5, r6, r7, lr}
    605c:	270e      	movs	r7, #14
    info.num_sections = 1;
    605e:	2401      	movs	r4, #1
{
    6060:	b08d      	sub	sp, #52	; 0x34
    6062:	446f      	add	r7, sp
    6064:	8038      	strh	r0, [r7, #0]
    rpc_init_receive_section(&get_sections[0], (uint8 *)ret, sizeof(uint8), NULL);
    6066:	2300      	movs	r3, #0
    info.sections = get_sections;
    6068:	a809      	add	r0, sp, #36	; 0x24
    info.num_sections = 1;
    606a:	ae05      	add	r6, sp, #20
    rpc_init_receive_section(&get_sections[0], (uint8 *)ret, sizeof(uint8), NULL);
    606c:	0022      	movs	r2, r4
    info.sections = get_sections;
    606e:	9005      	str	r0, [sp, #20]
    info.num_sections = 1;
    6070:	7134      	strb	r4, [r6, #4]
    rpc_init_receive_section(&get_sections[0], (uint8 *)ret, sizeof(uint8), NULL);
    6072:	f7fc f9c4 	bl	23fe <rpc_init_receive_section>
    data_to_send[0].data_length = sizeof(cid);
    6076:	2302      	movs	r3, #2
    data_to_send[0].data_location = (uint8 *)&cid;
    6078:	ad07      	add	r5, sp, #28
    RPC_ERR rpc_return = rpc_command_claim(CORES_PROTOCOL_CORE);
    607a:	0020      	movs	r0, r4
    data_to_send[0].data_location = (uint8 *)&cid;
    607c:	9707      	str	r7, [sp, #28]
    data_to_send[0].data_length = sizeof(cid);
    607e:	80ab      	strh	r3, [r5, #4]
    RPC_ERR rpc_return = rpc_command_claim(CORES_PROTOCOL_CORE);
    6080:	f7fc f9ec 	bl	245c <rpc_command_claim>
    if (rpc_return != RPC_ERR_OK)
    6084:	2800      	cmp	r0, #0
    6086:	d110      	bne.n	60aa <command_delete_tft_req+0x50>
    set_receive_info(CORES_PROTOCOL_CORE, &info);
    6088:	0031      	movs	r1, r6
    608a:	0020      	movs	r0, r4
    608c:	f7fb fe88 	bl	1da0 <set_receive_info>
    rpc_interface_scatter_send(CORES_PROTOCOL_CORE, RPC_APPLICATION_TO_PROTOCOL_DELETE_TFT_REQ, true, 1, data_to_send);
    6090:	0023      	movs	r3, r4
    6092:	0022      	movs	r2, r4
    6094:	2169      	movs	r1, #105	; 0x69
    6096:	0020      	movs	r0, r4
    6098:	9500      	str	r5, [sp, #0]
    609a:	f7fc f931 	bl	2300 <rpc_interface_scatter_send>
    rpc_blocking_loop(CORES_PROTOCOL_CORE);
    609e:	0020      	movs	r0, r4
    60a0:	f7fc f9b2 	bl	2408 <rpc_blocking_loop>
    return rpc_command_release(CORES_PROTOCOL_CORE);
    60a4:	0020      	movs	r0, r4
    60a6:	f7fc f9c5 	bl	2434 <rpc_command_release>
}
    60aa:	b00d      	add	sp, #52	; 0x34
    60ac:	bdf0      	pop	{r4, r5, r6, r7, pc}

000060ae <command_set_tft_req>:
{
    60ae:	b5f0      	push	{r4, r5, r6, r7, lr}
    60b0:	260e      	movs	r6, #14
    info.num_sections = 1;
    60b2:	2401      	movs	r4, #1
{
    60b4:	b08f      	sub	sp, #60	; 0x3c
    60b6:	446e      	add	r6, sp
    60b8:	9102      	str	r1, [sp, #8]
    60ba:	8030      	strh	r0, [r6, #0]
    60bc:	0011      	movs	r1, r2
    info.sections = get_sections;
    60be:	a807      	add	r0, sp, #28
    rpc_init_receive_section(&get_sections[0], (uint8 *)ret, sizeof(uint8), NULL);
    60c0:	2300      	movs	r3, #0
    info.num_sections = 1;
    60c2:	af05      	add	r7, sp, #20
    rpc_init_receive_section(&get_sections[0], (uint8 *)ret, sizeof(uint8), NULL);
    60c4:	0022      	movs	r2, r4
    info.sections = get_sections;
    60c6:	9005      	str	r0, [sp, #20]
    info.num_sections = 1;
    60c8:	713c      	strb	r4, [r7, #4]
    rpc_init_receive_section(&get_sections[0], (uint8 *)ret, sizeof(uint8), NULL);
    60ca:	f7fc f998 	bl	23fe <rpc_init_receive_section>
    data_to_send[0].data_length = sizeof(tft_length);
    60ce:	2302      	movs	r3, #2
    data_to_send[0].data_location = (uint8 *)&tft_length;
    60d0:	ad0a      	add	r5, sp, #40	; 0x28
    data_to_send[0].data_length = sizeof(tft_length);
    60d2:	80ab      	strh	r3, [r5, #4]
    data_to_send[1].data_location = (uint8 *)tft;
    60d4:	9b02      	ldr	r3, [sp, #8]
    RPC_ERR rpc_return = rpc_command_claim(CORES_PROTOCOL_CORE);
    60d6:	0020      	movs	r0, r4
    data_to_send[1].data_location = (uint8 *)tft;
    60d8:	930c      	str	r3, [sp, #48]	; 0x30
    data_to_send[1].data_length = tft_length;
    60da:	8833      	ldrh	r3, [r6, #0]
    data_to_send[0].data_location = (uint8 *)&tft_length;
    60dc:	960a      	str	r6, [sp, #40]	; 0x28
    data_to_send[1].data_length = tft_length;
    60de:	81ab      	strh	r3, [r5, #12]
    RPC_ERR rpc_return = rpc_command_claim(CORES_PROTOCOL_CORE);
    60e0:	f7fc f9bc 	bl	245c <rpc_command_claim>
    if (rpc_return != RPC_ERR_OK)
    60e4:	2800      	cmp	r0, #0
    60e6:	d110      	bne.n	610a <command_set_tft_req+0x5c>
    set_receive_info(CORES_PROTOCOL_CORE, &info);
    60e8:	0039      	movs	r1, r7
    60ea:	0020      	movs	r0, r4
    60ec:	f7fb fe58 	bl	1da0 <set_receive_info>
    rpc_interface_scatter_send(CORES_PROTOCOL_CORE, RPC_APPLICATION_TO_PROTOCOL_SET_TFT_REQ, true, 2, data_to_send);
    60f0:	2302      	movs	r3, #2
    60f2:	0022      	movs	r2, r4
    60f4:	216a      	movs	r1, #106	; 0x6a
    60f6:	0020      	movs	r0, r4
    60f8:	9500      	str	r5, [sp, #0]
    60fa:	f7fc f901 	bl	2300 <rpc_interface_scatter_send>
    rpc_blocking_loop(CORES_PROTOCOL_CORE);
    60fe:	0020      	movs	r0, r4
    6100:	f7fc f982 	bl	2408 <rpc_blocking_loop>
    return rpc_command_release(CORES_PROTOCOL_CORE);
    6104:	0020      	movs	r0, r4
    6106:	f7fc f995 	bl	2434 <rpc_command_release>
}
    610a:	b00f      	add	sp, #60	; 0x3c
    610c:	bdf0      	pop	{r4, r5, r6, r7, pc}

0000610e <command_get_tft_context>:
{
    610e:	b5f0      	push	{r4, r5, r6, r7, lr}
    6110:	240f      	movs	r4, #15
    6112:	b091      	sub	sp, #68	; 0x44
    6114:	446c      	add	r4, sp
    6116:	7020      	strb	r0, [r4, #0]
    6118:	4668      	mov	r0, sp
    info.num_sections = 2;
    611a:	2602      	movs	r6, #2
{
    611c:	7381      	strb	r1, [r0, #14]
    info.num_sections = 2;
    611e:	af04      	add	r7, sp, #16
    info.sections = get_sections;
    6120:	a80a      	add	r0, sp, #40	; 0x28
    rpc_init_receive_section(&get_sections[0], (uint8 *)tft_context, tft_context_max_length, tft_context_length);
    6122:	9916      	ldr	r1, [sp, #88]	; 0x58
    info.sections = get_sections;
    6124:	9004      	str	r0, [sp, #16]
    info.num_sections = 2;
    6126:	713e      	strb	r6, [r7, #4]
    rpc_init_receive_section(&get_sections[0], (uint8 *)tft_context, tft_context_max_length, tft_context_length);
    6128:	f7fc f969 	bl	23fe <rpc_init_receive_section>
    rpc_init_receive_section(&get_sections[1], (uint8 *)num_of_packet_filters, sizeof(uint8), NULL);
    612c:	2300      	movs	r3, #0
    612e:	a80d      	add	r0, sp, #52	; 0x34
    6130:	2201      	movs	r2, #1
    6132:	9917      	ldr	r1, [sp, #92]	; 0x5c
    6134:	f7fc f963 	bl	23fe <rpc_init_receive_section>
    data_to_send[0].data_location = (uint8 *)&cid;
    6138:	9406      	str	r4, [sp, #24]
    data_to_send[1].data_location = (uint8 *)&packet_filter;
    613a:	230e      	movs	r3, #14
    data_to_send[0].data_length = sizeof(cid);
    613c:	2401      	movs	r4, #1
    data_to_send[0].data_location = (uint8 *)&cid;
    613e:	ad06      	add	r5, sp, #24
    data_to_send[1].data_location = (uint8 *)&packet_filter;
    6140:	446b      	add	r3, sp
    RPC_ERR rpc_return = rpc_command_claim(CORES_PROTOCOL_CORE);
    6142:	0020      	movs	r0, r4
    data_to_send[0].data_length = sizeof(cid);
    6144:	80ac      	strh	r4, [r5, #4]
    data_to_send[1].data_location = (uint8 *)&packet_filter;
    6146:	9308      	str	r3, [sp, #32]
    data_to_send[1].data_length = sizeof(packet_filter);
    6148:	81ac      	strh	r4, [r5, #12]
    RPC_ERR rpc_return = rpc_command_claim(CORES_PROTOCOL_CORE);
    614a:	f7fc f987 	bl	245c <rpc_command_claim>
    if (rpc_return != RPC_ERR_OK)
    614e:	2800      	cmp	r0, #0
    6150:	d110      	bne.n	6174 <command_get_tft_context+0x66>
    set_receive_info(CORES_PROTOCOL_CORE, &info);
    6152:	0039      	movs	r1, r7
    6154:	0020      	movs	r0, r4
    6156:	f7fb fe23 	bl	1da0 <set_receive_info>
    rpc_interface_scatter_send(CORES_PROTOCOL_CORE, RPC_APPLICATION_TO_PROTOCOL_GET_TFT_CONTEXT, true, 2, data_to_send);
    615a:	0033      	movs	r3, r6
    615c:	0022      	movs	r2, r4
    615e:	216b      	movs	r1, #107	; 0x6b
    6160:	0020      	movs	r0, r4
    6162:	9500      	str	r5, [sp, #0]
    6164:	f7fc f8cc 	bl	2300 <rpc_interface_scatter_send>
    rpc_blocking_loop(CORES_PROTOCOL_CORE);
    6168:	0020      	movs	r0, r4
    616a:	f7fc f94d 	bl	2408 <rpc_blocking_loop>
    return rpc_command_release(CORES_PROTOCOL_CORE);
    616e:	0020      	movs	r0, r4
    6170:	f7fc f960 	bl	2434 <rpc_command_release>
}
    6174:	b011      	add	sp, #68	; 0x44
    6176:	bdf0      	pop	{r4, r5, r6, r7, pc}

00006178 <command_get_pin_state>:
{
    6178:	b570      	push	{r4, r5, r6, lr}
    info.num_sections = 2;
    617a:	2302      	movs	r3, #2
{
    617c:	0006      	movs	r6, r0
    617e:	000c      	movs	r4, r1
    6180:	b08a      	sub	sp, #40	; 0x28
    info.num_sections = 2;
    6182:	ad02      	add	r5, sp, #8
    info.sections = get_sections;
    6184:	a804      	add	r0, sp, #16
    info.num_sections = 2;
    6186:	712b      	strb	r3, [r5, #4]
    rpc_init_receive_section(&get_sections[0], (uint8 *)result, sizeof(uint8), NULL);
    6188:	2201      	movs	r2, #1
    618a:	2300      	movs	r3, #0
    618c:	0031      	movs	r1, r6
    info.sections = get_sections;
    618e:	9002      	str	r0, [sp, #8]
    rpc_init_receive_section(&get_sections[0], (uint8 *)result, sizeof(uint8), NULL);
    6190:	f7fc f935 	bl	23fe <rpc_init_receive_section>
    rpc_init_receive_section(&get_sections[1], (uint8 *)state, sizeof(uint8), NULL);
    6194:	0021      	movs	r1, r4
    6196:	2300      	movs	r3, #0
    6198:	2201      	movs	r2, #1
    619a:	a807      	add	r0, sp, #28
    619c:	f7fc f92f 	bl	23fe <rpc_init_receive_section>
    RPC_ERR rpc_return = rpc_command_claim(CORES_PROTOCOL_CORE);
    61a0:	2001      	movs	r0, #1
    61a2:	f7fc f95b 	bl	245c <rpc_command_claim>
    61a6:	1e04      	subs	r4, r0, #0
    if (rpc_return != RPC_ERR_OK)
    61a8:	d111      	bne.n	61ce <command_get_pin_state+0x56>
    set_receive_info(CORES_PROTOCOL_CORE, &info);
    61aa:	0029      	movs	r1, r5
    61ac:	2001      	movs	r0, #1
    61ae:	f7fb fdf7 	bl	1da0 <set_receive_info>
    rpc_interface_scatter_send(CORES_PROTOCOL_CORE, RPC_APPLICATION_TO_PROTOCOL_GET_PIN_STATE, true, 0, NULL);
    61b2:	2201      	movs	r2, #1
    61b4:	0023      	movs	r3, r4
    61b6:	0010      	movs	r0, r2
    61b8:	2176      	movs	r1, #118	; 0x76
    61ba:	9400      	str	r4, [sp, #0]
    61bc:	f7fc f8a0 	bl	2300 <rpc_interface_scatter_send>
    rpc_blocking_loop(CORES_PROTOCOL_CORE);
    61c0:	2001      	movs	r0, #1
    61c2:	f7fc f921 	bl	2408 <rpc_blocking_loop>
    return rpc_command_release(CORES_PROTOCOL_CORE);
    61c6:	2001      	movs	r0, #1
    61c8:	f7fc f934 	bl	2434 <rpc_command_release>
    61cc:	0004      	movs	r4, r0
}
    61ce:	0020      	movs	r0, r4
    61d0:	b00a      	add	sp, #40	; 0x28
    61d2:	bd70      	pop	{r4, r5, r6, pc}

000061d4 <command_get_pin_remaining_retries>:
{
    61d4:	b5f0      	push	{r4, r5, r6, r7, lr}
    61d6:	240f      	movs	r4, #15
    61d8:	001d      	movs	r5, r3
    info.num_sections = 3;
    61da:	2303      	movs	r3, #3
{
    61dc:	0017      	movs	r7, r2
    61de:	b093      	sub	sp, #76	; 0x4c
    61e0:	446c      	add	r4, sp
    info.num_sections = 3;
    61e2:	ae05      	add	r6, sp, #20
{
    61e4:	7020      	strb	r0, [r4, #0]
    info.num_sections = 3;
    61e6:	7133      	strb	r3, [r6, #4]
    info.sections = get_sections;
    61e8:	a809      	add	r0, sp, #36	; 0x24
    rpc_init_receive_section(&get_sections[0], (uint8 *)result, sizeof(uint8), NULL);
    61ea:	2300      	movs	r3, #0
    61ec:	2201      	movs	r2, #1
    info.sections = get_sections;
    61ee:	9005      	str	r0, [sp, #20]
    rpc_init_receive_section(&get_sections[0], (uint8 *)result, sizeof(uint8), NULL);
    61f0:	f7fc f905 	bl	23fe <rpc_init_receive_section>
    rpc_init_receive_section(&get_sections[1], (uint8 *)retries, sizeof(uint8), NULL);
    61f4:	2300      	movs	r3, #0
    61f6:	2201      	movs	r2, #1
    61f8:	0039      	movs	r1, r7
    61fa:	a80c      	add	r0, sp, #48	; 0x30
    61fc:	f7fc f8ff 	bl	23fe <rpc_init_receive_section>
    rpc_init_receive_section(&get_sections[2], (uint8 *)default_retries, sizeof(uint8), NULL);
    6200:	0029      	movs	r1, r5
    6202:	a80f      	add	r0, sp, #60	; 0x3c
    6204:	2300      	movs	r3, #0
    6206:	2201      	movs	r2, #1
    6208:	f7fc f8f9 	bl	23fe <rpc_init_receive_section>
    data_to_send[0].data_location = (uint8 *)&code;
    620c:	9407      	str	r4, [sp, #28]
    data_to_send[0].data_length = sizeof(code);
    620e:	2401      	movs	r4, #1
    data_to_send[0].data_location = (uint8 *)&code;
    6210:	ad07      	add	r5, sp, #28
    data_to_send[0].data_length = sizeof(code);
    6212:	80ac      	strh	r4, [r5, #4]
    RPC_ERR rpc_return = rpc_command_claim(CORES_PROTOCOL_CORE);
    6214:	0020      	movs	r0, r4
    6216:	f7fc f921 	bl	245c <rpc_command_claim>
    if (rpc_return != RPC_ERR_OK)
    621a:	2800      	cmp	r0, #0
    621c:	d110      	bne.n	6240 <command_get_pin_remaining_retries+0x6c>
    set_receive_info(CORES_PROTOCOL_CORE, &info);
    621e:	0031      	movs	r1, r6
    6220:	0020      	movs	r0, r4
    6222:	f7fb fdbd 	bl	1da0 <set_receive_info>
    rpc_interface_scatter_send(CORES_PROTOCOL_CORE, RPC_APPLICATION_TO_PROTOCOL_GET_PIN_REMAINING_RETRIES, true, 1, data_to_send);
    6226:	0023      	movs	r3, r4
    6228:	0022      	movs	r2, r4
    622a:	2177      	movs	r1, #119	; 0x77
    622c:	0020      	movs	r0, r4
    622e:	9500      	str	r5, [sp, #0]
    6230:	f7fc f866 	bl	2300 <rpc_interface_scatter_send>
    rpc_blocking_loop(CORES_PROTOCOL_CORE);
    6234:	0020      	movs	r0, r4
    6236:	f7fc f8e7 	bl	2408 <rpc_blocking_loop>
    return rpc_command_release(CORES_PROTOCOL_CORE);
    623a:	0020      	movs	r0, r4
    623c:	f7fc f8fa 	bl	2434 <rpc_command_release>
}
    6240:	b013      	add	sp, #76	; 0x4c
    6242:	bdf0      	pop	{r4, r5, r6, r7, pc}

00006244 <command_uicc_status_control>:
{
    6244:	b5f0      	push	{r4, r5, r6, r7, lr}
    6246:	270f      	movs	r7, #15
    info.num_sections = 1;
    6248:	2401      	movs	r4, #1
{
    624a:	b08d      	sub	sp, #52	; 0x34
    624c:	446f      	add	r7, sp
    624e:	7038      	strb	r0, [r7, #0]
    info.num_sections = 1;
    6250:	ae05      	add	r6, sp, #20
    info.sections = get_sections;
    6252:	a809      	add	r0, sp, #36	; 0x24
    rpc_init_receive_section(&get_sections[0], (uint8 *)result, sizeof(uint8), NULL);
    6254:	2300      	movs	r3, #0
    6256:	0022      	movs	r2, r4
    info.sections = get_sections;
    6258:	9005      	str	r0, [sp, #20]
    info.num_sections = 1;
    625a:	7134      	strb	r4, [r6, #4]
    data_to_send[0].data_location = (uint8 *)&status;
    625c:	ad07      	add	r5, sp, #28
    rpc_init_receive_section(&get_sections[0], (uint8 *)result, sizeof(uint8), NULL);
    625e:	f7fc f8ce 	bl	23fe <rpc_init_receive_section>
    RPC_ERR rpc_return = rpc_command_claim(CORES_PROTOCOL_CORE);
    6262:	0020      	movs	r0, r4
    data_to_send[0].data_location = (uint8 *)&status;
    6264:	9707      	str	r7, [sp, #28]
    data_to_send[0].data_length = sizeof(status);
    6266:	80ac      	strh	r4, [r5, #4]
    RPC_ERR rpc_return = rpc_command_claim(CORES_PROTOCOL_CORE);
    6268:	f7fc f8f8 	bl	245c <rpc_command_claim>
    if (rpc_return != RPC_ERR_OK)
    626c:	2800      	cmp	r0, #0
    626e:	d110      	bne.n	6292 <command_uicc_status_control+0x4e>
    set_receive_info(CORES_PROTOCOL_CORE, &info);
    6270:	0031      	movs	r1, r6
    6272:	0020      	movs	r0, r4
    6274:	f7fb fd94 	bl	1da0 <set_receive_info>
    rpc_interface_scatter_send(CORES_PROTOCOL_CORE, RPC_APPLICATION_TO_PROTOCOL_UICC_STATUS_CONTROL, true, 1, data_to_send);
    6278:	0023      	movs	r3, r4
    627a:	0022      	movs	r2, r4
    627c:	2178      	movs	r1, #120	; 0x78
    627e:	0020      	movs	r0, r4
    6280:	9500      	str	r5, [sp, #0]
    6282:	f7fc f83d 	bl	2300 <rpc_interface_scatter_send>
    rpc_blocking_loop(CORES_PROTOCOL_CORE);
    6286:	0020      	movs	r0, r4
    6288:	f7fc f8be 	bl	2408 <rpc_blocking_loop>
    return rpc_command_release(CORES_PROTOCOL_CORE);
    628c:	0020      	movs	r0, r4
    628e:	f7fc f8d1 	bl	2434 <rpc_command_release>
}
    6292:	b00d      	add	sp, #52	; 0x34
    6294:	bdf0      	pop	{r4, r5, r6, r7, pc}

00006296 <command_restricted_sim_access>:
{
    6296:	b5f0      	push	{r4, r5, r6, r7, lr}
    6298:	260e      	movs	r6, #14
    629a:	001c      	movs	r4, r3
    info.num_sections = 2;
    629c:	2502      	movs	r5, #2
{
    629e:	b091      	sub	sp, #68	; 0x44
    62a0:	446e      	add	r6, sp
    62a2:	9102      	str	r1, [sp, #8]
    62a4:	8030      	strh	r0, [r6, #0]
    62a6:	0011      	movs	r1, r2
    info.sections = get_sections;
    62a8:	a80a      	add	r0, sp, #40	; 0x28
    rpc_init_receive_section(&get_sections[0], (uint8 *)result, sizeof(uint8), NULL);
    62aa:	2300      	movs	r3, #0
    62ac:	2201      	movs	r2, #1
    info.num_sections = 2;
    62ae:	af04      	add	r7, sp, #16
    info.sections = get_sections;
    62b0:	9004      	str	r0, [sp, #16]
    info.num_sections = 2;
    62b2:	713d      	strb	r5, [r7, #4]
    rpc_init_receive_section(&get_sections[0], (uint8 *)result, sizeof(uint8), NULL);
    62b4:	f7fc f8a3 	bl	23fe <rpc_init_receive_section>
    rpc_init_receive_section(&get_sections[1], (uint8 *)response, response_max_length, response_length);
    62b8:	9b16      	ldr	r3, [sp, #88]	; 0x58
    62ba:	0022      	movs	r2, r4
    62bc:	a80d      	add	r0, sp, #52	; 0x34
    62be:	9917      	ldr	r1, [sp, #92]	; 0x5c
    62c0:	f7fc f89d 	bl	23fe <rpc_init_receive_section>
    data_to_send[1].data_location = (uint8 *)crsm_cmd;
    62c4:	9b02      	ldr	r3, [sp, #8]
    data_to_send[0].data_location = (uint8 *)&crsm_cmd_length;
    62c6:	ac06      	add	r4, sp, #24
    data_to_send[1].data_location = (uint8 *)crsm_cmd;
    62c8:	9308      	str	r3, [sp, #32]
    data_to_send[1].data_length = crsm_cmd_length;
    62ca:	8833      	ldrh	r3, [r6, #0]
    data_to_send[0].data_length = sizeof(crsm_cmd_length);
    62cc:	80a5      	strh	r5, [r4, #4]
    data_to_send[1].data_length = crsm_cmd_length;
    62ce:	81a3      	strh	r3, [r4, #12]
    RPC_ERR rpc_return = rpc_command_claim(CORES_PROTOCOL_CORE);
    62d0:	2001      	movs	r0, #1
    data_to_send[0].data_location = (uint8 *)&crsm_cmd_length;
    62d2:	9606      	str	r6, [sp, #24]
    RPC_ERR rpc_return = rpc_command_claim(CORES_PROTOCOL_CORE);
    62d4:	f7fc f8c2 	bl	245c <rpc_command_claim>
    if (rpc_return != RPC_ERR_OK)
    62d8:	2800      	cmp	r0, #0
    62da:	d110      	bne.n	62fe <command_restricted_sim_access+0x68>
    set_receive_info(CORES_PROTOCOL_CORE, &info);
    62dc:	0039      	movs	r1, r7
    62de:	3001      	adds	r0, #1
    62e0:	f7fb fd5e 	bl	1da0 <set_receive_info>
    rpc_interface_scatter_send(CORES_PROTOCOL_CORE, RPC_APPLICATION_TO_PROTOCOL_RESTRICTED_SIM_ACCESS, true, 2, data_to_send);
    62e4:	2201      	movs	r2, #1
    62e6:	002b      	movs	r3, r5
    62e8:	0010      	movs	r0, r2
    62ea:	2179      	movs	r1, #121	; 0x79
    62ec:	9400      	str	r4, [sp, #0]
    62ee:	f7fc f807 	bl	2300 <rpc_interface_scatter_send>
    rpc_blocking_loop(CORES_PROTOCOL_CORE);
    62f2:	2001      	movs	r0, #1
    62f4:	f7fc f888 	bl	2408 <rpc_blocking_loop>
    return rpc_command_release(CORES_PROTOCOL_CORE);
    62f8:	2001      	movs	r0, #1
    62fa:	f7fc f89b 	bl	2434 <rpc_command_release>
}
    62fe:	b011      	add	sp, #68	; 0x44
    6300:	bdf0      	pop	{r4, r5, r6, r7, pc}

00006302 <command_get_cid_status>:
{
    6302:	b5f0      	push	{r4, r5, r6, r7, lr}
    6304:	240f      	movs	r4, #15
    6306:	001d      	movs	r5, r3
    info.num_sections = 3;
    6308:	2303      	movs	r3, #3
{
    630a:	0017      	movs	r7, r2
    630c:	b093      	sub	sp, #76	; 0x4c
    630e:	446c      	add	r4, sp
    info.num_sections = 3;
    6310:	ae05      	add	r6, sp, #20
{
    6312:	7020      	strb	r0, [r4, #0]
    info.num_sections = 3;
    6314:	7133      	strb	r3, [r6, #4]
    info.sections = get_sections;
    6316:	a809      	add	r0, sp, #36	; 0x24
    rpc_init_receive_section(&get_sections[0], (uint8 *)ret, sizeof(uint8), NULL);
    6318:	2300      	movs	r3, #0
    631a:	2201      	movs	r2, #1
    info.sections = get_sections;
    631c:	9005      	str	r0, [sp, #20]
    rpc_init_receive_section(&get_sections[0], (uint8 *)ret, sizeof(uint8), NULL);
    631e:	f7fc f86e 	bl	23fe <rpc_init_receive_section>
    rpc_init_receive_section(&get_sections[1], (uint8 *)status, sizeof(uint8), NULL);
    6322:	2300      	movs	r3, #0
    6324:	2201      	movs	r2, #1
    6326:	0039      	movs	r1, r7
    6328:	a80c      	add	r0, sp, #48	; 0x30
    632a:	f7fc f868 	bl	23fe <rpc_init_receive_section>
    rpc_init_receive_section(&get_sections[2], (uint8 *)backoff, sizeof(uint16), NULL);
    632e:	0029      	movs	r1, r5
    6330:	a80f      	add	r0, sp, #60	; 0x3c
    6332:	2300      	movs	r3, #0
    6334:	2202      	movs	r2, #2
    6336:	f7fc f862 	bl	23fe <rpc_init_receive_section>
    data_to_send[0].data_location = (uint8 *)&cid;
    633a:	9407      	str	r4, [sp, #28]
    data_to_send[0].data_length = sizeof(cid);
    633c:	2401      	movs	r4, #1
    data_to_send[0].data_location = (uint8 *)&cid;
    633e:	ad07      	add	r5, sp, #28
    data_to_send[0].data_length = sizeof(cid);
    6340:	80ac      	strh	r4, [r5, #4]
    RPC_ERR rpc_return = rpc_command_claim(CORES_PROTOCOL_CORE);
    6342:	0020      	movs	r0, r4
    6344:	f7fc f88a 	bl	245c <rpc_command_claim>
    if (rpc_return != RPC_ERR_OK)
    6348:	2800      	cmp	r0, #0
    634a:	d110      	bne.n	636e <command_get_cid_status+0x6c>
    set_receive_info(CORES_PROTOCOL_CORE, &info);
    634c:	0031      	movs	r1, r6
    634e:	0020      	movs	r0, r4
    6350:	f7fb fd26 	bl	1da0 <set_receive_info>
    rpc_interface_scatter_send(CORES_PROTOCOL_CORE, RPC_APPLICATION_TO_PROTOCOL_GET_CID_STATUS, true, 1, data_to_send);
    6354:	0023      	movs	r3, r4
    6356:	0022      	movs	r2, r4
    6358:	217a      	movs	r1, #122	; 0x7a
    635a:	0020      	movs	r0, r4
    635c:	9500      	str	r5, [sp, #0]
    635e:	f7fb ffcf 	bl	2300 <rpc_interface_scatter_send>
    rpc_blocking_loop(CORES_PROTOCOL_CORE);
    6362:	0020      	movs	r0, r4
    6364:	f7fc f850 	bl	2408 <rpc_blocking_loop>
    return rpc_command_release(CORES_PROTOCOL_CORE);
    6368:	0020      	movs	r0, r4
    636a:	f7fc f863 	bl	2434 <rpc_command_release>
}
    636e:	b013      	add	sp, #76	; 0x4c
    6370:	bdf0      	pop	{r4, r5, r6, r7, pc}

00006372 <command_get_socket_status>:
{
    6372:	b5f0      	push	{r4, r5, r6, r7, lr}
    6374:	240f      	movs	r4, #15
    6376:	001d      	movs	r5, r3
    info.num_sections = 3;
    6378:	2303      	movs	r3, #3
{
    637a:	0017      	movs	r7, r2
    637c:	b093      	sub	sp, #76	; 0x4c
    637e:	446c      	add	r4, sp
    info.num_sections = 3;
    6380:	ae05      	add	r6, sp, #20
{
    6382:	7020      	strb	r0, [r4, #0]
    info.num_sections = 3;
    6384:	7133      	strb	r3, [r6, #4]
    info.sections = get_sections;
    6386:	a809      	add	r0, sp, #36	; 0x24
    rpc_init_receive_section(&get_sections[0], (uint8 *)ret, sizeof(uint8), NULL);
    6388:	2300      	movs	r3, #0
    638a:	2201      	movs	r2, #1
    info.sections = get_sections;
    638c:	9005      	str	r0, [sp, #20]
    rpc_init_receive_section(&get_sections[0], (uint8 *)ret, sizeof(uint8), NULL);
    638e:	f7fc f836 	bl	23fe <rpc_init_receive_section>
    rpc_init_receive_section(&get_sections[1], (uint8 *)status, sizeof(uint8), NULL);
    6392:	2300      	movs	r3, #0
    6394:	2201      	movs	r2, #1
    6396:	0039      	movs	r1, r7
    6398:	a80c      	add	r0, sp, #48	; 0x30
    639a:	f7fc f830 	bl	23fe <rpc_init_receive_section>
    rpc_init_receive_section(&get_sections[2], (uint8 *)backoff, sizeof(uint16), NULL);
    639e:	0029      	movs	r1, r5
    63a0:	a80f      	add	r0, sp, #60	; 0x3c
    63a2:	2300      	movs	r3, #0
    63a4:	2202      	movs	r2, #2
    63a6:	f7fc f82a 	bl	23fe <rpc_init_receive_section>
    data_to_send[0].data_location = (uint8 *)&socketid;
    63aa:	9407      	str	r4, [sp, #28]
    data_to_send[0].data_length = sizeof(socketid);
    63ac:	2401      	movs	r4, #1
    data_to_send[0].data_location = (uint8 *)&socketid;
    63ae:	ad07      	add	r5, sp, #28
    data_to_send[0].data_length = sizeof(socketid);
    63b0:	80ac      	strh	r4, [r5, #4]
    RPC_ERR rpc_return = rpc_command_claim(CORES_PROTOCOL_CORE);
    63b2:	0020      	movs	r0, r4
    63b4:	f7fc f852 	bl	245c <rpc_command_claim>
    if (rpc_return != RPC_ERR_OK)
    63b8:	2800      	cmp	r0, #0
    63ba:	d110      	bne.n	63de <command_get_socket_status+0x6c>
    set_receive_info(CORES_PROTOCOL_CORE, &info);
    63bc:	0031      	movs	r1, r6
    63be:	0020      	movs	r0, r4
    63c0:	f7fb fcee 	bl	1da0 <set_receive_info>
    rpc_interface_scatter_send(CORES_PROTOCOL_CORE, RPC_APPLICATION_TO_PROTOCOL_GET_SOCKET_STATUS, true, 1, data_to_send);
    63c4:	0023      	movs	r3, r4
    63c6:	0022      	movs	r2, r4
    63c8:	217b      	movs	r1, #123	; 0x7b
    63ca:	0020      	movs	r0, r4
    63cc:	9500      	str	r5, [sp, #0]
    63ce:	f7fb ff97 	bl	2300 <rpc_interface_scatter_send>
    rpc_blocking_loop(CORES_PROTOCOL_CORE);
    63d2:	0020      	movs	r0, r4
    63d4:	f7fc f818 	bl	2408 <rpc_blocking_loop>
    return rpc_command_release(CORES_PROTOCOL_CORE);
    63d8:	0020      	movs	r0, r4
    63da:	f7fc f82b 	bl	2434 <rpc_command_release>
}
    63de:	b013      	add	sp, #76	; 0x4c
    63e0:	bdf0      	pop	{r4, r5, r6, r7, pc}

000063e2 <command_radio_config_tx_calist>:
{
    63e2:	b5f0      	push	{r4, r5, r6, r7, lr}
    63e4:	270b      	movs	r7, #11
    info.num_sections = 1;
    63e6:	2501      	movs	r5, #1
{
    63e8:	b09d      	sub	sp, #116	; 0x74
    63ea:	446f      	add	r7, sp
    63ec:	9005      	str	r0, [sp, #20]
    63ee:	9104      	str	r1, [sp, #16]
    info.sections = get_sections;
    63f0:	a809      	add	r0, sp, #36	; 0x24
{
    63f2:	9203      	str	r2, [sp, #12]
    63f4:	703b      	strb	r3, [r7, #0]
    rpc_init_receive_section(&get_sections[0], (uint8 *)result, sizeof(uint8), NULL);
    63f6:	002a      	movs	r2, r5
    63f8:	2300      	movs	r3, #0
    info.num_sections = 1;
    63fa:	ae07      	add	r6, sp, #28
    rpc_init_receive_section(&get_sections[0], (uint8 *)result, sizeof(uint8), NULL);
    63fc:	9926      	ldr	r1, [sp, #152]	; 0x98
    info.sections = get_sections;
    63fe:	9007      	str	r0, [sp, #28]
    info.num_sections = 1;
    6400:	7135      	strb	r5, [r6, #4]
    rpc_init_receive_section(&get_sections[0], (uint8 *)result, sizeof(uint8), NULL);
    6402:	f7fb fffc 	bl	23fe <rpc_init_receive_section>
    data_to_send[0].data_location = (uint8 *)&start_frequency;
    6406:	ab05      	add	r3, sp, #20
    6408:	930c      	str	r3, [sp, #48]	; 0x30
    data_to_send[0].data_length = sizeof(start_frequency);
    640a:	2304      	movs	r3, #4
    data_to_send[0].data_location = (uint8 *)&start_frequency;
    640c:	ac0c      	add	r4, sp, #48	; 0x30
    data_to_send[0].data_length = sizeof(start_frequency);
    640e:	80a3      	strh	r3, [r4, #4]
    data_to_send[1].data_length = sizeof(step_frequency);
    6410:	81a3      	strh	r3, [r4, #12]
    data_to_send[2].data_length = sizeof(stop_frequency);
    6412:	82a3      	strh	r3, [r4, #20]
    data_to_send[4].data_location = (uint8 *)&step_power;
    6414:	ab22      	add	r3, sp, #136	; 0x88
    6416:	9314      	str	r3, [sp, #80]	; 0x50
    data_to_send[5].data_location = (uint8 *)&stop_power;
    6418:	ab23      	add	r3, sp, #140	; 0x8c
    data_to_send[1].data_location = (uint8 *)&step_frequency;
    641a:	aa04      	add	r2, sp, #16
    data_to_send[5].data_location = (uint8 *)&stop_power;
    641c:	9316      	str	r3, [sp, #88]	; 0x58
    data_to_send[6].data_location = (uint8 *)&num_subcarrier;
    641e:	ab24      	add	r3, sp, #144	; 0x90
    data_to_send[1].data_location = (uint8 *)&step_frequency;
    6420:	920e      	str	r2, [sp, #56]	; 0x38
    data_to_send[6].data_location = (uint8 *)&num_subcarrier;
    6422:	9318      	str	r3, [sp, #96]	; 0x60
    data_to_send[2].data_location = (uint8 *)&stop_frequency;
    6424:	aa03      	add	r2, sp, #12
    data_to_send[7].data_location = (uint8 *)&subcarrier_index;
    6426:	ab25      	add	r3, sp, #148	; 0x94
    RPC_ERR rpc_return = rpc_command_claim(CORES_PROTOCOL_CORE);
    6428:	0028      	movs	r0, r5
    data_to_send[2].data_location = (uint8 *)&stop_frequency;
    642a:	9210      	str	r2, [sp, #64]	; 0x40
    data_to_send[3].data_location = (uint8 *)&start_power;
    642c:	9712      	str	r7, [sp, #72]	; 0x48
    data_to_send[3].data_length = sizeof(start_power);
    642e:	83a5      	strh	r5, [r4, #28]
    data_to_send[4].data_length = sizeof(step_power);
    6430:	84a5      	strh	r5, [r4, #36]	; 0x24
    data_to_send[5].data_length = sizeof(stop_power);
    6432:	85a5      	strh	r5, [r4, #44]	; 0x2c
    data_to_send[6].data_length = sizeof(num_subcarrier);
    6434:	86a5      	strh	r5, [r4, #52]	; 0x34
    data_to_send[7].data_location = (uint8 *)&subcarrier_index;
    6436:	931a      	str	r3, [sp, #104]	; 0x68
    data_to_send[7].data_length = sizeof(subcarrier_index);
    6438:	87a5      	strh	r5, [r4, #60]	; 0x3c
    RPC_ERR rpc_return = rpc_command_claim(CORES_PROTOCOL_CORE);
    643a:	f7fc f80f 	bl	245c <rpc_command_claim>
    if (rpc_return != RPC_ERR_OK)
    643e:	2800      	cmp	r0, #0
    6440:	d110      	bne.n	6464 <command_radio_config_tx_calist+0x82>
    set_receive_info(CORES_PROTOCOL_CORE, &info);
    6442:	0031      	movs	r1, r6
    6444:	0028      	movs	r0, r5
    6446:	f7fb fcab 	bl	1da0 <set_receive_info>
    rpc_interface_scatter_send(CORES_PROTOCOL_CORE, RPC_APPLICATION_TO_PROTOCOL_RADIO_CONFIG_TX_CALIST, true, 8, data_to_send);
    644a:	2308      	movs	r3, #8
    644c:	002a      	movs	r2, r5
    644e:	217c      	movs	r1, #124	; 0x7c
    6450:	0028      	movs	r0, r5
    6452:	9400      	str	r4, [sp, #0]
    6454:	f7fb ff54 	bl	2300 <rpc_interface_scatter_send>
    rpc_blocking_loop(CORES_PROTOCOL_CORE);
    6458:	0028      	movs	r0, r5
    645a:	f7fb ffd5 	bl	2408 <rpc_blocking_loop>
    return rpc_command_release(CORES_PROTOCOL_CORE);
    645e:	0028      	movs	r0, r5
    6460:	f7fb ffe8 	bl	2434 <rpc_command_release>
}
    6464:	b01d      	add	sp, #116	; 0x74
    6466:	bdf0      	pop	{r4, r5, r6, r7, pc}

00006468 <command_radio_config_rx_calist>:
{
    6468:	b5f0      	push	{r4, r5, r6, r7, lr}
    646a:	270b      	movs	r7, #11
    info.num_sections = 1;
    646c:	2501      	movs	r5, #1
{
    646e:	b0a1      	sub	sp, #132	; 0x84
    6470:	446f      	add	r7, sp
    6472:	9005      	str	r0, [sp, #20]
    6474:	9104      	str	r1, [sp, #16]
    info.sections = get_sections;
    6476:	a809      	add	r0, sp, #36	; 0x24
{
    6478:	9203      	str	r2, [sp, #12]
    647a:	703b      	strb	r3, [r7, #0]
    rpc_init_receive_section(&get_sections[0], (uint8 *)result, sizeof(uint8), NULL);
    647c:	002a      	movs	r2, r5
    647e:	2300      	movs	r3, #0
    info.num_sections = 1;
    6480:	ae07      	add	r6, sp, #28
    rpc_init_receive_section(&get_sections[0], (uint8 *)result, sizeof(uint8), NULL);
    6482:	992c      	ldr	r1, [sp, #176]	; 0xb0
    data_to_send[0].data_location = (uint8 *)&start_frequency;
    6484:	ac0c      	add	r4, sp, #48	; 0x30
    info.sections = get_sections;
    6486:	9007      	str	r0, [sp, #28]
    info.num_sections = 1;
    6488:	7135      	strb	r5, [r6, #4]
    rpc_init_receive_section(&get_sections[0], (uint8 *)result, sizeof(uint8), NULL);
    648a:	f7fb ffb8 	bl	23fe <rpc_init_receive_section>
    data_to_send[1].data_location = (uint8 *)&step_frequency;
    648e:	aa04      	add	r2, sp, #16
    6490:	60a2      	str	r2, [r4, #8]
    data_to_send[2].data_location = (uint8 *)&stop_frequency;
    6492:	aa03      	add	r2, sp, #12
    6494:	6122      	str	r2, [r4, #16]
    data_to_send[4].data_location = (uint8 *)&step_agc_index;
    6496:	aa26      	add	r2, sp, #152	; 0x98
    6498:	6222      	str	r2, [r4, #32]
    data_to_send[5].data_location = (uint8 *)&stop_agc_index;
    649a:	aa27      	add	r2, sp, #156	; 0x9c
    649c:	62a2      	str	r2, [r4, #40]	; 0x28
    data_to_send[6].data_location = (uint8 *)&ul_power;
    649e:	aa28      	add	r2, sp, #160	; 0xa0
    64a0:	6322      	str	r2, [r4, #48]	; 0x30
    data_to_send[6].data_length = sizeof(ul_power);
    64a2:	2202      	movs	r2, #2
    64a4:	86a2      	strh	r2, [r4, #52]	; 0x34
    data_to_send[7].data_location = (uint8 *)&ul_freq;
    64a6:	aa29      	add	r2, sp, #164	; 0xa4
    64a8:	63a2      	str	r2, [r4, #56]	; 0x38
    data_to_send[8].data_location = (uint8 *)&rssi_meas_duration;
    64aa:	aa2a      	add	r2, sp, #168	; 0xa8
    data_to_send[0].data_location = (uint8 *)&start_frequency;
    64ac:	ab05      	add	r3, sp, #20
    data_to_send[8].data_location = (uint8 *)&rssi_meas_duration;
    64ae:	6422      	str	r2, [r4, #64]	; 0x40
    data_to_send[8].data_length = sizeof(rssi_meas_duration);
    64b0:	2236      	movs	r2, #54	; 0x36
    data_to_send[0].data_location = (uint8 *)&start_frequency;
    64b2:	930c      	str	r3, [sp, #48]	; 0x30
    data_to_send[0].data_length = sizeof(start_frequency);
    64b4:	2304      	movs	r3, #4
    data_to_send[8].data_length = sizeof(rssi_meas_duration);
    64b6:	446a      	add	r2, sp
    data_to_send[0].data_length = sizeof(start_frequency);
    64b8:	80a3      	strh	r3, [r4, #4]
    data_to_send[1].data_length = sizeof(step_frequency);
    64ba:	81a3      	strh	r3, [r4, #12]
    data_to_send[2].data_length = sizeof(stop_frequency);
    64bc:	82a3      	strh	r3, [r4, #20]
    data_to_send[7].data_length = sizeof(ul_freq);
    64be:	87a3      	strh	r3, [r4, #60]	; 0x3c
    data_to_send[8].data_length = sizeof(rssi_meas_duration);
    64c0:	87d3      	strh	r3, [r2, #62]	; 0x3e
    data_to_send[9].data_location = (uint8 *)&sweep_band;
    64c2:	ab2b      	add	r3, sp, #172	; 0xac
    64c4:	64a3      	str	r3, [r4, #72]	; 0x48
    data_to_send[9].data_length = sizeof(sweep_band);
    64c6:	ab1f      	add	r3, sp, #124	; 0x7c
    64c8:	801d      	strh	r5, [r3, #0]
    RPC_ERR rpc_return = rpc_command_claim(CORES_PROTOCOL_CORE);
    64ca:	0028      	movs	r0, r5
    data_to_send[3].data_location = (uint8 *)&start_agc_index;
    64cc:	61a7      	str	r7, [r4, #24]
    data_to_send[3].data_length = sizeof(start_agc_index);
    64ce:	83a5      	strh	r5, [r4, #28]
    data_to_send[4].data_length = sizeof(step_agc_index);
    64d0:	84a5      	strh	r5, [r4, #36]	; 0x24
    data_to_send[5].data_length = sizeof(stop_agc_index);
    64d2:	85a5      	strh	r5, [r4, #44]	; 0x2c
    RPC_ERR rpc_return = rpc_command_claim(CORES_PROTOCOL_CORE);
    64d4:	f7fb ffc2 	bl	245c <rpc_command_claim>
    if (rpc_return != RPC_ERR_OK)
    64d8:	2800      	cmp	r0, #0
    64da:	d110      	bne.n	64fe <command_radio_config_rx_calist+0x96>
    set_receive_info(CORES_PROTOCOL_CORE, &info);
    64dc:	0031      	movs	r1, r6
    64de:	0028      	movs	r0, r5
    64e0:	f7fb fc5e 	bl	1da0 <set_receive_info>
    rpc_interface_scatter_send(CORES_PROTOCOL_CORE, RPC_APPLICATION_TO_PROTOCOL_RADIO_CONFIG_RX_CALIST, true, 10, data_to_send);
    64e4:	230a      	movs	r3, #10
    64e6:	002a      	movs	r2, r5
    64e8:	217d      	movs	r1, #125	; 0x7d
    64ea:	0028      	movs	r0, r5
    64ec:	9400      	str	r4, [sp, #0]
    64ee:	f7fb ff07 	bl	2300 <rpc_interface_scatter_send>
    rpc_blocking_loop(CORES_PROTOCOL_CORE);
    64f2:	0028      	movs	r0, r5
    64f4:	f7fb ff88 	bl	2408 <rpc_blocking_loop>
    return rpc_command_release(CORES_PROTOCOL_CORE);
    64f8:	0028      	movs	r0, r5
    64fa:	f7fb ff9b 	bl	2434 <rpc_command_release>
}
    64fe:	b021      	add	sp, #132	; 0x84
    6500:	bdf0      	pop	{r4, r5, r6, r7, pc}
	...

00006504 <internal_incomming_response_default_blocking_response>:

/*
 * Incoming Responses
*/
void internal_incomming_response_default_blocking_response(CORES core)
{
    6504:	b570      	push	{r4, r5, r6, lr}
    assert(rpc_auto_generated_handles[core].blocking);
    6506:	4c0a      	ldr	r4, [pc, #40]	; (6530 <internal_incomming_response_default_blocking_response+0x2c>)
    6508:	0046      	lsls	r6, r0, #1
    650a:	19a3      	adds	r3, r4, r6
    650c:	785b      	ldrb	r3, [r3, #1]
{
    650e:	0005      	movs	r5, r0
    assert(rpc_auto_generated_handles[core].blocking);
    6510:	2b00      	cmp	r3, #0
    6512:	d103      	bne.n	651c <internal_incomming_response_default_blocking_response+0x18>
    6514:	4671      	mov	r1, lr
    6516:	2016      	movs	r0, #22
    6518:	f7fb fafa 	bl	1b10 <panic>
    rpc_auto_generated_handles[core].blocking = false;
    651c:	2300      	movs	r3, #0
    651e:	19a4      	adds	r4, r4, r6
    6520:	7063      	strb	r3, [r4, #1]
    if (rpc_mailboxes.outgoing_command_send_from_isr)
    6522:	4b04      	ldr	r3, [pc, #16]	; (6534 <internal_incomming_response_default_blocking_response+0x30>)
    6524:	68db      	ldr	r3, [r3, #12]
    6526:	2b00      	cmp	r3, #0
    6528:	d001      	beq.n	652e <internal_incomming_response_default_blocking_response+0x2a>
    {
        rpc_mailboxes.outgoing_command_send_from_isr(core);
    652a:	0028      	movs	r0, r5
    652c:	4798      	blx	r3
    }
}
    652e:	bd70      	pop	{r4, r5, r6, pc}
    6530:	01002e34 	.word	0x01002e34
    6534:	01002e10 	.word	0x01002e10

00006538 <rpc_get_buffer>:
#include "neulfw.h"
#include "rpc_private.h"
#include <string.h>

uint8 *rpc_get_buffer(uint8 *buffer, uint16 *buffer_position, uint16 amount)
{
    6538:	b510      	push	{r4, lr}
    *buffer_position += amount;
    653a:	880c      	ldrh	r4, [r1, #0]
    653c:	1914      	adds	r4, r2, r4
    653e:	b2a3      	uxth	r3, r4
    6540:	800b      	strh	r3, [r1, #0]
    return &buffer[*buffer_position - amount];
    6542:	1a9b      	subs	r3, r3, r2
    6544:	18c0      	adds	r0, r0, r3
}
    6546:	bd10      	pop	{r4, pc}

00006548 <rpc_get_int64>:

//lint -esym(759, rpc_get_int64)  Lint has spotted that this is not used at the moment, header could be moved
//lint -esym(714, rpc_get_int64)  Lint has spotted that this is not used at the moment
int64 rpc_get_int64(uint8 *buffer, uint16 *buffer_position)
{
    6548:	b537      	push	{r0, r1, r2, r4, r5, lr}
    int64 result = 0;
    654a:	2300      	movs	r3, #0
    654c:	2200      	movs	r2, #0
    654e:	880c      	ldrh	r4, [r1, #0]
{
    6550:	000d      	movs	r5, r1
    int64 result = 0;
    6552:	9200      	str	r2, [sp, #0]
    6554:	9301      	str	r3, [sp, #4]
    6556:	1901      	adds	r1, r0, r4
    if (((uint32)buffer & 0xfffffffC) == (uint32)buffer)
    6558:	0783      	lsls	r3, r0, #30
    655a:	d109      	bne.n	6570 <rpc_get_int64+0x28>
    {
        result = *(int64*)(&buffer[*buffer_position]);      //lint !e826   Extract 'useful data' from RPC payload
    655c:	680a      	ldr	r2, [r1, #0]
    655e:	684b      	ldr	r3, [r1, #4]
    6560:	9200      	str	r2, [sp, #0]
    6562:	9301      	str	r3, [sp, #4]
    {
        memcpy(&result, &buffer[*buffer_position], 8);
    }
    *buffer_position += 8;
    return result;
}
    6564:	9800      	ldr	r0, [sp, #0]
    6566:	9901      	ldr	r1, [sp, #4]
    *buffer_position += 8;
    6568:	3408      	adds	r4, #8
    656a:	802c      	strh	r4, [r5, #0]
}
    656c:	b003      	add	sp, #12
    656e:	bd30      	pop	{r4, r5, pc}
        memcpy(&result, &buffer[*buffer_position], 8);
    6570:	2208      	movs	r2, #8
    6572:	4668      	mov	r0, sp
    6574:	f7f9 fe3c 	bl	1f0 <memcpy>
    6578:	e7f4      	b.n	6564 <rpc_get_int64+0x1c>

0000657a <rpc_get_int32>:

int32 rpc_get_int32(uint8 *buffer, uint16 *buffer_position)
{
    int32 result = 0;
    657a:	2300      	movs	r3, #0
{
    657c:	b537      	push	{r0, r1, r2, r4, r5, lr}
    657e:	880c      	ldrh	r4, [r1, #0]
    6580:	000d      	movs	r5, r1
    int32 result = 0;
    6582:	9301      	str	r3, [sp, #4]
    6584:	1901      	adds	r1, r0, r4
    if (((uint32)buffer & 0xfffffffC) == (uint32)buffer)
    6586:	0783      	lsls	r3, r0, #30
    6588:	d105      	bne.n	6596 <rpc_get_int32+0x1c>
    {
        result = *(int32*)(&buffer[*buffer_position]);      //lint !e826   Extract 'useful data' from RPC payload
    658a:	680b      	ldr	r3, [r1, #0]
    658c:	9301      	str	r3, [sp, #4]
    else
    {
        //Not bus alligned :(
        memcpy(&result, &buffer[*buffer_position], 4);
    }
    *buffer_position += 4;
    658e:	3404      	adds	r4, #4
    6590:	802c      	strh	r4, [r5, #0]
    return result;
}
    6592:	9801      	ldr	r0, [sp, #4]
    6594:	bd3e      	pop	{r1, r2, r3, r4, r5, pc}
        memcpy(&result, &buffer[*buffer_position], 4);
    6596:	2204      	movs	r2, #4
    6598:	a801      	add	r0, sp, #4
    659a:	f7f9 fe29 	bl	1f0 <memcpy>
    659e:	e7f6      	b.n	658e <rpc_get_int32+0x14>

000065a0 <rpc_get_int16>:

int16 rpc_get_int16(const uint8 *buffer, uint16 *buffer_position)
{
    65a0:	b573      	push	{r0, r1, r4, r5, r6, lr}
    int16 result = 0;
    memcpy(&result, &buffer[*buffer_position], 2);
    65a2:	466b      	mov	r3, sp
{
    65a4:	000e      	movs	r6, r1
    memcpy(&result, &buffer[*buffer_position], 2);
    65a6:	880c      	ldrh	r4, [r1, #0]
    65a8:	1d9d      	adds	r5, r3, #6
    65aa:	1901      	adds	r1, r0, r4
    65ac:	2202      	movs	r2, #2
    65ae:	0028      	movs	r0, r5
    *buffer_position += 2;
    65b0:	3402      	adds	r4, #2
    memcpy(&result, &buffer[*buffer_position], 2);
    65b2:	f7f9 fe1d 	bl	1f0 <memcpy>
    return result;
    65b6:	2300      	movs	r3, #0
    65b8:	5ee8      	ldrsh	r0, [r5, r3]
    *buffer_position += 2;
    65ba:	8034      	strh	r4, [r6, #0]
}
    65bc:	bd76      	pop	{r1, r2, r4, r5, r6, pc}

000065be <rpc_get_int8>:

//lint -esym(714, rpc_get_int8)  Lint has spotted that this is not used at the moment in the updater build
int8 rpc_get_int8(const uint8 *buffer, uint16 *buffer_position)
{
    *buffer_position += 1;
    65be:	880a      	ldrh	r2, [r1, #0]
    65c0:	3201      	adds	r2, #1
    65c2:	b292      	uxth	r2, r2
    return *(int8*)(&buffer[(*buffer_position) - 1]);
    65c4:	1880      	adds	r0, r0, r2
    *buffer_position += 1;
    65c6:	800a      	strh	r2, [r1, #0]
    return *(int8*)(&buffer[(*buffer_position) - 1]);
    65c8:	3801      	subs	r0, #1
    65ca:	7800      	ldrb	r0, [r0, #0]
    65cc:	b240      	sxtb	r0, r0
}
    65ce:	4770      	bx	lr

000065d0 <log_init>:
#ifdef USE_CMSIS_OS
static osMutexId_t mutex = NULL;
#endif

void log_init( void )
{
    65d0:	b510      	push	{r4, lr}
    log_buffer_init(LOG_MEMORY_REGION_SECTION_CORE);
    65d2:	2002      	movs	r0, #2
    65d4:	f011 f840 	bl	17658 <log_buffer_init>

    /* Only reset data, if there isn't anything already there as we want to trigger TX on a reboot. */
    if (!preserve_valid())
    65d8:	f015 f8fa 	bl	1b7d0 <preserve_valid>
    65dc:	2800      	cmp	r0, #0
    65de:	d101      	bne.n	65e4 <log_init+0x14>
    {
        missed_messages = 0;
    65e0:	4b01      	ldr	r3, [pc, #4]	; (65e8 <log_init+0x18>)
    65e2:	6018      	str	r0, [r3, #0]
    }
}
    65e4:	bd10      	pop	{r4, pc}
    65e6:	46c0      	nop			; (mov r8, r8)
    65e8:	0100148c 	.word	0x0100148c

000065ec <log_full_log_enabled_init>:

void log_full_log_enabled_init( void )
{
    65ec:	b513      	push	{r0, r1, r4, lr}
    NEUL_LOG_BEHAVIOUR_CONFIG log_behaviour_config;
    NEUL_RET                  neul_ret;

    neul_ret = neul_log_get_log_behaviour_restricted(&log_behaviour_config);
    65ee:	466b      	mov	r3, sp
    65f0:	1ddc      	adds	r4, r3, #7
    65f2:	0020      	movs	r0, r4
    65f4:	f001 f98e 	bl	7914 <neul_log_get_log_behaviour_restricted>
    65f8:	4b05      	ldr	r3, [pc, #20]	; (6610 <log_full_log_enabled_init+0x24>)
    if ((neul_ret == NEUL_RET_OK) && (log_behaviour_config == NEUL_LOG_BEHAVIOUR_CONFIG_RESTRICTED))
    65fa:	2800      	cmp	r0, #0
    65fc:	d104      	bne.n	6608 <log_full_log_enabled_init+0x1c>
    65fe:	7822      	ldrb	r2, [r4, #0]
    6600:	2a01      	cmp	r2, #1
    6602:	d101      	bne.n	6608 <log_full_log_enabled_init+0x1c>
    {
        log_is_full_log_enabled = false;
    6604:	7018      	strb	r0, [r3, #0]
    }
    else
    {
        log_is_full_log_enabled = true;
    }
}
    6606:	bd13      	pop	{r0, r1, r4, pc}
        log_is_full_log_enabled = true;
    6608:	2201      	movs	r2, #1
    660a:	701a      	strb	r2, [r3, #0]
}
    660c:	e7fb      	b.n	6606 <log_full_log_enabled_init+0x1a>
    660e:	46c0      	nop			; (mov r8, r8)
    6610:	01001488 	.word	0x01001488

00006614 <log_init_after_rtos>:

#ifdef USE_CMSIS_OS
void log_init_after_rtos( void )
{
    6614:	b510      	push	{r4, lr}
    /* Create the mutex used to control read/write pointer updates. */
    mutex = osMutexNew(NULL);
    6616:	2000      	movs	r0, #0
    6618:	f00e f9ae 	bl	14978 <osMutexNew>
    661c:	4b03      	ldr	r3, [pc, #12]	; (662c <log_init_after_rtos+0x18>)
    661e:	1e01      	subs	r1, r0, #0
    6620:	6018      	str	r0, [r3, #0]
    if(!mutex)
    6622:	d102      	bne.n	662a <log_init_after_rtos+0x16>
    {
        panic(PANIC_LOG, LOG_PANIC_MUTEX_NOT_READY);
    6624:	200d      	movs	r0, #13
    6626:	f7fb fa73 	bl	1b10 <panic>
    }
}
    662a:	bd10      	pop	{r4, pc}
    662c:	01001490 	.word	0x01001490

00006630 <log_get_verbosity>:
    log_is_enabled_state = true;
}

log_verbosity_t log_get_verbosity(void)
{
    return log_current_verbosity;
    6630:	4b01      	ldr	r3, [pc, #4]	; (6638 <log_get_verbosity+0x8>)
    6632:	7818      	ldrb	r0, [r3, #0]
}
    6634:	4770      	bx	lr
    6636:	46c0      	nop			; (mov r8, r8)
    6638:	01000590 	.word	0x01000590

0000663c <log_event>:
    return logged;
} //lint !e454 !e456


void log_event(log_module_id_t module,  log_verbosity_t verbosity, log_flags_t kv_flags, log_message_id_t id, uint16 len, const uint8 *buffer )
{
    663c:	b5f0      	push	{r4, r5, r6, r7, lr}
    663e:	b08b      	sub	sp, #44	; 0x2c
    6640:	9305      	str	r3, [sp, #20]
    6642:	ab10      	add	r3, sp, #64	; 0x40
    6644:	881e      	ldrh	r6, [r3, #0]
    6646:	4674      	mov	r4, lr
    6648:	9004      	str	r0, [sp, #16]
    664a:	9101      	str	r1, [sp, #4]
    664c:	9202      	str	r2, [sp, #8]
    uint32 time_us = (uint32) hal_rtc_get_time_us();
    664e:	f013 f877 	bl	19740 <hal_rtc_get_time_us>
    if ( !log_is_enabled_state || log_current_verbosity > verbosity)
    6652:	4b48      	ldr	r3, [pc, #288]	; (6774 <log_event+0x138>)
    uint32 time_us = (uint32) hal_rtc_get_time_us();
    6654:	9003      	str	r0, [sp, #12]
    if ( !log_is_enabled_state || log_current_verbosity > verbosity)
    6656:	781d      	ldrb	r5, [r3, #0]
    6658:	2d00      	cmp	r5, #0
    665a:	d100      	bne.n	665e <log_event+0x22>
    665c:	e086      	b.n	676c <log_event+0x130>
    665e:	4b46      	ldr	r3, [pc, #280]	; (6778 <log_event+0x13c>)
    6660:	9a01      	ldr	r2, [sp, #4]
    6662:	781b      	ldrb	r3, [r3, #0]
    6664:	4293      	cmp	r3, r2
    6666:	d900      	bls.n	666a <log_event+0x2e>
    6668:	e080      	b.n	676c <log_event+0x130>
    if ((kv_flags == LOG_FLAGS_RESTRICTED) && ((log_full_log_enabled() == false)))
    666a:	9b02      	ldr	r3, [sp, #8]
    666c:	2b04      	cmp	r3, #4
    666e:	d103      	bne.n	6678 <log_event+0x3c>

#endif

bool log_full_log_enabled(void)
{
    return log_is_full_log_enabled;
    6670:	4b42      	ldr	r3, [pc, #264]	; (677c <log_event+0x140>)
    if ((kv_flags == LOG_FLAGS_RESTRICTED) && ((log_full_log_enabled() == false)))
    6672:	781b      	ldrb	r3, [r3, #0]
    6674:	2b00      	cmp	r3, #0
    6676:	d079      	beq.n	676c <log_event+0x130>
    if (osKernelGetState() == osKernelRunning)
    6678:	f00e f82c 	bl	146d4 <osKernelGetState>
    667c:	2802      	cmp	r0, #2
    667e:	d10b      	bne.n	6698 <log_event+0x5c>
        if(osMutexAcquire(mutex, osWaitForever) != osOK)
    6680:	2101      	movs	r1, #1
    6682:	4b3f      	ldr	r3, [pc, #252]	; (6780 <log_event+0x144>)
    6684:	4249      	negs	r1, r1
    6686:	6818      	ldr	r0, [r3, #0]
    6688:	f00e f98c 	bl	149a4 <osMutexAcquire>
    668c:	2800      	cmp	r0, #0
    668e:	d003      	beq.n	6698 <log_event+0x5c>
            panic(PANIC_LOG, LOG_PANIC_MUTEX_NOT_READY);    //lint !e454 Semaphore not taken if error code returned, but Lint doesn't know that.
    6690:	2100      	movs	r1, #0
    6692:	200d      	movs	r0, #13
    6694:	f7fb fa3c 	bl	1b10 <panic>
    lb_available = 0;
    6698:	ab06      	add	r3, sp, #24
    669a:	1c98      	adds	r0, r3, #2
    669c:	2300      	movs	r3, #0
    669e:	8003      	strh	r3, [r0, #0]
    lret = log_buffer_get_available_for_next_message(&lb_available);
    66a0:	f011 f804 	bl	176ac <log_buffer_get_available_for_next_message>
    assert(LOG_RET_OK==lret);
    66a4:	2800      	cmp	r0, #0
    66a6:	d003      	beq.n	66b0 <log_event+0x74>
    66a8:	0021      	movs	r1, r4
    66aa:	2016      	movs	r0, #22
    66ac:	f7fb fa30 	bl	1b10 <panic>
    bool triggerTx = false;
    66b0:	2400      	movs	r4, #0
    if ((missed_messages > 0)
    66b2:	4f34      	ldr	r7, [pc, #208]	; (6784 <log_event+0x148>)
    66b4:	683a      	ldr	r2, [r7, #0]
    66b6:	42a2      	cmp	r2, r4
    66b8:	d016      	beq.n	66e8 <log_event+0xac>
        && (lb_available >= (LOG_MESSAGE_TOTAL_SIZE(sizeof(log_system_missed_message_t)) + LOG_MESSAGE_TOTAL_SIZE(len)))) //lint !e456
    66ba:	ab06      	add	r3, sp, #24
    66bc:	8859      	ldrh	r1, [r3, #2]
    66be:	0033      	movs	r3, r6
    66c0:	3318      	adds	r3, #24
    66c2:	428b      	cmp	r3, r1
    66c4:	d810      	bhi.n	66e8 <log_event+0xac>
        log_header.kv = 0 | LOG_KV_SET_VERBOSITY(LOG_VERBOSITY_ERROR) | LOG_KV_SET_CLASS(LOG_KV_CLASS_SYSTEM) | LOG_KV_SET_CORE(CORES_THIS_CORE) | LOG_KV_SET_FLAGS(LOG_FLAGS_NONE); //lint !e845 Allow shifting 0
    66c6:	2383      	movs	r3, #131	; 0x83
        log_header.message_id = LOG_SYSTEM_MISSED_MESSAGE_BUFFER;
    66c8:	a808      	add	r0, sp, #32
        log_header.kv = 0 | LOG_KV_SET_VERBOSITY(LOG_VERBOSITY_ERROR) | LOG_KV_SET_CLASS(LOG_KV_CLASS_SYSTEM) | LOG_KV_SET_CORE(CORES_THIS_CORE) | LOG_KV_SET_FLAGS(LOG_FLAGS_NONE); //lint !e845 Allow shifting 0
    66ca:	9308      	str	r3, [sp, #32]
        log_header.message_id = LOG_SYSTEM_MISSED_MESSAGE_BUFFER;
    66cc:	3b7f      	subs	r3, #127	; 0x7f
    66ce:	8083      	strh	r3, [r0, #4]
        lret = log_buffer_message(&log_header, (const uint8 *) &sys_missed_messages, time_us, &was_empty);
    66d0:	ab06      	add	r3, sp, #24
        sys_missed_messages.counter = missed_messages;
    66d2:	9207      	str	r2, [sp, #28]
        lret = log_buffer_message(&log_header, (const uint8 *) &sys_missed_messages, time_us, &was_empty);
    66d4:	3301      	adds	r3, #1
    66d6:	9a03      	ldr	r2, [sp, #12]
    66d8:	a907      	add	r1, sp, #28
    66da:	f010 fffb 	bl	176d4 <log_buffer_message>
        if (lret == LOG_RET_OK)
    66de:	42a0      	cmp	r0, r4
    66e0:	d102      	bne.n	66e8 <log_event+0xac>
            triggerTx = was_empty;
    66e2:	ab06      	add	r3, sp, #24
            missed_messages = 0;
    66e4:	603c      	str	r4, [r7, #0]
            triggerTx = was_empty;
    66e6:	785c      	ldrb	r4, [r3, #1]
    if (lb_available >= LOG_MESSAGE_TOTAL_SIZE(len))
    66e8:	ab06      	add	r3, sp, #24
    66ea:	885a      	ldrh	r2, [r3, #2]
    66ec:	0033      	movs	r3, r6
    66ee:	330a      	adds	r3, #10
    66f0:	429a      	cmp	r2, r3
    66f2:	d33d      	bcc.n	6770 <log_event+0x134>
        log_header.kv = 0 | LOG_KV_SET_VERBOSITY(verbosity) | LOG_KV_SET_CLASS(LOG_KV_CLASS_CUSTOM) | LOG_KV_SET_CORE(CORES_THIS_CORE) | LOG_KV_SET_FLAGS(kv_flags); //lint !e845
    66f4:	2203      	movs	r2, #3
    66f6:	9b01      	ldr	r3, [sp, #4]
    66f8:	2118      	movs	r1, #24
    66fa:	4013      	ands	r3, r2
    66fc:	001a      	movs	r2, r3
    66fe:	2360      	movs	r3, #96	; 0x60
    6700:	425b      	negs	r3, r3
    6702:	431a      	orrs	r2, r3
    6704:	9b02      	ldr	r3, [sp, #8]
    6706:	a808      	add	r0, sp, #32
    6708:	00db      	lsls	r3, r3, #3
    670a:	400b      	ands	r3, r1
    670c:	4313      	orrs	r3, r2
    670e:	7003      	strb	r3, [r0, #0]
        log_header.module = module;
    6710:	466b      	mov	r3, sp
    6712:	7c1b      	ldrb	r3, [r3, #16]
        log_header.length = len;
    6714:	8086      	strh	r6, [r0, #4]
        log_header.module = module;
    6716:	7043      	strb	r3, [r0, #1]
        log_header.message_id = id;
    6718:	466b      	mov	r3, sp
    671a:	8a9b      	ldrh	r3, [r3, #20]
        lret = log_buffer_message(&log_header, buffer, time_us, &was_empty);
    671c:	9a03      	ldr	r2, [sp, #12]
        log_header.message_id = id;
    671e:	8043      	strh	r3, [r0, #2]
        lret = log_buffer_message(&log_header, buffer, time_us, &was_empty);
    6720:	ab06      	add	r3, sp, #24
    6722:	1c5e      	adds	r6, r3, #1
    6724:	0033      	movs	r3, r6
    6726:	9911      	ldr	r1, [sp, #68]	; 0x44
    6728:	f010 ffd4 	bl	176d4 <log_buffer_message>
        if (lret == LOG_RET_OK)
    672c:	2800      	cmp	r0, #0
    672e:	d11f      	bne.n	6770 <log_event+0x134>
    triggerTx = triggerTx || !log_reader_is_active();
    6730:	2701      	movs	r7, #1
            if (!triggerTx)
    6732:	2c00      	cmp	r4, #0
    6734:	d102      	bne.n	673c <log_event+0x100>
                triggerTx = was_empty;
    6736:	7834      	ldrb	r4, [r6, #0]
    triggerTx = triggerTx || !log_reader_is_active();
    6738:	0027      	movs	r7, r4
    673a:	002c      	movs	r4, r5
    if (osKernelGetState() == osKernelRunning)
    673c:	f00d ffca 	bl	146d4 <osKernelGetState>
    6740:	2802      	cmp	r0, #2
    6742:	d10d      	bne.n	6760 <log_event+0x124>
        if (triggerTx)      //lint !e456
    6744:	2f00      	cmp	r7, #0
    6746:	d001      	beq.n	674c <log_event+0x110>
            log_trigger();
    6748:	f000 f8a4 	bl	6894 <log_trigger>
        if (osMutexRelease(mutex) != osOK)
    674c:	4b0c      	ldr	r3, [pc, #48]	; (6780 <log_event+0x144>)
    674e:	6818      	ldr	r0, [r3, #0]
    6750:	f00e f94c 	bl	149ec <osMutexRelease>
    6754:	2800      	cmp	r0, #0
    6756:	d003      	beq.n	6760 <log_event+0x124>
            panic(PANIC_LOG, LOG_PANIC_MUTEX_NOT_READY); //lint !e454 !e456
    6758:	2100      	movs	r1, #0
    675a:	200d      	movs	r0, #13
    675c:	f7fb f9d8 	bl	1b10 <panic>
    if (record_missed_messages && !logged)
    6760:	2c00      	cmp	r4, #0
    6762:	d103      	bne.n	676c <log_event+0x130>
        missed_messages++;
    6764:	4a07      	ldr	r2, [pc, #28]	; (6784 <log_event+0x148>)
    6766:	6813      	ldr	r3, [r2, #0]
    6768:	3301      	adds	r3, #1
    676a:	6013      	str	r3, [r2, #0]
}
    676c:	b00b      	add	sp, #44	; 0x2c
    676e:	bdf0      	pop	{r4, r5, r6, r7, pc}
            logged = false;
    6770:	2500      	movs	r5, #0
    6772:	e7e1      	b.n	6738 <log_event+0xfc>
    6774:	01000591 	.word	0x01000591
    6778:	01000590 	.word	0x01000590
    677c:	01001488 	.word	0x01001488
    6780:	01001490 	.word	0x01001490
    6784:	0100148c 	.word	0x0100148c

00006788 <log_event_string>:
{
    6788:	b5f0      	push	{r4, r5, r6, r7, lr}
    678a:	4674      	mov	r4, lr
    678c:	b089      	sub	sp, #36	; 0x24
    678e:	9304      	str	r3, [sp, #16]
    if ((str == NULL) || (strlen(str) == 0))
    6790:	9b0e      	ldr	r3, [sp, #56]	; 0x38
    6792:	9405      	str	r4, [sp, #20]
{
    6794:	9003      	str	r0, [sp, #12]
    6796:	000e      	movs	r6, r1
    6798:	0017      	movs	r7, r2
    if ((str == NULL) || (strlen(str) == 0))
    679a:	2b00      	cmp	r3, #0
    679c:	d01b      	beq.n	67d6 <log_event_string+0x4e>
    679e:	0018      	movs	r0, r3
    67a0:	f014 fdfd 	bl	1b39e <strlen>
    67a4:	2800      	cmp	r0, #0
    67a6:	d016      	beq.n	67d6 <log_event_string+0x4e>
    str_len = (uint32)vsprintf ((char*)s, str, args);
    67a8:	4d0c      	ldr	r5, [pc, #48]	; (67dc <log_event_string+0x54>)
    va_start (args, str);//lint !e530 !e516  Lint hopelessly confused about va_args
    67aa:	aa0f      	add	r2, sp, #60	; 0x3c
    str_len = (uint32)vsprintf ((char*)s, str, args);
    67ac:	990e      	ldr	r1, [sp, #56]	; 0x38
    67ae:	0028      	movs	r0, r5
    va_start (args, str);//lint !e530 !e516  Lint hopelessly confused about va_args
    67b0:	9207      	str	r2, [sp, #28]
    str_len = (uint32)vsprintf ((char*)s, str, args);
    67b2:	f014 f87c 	bl	1a8ae <vsprintf>
    67b6:	0004      	movs	r4, r0
    assert(str_len < LOG_EVENT_MAX_LOG_STRING);
    67b8:	2863      	cmp	r0, #99	; 0x63
    67ba:	d903      	bls.n	67c4 <log_event_string+0x3c>
    67bc:	9905      	ldr	r1, [sp, #20]
    67be:	2016      	movs	r0, #22
    67c0:	f7fb f9a6 	bl	1b10 <panic>
    log_event(module, verbosity, kv_flags, id, (uint16)str_len, s);
    67c4:	b2a4      	uxth	r4, r4
    67c6:	9501      	str	r5, [sp, #4]
    67c8:	9400      	str	r4, [sp, #0]
    67ca:	9b04      	ldr	r3, [sp, #16]
    67cc:	003a      	movs	r2, r7
    67ce:	0031      	movs	r1, r6
    67d0:	9803      	ldr	r0, [sp, #12]
    67d2:	f7ff ff33 	bl	663c <log_event>
}
    67d6:	b009      	add	sp, #36	; 0x24
    67d8:	bdf0      	pop	{r4, r5, r6, r7, pc}
    67da:	46c0      	nop			; (mov r8, r8)
    67dc:	01001494 	.word	0x01001494

000067e0 <log_set_local_log_level>:

/** Set local log level from system log level
 * @return true if log level was successfuly set to the specified level
 */
NEUL_RET log_set_local_log_level(NEUL_LOG_LEVEL log_level)
{
    67e0:	b507      	push	{r0, r1, r2, lr}
    67e2:	466b      	mov	r3, sp
    67e4:	1dd9      	adds	r1, r3, #7
    67e6:	7008      	strb	r0, [r1, #0]
    if (log_level == NEUL_LOG_LEVEL_NONE)
    67e8:	2800      	cmp	r0, #0
    67ea:	d106      	bne.n	67fa <log_set_local_log_level+0x1a>
    log_is_enabled_state = false;
    67ec:	4b0e      	ldr	r3, [pc, #56]	; (6828 <log_set_local_log_level+0x48>)
    67ee:	7018      	strb	r0, [r3, #0]
            default:
                return NEUL_RET_ERROR;
        }
        log_set_verbosity(verbosity);
    }
    return neul_kv_set(LOG_KEYID_LOG_LEVEL, (uint8 *)&log_level, sizeof(NEUL_LOG_LEVEL));
    67f0:	2201      	movs	r2, #1
    67f2:	480e      	ldr	r0, [pc, #56]	; (682c <log_set_local_log_level+0x4c>)
    67f4:	f000 fed8 	bl	75a8 <neul_kv_set>
}
    67f8:	bd0e      	pop	{r1, r2, r3, pc}
        switch (log_level)
    67fa:	1e43      	subs	r3, r0, #1
                return NEUL_RET_ERROR;
    67fc:	2001      	movs	r0, #1
        switch (log_level)
    67fe:	2b03      	cmp	r3, #3
    6800:	d8fa      	bhi.n	67f8 <log_set_local_log_level+0x18>
    6802:	0018      	movs	r0, r3
    6804:	f7f9 fdce 	bl	3a4 <__gnu_thumb1_case_uqi>
    6808:	0b09020d 	.word	0x0b09020d
                verbosity = LOG_VERBOSITY_NORMAL;
    680c:	2301      	movs	r3, #1
    log_current_verbosity = verbosity;
    680e:	4a08      	ldr	r2, [pc, #32]	; (6830 <log_set_local_log_level+0x50>)
    6810:	7013      	strb	r3, [r2, #0]
    log_is_enabled_state = true;
    6812:	2201      	movs	r2, #1
    6814:	4b04      	ldr	r3, [pc, #16]	; (6828 <log_set_local_log_level+0x48>)
    6816:	701a      	strb	r2, [r3, #0]
    6818:	e7ea      	b.n	67f0 <log_set_local_log_level+0x10>
                verbosity = LOG_VERBOSITY_WARNING;
    681a:	2302      	movs	r3, #2
                break;
    681c:	e7f7      	b.n	680e <log_set_local_log_level+0x2e>
                verbosity = LOG_VERBOSITY_ERROR;
    681e:	2303      	movs	r3, #3
                break;
    6820:	e7f5      	b.n	680e <log_set_local_log_level+0x2e>
                verbosity = LOG_VERBOSITY_VERBOSE;
    6822:	2300      	movs	r3, #0
    6824:	e7f3      	b.n	680e <log_set_local_log_level+0x2e>
    6826:	46c0      	nop			; (mov r8, r8)
    6828:	01000591 	.word	0x01000591
    682c:	00000c02 	.word	0x00000c02
    6830:	01000590 	.word	0x01000590

00006834 <log_get_local_log_level>:

/** Get current log level
 * @return current log level
 */
NEUL_LOG_LEVEL log_get_local_log_level(void)
{
    6834:	b513      	push	{r0, r1, r4, lr}
    NEUL_LOG_LEVEL   log_level;
    NEUL_RET         retCode;
    uint16           kv_len;

    retCode = neul_kv_get(LOG_KEYID_LOG_LEVEL, sizeof(NEUL_LOG_LEVEL), &kv_len, (uint8 *)&log_level);
    6836:	466b      	mov	r3, sp
    6838:	466a      	mov	r2, sp
    683a:	1d5c      	adds	r4, r3, #5
    683c:	0023      	movs	r3, r4
    683e:	3206      	adds	r2, #6
    6840:	2101      	movs	r1, #1
    6842:	4804      	ldr	r0, [pc, #16]	; (6854 <log_get_local_log_level+0x20>)
    6844:	f000 feb5 	bl	75b2 <neul_kv_get>
    if (retCode != NEUL_RET_OK)
    6848:	2800      	cmp	r0, #0
    684a:	d001      	beq.n	6850 <log_get_local_log_level+0x1c>
    {
        log_level = NEUL_LOG_LEVEL_NORMAL;
    684c:	2302      	movs	r3, #2
    684e:	7023      	strb	r3, [r4, #0]
    }

    return log_level;
    6850:	7820      	ldrb	r0, [r4, #0]
}
    6852:	bd16      	pop	{r1, r2, r4, pc}
    6854:	00000c02 	.word	0x00000c02

00006858 <log_level_init>:

void log_level_init( void )
{
    6858:	b510      	push	{r4, lr}
    NEUL_LOG_LEVEL   log_level;

    log_level = log_get_local_log_level();
    685a:	f7ff ffeb 	bl	6834 <log_get_local_log_level>
    685e:	4a0b      	ldr	r2, [pc, #44]	; (688c <log_level_init+0x34>)

    if (log_level == NEUL_LOG_LEVEL_NONE)
    6860:	2800      	cmp	r0, #0
    6862:	d101      	bne.n	6868 <log_level_init+0x10>
    {
        log_is_enabled_state = false;
    6864:	7010      	strb	r0, [r2, #0]
                break;
            default:
                return;
        }
    }
}
    6866:	bd10      	pop	{r4, pc}
        log_is_enabled_state = true;
    6868:	2301      	movs	r3, #1
        switch (log_level)
    686a:	3801      	subs	r0, #1
        log_is_enabled_state = true;
    686c:	7013      	strb	r3, [r2, #0]
    686e:	001a      	movs	r2, r3
        switch (log_level)
    6870:	2803      	cmp	r0, #3
    6872:	d8f8      	bhi.n	6866 <log_level_init+0xe>
    6874:	4b06      	ldr	r3, [pc, #24]	; (6890 <log_level_init+0x38>)
    6876:	f7f9 fd95 	bl	3a4 <__gnu_thumb1_case_uqi>
    687a:	0302      	.short	0x0302
    687c:	0705      	.short	0x0705
                log_current_verbosity = LOG_VERBOSITY_VERBOSE;
    687e:	2200      	movs	r2, #0
                log_current_verbosity = LOG_VERBOSITY_ERROR;
    6880:	701a      	strb	r2, [r3, #0]
                break;
    6882:	e7f0      	b.n	6866 <log_level_init+0xe>
                log_current_verbosity = LOG_VERBOSITY_WARNING;
    6884:	2202      	movs	r2, #2
    6886:	e7fb      	b.n	6880 <log_level_init+0x28>
                log_current_verbosity = LOG_VERBOSITY_ERROR;
    6888:	2203      	movs	r2, #3
    688a:	e7f9      	b.n	6880 <log_level_init+0x28>
    688c:	01000591 	.word	0x01000591
    6890:	01000590 	.word	0x01000590

00006894 <log_trigger>:
#endif

#include "log_uart.h"

void log_trigger( void )
{
    6894:	b510      	push	{r4, lr}
    log_uart_trigger();
    6896:	f000 f92b 	bl	6af0 <log_uart_trigger>
}
    689a:	bd10      	pop	{r4, pc}

0000689c <flog_init>:
#else
#include "iflog.h"
#endif

FLOG_RET flog_init(void)
{
    689c:	b510      	push	{r4, lr}
    FLOG_RET flog_ret = FLOG_RET_OK;
#if defined(EXTERNAL_FLASH_LOG)
    eflog_init();
#else
    flog_ret = (FLOG_RET)iflog_init();//lint !e838
    689e:	f001 fc0d 	bl	80bc <iflog_init>
#endif

    return flog_ret;
}
    68a2:	bd10      	pop	{r4, pc}

000068a4 <flog_set_write_enable>:
#endif
    return;
}

void flog_set_write_enable(bool write_enable)
{
    68a4:	b510      	push	{r4, lr}
#if defined(EXTERNAL_FLASH_LOG)
    UNUSED(write_enable);
    return;
#else
    iflog_set_write_enable(write_enable);
    68a6:	f001 fc27 	bl	80f8 <iflog_set_write_enable>
#endif
}
    68aa:	bd10      	pop	{r4, pc}

000068ac <flog_log_write>:

FLOG_RET flog_log_write(uint8* buff, uint16 len, bool is_exception_log)
{
    68ac:	b510      	push	{r4, lr}
    FLOG_RET flog_ret = FLOG_RET_OK;
#if defined(EXTERNAL_FLASH_LOG)
    flog_ret = (FLOG_RET)eflog_log_write(buff, len, is_exception_log);//lint !e838
#else
    UNUSED(is_exception_log);
    flog_ret = (FLOG_RET)iflog_write(buff, len);//lint !e838
    68ae:	f001 fc29 	bl	8104 <iflog_write>
#endif

    return flog_ret;
}
    68b2:	bd10      	pop	{r4, pc}

000068b4 <flog_read>:

FLOG_RET flog_read(uint8* buff, uint16 buff_size, uint16* len)
{
    68b4:	b510      	push	{r4, lr}
    FLOG_RET flog_ret = FLOG_RET_OK;
#if defined(EXTERNAL_FLASH_LOG)
    flog_ret = (FLOG_RET)eflog_read(buff, buff_size, len);//lint !e838
#else
    flog_ret = (FLOG_RET)iflog_read(buff, buff_size, len);//lint !e838
    68b6:	f001 fcc3 	bl	8240 <iflog_read>
#endif

    return flog_ret;
}
    68ba:	bd10      	pop	{r4, pc}

000068bc <flog_page_read_finish>:
    68bc:	4770      	bx	lr

000068be <flog_get_available_size>:
#endif
    return;
}

uint16 flog_get_available_size(void)
{
    68be:	b510      	push	{r4, lr}
    uint16 flog_ret;

#if defined(EXTERNAL_FLASH_LOG)
    flog_ret = 0;
#else
    flog_ret = iflog_get_available_size();
    68c0:	f001 fca8 	bl	8214 <iflog_get_available_size>
#endif

    return flog_ret;
}
    68c4:	bd10      	pop	{r4, pc}
	...

000068c8 <log_uart_retrigger_from_timer>:
/**
 * Callback to register in a timer to re-trigger the logging mechanism.
 * @param xTimer osTimer. Unused
 */
static void log_uart_retrigger_from_timer(osTimerId_t xTimer)
{
    68c8:	b510      	push	{r4, lr}
    UNUSED(xTimer);
    (void)osSemaphoreRelease(semaphore_logs);
    68ca:	4b02      	ldr	r3, [pc, #8]	; (68d4 <log_uart_retrigger_from_timer+0xc>)
    68cc:	6818      	ldr	r0, [r3, #0]
    68ce:	f00e f901 	bl	14ad4 <osSemaphoreRelease>
}
    68d2:	bd10      	pop	{r4, pc}
    68d4:	01001588 	.word	0x01001588

000068d8 <log_uart_dma_tx_isr_callback>:
    // Only stop if the protocol core is in deep sleep, the next message is recent and the log level is under the watermark.
    return ( PROTOCOL_ASSERTS_SLEEP() && ((uint32)((uint32) hal_rtc_get_time_us() - next_msg_us) <  OLDEST_MESSAGE_IN_BUFFER*1000)  && log_uart_is_protocol_region_under_watermark() );
}

static void log_uart_dma_tx_isr_callback(DMA_INTERRUPT intr)
{
    68d8:	b510      	push	{r4, lr}
    UNUSED(intr);

    /* Pass the amount of data actually transmitted, so we can update the read pointer. */
    (void)osSemaphoreRelease(semaphore_uart);
    68da:	4b02      	ldr	r3, [pc, #8]	; (68e4 <log_uart_dma_tx_isr_callback+0xc>)
    68dc:	6818      	ldr	r0, [r3, #0]
    68de:	f00e f8f9 	bl	14ad4 <osSemaphoreRelease>

}
    68e2:	bd10      	pop	{r4, pc}
    68e4:	0100158c 	.word	0x0100158c

000068e8 <log_uart_write_blocking>:
    /* Give the semaphore to ensure the main logging task will be active */
    (void)osSemaphoreRelease(semaphore_logs);
}

static void log_uart_write_blocking(const void * buf, uint16 len, DMA_CH_CYCLE_TYPE dma_cycle_type)
{
    68e8:	b5f0      	push	{r4, r5, r6, r7, lr}
    68ea:	000f      	movs	r7, r1
    68ec:	b087      	sub	sp, #28
    UART_WRITE_DMA_CONFIGURATION dma_config;

    assert(dma_cycle_type < DMA_CH_CYCLE_TYPE_MAX);

    dma_config.cycle_type = dma_cycle_type;
    dma_config.done_callback = log_uart_dma_tx_isr_callback;
    68ee:	4b19      	ldr	r3, [pc, #100]	; (6954 <log_uart_write_blocking+0x6c>)
    dma_config.cycle_type = dma_cycle_type;
    68f0:	ac04      	add	r4, sp, #16
{
    68f2:	9003      	str	r0, [sp, #12]
    dma_config.cycle_type = dma_cycle_type;
    68f4:	7022      	strb	r2, [r4, #0]
    dma_config.done_callback = log_uart_dma_tx_isr_callback;
    68f6:	6063      	str	r3, [r4, #4]

    while ( !uart_write(log_uart, buf, len, &dma_config, NULL) )
    68f8:	2500      	movs	r5, #0
    68fa:	4e17      	ldr	r6, [pc, #92]	; (6958 <log_uart_write_blocking+0x70>)
    68fc:	0023      	movs	r3, r4
    68fe:	7830      	ldrb	r0, [r6, #0]
    6900:	003a      	movs	r2, r7
    6902:	9500      	str	r5, [sp, #0]
    6904:	9903      	ldr	r1, [sp, #12]
    6906:	f00f fb97 	bl	16038 <uart_write>
    690a:	42a8      	cmp	r0, r5
    690c:	d014      	beq.n	6938 <log_uart_write_blocking+0x50>
            (void)osDelay(LOG_UART_DELAY_ON_UART_BUSY);
        }
    }

    /* uart_write() had updated the cycle_type based on the DMA transferring situation */
    if (dma_config.cycle_type != DMA_CH_CYCLE_TYPE_BATCHED_PART)
    690e:	7823      	ldrb	r3, [r4, #0]
    6910:	2b01      	cmp	r3, #1
    6912:	d00f      	beq.n	6934 <log_uart_write_blocking+0x4c>
    {
        // Wait until the uart write has been completed
        if (osKernelGetState() == osKernelRunning)
    6914:	f00d fede 	bl	146d4 <osKernelGetState>
    6918:	2802      	cmp	r0, #2
    691a:	d115      	bne.n	6948 <log_uart_write_blocking+0x60>
        {
            if (osSemaphoreAcquire(semaphore_uart, osWaitForever) != osOK)
    691c:	2101      	movs	r1, #1
    691e:	4b0f      	ldr	r3, [pc, #60]	; (695c <log_uart_write_blocking+0x74>)
    6920:	4249      	negs	r1, r1
    6922:	6818      	ldr	r0, [r3, #0]
    6924:	f00e f8aa 	bl	14a7c <osSemaphoreAcquire>
    6928:	42a8      	cmp	r0, r5
    692a:	d003      	beq.n	6934 <log_uart_write_blocking+0x4c>
            {
                panic(PANIC_LOG, LOG_PANIC_MUTEX_NOT_READY); //lint !e454 !e456
    692c:	0029      	movs	r1, r5
    692e:	200d      	movs	r0, #13
    6930:	f7fb f8ee 	bl	1b10 <panic>
        {
            while( uart_has_pending_transmissions(log_uart) )
                {};
        }
    }
} //lint !e454 !e456
    6934:	b007      	add	sp, #28
    6936:	bdf0      	pop	{r4, r5, r6, r7, pc}
        if (osKernelGetState() == osKernelRunning)
    6938:	f00d fecc 	bl	146d4 <osKernelGetState>
    693c:	2802      	cmp	r0, #2
    693e:	d1db      	bne.n	68f8 <log_uart_write_blocking+0x10>
            (void)osDelay(LOG_UART_DELAY_ON_UART_BUSY);
    6940:	3801      	subs	r0, #1
    6942:	f00d ff92 	bl	1486a <osDelay>
    6946:	e7d7      	b.n	68f8 <log_uart_write_blocking+0x10>
            while( uart_has_pending_transmissions(log_uart) )
    6948:	7830      	ldrb	r0, [r6, #0]
    694a:	f00f fa35 	bl	15db8 <uart_has_pending_transmissions>
    694e:	2800      	cmp	r0, #0
    6950:	d1fa      	bne.n	6948 <log_uart_write_blocking+0x60>
    6952:	e7ef      	b.n	6934 <log_uart_write_blocking+0x4c>
    6954:	000068d9 	.word	0x000068d9
    6958:	01000592 	.word	0x01000592
    695c:	0100158c 	.word	0x0100158c

00006960 <log_uart_init>:
{
    6960:	b5f0      	push	{r4, r5, r6, r7, lr}
    6962:	b087      	sub	sp, #28
    6964:	4677      	mov	r7, lr
    LOG_READER_RET lret = log_buffer_reader_init();
    6966:	f010 ff9f 	bl	178a8 <log_buffer_reader_init>
    assert( lret == LOG_READER_RET_OK);
    696a:	2800      	cmp	r0, #0
    696c:	d003      	beq.n	6976 <log_uart_init+0x16>
    696e:	0039      	movs	r1, r7
    6970:	2016      	movs	r0, #22
    6972:	f7fb f8cd 	bl	1b10 <panic>
    if (neul_kv_get(BASE_KEYID_UART_1_CONFIG, sizeof(uart_pin_configuration), &kvalue_length, (uint8 *)&log_uart_pins) != NEUL_RET_OK) //lint !e845  In this case, the macro BASE_KEYID_UART_1_CONFIG expands on the to have a 'x | 0' which lint does not like
    6976:	466a      	mov	r2, sp
    6978:	ac02      	add	r4, sp, #8
    697a:	0023      	movs	r3, r4
    697c:	3206      	adds	r2, #6
    697e:	2104      	movs	r1, #4
    6980:	2011      	movs	r0, #17
    6982:	f000 fe16 	bl	75b2 <neul_kv_get>
    6986:	2800      	cmp	r0, #0
    6988:	d007      	beq.n	699a <log_uart_init+0x3a>
        log_uart_pins.tx_pin = PIN_NONE;
    698a:	2328      	movs	r3, #40	; 0x28
        log_uart = UART_BUS_NONE;
    698c:	2203      	movs	r2, #3
        log_uart_pins.tx_pin = PIN_NONE;
    698e:	7023      	strb	r3, [r4, #0]
        log_uart_pins.rx_pin = PIN_NONE;
    6990:	7063      	strb	r3, [r4, #1]
        log_uart_pins.cts_pin = PIN_NONE;
    6992:	70a3      	strb	r3, [r4, #2]
        log_uart_pins.rts_pin = PIN_NONE;
    6994:	70e3      	strb	r3, [r4, #3]
        log_uart = UART_BUS_NONE;
    6996:	4b22      	ldr	r3, [pc, #136]	; (6a20 <log_uart_init+0xc0>)
    6998:	701a      	strb	r2, [r3, #0]
    if (log_uart_pins.tx_pin != PIN_NONE)  //lint !e774 temp while hard-wiring pin
    699a:	7823      	ldrb	r3, [r4, #0]
    699c:	2b28      	cmp	r3, #40	; 0x28
    699e:	d039      	beq.n	6a14 <log_uart_init+0xb4>
        if (non_os_is_driver_initialised(DRIVER_INIT_UART) != true)
    69a0:	2008      	movs	r0, #8
    69a2:	f011 fc2f 	bl	18204 <non_os_is_driver_initialised>
    69a6:	2800      	cmp	r0, #0
    69a8:	d101      	bne.n	69ae <log_uart_init+0x4e>
            uart_init();
    69aa:	f00e fe93 	bl	156d4 <uart_init>
        uart_line_config.baud_rate = LOG_UART_BAUD_RATE;
    69ae:	23e1      	movs	r3, #225	; 0xe1
    69b0:	031b      	lsls	r3, r3, #12
    69b2:	9304      	str	r3, [sp, #16]
        uart_line_config.data_bits = LOG_UART_DATA_BITS;
    69b4:	2303      	movs	r3, #3
        uart_line_config.baud_rate = LOG_UART_BAUD_RATE;
    69b6:	ad04      	add	r5, sp, #16
        uart_dma_config.tx_use_dma = true;
    69b8:	2201      	movs	r2, #1
        uart_line_config.data_bits = LOG_UART_DATA_BITS;
    69ba:	712b      	strb	r3, [r5, #4]
        uart_line_config.parity    = LOG_UART_PARITY;
    69bc:	2300      	movs	r3, #0
        uart_dma_config.tx_use_dma = true;
    69be:	ae03      	add	r6, sp, #12
    69c0:	7032      	strb	r2, [r6, #0]
        log_uart = uart_claim( &log_uart_pins );
    69c2:	0020      	movs	r0, r4
        uart_dma_config.tx_dma_ch_priority = LOG_UART_DMA_CH_PRIORITY;
    69c4:	3206      	adds	r2, #6
        uart_line_config.parity    = LOG_UART_PARITY;
    69c6:	716b      	strb	r3, [r5, #5]
        uart_line_config.stop_bits = LOG_UART_STOP_BITS;
    69c8:	71ab      	strb	r3, [r5, #6]
        uart_dma_config.tx_dma_ch_priority = LOG_UART_DMA_CH_PRIORITY;
    69ca:	70b2      	strb	r2, [r6, #2]
        uart_dma_config.rx_use_dma = false;
    69cc:	7073      	strb	r3, [r6, #1]
        log_uart = uart_claim( &log_uart_pins );
    69ce:	f00e feb1 	bl	15734 <uart_claim>
    69d2:	4b13      	ldr	r3, [pc, #76]	; (6a20 <log_uart_init+0xc0>)
        bool uart_opened = uart_open(log_uart, &uart_line_config, &uart_buffer_config, &uart_dma_config);
    69d4:	aa01      	add	r2, sp, #4
        log_uart = uart_claim( &log_uart_pins );
    69d6:	7018      	strb	r0, [r3, #0]
        bool uart_opened = uart_open(log_uart, &uart_line_config, &uart_buffer_config, &uart_dma_config);
    69d8:	0029      	movs	r1, r5
    69da:	0033      	movs	r3, r6
    69dc:	f00e ffd8 	bl	15990 <uart_open>
        assert( uart_opened );
    69e0:	2800      	cmp	r0, #0
    69e2:	d103      	bne.n	69ec <log_uart_init+0x8c>
    69e4:	0039      	movs	r1, r7
    69e6:	3016      	adds	r0, #22
    69e8:	f7fb f892 	bl	1b10 <panic>
        sequence_number = 0;
    69ec:	2200      	movs	r2, #0
    69ee:	4b0d      	ldr	r3, [pc, #52]	; (6a24 <log_uart_init+0xc4>)
        if (non_os_is_driver_initialised(DRIVER_INIT_IPC) == false)
    69f0:	2005      	movs	r0, #5
        sequence_number = 0;
    69f2:	601a      	str	r2, [r3, #0]
        if (non_os_is_driver_initialised(DRIVER_INIT_IPC) == false)
    69f4:	f011 fc06 	bl	18204 <non_os_is_driver_initialised>
    69f8:	2800      	cmp	r0, #0
    69fa:	d101      	bne.n	6a00 <log_uart_init+0xa0>
            ipc_init();
    69fc:	f010 fce4 	bl	173c8 <ipc_init>
        IPC_STATUS ipc_ret = ipc_register_handler(IPC_ACTION_LOG_INFO, log_reader_info_action_handler);
    6a00:	4909      	ldr	r1, [pc, #36]	; (6a28 <log_uart_init+0xc8>)
    6a02:	2007      	movs	r0, #7
    6a04:	f010 fcfc 	bl	17400 <ipc_register_handler>
        assert(ipc_ret == IPC_STATUS_OK);
    6a08:	2800      	cmp	r0, #0
    6a0a:	d003      	beq.n	6a14 <log_uart_init+0xb4>
    6a0c:	0039      	movs	r1, r7
    6a0e:	2016      	movs	r0, #22
    6a10:	f7fb f87e 	bl	1b10 <panic>
    log_uart_protocol_log_watermark = LOG_UART_PROTOCOL_LOG_WATERMARK_VALUE_ON_INIT;
    6a14:	2200      	movs	r2, #0
    6a16:	4b05      	ldr	r3, [pc, #20]	; (6a2c <log_uart_init+0xcc>)
    6a18:	801a      	strh	r2, [r3, #0]
}
    6a1a:	b007      	add	sp, #28
    6a1c:	bdf0      	pop	{r4, r5, r6, r7, pc}
    6a1e:	46c0      	nop			; (mov r8, r8)
    6a20:	01000592 	.word	0x01000592
    6a24:	01001590 	.word	0x01001590
    6a28:	00006b01 	.word	0x00006b01
    6a2c:	010014fc 	.word	0x010014fc

00006a30 <log_uart_update_watermark_level>:
{
    6a30:	b510      	push	{r4, lr}
    assert (log_mem_region == LOG_MEMORY_REGION_SECTION_1);
    6a32:	2801      	cmp	r0, #1
    6a34:	d004      	beq.n	6a40 <log_uart_update_watermark_level+0x10>
    6a36:	4671      	mov	r1, lr
    6a38:	2016      	movs	r0, #22
    6a3a:	f7fb f869 	bl	1b10 <panic>
}
    6a3e:	bd10      	pop	{r4, pc}
        log_uart_protocol_log_watermark = new_watermark_val;
    6a40:	4b01      	ldr	r3, [pc, #4]	; (6a48 <log_uart_update_watermark_level+0x18>)
    6a42:	8019      	strh	r1, [r3, #0]
    6a44:	e7fb      	b.n	6a3e <log_uart_update_watermark_level+0xe>
    6a46:	46c0      	nop			; (mov r8, r8)
    6a48:	010014fc 	.word	0x010014fc

00006a4c <log_uart_init_after_rtos>:
    semaphore_logs = osSemaphoreNew(1, 0, NULL);
    6a4c:	2200      	movs	r2, #0
{
    6a4e:	b570      	push	{r4, r5, r6, lr}
    semaphore_logs = osSemaphoreNew(1, 0, NULL);
    6a50:	0011      	movs	r1, r2
{
    6a52:	0004      	movs	r4, r0
    semaphore_logs = osSemaphoreNew(1, 0, NULL);
    6a54:	2001      	movs	r0, #1
    6a56:	f00d fff5 	bl	14a44 <osSemaphoreNew>
    6a5a:	4b1f      	ldr	r3, [pc, #124]	; (6ad8 <log_uart_init_after_rtos+0x8c>)
    6a5c:	1e01      	subs	r1, r0, #0
    6a5e:	6018      	str	r0, [r3, #0]
    if(semaphore_logs == NULL)
    6a60:	d102      	bne.n	6a68 <log_uart_init_after_rtos+0x1c>
        panic(PANIC_LOG, LOG_PANIC_MUTEX_NOT_READY);
    6a62:	200d      	movs	r0, #13
    6a64:	f7fb f854 	bl	1b10 <panic>
    semaphore_uart = osSemaphoreNew(1, 0, NULL);
    6a68:	2200      	movs	r2, #0
    6a6a:	2001      	movs	r0, #1
    6a6c:	0011      	movs	r1, r2
    6a6e:	f00d ffe9 	bl	14a44 <osSemaphoreNew>
    6a72:	4b1a      	ldr	r3, [pc, #104]	; (6adc <log_uart_init_after_rtos+0x90>)
    6a74:	1e01      	subs	r1, r0, #0
    6a76:	6018      	str	r0, [r3, #0]
    if(semaphore_uart == NULL)
    6a78:	d102      	bne.n	6a80 <log_uart_init_after_rtos+0x34>
        panic(PANIC_LOG, LOG_PANIC_MUTEX_NOT_READY);
    6a7a:	200d      	movs	r0, #13
    6a7c:	f7fb f848 	bl	1b10 <panic>
    semaphore_log_output = osSemaphoreNew(1, 1, NULL);
    6a80:	2101      	movs	r1, #1
    6a82:	2200      	movs	r2, #0
    6a84:	0008      	movs	r0, r1
    6a86:	f00d ffdd 	bl	14a44 <osSemaphoreNew>
    6a8a:	4b15      	ldr	r3, [pc, #84]	; (6ae0 <log_uart_init_after_rtos+0x94>)
    6a8c:	1e01      	subs	r1, r0, #0
    6a8e:	6018      	str	r0, [r3, #0]
    if (semaphore_log_output == NULL)
    6a90:	d102      	bne.n	6a98 <log_uart_init_after_rtos+0x4c>
        panic(PANIC_LOG, LOG_PANIC_MUTEX_NOT_READY);
    6a92:	200d      	movs	r0, #13
    6a94:	f7fb f83c 	bl	1b10 <panic>
    semaphore_log_reader_enable = osSemaphoreNew (1, 0, NULL);
    6a98:	2200      	movs	r2, #0
    6a9a:	2001      	movs	r0, #1
    6a9c:	0011      	movs	r1, r2
    6a9e:	f00d ffd1 	bl	14a44 <osSemaphoreNew>
    6aa2:	4d10      	ldr	r5, [pc, #64]	; (6ae4 <log_uart_init_after_rtos+0x98>)
    6aa4:	1e01      	subs	r1, r0, #0
    6aa6:	6028      	str	r0, [r5, #0]
    if (semaphore_log_reader_enable == NULL)
    6aa8:	d102      	bne.n	6ab0 <log_uart_init_after_rtos+0x64>
        panic(PANIC_LOG, LOG_PANIC_MUTEX_NOT_READY);
    6aaa:	200d      	movs	r0, #13
    6aac:	f7fb f830 	bl	1b10 <panic>
    if (enable_at_start)
    6ab0:	2c00      	cmp	r4, #0
    6ab2:	d002      	beq.n	6aba <log_uart_init_after_rtos+0x6e>
        (void) osSemaphoreRelease(semaphore_log_reader_enable);
    6ab4:	6828      	ldr	r0, [r5, #0]
    6ab6:	f00e f80d 	bl	14ad4 <osSemaphoreRelease>
    log_uart_early_stop_timer = osTimerNew(log_uart_retrigger_from_timer, osTimerOnce, NULL, NULL);
    6aba:	2300      	movs	r3, #0
    6abc:	480a      	ldr	r0, [pc, #40]	; (6ae8 <log_uart_init_after_rtos+0x9c>)
    6abe:	001a      	movs	r2, r3
    6ac0:	0019      	movs	r1, r3
    6ac2:	f00d fed9 	bl	14878 <osTimerNew>
    6ac6:	4b09      	ldr	r3, [pc, #36]	; (6aec <log_uart_init_after_rtos+0xa0>)
    6ac8:	6018      	str	r0, [r3, #0]
    if (log_uart_early_stop_timer == NULL)
    6aca:	2800      	cmp	r0, #0
    6acc:	d103      	bne.n	6ad6 <log_uart_init_after_rtos+0x8a>
        panic(PANIC_LOG, LOG_PANIC_TIMER_INIT);
    6ace:	2102      	movs	r1, #2
    6ad0:	300d      	adds	r0, #13
    6ad2:	f7fb f81d 	bl	1b10 <panic>
}
    6ad6:	bd70      	pop	{r4, r5, r6, pc}
    6ad8:	01001588 	.word	0x01001588
    6adc:	0100158c 	.word	0x0100158c
    6ae0:	01001580 	.word	0x01001580
    6ae4:	01001584 	.word	0x01001584
    6ae8:	000068c9 	.word	0x000068c9
    6aec:	010014f8 	.word	0x010014f8

00006af0 <log_uart_trigger>:
{
    6af0:	b510      	push	{r4, lr}
    (void)osSemaphoreRelease(semaphore_logs);
    6af2:	4b02      	ldr	r3, [pc, #8]	; (6afc <log_uart_trigger+0xc>)
    6af4:	6818      	ldr	r0, [r3, #0]
    6af6:	f00d ffed 	bl	14ad4 <osSemaphoreRelease>
}
    6afa:	bd10      	pop	{r4, pc}
    6afc:	01001588 	.word	0x01001588

00006b00 <log_reader_info_action_handler>:
{
    6b00:	b510      	push	{r4, lr}
    assert(message == IPC_ACTION_LOG_INFO);
    6b02:	2807      	cmp	r0, #7
    6b04:	d003      	beq.n	6b0e <log_reader_info_action_handler+0xe>
    6b06:	4671      	mov	r1, lr
    6b08:	2016      	movs	r0, #22
    6b0a:	f7fb f801 	bl	1b10 <panic>
    log_uart_trigger();
    6b0e:	f7ff ffef 	bl	6af0 <log_uart_trigger>
}
    6b12:	2001      	movs	r0, #1
    6b14:	bd10      	pop	{r4, pc}
	...

00006b18 <log_uart_nxlog_ctrl>:

NEUL_RET log_uart_nxlog_ctrl(NXLOG_OPERATION cmd, log_uart_output_response_to_at_uart_callback output_callback)
{
    6b18:	4673      	mov	r3, lr
    6b1a:	b5f0      	push	{r4, r5, r6, r7, lr}
    NEUL_RET result = NEUL_RET_OK;
    FLOG_RET ret = FLOG_RET_OK;
    void *buffer = NULL;
    uint16 len = 0;
    6b1c:	2700      	movs	r7, #0
{
    6b1e:	b085      	sub	sp, #20
    6b20:	9301      	str	r3, [sp, #4]
    uint16 len = 0;
    6b22:	ab02      	add	r3, sp, #8
    6b24:	1d9c      	adds	r4, r3, #6
{
    6b26:	000e      	movs	r6, r1
    uint16 len = 0;
    6b28:	8027      	strh	r7, [r4, #0]
    uint8 *rsp_string = NULL;
    switch(cmd)
    6b2a:	2803      	cmp	r0, #3
    6b2c:	d003      	beq.n	6b36 <log_uart_nxlog_ctrl+0x1e>
    6b2e:	2804      	cmp	r0, #4
    6b30:	d03f      	beq.n	6bb2 <log_uart_nxlog_ctrl+0x9a>
                result = NEUL_RET_ERROR;
            }
        }
        break;
        default:
            result = NEUL_RET_ERROR;
    6b32:	2501      	movs	r5, #1
    6b34:	e029      	b.n	6b8a <log_uart_nxlog_ctrl+0x72>
              rsp_string = irmalloc(FLOG_READ_LENGTH);
    6b36:	2080      	movs	r0, #128	; 0x80
    6b38:	0080      	lsls	r0, r0, #2
    6b3a:	f00b ff61 	bl	12a00 <irmalloc>
    6b3e:	1e07      	subs	r7, r0, #0
              if(NULL != rsp_string)
    6b40:	d0f7      	beq.n	6b32 <log_uart_nxlog_ctrl+0x1a>
                 ret = flog_read(rsp_string, FLOG_READ_LENGTH,&len);
    6b42:	2180      	movs	r1, #128	; 0x80
    6b44:	0022      	movs	r2, r4
    6b46:	0089      	lsls	r1, r1, #2
    6b48:	f7ff feb4 	bl	68b4 <flog_read>
                     result = NEUL_RET_ERROR;
    6b4c:	2501      	movs	r5, #1
                 if((FLOG_RET_NO_DATA >= ret) && len > 0)
    6b4e:	42a8      	cmp	r0, r5
    6b50:	d818      	bhi.n	6b84 <log_uart_nxlog_ctrl+0x6c>
    6b52:	8823      	ldrh	r3, [r4, #0]
    6b54:	2b00      	cmp	r3, #0
    6b56:	d015      	beq.n	6b84 <log_uart_nxlog_ctrl+0x6c>
                            ret = flog_read(rsp_string, FLOG_READ_LENGTH,&len);
    6b58:	2580      	movs	r5, #128	; 0x80
    6b5a:	00ad      	lsls	r5, r5, #2
                            if (output_callback != NULL)
    6b5c:	2e00      	cmp	r6, #0
    6b5e:	d002      	beq.n	6b66 <log_uart_nxlog_ctrl+0x4e>
                                output_callback((char*)rsp_string, len);
    6b60:	8821      	ldrh	r1, [r4, #0]
    6b62:	0038      	movs	r0, r7
    6b64:	47b0      	blx	r6
                            ret = flog_read(rsp_string, FLOG_READ_LENGTH,&len);
    6b66:	0022      	movs	r2, r4
    6b68:	0029      	movs	r1, r5
    6b6a:	0038      	movs	r0, r7
    6b6c:	f7ff fea2 	bl	68b4 <flog_read>
                        } while((FLOG_RET_OK == ret) && (len > 0));
    6b70:	2800      	cmp	r0, #0
    6b72:	d10d      	bne.n	6b90 <log_uart_nxlog_ctrl+0x78>
    6b74:	8823      	ldrh	r3, [r4, #0]
    6b76:	2b00      	cmp	r3, #0
    6b78:	d1f0      	bne.n	6b5c <log_uart_nxlog_ctrl+0x44>
                        if (output_callback != NULL)
    6b7a:	2e00      	cmp	r6, #0
    6b7c:	d111      	bne.n	6ba2 <log_uart_nxlog_ctrl+0x8a>
                        flog_page_read_finish();//lint !e522
    6b7e:	f7ff fe9d 	bl	68bc <flog_page_read_finish>
    NEUL_RET result = NEUL_RET_OK;
    6b82:	2500      	movs	r5, #0
                 irfree(rsp_string);
    6b84:	0038      	movs	r0, r7
                    irfree(buffer);
    6b86:	f00b ff57 	bl	12a38 <irfree>
        break;
    }
    return result;
}
    6b8a:	0028      	movs	r0, r5
    6b8c:	b005      	add	sp, #20
    6b8e:	bdf0      	pop	{r4, r5, r6, r7, pc}
                        if((FLOG_RET_NO_DATA == ret) && (len > 0))
    6b90:	2801      	cmp	r0, #1
    6b92:	d1f2      	bne.n	6b7a <log_uart_nxlog_ctrl+0x62>
    6b94:	8821      	ldrh	r1, [r4, #0]
    6b96:	2900      	cmp	r1, #0
    6b98:	d0ef      	beq.n	6b7a <log_uart_nxlog_ctrl+0x62>
                            if (output_callback != NULL)
    6b9a:	2e00      	cmp	r6, #0
    6b9c:	d0ef      	beq.n	6b7e <log_uart_nxlog_ctrl+0x66>
                                output_callback((char*)rsp_string, len);
    6b9e:	0038      	movs	r0, r7
    6ba0:	47b0      	blx	r6
                            output_callback(FLOG_AT_STR_RN, (uint16)strlen(FLOG_AT_STR_RN));
    6ba2:	4c2d      	ldr	r4, [pc, #180]	; (6c58 <log_uart_nxlog_ctrl+0x140>)
    6ba4:	0020      	movs	r0, r4
    6ba6:	f014 fbfa 	bl	1b39e <strlen>
    6baa:	b281      	uxth	r1, r0
    6bac:	0020      	movs	r0, r4
    6bae:	47b0      	blx	r6
    6bb0:	e7e5      	b.n	6b7e <log_uart_nxlog_ctrl+0x66>
            if( log_uart != UART_BUS_NONE )
    6bb2:	4b2a      	ldr	r3, [pc, #168]	; (6c5c <log_uart_nxlog_ctrl+0x144>)
    6bb4:	781b      	ldrb	r3, [r3, #0]
    6bb6:	2b03      	cmp	r3, #3
    6bb8:	d0bb      	beq.n	6b32 <log_uart_nxlog_ctrl+0x1a>
                buffer = irmalloc(FLOG_READ_LENGTH);
    6bba:	2080      	movs	r0, #128	; 0x80
    6bbc:	0080      	lsls	r0, r0, #2
    6bbe:	f00b ff1f 	bl	12a00 <irmalloc>
    6bc2:	1e06      	subs	r6, r0, #0
                if(NULL != buffer)
    6bc4:	d0b5      	beq.n	6b32 <log_uart_nxlog_ctrl+0x1a>
                    ret = flog_read(buffer, FLOG_READ_LENGTH,&len);
    6bc6:	2180      	movs	r1, #128	; 0x80
    6bc8:	0022      	movs	r2, r4
    6bca:	0089      	lsls	r1, r1, #2
    6bcc:	f7ff fe72 	bl	68b4 <flog_read>
                        result = NEUL_RET_ERROR;
    6bd0:	2501      	movs	r5, #1
                    if((FLOG_RET_NO_DATA >= ret) && len > 0)
    6bd2:	42a8      	cmp	r0, r5
    6bd4:	d82c      	bhi.n	6c30 <log_uart_nxlog_ctrl+0x118>
    6bd6:	8823      	ldrh	r3, [r4, #0]
    6bd8:	2b00      	cmp	r3, #0
    6bda:	d029      	beq.n	6c30 <log_uart_nxlog_ctrl+0x118>
                        if (osSemaphoreAcquire(semaphore_log_output, osWaitForever) != osOK)
    6bdc:	2101      	movs	r1, #1
    6bde:	4d20      	ldr	r5, [pc, #128]	; (6c60 <log_uart_nxlog_ctrl+0x148>)
    6be0:	4249      	negs	r1, r1
    6be2:	6828      	ldr	r0, [r5, #0]
    6be4:	f00d ff4a 	bl	14a7c <osSemaphoreAcquire>
    6be8:	2800      	cmp	r0, #0
    6bea:	d003      	beq.n	6bf4 <log_uart_nxlog_ctrl+0xdc>
                            panic(PANIC_LOG, LOG_PANIC_MUTEX_NOT_READY); //lint !e454 !e456
    6bec:	0039      	movs	r1, r7
    6bee:	200d      	movs	r0, #13
    6bf0:	f7fa ff8e 	bl	1b10 <panic>
    6bf4:	4f1b      	ldr	r7, [pc, #108]	; (6c64 <log_uart_nxlog_ctrl+0x14c>)
                            assert(len < DMA_CH_MAX_TRANSFER_NUM);
    6bf6:	8823      	ldrh	r3, [r4, #0]
    6bf8:	42bb      	cmp	r3, r7
    6bfa:	d903      	bls.n	6c04 <log_uart_nxlog_ctrl+0xec>
    6bfc:	9901      	ldr	r1, [sp, #4]
    6bfe:	2016      	movs	r0, #22
    6c00:	f7fa ff86 	bl	1b10 <panic>
                            log_uart_write_blocking((const void *) buffer, len, DMA_CH_CYCLE_TYPE_SINGLE);
    6c04:	8821      	ldrh	r1, [r4, #0]
    6c06:	2200      	movs	r2, #0
    6c08:	0030      	movs	r0, r6
    6c0a:	f7ff fe6d 	bl	68e8 <log_uart_write_blocking>
                            ret = flog_read(buffer, FLOG_READ_LENGTH,&len);
    6c0e:	2180      	movs	r1, #128	; 0x80
    6c10:	0022      	movs	r2, r4
    6c12:	0089      	lsls	r1, r1, #2
    6c14:	0030      	movs	r0, r6
    6c16:	f7ff fe4d 	bl	68b4 <flog_read>
                        } while((FLOG_RET_OK == ret) && (len > 0));
    6c1a:	2800      	cmp	r0, #0
    6c1c:	d10a      	bne.n	6c34 <log_uart_nxlog_ctrl+0x11c>
    6c1e:	8823      	ldrh	r3, [r4, #0]
    6c20:	2b00      	cmp	r3, #0
    6c22:	d1e8      	bne.n	6bf6 <log_uart_nxlog_ctrl+0xde>
                        flog_page_read_finish();//lint !e522
    6c24:	f7ff fe4a 	bl	68bc <flog_page_read_finish>
                        (void)osSemaphoreRelease( semaphore_log_output);
    6c28:	6828      	ldr	r0, [r5, #0]
    6c2a:	f00d ff53 	bl	14ad4 <osSemaphoreRelease>
    NEUL_RET result = NEUL_RET_OK;
    6c2e:	2500      	movs	r5, #0
                    irfree(buffer);
    6c30:	0030      	movs	r0, r6
    6c32:	e7a8      	b.n	6b86 <log_uart_nxlog_ctrl+0x6e>
                        if((FLOG_RET_NO_DATA == ret) && (len > 0))
    6c34:	2801      	cmp	r0, #1
    6c36:	d1f5      	bne.n	6c24 <log_uart_nxlog_ctrl+0x10c>
    6c38:	8823      	ldrh	r3, [r4, #0]
    6c3a:	2b00      	cmp	r3, #0
    6c3c:	d0f2      	beq.n	6c24 <log_uart_nxlog_ctrl+0x10c>
                            assert(len < DMA_CH_MAX_TRANSFER_NUM);
    6c3e:	42bb      	cmp	r3, r7
    6c40:	d903      	bls.n	6c4a <log_uart_nxlog_ctrl+0x132>
    6c42:	9901      	ldr	r1, [sp, #4]
    6c44:	3015      	adds	r0, #21
    6c46:	f7fa ff63 	bl	1b10 <panic>
                            log_uart_write_blocking((const void *) buffer, len, DMA_CH_CYCLE_TYPE_SINGLE);
    6c4a:	8821      	ldrh	r1, [r4, #0]
    6c4c:	2200      	movs	r2, #0
    6c4e:	0030      	movs	r0, r6
    6c50:	f7ff fe4a 	bl	68e8 <log_uart_write_blocking>
    6c54:	e7e6      	b.n	6c24 <log_uart_nxlog_ctrl+0x10c>
    6c56:	46c0      	nop			; (mov r8, r8)
    6c58:	00022d8f 	.word	0x00022d8f
    6c5c:	01000592 	.word	0x01000592
    6c60:	01001580 	.word	0x01001580
    6c64:	000003ff 	.word	0x000003ff

00006c68 <log_main>:
}
#endif

//lint -esym(459, log_main) Function whose address was taken has unprotected access
void log_main( void *unused_p )
{
    6c68:	b5f0      	push	{r4, r5, r6, r7, lr}

    LOG_READER_RET lr_ret;
    LOG_MEMORY_REGION_SECTION lregion;
    log_buffer_header lb_header;
    uint8 * b1 = NULL;
    uint16 l1 = 0;
    6c6a:	240e      	movs	r4, #14
    uint8 * b1 = NULL;
    6c6c:	2300      	movs	r3, #0
{
    6c6e:	b08d      	sub	sp, #52	; 0x34
    uint16 l1 = 0;
    6c70:	aa02      	add	r2, sp, #8
    6c72:	18a4      	adds	r4, r4, r2
    uint16 l2 = 0;

    log_full_log_enabled_init();

    // wait here until we are enabled
    while( osSemaphoreAcquire(semaphore_log_reader_enable, osWaitForever) != osOK )
    6c74:	2501      	movs	r5, #1
    uint16 l2 = 0;
    6c76:	aa06      	add	r2, sp, #24
    6c78:	4677      	mov	r7, lr
    uint8 * b1 = NULL;
    6c7a:	9307      	str	r3, [sp, #28]
    uint16 l1 = 0;
    6c7c:	8023      	strh	r3, [r4, #0]
    uint8 * b2 = NULL;
    6c7e:	9308      	str	r3, [sp, #32]
    uint16 l2 = 0;
    6c80:	8013      	strh	r3, [r2, #0]
    log_full_log_enabled_init();
    6c82:	f7ff fcb3 	bl	65ec <log_full_log_enabled_init>
    while( osSemaphoreAcquire(semaphore_log_reader_enable, osWaitForever) != osOK )
    6c86:	426d      	negs	r5, r5
    6c88:	4b9f      	ldr	r3, [pc, #636]	; (6f08 <log_main+0x2a0>)
    6c8a:	0029      	movs	r1, r5
    6c8c:	6818      	ldr	r0, [r3, #0]
    6c8e:	f00d fef5 	bl	14a7c <osSemaphoreAcquire>
    6c92:	2800      	cmp	r0, #0
    6c94:	d1f8      	bne.n	6c88 <log_main+0x20>
    {
        // loop as osWaitForever isn't forever
    }

    log_uart_init();
    6c96:	f7ff fe63 	bl	6960 <log_uart_init>
    uint32 flog_time_out = clocks_get_core_clock() * FLOG_TIME_OUT;
    6c9a:	f010 f9d4 	bl	17046 <clocks_get_core_clock>
    {
        enable_nxlog = false;
    }
#endif

    memcpy(packed_short_log, LOG_UART_PREFIX, LOG_UART_PREFIX_LENGTH);
    6c9e:	2205      	movs	r2, #5
    uint32 flog_time_out = clocks_get_core_clock() * FLOG_TIME_OUT;
    6ca0:	0083      	lsls	r3, r0, #2
    memcpy(packed_short_log, LOG_UART_PREFIX, LOG_UART_PREFIX_LENGTH);
    6ca2:	499a      	ldr	r1, [pc, #616]	; (6f0c <log_main+0x2a4>)
    6ca4:	489a      	ldr	r0, [pc, #616]	; (6f10 <log_main+0x2a8>)
    uint32 flog_time_out = clocks_get_core_clock() * FLOG_TIME_OUT;
    6ca6:	9303      	str	r3, [sp, #12]
    memcpy(packed_short_log, LOG_UART_PREFIX, LOG_UART_PREFIX_LENGTH);
    6ca8:	f7f9 faa2 	bl	1f0 <memcpy>
    for (;;)
    {
        // Check if there are messages
        lr_ret = log_buffer_reader_lock_next(&lregion, &lb_header);
    6cac:	200d      	movs	r0, #13
    6cae:	ab02      	add	r3, sp, #8
    6cb0:	a909      	add	r1, sp, #36	; 0x24
    6cb2:	18c0      	adds	r0, r0, r3
    6cb4:	f010 fe46 	bl	17944 <log_buffer_reader_lock_next>
    6cb8:	1e05      	subs	r5, r0, #0
        assert( lr_ret == LOG_READER_RET_OK || lr_ret == LOG_READER_RET_THERE_IS_NO_NEXT_MESSAGE );
    6cba:	d005      	beq.n	6cc8 <log_main+0x60>
    6cbc:	2805      	cmp	r0, #5
    6cbe:	d003      	beq.n	6cc8 <log_main+0x60>
            lr_ret = log_buffer_reader_discard(lregion);
            assert( lr_ret == LOG_READER_RET_OK );

            // Check if there is a new message to get
            lr_ret = log_buffer_reader_lock_next(&lregion, &lb_header);
            assert( lr_ret == LOG_READER_RET_OK || lr_ret == LOG_READER_RET_THERE_IS_NO_NEXT_MESSAGE );
    6cc0:	0039      	movs	r1, r7
    6cc2:	2016      	movs	r0, #22
    6cc4:	f7fa ff24 	bl	1b10 <panic>
        while (lr_ret == LOG_READER_RET_OK)
    6cc8:	2d00      	cmp	r5, #0
    6cca:	d000      	beq.n	6cce <log_main+0x66>
    6ccc:	e0a3      	b.n	6e16 <log_main+0x1ae>
            if (osSemaphoreAcquire(semaphore_log_output, osWaitForever) != osOK)
    6cce:	2101      	movs	r1, #1
    6cd0:	4b90      	ldr	r3, [pc, #576]	; (6f14 <log_main+0x2ac>)
    6cd2:	4249      	negs	r1, r1
    6cd4:	6818      	ldr	r0, [r3, #0]
    6cd6:	f00d fed1 	bl	14a7c <osSemaphoreAcquire>
    6cda:	2800      	cmp	r0, #0
    6cdc:	d003      	beq.n	6ce6 <log_main+0x7e>
                panic(PANIC_LOG, LOG_PANIC_MUTEX_NOT_READY); //lint !e454 !e456
    6cde:	2100      	movs	r1, #0
    6ce0:	200d      	movs	r0, #13
    6ce2:	f7fa ff15 	bl	1b10 <panic>
    6ce6:	2203      	movs	r2, #3
            if(((lb_header.msg_header.kv>>LOG_KV_FLAGS_SHIFT) & LOG_KV_FLAGS_MASK) == LOG_FLAGS_XLOG)
    6ce8:	ae09      	add	r6, sp, #36	; 0x24
    6cea:	7933      	ldrb	r3, [r6, #4]
            lr_ret = log_buffer_reader_claim_next(lregion, &b1, &l1, &b2, &l2);
    6cec:	ad06      	add	r5, sp, #24
            if(((lb_header.msg_header.kv>>LOG_KV_FLAGS_SHIFT) & LOG_KV_FLAGS_MASK) == LOG_FLAGS_XLOG)
    6cee:	08db      	lsrs	r3, r3, #3
    6cf0:	401a      	ands	r2, r3
            lr_ret = log_buffer_reader_claim_next(lregion, &b1, &l1, &b2, &l2);
    6cf2:	230d      	movs	r3, #13
    6cf4:	9202      	str	r2, [sp, #8]
    6cf6:	aa02      	add	r2, sp, #8
    6cf8:	189b      	adds	r3, r3, r2
    6cfa:	7818      	ldrb	r0, [r3, #0]
    6cfc:	0022      	movs	r2, r4
    6cfe:	9500      	str	r5, [sp, #0]
    6d00:	ab08      	add	r3, sp, #32
    6d02:	a907      	add	r1, sp, #28
    6d04:	f010 fe86 	bl	17a14 <log_buffer_reader_claim_next>
            assert( lr_ret == LOG_READER_RET_OK ); // we are sure there is a new message
    6d08:	2800      	cmp	r0, #0
    6d0a:	d003      	beq.n	6d14 <log_main+0xac>
    6d0c:	0039      	movs	r1, r7
    6d0e:	2016      	movs	r0, #22
    6d10:	f7fa fefe 	bl	1b10 <panic>
            assert ( lb_header.msg_header.length == l1 + l2 ) ;
    6d14:	8823      	ldrh	r3, [r4, #0]
    6d16:	8829      	ldrh	r1, [r5, #0]
    6d18:	8932      	ldrh	r2, [r6, #8]
    6d1a:	185b      	adds	r3, r3, r1
    6d1c:	429a      	cmp	r2, r3
    6d1e:	d003      	beq.n	6d28 <log_main+0xc0>
    6d20:	0039      	movs	r1, r7
    6d22:	2016      	movs	r0, #22
    6d24:	f7fa fef4 	bl	1b10 <panic>
            sequence_number++;
    6d28:	497b      	ldr	r1, [pc, #492]	; (6f18 <log_main+0x2b0>)
    6d2a:	680b      	ldr	r3, [r1, #0]
    6d2c:	3301      	adds	r3, #1
    6d2e:	600b      	str	r3, [r1, #0]
            if( log_uart != UART_BUS_NONE )
    6d30:	4b7a      	ldr	r3, [pc, #488]	; (6f1c <log_main+0x2b4>)
    6d32:	781b      	ldrb	r3, [r3, #0]
    6d34:	2b03      	cmp	r3, #3
    6d36:	d025      	beq.n	6d84 <log_main+0x11c>
                memcpy(packed_short_log + LOG_UART_PREFIX_LENGTH, &sequence_number, sizeof(sequence_number));
    6d38:	2204      	movs	r2, #4
    6d3a:	4879      	ldr	r0, [pc, #484]	; (6f20 <log_main+0x2b8>)
    6d3c:	f7f9 fa58 	bl	1f0 <memcpy>
                memcpy(packed_short_log + LOG_UART_PREFIX_LENGTH + sizeof(sequence_number), &lb_header, sizeof(lb_header));
    6d40:	4873      	ldr	r0, [pc, #460]	; (6f10 <log_main+0x2a8>)
    6d42:	ad09      	add	r5, sp, #36	; 0x24
    6d44:	3009      	adds	r0, #9
    6d46:	220a      	movs	r2, #10
    6d48:	0029      	movs	r1, r5
    6d4a:	f7f9 fa51 	bl	1f0 <memcpy>
                if (lb_header.msg_header.length <= sizeof(packed_short_log) - LOG_UART_MSG_PREFIX_AND_HEADER_LENGTH)
    6d4e:	892e      	ldrh	r6, [r5, #8]
    6d50:	2e6d      	cmp	r6, #109	; 0x6d
    6d52:	d873      	bhi.n	6e3c <log_main+0x1d4>
                    if (l1 > 0)
    6d54:	8825      	ldrh	r5, [r4, #0]
    6d56:	2d00      	cmp	r5, #0
    6d58:	d004      	beq.n	6d64 <log_main+0xfc>
                        memcpy(packed_short_log + LOG_UART_MSG_PREFIX_AND_HEADER_LENGTH, b1, l1);
    6d5a:	002a      	movs	r2, r5
    6d5c:	9907      	ldr	r1, [sp, #28]
    6d5e:	4871      	ldr	r0, [pc, #452]	; (6f24 <log_main+0x2bc>)
    6d60:	f7f9 fa46 	bl	1f0 <memcpy>
                    if (l2 > 0)
    6d64:	ab06      	add	r3, sp, #24
    6d66:	881a      	ldrh	r2, [r3, #0]
    6d68:	2a00      	cmp	r2, #0
    6d6a:	d005      	beq.n	6d78 <log_main+0x110>
                        memcpy(packed_short_log + LOG_UART_MSG_PREFIX_AND_HEADER_LENGTH + l1, b2, l2);
    6d6c:	4868      	ldr	r0, [pc, #416]	; (6f10 <log_main+0x2a8>)
    6d6e:	3513      	adds	r5, #19
    6d70:	1828      	adds	r0, r5, r0
    6d72:	9908      	ldr	r1, [sp, #32]
    6d74:	f7f9 fa3c 	bl	1f0 <memcpy>
                    log_uart_write_blocking( packed_short_log, (uint16)(LOG_UART_MSG_PREFIX_AND_HEADER_LENGTH + lb_header.msg_header.length), DMA_CH_CYCLE_TYPE_SINGLE );
    6d78:	2200      	movs	r2, #0
    6d7a:	3613      	adds	r6, #19
    6d7c:	4864      	ldr	r0, [pc, #400]	; (6f10 <log_main+0x2a8>)
    6d7e:	b2b1      	uxth	r1, r6
                        log_uart_write_blocking((const void *) b2, l2, DMA_CH_CYCLE_TYPE_BATCHED_END);
    6d80:	f7ff fdb2 	bl	68e8 <log_uart_write_blocking>
            if (is_xlog_message)
    6d84:	9b02      	ldr	r3, [sp, #8]
    6d86:	2b01      	cmp	r3, #1
    6d88:	d12b      	bne.n	6de2 <log_main+0x17a>
                if ((watchdog_get_time() > flog_time_out) && (flog_get_available_size() >= ((uint16)LOG_UART_PREFIX_LENGTH + (uint16) sizeof(sequence_number) + (uint16) sizeof(log_buffer_header) + l1 + l2)))
    6d8a:	f011 fda3 	bl	188d4 <watchdog_get_time>
    6d8e:	9b03      	ldr	r3, [sp, #12]
    6d90:	4298      	cmp	r0, r3
    6d92:	d926      	bls.n	6de2 <log_main+0x17a>
    6d94:	f7ff fd93 	bl	68be <flog_get_available_size>
    6d98:	8823      	ldrh	r3, [r4, #0]
    6d9a:	aa06      	add	r2, sp, #24
    6d9c:	8812      	ldrh	r2, [r2, #0]
    6d9e:	3313      	adds	r3, #19
    6da0:	189b      	adds	r3, r3, r2
    6da2:	4298      	cmp	r0, r3
    6da4:	db1d      	blt.n	6de2 <log_main+0x17a>
                    (void)flog_log_write((uint8 *)LOG_UART_PREFIX,  (uint16)LOG_UART_PREFIX_LENGTH, true);
    6da6:	9a02      	ldr	r2, [sp, #8]
    6da8:	2105      	movs	r1, #5
    6daa:	4858      	ldr	r0, [pc, #352]	; (6f0c <log_main+0x2a4>)
    6dac:	f7ff fd7e 	bl	68ac <flog_log_write>
                    (void)flog_log_write((uint8 *)&sequence_number, (uint16)sizeof(sequence_number), true);
    6db0:	9a02      	ldr	r2, [sp, #8]
    6db2:	2104      	movs	r1, #4
    6db4:	4858      	ldr	r0, [pc, #352]	; (6f18 <log_main+0x2b0>)
    6db6:	f7ff fd79 	bl	68ac <flog_log_write>
                    (void)flog_log_write((uint8 *)&lb_header,       (uint16)sizeof(log_buffer_header), true);
    6dba:	210a      	movs	r1, #10
    6dbc:	9a02      	ldr	r2, [sp, #8]
    6dbe:	a809      	add	r0, sp, #36	; 0x24
    6dc0:	f7ff fd74 	bl	68ac <flog_log_write>
                    if (l1 > 0)
    6dc4:	8821      	ldrh	r1, [r4, #0]
    6dc6:	2900      	cmp	r1, #0
    6dc8:	d003      	beq.n	6dd2 <log_main+0x16a>
                        (void)flog_log_write((uint8 *)b1, (uint16)l1, true);
    6dca:	9a02      	ldr	r2, [sp, #8]
    6dcc:	9807      	ldr	r0, [sp, #28]
    6dce:	f7ff fd6d 	bl	68ac <flog_log_write>
                    if (l2 > 0)
    6dd2:	ab06      	add	r3, sp, #24
    6dd4:	8819      	ldrh	r1, [r3, #0]
    6dd6:	2900      	cmp	r1, #0
    6dd8:	d003      	beq.n	6de2 <log_main+0x17a>
                        (void)flog_log_write((uint8 *)b2, (uint16)l2, true);
    6dda:	2201      	movs	r2, #1
    6ddc:	9808      	ldr	r0, [sp, #32]
    6dde:	f7ff fd65 	bl	68ac <flog_log_write>
            lr_ret = log_buffer_reader_discard(lregion);
    6de2:	250d      	movs	r5, #13
            (void)osSemaphoreRelease( semaphore_log_output);
    6de4:	4b4b      	ldr	r3, [pc, #300]	; (6f14 <log_main+0x2ac>)
    6de6:	6818      	ldr	r0, [r3, #0]
    6de8:	f00d fe74 	bl	14ad4 <osSemaphoreRelease>
            lr_ret = log_buffer_reader_discard(lregion);
    6dec:	ab02      	add	r3, sp, #8
    6dee:	18ed      	adds	r5, r5, r3
    6df0:	7828      	ldrb	r0, [r5, #0]
    6df2:	f010 fe9d 	bl	17b30 <log_buffer_reader_discard>
            assert( lr_ret == LOG_READER_RET_OK );
    6df6:	2800      	cmp	r0, #0
    6df8:	d003      	beq.n	6e02 <log_main+0x19a>
    6dfa:	0039      	movs	r1, r7
    6dfc:	2016      	movs	r0, #22
    6dfe:	f7fa fe87 	bl	1b10 <panic>
            lr_ret = log_buffer_reader_lock_next(&lregion, &lb_header);
    6e02:	0028      	movs	r0, r5
    6e04:	a909      	add	r1, sp, #36	; 0x24
    6e06:	f010 fd9d 	bl	17944 <log_buffer_reader_lock_next>
    6e0a:	0005      	movs	r5, r0
    6e0c:	1e06      	subs	r6, r0, #0
            assert( lr_ret == LOG_READER_RET_OK || lr_ret == LOG_READER_RET_THERE_IS_NO_NEXT_MESSAGE );
    6e0e:	d053      	beq.n	6eb8 <log_main+0x250>
    6e10:	2805      	cmp	r0, #5
    6e12:	d000      	beq.n	6e16 <log_main+0x1ae>
    6e14:	e754      	b.n	6cc0 <log_main+0x58>
            }
        }

        // If there has been log indicator get run again

        if (osKernelGetState() == osKernelRunning)
    6e16:	f00d fc5d 	bl	146d4 <osKernelGetState>
    6e1a:	2802      	cmp	r0, #2
    6e1c:	d000      	beq.n	6e20 <log_main+0x1b8>
    6e1e:	e745      	b.n	6cac <log_main+0x44>
        {
            if(osSemaphoreAcquire(semaphore_logs, osWaitForever) != osOK)
    6e20:	2101      	movs	r1, #1
    6e22:	4b41      	ldr	r3, [pc, #260]	; (6f28 <log_main+0x2c0>)
    6e24:	4249      	negs	r1, r1
    6e26:	6818      	ldr	r0, [r3, #0]
    6e28:	f00d fe28 	bl	14a7c <osSemaphoreAcquire>
    6e2c:	2800      	cmp	r0, #0
    6e2e:	d100      	bne.n	6e32 <log_main+0x1ca>
    6e30:	e73c      	b.n	6cac <log_main+0x44>
            {
                panic(PANIC_LOG, LOG_PANIC_MUTEX_NOT_READY); //lint !e454 !e456
    6e32:	2100      	movs	r1, #0
    6e34:	200d      	movs	r0, #13
    6e36:	f7fa fe6b 	bl	1b10 <panic>
    6e3a:	e737      	b.n	6cac <log_main+0x44>
                    log_uart_write_blocking( packed_short_log, LOG_UART_MSG_PREFIX_AND_HEADER_LENGTH,
    6e3c:	2201      	movs	r2, #1
    6e3e:	2113      	movs	r1, #19
    6e40:	4833      	ldr	r0, [pc, #204]	; (6f10 <log_main+0x2a8>)
    6e42:	f7ff fd51 	bl	68e8 <log_uart_write_blocking>
                    if (l1 > 0)
    6e46:	8823      	ldrh	r3, [r4, #0]
    6e48:	2b00      	cmp	r3, #0
    6e4a:	d00c      	beq.n	6e66 <log_main+0x1fe>
                        while (l1 > DMA_CH_MAX_TRANSFER_NUM)
    6e4c:	2580      	movs	r5, #128	; 0x80
    6e4e:	00ed      	lsls	r5, r5, #3
    6e50:	8821      	ldrh	r1, [r4, #0]
    6e52:	9807      	ldr	r0, [sp, #28]
    6e54:	42a9      	cmp	r1, r5
    6e56:	d813      	bhi.n	6e80 <log_main+0x218>
                        log_uart_write_blocking((const void *) b1, l1, (l2 > 0) ? DMA_CH_CYCLE_TYPE_BATCHED_PART : DMA_CH_CYCLE_TYPE_BATCHED_END);
    6e58:	ab06      	add	r3, sp, #24
    6e5a:	881a      	ldrh	r2, [r3, #0]
    6e5c:	4253      	negs	r3, r2
    6e5e:	415a      	adcs	r2, r3
    6e60:	3201      	adds	r2, #1
    6e62:	f7ff fd41 	bl	68e8 <log_uart_write_blocking>
                    if (l2 > 0)
    6e66:	ab06      	add	r3, sp, #24
    6e68:	881b      	ldrh	r3, [r3, #0]
    6e6a:	2b00      	cmp	r3, #0
    6e6c:	d08a      	beq.n	6d84 <log_main+0x11c>
                        while (l2 > DMA_CH_MAX_TRANSFER_NUM)
    6e6e:	2680      	movs	r6, #128	; 0x80
    6e70:	00f6      	lsls	r6, r6, #3
    6e72:	ad06      	add	r5, sp, #24
    6e74:	8829      	ldrh	r1, [r5, #0]
    6e76:	9808      	ldr	r0, [sp, #32]
    6e78:	42b1      	cmp	r1, r6
    6e7a:	d80f      	bhi.n	6e9c <log_main+0x234>
                        log_uart_write_blocking((const void *) b2, l2, DMA_CH_CYCLE_TYPE_BATCHED_END);
    6e7c:	2202      	movs	r2, #2
    6e7e:	e77f      	b.n	6d80 <log_main+0x118>
                            log_uart_write_blocking((const void *) b1, DMA_CH_MAX_TRANSFER_NUM, DMA_CH_CYCLE_TYPE_BATCHED_PART);
    6e80:	2201      	movs	r2, #1
    6e82:	0029      	movs	r1, r5
    6e84:	f7ff fd30 	bl	68e8 <log_uart_write_blocking>
                            b1 += DMA_CH_MAX_TRANSFER_NUM;
    6e88:	2280      	movs	r2, #128	; 0x80
    6e8a:	9b07      	ldr	r3, [sp, #28]
    6e8c:	00d2      	lsls	r2, r2, #3
    6e8e:	189b      	adds	r3, r3, r2
    6e90:	9307      	str	r3, [sp, #28]
                            l1 -= DMA_CH_MAX_TRANSFER_NUM;
    6e92:	4a26      	ldr	r2, [pc, #152]	; (6f2c <log_main+0x2c4>)
    6e94:	8823      	ldrh	r3, [r4, #0]
    6e96:	189b      	adds	r3, r3, r2
    6e98:	8023      	strh	r3, [r4, #0]
    6e9a:	e7d9      	b.n	6e50 <log_main+0x1e8>
                            log_uart_write_blocking((const void *) b2, DMA_CH_MAX_TRANSFER_NUM, DMA_CH_CYCLE_TYPE_BATCHED_PART);
    6e9c:	2201      	movs	r2, #1
    6e9e:	0031      	movs	r1, r6
    6ea0:	f7ff fd22 	bl	68e8 <log_uart_write_blocking>
                            b2 += DMA_CH_MAX_TRANSFER_NUM;
    6ea4:	2280      	movs	r2, #128	; 0x80
    6ea6:	9b08      	ldr	r3, [sp, #32]
    6ea8:	00d2      	lsls	r2, r2, #3
    6eaa:	189b      	adds	r3, r3, r2
    6eac:	9308      	str	r3, [sp, #32]
                            l2 -= DMA_CH_MAX_TRANSFER_NUM;
    6eae:	4a1f      	ldr	r2, [pc, #124]	; (6f2c <log_main+0x2c4>)
    6eb0:	882b      	ldrh	r3, [r5, #0]
    6eb2:	189b      	adds	r3, r3, r2
    6eb4:	802b      	strh	r3, [r5, #0]
    6eb6:	e7dc      	b.n	6e72 <log_main+0x20a>
            if (lr_ret == LOG_READER_RET_OK  && log_uart_early_stop(lb_header.time_us))
    6eb8:	9d09      	ldr	r5, [sp, #36]	; 0x24
    return ( PROTOCOL_ASSERTS_SLEEP() && ((uint32)((uint32) hal_rtc_get_time_us() - next_msg_us) <  OLDEST_MESSAGE_IN_BUFFER*1000)  && log_uart_is_protocol_region_under_watermark() );
    6eba:	f012 fbf9 	bl	196b0 <hal_lpc_get_status_register>
    6ebe:	01c3      	lsls	r3, r0, #7
    6ec0:	d400      	bmi.n	6ec4 <log_main+0x25c>
    6ec2:	e704      	b.n	6cce <log_main+0x66>
    6ec4:	f012 fc3c 	bl	19740 <hal_rtc_get_time_us>
    6ec8:	4b19      	ldr	r3, [pc, #100]	; (6f30 <log_main+0x2c8>)
    6eca:	1b45      	subs	r5, r0, r5
    6ecc:	429d      	cmp	r5, r3
    6ece:	d900      	bls.n	6ed2 <log_main+0x26a>
    6ed0:	e6fd      	b.n	6cce <log_main+0x66>
    uint16 used_space = 0;
    6ed2:	2512      	movs	r5, #18
    6ed4:	ab02      	add	r3, sp, #8
    6ed6:	18ed      	adds	r5, r5, r3
    (void) log_buffer_get_used_space(LOG_MEMORY_REGION_SECTION_1, &used_space);
    6ed8:	0029      	movs	r1, r5
    6eda:	2001      	movs	r0, #1
    uint16 used_space = 0;
    6edc:	802e      	strh	r6, [r5, #0]
    (void) log_buffer_get_used_space(LOG_MEMORY_REGION_SECTION_1, &used_space);
    6ede:	f010 fd7b 	bl	179d8 <log_buffer_get_used_space>
    return (used_space < log_uart_protocol_log_watermark);
    6ee2:	4b14      	ldr	r3, [pc, #80]	; (6f34 <log_main+0x2cc>)
    6ee4:	882a      	ldrh	r2, [r5, #0]
    6ee6:	881b      	ldrh	r3, [r3, #0]
            if (lr_ret == LOG_READER_RET_OK  && log_uart_early_stop(lb_header.time_us))
    6ee8:	429a      	cmp	r2, r3
    6eea:	d300      	bcc.n	6eee <log_main+0x286>
    6eec:	e6ef      	b.n	6cce <log_main+0x66>
    osStatus_t os_timer_ret = osTimerStart(log_uart_early_stop_timer, OLDEST_MESSAGE_IN_BUFFER);
    6eee:	21fa      	movs	r1, #250	; 0xfa
    6ef0:	4b11      	ldr	r3, [pc, #68]	; (6f38 <log_main+0x2d0>)
    6ef2:	0089      	lsls	r1, r1, #2
    6ef4:	6818      	ldr	r0, [r3, #0]
    6ef6:	f00d fce7 	bl	148c8 <osTimerStart>
    assert (os_timer_ret == osOK);
    6efa:	2800      	cmp	r0, #0
    6efc:	d08b      	beq.n	6e16 <log_main+0x1ae>
    6efe:	0039      	movs	r1, r7
    6f00:	2016      	movs	r0, #22
    6f02:	f7fa fe05 	bl	1b10 <panic>
    6f06:	e786      	b.n	6e16 <log_main+0x1ae>
    6f08:	01001584 	.word	0x01001584
    6f0c:	00022b7c 	.word	0x00022b7c
    6f10:	01001500 	.word	0x01001500
    6f14:	01001580 	.word	0x01001580
    6f18:	01001590 	.word	0x01001590
    6f1c:	01000592 	.word	0x01000592
    6f20:	01001505 	.word	0x01001505
    6f24:	01001513 	.word	0x01001513
    6f28:	01001588 	.word	0x01001588
    6f2c:	fffffc00 	.word	0xfffffc00
    6f30:	000f423f 	.word	0x000f423f
    6f34:	010014fc 	.word	0x010014fc
    6f38:	010014f8 	.word	0x010014f8

00006f3c <log_uart_enable>:
        }
    } //lint !e456 Semaphore is taking here and given by the log_trigger
}//lint !e456

void log_uart_enable(void)
{
    6f3c:	b510      	push	{r4, lr}
    (void) osSemaphoreRelease(semaphore_log_reader_enable);
    6f3e:	4b02      	ldr	r3, [pc, #8]	; (6f48 <log_uart_enable+0xc>)
    6f40:	6818      	ldr	r0, [r3, #0]
    6f42:	f00d fdc7 	bl	14ad4 <osSemaphoreRelease>
}
    6f46:	bd10      	pop	{r4, pc}
    6f48:	01001584 	.word	0x01001584

00006f4c <update_package_parse_cnf>:

    return NEUL_UPDATE_RET_OK;
}

static void update_package_parse_cnf(uint8 status)
{
    6f4c:	b510      	push	{r4, lr}
    if (package_parse_finish_callback != NULL)
    6f4e:	4c04      	ldr	r4, [pc, #16]	; (6f60 <update_package_parse_cnf+0x14>)
    6f50:	6823      	ldr	r3, [r4, #0]
    6f52:	2b00      	cmp	r3, #0
    6f54:	d002      	beq.n	6f5c <update_package_parse_cnf+0x10>
    {
        package_parse_finish_callback(status);
    6f56:	4798      	blx	r3
        package_parse_finish_callback = NULL;
    6f58:	2300      	movs	r3, #0
    6f5a:	6023      	str	r3, [r4, #0]
    }
}
    6f5c:	bd10      	pop	{r4, pc}
    6f5e:	46c0      	nop			; (mov r8, r8)
    6f60:	0100159c 	.word	0x0100159c

00006f64 <update_package_process_cnf>:

    return NEUL_UPDATE_RET_OK;
}

static void update_package_process_cnf(uint8 status)
{
    6f64:	b510      	push	{r4, lr}
    if (package_validate_finish_callback != NULL)
    6f66:	4c04      	ldr	r4, [pc, #16]	; (6f78 <update_package_process_cnf+0x14>)
    6f68:	6823      	ldr	r3, [r4, #0]
    6f6a:	2b00      	cmp	r3, #0
    6f6c:	d002      	beq.n	6f74 <update_package_process_cnf+0x10>
    {
        package_validate_finish_callback(status);
    6f6e:	4798      	blx	r3
        package_validate_finish_callback = NULL;
    6f70:	2300      	movs	r3, #0
    6f72:	6023      	str	r3, [r4, #0]
    }
}
    6f74:	bd10      	pop	{r4, pc}
    6f76:	46c0      	nop			; (mov r8, r8)
    6f78:	010015a0 	.word	0x010015a0

00006f7c <update_package_get_package_info_cnf>:

    return NEUL_UPDATE_RET_OK;
}

static void update_package_get_package_info_cnf(uint16 info_length, const uint8 *info)
{
    6f7c:	b570      	push	{r4, r5, r6, lr}
    6f7e:	1e0d      	subs	r5, r1, #0
    uint16 len = info_length < MAX_PKGINFO_LENGTH ? info_length : MAX_PKGINFO_LENGTH;
    uint8 *ota_package_info  = NULL;

    if (info != NULL)
    6f80:	d011      	beq.n	6fa6 <update_package_get_package_info_cnf+0x2a>
    {
        /* We should only malloc the package info buffer when needed. */
        if (get_package_info_buff_callback != NULL)
    6f82:	4b0d      	ldr	r3, [pc, #52]	; (6fb8 <update_package_get_package_info_cnf+0x3c>)
    6f84:	681b      	ldr	r3, [r3, #0]
    6f86:	2b00      	cmp	r3, #0
    6f88:	d00d      	beq.n	6fa6 <update_package_get_package_info_cnf+0x2a>
    uint16 len = info_length < MAX_PKGINFO_LENGTH ? info_length : MAX_PKGINFO_LENGTH;
    6f8a:	1c04      	adds	r4, r0, #0
    6f8c:	2864      	cmp	r0, #100	; 0x64
    6f8e:	d900      	bls.n	6f92 <update_package_get_package_info_cnf+0x16>
    6f90:	2464      	movs	r4, #100	; 0x64
    6f92:	b2a4      	uxth	r4, r4
        {
            ota_package_info = get_package_info_buff_callback(len + 1); /* plus 1 is the tail '\0' */
    6f94:	1c60      	adds	r0, r4, #1
    6f96:	b280      	uxth	r0, r0
    6f98:	4798      	blx	r3
        }
        if (ota_package_info != NULL)
    6f9a:	2800      	cmp	r0, #0
    6f9c:	d003      	beq.n	6fa6 <update_package_get_package_info_cnf+0x2a>
        {
            memcpy(ota_package_info, info, len);
    6f9e:	0022      	movs	r2, r4
    6fa0:	0029      	movs	r1, r5
    6fa2:	f7f9 f925 	bl	1f0 <memcpy>
        }
    }

    if (get_package_info_cnf_callback != NULL)
    6fa6:	4c05      	ldr	r4, [pc, #20]	; (6fbc <update_package_get_package_info_cnf+0x40>)
    6fa8:	6823      	ldr	r3, [r4, #0]
    6faa:	2b00      	cmp	r3, #0
    6fac:	d002      	beq.n	6fb4 <update_package_get_package_info_cnf+0x38>
    {
        get_package_info_cnf_callback();
    6fae:	4798      	blx	r3
        get_package_info_cnf_callback = NULL;
    6fb0:	2300      	movs	r3, #0
    6fb2:	6023      	str	r3, [r4, #0]
    }
}
    6fb4:	bd70      	pop	{r4, r5, r6, pc}
    6fb6:	46c0      	nop			; (mov r8, r8)
    6fb8:	01001594 	.word	0x01001594
    6fbc:	01001598 	.word	0x01001598

00006fc0 <update_package_get_package_name_cnf>:



static void update_package_get_package_name_cnf(uint16 pkgname_length, uint8 *pkgname)
{
    6fc0:	b510      	push	{r4, lr}
    update_package_get_package_info_cnf(pkgname_length, pkgname);
    6fc2:	f7ff ffdb 	bl	6f7c <update_package_get_package_info_cnf>
}//lint !e818
    6fc6:	bd10      	pop	{r4, pc}

00006fc8 <update_package_get_package_version_cnf>:
    6fc8:	b510      	push	{r4, lr}
    6fca:	f7ff ffd7 	bl	6f7c <update_package_get_package_info_cnf>
    6fce:	bd10      	pop	{r4, pc}

00006fd0 <ota_package_upgrade_req>:
{
    6fd0:	b507      	push	{r0, r1, r2, lr}
    if (neul_update_firmware_upgrade_req(&status) != NEUL_RET_OK)
    6fd2:	466b      	mov	r3, sp
    6fd4:	1dd8      	adds	r0, r3, #7
    6fd6:	f000 fbf2 	bl	77be <neul_update_firmware_upgrade_req>
    return NEUL_UPDATE_RET_OK;
    6fda:	1e43      	subs	r3, r0, #1
    6fdc:	4198      	sbcs	r0, r3
    6fde:	0080      	lsls	r0, r0, #2
}
    6fe0:	bd0e      	pop	{r1, r2, r3, pc}
	...

00006fe4 <ota_package_parse_req>:
    package_parse_finish_callback = callback;
    6fe4:	4b04      	ldr	r3, [pc, #16]	; (6ff8 <ota_package_parse_req+0x14>)
{
    6fe6:	b510      	push	{r4, lr}
    package_parse_finish_callback = callback;
    6fe8:	6018      	str	r0, [r3, #0]
    if (neul_update_package_parse_req() != NEUL_RET_OK)
    6fea:	f000 fbf5 	bl	77d8 <neul_update_package_parse_req>
    return NEUL_UPDATE_RET_OK;
    6fee:	1e43      	subs	r3, r0, #1
    6ff0:	4198      	sbcs	r0, r3
    6ff2:	0080      	lsls	r0, r0, #2
}
    6ff4:	bd10      	pop	{r4, pc}
    6ff6:	46c0      	nop			; (mov r8, r8)
    6ff8:	0100159c 	.word	0x0100159c

00006ffc <ota_get_package_info_req>:
    get_package_info_cnf_callback = callback;
    6ffc:	4b09      	ldr	r3, [pc, #36]	; (7024 <ota_get_package_info_req+0x28>)
{
    6ffe:	b510      	push	{r4, lr}
    get_package_info_cnf_callback = callback;
    7000:	6018      	str	r0, [r3, #0]
    get_package_info_buff_callback = get_buff;
    7002:	4b09      	ldr	r3, [pc, #36]	; (7028 <ota_get_package_info_req+0x2c>)
    7004:	6019      	str	r1, [r3, #0]
    switch (type)
    7006:	2a00      	cmp	r2, #0
    7008:	d003      	beq.n	7012 <ota_get_package_info_req+0x16>
    700a:	2a01      	cmp	r2, #1
    700c:	d007      	beq.n	701e <ota_get_package_info_req+0x22>
            return NEUL_UPDATE_RET_ERROR;
    700e:	2004      	movs	r0, #4
    7010:	e004      	b.n	701c <ota_get_package_info_req+0x20>
            result = neul_update_package_get_package_name_req();
    7012:	f000 fbed 	bl	77f0 <neul_update_package_get_package_name_req>
    return NEUL_UPDATE_RET_OK;
    7016:	1e43      	subs	r3, r0, #1
    7018:	4198      	sbcs	r0, r3
    701a:	0080      	lsls	r0, r0, #2
}
    701c:	bd10      	pop	{r4, pc}
            result = neul_update_package_get_package_version_req();
    701e:	f000 fbf3 	bl	7808 <neul_update_package_get_package_version_req>
            break;
    7022:	e7f8      	b.n	7016 <ota_get_package_info_req+0x1a>
    7024:	01001598 	.word	0x01001598
    7028:	01001594 	.word	0x01001594

0000702c <set_update_method>:

    return true;
}

bool set_update_method(uint8 update_method)
{
    702c:	b507      	push	{r0, r1, r2, lr}
    702e:	466b      	mov	r3, sp
    7030:	1dd9      	adds	r1, r3, #7
    7032:	7008      	strb	r0, [r1, #0]
    if (neul_kv_set(OTA_KEYID_UPDATE_MODE, (uint8*)(&update_method), sizeof(uint8)) != NEUL_RET_OK)
    7034:	2201      	movs	r2, #1
    7036:	4803      	ldr	r0, [pc, #12]	; (7044 <set_update_method+0x18>)
    7038:	f000 fab6 	bl	75a8 <neul_kv_set>
    703c:	4243      	negs	r3, r0
    703e:	4158      	adcs	r0, r3
    {
        return false;
    }
    return true;
}
    7040:	b2c0      	uxtb	r0, r0
    7042:	bd0e      	pop	{r1, r2, r3, pc}
    7044:	00001403 	.word	0x00001403

00007048 <ota_init>:
    (void) neul_update_register_package_get_package_version_cnf_callback((NEUL_UPDATE_GET_PACKAGE_VERSION) update_package_get_package_version_cnf);
}


void ota_init(void)
{
    7048:	b510      	push	{r4, lr}
    (void) neul_update_register_package_parse_cnf_callback((NEUL_UPDATE_PACKAGE_PARSE_CNF) update_package_parse_cnf);
    704a:	4807      	ldr	r0, [pc, #28]	; (7068 <ota_init+0x20>)
    704c:	f000 fc04 	bl	7858 <neul_update_register_package_parse_cnf_callback>
    (void) neul_update_register_package_process_cnf_callback((NEUL_UPDATE_PACKAGE_PROCESS_CNF) update_package_process_cnf);
    7050:	4806      	ldr	r0, [pc, #24]	; (706c <ota_init+0x24>)
    7052:	f000 fc07 	bl	7864 <neul_update_register_package_process_cnf_callback>
    (void) neul_update_register_package_get_package_name_cnf_callback((NEUL_UPDATE_GET_PACKAGE_NAME) update_package_get_package_name_cnf);
    7056:	4806      	ldr	r0, [pc, #24]	; (7070 <ota_init+0x28>)
    7058:	f000 fc0a 	bl	7870 <neul_update_register_package_get_package_name_cnf_callback>
    (void) neul_update_register_package_get_package_version_cnf_callback((NEUL_UPDATE_GET_PACKAGE_VERSION) update_package_get_package_version_cnf);
    705c:	4805      	ldr	r0, [pc, #20]	; (7074 <ota_init+0x2c>)
    705e:	f000 fc0d 	bl	787c <neul_update_register_package_get_package_version_cnf_callback>
    ota_register_callback();
    ota_iflash_register_callback();
    7062:	f000 f8b7 	bl	71d4 <ota_iflash_register_callback>
}
    7066:	bd10      	pop	{r4, pc}
    7068:	00006f4d 	.word	0x00006f4d
    706c:	00006f65 	.word	0x00006f65
    7070:	00006fc1 	.word	0x00006fc1
    7074:	00006fc9 	.word	0x00006fc9

00007078 <update_package_flash_write_done>:

    return;
}

static void update_package_flash_write_done(uint8 result)
{
    7078:	b510      	push	{r4, lr}
    log_uart_update_watermark_level(LOG_MEMORY_REGION_SECTION_1, LOG_UART_PROTOCOL_LOG_WATERMARK_VALUE_ON_INIT);
    707a:	2100      	movs	r1, #0
{
    707c:	0004      	movs	r4, r0
    log_uart_update_watermark_level(LOG_MEMORY_REGION_SECTION_1, LOG_UART_PROTOCOL_LOG_WATERMARK_VALUE_ON_INIT);
    707e:	2001      	movs	r0, #1
    7080:	f7ff fcd6 	bl	6a30 <log_uart_update_watermark_level>
    if (flash_write_callback != NULL)
    7084:	4b03      	ldr	r3, [pc, #12]	; (7094 <update_package_flash_write_done+0x1c>)
    7086:	681b      	ldr	r3, [r3, #0]
    7088:	2b00      	cmp	r3, #0
    708a:	d001      	beq.n	7090 <update_package_flash_write_done+0x18>
    {
        (*flash_write_callback)(result);
    708c:	0020      	movs	r0, r4
    708e:	4798      	blx	r3
    }

    return;
}
    7090:	bd10      	pop	{r4, pc}
    7092:	46c0      	nop			; (mov r8, r8)
    7094:	010015ac 	.word	0x010015ac

00007098 <update_package_flash_erase_done>:
    flash_erased_ok = result;
    7098:	4b06      	ldr	r3, [pc, #24]	; (70b4 <update_package_flash_erase_done+0x1c>)
{
    709a:	b510      	push	{r4, lr}
    flash_erased_ok = result;
    709c:	7018      	strb	r0, [r3, #0]
    if(!flash_erased_ok)
    709e:	2800      	cmp	r0, #0
    70a0:	d102      	bne.n	70a8 <update_package_flash_erase_done+0x10>
        flog_set_write_enable(true);
    70a2:	3001      	adds	r0, #1
    70a4:	f7ff fbfe 	bl	68a4 <flog_set_write_enable>
    if (flash_erase_callback != NULL)
    70a8:	4b03      	ldr	r3, [pc, #12]	; (70b8 <update_package_flash_erase_done+0x20>)
    70aa:	681b      	ldr	r3, [r3, #0]
    70ac:	2b00      	cmp	r3, #0
    70ae:	d000      	beq.n	70b2 <update_package_flash_erase_done+0x1a>
        (*flash_erase_callback)();
    70b0:	4798      	blx	r3
}
    70b2:	bd10      	pop	{r4, pc}
    70b4:	010015a8 	.word	0x010015a8
    70b8:	010015a4 	.word	0x010015a4

000070bc <ota_iflash_write>:
{
    70bc:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
    70be:	001e      	movs	r6, r3
    bool write_queued = false;
    70c0:	466b      	mov	r3, sp
{
    70c2:	0007      	movs	r7, r0
    bool write_queued = false;
    70c4:	1ddc      	adds	r4, r3, #7
    70c6:	2300      	movs	r3, #0
    flash_write_callback = NULL;
    70c8:	4d09      	ldr	r5, [pc, #36]	; (70f0 <ota_iflash_write+0x34>)
{
    70ca:	0010      	movs	r0, r2
    bool write_queued = false;
    70cc:	7023      	strb	r3, [r4, #0]
    (void)neul_update_package_flash_write((uint32)length, (uint32)buffer, offset, &write_queued);
    70ce:	000a      	movs	r2, r1
    flash_write_callback = NULL;
    70d0:	602b      	str	r3, [r5, #0]
    (void)neul_update_package_flash_write((uint32)length, (uint32)buffer, offset, &write_queued);
    70d2:	0039      	movs	r1, r7
    70d4:	0023      	movs	r3, r4
    70d6:	f000 fba3 	bl	7820 <neul_update_package_flash_write>
    log_uart_update_watermark_level(LOG_MEMORY_REGION_SECTION_1, LOG_UART_PROTOCOL_LOG_WATERMARK_VALUE_HIGH);
    70da:	2180      	movs	r1, #128	; 0x80
    70dc:	2001      	movs	r0, #1
    70de:	0189      	lsls	r1, r1, #6
    70e0:	f7ff fca6 	bl	6a30 <log_uart_update_watermark_level>
    if (write_queued)
    70e4:	7820      	ldrb	r0, [r4, #0]
    70e6:	2800      	cmp	r0, #0
    70e8:	d000      	beq.n	70ec <ota_iflash_write+0x30>
        flash_write_callback = done_callback;
    70ea:	602e      	str	r6, [r5, #0]
}
    70ec:	bdfe      	pop	{r1, r2, r3, r4, r5, r6, r7, pc}
    70ee:	46c0      	nop			; (mov r8, r8)
    70f0:	010015ac 	.word	0x010015ac

000070f4 <ota_iflash_erase>:
{
    70f4:	b573      	push	{r0, r1, r4, r5, r6, lr}
    bool erase_queued = false;
    70f6:	466b      	mov	r3, sp
    70f8:	1ddc      	adds	r4, r3, #7
    70fa:	2300      	movs	r3, #0
    flash_erased_ok = false;
    70fc:	4a06      	ldr	r2, [pc, #24]	; (7118 <ota_iflash_erase+0x24>)
    flash_erase_callback = NULL;
    70fe:	4d07      	ldr	r5, [pc, #28]	; (711c <ota_iflash_erase+0x28>)
{
    7100:	0006      	movs	r6, r0
    (void)neul_update_package_flash_erase(&erase_queued);
    7102:	0020      	movs	r0, r4
    bool erase_queued = false;
    7104:	7023      	strb	r3, [r4, #0]
    flash_erased_ok = false;
    7106:	7013      	strb	r3, [r2, #0]
    flash_erase_callback = NULL;
    7108:	602b      	str	r3, [r5, #0]
    (void)neul_update_package_flash_erase(&erase_queued);
    710a:	f000 fb90 	bl	782e <neul_update_package_flash_erase>
    if (erase_queued)
    710e:	7820      	ldrb	r0, [r4, #0]
    7110:	2800      	cmp	r0, #0
    7112:	d000      	beq.n	7116 <ota_iflash_erase+0x22>
        flash_erase_callback = erase_callback;
    7114:	602e      	str	r6, [r5, #0]
}
    7116:	bd76      	pop	{r1, r2, r4, r5, r6, pc}
    7118:	010015a8 	.word	0x010015a8
    711c:	010015a4 	.word	0x010015a4

00007120 <initialise_fota>:
{
    7120:	b513      	push	{r0, r1, r4, lr}
    bool allocated = false;
    7122:	466b      	mov	r3, sp
    (void)neul_update_package_allocate_flash(update_package_size, &allocated);
    7124:	2001      	movs	r0, #1
    bool allocated = false;
    7126:	1ddc      	adds	r4, r3, #7
    7128:	2300      	movs	r3, #0
    (void)neul_update_package_allocate_flash(update_package_size, &allocated);
    712a:	0021      	movs	r1, r4
    712c:	4240      	negs	r0, r0
    bool allocated = false;
    712e:	7023      	strb	r3, [r4, #0]
    (void)neul_update_package_allocate_flash(update_package_size, &allocated);
    7130:	f000 fb84 	bl	783c <neul_update_package_allocate_flash>
    return allocated;
    7134:	7820      	ldrb	r0, [r4, #0]
}
    7136:	bd16      	pop	{r1, r2, r4, pc}

00007138 <ota_package_init>:

NEUL_UPDATE_RET ota_package_init(OTA_FLASH_ERASE_DONE_CB callback)
{
    7138:	b510      	push	{r4, lr}
    713a:	0004      	movs	r4, r0
    if (!initialise_fota())
    713c:	f7ff fff0 	bl	7120 <initialise_fota>
    {
        return NEUL_UPDATE_RET_ERROR;
    7140:	2304      	movs	r3, #4
    if (!initialise_fota())
    7142:	2800      	cmp	r0, #0
    7144:	d00c      	beq.n	7160 <ota_package_init+0x28>
    }

    flog_set_write_enable(false);
    7146:	2000      	movs	r0, #0
    7148:	f7ff fbac 	bl	68a4 <flog_set_write_enable>
    if (!ota_iflash_erase(callback))
    714c:	0020      	movs	r0, r4
    714e:	f7ff ffd1 	bl	70f4 <ota_iflash_erase>
    {
        flog_set_write_enable(true);
        return NEUL_UPDATE_RET_ERROR;
    }

    return NEUL_UPDATE_RET_OK;
    7152:	2300      	movs	r3, #0
    if (!ota_iflash_erase(callback))
    7154:	4298      	cmp	r0, r3
    7156:	d103      	bne.n	7160 <ota_package_init+0x28>
        flog_set_write_enable(true);
    7158:	2001      	movs	r0, #1
    715a:	f7ff fba3 	bl	68a4 <flog_set_write_enable>
        return NEUL_UPDATE_RET_ERROR;
    715e:	2304      	movs	r3, #4
}
    7160:	0018      	movs	r0, r3
    7162:	bd10      	pop	{r4, pc}

00007164 <ota_check_flash_erased_result>:

bool ota_check_flash_erased_result(void)
{
    return flash_erased_ok;
    7164:	4b01      	ldr	r3, [pc, #4]	; (716c <ota_check_flash_erased_result+0x8>)
    7166:	7818      	ldrb	r0, [r3, #0]
}
    7168:	4770      	bx	lr
    716a:	46c0      	nop			; (mov r8, r8)
    716c:	010015a8 	.word	0x010015a8

00007170 <ota_package_download>:

NEUL_UPDATE_RET ota_package_download(uint32 offset, const uint8 * buff, uint16 len, OTA_FLASH_WRITE_DONE_CB callback)
{
    7170:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
    7172:	0005      	movs	r5, r0
    7174:	000f      	movs	r7, r1
    7176:	1e14      	subs	r4, r2, #0
    7178:	9301      	str	r3, [sp, #4]
    if (len == 0)
    717a:	d104      	bne.n	7186 <ota_package_download+0x16>
    {
        flog_set_write_enable(true);
    717c:	2001      	movs	r0, #1
    717e:	f7ff fb91 	bl	68a4 <flog_set_write_enable>
        return NEUL_UPDATE_RET_ERROR;
    7182:	2004      	movs	r0, #4
        flog_set_write_enable(true);
        return NEUL_UPDATE_RET_ERROR;
    }

    return NEUL_UPDATE_RET_OK;
}
    7184:	bdfe      	pop	{r1, r2, r3, r4, r5, r6, r7, pc}
    assert((offset + len) > offset);
    7186:	1813      	adds	r3, r2, r0
    7188:	4283      	cmp	r3, r0
    718a:	d803      	bhi.n	7194 <ota_package_download+0x24>
    718c:	4671      	mov	r1, lr
    718e:	2016      	movs	r0, #22
    7190:	f7fa fcbe 	bl	1b10 <panic>
    if ((buff == NULL) || (len > OTA_PACKAGE_BUFF_SIZE) || ((len % 4) != 0) || ((offset % 4) != 0))
    7194:	2f00      	cmp	r7, #0
    7196:	d0f1      	beq.n	717c <ota_package_download+0xc>
    7198:	2380      	movs	r3, #128	; 0x80
    719a:	009b      	lsls	r3, r3, #2
    719c:	429c      	cmp	r4, r3
    719e:	d8ed      	bhi.n	717c <ota_package_download+0xc>
    71a0:	2003      	movs	r0, #3
    71a2:	4204      	tst	r4, r0
    71a4:	d1ea      	bne.n	717c <ota_package_download+0xc>
    71a6:	4028      	ands	r0, r5
    71a8:	9000      	str	r0, [sp, #0]
    71aa:	d1e7      	bne.n	717c <ota_package_download+0xc>
    memcpy(ota_package_buff, buff, len);
    71ac:	4e07      	ldr	r6, [pc, #28]	; (71cc <ota_package_download+0x5c>)
    71ae:	0022      	movs	r2, r4
    71b0:	0039      	movs	r1, r7
    71b2:	0030      	movs	r0, r6
    71b4:	f7f9 f81c 	bl	1f0 <memcpy>
    if (! ota_iflash_write(ota_package_buff, offset, len, callback))
    71b8:	9b01      	ldr	r3, [sp, #4]
    71ba:	0022      	movs	r2, r4
    71bc:	0029      	movs	r1, r5
    71be:	0030      	movs	r0, r6
    71c0:	f7ff ff7c 	bl	70bc <ota_iflash_write>
    71c4:	2800      	cmp	r0, #0
    71c6:	d0d9      	beq.n	717c <ota_package_download+0xc>
    return NEUL_UPDATE_RET_OK;
    71c8:	9800      	ldr	r0, [sp, #0]
    71ca:	e7db      	b.n	7184 <ota_package_download+0x14>
    71cc:	010015b0 	.word	0x010015b0

000071d0 <ota_poll>:

void ota_poll(void)
{}
    71d0:	4770      	bx	lr
	...

000071d4 <ota_iflash_register_callback>:

void ota_iflash_register_callback(void)
{
    71d4:	b510      	push	{r4, lr}
    (void) neul_update_register_flash_erase_done_callback((NEUL_UPDATE_FLASH_ERASE_DONE) update_package_flash_erase_done);
    71d6:	4803      	ldr	r0, [pc, #12]	; (71e4 <ota_iflash_register_callback+0x10>)
    71d8:	f000 fb38 	bl	784c <neul_update_register_flash_erase_done_callback>
    (void) neul_update_register_flash_write_done_callback((NEUL_UPDATE_FLASH_WRITE_DONE) update_package_flash_write_done);
    71dc:	4802      	ldr	r0, [pc, #8]	; (71e8 <ota_iflash_register_callback+0x14>)
    71de:	f000 fb53 	bl	7888 <neul_update_register_flash_write_done_callback>

}
    71e2:	bd10      	pop	{r4, pc}
    71e4:	00007099 	.word	0x00007099
    71e8:	00007079 	.word	0x00007079

000071ec <neul_kv_find_key_location_in_cache>:
}


static kv_cache_node_t *neul_kv_find_key_location_in_cache(neul_kv_key key, const kv_cache_node_root *cache)
{
    kv_cache_node_t *here = cache->kv_cache;
    71ec:	680b      	ldr	r3, [r1, #0]

    while(here != NULL)
    71ee:	2b00      	cmp	r3, #0
    71f0:	d101      	bne.n	71f6 <neul_kv_find_key_location_in_cache+0xa>
            return here;
        }
        here = here->next;
    }
    return here;
}
    71f2:	0018      	movs	r0, r3
    71f4:	4770      	bx	lr
        if (here->key == key)
    71f6:	891a      	ldrh	r2, [r3, #8]
    71f8:	4282      	cmp	r2, r0
    71fa:	d0fa      	beq.n	71f2 <neul_kv_find_key_location_in_cache+0x6>
        here = here->next;
    71fc:	681b      	ldr	r3, [r3, #0]
    71fe:	e7f6      	b.n	71ee <neul_kv_find_key_location_in_cache+0x2>

00007200 <kv_empty_cache>:
{
    7200:	b570      	push	{r4, r5, r6, lr}
    7202:	0005      	movs	r5, r0
    here = cache->kv_cache;
    7204:	6804      	ldr	r4, [r0, #0]
    while(here != NULL)
    7206:	2c00      	cmp	r4, #0
    7208:	d102      	bne.n	7210 <kv_empty_cache+0x10>
    cache->kv_cache = NULL;
    720a:	602c      	str	r4, [r5, #0]
    cache->kv_security_locked = KV_SECURITY_STATE_UNLOCKED;
    720c:	60ac      	str	r4, [r5, #8]
}
    720e:	bd70      	pop	{r4, r5, r6, pc}
        if (here->kvalue != NULL)
    7210:	6860      	ldr	r0, [r4, #4]
        next = here->next;
    7212:	6826      	ldr	r6, [r4, #0]
        if (here->kvalue != NULL)
    7214:	2800      	cmp	r0, #0
    7216:	d001      	beq.n	721c <kv_empty_cache+0x1c>
            irfree(here->kvalue);
    7218:	f00b fc0e 	bl	12a38 <irfree>
        irfree(here);
    721c:	0020      	movs	r0, r4
    721e:	f00b fc0b 	bl	12a38 <irfree>
        here = next;
    7222:	0034      	movs	r4, r6
    7224:	e7ef      	b.n	7206 <kv_empty_cache+0x6>
	...

00007228 <set_cache_operation_in_progress>:
{
    7228:	4673      	mov	r3, lr
    722a:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
    if (osMutexAcquire(kv_cache_mutex, osWaitForever) != osOK)
    722c:	2101      	movs	r1, #1
    722e:	9301      	str	r3, [sp, #4]
    7230:	4b2c      	ldr	r3, [pc, #176]	; (72e4 <set_cache_operation_in_progress+0xbc>)
    7232:	4249      	negs	r1, r1
    7234:	6818      	ldr	r0, [r3, #0]
    7236:	f00d fbb5 	bl	149a4 <osMutexAcquire>
    723a:	2800      	cmp	r0, #0
    723c:	d003      	beq.n	7246 <set_cache_operation_in_progress+0x1e>
        assert(false);
    723e:	9901      	ldr	r1, [sp, #4]
    7240:	2016      	movs	r0, #22
    7242:	f7fa fc65 	bl	1b10 <panic>
       kv_cache_root_primary->kv_clean = NEUL_KV_CLEAN;
    7246:	2301      	movs	r3, #1
    7248:	4c27      	ldr	r4, [pc, #156]	; (72e8 <set_cache_operation_in_progress+0xc0>)
    724a:	6820      	ldr	r0, [r4, #0]
    724c:	7303      	strb	r3, [r0, #12]
    if (kv_cache_root_primary->kv_security_locked != KV_SECURITY_STATE_UNLOCKED) // locked or flushed
    724e:	6883      	ldr	r3, [r0, #8]
    7250:	2b00      	cmp	r3, #0
    7252:	d022      	beq.n	729a <set_cache_operation_in_progress+0x72>
    if ((kv_cache_root_primary->kv_security_locked == KV_SECURITY_STATE_FLUSHED) || (kv_cache_root_primary->kv_security_locked == KV_SECURITY_STATE_ERROR))
    7254:	6883      	ldr	r3, [r0, #8]
    7256:	2b02      	cmp	r3, #2
    7258:	d002      	beq.n	7260 <set_cache_operation_in_progress+0x38>
    725a:	6883      	ldr	r3, [r0, #8]
    725c:	2b03      	cmp	r3, #3
    725e:	d101      	bne.n	7264 <set_cache_operation_in_progress+0x3c>
        kv_empty_cache(kv_cache_root_primary);
    7260:	f7ff ffce 	bl	7200 <kv_empty_cache>
    if ((kv_cache_root_secondary->kv_security_locked == KV_SECURITY_STATE_FLUSHED) || (kv_cache_root_secondary->kv_security_locked == KV_SECURITY_STATE_ERROR))
    7264:	4f21      	ldr	r7, [pc, #132]	; (72ec <set_cache_operation_in_progress+0xc4>)
    7266:	6838      	ldr	r0, [r7, #0]
    7268:	6883      	ldr	r3, [r0, #8]
    726a:	2b02      	cmp	r3, #2
    726c:	d002      	beq.n	7274 <set_cache_operation_in_progress+0x4c>
    726e:	6883      	ldr	r3, [r0, #8]
    7270:	2b03      	cmp	r3, #3
    7272:	d101      	bne.n	7278 <set_cache_operation_in_progress+0x50>
        kv_empty_cache(kv_cache_root_secondary);
    7274:	f7ff ffc4 	bl	7200 <kv_empty_cache>
    if (kv_cache_root_primary == (&kv_cache_root_a))
    7278:	6823      	ldr	r3, [r4, #0]
    727a:	4e1d      	ldr	r6, [pc, #116]	; (72f0 <set_cache_operation_in_progress+0xc8>)
    727c:	4d1d      	ldr	r5, [pc, #116]	; (72f4 <set_cache_operation_in_progress+0xcc>)
    727e:	42b3      	cmp	r3, r6
    7280:	d11c      	bne.n	72bc <set_cache_operation_in_progress+0x94>
        assert(kv_cache_root_b.kv_security_locked == KV_SECURITY_STATE_UNLOCKED);
    7282:	68ab      	ldr	r3, [r5, #8]
    7284:	2b00      	cmp	r3, #0
    7286:	d003      	beq.n	7290 <set_cache_operation_in_progress+0x68>
    7288:	9901      	ldr	r1, [sp, #4]
    728a:	2016      	movs	r0, #22
    728c:	f7fa fc40 	bl	1b10 <panic>
        kv_cache_base.primary = KV_CACHE_B;
    7290:	2202      	movs	r2, #2
    7292:	4b19      	ldr	r3, [pc, #100]	; (72f8 <set_cache_operation_in_progress+0xd0>)
        kv_cache_root_primary = &kv_cache_root_b;
    7294:	6025      	str	r5, [r4, #0]
        kv_cache_root_secondary = &kv_cache_root_a;
    7296:	603e      	str	r6, [r7, #0]
        kv_cache_base.primary = KV_CACHE_A;
    7298:	711a      	strb	r2, [r3, #4]
       kv_cache_root_primary->kv_clean = NEUL_KV_UNCLEAN;
    729a:	2200      	movs	r2, #0
    729c:	6823      	ldr	r3, [r4, #0]
    729e:	731a      	strb	r2, [r3, #12]
   while(kv_cache_root_primary->kv_security_locked != KV_SECURITY_STATE_UNLOCKED);
    72a0:	689b      	ldr	r3, [r3, #8]
    72a2:	4293      	cmp	r3, r2
    72a4:	d1cf      	bne.n	7246 <set_cache_operation_in_progress+0x1e>
   if ((kv_cache_root_secondary->kv_security_locked == KV_SECURITY_STATE_FLUSHED) || (kv_cache_root_secondary->kv_security_locked == KV_SECURITY_STATE_ERROR))
    72a6:	4b11      	ldr	r3, [pc, #68]	; (72ec <set_cache_operation_in_progress+0xc4>)
    72a8:	6818      	ldr	r0, [r3, #0]
    72aa:	6883      	ldr	r3, [r0, #8]
    72ac:	2b02      	cmp	r3, #2
    72ae:	d002      	beq.n	72b6 <set_cache_operation_in_progress+0x8e>
    72b0:	6883      	ldr	r3, [r0, #8]
    72b2:	2b03      	cmp	r3, #3
    72b4:	d101      	bne.n	72ba <set_cache_operation_in_progress+0x92>
       kv_empty_cache(kv_cache_root_secondary);
    72b6:	f7ff ffa3 	bl	7200 <kv_empty_cache>
} //lint !e454
    72ba:	bdf7      	pop	{r0, r1, r2, r4, r5, r6, r7, pc}
    else if (kv_cache_root_primary == (&kv_cache_root_b))
    72bc:	42ab      	cmp	r3, r5
    72be:	d10b      	bne.n	72d8 <set_cache_operation_in_progress+0xb0>
        assert(kv_cache_root_a.kv_security_locked == KV_SECURITY_STATE_UNLOCKED);
    72c0:	68b3      	ldr	r3, [r6, #8]
    72c2:	2b00      	cmp	r3, #0
    72c4:	d003      	beq.n	72ce <set_cache_operation_in_progress+0xa6>
    72c6:	9901      	ldr	r1, [sp, #4]
    72c8:	2016      	movs	r0, #22
    72ca:	f7fa fc21 	bl	1b10 <panic>
        kv_cache_root_primary = &kv_cache_root_a;
    72ce:	6026      	str	r6, [r4, #0]
        kv_cache_root_secondary = &kv_cache_root_b;
    72d0:	603d      	str	r5, [r7, #0]
        kv_cache_base.primary = KV_CACHE_A;
    72d2:	4b09      	ldr	r3, [pc, #36]	; (72f8 <set_cache_operation_in_progress+0xd0>)
    72d4:	2201      	movs	r2, #1
    72d6:	e7df      	b.n	7298 <set_cache_operation_in_progress+0x70>
        assert(false);
    72d8:	9901      	ldr	r1, [sp, #4]
    72da:	2016      	movs	r0, #22
    72dc:	f7fa fc18 	bl	1b10 <panic>
    72e0:	e7db      	b.n	729a <set_cache_operation_in_progress+0x72>
    72e2:	46c0      	nop			; (mov r8, r8)
    72e4:	010017c0 	.word	0x010017c0
    72e8:	010017e4 	.word	0x010017e4
    72ec:	010017e8 	.word	0x010017e8
    72f0:	010017c4 	.word	0x010017c4
    72f4:	010017d4 	.word	0x010017d4
    72f8:	010017b0 	.word	0x010017b0

000072fc <add_kv_cache_key_by_type>:

    return true;
}

static NEUL_RET add_kv_cache_key_by_type(neul_kv_key key, const uint8 *kvalue, uint16 kvalue_length, bool permanent, kv_cache_node_root *cache_root_primary)
{
    72fc:	b5f0      	push	{r4, r5, r6, r7, lr}
    72fe:	0017      	movs	r7, r2
    7300:	b085      	sub	sp, #20
    kv_cache_node_t *new_node;

    kv_cache_node_t **here;
    here = &(cache_root_primary->kv_cache);
    7302:	9d0a      	ldr	r5, [sp, #40]	; 0x28
{
    7304:	9002      	str	r0, [sp, #8]
    here = &(cache_root_primary->kv_cache);
    7306:	682c      	ldr	r4, [r5, #0]
{
    7308:	9101      	str	r1, [sp, #4]
    730a:	9303      	str	r3, [sp, #12]
    /*
     * If this key is already in the cache, use the new key and delete the
     * old key. The same key can be set with different kvalue_length. If the
     * key is the same re-use malloc'd space.
     */
    while(*here != NULL)
    730c:	2c00      	cmp	r4, #0
    730e:	d110      	bne.n	7332 <add_kv_cache_key_by_type+0x36>
       // Move to next entry;
       here = &(*here)->next;
    }

    // New keys added to end of linked list
    new_node = (kv_cache_node_t *) irmalloc(sizeof(kv_cache_node_t));
    7310:	2010      	movs	r0, #16
    7312:	f00b fb75 	bl	12a00 <irmalloc>
    7316:	0006      	movs	r6, r0
    if (new_node == NULL)
    {
        return NEUL_RET_MEMORY_ERROR;
    7318:	200d      	movs	r0, #13
    if (new_node == NULL)
    731a:	2e00      	cmp	r6, #0
    731c:	d01c      	beq.n	7358 <add_kv_cache_key_by_type+0x5c>
    }

    new_node->kvalue = (uint8 *) irmalloc(sizeof(uint8)*kvalue_length);
    731e:	0038      	movs	r0, r7
    7320:	f00b fb6e 	bl	12a00 <irmalloc>
    7324:	6070      	str	r0, [r6, #4]
    if (new_node->kvalue == NULL)
    7326:	2800      	cmp	r0, #0
    7328:	d134      	bne.n	7394 <add_kv_cache_key_by_type+0x98>
    {
        irfree(new_node);
    732a:	0030      	movs	r0, r6
    732c:	f00b fb84 	bl	12a38 <irfree>
    7330:	e024      	b.n	737c <add_kv_cache_key_by_type+0x80>
       if ((*here)->key == key)
    7332:	8923      	ldrh	r3, [r4, #8]
    7334:	9a02      	ldr	r2, [sp, #8]
    7336:	4293      	cmp	r3, r2
    7338:	d129      	bne.n	738e <add_kv_cache_key_by_type+0x92>
           if ((*here)->permanent)
    733a:	7b66      	ldrb	r6, [r4, #13]
               return NEUL_RET_ILLEGAL_OPERATION;
    733c:	2004      	movs	r0, #4
           if ((*here)->permanent)
    733e:	2e00      	cmp	r6, #0
    7340:	d10a      	bne.n	7358 <add_kv_cache_key_by_type+0x5c>
           if ((*here)->kvalue_length == kvalue_length)
    7342:	8963      	ldrh	r3, [r4, #10]
    7344:	6860      	ldr	r0, [r4, #4]
    7346:	42bb      	cmp	r3, r7
    7348:	d108      	bne.n	735c <add_kv_cache_key_by_type+0x60>
               memcpy((*here)->kvalue, kvalue, kvalue_length);
    734a:	003a      	movs	r2, r7
    734c:	9901      	ldr	r1, [sp, #4]
    734e:	f7f8 ff4f 	bl	1f0 <memcpy>
               return NEUL_RET_OK;
    7352:	0030      	movs	r0, r6
               (*here)->erase = false;
    7354:	682b      	ldr	r3, [r5, #0]
    7356:	731e      	strb	r6, [r3, #12]
    new_node->erase=false;
    new_node->permanent=permanent;

    *here = new_node;
    return NEUL_RET_OK;
}
    7358:	b005      	add	sp, #20
    735a:	bdf0      	pop	{r4, r5, r6, r7, pc}
               irfree((*here)->kvalue);
    735c:	f00b fb6c 	bl	12a38 <irfree>
               (*here)->kvalue = (uint8 *)irmalloc(sizeof(uint8)*kvalue_length);
    7360:	0038      	movs	r0, r7
    7362:	682c      	ldr	r4, [r5, #0]
    7364:	f00b fb4c 	bl	12a00 <irmalloc>
    7368:	6060      	str	r0, [r4, #4]
               if ((*here)->kvalue == NULL)
    736a:	682b      	ldr	r3, [r5, #0]
    736c:	6858      	ldr	r0, [r3, #4]
    736e:	2800      	cmp	r0, #0
    7370:	d106      	bne.n	7380 <add_kv_cache_key_by_type+0x84>
                   tmp = (*here)->next;
    7372:	681c      	ldr	r4, [r3, #0]
                   irfree (*here);
    7374:	0018      	movs	r0, r3
    7376:	f00b fb5f 	bl	12a38 <irfree>
                   *here = tmp;
    737a:	602c      	str	r4, [r5, #0]
        return NEUL_RET_MEMORY_ERROR;
    737c:	200d      	movs	r0, #13
    737e:	e7eb      	b.n	7358 <add_kv_cache_key_by_type+0x5c>
               memcpy((*here)->kvalue, kvalue, kvalue_length);
    7380:	003a      	movs	r2, r7
    7382:	9901      	ldr	r1, [sp, #4]
    7384:	f7f8 ff34 	bl	1f0 <memcpy>
               (*here)->kvalue_length = kvalue_length;
    7388:	682b      	ldr	r3, [r5, #0]
    738a:	815f      	strh	r7, [r3, #10]
    738c:	e7e1      	b.n	7352 <add_kv_cache_key_by_type+0x56>
       here = &(*here)->next;
    738e:	0025      	movs	r5, r4
    7390:	6824      	ldr	r4, [r4, #0]
    7392:	e7bb      	b.n	730c <add_kv_cache_key_by_type+0x10>
    new_node->key = key;
    7394:	466b      	mov	r3, sp
    7396:	891b      	ldrh	r3, [r3, #8]
    new_node->kvalue_length = kvalue_length;
    7398:	8177      	strh	r7, [r6, #10]
    new_node->key = key;
    739a:	8133      	strh	r3, [r6, #8]
    memcpy(new_node->kvalue, kvalue, kvalue_length);
    739c:	003a      	movs	r2, r7
    739e:	9901      	ldr	r1, [sp, #4]
    73a0:	f7f8 ff26 	bl	1f0 <memcpy>
    new_node->permanent=permanent;
    73a4:	466b      	mov	r3, sp
    73a6:	7b1b      	ldrb	r3, [r3, #12]
    new_node->next = NULL;
    73a8:	6034      	str	r4, [r6, #0]
    new_node->erase=false;
    73aa:	7334      	strb	r4, [r6, #12]
    new_node->permanent=permanent;
    73ac:	7373      	strb	r3, [r6, #13]
    return NEUL_RET_OK;
    73ae:	0020      	movs	r0, r4
    *here = new_node;
    73b0:	602e      	str	r6, [r5, #0]
    return NEUL_RET_OK;
    73b2:	e7d1      	b.n	7358 <add_kv_cache_key_by_type+0x5c>

000073b4 <read_kv_cache_key>:
{
    73b4:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    73b6:	001f      	movs	r7, r3
    here = read_kv_key_from_cache(key, kv_cache_root_primary);
    73b8:	4b12      	ldr	r3, [pc, #72]	; (7404 <read_kv_cache_key+0x50>)
{
    73ba:	000d      	movs	r5, r1
    return neul_kv_find_key_location_in_cache(key, cache);
    73bc:	6819      	ldr	r1, [r3, #0]
{
    73be:	0006      	movs	r6, r0
    73c0:	0014      	movs	r4, r2
    return neul_kv_find_key_location_in_cache(key, cache);
    73c2:	f7ff ff13 	bl	71ec <neul_kv_find_key_location_in_cache>
    if (here == NULL)
    73c6:	2800      	cmp	r0, #0
    73c8:	d106      	bne.n	73d8 <read_kv_cache_key+0x24>
        here = read_kv_key_from_cache(key, kv_cache_root_secondary);
    73ca:	4b0f      	ldr	r3, [pc, #60]	; (7408 <read_kv_cache_key+0x54>)
    return neul_kv_find_key_location_in_cache(key, cache);
    73cc:	0030      	movs	r0, r6
    73ce:	6819      	ldr	r1, [r3, #0]
    73d0:	f7ff ff0c 	bl	71ec <neul_kv_find_key_location_in_cache>
            return false;
    73d4:	1e03      	subs	r3, r0, #0
        if (here == NULL)
    73d6:	d005      	beq.n	73e4 <read_kv_cache_key+0x30>
        else if (here->erase)
    73d8:	7b03      	ldrb	r3, [r0, #12]
    73da:	2b00      	cmp	r3, #0
    73dc:	d004      	beq.n	73e8 <read_kv_cache_key+0x34>
            *erased = true;
    73de:	2301      	movs	r3, #1
    73e0:	9a06      	ldr	r2, [sp, #24]
    73e2:	7013      	strb	r3, [r2, #0]
}
    73e4:	0018      	movs	r0, r3
    73e6:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    *kvalue_length = here->kvalue_length;
    73e8:	8942      	ldrh	r2, [r0, #10]
    73ea:	8022      	strh	r2, [r4, #0]
    memcpy(kvalue, here->kvalue, min(kvalue_max_length, *kvalue_length));
    73ec:	6841      	ldr	r1, [r0, #4]
    73ee:	42aa      	cmp	r2, r5
    73f0:	d900      	bls.n	73f4 <read_kv_cache_key+0x40>
    73f2:	002a      	movs	r2, r5
    73f4:	0038      	movs	r0, r7
    73f6:	f7f8 fefb 	bl	1f0 <memcpy>
    *erased = false;
    73fa:	2300      	movs	r3, #0
    73fc:	9a06      	ldr	r2, [sp, #24]
    73fe:	7013      	strb	r3, [r2, #0]
    return true;
    7400:	3301      	adds	r3, #1
    7402:	e7ef      	b.n	73e4 <read_kv_cache_key+0x30>
    7404:	010017e4 	.word	0x010017e4
    7408:	010017e8 	.word	0x010017e8

0000740c <set_cache_operation_clean>:
    kv_cache_root_primary->kv_clean = NEUL_KV_CLEAN;
    740c:	2201      	movs	r2, #1
{
    740e:	b510      	push	{r4, lr}
    kv_cache_root_primary->kv_clean = NEUL_KV_CLEAN;
    7410:	4b07      	ldr	r3, [pc, #28]	; (7430 <set_cache_operation_clean+0x24>)
    7412:	4674      	mov	r4, lr
    7414:	681b      	ldr	r3, [r3, #0]
    7416:	731a      	strb	r2, [r3, #12]
    if (osMutexRelease(kv_cache_mutex) != osOK) //lint !e455
    7418:	4b06      	ldr	r3, [pc, #24]	; (7434 <set_cache_operation_clean+0x28>)
    741a:	6818      	ldr	r0, [r3, #0]
    741c:	f00d fae6 	bl	149ec <osMutexRelease>
    7420:	2800      	cmp	r0, #0
    7422:	d003      	beq.n	742c <set_cache_operation_clean+0x20>
        assert(false);
    7424:	0021      	movs	r1, r4
    7426:	2016      	movs	r0, #22
    7428:	f7fa fb72 	bl	1b10 <panic>
}
    742c:	bd10      	pop	{r4, pc}
    742e:	46c0      	nop			; (mov r8, r8)
    7430:	010017e4 	.word	0x010017e4
    7434:	010017c0 	.word	0x010017c0

00007438 <neul_kv_queue_cache_for_write>:
{
    7438:	b513      	push	{r0, r1, r4, lr}
    rpc_ret_val = command_kv_queue_cache_for_write(&kv_cache_ret_code);
    743a:	466b      	mov	r3, sp
    743c:	1ddc      	adds	r4, r3, #7
    743e:	0020      	movs	r0, r4
    7440:	f7fe f8ed 	bl	561e <command_kv_queue_cache_for_write>
        return false;
    7444:	2300      	movs	r3, #0
    if ((rpc_ret_val != RPC_ERR_OK) || (kv_cache_ret_code != NEUL_RET_OK))
    7446:	4298      	cmp	r0, r3
    7448:	d103      	bne.n	7452 <neul_kv_queue_cache_for_write+0x1a>
    744a:	7823      	ldrb	r3, [r4, #0]
    744c:	4258      	negs	r0, r3
    744e:	4143      	adcs	r3, r0
    7450:	b2db      	uxtb	r3, r3
}
    7452:	0018      	movs	r0, r3
    7454:	bd16      	pop	{r1, r2, r4, pc}
	...

00007458 <neul_kv_find_key_for_writing>:
    *node = current;
    return ret_value;
}

static NEUL_RET neul_kv_find_key_for_writing(neul_kv_key key, kv_cache_node_t **node)
{
    7458:	b5f0      	push	{r4, r5, r6, r7, lr}
    return neul_kv_find_key_for_writing_common(false, key, node, kv_cache_root_primary, kv_cache_root_secondary);
    745a:	4b37      	ldr	r3, [pc, #220]	; (7538 <neul_kv_find_key_for_writing+0xe0>)
{
    745c:	b087      	sub	sp, #28
    return neul_kv_find_key_for_writing_common(false, key, node, kv_cache_root_primary, kv_cache_root_secondary);
    745e:	681c      	ldr	r4, [r3, #0]
{
    7460:	9103      	str	r1, [sp, #12]
    current = neul_kv_find_key_location_in_cache(key, primary);
    7462:	0021      	movs	r1, r4
{
    7464:	0005      	movs	r5, r0
    current = neul_kv_find_key_location_in_cache(key, primary);
    7466:	f7ff fec1 	bl	71ec <neul_kv_find_key_location_in_cache>
    746a:	0007      	movs	r7, r0
    NEUL_RET ret_value = NEUL_RET_OK;
    746c:	2000      	movs	r0, #0
    if (current == NULL)
    746e:	4287      	cmp	r7, r0
    7470:	d13a      	bne.n	74e8 <neul_kv_find_key_for_writing+0x90>
    return neul_kv_find_key_for_writing_common(false, key, node, kv_cache_root_primary, kv_cache_root_secondary);
    7472:	4b32      	ldr	r3, [pc, #200]	; (753c <neul_kv_find_key_for_writing+0xe4>)
        current = neul_kv_find_key_location_in_cache(key, secondary);
    7474:	0028      	movs	r0, r5
    7476:	6819      	ldr	r1, [r3, #0]
    7478:	f7ff feb8 	bl	71ec <neul_kv_find_key_location_in_cache>
    747c:	1e07      	subs	r7, r0, #0
        if (current == NULL)
    747e:	d150      	bne.n	7522 <neul_kv_find_key_for_writing+0xca>
    uint16 kvalue_length = 64;
    7480:	230e      	movs	r3, #14
    7482:	aa02      	add	r2, sp, #8
    7484:	189b      	adds	r3, r3, r2
    7486:	2240      	movs	r2, #64	; 0x40
    uint8 *kvalue = 0;
    7488:	0004      	movs	r4, r0
    uint16 kvalue_length = 64;
    748a:	801a      	strh	r2, [r3, #0]
    uint16 kvalue_max_length = 0;
    748c:	0003      	movs	r3, r0
    while (kvalue_length > kvalue_max_length)
    748e:	aa02      	add	r2, sp, #8
    7490:	89d6      	ldrh	r6, [r2, #14]
    7492:	429e      	cmp	r6, r3
    7494:	d811      	bhi.n	74ba <neul_kv_find_key_for_writing+0x62>
    kv_ret_val = add_kv_cache_key(key, kvalue, kvalue_length, permanent); //lint !e449 Lint has noticed that kvalue gets freed in the above loop
    7496:	230d      	movs	r3, #13
    7498:	189b      	adds	r3, r3, r2
    return(add_kv_cache_key_by_type( key, kvalue, kvalue_length, permanent, kv_cache_root_primary));
    749a:	4a27      	ldr	r2, [pc, #156]	; (7538 <neul_kv_find_key_for_writing+0xe0>)
    749c:	781b      	ldrb	r3, [r3, #0]
    749e:	6812      	ldr	r2, [r2, #0]
    74a0:	0021      	movs	r1, r4
    74a2:	9200      	str	r2, [sp, #0]
    74a4:	0028      	movs	r0, r5
    74a6:	0032      	movs	r2, r6
    74a8:	f7ff ff28 	bl	72fc <add_kv_cache_key_by_type>
    kv_ret_val = add_kv_cache_key(key, kvalue, kvalue_length, permanent); //lint !e449 Lint has noticed that kvalue gets freed in the above loop
    74ac:	ae05      	add	r6, sp, #20
    74ae:	7030      	strb	r0, [r6, #0]
    irfree(kvalue);
    74b0:	0020      	movs	r0, r4
    74b2:	f00b fac1 	bl	12a38 <irfree>
    return (NEUL_RET)kv_ret_val;
    74b6:	7830      	ldrb	r0, [r6, #0]
    74b8:	e022      	b.n	7500 <neul_kv_find_key_for_writing+0xa8>
        kvalue = (uint8 *)irmalloc(kvalue_max_length);
    74ba:	0030      	movs	r0, r6
    74bc:	f00b faa0 	bl	12a00 <irmalloc>
    74c0:	1e04      	subs	r4, r0, #0
        if (kvalue == NULL)
    74c2:	d036      	beq.n	7532 <neul_kv_find_key_for_writing+0xda>
        if ( command_kv_get(key, &kv_ret_val, kvalue_max_length, &kvalue_length, kvalue, &permanent)  != RPC_ERR_OK)
    74c4:	230d      	movs	r3, #13
    74c6:	aa02      	add	r2, sp, #8
    74c8:	189b      	adds	r3, r3, r2
    74ca:	9301      	str	r3, [sp, #4]
    74cc:	230e      	movs	r3, #14
    74ce:	9000      	str	r0, [sp, #0]
    74d0:	189b      	adds	r3, r3, r2
    74d2:	a905      	add	r1, sp, #20
    74d4:	0032      	movs	r2, r6
    74d6:	0028      	movs	r0, r5
    74d8:	f7fb ff07 	bl	32ea <command_kv_get>
    74dc:	2800      	cmp	r0, #0
    74de:	d006      	beq.n	74ee <neul_kv_find_key_for_writing+0x96>
            irfree(kvalue);
    74e0:	0020      	movs	r0, r4
    74e2:	f00b faa9 	bl	12a38 <irfree>
            return NEUL_RET_ERROR_RPC;
    74e6:	2002      	movs	r0, #2
    *node = current;
    74e8:	9b03      	ldr	r3, [sp, #12]
    74ea:	601f      	str	r7, [r3, #0]
    return neul_kv_find_key_for_writing_common(false, key, node, kv_cache_root_primary, kv_cache_root_secondary);
    74ec:	e00e      	b.n	750c <neul_kv_find_key_for_writing+0xb4>
        if (kv_ret_val != NEUL_RET_OK)
    74ee:	ab02      	add	r3, sp, #8
    74f0:	7b1b      	ldrb	r3, [r3, #12]
    74f2:	2b00      	cmp	r3, #0
    74f4:	d00c      	beq.n	7510 <neul_kv_find_key_for_writing+0xb8>
            irfree(kvalue); //cannot find key
    74f6:	0020      	movs	r0, r4
    74f8:	f00b fa9e 	bl	12a38 <irfree>
            return (NEUL_RET)kv_ret_val;
    74fc:	ab02      	add	r3, sp, #8
    74fe:	7b18      	ldrb	r0, [r3, #12]
            if (ret_value == NEUL_RET_OK)
    7500:	2800      	cmp	r0, #0
    7502:	d1f1      	bne.n	74e8 <neul_kv_find_key_for_writing+0x90>
                ret_value = neul_kv_find_key_for_writing(key, node);
    7504:	9903      	ldr	r1, [sp, #12]
    7506:	0028      	movs	r0, r5
    7508:	f7ff ffa6 	bl	7458 <neul_kv_find_key_for_writing>
}
    750c:	b007      	add	sp, #28
    750e:	bdf0      	pop	{r4, r5, r6, r7, pc}
        if (kvalue_length > kvalue_max_length)
    7510:	ab02      	add	r3, sp, #8
    7512:	89db      	ldrh	r3, [r3, #14]
    7514:	42b3      	cmp	r3, r6
    7516:	d902      	bls.n	751e <neul_kv_find_key_for_writing+0xc6>
            irfree(kvalue); //and go round the loop again
    7518:	0020      	movs	r0, r4
    751a:	f00b fa8d 	bl	12a38 <irfree>
{
    751e:	0033      	movs	r3, r6
    7520:	e7b5      	b.n	748e <neul_kv_find_key_for_writing+0x36>
    return(add_kv_cache_key_by_type( key, kvalue, kvalue_length, permanent, kv_cache_root_primary));
    7522:	7b43      	ldrb	r3, [r0, #13]
    7524:	8942      	ldrh	r2, [r0, #10]
    7526:	9400      	str	r4, [sp, #0]
    7528:	6841      	ldr	r1, [r0, #4]
    752a:	0028      	movs	r0, r5
    752c:	f7ff fee6 	bl	72fc <add_kv_cache_key_by_type>
    7530:	e7e6      	b.n	7500 <neul_kv_find_key_for_writing+0xa8>
            return NEUL_RET_MEMORY_ERROR;
    7532:	200d      	movs	r0, #13
    7534:	e7d8      	b.n	74e8 <neul_kv_find_key_for_writing+0x90>
    7536:	46c0      	nop			; (mov r8, r8)
    7538:	010017e4 	.word	0x010017e4
    753c:	010017e8 	.word	0x010017e8

00007540 <neul_kv_set_with_attributes>:
{
    7540:	b5f0      	push	{r4, r5, r6, r7, lr}
    7542:	001f      	movs	r7, r3
    kv_cache_node_t *existing_key = NULL;
    7544:	2300      	movs	r3, #0
{
    7546:	b087      	sub	sp, #28
    7548:	0005      	movs	r5, r0
    754a:	000e      	movs	r6, r1
    754c:	9203      	str	r2, [sp, #12]
    kv_cache_node_t *existing_key = NULL;
    754e:	9305      	str	r3, [sp, #20]
        return NEUL_RET_ERROR_IN_PARAMETERS;
    7550:	2403      	movs	r4, #3
    if( kvalue == NULL )
    7552:	4299      	cmp	r1, r3
    7554:	d014      	beq.n	7580 <neul_kv_set_with_attributes+0x40>
    set_cache_operation_in_progress();
    7556:	f7ff fe67 	bl	7228 <set_cache_operation_in_progress>
    kv_ret_val = neul_kv_find_key_for_writing(key, &existing_key);
    755a:	a905      	add	r1, sp, #20
    755c:	0028      	movs	r0, r5
    755e:	f7ff ff7b 	bl	7458 <neul_kv_find_key_for_writing>
    7562:	1e04      	subs	r4, r0, #0
    if ((kv_ret_val == NEUL_RET_OK) || (kv_ret_val == NEUL_RET_KEY_NOT_FOUND))
    7564:	d001      	beq.n	756a <neul_kv_set_with_attributes+0x2a>
    7566:	2807      	cmp	r0, #7
    7568:	d117      	bne.n	759a <neul_kv_set_with_attributes+0x5a>
        if (existing_key != NULL)
    756a:	9b05      	ldr	r3, [sp, #20]
    756c:	2b00      	cmp	r3, #0
    756e:	d00a      	beq.n	7586 <neul_kv_set_with_attributes+0x46>
            if (existing_key->permanent)
    7570:	7b5b      	ldrb	r3, [r3, #13]
    7572:	2b00      	cmp	r3, #0
    7574:	d007      	beq.n	7586 <neul_kv_set_with_attributes+0x46>
                set_cache_operation_clean();
    7576:	f7ff ff49 	bl	740c <set_cache_operation_clean>
                return NEUL_RET_ILLEGAL_OPERATION;
    757a:	2404      	movs	r4, #4
                (void)neul_kv_queue_cache_for_write();
    757c:	f7ff ff5c 	bl	7438 <neul_kv_queue_cache_for_write>
}
    7580:	0020      	movs	r0, r4
    7582:	b007      	add	sp, #28
    7584:	bdf0      	pop	{r4, r5, r6, r7, pc}
    return(add_kv_cache_key_by_type( key, kvalue, kvalue_length, permanent, kv_cache_root_primary));
    7586:	4b07      	ldr	r3, [pc, #28]	; (75a4 <neul_kv_set_with_attributes+0x64>)
    7588:	9a03      	ldr	r2, [sp, #12]
    758a:	681b      	ldr	r3, [r3, #0]
    758c:	0031      	movs	r1, r6
    758e:	9300      	str	r3, [sp, #0]
    7590:	0028      	movs	r0, r5
    7592:	003b      	movs	r3, r7
    7594:	f7ff feb2 	bl	72fc <add_kv_cache_key_by_type>
    7598:	0004      	movs	r4, r0
    set_cache_operation_clean();
    759a:	f7ff ff37 	bl	740c <set_cache_operation_clean>
    (void)neul_kv_queue_cache_for_write();
    759e:	f7ff ff4b 	bl	7438 <neul_kv_queue_cache_for_write>
    return (NEUL_RET) kv_ret_val;
    75a2:	e7ed      	b.n	7580 <neul_kv_set_with_attributes+0x40>
    75a4:	010017e4 	.word	0x010017e4

000075a8 <neul_kv_set>:
{
    75a8:	b510      	push	{r4, lr}
    return  neul_kv_set_with_attributes(key, kvalue,  kvalue_length, false);
    75aa:	2300      	movs	r3, #0
    75ac:	f7ff ffc8 	bl	7540 <neul_kv_set_with_attributes>
}
    75b0:	bd10      	pop	{r4, pc}

000075b2 <neul_kv_get>:
{
    75b2:	b5f0      	push	{r4, r5, r6, r7, lr}
    bool is_permanent = false;
    75b4:	270e      	movs	r7, #14
{
    75b6:	b087      	sub	sp, #28
    75b8:	001d      	movs	r5, r3
    bool erased = false;
    75ba:	260f      	movs	r6, #15
    bool is_permanent = false;
    75bc:	ab02      	add	r3, sp, #8
    75be:	18ff      	adds	r7, r7, r3
    75c0:	2300      	movs	r3, #0
{
    75c2:	0014      	movs	r4, r2
    bool erased = false;
    75c4:	aa02      	add	r2, sp, #8
    75c6:	18b6      	adds	r6, r6, r2
{
    75c8:	9002      	str	r0, [sp, #8]
    75ca:	9103      	str	r1, [sp, #12]
    bool is_permanent = false;
    75cc:	703b      	strb	r3, [r7, #0]
    bool erased = false;
    75ce:	7033      	strb	r3, [r6, #0]
        return NEUL_RET_ERROR_IN_PARAMETERS;
    75d0:	2003      	movs	r0, #3
    if( kvalue_length == NULL || kvalue == NULL)
    75d2:	429c      	cmp	r4, r3
    75d4:	d013      	beq.n	75fe <neul_kv_get+0x4c>
    75d6:	429d      	cmp	r5, r3
    75d8:	d011      	beq.n	75fe <neul_kv_get+0x4c>
    set_cache_operation_in_progress();
    75da:	f7ff fe25 	bl	7228 <set_cache_operation_in_progress>
    if (read_kv_cache_key(key, kvalue_max_length, kvalue_length, kvalue, &erased))
    75de:	9600      	str	r6, [sp, #0]
    75e0:	002b      	movs	r3, r5
    75e2:	0022      	movs	r2, r4
    75e4:	9903      	ldr	r1, [sp, #12]
    75e6:	9802      	ldr	r0, [sp, #8]
    75e8:	f7ff fee4 	bl	73b4 <read_kv_cache_key>
    75ec:	2800      	cmp	r0, #0
    75ee:	d008      	beq.n	7602 <neul_kv_get+0x50>
        set_cache_operation_clean();
    75f0:	f7ff ff0c 	bl	740c <set_cache_operation_clean>
        if (erased)
    75f4:	7833      	ldrb	r3, [r6, #0]
            return (NEUL_RET_KEY_NOT_FOUND);
    75f6:	2007      	movs	r0, #7
        if (erased)
    75f8:	2b00      	cmp	r3, #0
    75fa:	d100      	bne.n	75fe <neul_kv_get+0x4c>
        return (NEUL_RET_OK);
    75fc:	0018      	movs	r0, r3
}
    75fe:	b007      	add	sp, #28
    7600:	bdf0      	pop	{r4, r5, r6, r7, pc}
    if ( command_kv_get(key, &kv_ret_val, kvalue_max_length, kvalue_length, kvalue, &is_permanent)  != RPC_ERR_OK)
    7602:	260d      	movs	r6, #13
    7604:	ab02      	add	r3, sp, #8
    7606:	18f6      	adds	r6, r6, r3
    7608:	9701      	str	r7, [sp, #4]
    760a:	9500      	str	r5, [sp, #0]
    760c:	0023      	movs	r3, r4
    760e:	9a03      	ldr	r2, [sp, #12]
    7610:	0031      	movs	r1, r6
    7612:	9802      	ldr	r0, [sp, #8]
    7614:	f7fb fe69 	bl	32ea <command_kv_get>
    7618:	2800      	cmp	r0, #0
    761a:	d003      	beq.n	7624 <neul_kv_get+0x72>
        set_cache_operation_clean();
    761c:	f7ff fef6 	bl	740c <set_cache_operation_clean>
        return NEUL_RET_ERROR_RPC;
    7620:	2002      	movs	r0, #2
    7622:	e7ec      	b.n	75fe <neul_kv_get+0x4c>
    set_cache_operation_clean();
    7624:	f7ff fef2 	bl	740c <set_cache_operation_clean>
    return (NEUL_RET) kv_ret_val;
    7628:	7830      	ldrb	r0, [r6, #0]
    762a:	e7e8      	b.n	75fe <neul_kv_get+0x4c>

0000762c <remote_command_kv_apps_cache_flushed>:
}
    762c:	4770      	bx	lr
	...

00007630 <neul_kv_init>:
}
#endif

//lint -sem(neul_kv_init, thread_protected)
void neul_kv_init(void)
{
    7630:	b510      	push	{r4, lr}
    if (non_os_is_driver_initialised(DRIVER_INIT_NEUL_KV))
    7632:	200b      	movs	r0, #11
    7634:	4674      	mov	r4, lr
    7636:	f010 fde5 	bl	18204 <non_os_is_driver_initialised>
    763a:	2800      	cmp	r0, #0
    763c:	d122      	bne.n	7684 <neul_kv_init+0x54>
        return;
    }

#if defined USE_CMSIS_OS

    kv_cache_mutex = osMutexNew(NULL);
    763e:	f00d f99b 	bl	14978 <osMutexNew>
    7642:	4b11      	ldr	r3, [pc, #68]	; (7688 <neul_kv_init+0x58>)
    7644:	6018      	str	r0, [r3, #0]
    assert(kv_cache_mutex);
    7646:	2800      	cmp	r0, #0
    7648:	d103      	bne.n	7652 <neul_kv_init+0x22>
    764a:	0021      	movs	r1, r4
    764c:	3016      	adds	r0, #22
    764e:	f7fa fa5f 	bl	1b10 <panic>

#endif //defined USE_CMSIS_OS
    kv_cache_root_a.kv_magic = NEUL_KV_MAGIC;
    kv_cache_root_a.kv_cache = NULL;
    7652:	2000      	movs	r0, #0
    kv_cache_root_a.kv_security_locked = KV_SECURITY_STATE_UNLOCKED;
    kv_cache_root_a.kv_clean = NEUL_KV_CLEAN;
    7654:	2101      	movs	r1, #1
    kv_cache_root_a.kv_magic = NEUL_KV_MAGIC;
    7656:	4a0d      	ldr	r2, [pc, #52]	; (768c <neul_kv_init+0x5c>)

    kv_cache_root_b.kv_magic = NEUL_KV_MAGIC;
    7658:	4b0d      	ldr	r3, [pc, #52]	; (7690 <neul_kv_init+0x60>)
    kv_cache_root_a.kv_security_locked = KV_SECURITY_STATE_UNLOCKED;
    765a:	6090      	str	r0, [r2, #8]
    kv_cache_root_a.kv_cache = NULL;
    765c:	6010      	str	r0, [r2, #0]
    kv_cache_root_a.kv_clean = NEUL_KV_CLEAN;
    765e:	7311      	strb	r1, [r2, #12]
    kv_cache_root_b.kv_cache = NULL;
    7660:	6018      	str	r0, [r3, #0]
    kv_cache_root_b.kv_security_locked = KV_SECURITY_STATE_UNLOCKED;
    7662:	6098      	str	r0, [r3, #8]
    kv_cache_root_b.kv_clean = NEUL_KV_CLEAN;

    kv_cache_root_primary   =  &kv_cache_root_a;
    7664:	480b      	ldr	r0, [pc, #44]	; (7694 <neul_kv_init+0x64>)
    kv_cache_root_a.kv_magic = NEUL_KV_MAGIC;
    7666:	4c0c      	ldr	r4, [pc, #48]	; (7698 <neul_kv_init+0x68>)
    kv_cache_root_primary   =  &kv_cache_root_a;
    7668:	6002      	str	r2, [r0, #0]
    kv_cache_root_secondary =  &kv_cache_root_b;
    766a:	480c      	ldr	r0, [pc, #48]	; (769c <neul_kv_init+0x6c>)
    kv_cache_root_a.kv_magic = NEUL_KV_MAGIC;
    766c:	6054      	str	r4, [r2, #4]
    kv_cache_root_secondary =  &kv_cache_root_b;
    766e:	6003      	str	r3, [r0, #0]

    kv_cache_base.kv_magic =   NEUL_KV_MAGIC;
    7670:	480b      	ldr	r0, [pc, #44]	; (76a0 <neul_kv_init+0x70>)
    kv_cache_root_b.kv_magic = NEUL_KV_MAGIC;
    7672:	605c      	str	r4, [r3, #4]
    kv_cache_base.kv_magic =   NEUL_KV_MAGIC;
    7674:	6004      	str	r4, [r0, #0]
    kv_cache_base.kv_cache_a = &kv_cache_root_a;
    7676:	6082      	str	r2, [r0, #8]
    kv_cache_base.kv_cache_b = &kv_cache_root_b;
    7678:	60c3      	str	r3, [r0, #12]
    kv_cache_base.primary =    KV_CACHE_A;
    767a:	7101      	strb	r1, [r0, #4]
#if CORE==SECURITY

    neul_kv_asset_init();

#endif // CORE != SECURITY
    non_os_set_driver_initalised(DRIVER_INIT_NEUL_KV, true);
    767c:	200b      	movs	r0, #11
    kv_cache_root_b.kv_clean = NEUL_KV_CLEAN;
    767e:	7319      	strb	r1, [r3, #12]
    non_os_set_driver_initalised(DRIVER_INIT_NEUL_KV, true);
    7680:	f010 fdca 	bl	18218 <non_os_set_driver_initalised>
}
    7684:	bd10      	pop	{r4, pc}
    7686:	46c0      	nop			; (mov r8, r8)
    7688:	010017c0 	.word	0x010017c0
    768c:	010017c4 	.word	0x010017c4
    7690:	010017d4 	.word	0x010017d4
    7694:	010017e4 	.word	0x010017e4
    7698:	deadcafe 	.word	0xdeadcafe
    769c:	010017e8 	.word	0x010017e8
    76a0:	010017b0 	.word	0x010017b0

000076a4 <neul_kv_cache_register>:


void neul_kv_cache_register(void)
{
    76a4:	b507      	push	{r0, r1, r2, lr}
#if CORE != SECURITY

    NEUL_RET ret_val;
    (void) command_register_kvcache((uint32) &(kv_cache_base), (uint8 *) &ret_val);
    76a6:	466b      	mov	r3, sp
    76a8:	4802      	ldr	r0, [pc, #8]	; (76b4 <neul_kv_cache_register+0x10>)
    76aa:	1dd9      	adds	r1, r3, #7
    76ac:	f7fd ff8d 	bl	55ca <command_register_kvcache>

    kv_storage_set_store_cache(KV_STORE_SECURITY, CORES_SECURITY_CORE, &kv_cache_base);
    kv_storage_set_store_cache(KV_STORE_ASSET, CORES_SECURITY_CORE, &kv_cache_asset_base);

#endif // CORE != SECURITY
}
    76b0:	bd07      	pop	{r0, r1, r2, pc}
    76b2:	46c0      	nop			; (mov r8, r8)
    76b4:	010017b0 	.word	0x010017b0

000076b8 <aio_manager_init>:

/** clear down the resource status table, and the deferred mux selection flags
 * @return success
*/
AIO_MANAGER_RET aio_manager_init(void)
{
    76b8:	b510      	push	{r4, lr}
    if(aio_manager_mutex == NULL)
    76ba:	4c10      	ldr	r4, [pc, #64]	; (76fc <aio_manager_init+0x44>)
    76bc:	6820      	ldr	r0, [r4, #0]
    76be:	2800      	cmp	r0, #0
    76c0:	d013      	beq.n	76ea <aio_manager_init+0x32>
    ret_value = aio_manager_create_mutex();
    if ( ret_value != AIO_MANAGER_RET_OK)
    {
        return ret_value;
    }
    the_status_table = aio_manager_get_status_table();
    76c2:	f00e ff31 	bl	16528 <aio_manager_get_status_table>
    76c6:	0003      	movs	r3, r0
    for( i=0; i < AIO_RESOURCE_MAX_NUMBER; i++)
    {
        the_status_table[i] = AIO_RESOURCE_FREE;
    76c8:	2200      	movs	r2, #0
    76ca:	3317      	adds	r3, #23
    76cc:	7002      	strb	r2, [r0, #0]
    76ce:	3001      	adds	r0, #1
    for( i=0; i < AIO_RESOURCE_MAX_NUMBER; i++)
    76d0:	4298      	cmp	r0, r3
    76d2:	d1fb      	bne.n	76cc <aio_manager_init+0x14>
    }
    deferred_mux_flags = aio_manager_get_deferred_mux_select_config();
    76d4:	f00e ff2c 	bl	16530 <aio_manager_get_deferred_mux_select_config>
    deferred_mux_flags->aio_pin_0 = HAL_MUXBUS_CONFIG_NOT_SET;
    76d8:	2307      	movs	r3, #7
    76da:	7003      	strb	r3, [r0, #0]
    deferred_mux_flags->aio_pin_1 = HAL_MUXBUS_CONFIG_NOT_SET;
    76dc:	7043      	strb	r3, [r0, #1]
    deferred_mux_flags->idac = HAL_MUXBUS_CONFIG_NOT_SET;
    76de:	7083      	strb	r3, [r0, #2]
    deferred_mux_flags->buf_ref = HAL_MUXBUS_CONFIG_NOT_SET;
    76e0:	70c3      	strb	r3, [r0, #3]
    deferred_mux_flags->vbat_div = HAL_MUXBUS_CONFIG_NOT_SET;
    76e2:	7103      	strb	r3, [r0, #4]
    deferred_mux_flags->vdd_core = HAL_MUXBUS_CONFIG_NOT_SET;
    76e4:	7143      	strb	r3, [r0, #5]

    return ret_value;
    76e6:	2300      	movs	r3, #0
    76e8:	e005      	b.n	76f6 <aio_manager_init+0x3e>
        aio_manager_mutex = osMutexNew(NULL);
    76ea:	f00d f945 	bl	14978 <osMutexNew>
            return AIO_MANAGER_RET_MUTEX_ERROR;
    76ee:	230f      	movs	r3, #15
        aio_manager_mutex = osMutexNew(NULL);
    76f0:	6020      	str	r0, [r4, #0]
        if (aio_manager_mutex == NULL)
    76f2:	2800      	cmp	r0, #0
    76f4:	d1e5      	bne.n	76c2 <aio_manager_init+0xa>
}
    76f6:	0018      	movs	r0, r3
    76f8:	bd10      	pop	{r4, pc}
    76fa:	46c0      	nop			; (mov r8, r8)
    76fc:	010017ec 	.word	0x010017ec

00007700 <io_bank_init_helper>:
static PMU_VDD_IO_LEVEL bank_r2_voltage;
static PMU_VDD_IO_LEVEL bank_l1_voltage;


static void io_bank_init_helper(PMU_VDD_IO_BANK bank, neul_kv_key main_key, neul_kv_key alt_key, PMU_VDD_IO_LEVEL *level, PMU_VDD_IO_LEVEL default_level)
{
    7700:	b5f0      	push	{r4, r5, r6, r7, lr}
    7702:	b085      	sub	sp, #20
    7704:	9300      	str	r3, [sp, #0]
    7706:	ab0a      	add	r3, sp, #40	; 0x28
    7708:	781b      	ldrb	r3, [r3, #0]
    770a:	0017      	movs	r7, r2
    PMU_VDD_IO_LEVEL config_level;
    uint16 value_length;
    NEUL_RET ret;

    ret = neul_kv_get(main_key, sizeof(config_level), &value_length, (uint8*)&config_level);
    770c:	ac03      	add	r4, sp, #12
    770e:	aa02      	add	r2, sp, #8
{
    7710:	9301      	str	r3, [sp, #4]
    7712:	0006      	movs	r6, r0
    ret = neul_kv_get(main_key, sizeof(config_level), &value_length, (uint8*)&config_level);
    7714:	0023      	movs	r3, r4
{
    7716:	0008      	movs	r0, r1
    ret = neul_kv_get(main_key, sizeof(config_level), &value_length, (uint8*)&config_level);
    7718:	3206      	adds	r2, #6
    771a:	2101      	movs	r1, #1
    771c:	f7ff ff49 	bl	75b2 <neul_kv_get>
    7720:	ab02      	add	r3, sp, #8
    7722:	1d5d      	adds	r5, r3, #5
    7724:	7028      	strb	r0, [r5, #0]
    // handle old values, should be redundant but SSB upgrader should migrate these if seen
    if (ret != NEUL_RET_OK)
    7726:	2800      	cmp	r0, #0
    7728:	d007      	beq.n	773a <io_bank_init_helper+0x3a>
    {
        ret = neul_kv_get(alt_key, sizeof(config_level), &value_length, (uint8*)&config_level);
    772a:	aa02      	add	r2, sp, #8
    772c:	0023      	movs	r3, r4
    772e:	3206      	adds	r2, #6
    7730:	2101      	movs	r1, #1
    7732:	0038      	movs	r0, r7
    7734:	f7ff ff3d 	bl	75b2 <neul_kv_get>
    7738:	7028      	strb	r0, [r5, #0]
    }

    if (ret != NEUL_RET_OK)
    773a:	ab02      	add	r3, sp, #8
    773c:	3305      	adds	r3, #5
    773e:	781b      	ldrb	r3, [r3, #0]
    7740:	2b00      	cmp	r3, #0
    7742:	d002      	beq.n	774a <io_bank_init_helper+0x4a>
    {
        config_level = default_level;
    7744:	466b      	mov	r3, sp
    7746:	791b      	ldrb	r3, [r3, #4]
    7748:	7023      	strb	r3, [r4, #0]
    }
    *level = config_level;
    774a:	7821      	ldrb	r1, [r4, #0]
    774c:	9b00      	ldr	r3, [sp, #0]
    // ignore error - we should always be passing a valid value, and a failure would
    // be that another core has already set it as it's using a pin on that bank
    (void) command_set_vdd_io_level(bank, config_level, (uint8 *)&ret);
    774e:	002a      	movs	r2, r5
    *level = config_level;
    7750:	7019      	strb	r1, [r3, #0]
    (void) command_set_vdd_io_level(bank, config_level, (uint8 *)&ret);
    7752:	0030      	movs	r0, r6
    7754:	f7fb fd22 	bl	319c <command_set_vdd_io_level>
}
    7758:	b005      	add	sp, #20
    775a:	bdf0      	pop	{r4, r5, r6, r7, pc}

0000775c <io_bank_init>:
/*
 * read values from kv store, or use defaults, then set
 * R2 on and L1 off initially
 */
void io_bank_init(void)
{
    775c:	b537      	push	{r0, r1, r2, r4, r5, lr}

#ifdef USE_CMSIS_OS
    if (io_bank_mutex == NULL)
    775e:	4c10      	ldr	r4, [pc, #64]	; (77a0 <io_bank_init+0x44>)
    7760:	4675      	mov	r5, lr
    7762:	6820      	ldr	r0, [r4, #0]
    7764:	2800      	cmp	r0, #0
    7766:	d108      	bne.n	777a <io_bank_init+0x1e>
    {
        io_bank_mutex = osMutexNew(NULL);
    7768:	f00d f906 	bl	14978 <osMutexNew>
    776c:	6020      	str	r0, [r4, #0]
        if (io_bank_mutex == NULL)
    776e:	2800      	cmp	r0, #0
    7770:	d103      	bne.n	777a <io_bank_init+0x1e>
        {
            assert(false);
    7772:	0029      	movs	r1, r5
    7774:	3016      	adds	r0, #22
    7776:	f7fa f9cb 	bl	1b10 <panic>
        }
    }
#endif
    // PMU_VDD_IO_BANK_R2
    io_bank_init_helper(PMU_VDD_IO_BANK_R2, BASE_KEYID_VDD_IO_BANK_R2, UNUSED_KEYID_RESERVED_1, &bank_r2_voltage, PMU_VDD_IO_BANK_R2_DEFAULT_LEVEL); //lint !e845
    777a:	2306      	movs	r3, #6
    777c:	22c0      	movs	r2, #192	; 0xc0
    777e:	9300      	str	r3, [sp, #0]
    7780:	0152      	lsls	r2, r2, #5
    7782:	4b08      	ldr	r3, [pc, #32]	; (77a4 <io_bank_init+0x48>)
    7784:	210a      	movs	r1, #10
    7786:	2001      	movs	r0, #1
    7788:	f7ff ffba 	bl	7700 <io_bank_init_helper>
    // PMU_VDD_IO_BANK_L1
    io_bank_init_helper(PMU_VDD_IO_BANK_L1, BASE_KEYID_VDD_IO_BANK_L1, UNUSED_KEYID_RESERVED_2, &bank_l1_voltage, PMU_VDD_IO_BANK_L1_DEFAULT_LEVEL);
    778c:	2308      	movs	r3, #8
    778e:	4a06      	ldr	r2, [pc, #24]	; (77a8 <io_bank_init+0x4c>)
    7790:	9300      	str	r3, [sp, #0]
    7792:	210b      	movs	r1, #11
    7794:	4b05      	ldr	r3, [pc, #20]	; (77ac <io_bank_init+0x50>)
    7796:	2003      	movs	r0, #3
    7798:	f7ff ffb2 	bl	7700 <io_bank_init_helper>
}
    779c:	bd37      	pop	{r0, r1, r2, r4, r5, pc}
    779e:	46c0      	nop			; (mov r8, r8)
    77a0:	010017f4 	.word	0x010017f4
    77a4:	010017f1 	.word	0x010017f1
    77a8:	00001801 	.word	0x00001801
    77ac:	010017f0 	.word	0x010017f0

000077b0 <neul_update_get_update_status>:
/** Return update status
 * @param update status
 * @return success or error
 */
NEUL_RET neul_update_get_update_status(NEUL_UPDATE_OTA_PACKAGE_STATUS *update_status)
{
    77b0:	b510      	push	{r4, lr}
    NEUL_RET result = NEUL_RET_ERROR;

    if (command_get_update_status((uint8 *) update_status) == RPC_ERR_OK)
    77b2:	f7fe f805 	bl	57c0 <command_get_update_status>
    77b6:	1e43      	subs	r3, r0, #1
    77b8:	4198      	sbcs	r0, r3
    {
        result =  NEUL_RET_OK;
    }
    return result;
    77ba:	b2c0      	uxtb	r0, r0
}
    77bc:	bd10      	pop	{r4, pc}

000077be <neul_update_firmware_upgrade_req>:
/** Request the UE initiates an update
 * @param status status
 * @return success or error
 */
NEUL_RET neul_update_firmware_upgrade_req(NEUL_UPDATE_RET *status)
{
    77be:	b513      	push	{r0, r1, r4, lr}
    NEUL_RET result;

    if (command_firmware_upgrade_req((uint8 *) &result, (uint8 *) status) != RPC_ERR_OK)
    77c0:	466b      	mov	r3, sp
    77c2:	1ddc      	adds	r4, r3, #7
{
    77c4:	0001      	movs	r1, r0
    if (command_firmware_upgrade_req((uint8 *) &result, (uint8 *) status) != RPC_ERR_OK)
    77c6:	0020      	movs	r0, r4
    77c8:	f7fc fe0a 	bl	43e0 <command_firmware_upgrade_req>
    77cc:	2800      	cmp	r0, #0
    77ce:	d001      	beq.n	77d4 <neul_update_firmware_upgrade_req+0x16>
    {
        result =  NEUL_RET_ERROR;
    77d0:	2301      	movs	r3, #1
    77d2:	7023      	strb	r3, [r4, #0]
    }
    return result;
    77d4:	7820      	ldrb	r0, [r4, #0]
}
    77d6:	bd16      	pop	{r1, r2, r4, pc}

000077d8 <neul_update_package_parse_req>:

/** Request to parse the package
 * @return success or error
 */
NEUL_RET neul_update_package_parse_req(void)
{
    77d8:	b513      	push	{r0, r1, r4, lr}
    NEUL_RET result;

    if (command_update_package_parse_req((uint8 *) &result) != RPC_ERR_OK)
    77da:	466b      	mov	r3, sp
    77dc:	1ddc      	adds	r4, r3, #7
    77de:	0020      	movs	r0, r4
    77e0:	f7fc fd8f 	bl	4302 <command_update_package_parse_req>
    77e4:	2800      	cmp	r0, #0
    77e6:	d001      	beq.n	77ec <neul_update_package_parse_req+0x14>
    {
        result =  NEUL_RET_ERROR;
    77e8:	2301      	movs	r3, #1
    77ea:	7023      	strb	r3, [r4, #0]
    }
    return result;
    77ec:	7820      	ldrb	r0, [r4, #0]
}
    77ee:	bd16      	pop	{r1, r2, r4, pc}

000077f0 <neul_update_package_get_package_name_req>:

/** Get package name from FOTA package
 * @return success or error
 */
NEUL_RET neul_update_package_get_package_name_req()
{
    77f0:	b513      	push	{r0, r1, r4, lr}
    NEUL_RET result;

    if (command_update_package_get_package_name_req((uint8 *) &result) != RPC_ERR_OK)
    77f2:	466b      	mov	r3, sp
    77f4:	1ddc      	adds	r4, r3, #7
    77f6:	0020      	movs	r0, r4
    77f8:	f7fc fdcd 	bl	4396 <command_update_package_get_package_name_req>
    77fc:	2800      	cmp	r0, #0
    77fe:	d001      	beq.n	7804 <neul_update_package_get_package_name_req+0x14>
    {
        result =  NEUL_RET_ERROR;
    7800:	2301      	movs	r3, #1
    7802:	7023      	strb	r3, [r4, #0]
    }
    return result;
    7804:	7820      	ldrb	r0, [r4, #0]
}
    7806:	bd16      	pop	{r1, r2, r4, pc}

00007808 <neul_update_package_get_package_version_req>:

/** Get version number from FOTA package
 * @return success or error
 */
NEUL_RET neul_update_package_get_package_version_req()
{
    7808:	b513      	push	{r0, r1, r4, lr}
    NEUL_RET result;

    if (command_update_package_get_package_version_req((uint8 *) &result) != RPC_ERR_OK)
    780a:	466b      	mov	r3, sp
    780c:	1ddc      	adds	r4, r3, #7
    780e:	0020      	movs	r0, r4
    7810:	f7fc fd9c 	bl	434c <command_update_package_get_package_version_req>
    7814:	2800      	cmp	r0, #0
    7816:	d001      	beq.n	781c <neul_update_package_get_package_version_req+0x14>
    {
        result =  NEUL_RET_ERROR;
    7818:	2301      	movs	r3, #1
    781a:	7023      	strb	r3, [r4, #0]
    }
    return result;
    781c:	7820      	ldrb	r0, [r4, #0]
}
    781e:	bd16      	pop	{r1, r2, r4, pc}

00007820 <neul_update_package_flash_write>:
 * @param offset
 * @param buffered
 * @return success or error
 */
NEUL_RET neul_update_package_flash_write(uint32 buffer_length, uint32 buffer, uint32 offset, bool *buffered)
{
    7820:	b510      	push	{r4, lr}
    NEUL_RET result = NEUL_RET_ERROR;

    if (command_update_package_flash_write(buffer_length, buffer, offset, buffered) == RPC_ERR_OK)
    7822:	f7fc fe2f 	bl	4484 <command_update_package_flash_write>
    7826:	1e43      	subs	r3, r0, #1
    7828:	4198      	sbcs	r0, r3
    {
        result =  NEUL_RET_OK;
    }
    return result;
    782a:	b2c0      	uxtb	r0, r0
}
    782c:	bd10      	pop	{r4, pc}

0000782e <neul_update_package_flash_erase>:
/** Reset UE update result
 * @param queued if erase request queued
 * @return success or error
 */
NEUL_RET neul_update_package_flash_erase(bool *queued)
{
    782e:	b510      	push	{r4, lr}
    NEUL_RET result = NEUL_RET_ERROR;

    if (command_update_package_flash_erase(queued) == RPC_ERR_OK)
    7830:	f7fc fe03 	bl	443a <command_update_package_flash_erase>
    7834:	1e43      	subs	r3, r0, #1
    7836:	4198      	sbcs	r0, r3
    {
        result =  NEUL_RET_OK;
    }
    return result;
    7838:	b2c0      	uxtb	r0, r0
}
    783a:	bd10      	pop	{r4, pc}

0000783c <neul_update_package_allocate_flash>:
 * @param expected allocated flash size for udpate package
 * @param allocated return true if space allocated succeeded, and false otherwise
 * @return success or error
 */
NEUL_RET neul_update_package_allocate_flash(uint32 update_package_size, bool *allocated)
{
    783c:	b510      	push	{r4, lr}
    NEUL_RET result = NEUL_RET_ERROR;

    if (command_update_package_allocate_flash(update_package_size, allocated) == RPC_ERR_OK)
    783e:	f7fe f908 	bl	5a52 <command_update_package_allocate_flash>
    7842:	1e43      	subs	r3, r0, #1
    7844:	4198      	sbcs	r0, r3
    {
        result = NEUL_RET_OK;
    }
    return result;
    7846:	b2c0      	uxtb	r0, r0
}
    7848:	bd10      	pop	{r4, pc}
	...

0000784c <neul_update_register_flash_erase_done_callback>:
 * @param callback to register
 * @return success or error
 */
NEUL_RET neul_update_register_flash_erase_done_callback(NEUL_UPDATE_FLASH_ERASE_DONE callback)
{
    flash_erase_done_callback = callback;
    784c:	4b01      	ldr	r3, [pc, #4]	; (7854 <neul_update_register_flash_erase_done_callback+0x8>)
    784e:	6018      	str	r0, [r3, #0]
    return NEUL_RET_OK;
}
    7850:	2000      	movs	r0, #0
    7852:	4770      	bx	lr
    7854:	010017f8 	.word	0x010017f8

00007858 <neul_update_register_package_parse_cnf_callback>:
 * @param callback to register
 * @return success or error
 */
NEUL_RET neul_update_register_package_parse_cnf_callback(NEUL_UPDATE_PACKAGE_PARSE_CNF callback)
{
    package_parse_cnf_callback = callback;
    7858:	4b01      	ldr	r3, [pc, #4]	; (7860 <neul_update_register_package_parse_cnf_callback+0x8>)
    785a:	6018      	str	r0, [r3, #0]
    return NEUL_RET_OK;
}
    785c:	2000      	movs	r0, #0
    785e:	4770      	bx	lr
    7860:	01001808 	.word	0x01001808

00007864 <neul_update_register_package_process_cnf_callback>:
 * @param callback to register
 * @return success or error
 */
NEUL_RET neul_update_register_package_process_cnf_callback(NEUL_UPDATE_PACKAGE_PROCESS_CNF callback)
{
    package_process_cnf_callback = callback;
    7864:	4b01      	ldr	r3, [pc, #4]	; (786c <neul_update_register_package_process_cnf_callback+0x8>)
    7866:	6018      	str	r0, [r3, #0]
    return NEUL_RET_OK;
}
    7868:	2000      	movs	r0, #0
    786a:	4770      	bx	lr
    786c:	0100180c 	.word	0x0100180c

00007870 <neul_update_register_package_get_package_name_cnf_callback>:
 * @param callback to register
 * @return success or error
 */
NEUL_RET neul_update_register_package_get_package_name_cnf_callback(NEUL_UPDATE_GET_PACKAGE_NAME callback)
{
    get_package_name_cnf_callback = callback;
    7870:	4b01      	ldr	r3, [pc, #4]	; (7878 <neul_update_register_package_get_package_name_cnf_callback+0x8>)
    7872:	6018      	str	r0, [r3, #0]
    return NEUL_RET_OK;
}
    7874:	2000      	movs	r0, #0
    7876:	4770      	bx	lr
    7878:	01001800 	.word	0x01001800

0000787c <neul_update_register_package_get_package_version_cnf_callback>:
 * @param callback to register
 * @return success or error
 */
NEUL_RET neul_update_register_package_get_package_version_cnf_callback(NEUL_UPDATE_GET_PACKAGE_VERSION callback)
{
    get_package_version_cnf_callback = callback;
    787c:	4b01      	ldr	r3, [pc, #4]	; (7884 <neul_update_register_package_get_package_version_cnf_callback+0x8>)
    787e:	6018      	str	r0, [r3, #0]
    return NEUL_RET_OK;
}
    7880:	2000      	movs	r0, #0
    7882:	4770      	bx	lr
    7884:	01001804 	.word	0x01001804

00007888 <neul_update_register_flash_write_done_callback>:
 * @param callback to register
 * @return success or error
 */
NEUL_RET neul_update_register_flash_write_done_callback(NEUL_UPDATE_FLASH_WRITE_DONE callback)
{
    flash_write_done_callback = callback;
    7888:	4b01      	ldr	r3, [pc, #4]	; (7890 <neul_update_register_flash_write_done_callback+0x8>)
    788a:	6018      	str	r0, [r3, #0]
    return NEUL_RET_OK;
}
    788c:	2000      	movs	r0, #0
    788e:	4770      	bx	lr
    7890:	010017fc 	.word	0x010017fc

00007894 <remote_command_update_package_flash_erase_done>:

void remote_command_update_package_flash_erase_done(CORES core, bool result)
{
    7894:	b510      	push	{r4, lr}
    UNUSED(core);
    NEUL_UPDATE_FLASH_ERASE_DONE local_callback = flash_erase_done_callback;
    7896:	4b03      	ldr	r3, [pc, #12]	; (78a4 <remote_command_update_package_flash_erase_done+0x10>)
    7898:	681b      	ldr	r3, [r3, #0]
    if (local_callback != NULL)
    789a:	2b00      	cmp	r3, #0
    789c:	d001      	beq.n	78a2 <remote_command_update_package_flash_erase_done+0xe>
    {
        (*local_callback)(result);
    789e:	0008      	movs	r0, r1
    78a0:	4798      	blx	r3
    }
}
    78a2:	bd10      	pop	{r4, pc}
    78a4:	010017f8 	.word	0x010017f8

000078a8 <remote_command_update_package_parse_cnf>:

void remote_command_update_package_parse_cnf(CORES core, uint8 status)
{
    78a8:	b510      	push	{r4, lr}
    UNUSED(core);
    NEUL_UPDATE_PACKAGE_PARSE_CNF local_callback = package_parse_cnf_callback;
    78aa:	4b03      	ldr	r3, [pc, #12]	; (78b8 <remote_command_update_package_parse_cnf+0x10>)
    78ac:	681b      	ldr	r3, [r3, #0]
    if (local_callback != NULL)
    78ae:	2b00      	cmp	r3, #0
    78b0:	d001      	beq.n	78b6 <remote_command_update_package_parse_cnf+0xe>
    {
        (*local_callback)(status);
    78b2:	0008      	movs	r0, r1
    78b4:	4798      	blx	r3
    }
}
    78b6:	bd10      	pop	{r4, pc}
    78b8:	01001808 	.word	0x01001808

000078bc <remote_command_update_package_process_cnf>:

void remote_command_update_package_process_cnf(CORES core, uint8 status)
{
    78bc:	b510      	push	{r4, lr}
    UNUSED(core);
    NEUL_UPDATE_PACKAGE_PROCESS_CNF local_callback = package_process_cnf_callback;
    78be:	4b03      	ldr	r3, [pc, #12]	; (78cc <remote_command_update_package_process_cnf+0x10>)
    78c0:	681b      	ldr	r3, [r3, #0]
    if (local_callback != NULL)
    78c2:	2b00      	cmp	r3, #0
    78c4:	d001      	beq.n	78ca <remote_command_update_package_process_cnf+0xe>
    {
        (*local_callback)(status);
    78c6:	0008      	movs	r0, r1
    78c8:	4798      	blx	r3
    }
}
    78ca:	bd10      	pop	{r4, pc}
    78cc:	0100180c 	.word	0x0100180c

000078d0 <remote_command_update_package_get_package_name_cnf>:

void remote_command_update_package_get_package_name_cnf(CORES core, uint16 pkgname_length, uint8 *pkgname)
{
    78d0:	b510      	push	{r4, lr}
    UNUSED(core);
    NEUL_UPDATE_GET_PACKAGE_NAME local_callback = get_package_name_cnf_callback;
    78d2:	4b04      	ldr	r3, [pc, #16]	; (78e4 <remote_command_update_package_get_package_name_cnf+0x14>)
{
    78d4:	0008      	movs	r0, r1
    NEUL_UPDATE_GET_PACKAGE_NAME local_callback = get_package_name_cnf_callback;
    78d6:	681b      	ldr	r3, [r3, #0]
    if (local_callback != NULL)
    78d8:	2b00      	cmp	r3, #0
    78da:	d001      	beq.n	78e0 <remote_command_update_package_get_package_name_cnf+0x10>
    {
        (*local_callback)(pkgname_length, pkgname);
    78dc:	0011      	movs	r1, r2
    78de:	4798      	blx	r3
    }
}
    78e0:	bd10      	pop	{r4, pc}
    78e2:	46c0      	nop			; (mov r8, r8)
    78e4:	01001800 	.word	0x01001800

000078e8 <remote_command_update_package_get_package_version_cnf>:

void remote_command_update_package_get_package_version_cnf(CORES core, uint16 version_length, uint8 *version)
{
    78e8:	b510      	push	{r4, lr}
    UNUSED(core);
    NEUL_UPDATE_GET_PACKAGE_VERSION local_callback = get_package_version_cnf_callback;
    78ea:	4b04      	ldr	r3, [pc, #16]	; (78fc <remote_command_update_package_get_package_version_cnf+0x14>)
{
    78ec:	0008      	movs	r0, r1
    NEUL_UPDATE_GET_PACKAGE_VERSION local_callback = get_package_version_cnf_callback;
    78ee:	681b      	ldr	r3, [r3, #0]
    if (local_callback != NULL)
    78f0:	2b00      	cmp	r3, #0
    78f2:	d001      	beq.n	78f8 <remote_command_update_package_get_package_version_cnf+0x10>
    {
        (*local_callback)(version_length, version);
    78f4:	0011      	movs	r1, r2
    78f6:	4798      	blx	r3
    }
}
    78f8:	bd10      	pop	{r4, pc}
    78fa:	46c0      	nop			; (mov r8, r8)
    78fc:	01001804 	.word	0x01001804

00007900 <remote_command_update_package_flash_write_done>:

void remote_command_update_package_flash_write_done(CORES core, uint8 result)
{
    7900:	b510      	push	{r4, lr}
    UNUSED(core);
    NEUL_UPDATE_FLASH_WRITE_DONE local_callback = flash_write_done_callback;
    7902:	4b03      	ldr	r3, [pc, #12]	; (7910 <remote_command_update_package_flash_write_done+0x10>)
    7904:	681b      	ldr	r3, [r3, #0]
    if (local_callback != NULL)
    7906:	2b00      	cmp	r3, #0
    7908:	d001      	beq.n	790e <remote_command_update_package_flash_write_done+0xe>
    {
        (*local_callback)(result);
    790a:	0008      	movs	r0, r1
    790c:	4798      	blx	r3
    }
}
    790e:	bd10      	pop	{r4, pc}
    7910:	010017fc 	.word	0x010017fc

00007914 <neul_log_get_log_behaviour_restricted>:
******************************************************************************/
#include "neul_log.h"
#include "neul_error_types.h"

NEUL_RET  neul_log_get_log_behaviour_restricted(NEUL_LOG_BEHAVIOUR_CONFIG* log_behaviour_config)
{
    7914:	2201      	movs	r2, #1
    if (log_behaviour_config == NULL)
    {
        return NEUL_RET_ERROR;
    7916:	0013      	movs	r3, r2
    if (log_behaviour_config == NULL)
    7918:	2800      	cmp	r0, #0
    791a:	d001      	beq.n	7920 <neul_log_get_log_behaviour_restricted+0xc>
    *log_behaviour_config = NEUL_LOG_BEHAVIOUR_CONFIG_UNRESTRICTED;
#else
    *log_behaviour_config = NEUL_LOG_BEHAVIOUR_CONFIG_RESTRICTED;
#endif

    return NEUL_RET_OK;
    791c:	2300      	movs	r3, #0
    *log_behaviour_config = NEUL_LOG_BEHAVIOUR_CONFIG_RESTRICTED;
    791e:	7002      	strb	r2, [r0, #0]
}
    7920:	0018      	movs	r0, r3
    7922:	4770      	bx	lr

00007924 <set_network_config>:

    (void)set_network_config(NETWORK_CONFIG_SILENT, socket_silence);  // Switch on socket_silence defaultly
}

NEUL_RET set_network_config(uint16 config, uint16 value)
{
    7924:	b513      	push	{r0, r1, r4, lr}
    NEUL_RET result;

    if (command_set_network_config(config, value, (uint8*)&result) != RPC_ERR_OK)
    7926:	466b      	mov	r3, sp
    7928:	1ddc      	adds	r4, r3, #7
    792a:	0022      	movs	r2, r4
    792c:	f7fe f8e1 	bl	5af2 <command_set_network_config>
    {
        return NEUL_RET_ERROR_RPC;
    7930:	2302      	movs	r3, #2
    if (command_set_network_config(config, value, (uint8*)&result) != RPC_ERR_OK)
    7932:	2800      	cmp	r0, #0
    7934:	d100      	bne.n	7938 <set_network_config+0x14>
    }

    return result;
    7936:	7823      	ldrb	r3, [r4, #0]
}
    7938:	0018      	movs	r0, r3
    793a:	bd16      	pop	{r1, r2, r4, pc}

0000793c <network_config_init>:
{
    793c:	b537      	push	{r0, r1, r2, r4, r5, lr}
    if (neul_kv_get(NETWORK_SOCKET_SILENCE, sizeof(socket_silence), &socket_silence_len, (uint8*)&socket_silence) != NEUL_RET_OK) //lint !e845
    793e:	20e0      	movs	r0, #224	; 0xe0
    7940:	466a      	mov	r2, sp
    uint16 socket_silence = NETWORK_CONFIG_SILENT_MODE_ON;
    7942:	2501      	movs	r5, #1
    7944:	ac01      	add	r4, sp, #4
    if (neul_kv_get(NETWORK_SOCKET_SILENCE, sizeof(socket_silence), &socket_silence_len, (uint8*)&socket_silence) != NEUL_RET_OK) //lint !e845
    7946:	0023      	movs	r3, r4
    7948:	3206      	adds	r2, #6
    794a:	2102      	movs	r1, #2
    794c:	0140      	lsls	r0, r0, #5
    uint16 socket_silence = NETWORK_CONFIG_SILENT_MODE_ON;
    794e:	8025      	strh	r5, [r4, #0]
    if (neul_kv_get(NETWORK_SOCKET_SILENCE, sizeof(socket_silence), &socket_silence_len, (uint8*)&socket_silence) != NEUL_RET_OK) //lint !e845
    7950:	f7ff fe2f 	bl	75b2 <neul_kv_get>
    7954:	2800      	cmp	r0, #0
    7956:	d000      	beq.n	795a <network_config_init+0x1e>
        socket_silence = NETWORK_CONFIG_SILENT_MODE_ON;
    7958:	8025      	strh	r5, [r4, #0]
    (void)set_network_config(NETWORK_CONFIG_SILENT, socket_silence);  // Switch on socket_silence defaultly
    795a:	8821      	ldrh	r1, [r4, #0]
    795c:	2000      	movs	r0, #0
    795e:	f7ff ffe1 	bl	7924 <set_network_config>
}
    7962:	bd37      	pop	{r0, r1, r2, r4, r5, pc}

00007964 <report_tcp_seq_send_result>:
    UNUSED(send_len);
#endif
}

static void report_tcp_seq_send_result(uint16 sock_num, uint8 seq, bool result)
{
    7964:	b510      	push	{r4, lr}
#ifndef TEST_SUITE

    if ((socket_list[sock_num]->sent_callback != NULL) && (seq != 0)) //seq 0 won't report to user if the data is acked.
    7966:	4b05      	ldr	r3, [pc, #20]	; (797c <report_tcp_seq_send_result+0x18>)
    7968:	0084      	lsls	r4, r0, #2
    796a:	58e3      	ldr	r3, [r4, r3]
    796c:	689b      	ldr	r3, [r3, #8]
    796e:	2b00      	cmp	r3, #0
    7970:	d002      	beq.n	7978 <report_tcp_seq_send_result+0x14>
    7972:	2900      	cmp	r1, #0
    7974:	d000      	beq.n	7978 <report_tcp_seq_send_result+0x14>
    {
        socket_list[sock_num]->sent_callback(sock_num, seq, result);
    7976:	4798      	blx	r3
#else
    UNUSED(sock_num);
    UNUSED(seq);
    UNUSED(result);
#endif
}
    7978:	bd10      	pop	{r4, pc}
    797a:	46c0      	nop			; (mov r8, r8)
    797c:	01001820 	.word	0x01001820

00007980 <socket_status_update.part.0>:

    tcp_ul_indicator_release();
    return true;
}

static void socket_status_update(uint16 sock_num, SOCKET_STATUS status, int arg)
    7980:	b510      	push	{r4, lr}
{
    socket_status_notify_fn status_callback;

    if ((sock_num >= NUM_SOCKETS) || (socket_list[sock_num] == NULL))
    7982:	4b05      	ldr	r3, [pc, #20]	; (7998 <socket_status_update.part.0+0x18>)
    7984:	0084      	lsls	r4, r0, #2
    7986:	58e3      	ldr	r3, [r4, r3]
    7988:	2b00      	cmp	r3, #0
    798a:	d003      	beq.n	7994 <socket_status_update.part.0+0x14>
    {
        return;
    }

    status_callback = socket_list[sock_num]->status_callback;
    798c:	68db      	ldr	r3, [r3, #12]

    if (status_callback)
    798e:	2b00      	cmp	r3, #0
    7990:	d000      	beq.n	7994 <socket_status_update.part.0+0x14>
    {
        status_callback(sock_num, status, arg);
    7992:	4798      	blx	r3
    }
}
    7994:	bd10      	pop	{r4, pc}
    7996:	46c0      	nop			; (mov r8, r8)
    7998:	01001820 	.word	0x01001820

0000799c <tcp_ul_indicator_acquire>:
{
    799c:	b510      	push	{r4, lr}
    if (tcp_ul_indicator_mutex != NULL)
    799e:	4b07      	ldr	r3, [pc, #28]	; (79bc <tcp_ul_indicator_acquire+0x20>)
    79a0:	6818      	ldr	r0, [r3, #0]
    79a2:	2800      	cmp	r0, #0
    79a4:	d009      	beq.n	79ba <tcp_ul_indicator_acquire+0x1e>
        if(osMutexAcquire(tcp_ul_indicator_mutex, osWaitForever) != osOK)
    79a6:	2101      	movs	r1, #1
    79a8:	4249      	negs	r1, r1
    79aa:	f00c fffb 	bl	149a4 <osMutexAcquire>
    79ae:	2800      	cmp	r0, #0
    79b0:	d003      	beq.n	79ba <tcp_ul_indicator_acquire+0x1e>
            panic(PANIC_LOG, TCP_UL_INDICATOR_MUTEX_NOT_READY);
    79b2:	2100      	movs	r1, #0
    79b4:	200d      	movs	r0, #13
    79b6:	f7fa f8ab 	bl	1b10 <panic>
} //lint !e454 !e456 Semaphore not taken if error code returned, but Lint doesn't know that.
    79ba:	bd10      	pop	{r4, pc}
    79bc:	01001858 	.word	0x01001858

000079c0 <tcp_ul_indicator_release>:
{
    79c0:	b510      	push	{r4, lr}
    if (tcp_ul_indicator_mutex != NULL)
    79c2:	4b06      	ldr	r3, [pc, #24]	; (79dc <tcp_ul_indicator_release+0x1c>)
    79c4:	6818      	ldr	r0, [r3, #0]
    79c6:	2800      	cmp	r0, #0
    79c8:	d007      	beq.n	79da <tcp_ul_indicator_release+0x1a>
        if (osMutexRelease(tcp_ul_indicator_mutex) != osOK)//lint !e455
    79ca:	f00d f80f 	bl	149ec <osMutexRelease>
    79ce:	2800      	cmp	r0, #0
    79d0:	d003      	beq.n	79da <tcp_ul_indicator_release+0x1a>
            panic(PANIC_LOG, TCP_UL_INDICATOR_MUTEX_NOT_READY);
    79d2:	2100      	movs	r1, #0
    79d4:	200d      	movs	r0, #13
    79d6:	f7fa f89b 	bl	1b10 <panic>
}
    79da:	bd10      	pop	{r4, pc}
    79dc:	01001858 	.word	0x01001858

000079e0 <close_local_socket>:
 * @param sock_num Socket number
 * @param status   Socket close reason
 * @return NEUL_SOCKET_RET_OK or NEUL_SOCKET_RET_ERROR for error.
 */
static int close_local_socket(uint16 sock_num, SOCKET_STATUS status)
{
    79e0:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
    79e2:	0007      	movs	r7, r0
    79e4:	9101      	str	r1, [sp, #4]
    message_header_t *msg_hdr;
    message_header_t *msg_hdr2;

    if ((sock_num >= NUM_SOCKETS) || (socket_list[sock_num] == NULL))
    79e6:	2806      	cmp	r0, #6
    79e8:	d839      	bhi.n	7a5e <close_local_socket+0x7e>
    79ea:	4e1e      	ldr	r6, [pc, #120]	; (7a64 <close_local_socket+0x84>)
    79ec:	0085      	lsls	r5, r0, #2
    79ee:	59ab      	ldr	r3, [r5, r6]
    79f0:	2b00      	cmp	r3, #0
    79f2:	d034      	beq.n	7a5e <close_local_socket+0x7e>
    {
        return NEUL_SOCKET_RET_ERROR;
    }

    non_os_enter_critical();
    79f4:	f010 fbde 	bl	181b4 <non_os_enter_critical>
    msg_hdr = socket_list[sock_num]->message;
    79f8:	59ab      	ldr	r3, [r5, r6]
    79fa:	691c      	ldr	r4, [r3, #16]
    // free up any unread messages
    while (msg_hdr != NULL)
    79fc:	2c00      	cmp	r4, #0
    79fe:	d116      	bne.n	7a2e <close_local_socket+0x4e>
            irfree(msg_hdr->buffer);
        }
        msg_hdr=msg_hdr->next;
        irfree(msg_hdr2);
    }
    non_os_exit_critical();
    7a00:	f010 fbec 	bl	181dc <non_os_exit_critical>
    tcp_ul_indicator_acquire();
    7a04:	f7ff ffca 	bl	799c <tcp_ul_indicator_acquire>
    head = tcp_ul_indicator_list[sock_num];
    7a08:	4b17      	ldr	r3, [pc, #92]	; (7a68 <close_local_socket+0x88>)
    7a0a:	595c      	ldr	r4, [r3, r5]
    while (head)
    7a0c:	2c00      	cmp	r4, #0
    7a0e:	d11a      	bne.n	7a46 <close_local_socket+0x66>
    tcp_ul_indicator_list[sock_num] = NULL;
    7a10:	4b15      	ldr	r3, [pc, #84]	; (7a68 <close_local_socket+0x88>)
    7a12:	515c      	str	r4, [r3, r5]
    tcp_ul_indicator_release();
    7a14:	f7ff ffd4 	bl	79c0 <tcp_ul_indicator_release>
    7a18:	0022      	movs	r2, r4
    7a1a:	9901      	ldr	r1, [sp, #4]
    7a1c:	0038      	movs	r0, r7
    7a1e:	f7ff ffaf 	bl	7980 <socket_status_update.part.0>
    remove_all_tcp_seq_from_queue(sock_num);

    // close scoket, clear at allocation, report close indication to AT comm.
    socket_status_update(sock_num, status, 0);

    irfree(socket_list[sock_num]);
    7a22:	5970      	ldr	r0, [r6, r5]
    7a24:	f00b f808 	bl	12a38 <irfree>
    socket_list[sock_num] = NULL;

    return NEUL_SOCKET_RET_OK;
    7a28:	0020      	movs	r0, r4
    socket_list[sock_num] = NULL;
    7a2a:	5174      	str	r4, [r6, r5]
}
    7a2c:	bdfe      	pop	{r1, r2, r3, r4, r5, r6, r7, pc}
        if (msg_hdr->buffer != NULL)
    7a2e:	69e0      	ldr	r0, [r4, #28]
    7a30:	2800      	cmp	r0, #0
    7a32:	d001      	beq.n	7a38 <close_local_socket+0x58>
            irfree(msg_hdr->buffer);
    7a34:	f00b f800 	bl	12a38 <irfree>
        msg_hdr=msg_hdr->next;
    7a38:	6a23      	ldr	r3, [r4, #32]
        irfree(msg_hdr2);
    7a3a:	0020      	movs	r0, r4
        msg_hdr=msg_hdr->next;
    7a3c:	9300      	str	r3, [sp, #0]
        irfree(msg_hdr2);
    7a3e:	f00a fffb 	bl	12a38 <irfree>
        msg_hdr=msg_hdr->next;
    7a42:	9c00      	ldr	r4, [sp, #0]
    7a44:	e7da      	b.n	79fc <close_local_socket+0x1c>
        report_tcp_seq_send_result(sock_num, head->seq, false); // Close socket, report the data that had not acked.
    7a46:	7821      	ldrb	r1, [r4, #0]
    7a48:	2200      	movs	r2, #0
    7a4a:	0038      	movs	r0, r7
    7a4c:	f7ff ff8a 	bl	7964 <report_tcp_seq_send_result>
        node = head->next;
    7a50:	6863      	ldr	r3, [r4, #4]
        irfree(head);
    7a52:	0020      	movs	r0, r4
        node = head->next;
    7a54:	9300      	str	r3, [sp, #0]
        irfree(head);
    7a56:	f00a ffef 	bl	12a38 <irfree>
        head = node;
    7a5a:	9c00      	ldr	r4, [sp, #0]
    7a5c:	e7d6      	b.n	7a0c <close_local_socket+0x2c>
        return NEUL_SOCKET_RET_ERROR;
    7a5e:	2001      	movs	r0, #1
    7a60:	4240      	negs	r0, r0
    7a62:	e7e3      	b.n	7a2c <close_local_socket+0x4c>
    7a64:	01001820 	.word	0x01001820
    7a68:	0100183c 	.word	0x0100183c

00007a6c <socket_init>:
{
    7a6c:	b510      	push	{r4, lr}
    memset(socket_list, 0, sizeof(socket_list));
    7a6e:	221c      	movs	r2, #28
    7a70:	2100      	movs	r1, #0
    7a72:	4809      	ldr	r0, [pc, #36]	; (7a98 <socket_init+0x2c>)
    7a74:	f7f8 fc34 	bl	2e0 <memset>
    memset(tcp_ul_indicator_list, 0, sizeof(tcp_ul_indicator_list));
    7a78:	2100      	movs	r1, #0
    7a7a:	221c      	movs	r2, #28
    7a7c:	4807      	ldr	r0, [pc, #28]	; (7a9c <socket_init+0x30>)
    7a7e:	f7f8 fc2f 	bl	2e0 <memset>
    tcp_ul_indicator_mutex = osMutexNew(NULL);
    7a82:	2000      	movs	r0, #0
    7a84:	f00c ff78 	bl	14978 <osMutexNew>
    7a88:	4b05      	ldr	r3, [pc, #20]	; (7aa0 <socket_init+0x34>)
    7a8a:	1e01      	subs	r1, r0, #0
    7a8c:	6018      	str	r0, [r3, #0]
    if(!tcp_ul_indicator_mutex)
    7a8e:	d102      	bne.n	7a96 <socket_init+0x2a>
        panic(PANIC_LOG, TCP_UL_INDICATOR_MUTEX_NOT_READY);
    7a90:	200d      	movs	r0, #13
    7a92:	f7fa f83d 	bl	1b10 <panic>
}
    7a96:	bd10      	pop	{r4, pc}
    7a98:	01001820 	.word	0x01001820
    7a9c:	0100183c 	.word	0x0100183c
    7aa0:	01001858 	.word	0x01001858

00007aa4 <get_sock_type>:
        return SOCK_NONE;
    7aa4:	2200      	movs	r2, #0
    if ((sock_num >= NUM_SOCKETS) || (socket_list[sock_num] == NULL ))
    7aa6:	2806      	cmp	r0, #6
    7aa8:	d805      	bhi.n	7ab6 <get_sock_type+0x12>
    7aaa:	4904      	ldr	r1, [pc, #16]	; (7abc <get_sock_type+0x18>)
    7aac:	0080      	lsls	r0, r0, #2
    7aae:	5843      	ldr	r3, [r0, r1]
    7ab0:	4293      	cmp	r3, r2
    7ab2:	d000      	beq.n	7ab6 <get_sock_type+0x12>
    return (socket_list[sock_num]->type);
    7ab4:	785a      	ldrb	r2, [r3, #1]
}
    7ab6:	0010      	movs	r0, r2
    7ab8:	4770      	bx	lr
    7aba:	46c0      	nop			; (mov r8, r8)
    7abc:	01001820 	.word	0x01001820

00007ac0 <get_tcp_pending_data_seqs>:
{
    7ac0:	b570      	push	{r4, r5, r6, lr}
    7ac2:	0005      	movs	r5, r0
    7ac4:	000c      	movs	r4, r1
        return false;
    7ac6:	2000      	movs	r0, #0
    if (sock_num >=  NUM_SOCKETS)
    7ac8:	2d06      	cmp	r5, #6
    7aca:	d80b      	bhi.n	7ae4 <get_tcp_pending_data_seqs+0x24>
    tcp_ul_indicator_acquire();
    7acc:	f7ff ff66 	bl	799c <tcp_ul_indicator_acquire>
    node = tcp_ul_indicator_list[sock_num];
    7ad0:	4b0c      	ldr	r3, [pc, #48]	; (7b04 <get_tcp_pending_data_seqs+0x44>)
    7ad2:	00ad      	lsls	r5, r5, #2
    7ad4:	58ea      	ldr	r2, [r5, r3]
            data_seqs[(node->seq / 8)] |= (uint8)((0x80 >> (node->seq % 8)));
    7ad6:	2007      	movs	r0, #7
    7ad8:	2580      	movs	r5, #128	; 0x80
    while (node)
    7ada:	2a00      	cmp	r2, #0
    7adc:	d103      	bne.n	7ae6 <get_tcp_pending_data_seqs+0x26>
    tcp_ul_indicator_release();
    7ade:	f7ff ff6f 	bl	79c0 <tcp_ul_indicator_release>
    return true;
    7ae2:	2001      	movs	r0, #1
}
    7ae4:	bd70      	pop	{r4, r5, r6, pc}
        if (node->seq != 0) //seq 0 won't report to user
    7ae6:	7813      	ldrb	r3, [r2, #0]
    7ae8:	2b00      	cmp	r3, #0
    7aea:	d008      	beq.n	7afe <get_tcp_pending_data_seqs+0x3e>
            data_seqs[(node->seq / 8)] |= (uint8)((0x80 >> (node->seq % 8)));
    7aec:	002e      	movs	r6, r5
    7aee:	08d9      	lsrs	r1, r3, #3
    7af0:	4003      	ands	r3, r0
    7af2:	411e      	asrs	r6, r3
    7af4:	0033      	movs	r3, r6
    7af6:	1861      	adds	r1, r4, r1
    7af8:	780e      	ldrb	r6, [r1, #0]
    7afa:	4333      	orrs	r3, r6
    7afc:	700b      	strb	r3, [r1, #0]
        node = node->next;
    7afe:	6852      	ldr	r2, [r2, #4]
    7b00:	e7eb      	b.n	7ada <get_tcp_pending_data_seqs+0x1a>
    7b02:	46c0      	nop			; (mov r8, r8)
    7b04:	0100183c 	.word	0x0100183c

00007b08 <remote_command_recvfrom>:
{
    7b08:	b5f0      	push	{r4, r5, r6, r7, lr}
    7b0a:	b08b      	sub	sp, #44	; 0x2c
    7b0c:	9100      	str	r1, [sp, #0]
    7b0e:	0015      	movs	r5, r2
    7b10:	001f      	movs	r7, r3
    if (sock_num >= NUM_SOCKETS || sock_address == NULL)
    7b12:	2906      	cmp	r1, #6
    7b14:	d829      	bhi.n	7b6a <remote_command_recvfrom+0x62>
    7b16:	9b11      	ldr	r3, [sp, #68]	; 0x44
    7b18:	2b00      	cmp	r3, #0
    7b1a:	d026      	beq.n	7b6a <remote_command_recvfrom+0x62>
    if (socket_list[sock_num] == NULL)
    7b1c:	4b37      	ldr	r3, [pc, #220]	; (7bfc <remote_command_recvfrom+0xf4>)
    7b1e:	008a      	lsls	r2, r1, #2
    7b20:	58d6      	ldr	r6, [r2, r3]
    7b22:	2e00      	cmp	r6, #0
    7b24:	d021      	beq.n	7b6a <remote_command_recvfrom+0x62>
    memcpy(&sock_addr, (struct sockaddr_storage *)sock_address, sizeof(struct sockaddr_storage));       //lint !e826
    7b26:	221c      	movs	r2, #28
    7b28:	9911      	ldr	r1, [sp, #68]	; 0x44
    7b2a:	a803      	add	r0, sp, #12
    7b2c:	f7f8 fb60 	bl	1f0 <memcpy>
    if ((sock_addr == NULL) || (buffer == NULL) || (sock_entry == NULL))
    7b30:	2f00      	cmp	r7, #0
    7b32:	d01a      	beq.n	7b6a <remote_command_recvfrom+0x62>
    total_message_len = sizeof(message_header_t) + buffer_length;
    7b34:	002b      	movs	r3, r5
    7b36:	3324      	adds	r3, #36	; 0x24
    if ((((data_buffered + total_message_len) > MAX_DATA) || (message_buffered > MAX_MESSAGES)) && (sock_entry->message != NULL))
    7b38:	b29b      	uxth	r3, r3
    7b3a:	9301      	str	r3, [sp, #4]
    7b3c:	4b30      	ldr	r3, [pc, #192]	; (7c00 <remote_command_recvfrom+0xf8>)
    7b3e:	9a01      	ldr	r2, [sp, #4]
    7b40:	681b      	ldr	r3, [r3, #0]
    7b42:	18d3      	adds	r3, r2, r3
    7b44:	4a2f      	ldr	r2, [pc, #188]	; (7c04 <remote_command_recvfrom+0xfc>)
    7b46:	4293      	cmp	r3, r2
    7b48:	dc03      	bgt.n	7b52 <remote_command_recvfrom+0x4a>
    7b4a:	4b2f      	ldr	r3, [pc, #188]	; (7c08 <remote_command_recvfrom+0x100>)
    7b4c:	681b      	ldr	r3, [r3, #0]
    7b4e:	2b0a      	cmp	r3, #10
    7b50:	dd0d      	ble.n	7b6e <remote_command_recvfrom+0x66>
    7b52:	6933      	ldr	r3, [r6, #16]
    7b54:	2b00      	cmp	r3, #0
    7b56:	d00a      	beq.n	7b6e <remote_command_recvfrom+0x66>
        message_dropped++;
    7b58:	4a2c      	ldr	r2, [pc, #176]	; (7c0c <remote_command_recvfrom+0x104>)
    7b5a:	2107      	movs	r1, #7
    7b5c:	6813      	ldr	r3, [r2, #0]
    7b5e:	9800      	ldr	r0, [sp, #0]
    7b60:	3301      	adds	r3, #1
    7b62:	6013      	str	r3, [r2, #0]
    7b64:	002a      	movs	r2, r5
    7b66:	f7ff ff0b 	bl	7980 <socket_status_update.part.0>
}//lint !e818
    7b6a:	b00b      	add	sp, #44	; 0x2c
    7b6c:	bdf0      	pop	{r4, r5, r6, r7, pc}
    msg_hdr = (message_header_t *) irmalloc(sizeof(message_header_t));
    7b6e:	2024      	movs	r0, #36	; 0x24
    7b70:	f00a ff46 	bl	12a00 <irmalloc>
    7b74:	1e04      	subs	r4, r0, #0
    if (msg_hdr == NULL)
    7b76:	d104      	bne.n	7b82 <remote_command_recvfrom+0x7a>
        message_dropped++;
    7b78:	4a24      	ldr	r2, [pc, #144]	; (7c0c <remote_command_recvfrom+0x104>)
    7b7a:	6813      	ldr	r3, [r2, #0]
    7b7c:	3301      	adds	r3, #1
    7b7e:	6013      	str	r3, [r2, #0]
    7b80:	e7f3      	b.n	7b6a <remote_command_recvfrom+0x62>
    msg_hdr->buffer = irmalloc(buffer_length);
    7b82:	0028      	movs	r0, r5
    7b84:	f00a ff3c 	bl	12a00 <irmalloc>
    7b88:	61e0      	str	r0, [r4, #28]
    if (msg_hdr->buffer == NULL)
    7b8a:	2800      	cmp	r0, #0
    7b8c:	d103      	bne.n	7b96 <remote_command_recvfrom+0x8e>
        irfree(msg_hdr);
    7b8e:	0020      	movs	r0, r4
    7b90:	f00a ff52 	bl	12a38 <irfree>
    7b94:	e7e9      	b.n	7b6a <remote_command_recvfrom+0x62>
    memcpy(msg_hdr->buffer, buffer, buffer_length);
    7b96:	0039      	movs	r1, r7
    7b98:	002a      	movs	r2, r5
    7b9a:	f7f8 fb29 	bl	1f0 <memcpy>
    memcpy(&(msg_hdr->src_addr), &(sock_addr->sin_addr), sizeof(ip_addr_t));
    7b9e:	2214      	movs	r2, #20
    7ba0:	a904      	add	r1, sp, #16
    msg_hdr->buffer_length = buffer_length;
    7ba2:	8325      	strh	r5, [r4, #24]
    memcpy(&(msg_hdr->src_addr), &(sock_addr->sin_addr), sizeof(ip_addr_t));
    7ba4:	0020      	movs	r0, r4
    7ba6:	f7f8 fb23 	bl	1f0 <memcpy>
    msg_hdr->src_port = sock_addr->sin_port;
    7baa:	ab02      	add	r3, sp, #8
    7bac:	88db      	ldrh	r3, [r3, #6]
    data_buffered += total_message_len;
    7bae:	4a14      	ldr	r2, [pc, #80]	; (7c00 <remote_command_recvfrom+0xf8>)
    msg_hdr->src_port = sock_addr->sin_port;
    7bb0:	82a3      	strh	r3, [r4, #20]
    data_buffered += total_message_len;
    7bb2:	6811      	ldr	r1, [r2, #0]
    msg_hdr->cur_pos = 0;
    7bb4:	2300      	movs	r3, #0
    data_buffered += total_message_len;
    7bb6:	468c      	mov	ip, r1
    msg_hdr->cur_pos = 0;
    7bb8:	82e3      	strh	r3, [r4, #22]
    msg_hdr->next = NULL;
    7bba:	6223      	str	r3, [r4, #32]
    data_buffered += total_message_len;
    7bbc:	9b01      	ldr	r3, [sp, #4]
    if (sock_entry->message == NULL)
    7bbe:	6937      	ldr	r7, [r6, #16]
    data_buffered += total_message_len;
    7bc0:	4463      	add	r3, ip
    7bc2:	6013      	str	r3, [r2, #0]
    message_buffered++;
    7bc4:	4a10      	ldr	r2, [pc, #64]	; (7c08 <remote_command_recvfrom+0x100>)
    7bc6:	6813      	ldr	r3, [r2, #0]
    7bc8:	3301      	adds	r3, #1
    7bca:	6013      	str	r3, [r2, #0]
    if (sock_entry->message == NULL)
    7bcc:	2f00      	cmp	r7, #0
    7bce:	d109      	bne.n	7be4 <remote_command_recvfrom+0xdc>
        sock_entry->message = msg_hdr;
    7bd0:	6134      	str	r4, [r6, #16]
        if (sock_entry->recv_callback != NULL)
    7bd2:	6874      	ldr	r4, [r6, #4]
    7bd4:	2c00      	cmp	r4, #0
    7bd6:	d0c8      	beq.n	7b6a <remote_command_recvfrom+0x62>
            (sock_entry->recv_callback)(sock_num, buffer_length, (struct sockaddr *) sock_address, sizeof(*sock_address));
    7bd8:	230f      	movs	r3, #15
    7bda:	aa03      	add	r2, sp, #12
    7bdc:	0029      	movs	r1, r5
    7bde:	9800      	ldr	r0, [sp, #0]
    7be0:	47a0      	blx	r4
    7be2:	e7c2      	b.n	7b6a <remote_command_recvfrom+0x62>
        non_os_enter_critical();
    7be4:	f010 fae6 	bl	181b4 <non_os_enter_critical>
        while (msg_ptr->next != NULL)
    7be8:	6a3b      	ldr	r3, [r7, #32]
    7bea:	2b00      	cmp	r3, #0
    7bec:	d103      	bne.n	7bf6 <remote_command_recvfrom+0xee>
        msg_ptr->next = msg_hdr;
    7bee:	623c      	str	r4, [r7, #32]
        non_os_exit_critical();
    7bf0:	f010 faf4 	bl	181dc <non_os_exit_critical>
    7bf4:	e7b9      	b.n	7b6a <remote_command_recvfrom+0x62>
        while (msg_ptr->next != NULL)
    7bf6:	001f      	movs	r7, r3
    7bf8:	e7f6      	b.n	7be8 <remote_command_recvfrom+0xe0>
    7bfa:	46c0      	nop			; (mov r8, r8)
    7bfc:	01001820 	.word	0x01001820
    7c00:	01001810 	.word	0x01001810
    7c04:	000006a4 	.word	0x000006a4
    7c08:	01001818 	.word	0x01001818
    7c0c:	0100181c 	.word	0x0100181c

00007c10 <remote_command_socket_recv>:
{
    7c10:	b537      	push	{r0, r1, r2, r4, r5, lr}
    7c12:	ac06      	add	r4, sp, #24
    7c14:	8824      	ldrh	r4, [r4, #0]
    remote_command_recvfrom(core, sock_num, buffer_length, buffer, sock_address_length, sock_address);
    7c16:	9d07      	ldr	r5, [sp, #28]
    7c18:	9400      	str	r4, [sp, #0]
    7c1a:	9501      	str	r5, [sp, #4]
    7c1c:	f7ff ff74 	bl	7b08 <remote_command_recvfrom>
}
    7c20:	bd37      	pop	{r0, r1, r2, r4, r5, pc}
	...

00007c24 <remote_command_flowcontrol_status>:
{
    7c24:	4b03      	ldr	r3, [pc, #12]	; (7c34 <remote_command_flowcontrol_status+0x10>)
    if (status == FLOWCONTROL_ENABLED)
    7c26:	2901      	cmp	r1, #1
    7c28:	d101      	bne.n	7c2e <remote_command_flowcontrol_status+0xa>
        flowcontrol_enabled = true;
    7c2a:	7019      	strb	r1, [r3, #0]
}
    7c2c:	4770      	bx	lr
        flowcontrol_enabled = false;
    7c2e:	2200      	movs	r2, #0
    7c30:	701a      	strb	r2, [r3, #0]
}
    7c32:	e7fb      	b.n	7c2c <remote_command_flowcontrol_status+0x8>
    7c34:	01001814 	.word	0x01001814

00007c38 <remote_command_socket_notify>:

void remote_command_socket_notify(CORES core, uint16 sock_num, uint16 notify, int arg)
{
    7c38:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
    7c3a:	000e      	movs	r6, r1
    7c3c:	0014      	movs	r4, r2
    7c3e:	001d      	movs	r5, r3
    UNUSED(core);
    if ((sock_num >= NUM_SOCKETS) || (socket_list[sock_num] == NULL))
    7c40:	2906      	cmp	r1, #6
    7c42:	d810      	bhi.n	7c66 <remote_command_socket_notify+0x2e>
    7c44:	4b1d      	ldr	r3, [pc, #116]	; (7cbc <remote_command_socket_notify+0x84>)
    7c46:	008f      	lsls	r7, r1, #2
    7c48:	58fb      	ldr	r3, [r7, r3]
    7c4a:	2b00      	cmp	r3, #0
    7c4c:	d00b      	beq.n	7c66 <remote_command_socket_notify+0x2e>
    7c4e:	b2d1      	uxtb	r1, r2
    7c50:	0030      	movs	r0, r6
    7c52:	002a      	movs	r2, r5
    7c54:	f7ff fe94 	bl	7980 <socket_status_update.part.0>
    }

    // Report notifies from protocol lwip stack.
    socket_status_update(sock_num, (SOCKET_STATUS)notify, arg);

    switch (notify)
    7c58:	2c01      	cmp	r4, #1
    7c5a:	d005      	beq.n	7c68 <remote_command_socket_notify+0x30>
    7c5c:	2c00      	cmp	r4, #0
    7c5e:	d002      	beq.n	7c66 <remote_command_socket_notify+0x2e>
    7c60:	3c03      	subs	r4, #3
    7c62:	2c01      	cmp	r4, #1
    7c64:	d924      	bls.n	7cb0 <remote_command_socket_notify+0x78>
            (void)close_local_socket(sock_num, SOCKET_CLOSE_PASSIVE);
            break;
        default:
            return;
    }
}
    7c66:	bdf7      	pop	{r0, r1, r2, r4, r5, r6, r7, pc}
    tcp_ul_indicator_acquire();
    7c68:	f7ff fe98 	bl	799c <tcp_ul_indicator_acquire>
    head = tcp_ul_indicator_list[sock_num];
    7c6c:	4b14      	ldr	r3, [pc, #80]	; (7cc0 <remote_command_socket_notify+0x88>)
            remove_tcp_seq_from_queue(sock_num, (uint16)arg);
    7c6e:	b2ad      	uxth	r5, r5
    head = tcp_ul_indicator_list[sock_num];
    7c70:	58fc      	ldr	r4, [r7, r3]
    if (head == NULL)
    7c72:	2c00      	cmp	r4, #0
    7c74:	d112      	bne.n	7c9c <remote_command_socket_notify+0x64>
    tcp_ul_indicator_release();
    7c76:	f7ff fea3 	bl	79c0 <tcp_ul_indicator_release>
    7c7a:	e7f4      	b.n	7c66 <remote_command_socket_notify+0x2e>
        if (node->data_len <= acked_len)    //move head to head->next, free the node if the data acked, report the seq send success.
    7c7c:	8863      	ldrh	r3, [r4, #2]
    7c7e:	42ab      	cmp	r3, r5
    7c80:	d811      	bhi.n	7ca6 <remote_command_socket_notify+0x6e>
            acked_len -= node->data_len;
    7c82:	1aed      	subs	r5, r5, r3
            head = node->next;
    7c84:	6863      	ldr	r3, [r4, #4]
            report_tcp_seq_send_result(sock_num, node->seq, true);
    7c86:	7821      	ldrb	r1, [r4, #0]
    7c88:	2201      	movs	r2, #1
    7c8a:	0030      	movs	r0, r6
            head = node->next;
    7c8c:	9301      	str	r3, [sp, #4]
            report_tcp_seq_send_result(sock_num, node->seq, true);
    7c8e:	f7ff fe69 	bl	7964 <report_tcp_seq_send_result>
            irfree(node);
    7c92:	0020      	movs	r0, r4
    7c94:	f00a fed0 	bl	12a38 <irfree>
            head = node->next;
    7c98:	9c01      	ldr	r4, [sp, #4]
            acked_len -= node->data_len;
    7c9a:	b2ad      	uxth	r5, r5
    while (acked_len && node)
    7c9c:	2d00      	cmp	r5, #0
    7c9e:	d004      	beq.n	7caa <remote_command_socket_notify+0x72>
    7ca0:	2c00      	cmp	r4, #0
    7ca2:	d1eb      	bne.n	7c7c <remote_command_socket_notify+0x44>
    7ca4:	e001      	b.n	7caa <remote_command_socket_notify+0x72>
            node->data_len -= acked_len;
    7ca6:	1b5d      	subs	r5, r3, r5
    7ca8:	8065      	strh	r5, [r4, #2]
    tcp_ul_indicator_list[sock_num] = head;
    7caa:	4b05      	ldr	r3, [pc, #20]	; (7cc0 <remote_command_socket_notify+0x88>)
    7cac:	51dc      	str	r4, [r3, r7]
    7cae:	e7e2      	b.n	7c76 <remote_command_socket_notify+0x3e>
            (void)close_local_socket(sock_num, SOCKET_CLOSE_PASSIVE);
    7cb0:	2105      	movs	r1, #5
    7cb2:	0030      	movs	r0, r6
    7cb4:	f7ff fe94 	bl	79e0 <close_local_socket>
            break;
    7cb8:	e7d5      	b.n	7c66 <remote_command_socket_notify+0x2e>
    7cba:	46c0      	nop			; (mov r8, r8)
    7cbc:	01001820 	.word	0x01001820
    7cc0:	0100183c 	.word	0x0100183c

00007cc4 <socket>:

/*
 * Create a socket. If all available sockets are in use, this will return fail
 */
int socket(PROTOCOL_FAMILY domain, SOCKET_TYPE type, PROTOCOL_TYPE protocol)
{
    7cc4:	b5f0      	push	{r4, r5, r6, r7, lr}
    UNUSED(domain);
    uint16 socknum = 0;
    7cc6:	240e      	movs	r4, #14
{
    7cc8:	b087      	sub	sp, #28
    uint16 socknum = 0;
    7cca:	ab02      	add	r3, sp, #8
    7ccc:	18e4      	adds	r4, r4, r3
    7cce:	2300      	movs	r3, #0
    NEUL_RET ret;

    // get socket from protocol core
    if ((command_allocate_socket(domain, type, protocol, (uint8 *) &ret, &socknum) != RPC_ERR_OK) || (ret != NEUL_RET_OK))
    7cd0:	250d      	movs	r5, #13
    uint16 socknum = 0;
    7cd2:	8023      	strh	r3, [r4, #0]
    if ((command_allocate_socket(domain, type, protocol, (uint8 *) &ret, &socknum) != RPC_ERR_OK) || (ret != NEUL_RET_OK))
    7cd4:	ab02      	add	r3, sp, #8
    7cd6:	18ed      	adds	r5, r5, r3
    7cd8:	9400      	str	r4, [sp, #0]
    7cda:	002b      	movs	r3, r5
{
    7cdc:	000f      	movs	r7, r1
    7cde:	9202      	str	r2, [sp, #8]
    if ((command_allocate_socket(domain, type, protocol, (uint8 *) &ret, &socknum) != RPC_ERR_OK) || (ret != NEUL_RET_OK))
    7ce0:	f7fc f8d9 	bl	3e96 <command_allocate_socket>
    7ce4:	2800      	cmp	r0, #0
    7ce6:	d003      	beq.n	7cf0 <socket+0x2c>
    {
        return NEUL_SOCKET_RET_ERROR;
    7ce8:	2001      	movs	r0, #1
    7cea:	4240      	negs	r0, r0
    memset((void*)socket_list[socknum], 0x00, sizeof(socket_entry_t));
    socket_list[socknum]->type = type;
    socket_list[socknum]->protocol = protocol;

    return (int)socknum;
}
    7cec:	b007      	add	sp, #28
    7cee:	bdf0      	pop	{r4, r5, r6, r7, pc}
    if ((command_allocate_socket(domain, type, protocol, (uint8 *) &ret, &socknum) != RPC_ERR_OK) || (ret != NEUL_RET_OK))
    7cf0:	782b      	ldrb	r3, [r5, #0]
    7cf2:	2b00      	cmp	r3, #0
    7cf4:	d1f8      	bne.n	7ce8 <socket+0x24>
    if (socknum >= NUM_SOCKETS || socket_list[socknum] != NULL)
    7cf6:	8826      	ldrh	r6, [r4, #0]
    7cf8:	2e06      	cmp	r6, #6
    7cfa:	d8f5      	bhi.n	7ce8 <socket+0x24>
    7cfc:	4d0f      	ldr	r5, [pc, #60]	; (7d3c <socket+0x78>)
    7cfe:	00b6      	lsls	r6, r6, #2
    7d00:	5973      	ldr	r3, [r6, r5]
    7d02:	9303      	str	r3, [sp, #12]
    7d04:	2b00      	cmp	r3, #0
    7d06:	d1ef      	bne.n	7ce8 <socket+0x24>
    socket_list[socknum] = irmalloc(sizeof(socket_entry_t));
    7d08:	2014      	movs	r0, #20
    7d0a:	f00a fe79 	bl	12a00 <irmalloc>
    if (socket_list[socknum] == NULL)
    7d0e:	8823      	ldrh	r3, [r4, #0]
    socket_list[socknum] = irmalloc(sizeof(socket_entry_t));
    7d10:	5170      	str	r0, [r6, r5]
    if (socket_list[socknum] == NULL)
    7d12:	009b      	lsls	r3, r3, #2
    7d14:	5958      	ldr	r0, [r3, r5]
    7d16:	2800      	cmp	r0, #0
    7d18:	d0e6      	beq.n	7ce8 <socket+0x24>
    memset((void*)socket_list[socknum], 0x00, sizeof(socket_entry_t));
    7d1a:	2214      	movs	r2, #20
    7d1c:	9903      	ldr	r1, [sp, #12]
    7d1e:	f7f8 fadf 	bl	2e0 <memset>
    socket_list[socknum]->protocol = protocol;
    7d22:	466a      	mov	r2, sp
    socket_list[socknum]->type = type;
    7d24:	8823      	ldrh	r3, [r4, #0]
    socket_list[socknum]->protocol = protocol;
    7d26:	7a12      	ldrb	r2, [r2, #8]
    socket_list[socknum]->type = type;
    7d28:	009b      	lsls	r3, r3, #2
    7d2a:	595b      	ldr	r3, [r3, r5]
    7d2c:	705f      	strb	r7, [r3, #1]
    socket_list[socknum]->protocol = protocol;
    7d2e:	8823      	ldrh	r3, [r4, #0]
    7d30:	009b      	lsls	r3, r3, #2
    7d32:	595b      	ldr	r3, [r3, r5]
    7d34:	701a      	strb	r2, [r3, #0]
    return (int)socknum;
    7d36:	8820      	ldrh	r0, [r4, #0]
    7d38:	e7d8      	b.n	7cec <socket+0x28>
    7d3a:	46c0      	nop			; (mov r8, r8)
    7d3c:	01001820 	.word	0x01001820

00007d40 <neul_bind>:

/*
 * Bind a socket to a port. The notify callback can be null, or a pointer to a callback
 */
int neul_bind(int sock_num, const struct sockaddr *sock_address, socklen_t sock_len, socket_recv_notify_fn socket_notify_callback)
{
    7d40:	b5f0      	push	{r4, r5, r6, r7, lr}
    UNUSED(sock_len);
    NEUL_RET ret;

     // check it's been opened
    if ((socket_list[sock_num] == NULL) || (sock_address == NULL))
    7d42:	4c0f      	ldr	r4, [pc, #60]	; (7d80 <neul_bind+0x40>)
{
    7d44:	b085      	sub	sp, #20
    if ((socket_list[sock_num] == NULL) || (sock_address == NULL))
    7d46:	0085      	lsls	r5, r0, #2
{
    7d48:	9301      	str	r3, [sp, #4]
    if ((socket_list[sock_num] == NULL) || (sock_address == NULL))
    7d4a:	592b      	ldr	r3, [r5, r4]
{
    7d4c:	000f      	movs	r7, r1
    if ((socket_list[sock_num] == NULL) || (sock_address == NULL))
    7d4e:	2b00      	cmp	r3, #0
    7d50:	d103      	bne.n	7d5a <neul_bind+0x1a>
    {
        return NEUL_SOCKET_RET_ERROR;
    7d52:	2001      	movs	r0, #1
    7d54:	4240      	negs	r0, r0
    }

    socket_list[sock_num]->recv_callback = socket_notify_callback;

    return NEUL_SOCKET_RET_OK;
}
    7d56:	b005      	add	sp, #20
    7d58:	bdf0      	pop	{r4, r5, r6, r7, pc}
    if ((socket_list[sock_num] == NULL) || (sock_address == NULL))
    7d5a:	2900      	cmp	r1, #0
    7d5c:	d0f9      	beq.n	7d52 <neul_bind+0x12>
    if(command_neul_bind((uint16) sock_num, sock_len, (uint8 *) sock_address, (uint8 *) &ret) != RPC_ERR_OK || ret != NEUL_RET_OK)
    7d5e:	ab02      	add	r3, sp, #8
    7d60:	1dde      	adds	r6, r3, #7
    7d62:	b291      	uxth	r1, r2
    7d64:	b280      	uxth	r0, r0
    7d66:	0033      	movs	r3, r6
    7d68:	003a      	movs	r2, r7
    7d6a:	f7fc f8fb 	bl	3f64 <command_neul_bind>
    7d6e:	2800      	cmp	r0, #0
    7d70:	d1ef      	bne.n	7d52 <neul_bind+0x12>
    7d72:	7830      	ldrb	r0, [r6, #0]
    7d74:	2800      	cmp	r0, #0
    7d76:	d1ec      	bne.n	7d52 <neul_bind+0x12>
    socket_list[sock_num]->recv_callback = socket_notify_callback;
    7d78:	592b      	ldr	r3, [r5, r4]
    7d7a:	9a01      	ldr	r2, [sp, #4]
    7d7c:	605a      	str	r2, [r3, #4]
    return NEUL_SOCKET_RET_OK;
    7d7e:	e7ea      	b.n	7d56 <neul_bind+0x16>
    7d80:	01001820 	.word	0x01001820

00007d84 <connect>:
 * @param dest_addr remote ip address to connect
 * @param dest_addr_length The lenght of socket address
 * @return NEUL_SOCKET_RET_OK or NEUL_SOCKET_RET_ERROR for error
 */
ssize_t connect(int sock_num, const struct sockaddr *dest_addr, uint16 dest_addr_length)
{
    7d84:	b537      	push	{r0, r1, r2, r4, r5, lr}
    7d86:	000d      	movs	r5, r1
    7d88:	0011      	movs	r1, r2
    NEUL_RET ret;

    if ((dest_addr == NULL) || (dest_addr_length == 0))
    7d8a:	2d00      	cmp	r5, #0
    7d8c:	d011      	beq.n	7db2 <connect+0x2e>
    7d8e:	2a00      	cmp	r2, #0
    7d90:	d00f      	beq.n	7db2 <connect+0x2e>
    {
        return NEUL_SOCKET_RET_ERROR;
    }

    if (command_socket_connect((uint16)sock_num, dest_addr_length, (uint8*)dest_addr, (uint8*)&ret) != RPC_ERR_OK || ret != NEUL_RET_OK)
    7d92:	466b      	mov	r3, sp
    7d94:	1ddc      	adds	r4, r3, #7
    7d96:	b280      	uxth	r0, r0
    7d98:	0023      	movs	r3, r4
    7d9a:	002a      	movs	r2, r5
    7d9c:	f7fc f9c5 	bl	412a <command_socket_connect>
    7da0:	2800      	cmp	r0, #0
    7da2:	d102      	bne.n	7daa <connect+0x26>
    7da4:	7823      	ldrb	r3, [r4, #0]
    7da6:	2b00      	cmp	r3, #0
    7da8:	d005      	beq.n	7db6 <connect+0x32>
    {
        if (ret == NEUL_RET_PROTOCOL_FAMILY_UNMATCHING)
    7daa:	7823      	ldrb	r3, [r4, #0]
        {
            return NEUL_SOCKET_RET_NO_NETWORK_SERVICE;
    7dac:	2004      	movs	r0, #4
        if (ret == NEUL_RET_PROTOCOL_FAMILY_UNMATCHING)
    7dae:	2b22      	cmp	r3, #34	; 0x22
    7db0:	d000      	beq.n	7db4 <connect+0x30>
        }
        return NEUL_SOCKET_RET_ERROR;
    7db2:	2001      	movs	r0, #1
            return NEUL_SOCKET_RET_NO_NETWORK_SERVICE;
    7db4:	4240      	negs	r0, r0
    }

    return NEUL_SOCKET_RET_OK;
}
    7db6:	bd3e      	pop	{r1, r2, r3, r4, r5, pc}

00007db8 <sendto_with_indication>:
 * @param dest_len    length of destination socket
 * @param flags       controls aspects of operation. no flags specified so far
 * @return number of bytes of data transmitted in buffer, 0 if no data is available, and NEUL_SOCKET_RET_ERROR if there is an error
 */
ssize_t sendto_with_indication(int sock_num, uint8 seq_num, const void *message, size_t length, SOCK_MSG_FLAG flags, const struct sockaddr *dest_addr, socklen_t dest_len)
{
    7db8:	b5f0      	push	{r4, r5, r6, r7, lr}
    7dba:	b087      	sub	sp, #28
    7dbc:	001c      	movs	r4, r3
    7dbe:	ab0c      	add	r3, sp, #48	; 0x30
    7dc0:	881f      	ldrh	r7, [r3, #0]
    7dc2:	ab0e      	add	r3, sp, #56	; 0x38
    7dc4:	468c      	mov	ip, r1
    7dc6:	781b      	ldrb	r3, [r3, #0]
    NEUL_RET ret;

    if ((message == NULL) || (dest_addr == NULL) || (length == 0) || (dest_len == 0))
    7dc8:	2a00      	cmp	r2, #0
    7dca:	d02a      	beq.n	7e22 <sendto_with_indication+0x6a>
    7dcc:	9d0d      	ldr	r5, [sp, #52]	; 0x34
    7dce:	2d00      	cmp	r5, #0
    7dd0:	d027      	beq.n	7e22 <sendto_with_indication+0x6a>
    7dd2:	2c00      	cmp	r4, #0
    7dd4:	d025      	beq.n	7e22 <sendto_with_indication+0x6a>
    7dd6:	2b00      	cmp	r3, #0
    7dd8:	d023      	beq.n	7e22 <sendto_with_indication+0x6a>
    {
        return NEUL_SOCKET_RET_ERROR;
    }

    if (flowcontrol_enabled)
    7dda:	4d13      	ldr	r5, [pc, #76]	; (7e28 <sendto_with_indication+0x70>)
    7ddc:	782d      	ldrb	r5, [r5, #0]
    7dde:	2d00      	cmp	r5, #0
    7de0:	d003      	beq.n	7dea <sendto_with_indication+0x32>
    {
        return NEUL_SOCKET_RET_FLOWCONTROL;
    7de2:	2002      	movs	r0, #2
        {
            return NEUL_SOCKET_RET_DATA_SEQUENCE_REPEAT_ERROR;
        }
        else if (ret == NEUL_RET_PROTOCOL_FAMILY_UNMATCHING)
        {
            return NEUL_SOCKET_RET_NO_NETWORK_SERVICE;
    7de4:	4240      	negs	r0, r0
        }
        return NEUL_SOCKET_RET_ERROR;
    }

    return (ssize_t) length;
}
    7de6:	b007      	add	sp, #28
    7de8:	bdf0      	pop	{r4, r5, r6, r7, pc}
    if((command_sendto((uint16) sock_num, (uint16) length, (uint8 *) message, seq_num, flags, dest_len, (uint8 *) dest_addr, (uint8 *) &ret) != RPC_ERR_OK) || ret != NEUL_RET_OK)
    7dea:	2517      	movs	r5, #23
    7dec:	990d      	ldr	r1, [sp, #52]	; 0x34
    7dee:	b2a6      	uxth	r6, r4
    7df0:	446d      	add	r5, sp
    7df2:	9102      	str	r1, [sp, #8]
    7df4:	9301      	str	r3, [sp, #4]
    7df6:	b280      	uxth	r0, r0
    7df8:	9503      	str	r5, [sp, #12]
    7dfa:	9700      	str	r7, [sp, #0]
    7dfc:	4663      	mov	r3, ip
    7dfe:	0031      	movs	r1, r6
    7e00:	f7fc f8e6 	bl	3fd0 <command_sendto>
    7e04:	2800      	cmp	r0, #0
    7e06:	d103      	bne.n	7e10 <sendto_with_indication+0x58>
    7e08:	782b      	ldrb	r3, [r5, #0]
    return (ssize_t) length;
    7e0a:	0020      	movs	r0, r4
    if((command_sendto((uint16) sock_num, (uint16) length, (uint8 *) message, seq_num, flags, dest_len, (uint8 *) dest_addr, (uint8 *) &ret) != RPC_ERR_OK) || ret != NEUL_RET_OK)
    7e0c:	2b00      	cmp	r3, #0
    7e0e:	d0ea      	beq.n	7de6 <sendto_with_indication+0x2e>
        if (ret == NEUL_RET_FLOW_CONTROL)
    7e10:	782b      	ldrb	r3, [r5, #0]
    7e12:	2b08      	cmp	r3, #8
    7e14:	d0e5      	beq.n	7de2 <sendto_with_indication+0x2a>
            return NEUL_SOCKET_RET_DATA_SEQUENCE_REPEAT_ERROR;
    7e16:	2003      	movs	r0, #3
        else if (ret == NEUL_RET_DATA_SEQUENCE_REPEAT_ERROR)
    7e18:	2b1e      	cmp	r3, #30
    7e1a:	d0e3      	beq.n	7de4 <sendto_with_indication+0x2c>
            return NEUL_SOCKET_RET_NO_NETWORK_SERVICE;
    7e1c:	2004      	movs	r0, #4
        else if (ret == NEUL_RET_PROTOCOL_FAMILY_UNMATCHING)
    7e1e:	2b22      	cmp	r3, #34	; 0x22
    7e20:	d0e0      	beq.n	7de4 <sendto_with_indication+0x2c>
        return NEUL_SOCKET_RET_ERROR;
    7e22:	2001      	movs	r0, #1
    7e24:	e7de      	b.n	7de4 <sendto_with_indication+0x2c>
    7e26:	46c0      	nop			; (mov r8, r8)
    7e28:	01001814 	.word	0x01001814

00007e2c <sendto>:
{
    7e2c:	b530      	push	{r4, r5, lr}
    7e2e:	b085      	sub	sp, #20
    7e30:	ac08      	add	r4, sp, #32
    7e32:	cc20      	ldmia	r4!, {r5}
    7e34:	7824      	ldrb	r4, [r4, #0]
    return sendto_with_indication(sock_num, 0, message, length, flags, dest_addr, dest_len);
    7e36:	9300      	str	r3, [sp, #0]
    7e38:	9402      	str	r4, [sp, #8]
    7e3a:	0013      	movs	r3, r2
    7e3c:	9501      	str	r5, [sp, #4]
    7e3e:	000a      	movs	r2, r1
    7e40:	2100      	movs	r1, #0
    7e42:	f7ff ffb9 	bl	7db8 <sendto_with_indication>
}
    7e46:	b005      	add	sp, #20
    7e48:	bd30      	pop	{r4, r5, pc}

00007e4a <send>:
 * @param length length of data to be sent
 * @param flags  controls aspects of operation. no flags specified so far
 * @return number of bytes of data transmitted in buffer, 0 if no data is available, and -1 if there is an error
 */
ssize_t send(int sock_num, const void *message, size_t length, SOCK_MSG_FLAG flags)
{
    7e4a:	b57f      	push	{r0, r1, r2, r3, r4, r5, r6, lr}
    7e4c:	0014      	movs	r4, r2
    NEUL_RET ret;

    if ((message == NULL) || (length == 0) || (sock_num >= NUM_SOCKETS))
    7e4e:	2900      	cmp	r1, #0
    7e50:	d016      	beq.n	7e80 <send+0x36>
    7e52:	2a00      	cmp	r2, #0
    7e54:	d014      	beq.n	7e80 <send+0x36>
    7e56:	2806      	cmp	r0, #6
    7e58:	dc12      	bgt.n	7e80 <send+0x36>
    {
        return NEUL_SOCKET_RET_ERROR;
    }

    if ((command_socket_send((uint16)sock_num, (uint16)length, (uint8*)message, (uint16)flags, (uint8*)&ret) != RPC_ERR_OK) || (ret != NEUL_RET_OK))
    7e5a:	250f      	movs	r5, #15
    7e5c:	b296      	uxth	r6, r2
    7e5e:	446d      	add	r5, sp
    7e60:	000a      	movs	r2, r1
    7e62:	b280      	uxth	r0, r0
    7e64:	9500      	str	r5, [sp, #0]
    7e66:	0031      	movs	r1, r6
    7e68:	f7fc f923 	bl	40b2 <command_socket_send>
    7e6c:	2800      	cmp	r0, #0
    7e6e:	d103      	bne.n	7e78 <send+0x2e>
    7e70:	782b      	ldrb	r3, [r5, #0]
        }

        return NEUL_SOCKET_RET_ERROR;
    }

    return (ssize_t)length;
    7e72:	0020      	movs	r0, r4
    if ((command_socket_send((uint16)sock_num, (uint16)length, (uint8*)message, (uint16)flags, (uint8*)&ret) != RPC_ERR_OK) || (ret != NEUL_RET_OK))
    7e74:	2b00      	cmp	r3, #0
    7e76:	d005      	beq.n	7e84 <send+0x3a>
        if (ret == NEUL_RET_FLOW_CONTROL)
    7e78:	782b      	ldrb	r3, [r5, #0]
            return NEUL_SOCKET_RET_FLOWCONTROL;
    7e7a:	2002      	movs	r0, #2
        if (ret == NEUL_RET_FLOW_CONTROL)
    7e7c:	2b08      	cmp	r3, #8
    7e7e:	d000      	beq.n	7e82 <send+0x38>
        return NEUL_SOCKET_RET_ERROR;
    7e80:	2001      	movs	r0, #1
            return NEUL_SOCKET_RET_FLOWCONTROL;
    7e82:	4240      	negs	r0, r0
}
    7e84:	b004      	add	sp, #16
    7e86:	bd70      	pop	{r4, r5, r6, pc}

00007e88 <send_with_indication>:
{
    7e88:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
    7e8a:	001c      	movs	r4, r3
    7e8c:	ab08      	add	r3, sp, #32
    7e8e:	881b      	ldrh	r3, [r3, #0]
    7e90:	0006      	movs	r6, r0
    7e92:	000d      	movs	r5, r1
    7e94:	9200      	str	r2, [sp, #0]
    7e96:	9301      	str	r3, [sp, #4]
    if ((message == NULL) || (length == 0) || (sock_num >= NUM_SOCKETS))
    7e98:	2a00      	cmp	r2, #0
    7e9a:	d03b      	beq.n	7f14 <send_with_indication+0x8c>
    7e9c:	2c00      	cmp	r4, #0
    7e9e:	d039      	beq.n	7f14 <send_with_indication+0x8c>
    7ea0:	2806      	cmp	r0, #6
    7ea2:	dc37      	bgt.n	7f14 <send_with_indication+0x8c>
    tcp_ul_indicator_acquire();
    7ea4:	f7ff fd7a 	bl	799c <tcp_ul_indicator_acquire>
    7ea8:	b2b3      	uxth	r3, r6
    node = tcp_ul_indicator_list[sock_num];
    7eaa:	009f      	lsls	r7, r3, #2
    7eac:	4b1b      	ldr	r3, [pc, #108]	; (7f1c <send_with_indication+0x94>)
    7eae:	58fb      	ldr	r3, [r7, r3]
    while (node)
    7eb0:	2b00      	cmp	r3, #0
    7eb2:	d11e      	bne.n	7ef2 <send_with_indication+0x6a>
    tcp_ul_indicator_release();
    7eb4:	f7ff fd84 	bl	79c0 <tcp_ul_indicator_release>
    ret = send(sock_num, message, length, flags);
    7eb8:	9b01      	ldr	r3, [sp, #4]
    7eba:	0022      	movs	r2, r4
    7ebc:	9900      	ldr	r1, [sp, #0]
    7ebe:	0030      	movs	r0, r6
    7ec0:	f7ff ffc3 	bl	7e4a <send>
    if (ret < 0)
    7ec4:	2800      	cmp	r0, #0
    7ec6:	db13      	blt.n	7ef0 <send_with_indication+0x68>
    node = (tcp_indicator_t*)irmalloc(sizeof(tcp_indicator_t));
    7ec8:	2008      	movs	r0, #8
    7eca:	f00a fd99 	bl	12a00 <irmalloc>
    7ece:	1e06      	subs	r6, r0, #0
    if (node == NULL)
    7ed0:	d00d      	beq.n	7eee <send_with_indication+0x66>
    node->next = NULL;
    7ed2:	2300      	movs	r3, #0
    node->data_len = send_len;
    7ed4:	8044      	strh	r4, [r0, #2]
    node->next = NULL;
    7ed6:	6043      	str	r3, [r0, #4]
    node->seq = seq;
    7ed8:	7005      	strb	r5, [r0, #0]
    tcp_ul_indicator_acquire();
    7eda:	f7ff fd5f 	bl	799c <tcp_ul_indicator_acquire>
    head = tcp_ul_indicator_list[sock_num];
    7ede:	4b0f      	ldr	r3, [pc, #60]	; (7f1c <send_with_indication+0x94>)
    7ee0:	59db      	ldr	r3, [r3, r7]
    if (head == NULL)
    7ee2:	2b00      	cmp	r3, #0
    7ee4:	d111      	bne.n	7f0a <send_with_indication+0x82>
        tcp_ul_indicator_list[sock_num] = node; // store node as head
    7ee6:	4b0d      	ldr	r3, [pc, #52]	; (7f1c <send_with_indication+0x94>)
    7ee8:	51de      	str	r6, [r3, r7]
    tcp_ul_indicator_release();
    7eea:	f7ff fd69 	bl	79c0 <tcp_ul_indicator_release>
    return (ssize_t)length;
    7eee:	0020      	movs	r0, r4
}
    7ef0:	bdfe      	pop	{r1, r2, r3, r4, r5, r6, r7, pc}
        if (node->seq == seq)
    7ef2:	781a      	ldrb	r2, [r3, #0]
    7ef4:	42aa      	cmp	r2, r5
    7ef6:	d105      	bne.n	7f04 <send_with_indication+0x7c>
            tcp_ul_indicator_release();
    7ef8:	f7ff fd62 	bl	79c0 <tcp_ul_indicator_release>
    if (!is_tcp_seq_available((uint16)sock_num, seq_num) && (seq_num != 0)) // seq 0 would be use many times, but won't report to user if the data is acked.
    7efc:	2d00      	cmp	r5, #0
    7efe:	d0db      	beq.n	7eb8 <send_with_indication+0x30>
        return NEUL_SOCKET_RET_DATA_SEQUENCE_REPEAT_ERROR;
    7f00:	2003      	movs	r0, #3
    7f02:	e008      	b.n	7f16 <send_with_indication+0x8e>
        node= node->next;
    7f04:	685b      	ldr	r3, [r3, #4]
    7f06:	e7d3      	b.n	7eb0 <send_with_indication+0x28>
        while (head->next != NULL)
    7f08:	0013      	movs	r3, r2
    7f0a:	685a      	ldr	r2, [r3, #4]
    7f0c:	2a00      	cmp	r2, #0
    7f0e:	d1fb      	bne.n	7f08 <send_with_indication+0x80>
        head->next = node;
    7f10:	605e      	str	r6, [r3, #4]
    7f12:	e7ea      	b.n	7eea <send_with_indication+0x62>
        return NEUL_SOCKET_RET_ERROR;
    7f14:	2001      	movs	r0, #1
        return NEUL_SOCKET_RET_DATA_SEQUENCE_REPEAT_ERROR;
    7f16:	4240      	negs	r0, r0
    7f18:	e7ea      	b.n	7ef0 <send_with_indication+0x68>
    7f1a:	46c0      	nop			; (mov r8, r8)
    7f1c:	0100183c 	.word	0x0100183c

00007f20 <recvfrom>:
 * @param length length of buffer
 * @param flags  controls aspects of operation. e.g. Block/Non-Block operation
 * @return number of bytes of data returned in buffer, 0 if no data is available, and -1 if there is an error
 */
ssize_t recvfrom(int sock_num, void *buffer, size_t length, SOCK_MSG_FLAG flags,  struct sockaddr *src_addr, socklen_t src_len)
{
    7f20:	b5f0      	push	{r4, r5, r6, r7, lr}
    7f22:	000b      	movs	r3, r1
    7f24:	b087      	sub	sp, #28
    7f26:	0006      	movs	r6, r0
    uint16 ret_len;
    uint8 *data;
    struct sockaddr_in *src_addr_in = (struct sockaddr_in *) src_addr;    //lint !e740 !e826 sockaddr is an anonymous union
    struct sockaddr_in notify_addr;

    if ((sock_num < 0) || (sock_num >= NUM_SOCKETS))
    7f28:	2806      	cmp	r0, #6
    7f2a:	d857      	bhi.n	7fdc <recvfrom+0xbc>
    {
        return NEUL_SOCKET_RET_ERROR;
    }

    socket_entry_t *sock_entry = socket_list[sock_num];
    7f2c:	492d      	ldr	r1, [pc, #180]	; (7fe4 <recvfrom+0xc4>)
    7f2e:	0080      	lsls	r0, r0, #2
    7f30:	5845      	ldr	r5, [r0, r1]
    // socket not allocated. Make an assert as can't reach
    if ((sock_entry == NULL) || (buffer == NULL))
    7f32:	2d00      	cmp	r5, #0
    7f34:	d052      	beq.n	7fdc <recvfrom+0xbc>
    7f36:	2b00      	cmp	r3, #0
    7f38:	d050      	beq.n	7fdc <recvfrom+0xbc>
    {
        return NEUL_SOCKET_RET_ERROR;
    }

    // check if any messages are present
    if (sock_entry->message == NULL)
    7f3a:	692c      	ldr	r4, [r5, #16]
    {
        return 0;
    7f3c:	1e20      	subs	r0, r4, #0
    if (sock_entry->message == NULL)
    7f3e:	d04b      	beq.n	7fd8 <recvfrom+0xb8>
    }

    msg_hdr = sock_entry->message;

    if ((msg_hdr == NULL) || (msg_hdr->buffer == NULL))
    7f40:	69e1      	ldr	r1, [r4, #28]
    7f42:	2900      	cmp	r1, #0
    7f44:	d04a      	beq.n	7fdc <recvfrom+0xbc>
    {
        return NEUL_SOCKET_RET_ERROR;
    }

    // assert: ret_len must always be positive
    if (msg_hdr->cur_pos > msg_hdr->buffer_length)
    7f46:	8ae0      	ldrh	r0, [r4, #22]
    7f48:	4684      	mov	ip, r0
    7f4a:	8b20      	ldrh	r0, [r4, #24]
    7f4c:	4584      	cmp	ip, r0
    7f4e:	d845      	bhi.n	7fdc <recvfrom+0xbc>
    {
        return NEUL_SOCKET_RET_ERROR;
    }

    ret_len = msg_hdr->buffer_length - msg_hdr->cur_pos;
    7f50:	4667      	mov	r7, ip
    7f52:	1bc0      	subs	r0, r0, r7
    7f54:	b287      	uxth	r7, r0
    data = msg_hdr->buffer;

    if (ret_len > length)   // more data than buffer
    7f56:	4297      	cmp	r7, r2
    7f58:	d900      	bls.n	7f5c <recvfrom+0x3c>
    {
        ret_len = (uint16) length;
    7f5a:	b297      	uxth	r7, r2
    }

    memcpy((char *) buffer, (char *) (data + msg_hdr->cur_pos), ret_len);
    7f5c:	0018      	movs	r0, r3
    7f5e:	4461      	add	r1, ip
    7f60:	003a      	movs	r2, r7
    7f62:	f7f8 f945 	bl	1f0 <memcpy>
    msg_hdr->cur_pos += ret_len;
    7f66:	8ae3      	ldrh	r3, [r4, #22]
    7f68:	18fb      	adds	r3, r7, r3
    7f6a:	82e3      	strh	r3, [r4, #22]

    if(src_addr_in)
    7f6c:	9b0c      	ldr	r3, [sp, #48]	; 0x30
    7f6e:	2b00      	cmp	r3, #0
    7f70:	d007      	beq.n	7f82 <recvfrom+0x62>
    {
        memcpy(&(src_addr_in->sin_addr), &(msg_hdr->src_addr),sizeof(ip_addr_t));
    7f72:	1d18      	adds	r0, r3, #4
    7f74:	2214      	movs	r2, #20
    7f76:	0021      	movs	r1, r4
    7f78:	f7f8 f93a 	bl	1f0 <memcpy>
        src_addr_in->sin_port = msg_hdr->src_port;
    7f7c:	8aa3      	ldrh	r3, [r4, #20]
    7f7e:	9a0c      	ldr	r2, [sp, #48]	; 0x30
    7f80:	8053      	strh	r3, [r2, #2]
    }

    if (msg_hdr->cur_pos == msg_hdr->buffer_length)
    7f82:	8ae2      	ldrh	r2, [r4, #22]
    7f84:	8b23      	ldrh	r3, [r4, #24]
    7f86:	4293      	cmp	r3, r2
    7f88:	d125      	bne.n	7fd6 <recvfrom+0xb6>
    {
        data_buffered -= (int) sizeof(message_header_t) + (int) (msg_hdr->buffer_length);
    7f8a:	4a17      	ldr	r2, [pc, #92]	; (7fe8 <recvfrom+0xc8>)
    7f8c:	3324      	adds	r3, #36	; 0x24
    7f8e:	6811      	ldr	r1, [r2, #0]
        message_buffered--;
        irfree(msg_hdr->buffer);
    7f90:	69e0      	ldr	r0, [r4, #28]
        data_buffered -= (int) sizeof(message_header_t) + (int) (msg_hdr->buffer_length);
    7f92:	1acb      	subs	r3, r1, r3
    7f94:	6013      	str	r3, [r2, #0]
        message_buffered--;
    7f96:	4a15      	ldr	r2, [pc, #84]	; (7fec <recvfrom+0xcc>)
    7f98:	6813      	ldr	r3, [r2, #0]
    7f9a:	3b01      	subs	r3, #1
    7f9c:	6013      	str	r3, [r2, #0]
        irfree(msg_hdr->buffer);
    7f9e:	f00a fd4b 	bl	12a38 <irfree>
        sock_entry->message = msg_hdr->next;
    7fa2:	6a23      	ldr	r3, [r4, #32]
        irfree(msg_hdr);
    7fa4:	0020      	movs	r0, r4
        sock_entry->message = msg_hdr->next;
    7fa6:	612b      	str	r3, [r5, #16]
        irfree(msg_hdr);
    7fa8:	f00a fd46 	bl	12a38 <irfree>

        if ((sock_entry->message != NULL) && (sock_entry->recv_callback != NULL))
    7fac:	692c      	ldr	r4, [r5, #16]
    7fae:	2c00      	cmp	r4, #0
    7fb0:	d011      	beq.n	7fd6 <recvfrom+0xb6>
    7fb2:	686b      	ldr	r3, [r5, #4]
    7fb4:	2b00      	cmp	r3, #0
    7fb6:	d00e      	beq.n	7fd6 <recvfrom+0xb6>
        {
        /* new message so shout */

            msg_hdr=sock_entry->message;

            memcpy(&(notify_addr.sin_addr), &(msg_hdr->src_addr),sizeof(ip_addr_t));
    7fb8:	0021      	movs	r1, r4
    7fba:	2214      	movs	r2, #20
    7fbc:	a801      	add	r0, sp, #4
    7fbe:	f7f8 f917 	bl	1f0 <memcpy>
            notify_addr.sin_port = msg_hdr->src_port;
    7fc2:	466a      	mov	r2, sp
    7fc4:	8aa3      	ldrh	r3, [r4, #20]

            (sock_entry->recv_callback)(sock_num, (msg_hdr->buffer_length - msg_hdr->cur_pos), (struct sockaddr *) &(notify_addr), sizeof(notify_addr));    //lint !e740 !e826
    7fc6:	0030      	movs	r0, r6
            notify_addr.sin_port = msg_hdr->src_port;
    7fc8:	8053      	strh	r3, [r2, #2]
            (sock_entry->recv_callback)(sock_num, (msg_hdr->buffer_length - msg_hdr->cur_pos), (struct sockaddr *) &(notify_addr), sizeof(notify_addr));    //lint !e740 !e826
    7fca:	8ae3      	ldrh	r3, [r4, #22]
    7fcc:	8b21      	ldrh	r1, [r4, #24]
    7fce:	686c      	ldr	r4, [r5, #4]
    7fd0:	1ac9      	subs	r1, r1, r3
    7fd2:	2318      	movs	r3, #24
    7fd4:	47a0      	blx	r4
        }
    }
    return (ssize_t) ret_len;
    7fd6:	0038      	movs	r0, r7
}
    7fd8:	b007      	add	sp, #28
    7fda:	bdf0      	pop	{r4, r5, r6, r7, pc}
        return NEUL_SOCKET_RET_ERROR;
    7fdc:	2001      	movs	r0, #1
    7fde:	4240      	negs	r0, r0
    7fe0:	e7fa      	b.n	7fd8 <recvfrom+0xb8>
    7fe2:	46c0      	nop			; (mov r8, r8)
    7fe4:	01001820 	.word	0x01001820
    7fe8:	01001810 	.word	0x01001810
    7fec:	01001818 	.word	0x01001818

00007ff0 <close_socket>:
 /** @brief Close a socket between protocol and application.
  * @param sock_num socket number from socket()
  * @return NEUL_SOCKET_RET_OK or NEUL_SOCKET_RET_ERROR for error
  */
int close_socket(int sock_num)
{
    7ff0:	b537      	push	{r0, r1, r2, r4, r5, lr}
    NEUL_RET ret;

    if ((command_close_socket((uint16)sock_num, (uint8 *) &ret) != RPC_ERR_OK) || ret != NEUL_RET_OK)
    7ff2:	466b      	mov	r3, sp
    7ff4:	b284      	uxth	r4, r0
    7ff6:	1ddd      	adds	r5, r3, #7
    7ff8:	0029      	movs	r1, r5
    7ffa:	0020      	movs	r0, r4
    7ffc:	f7fb ff88 	bl	3f10 <command_close_socket>
    8000:	2800      	cmp	r0, #0
    8002:	d107      	bne.n	8014 <close_socket+0x24>
    8004:	782b      	ldrb	r3, [r5, #0]
    8006:	2b00      	cmp	r3, #0
    8008:	d104      	bne.n	8014 <close_socket+0x24>
    {
        return NEUL_SOCKET_RET_ERROR;
    }

    return close_local_socket((uint16)sock_num, SOCKET_CLOSE_PROACTIVE);
    800a:	2106      	movs	r1, #6
    800c:	0020      	movs	r0, r4
    800e:	f7ff fce7 	bl	79e0 <close_local_socket>
}
    8012:	bd3e      	pop	{r1, r2, r3, r4, r5, pc}
        return NEUL_SOCKET_RET_ERROR;
    8014:	2001      	movs	r0, #1
    8016:	4240      	negs	r0, r0
    8018:	e7fb      	b.n	8012 <close_socket+0x22>
	...

0000801c <socklen>:
int socklen(int sock_num)
{
    socket_entry_t *sock_entry;
    message_header_t *msg_hdr;

    if ((sock_num < 0) || (sock_num >= NUM_SOCKETS))
    801c:	2806      	cmp	r0, #6
    801e:	d80e      	bhi.n	803e <socklen+0x22>
    {
        return NEUL_SOCKET_RET_ERROR;
    }

    sock_entry = socket_list[sock_num];
    8020:	4b08      	ldr	r3, [pc, #32]	; (8044 <socklen+0x28>)
    8022:	0080      	lsls	r0, r0, #2
    8024:	58c3      	ldr	r3, [r0, r3]

    // socket not allocated
    if (sock_entry == NULL)
    8026:	2b00      	cmp	r3, #0
    8028:	d009      	beq.n	803e <socklen+0x22>
    {
        return NEUL_SOCKET_RET_ERROR;
    }

    // check if any messages are present
    if (sock_entry->message == NULL)
    802a:	691b      	ldr	r3, [r3, #16]
    {
        return 0;
    802c:	1e18      	subs	r0, r3, #0
    if (sock_entry->message == NULL)
    802e:	d005      	beq.n	803c <socklen+0x20>
    }

    msg_hdr = sock_entry->message;

    if ((msg_hdr == NULL) || (msg_hdr->buffer == NULL))
    8030:	69da      	ldr	r2, [r3, #28]
    8032:	2a00      	cmp	r2, #0
    8034:	d003      	beq.n	803e <socklen+0x22>
    {
        return NEUL_SOCKET_RET_ERROR;
    }

    return(msg_hdr->buffer_length - msg_hdr->cur_pos);
    8036:	8b18      	ldrh	r0, [r3, #24]
    8038:	8adb      	ldrh	r3, [r3, #22]
    803a:	1ac0      	subs	r0, r0, r3
}
    803c:	4770      	bx	lr
        return NEUL_SOCKET_RET_ERROR;
    803e:	2001      	movs	r0, #1
    8040:	4240      	negs	r0, r0
    8042:	e7fb      	b.n	803c <socklen+0x20>
    8044:	01001820 	.word	0x01001820

00008048 <sock_callback_set>:
{
    socket_entry_t *sock_entry;

    if ((sock_num < 0) || (sock_num >= NUM_SOCKETS))
    {
        return NEUL_RET_ERROR_IN_PARAMETERS;
    8048:	2303      	movs	r3, #3
    if ((sock_num < 0) || (sock_num >= NUM_SOCKETS))
    804a:	2806      	cmp	r0, #6
    804c:	d808      	bhi.n	8060 <sock_callback_set+0x18>
    }

    sock_entry = socket_list[sock_num];
    804e:	4b05      	ldr	r3, [pc, #20]	; (8064 <sock_callback_set+0x1c>)
    8050:	0080      	lsls	r0, r0, #2
    8052:	58c0      	ldr	r0, [r0, r3]
    if (sock_entry == NULL)
    {
        return NEUL_RET_ERROR;
    8054:	2301      	movs	r3, #1
    if (sock_entry == NULL)
    8056:	2800      	cmp	r0, #0
    8058:	d002      	beq.n	8060 <sock_callback_set+0x18>
    }

    sock_entry->sent_callback = socket_sent_notify_callback;
    sock_entry->status_callback = socket_status_notify_callback;

    return NEUL_RET_OK;
    805a:	2300      	movs	r3, #0
    sock_entry->sent_callback = socket_sent_notify_callback;
    805c:	6081      	str	r1, [r0, #8]
    sock_entry->status_callback = socket_status_notify_callback;
    805e:	60c2      	str	r2, [r0, #12]
}
    8060:	0018      	movs	r0, r3
    8062:	4770      	bx	lr
    8064:	01001820 	.word	0x01001820

00008068 <remote_command_socket_data_sent>:
 * @param core The core this is called on
 * @param socket Socket that the data packet was sent on
 * @param status Success of failure of the transmit
 */
void remote_command_socket_data_sent(CORES core, uint16 data_seq, bool status)
{
    8068:	b510      	push	{r4, lr}
    socket_entry_t *sock_entry;
    uint16 sock_num;
    uint8 seq_num;
    socket_sent_notify_fn nonip_data_status_callback;

    sock_num = ((data_seq >> 8) & 0xFF);
    806a:	0a08      	lsrs	r0, r1, #8
    seq_num = (uint8)(data_seq & 0xFF);

    if (sock_num >= NUM_SOCKETS)
    806c:	2806      	cmp	r0, #6
    806e:	d809      	bhi.n	8084 <remote_command_socket_data_sent+0x1c>
    {
        return;
    }

    sock_entry = socket_list[sock_num];
    8070:	4b05      	ldr	r3, [pc, #20]	; (8088 <remote_command_socket_data_sent+0x20>)
    8072:	0084      	lsls	r4, r0, #2
    8074:	58e3      	ldr	r3, [r4, r3]
    if ((sock_entry == NULL) || (sock_entry->sent_callback == NULL))
    8076:	2b00      	cmp	r3, #0
    8078:	d004      	beq.n	8084 <remote_command_socket_data_sent+0x1c>
    807a:	689b      	ldr	r3, [r3, #8]
    807c:	2b00      	cmp	r3, #0
    807e:	d001      	beq.n	8084 <remote_command_socket_data_sent+0x1c>

    nonip_data_status_callback = sock_entry->sent_callback;

    if (nonip_data_status_callback != NULL)
    {
        nonip_data_status_callback(sock_num, seq_num, status);
    8080:	b2c9      	uxtb	r1, r1
    8082:	4798      	blx	r3
    }
}
    8084:	bd10      	pop	{r4, pc}
    8086:	46c0      	nop			; (mov r8, r8)
    8088:	01001820 	.word	0x01001820

0000808c <get_socket_status>:
 * @param status socket status
 * @param backoff remaining backoff time value, uint : s, valid only when status is SOCKET_OR_CID_STATUS_BACK_OFF
 * @return NUEL_RET
 */
NEUL_RET get_socket_status(uint8 socketid, SOCKET_OR_CID_STATUS *status, uint16 *backoff)
{
    808c:	b513      	push	{r0, r1, r4, lr}
    808e:	0013      	movs	r3, r2
    NEUL_RET ret;

    if (flowcontrol_enabled)
    8090:	4a09      	ldr	r2, [pc, #36]	; (80b8 <get_socket_status+0x2c>)
    8092:	7812      	ldrb	r2, [r2, #0]
    8094:	2a00      	cmp	r2, #0
    8096:	d004      	beq.n	80a2 <get_socket_status+0x16>
    {
        *status = SOCKET_OR_CID_STATUS_FLOW_CONTROL;
    8098:	2302      	movs	r3, #2
    809a:	700b      	strb	r3, [r1, #0]

        return NEUL_RET_OK;
    809c:	2300      	movs	r3, #0
    if(command_get_socket_status(socketid, (uint8 *)&ret, (uint8 *)status, backoff) != RPC_ERR_OK)
    {
        return NEUL_RET_ERROR;
    }
    return ret;
}
    809e:	0018      	movs	r0, r3
    80a0:	bd16      	pop	{r1, r2, r4, pc}
    if(command_get_socket_status(socketid, (uint8 *)&ret, (uint8 *)status, backoff) != RPC_ERR_OK)
    80a2:	466a      	mov	r2, sp
    80a4:	1dd4      	adds	r4, r2, #7
    80a6:	000a      	movs	r2, r1
    80a8:	0021      	movs	r1, r4
    80aa:	f7fe f962 	bl	6372 <command_get_socket_status>
        return NEUL_RET_ERROR;
    80ae:	2301      	movs	r3, #1
    if(command_get_socket_status(socketid, (uint8 *)&ret, (uint8 *)status, backoff) != RPC_ERR_OK)
    80b0:	2800      	cmp	r0, #0
    80b2:	d1f4      	bne.n	809e <get_socket_status+0x12>
    return ret;
    80b4:	7823      	ldrb	r3, [r4, #0]
    80b6:	e7f2      	b.n	809e <get_socket_status+0x12>
    80b8:	01001814 	.word	0x01001814

000080bc <iflog_init>:
    IFLOG_RET result = IFLOG_RET_ERROR;

    iflog_cache.magic     = 0;
    iflog_cache.r_index   = 0;
    iflog_cache.w_index   = 0;
    iflog_cache.buff_size = sizeof(iflog_cache.buff);
    80bc:	2280      	movs	r2, #128	; 0x80
    iflog_cache.magic     = 0;
    80be:	2100      	movs	r1, #0
{
    80c0:	b510      	push	{r4, lr}
    iflog_cache.magic     = 0;
    80c2:	4c0a      	ldr	r4, [pc, #40]	; (80ec <iflog_init+0x30>)
    iflog_cache.buff_size = sizeof(iflog_cache.buff);
    80c4:	0052      	lsls	r2, r2, #1
    assert((iflog_cache.buff_size % 4) == 0);
    assert(((uint32)(iflog_cache.buff) % 4) == 0);
    memset(iflog_cache.buff, 0x00, iflog_cache.buff_size);
    80c6:	480a      	ldr	r0, [pc, #40]	; (80f0 <iflog_init+0x34>)
    iflog_cache.r_index   = 0;
    80c8:	80a1      	strh	r1, [r4, #4]
    iflog_cache.magic     = 0;
    80ca:	8021      	strh	r1, [r4, #0]
    iflog_cache.w_index   = 0;
    80cc:	8061      	strh	r1, [r4, #2]
    iflog_cache.buff_size = sizeof(iflog_cache.buff);
    80ce:	80e2      	strh	r2, [r4, #6]
    memset(iflog_cache.buff, 0x00, iflog_cache.buff_size);
    80d0:	f7f8 f906 	bl	2e0 <memset>

    if (flash_log_register(&iflog_cache) == NEUL_RET_OK)
    80d4:	0020      	movs	r0, r4
    80d6:	f013 fb9d 	bl	1b814 <flash_log_register>
    IFLOG_RET result = IFLOG_RET_ERROR;
    80da:	2302      	movs	r3, #2
    if (flash_log_register(&iflog_cache) == NEUL_RET_OK)
    80dc:	2800      	cmp	r0, #0
    80de:	d102      	bne.n	80e6 <iflog_init+0x2a>
    {
        iflog_cache.magic = IFLOG_MAGIC;
    80e0:	4b04      	ldr	r3, [pc, #16]	; (80f4 <iflog_init+0x38>)
    80e2:	8023      	strh	r3, [r4, #0]
        result = IFLOG_RET_OK;
    80e4:	0003      	movs	r3, r0
    }

    return result;
}
    80e6:	0018      	movs	r0, r3
    80e8:	bd10      	pop	{r4, pc}
    80ea:	46c0      	nop			; (mov r8, r8)
    80ec:	0100185c 	.word	0x0100185c
    80f0:	01001864 	.word	0x01001864
    80f4:	ffffcafe 	.word	0xffffcafe

000080f8 <iflog_set_write_enable>:

void iflog_set_write_enable(bool write_enable)
{
    iflog_enable_write = write_enable;
    80f8:	4b01      	ldr	r3, [pc, #4]	; (8100 <iflog_set_write_enable+0x8>)
    80fa:	7018      	strb	r0, [r3, #0]
}
    80fc:	4770      	bx	lr
    80fe:	46c0      	nop			; (mov r8, r8)
    8100:	01000593 	.word	0x01000593

00008104 <iflog_write>:

//lint -esym(818, buff) Don't whine about buff not being changed.
IFLOG_RET iflog_write(uint8* buff, uint16 len)
{
    8104:	4673      	mov	r3, lr
    8106:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
    uint16 available_space  = 0;
    uint16 first_part_len  = 0;
    uint16 second_part_len = 0;
    uint16 flush_len;

    if (iflog_cache.magic != IFLOG_MAGIC)
    8108:	4c3e      	ldr	r4, [pc, #248]	; (8204 <iflog_write+0x100>)
    810a:	9301      	str	r3, [sp, #4]
    810c:	8822      	ldrh	r2, [r4, #0]
    810e:	4b3e      	ldr	r3, [pc, #248]	; (8208 <iflog_write+0x104>)
{
    8110:	9000      	str	r0, [sp, #0]
    8112:	000e      	movs	r6, r1
    {
        return IFLOG_RET_UNINIT;
    8114:	2005      	movs	r0, #5
    if (iflog_cache.magic != IFLOG_MAGIC)
    8116:	429a      	cmp	r2, r3
    8118:	d163      	bne.n	81e2 <iflog_write+0xde>
    }

    if(!iflog_enable_write)
    811a:	4b3c      	ldr	r3, [pc, #240]	; (820c <iflog_write+0x108>)
    {
        return IFLOG_RET_WRITE_DISABLED;
    811c:	3002      	adds	r0, #2
    if(!iflog_enable_write)
    811e:	781b      	ldrb	r3, [r3, #0]
    8120:	2b00      	cmp	r3, #0
    8122:	d05e      	beq.n	81e2 <iflog_write+0xde>
    }

    if((buff == NULL) || (len > IFLOG_BUFF_SIZE) || (len == 0))
    8124:	9b00      	ldr	r3, [sp, #0]
    {
        return IFLOG_RET_BAD_PARAMS;
    8126:	3804      	subs	r0, #4
    if((buff == NULL) || (len > IFLOG_BUFF_SIZE) || (len == 0))
    8128:	2b00      	cmp	r3, #0
    812a:	d05a      	beq.n	81e2 <iflog_write+0xde>
    812c:	1e4b      	subs	r3, r1, #1
    812e:	2bff      	cmp	r3, #255	; 0xff
    8130:	d857      	bhi.n	81e2 <iflog_write+0xde>
    }

    assert(iflog_cache.w_index < iflog_cache.buff_size);
    8132:	8863      	ldrh	r3, [r4, #2]
    8134:	88e2      	ldrh	r2, [r4, #6]
    8136:	429a      	cmp	r2, r3
    8138:	d803      	bhi.n	8142 <iflog_write+0x3e>
    813a:	4671      	mov	r1, lr
    813c:	3013      	adds	r0, #19
    813e:	f7f9 fce7 	bl	1b10 <panic>
    assert(iflog_cache.r_index < iflog_cache.buff_size);
    8142:	88a3      	ldrh	r3, [r4, #4]
    8144:	88e2      	ldrh	r2, [r4, #6]
    8146:	429a      	cmp	r2, r3
    8148:	d803      	bhi.n	8152 <iflog_write+0x4e>
    814a:	9901      	ldr	r1, [sp, #4]
    814c:	2016      	movs	r0, #22
    814e:	f7f9 fcdf 	bl	1b10 <panic>

    //calculate available space
    if (iflog_cache.w_index >= iflog_cache.r_index)
    8152:	8862      	ldrh	r2, [r4, #2]
    8154:	88a3      	ldrh	r3, [r4, #4]
    8156:	429a      	cmp	r2, r3
    8158:	d344      	bcc.n	81e4 <iflog_write+0xe0>
         *********************************************
         *  |--avail---|------log------|---avail--|  *
         *  s       r_index         w_index       e  *
         *********************************************
         */
        available_space  = iflog_cache.buff_size - iflog_cache.w_index;
    815a:	8862      	ldrh	r2, [r4, #2]
    815c:	88e5      	ldrh	r5, [r4, #6]
        available_space += iflog_cache.r_index;
    815e:	88a3      	ldrh	r3, [r4, #4]
    8160:	18eb      	adds	r3, r5, r3
    8162:	1a9b      	subs	r3, r3, r2
        if (len > (iflog_cache.buff_size - iflog_cache.w_index))
    8164:	8862      	ldrh	r2, [r4, #2]
        available_space += iflog_cache.r_index;
    8166:	b29b      	uxth	r3, r3
        if (len > (iflog_cache.buff_size - iflog_cache.w_index))
    8168:	1aaa      	subs	r2, r5, r2
    816a:	4296      	cmp	r6, r2
    816c:	dd3e      	ble.n	81ec <iflog_write+0xe8>
        {
            first_part_len  = iflog_cache.buff_size - iflog_cache.w_index;
    816e:	8861      	ldrh	r1, [r4, #2]
    8170:	1a6d      	subs	r5, r5, r1
    8172:	b2ad      	uxth	r5, r5
            second_part_len = len - first_part_len;
    8174:	1b77      	subs	r7, r6, r5
    8176:	b2bf      	uxth	r7, r7
    }

    available_space = (available_space > 0) ? (available_space - 1) : 0;
    if (available_space < len)
    {
        return IFLOG_RET_NO_SPACE;
    8178:	2004      	movs	r0, #4
    available_space = (available_space > 0) ? (available_space - 1) : 0;
    817a:	2b00      	cmp	r3, #0
    817c:	d031      	beq.n	81e2 <iflog_write+0xde>
    817e:	3b01      	subs	r3, #1
    if (available_space < len)
    8180:	b29b      	uxth	r3, r3
    8182:	429e      	cmp	r6, r3
    8184:	d82d      	bhi.n	81e2 <iflog_write+0xde>
    }

    //write data into buffer and notify security
    if (first_part_len > 0)
    8186:	2d00      	cmp	r5, #0
    8188:	d006      	beq.n	8198 <iflog_write+0x94>
    {
        memcpy(&(iflog_cache.buff[iflog_cache.w_index]), buff, first_part_len);
    818a:	8860      	ldrh	r0, [r4, #2]
    818c:	002a      	movs	r2, r5
    818e:	3008      	adds	r0, #8
    8190:	1820      	adds	r0, r4, r0
    8192:	9900      	ldr	r1, [sp, #0]
    8194:	f7f8 f82c 	bl	1f0 <memcpy>
    }

    if (second_part_len > 0)
    8198:	2f00      	cmp	r7, #0
    819a:	d010      	beq.n	81be <iflog_write+0xba>
    {
        assert(((iflog_cache.w_index + first_part_len) % iflog_cache.buff_size) == 0);
    819c:	8860      	ldrh	r0, [r4, #2]
    819e:	88e1      	ldrh	r1, [r4, #6]
    81a0:	1940      	adds	r0, r0, r5
    81a2:	f7f8 fa79 	bl	698 <__aeabi_idivmod>
    81a6:	2900      	cmp	r1, #0
    81a8:	d003      	beq.n	81b2 <iflog_write+0xae>
    81aa:	9901      	ldr	r1, [sp, #4]
    81ac:	2016      	movs	r0, #22
    81ae:	f7f9 fcaf 	bl	1b10 <panic>
        memcpy(&(iflog_cache.buff[0]), buff + first_part_len, second_part_len);
    81b2:	9b00      	ldr	r3, [sp, #0]
    81b4:	003a      	movs	r2, r7
    81b6:	1959      	adds	r1, r3, r5
    81b8:	4815      	ldr	r0, [pc, #84]	; (8210 <iflog_write+0x10c>)
    81ba:	f7f8 f819 	bl	1f0 <memcpy>
    }

    flush_len = FORCE_4_ALIGNMENT(iflog_cache.w_index + len) - FORCE_4_ALIGNMENT(iflog_cache.w_index);
    81be:	2203      	movs	r2, #3
    81c0:	8861      	ldrh	r1, [r4, #2]
    81c2:	8860      	ldrh	r0, [r4, #2]
    81c4:	1989      	adds	r1, r1, r6
    81c6:	4391      	bics	r1, r2
    81c8:	4390      	bics	r0, r2
    81ca:	1a09      	subs	r1, r1, r0
    81cc:	b289      	uxth	r1, r1
    if ((flush_len == 0) || (flash_log_write(FORCE_4_ALIGNMENT(iflog_cache.w_index), flush_len) == NEUL_RET_OK))
    81ce:	2900      	cmp	r1, #0
    81d0:	d10f      	bne.n	81f2 <iflog_write+0xee>
    {
        iflog_cache.w_index = (iflog_cache.w_index + len) % iflog_cache.buff_size;
    81d2:	8860      	ldrh	r0, [r4, #2]
    81d4:	88e1      	ldrh	r1, [r4, #6]
    81d6:	1980      	adds	r0, r0, r6
    81d8:	f7f8 fa5e 	bl	698 <__aeabi_idivmod>
        result = IFLOG_RET_OK;
    81dc:	2000      	movs	r0, #0
        iflog_cache.w_index = (iflog_cache.w_index + len) % iflog_cache.buff_size;
    81de:	b289      	uxth	r1, r1
    81e0:	8061      	strh	r1, [r4, #2]
    }

    return result;
}
    81e2:	bdfe      	pop	{r1, r2, r3, r4, r5, r6, r7, pc}
        available_space  = iflog_cache.r_index - iflog_cache.w_index;
    81e4:	88a3      	ldrh	r3, [r4, #4]
    81e6:	8862      	ldrh	r2, [r4, #2]
    81e8:	1a9b      	subs	r3, r3, r2
    81ea:	b29b      	uxth	r3, r3
    81ec:	0035      	movs	r5, r6
            second_part_len = 0;
    81ee:	2700      	movs	r7, #0
    81f0:	e7c2      	b.n	8178 <iflog_write+0x74>
    if ((flush_len == 0) || (flash_log_write(FORCE_4_ALIGNMENT(iflog_cache.w_index), flush_len) == NEUL_RET_OK))
    81f2:	8860      	ldrh	r0, [r4, #2]
    81f4:	4390      	bics	r0, r2
    81f6:	f013 fb19 	bl	1b82c <flash_log_write>
    81fa:	2800      	cmp	r0, #0
    81fc:	d0e9      	beq.n	81d2 <iflog_write+0xce>
    IFLOG_RET result = IFLOG_RET_ERROR;
    81fe:	2002      	movs	r0, #2
    8200:	e7ef      	b.n	81e2 <iflog_write+0xde>
    8202:	46c0      	nop			; (mov r8, r8)
    8204:	0100185c 	.word	0x0100185c
    8208:	0000cafe 	.word	0x0000cafe
    820c:	01000593 	.word	0x01000593
    8210:	01001864 	.word	0x01001864

00008214 <iflog_get_available_size>:

uint16 iflog_get_available_size(void)
{
    uint16 available_size;
    if (iflog_cache.w_index >= iflog_cache.r_index)
    8214:	4b09      	ldr	r3, [pc, #36]	; (823c <iflog_get_available_size+0x28>)
    8216:	8859      	ldrh	r1, [r3, #2]
    8218:	889a      	ldrh	r2, [r3, #4]
    821a:	4291      	cmp	r1, r2
    821c:	d30a      	bcc.n	8234 <iflog_get_available_size+0x20>
         *********************************************
         *  |--avail---|------log------|---avail--|  *
         *  s       r_index         w_index       e  *
         *********************************************
         */
        available_size  = iflog_cache.buff_size - iflog_cache.w_index;
    821e:	885a      	ldrh	r2, [r3, #2]
        available_size += iflog_cache.r_index;
    8220:	8898      	ldrh	r0, [r3, #4]
    8222:	88db      	ldrh	r3, [r3, #6]
    8224:	18c0      	adds	r0, r0, r3
    8226:	1a80      	subs	r0, r0, r2
         ***************************************************
         *  |------log------|---avail---|------log-------|  *
         *  s            w_index    r_index             e  *
         ***************************************************
         */
        available_size  = iflog_cache.r_index - iflog_cache.w_index;
    8228:	b280      	uxth	r0, r0
    }
    return ((available_size > 0) ? (available_size - 1) : 0);
    822a:	2800      	cmp	r0, #0
    822c:	d001      	beq.n	8232 <iflog_get_available_size+0x1e>
    822e:	3801      	subs	r0, #1
    8230:	b280      	uxth	r0, r0
}
    8232:	4770      	bx	lr
        available_size  = iflog_cache.r_index - iflog_cache.w_index;
    8234:	8898      	ldrh	r0, [r3, #4]
    8236:	885b      	ldrh	r3, [r3, #2]
    8238:	1ac0      	subs	r0, r0, r3
    823a:	e7f5      	b.n	8228 <iflog_get_available_size+0x14>
    823c:	0100185c 	.word	0x0100185c

00008240 <iflog_read>:

IFLOG_RET iflog_read(uint8 * buff, uint16 buff_size, uint16 * len)
{
    8240:	b570      	push	{r4, r5, r6, lr}
    IFLOG_RET result = IFLOG_RET_OK;

    if (iflog_cache.magic != IFLOG_MAGIC)
    8242:	4b11      	ldr	r3, [pc, #68]	; (8288 <iflog_read+0x48>)
{
    8244:	000c      	movs	r4, r1
    8246:	0015      	movs	r5, r2
    if (iflog_cache.magic != IFLOG_MAGIC)
    8248:	8819      	ldrh	r1, [r3, #0]
    824a:	4a10      	ldr	r2, [pc, #64]	; (828c <iflog_read+0x4c>)
    {
        return IFLOG_RET_UNINIT;
    824c:	2305      	movs	r3, #5
    if (iflog_cache.magic != IFLOG_MAGIC)
    824e:	4291      	cmp	r1, r2
    8250:	d117      	bne.n	8282 <iflog_read+0x42>
    8252:	2203      	movs	r2, #3
    }
    if ((buff == NULL) || ((uint32)buff % 4 != 0) || buff_size == 0 || (buff_size % 4 != 0) || len == NULL)
    {
        return IFLOG_RET_BAD_PARAMS;
    8254:	0013      	movs	r3, r2
    if ((buff == NULL) || ((uint32)buff % 4 != 0) || buff_size == 0 || (buff_size % 4 != 0) || len == NULL)
    8256:	2800      	cmp	r0, #0
    8258:	d013      	beq.n	8282 <iflog_read+0x42>
    825a:	4210      	tst	r0, r2
    825c:	d111      	bne.n	8282 <iflog_read+0x42>
    825e:	2c00      	cmp	r4, #0
    8260:	d00f      	beq.n	8282 <iflog_read+0x42>
    8262:	4214      	tst	r4, r2
    8264:	d10d      	bne.n	8282 <iflog_read+0x42>
    8266:	2d00      	cmp	r5, #0
    8268:	d00b      	beq.n	8282 <iflog_read+0x42>
    }

    if (flash_log_read((uint32)buff, buff_size, len) == NEUL_RET_OK)
    826a:	002a      	movs	r2, r5
    826c:	0021      	movs	r1, r4
    826e:	f013 fae9 	bl	1b844 <flash_log_read>
            result = IFLOG_RET_NO_DATA;
        }
    }
    else
    {
        result = IFLOG_RET_ERROR;
    8272:	2302      	movs	r3, #2
    if (flash_log_read((uint32)buff, buff_size, len) == NEUL_RET_OK)
    8274:	2800      	cmp	r0, #0
    8276:	d104      	bne.n	8282 <iflog_read+0x42>
        if(buff_size != *len)
    8278:	882b      	ldrh	r3, [r5, #0]
    827a:	1b1b      	subs	r3, r3, r4
    827c:	1e58      	subs	r0, r3, #1
    827e:	4183      	sbcs	r3, r0
        return IFLOG_RET_UNINIT;
    8280:	b2db      	uxtb	r3, r3
    }
    return result;
}
    8282:	0018      	movs	r0, r3
    8284:	bd70      	pop	{r4, r5, r6, pc}
    8286:	46c0      	nop			; (mov r8, r8)
    8288:	0100185c 	.word	0x0100185c
    828c:	0000cafe 	.word	0x0000cafe

00008290 <aio_func_set_default_temperature_coefficient>:
 * @brief Read the calibrated temperature coefficient from KV, or retrieve the default temperature coefficient,
 *        and set this as the temp_mon conversion factor
 * @return AIO_FUNC_RET_OK for success, else error
 */
AIO_FUNC_RET aio_func_set_default_temperature_coefficient(void)
{
    8290:	b513      	push	{r0, r1, r4, lr}
    AIO_FUNC_RET aio_func_ret = AIO_FUNC_RET_ERROR;
    uint16 temperature_coefficient;

    if (get_chip_temp_coefficient(&temperature_coefficient) == NEUL_RET_OK)
    8292:	466b      	mov	r3, sp
    8294:	1d9c      	adds	r4, r3, #6
    8296:	0020      	movs	r0, r4
    8298:	f014 fd46 	bl	1cd28 <get_chip_temp_coefficient>
    829c:	0003      	movs	r3, r0
    AIO_FUNC_RET aio_func_ret = AIO_FUNC_RET_ERROR;
    829e:	2001      	movs	r0, #1
    if (get_chip_temp_coefficient(&temperature_coefficient) == NEUL_RET_OK)
    82a0:	2b00      	cmp	r3, #0
    82a2:	d105      	bne.n	82b0 <aio_func_set_default_temperature_coefficient+0x20>
    {
        if (temp_mon_set_coefficient(temperature_coefficient) == TEMP_MON_RET_OK)
    82a4:	8820      	ldrh	r0, [r4, #0]
    82a6:	f00e f947 	bl	16538 <temp_mon_set_coefficient>
    82aa:	1e43      	subs	r3, r0, #1
    82ac:	4198      	sbcs	r0, r3
    AIO_FUNC_RET aio_func_ret = AIO_FUNC_RET_ERROR;
    82ae:	b2c0      	uxtb	r0, r0
            aio_func_ret = AIO_FUNC_RET_OK;
        }
    }

    return aio_func_ret;
}
    82b0:	bd16      	pop	{r1, r2, r4, pc}
	...

000082b4 <at_perform_one_atcommand>:

    return AT_RET_OK;
}

static AT_RET at_perform_one_atcommand(uint8 *p_str)
{
    82b4:	b5f0      	push	{r4, r5, r6, r7, lr}
    const AT_CMD_CB_s  *cmd_cb;
    AT_RET              cause = AT_RET_SYNTAX_ERROR;
    log_flags_t         log_flag = LOG_FLAGS_NONE;

    str = p_str;
    at_cmd_len = at_get_cmd_length(str);
    82b6:	260e      	movs	r6, #14
{
    82b8:	b087      	sub	sp, #28
    82ba:	0004      	movs	r4, r0
    at_cmd_len = at_get_cmd_length(str);
    82bc:	f001 ff29 	bl	a112 <at_get_cmd_length>
    82c0:	ab02      	add	r3, sp, #8
    82c2:	18f6      	adds	r6, r6, r3
    82c4:	8030      	strh	r0, [r6, #0]

    cmd_cb = at_get_atcmd_cb_from_atstring(str, &at_cmd_len);
    82c6:	0031      	movs	r1, r6
    82c8:	0020      	movs	r0, r4
    82ca:	f002 fb19 	bl	a900 <at_get_atcmd_cb_from_atstring>
        }

        return cause;
    }

    return AT_RET_SYNTAX_ERROR;
    82ce:	2701      	movs	r7, #1
    cmd_cb = at_get_atcmd_cb_from_atstring(str, &at_cmd_len);
    82d0:	1e05      	subs	r5, r0, #0
    if(cmd_cb)
    82d2:	d046      	beq.n	8362 <at_perform_one_atcommand+0xae>
        at_processing_cmd_cb = cmd_cb;
    82d4:	4b25      	ldr	r3, [pc, #148]	; (836c <at_perform_one_atcommand+0xb8>)
    82d6:	6018      	str	r0, [r3, #0]
        if (AT_IS_ABORTABLE(cmd_cb->flag))
    82d8:	8803      	ldrh	r3, [r0, #0]
    82da:	065a      	lsls	r2, r3, #25
    82dc:	d501      	bpl.n	82e2 <at_perform_one_atcommand+0x2e>
            g_at_processing_cmd_abortable = true;
    82de:	4a24      	ldr	r2, [pc, #144]	; (8370 <at_perform_one_atcommand+0xbc>)
    82e0:	7017      	strb	r7, [r2, #0]
        if (AT_IS_LOGABLE(cmd_cb->flag))
    82e2:	2708      	movs	r7, #8
        if (AT_IS_LOG_RESTRICTED(cmd_cb->flag))
    82e4:	069a      	lsls	r2, r3, #26
            log_flag = LOG_FLAGS_RESTRICTED;
    82e6:	0fd2      	lsrs	r2, r2, #31
    82e8:	0092      	lsls	r2, r2, #2
    82ea:	9203      	str	r2, [sp, #12]
        if (AT_IS_LOGABLE(cmd_cb->flag))
    82ec:	403b      	ands	r3, r7
    82ee:	d01a      	beq.n	8326 <at_perform_one_atcommand+0x72>
            log_event(APPS_SW_MODULE_AT, LOG_VERBOSITY_NORMAL, log_flag, NEUL_LOG_TYPE_STRING, (uint16)strlen((const char *)str), (const uint8*) str);
    82f0:	0020      	movs	r0, r4
    82f2:	f013 f854 	bl	1b39e <strlen>
    82f6:	2300      	movs	r3, #0
    82f8:	b280      	uxth	r0, r0
    82fa:	9401      	str	r4, [sp, #4]
    82fc:	9000      	str	r0, [sp, #0]
            log_event(APPS_SW_MODULE_AT, LOG_VERBOSITY_NORMAL, log_flag, NEUL_LOG_TYPE_STRING, at_cmd_len, (const uint8*) str);
    82fe:	0038      	movs	r0, r7
    8300:	9a03      	ldr	r2, [sp, #12]
    8302:	2101      	movs	r1, #1
    8304:	f7fe f99a 	bl	663c <log_event>
        str += at_cmd_len; //=1,2,3
    8308:	8830      	ldrh	r0, [r6, #0]
    830a:	1820      	adds	r0, r4, r0
        if(*str == '?' && (*(str + 1) == '\0'))
    830c:	7803      	ldrb	r3, [r0, #0]
    830e:	2b3f      	cmp	r3, #63	; 0x3f
    8310:	d10d      	bne.n	832e <at_perform_one_atcommand+0x7a>
    8312:	7843      	ldrb	r3, [r0, #1]
    8314:	2b00      	cmp	r3, #0
    8316:	d127      	bne.n	8368 <at_perform_one_atcommand+0xb4>
            if(cmd_cb->at_read_handler)
    8318:	68eb      	ldr	r3, [r5, #12]
    AT_RET              cause = AT_RET_SYNTAX_ERROR;
    831a:	2701      	movs	r7, #1
        else if(cmd_cb->at_exec_handler)
    831c:	2b00      	cmp	r3, #0
    831e:	d019      	beq.n	8354 <at_perform_one_atcommand+0xa0>
            cause = (cmd_cb->at_exec_handler)();
    8320:	4798      	blx	r3
    8322:	0007      	movs	r7, r0
    8324:	e016      	b.n	8354 <at_perform_one_atcommand+0xa0>
            log_event(APPS_SW_MODULE_AT, LOG_VERBOSITY_NORMAL, log_flag, NEUL_LOG_TYPE_STRING, at_cmd_len, (const uint8*) str);
    8326:	9401      	str	r4, [sp, #4]
    8328:	8832      	ldrh	r2, [r6, #0]
    832a:	9200      	str	r2, [sp, #0]
    832c:	e7e7      	b.n	82fe <at_perform_one_atcommand+0x4a>
        else if ((*str == '=') && ( *(str + 1) == '?') && (*(str + 2) == '\0'))
    832e:	2b3d      	cmp	r3, #61	; 0x3d
    8330:	d11a      	bne.n	8368 <at_perform_one_atcommand+0xb4>
    8332:	7843      	ldrb	r3, [r0, #1]
    8334:	2b3f      	cmp	r3, #63	; 0x3f
    8336:	d104      	bne.n	8342 <at_perform_one_atcommand+0x8e>
    8338:	7883      	ldrb	r3, [r0, #2]
    833a:	2b00      	cmp	r3, #0
    833c:	d101      	bne.n	8342 <at_perform_one_atcommand+0x8e>
            if(cmd_cb->at_test_handler)
    833e:	692b      	ldr	r3, [r5, #16]
    8340:	e7eb      	b.n	831a <at_perform_one_atcommand+0x66>
            if(cmd_cb->at_set_handler)
    8342:	68ab      	ldr	r3, [r5, #8]
            str++; //1,2,3
    8344:	3001      	adds	r0, #1
    AT_RET              cause = AT_RET_SYNTAX_ERROR;
    8346:	2701      	movs	r7, #1
            if(cmd_cb->at_set_handler)
    8348:	2b00      	cmp	r3, #0
    834a:	d003      	beq.n	8354 <at_perform_one_atcommand+0xa0>
                cause = (cmd_cb->at_set_handler)(str);
    834c:	4798      	blx	r3
    834e:	0007      	movs	r7, r0
                at_free_at_params();
    8350:	f001 ffb2 	bl	a2b8 <at_free_at_params>
        if (AT_IS_SMS_CMD(cmd_cb->flag))
    8354:	882b      	ldrh	r3, [r5, #0]
    8356:	05db      	lsls	r3, r3, #23
    8358:	d503      	bpl.n	8362 <at_perform_one_atcommand+0xae>
            cause = at_parse_convert_sms_result(cause);
    835a:	0038      	movs	r0, r7
    835c:	f001 ffa2 	bl	a2a4 <at_parse_convert_sms_result>
    8360:	0007      	movs	r7, r0
}
    8362:	0038      	movs	r0, r7
    8364:	b007      	add	sp, #28
    8366:	bdf0      	pop	{r4, r5, r6, r7, pc}
        else if(cmd_cb->at_exec_handler)
    8368:	696b      	ldr	r3, [r5, #20]
    836a:	e7d6      	b.n	831a <at_perform_one_atcommand+0x66>
    836c:	01001968 	.word	0x01001968
    8370:	01001984 	.word	0x01001984

00008374 <at_free_cmd_memory>:

static void at_free_cmd_memory(void)
{
    8374:	b510      	push	{r4, lr}
    if(g_at_cmd_info.str != NULL)
    8376:	4c05      	ldr	r4, [pc, #20]	; (838c <at_free_cmd_memory+0x18>)
    8378:	6820      	ldr	r0, [r4, #0]
    837a:	2800      	cmp	r0, #0
    837c:	d004      	beq.n	8388 <at_free_cmd_memory+0x14>
    {
        at_free(g_at_cmd_info.str);
    837e:	f00a fb5b 	bl	12a38 <irfree>
    8382:	2300      	movs	r3, #0
    8384:	6023      	str	r3, [r4, #0]
        g_at_cmd_info.offset = 0;
    8386:	80a3      	strh	r3, [r4, #4]
    }
}
    8388:	bd10      	pop	{r4, pc}
    838a:	46c0      	nop			; (mov r8, r8)
    838c:	0100197c 	.word	0x0100197c

00008390 <app_at_send_next_command>:

    return cause;
}

static void app_at_send_next_command(void)
{
    8390:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    if(g_at_cmd_info.offset != 0)
    8392:	4c1e      	ldr	r4, [pc, #120]	; (840c <app_at_send_next_command+0x7c>)
    8394:	88a6      	ldrh	r6, [r4, #4]
    8396:	2e00      	cmp	r6, #0
    8398:	d007      	beq.n	83aa <app_at_send_next_command+0x1a>
    at_cmd_len = at_get_cmd_length(&g_at_cmd_info.str[offset]); //one AT command len
    839a:	6823      	ldr	r3, [r4, #0]
    839c:	1998      	adds	r0, r3, r6
    839e:	f001 feb8 	bl	a112 <at_get_cmd_length>
    83a2:	1e05      	subs	r5, r0, #0
    if(at_cmd_len == 0)
    83a4:	d102      	bne.n	83ac <app_at_send_next_command+0x1c>
        at_free_cmd_memory();
    83a6:	f7ff ffe5 	bl	8374 <at_free_cmd_memory>
    {
        at_send_next_at_command();
        return;
    }
}
    83aa:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    str = &g_at_cmd_info.str[offset];
    83ac:	6823      	ldr	r3, [r4, #0]
        end_flag = true;
    83ae:	2701      	movs	r7, #1
    str = &g_at_cmd_info.str[offset];
    83b0:	1998      	adds	r0, r3, r6
    if(str[at_cmd_len ] == '\0')
    83b2:	1943      	adds	r3, r0, r5
    83b4:	781a      	ldrb	r2, [r3, #0]
    83b6:	2a00      	cmp	r2, #0
    83b8:	d003      	beq.n	83c2 <app_at_send_next_command+0x32>
    83ba:	2700      	movs	r7, #0
    else if(str[at_cmd_len ] == ';')
    83bc:	2a3b      	cmp	r2, #59	; 0x3b
    83be:	d100      	bne.n	83c2 <app_at_send_next_command+0x32>
        str[at_cmd_len ] = '\0';
    83c0:	701f      	strb	r7, [r3, #0]
    g_at_cmd_in_progress = status;
    83c2:	2201      	movs	r2, #1
    83c4:	4b12      	ldr	r3, [pc, #72]	; (8410 <app_at_send_next_command+0x80>)
    83c6:	701a      	strb	r2, [r3, #0]
    cause = at_perform_one_atcommand(str);
    83c8:	f7ff ff74 	bl	82b4 <at_perform_one_atcommand>
    83cc:	0006      	movs	r6, r0
    if(end_flag)
    83ce:	2f00      	cmp	r7, #0
    83d0:	d009      	beq.n	83e6 <app_at_send_next_command+0x56>
        at_free_cmd_memory();
    83d2:	f7ff ffcf 	bl	8374 <at_free_cmd_memory>
    if(cause == AT_RET_CMD_IN_PROGRESS_BLOCK)
    83d6:	2e09      	cmp	r6, #9
    83d8:	d10a      	bne.n	83f0 <app_at_send_next_command+0x60>
        blocking_begin_time = rtc_get_time_ms();
    83da:	f010 f913 	bl	18604 <rtc_get_time_ms>
    83de:	4b0d      	ldr	r3, [pc, #52]	; (8414 <app_at_send_next_command+0x84>)
    83e0:	6018      	str	r0, [r3, #0]
    83e2:	6059      	str	r1, [r3, #4]
    83e4:	e7e1      	b.n	83aa <app_at_send_next_command+0x1a>
        g_at_cmd_info.offset += (at_cmd_len + 1);
    83e6:	88a3      	ldrh	r3, [r4, #4]
    83e8:	3301      	adds	r3, #1
    83ea:	18ed      	adds	r5, r5, r3
    83ec:	80a5      	strh	r5, [r4, #4]
    83ee:	e7f2      	b.n	83d6 <app_at_send_next_command+0x46>
    g_at_cmd_in_progress = status;
    83f0:	2300      	movs	r3, #0
    83f2:	4a07      	ldr	r2, [pc, #28]	; (8410 <app_at_send_next_command+0x80>)
    at_status_output(cause);
    83f4:	0030      	movs	r0, r6
    g_at_cmd_in_progress = status;
    83f6:	7013      	strb	r3, [r2, #0]
        g_at_processing_cmd_abortable   = false;
    83f8:	4a07      	ldr	r2, [pc, #28]	; (8418 <app_at_send_next_command+0x88>)
    83fa:	7013      	strb	r3, [r2, #0]
        at_processing_cmd_cb            = NULL;
    83fc:	4a07      	ldr	r2, [pc, #28]	; (841c <app_at_send_next_command+0x8c>)
    83fe:	6013      	str	r3, [r2, #0]
    at_status_output(cause);
    8400:	f000 fffc 	bl	93fc <at_status_output>
    if(cause  == AT_RET_OK)
    8404:	2e00      	cmp	r6, #0
    8406:	d1ce      	bne.n	83a6 <app_at_send_next_command+0x16>
    8408:	e7c3      	b.n	8392 <app_at_send_next_command+0x2>
    840a:	46c0      	nop			; (mov r8, r8)
    840c:	0100197c 	.word	0x0100197c
    8410:	01001978 	.word	0x01001978
    8414:	01001970 	.word	0x01001970
    8418:	01001984 	.word	0x01001984
    841c:	01001968 	.word	0x01001968

00008420 <at_radio_cmd_abort_callback>:
    g_at_cmd_in_progress = status;
    8420:	2300      	movs	r3, #0
    8422:	4a0a      	ldr	r2, [pc, #40]	; (844c <at_radio_cmd_abort_callback+0x2c>)
{
    return at_initialized;
}

static void at_radio_cmd_abort_callback(NEUL_RET neul_ret)
{
    8424:	b510      	push	{r4, lr}
    g_at_cmd_in_progress = status;
    8426:	7013      	strb	r3, [r2, #0]
    at_set_in_progress_status(false);
    g_blocking_at_command_protected = false;
    8428:	4a09      	ldr	r2, [pc, #36]	; (8450 <at_radio_cmd_abort_callback+0x30>)
    842a:	7013      	strb	r3, [r2, #0]
    g_at_processing_cmd_abortable   = false;
    842c:	4a09      	ldr	r2, [pc, #36]	; (8454 <at_radio_cmd_abort_callback+0x34>)
    842e:	7013      	strb	r3, [r2, #0]
    at_processing_cmd_cb            = NULL;
    8430:	4a09      	ldr	r2, [pc, #36]	; (8458 <at_radio_cmd_abort_callback+0x38>)
    8432:	6013      	str	r3, [r2, #0]

    if (neul_ret == NEUL_RET_OK)
    8434:	4298      	cmp	r0, r3
    8436:	d105      	bne.n	8444 <at_radio_cmd_abort_callback+0x24>
    {
        at_status_output(AT_RET_CMD_ABORT_BY_USER);
    8438:	201a      	movs	r0, #26
    {
        // do nothing
    }
    else
    {
        at_status_output(AT_RET_CMD_ABORT_ERROR);
    843a:	f000 ffdf 	bl	93fc <at_status_output>
    }

    at_free_cmd_memory();
    843e:	f7ff ff99 	bl	8374 <at_free_cmd_memory>
}
    8442:	bd10      	pop	{r4, pc}
    else if  (neul_ret == NEUL_RET_NO_COMMAND_TO_ABORT)
    8444:	281f      	cmp	r0, #31
    8446:	d0fa      	beq.n	843e <at_radio_cmd_abort_callback+0x1e>
        at_status_output(AT_RET_CMD_ABORT_ERROR);
    8448:	201e      	movs	r0, #30
    844a:	e7f6      	b.n	843a <at_radio_cmd_abort_callback+0x1a>
    844c:	01001978 	.word	0x01001978
    8450:	01001985 	.word	0x01001985
    8454:	01001984 	.word	0x01001984
    8458:	01001968 	.word	0x01001968

0000845c <at_sim_pin_ind_callback>:

static void at_sim_pin_ind_callback(uint8 result)
{
    845c:	b510      	push	{r4, lr}
    845e:	b086      	sub	sp, #24
    char        rsp_string[AT_SIM_PIN_IND_LEN] = {0};
    8460:	2215      	movs	r2, #21
{
    8462:	0004      	movs	r4, r0
    char        rsp_string[AT_SIM_PIN_IND_LEN] = {0};
    8464:	2100      	movs	r1, #0
    8466:	4668      	mov	r0, sp
    8468:	f7f7 ff3a 	bl	2e0 <memset>

    if(result == NEUL_RET_SIM_PIN_REQUIRED)
    {
        (void)snprintf(rsp_string, AT_SIM_PIN_IND_LEN, APP_AT_STR_PIN);
    846c:	4a0a      	ldr	r2, [pc, #40]	; (8498 <at_sim_pin_ind_callback+0x3c>)
    if(result == NEUL_RET_SIM_PIN_REQUIRED)
    846e:	2c16      	cmp	r4, #22
    8470:	d005      	beq.n	847e <at_sim_pin_ind_callback+0x22>
    }
    else if(result == NEUL_RET_SIM_PUK_REQUIRED)
    {
        (void)snprintf(rsp_string, AT_SIM_PIN_IND_LEN, APP_AT_STR_PUK);
    8472:	4a0a      	ldr	r2, [pc, #40]	; (849c <at_sim_pin_ind_callback+0x40>)
    else if(result == NEUL_RET_SIM_PUK_REQUIRED)
    8474:	2c27      	cmp	r4, #39	; 0x27
    8476:	d002      	beq.n	847e <at_sim_pin_ind_callback+0x22>
    }
    else if(result == NEUL_RET_SIM_PUK_BLOCKED)
    8478:	2c28      	cmp	r4, #40	; 0x28
    847a:	d10a      	bne.n	8492 <at_sim_pin_ind_callback+0x36>
    {
        (void)snprintf(rsp_string, AT_SIM_PIN_IND_LEN, APP_AT_STR_PUK_BLOCKED);
    847c:	4a08      	ldr	r2, [pc, #32]	; (84a0 <at_sim_pin_ind_callback+0x44>)
    847e:	2115      	movs	r1, #21
    8480:	4668      	mov	r0, sp
    8482:	f012 f9f3 	bl	1a86c <snprintf>
    else
    {
        return;
    }

    delayed_async_print(rsp_string, AT_FLAG_LOGABLE, 0, 0);
    8486:	2300      	movs	r3, #0
    8488:	2108      	movs	r1, #8
    848a:	001a      	movs	r2, r3
    848c:	4668      	mov	r0, sp
    848e:	f002 fc15 	bl	acbc <delayed_async_print>
}
    8492:	b006      	add	sp, #24
    8494:	bd10      	pop	{r4, pc}
    8496:	46c0      	nop			; (mov r8, r8)
    8498:	00022e14 	.word	0x00022e14
    849c:	00022e29 	.word	0x00022e29
    84a0:	00022e3e 	.word	0x00022e3e

000084a4 <get_at_cmd_in_progress>:
    return g_at_cmd_in_progress;
    84a4:	4b01      	ldr	r3, [pc, #4]	; (84ac <get_at_cmd_in_progress+0x8>)
    84a6:	7818      	ldrb	r0, [r3, #0]
}
    84a8:	4770      	bx	lr
    84aa:	46c0      	nop			; (mov r8, r8)
    84ac:	01001978 	.word	0x01001978

000084b0 <get_at_processing_cmd_abortable>:
    return g_at_processing_cmd_abortable;
    84b0:	4b01      	ldr	r3, [pc, #4]	; (84b8 <get_at_processing_cmd_abortable+0x8>)
    84b2:	7818      	ldrb	r0, [r3, #0]
}
    84b4:	4770      	bx	lr
    84b6:	46c0      	nop			; (mov r8, r8)
    84b8:	01001984 	.word	0x01001984

000084bc <get_at_blocking_at_command_protected>:
    return g_blocking_at_command_protected;
    84bc:	4b01      	ldr	r3, [pc, #4]	; (84c4 <get_at_blocking_at_command_protected+0x8>)
    84be:	7818      	ldrb	r0, [r3, #0]
}
    84c0:	4770      	bx	lr
    84c2:	46c0      	nop			; (mov r8, r8)
    84c4:	01001985 	.word	0x01001985

000084c8 <app_at_send_callback_response>:
{
    84c8:	b510      	push	{r4, lr}
    84ca:	0004      	movs	r4, r0
    at_status_output(result);
    84cc:	f000 ff96 	bl	93fc <at_status_output>
    g_at_cmd_in_progress = status;
    84d0:	2300      	movs	r3, #0
    84d2:	4a08      	ldr	r2, [pc, #32]	; (84f4 <app_at_send_callback_response+0x2c>)
    84d4:	7013      	strb	r3, [r2, #0]
    g_blocking_at_command_protected = false;
    84d6:	4a08      	ldr	r2, [pc, #32]	; (84f8 <app_at_send_callback_response+0x30>)
    84d8:	7013      	strb	r3, [r2, #0]
    g_at_processing_cmd_abortable   = false;
    84da:	4a08      	ldr	r2, [pc, #32]	; (84fc <app_at_send_callback_response+0x34>)
    84dc:	7013      	strb	r3, [r2, #0]
    at_processing_cmd_cb            = NULL;
    84de:	4a08      	ldr	r2, [pc, #32]	; (8500 <app_at_send_callback_response+0x38>)
    84e0:	6013      	str	r3, [r2, #0]
    if(result == AT_RET_OK)
    84e2:	429c      	cmp	r4, r3
    84e4:	d102      	bne.n	84ec <app_at_send_callback_response+0x24>
        app_at_send_next_command();
    84e6:	f7ff ff53 	bl	8390 <app_at_send_next_command>
}
    84ea:	bd10      	pop	{r4, pc}
        at_free_cmd_memory();
    84ec:	f7ff ff42 	bl	8374 <at_free_cmd_memory>
}
    84f0:	e7fb      	b.n	84ea <app_at_send_callback_response+0x22>
    84f2:	46c0      	nop			; (mov r8, r8)
    84f4:	01001978 	.word	0x01001978
    84f8:	01001985 	.word	0x01001985
    84fc:	01001984 	.word	0x01001984
    8500:	01001968 	.word	0x01001968

00008504 <at_main>:
{
    8504:	b5f0      	push	{r4, r5, r6, r7, lr}
    8506:	b089      	sub	sp, #36	; 0x24
    if(at_uart_get_status() == AT_UART_STATUS_IN_PROCESS)
    8508:	f001 fa1a 	bl	9940 <at_uart_get_status>
    850c:	2801      	cmp	r0, #1
    850e:	d000      	beq.n	8512 <at_main+0xe>
    8510:	e1f8      	b.n	8904 <at_main+0x400>
        at_main_handle(at_uart_get_receive_buffer());
    8512:	f001 fa1b 	bl	994c <at_uart_get_receive_buffer>
    8516:	0004      	movs	r4, r0
    const uint8* receive_buffer = at_uart_get_receive_buffer();
    8518:	f001 fa18 	bl	994c <at_uart_get_receive_buffer>
    851c:	9003      	str	r0, [sp, #12]
    log_event(APPS_SW_MODULE_AT, LOG_VERBOSITY_VERBOSE, LOG_FLAGS_RESTRICTED, NEUL_LOG_TYPE_STRING, (uint16)strlen((const char *)receive_buffer), receive_buffer);
    851e:	f012 ff3e 	bl	1b39e <strlen>
    8522:	9b03      	ldr	r3, [sp, #12]
    8524:	b280      	uxth	r0, r0
    8526:	9301      	str	r3, [sp, #4]
    8528:	2300      	movs	r3, #0
    852a:	9000      	str	r0, [sp, #0]
    852c:	2204      	movs	r2, #4
    852e:	0019      	movs	r1, r3
    8530:	2008      	movs	r0, #8
    8532:	f7fe f883 	bl	663c <log_event>
    if ( ((p_str[0] == 'A') || (p_str[0] == 'a'))
    8536:	2320      	movs	r3, #32
    8538:	7822      	ldrb	r2, [r4, #0]
    853a:	439a      	bics	r2, r3
    853c:	2a41      	cmp	r2, #65	; 0x41
    853e:	d11f      	bne.n	8580 <at_main+0x7c>
    &&((p_str[1] == 'T') || (p_str[1] == 't'))
    8540:	7862      	ldrb	r2, [r4, #1]
    8542:	439a      	bics	r2, r3
    8544:	2a54      	cmp	r2, #84	; 0x54
    8546:	d11b      	bne.n	8580 <at_main+0x7c>
    &&( p_str[2] == '+')
    8548:	78a2      	ldrb	r2, [r4, #2]
    854a:	2a2b      	cmp	r2, #43	; 0x2b
    854c:	d118      	bne.n	8580 <at_main+0x7c>
    &&((p_str[3] == 'N') || (p_str[3] == 'n'))
    854e:	78e2      	ldrb	r2, [r4, #3]
    8550:	439a      	bics	r2, r3
    8552:	2a4e      	cmp	r2, #78	; 0x4e
    8554:	d114      	bne.n	8580 <at_main+0x7c>
    &&((p_str[4] == 'R') || (p_str[4] == 'r'))
    8556:	7922      	ldrb	r2, [r4, #4]
    8558:	439a      	bics	r2, r3
    855a:	2a52      	cmp	r2, #82	; 0x52
    855c:	d110      	bne.n	8580 <at_main+0x7c>
    &&((p_str[5] == 'B') || (p_str[5] == 'b'))
    855e:	7962      	ldrb	r2, [r4, #5]
    8560:	439a      	bics	r2, r3
    8562:	2a42      	cmp	r2, #66	; 0x42
    8564:	d10c      	bne.n	8580 <at_main+0x7c>
    &&(p_str[6] == '\0'))
    8566:	79a3      	ldrb	r3, [r4, #6]
    8568:	2b00      	cmp	r3, #0
    856a:	d109      	bne.n	8580 <at_main+0x7c>
        cmd_cb = at_get_atcmd_cb_from_atstring((p_str+2), &at_cmd_len);
    856c:	210e      	movs	r1, #14
    856e:	ab04      	add	r3, sp, #16
    8570:	1ca0      	adds	r0, r4, #2
    8572:	18c9      	adds	r1, r1, r3
    8574:	f002 f9c4 	bl	a900 <at_get_atcmd_cb_from_atstring>
        if (cmd_cb != NULL)
    8578:	2800      	cmp	r0, #0
    857a:	d001      	beq.n	8580 <at_main+0x7c>
            (void)cmd_cb->at_exec_handler();
    857c:	6943      	ldr	r3, [r0, #20]
    857e:	4798      	blx	r3
    if (g_blocking_at_command_protected) //ingored when aborting is progressing
    8580:	4fa1      	ldr	r7, [pc, #644]	; (8808 <at_main+0x304>)
    8582:	783b      	ldrb	r3, [r7, #0]
    8584:	2b00      	cmp	r3, #0
    8586:	d014      	beq.n	85b2 <at_main+0xae>
        at_uart_set_parity_error_status(false);
    8588:	2000      	movs	r0, #0
    858a:	f001 f9ef 	bl	996c <at_uart_set_parity_error_status>
        at_uart_set_frame_error_status(false);
    858e:	2000      	movs	r0, #0
    8590:	f001 f9fe 	bl	9990 <at_uart_set_frame_error_status>
        at_uart_set_buffer_error_status(false);
    8594:	2000      	movs	r0, #0
        at_uart_set_buffer_error_status(false);
    8596:	f001 f9f5 	bl	9984 <at_uart_set_buffer_error_status>
        at_uart_mark_can_receive();
    859a:	f001 f90d 	bl	97b8 <at_uart_mark_can_receive>
        delayed_async_output_list();
    859e:	f002 fb61 	bl	ac64 <delayed_async_output_list>
    at_uart_switch_to_new_config();
    85a2:	f001 fce5 	bl	9f70 <at_uart_switch_to_new_config>
    (void)at_uart_store_new_config();
    85a6:	f001 fbed 	bl	9d84 <at_uart_store_new_config>
    at_uart_switch_to_ppp();
    85aa:	f001 fd4d 	bl	a048 <at_uart_switch_to_ppp>
}
    85ae:	b009      	add	sp, #36	; 0x24
    85b0:	bdf0      	pop	{r4, r5, r6, r7, pc}
    if(g_at_cmd_in_progress)
    85b2:	4d96      	ldr	r5, [pc, #600]	; (880c <at_main+0x308>)
    85b4:	782e      	ldrb	r6, [r5, #0]
    85b6:	2e00      	cmp	r6, #0
    85b8:	d033      	beq.n	8622 <at_main+0x11e>
        if (rtc_get_time_ms() - blocking_begin_time < AT_BLOCKING_AT_CMD_PROTECT_TIME) //ingored when blocking command progress in 125 ms
    85ba:	f010 f823 	bl	18604 <rtc_get_time_ms>
    85be:	4b94      	ldr	r3, [pc, #592]	; (8810 <at_main+0x30c>)
    85c0:	681a      	ldr	r2, [r3, #0]
    85c2:	685b      	ldr	r3, [r3, #4]
    85c4:	1a80      	subs	r0, r0, r2
    85c6:	4199      	sbcs	r1, r3
    85c8:	2900      	cmp	r1, #0
    85ca:	d101      	bne.n	85d0 <at_main+0xcc>
    85cc:	287c      	cmp	r0, #124	; 0x7c
    85ce:	d9db      	bls.n	8588 <at_main+0x84>
        if ((g_at_processing_cmd_abortable) && (!AT_IS_APPLICATION_ONLY_CMD(at_processing_cmd_cb->flag)))
    85d0:	4b90      	ldr	r3, [pc, #576]	; (8814 <at_main+0x310>)
    85d2:	781b      	ldrb	r3, [r3, #0]
    85d4:	2b00      	cmp	r3, #0
    85d6:	d020      	beq.n	861a <at_main+0x116>
    85d8:	4b8f      	ldr	r3, [pc, #572]	; (8818 <at_main+0x314>)
    85da:	681b      	ldr	r3, [r3, #0]
    85dc:	881c      	ldrh	r4, [r3, #0]
    85de:	2380      	movs	r3, #128	; 0x80
    85e0:	401c      	ands	r4, r3
    85e2:	d11a      	bne.n	861a <at_main+0x116>
            g_blocking_at_command_protected = true;
    85e4:	2501      	movs	r5, #1
    85e6:	703d      	strb	r5, [r7, #0]
            neul_ret = abort_radio_processing_command();
    85e8:	f014 f97e 	bl	1c8e8 <abort_radio_processing_command>
    85ec:	1e02      	subs	r2, r0, #0
            if (neul_ret == NEUL_RET_OK)
    85ee:	d109      	bne.n	8604 <at_main+0x100>
                log_event(APPS_SW_MODULE_AT, LOG_VERBOSITY_NORMAL, LOG_FLAGS_NONE, NEUL_LOG_TYPE_STRING, (uint16)sizeof(AT_ABORTING_LOG_STRING), (const uint8*)AT_ABORTING_LOG_STRING);
    85f0:	4b8a      	ldr	r3, [pc, #552]	; (881c <at_main+0x318>)
    85f2:	9301      	str	r3, [sp, #4]
    85f4:	2309      	movs	r3, #9
    85f6:	9300      	str	r3, [sp, #0]
    85f8:	0003      	movs	r3, r0
                log_event(APPS_SW_MODULE_AT, LOG_VERBOSITY_NORMAL, LOG_FLAGS_NONE, NEUL_LOG_TYPE_STRING, (uint16)sizeof(AT_NO_COMMAND_TO_ABORT_LOG_STRING), (const uint8*)AT_NO_COMMAND_TO_ABORT_LOG_STRING);
    85fa:	0029      	movs	r1, r5
    85fc:	2008      	movs	r0, #8
    85fe:	f7fe f81d 	bl	663c <log_event>
    8602:	e7c1      	b.n	8588 <at_main+0x84>
                g_blocking_at_command_protected = false;
    8604:	703c      	strb	r4, [r7, #0]
                at_status_output(AT_RET_CMD_ABORT_ERROR);
    8606:	201e      	movs	r0, #30
            else if (neul_ret == NEUL_RET_NO_COMMAND_TO_ABORT)
    8608:	2a1f      	cmp	r2, #31
    860a:	d107      	bne.n	861c <at_main+0x118>
                log_event(APPS_SW_MODULE_AT, LOG_VERBOSITY_NORMAL, LOG_FLAGS_NONE, NEUL_LOG_TYPE_STRING, (uint16)sizeof(AT_NO_COMMAND_TO_ABORT_LOG_STRING), (const uint8*)AT_NO_COMMAND_TO_ABORT_LOG_STRING);
    860c:	4b84      	ldr	r3, [pc, #528]	; (8820 <at_main+0x31c>)
    860e:	0022      	movs	r2, r4
    8610:	9301      	str	r3, [sp, #4]
    8612:	2314      	movs	r3, #20
    8614:	9300      	str	r3, [sp, #0]
    8616:	0023      	movs	r3, r4
    8618:	e7ef      	b.n	85fa <at_main+0xf6>
            at_status_output(AT_RET_CMD_IN_PROGRESS);
    861a:	2005      	movs	r0, #5
    861c:	f000 feee 	bl	93fc <at_status_output>
    8620:	e7b2      	b.n	8588 <at_main+0x84>
    if (at_uart_get_parity_error_status())
    8622:	f001 f997 	bl	9954 <at_uart_get_parity_error_status>
    8626:	0007      	movs	r7, r0
        at_status_output(AT_RET_UART_PARITY_ERROR);
    8628:	2019      	movs	r0, #25
    if (at_uart_get_parity_error_status())
    862a:	2f00      	cmp	r7, #0
    862c:	d1f6      	bne.n	861c <at_main+0x118>
    else if (at_uart_get_frame_error_status())
    862e:	f001 f997 	bl	9960 <at_uart_get_frame_error_status>
    8632:	2800      	cmp	r0, #0
    8634:	d007      	beq.n	8646 <at_main+0x142>
        at_status_output(AT_RET_UART_FRAME_ERROR);
    8636:	201b      	movs	r0, #27
    8638:	f000 fee0 	bl	93fc <at_status_output>
        at_uart_set_frame_error_status(false);
    863c:	0038      	movs	r0, r7
    863e:	f001 f9a7 	bl	9990 <at_uart_set_frame_error_status>
        at_uart_set_buffer_error_status(false);
    8642:	0038      	movs	r0, r7
    8644:	e7a7      	b.n	8596 <at_main+0x92>
    else if (at_uart_get_buffer_error_status())
    8646:	f001 f997 	bl	9978 <at_uart_get_buffer_error_status>
    864a:	2800      	cmp	r0, #0
    864c:	d003      	beq.n	8656 <at_main+0x152>
        at_status_output(AT_RET_UART_BUFFER_ERROR);
    864e:	2031      	movs	r0, #49	; 0x31
    8650:	f000 fed4 	bl	93fc <at_status_output>
    8654:	e79e      	b.n	8594 <at_main+0x90>
    if (*p_str == '\0')
    8656:	7823      	ldrb	r3, [r4, #0]
    8658:	2b00      	cmp	r3, #0
    865a:	d09e      	beq.n	859a <at_main+0x96>
    if(!get_wait_for_sms_data())
    865c:	f000 fd8c 	bl	9178 <get_wait_for_sms_data>
    8660:	9002      	str	r0, [sp, #8]
    uint32 i = 0, j;
    8662:	1e07      	subs	r7, r0, #0
    if(!get_wait_for_sms_data())
    8664:	d056      	beq.n	8714 <at_main+0x210>
        while (*p_str == AT_CMD_LF || *p_str == AT_CMD_CR)//delete whitespace before the pdu data,and lenght also -1
    8666:	7823      	ldrb	r3, [r4, #0]
    8668:	2b0a      	cmp	r3, #10
    866a:	d100      	bne.n	866e <at_main+0x16a>
    866c:	e139      	b.n	88e2 <at_main+0x3de>
    866e:	2b0d      	cmp	r3, #13
    8670:	d100      	bne.n	8674 <at_main+0x170>
    8672:	e136      	b.n	88e2 <at_main+0x3de>
        cause = at_pre_process_sms_data(str);
    8674:	0020      	movs	r0, r4
    8676:	f000 fc7d 	bl	8f74 <at_pre_process_sms_data>
    867a:	1e06      	subs	r6, r0, #0
        if(cause == AT_RET_OK)
    867c:	d103      	bne.n	8686 <at_main+0x182>
            cause = at_process_sms_data(str);
    867e:	0020      	movs	r0, r4
    8680:	f000 fcce 	bl	9020 <at_process_sms_data>
    8684:	0006      	movs	r6, r0
        if(cause == AT_RET_CMD_IN_PROGRESS_BLOCK)
    8686:	2e09      	cmp	r6, #9
    8688:	d000      	beq.n	868c <at_main+0x188>
    868a:	e132      	b.n	88f2 <at_main+0x3ee>
    g_at_cmd_in_progress = status;
    868c:	2301      	movs	r3, #1
    868e:	702b      	strb	r3, [r5, #0]
        clear_wait_for_sms_data();
    8690:	f000 fd6c 	bl	916c <clear_wait_for_sms_data>
        set_at_sms_msg_type(AT_SMS_MESSAGE_NULL);
    8694:	2000      	movs	r0, #0
    8696:	f000 fd5d 	bl	9154 <set_at_sms_msg_type>
    869a:	e10a      	b.n	88b2 <at_main+0x3ae>
        if (p_str[i] == AT_CMD_DOUBLE_QUOTATION)
    869c:	2d22      	cmp	r5, #34	; 0x22
    869e:	d16c      	bne.n	877a <at_main+0x276>
            in_double_quotes = !in_double_quotes;
    86a0:	2201      	movs	r2, #1
    86a2:	9b02      	ldr	r3, [sp, #8]
    86a4:	4053      	eors	r3, r2
    86a6:	b2db      	uxtb	r3, r3
    86a8:	9302      	str	r3, [sp, #8]
        if (((p_str[i] == AT_CMD_PARAM_SEPARATOR) || (p_str[i] == AT_CMD_SEPARATOR)) && (!in_double_quotes))
    86aa:	9b04      	ldr	r3, [sp, #16]
    86ac:	781b      	ldrb	r3, [r3, #0]
    86ae:	2b2c      	cmp	r3, #44	; 0x2c
    86b0:	d001      	beq.n	86b6 <at_main+0x1b2>
    86b2:	2b3b      	cmp	r3, #59	; 0x3b
    86b4:	d12d      	bne.n	8712 <at_main+0x20e>
    86b6:	9b02      	ldr	r3, [sp, #8]
    86b8:	2b00      	cmp	r3, #0
    86ba:	d12a      	bne.n	8712 <at_main+0x20e>
            if (i > 0)
    86bc:	2f00      	cmp	r7, #0
    86be:	d014      	beq.n	86ea <at_main+0x1e6>
                j = i - 1;
    86c0:	1e7b      	subs	r3, r7, #1
    86c2:	001d      	movs	r5, r3
                while (p_str[j] == AT_CMD_WHITE_SPACE)
    86c4:	5d62      	ldrb	r2, [r4, r5]
    86c6:	2a20      	cmp	r2, #32
    86c8:	d100      	bne.n	86cc <at_main+0x1c8>
    86ca:	e097      	b.n	87fc <at_main+0x2f8>
                if (j != (i - 1))
    86cc:	42ab      	cmp	r3, r5
    86ce:	d00c      	beq.n	86ea <at_main+0x1e6>
                    memmove((p_str + j + 1), (p_str + i), (strlen((char*)p_str) - i) + 1); // +1 for '\0'
    86d0:	0020      	movs	r0, r4
    86d2:	f012 fe64 	bl	1b39e <strlen>
    86d6:	2301      	movs	r3, #1
    86d8:	3501      	adds	r5, #1
    86da:	1bda      	subs	r2, r3, r7
    86dc:	1966      	adds	r6, r4, r5
    86de:	1812      	adds	r2, r2, r0
    86e0:	9904      	ldr	r1, [sp, #16]
    86e2:	0030      	movs	r0, r6
    86e4:	f012 fe11 	bl	1b30a <memmove>
                    i = j + 1; // make sure i is right for the new p_str.
    86e8:	002f      	movs	r7, r5
            j = i + 1;
    86ea:	1c7e      	adds	r6, r7, #1
    86ec:	0035      	movs	r5, r6
    86ee:	1963      	adds	r3, r4, r5
    86f0:	9304      	str	r3, [sp, #16]
            while (p_str[j] == AT_CMD_WHITE_SPACE)
    86f2:	5d63      	ldrb	r3, [r4, r5]
    86f4:	2b20      	cmp	r3, #32
    86f6:	d100      	bne.n	86fa <at_main+0x1f6>
    86f8:	e082      	b.n	8800 <at_main+0x2fc>
            if (j != (i + 1))
    86fa:	42ae      	cmp	r6, r5
    86fc:	d009      	beq.n	8712 <at_main+0x20e>
                memmove((p_str + i + 1), (p_str + j), (strlen((char*)p_str) - j) + 1); // +1 for '\0'
    86fe:	0020      	movs	r0, r4
    8700:	f012 fe4d 	bl	1b39e <strlen>
    8704:	2301      	movs	r3, #1
    8706:	1b5a      	subs	r2, r3, r5
    8708:	1812      	adds	r2, r2, r0
    870a:	9904      	ldr	r1, [sp, #16]
    870c:	19a0      	adds	r0, r4, r6
    870e:	f012 fdfc 	bl	1b30a <memmove>
        i++;
    8712:	3701      	adds	r7, #1
    while (p_str[i] != AT_CMD_END_MARK)
    8714:	19e3      	adds	r3, r4, r7
    8716:	781d      	ldrb	r5, [r3, #0]
    8718:	9304      	str	r3, [sp, #16]
    871a:	2d00      	cmp	r5, #0
    871c:	d1be      	bne.n	869c <at_main+0x198>
    i = strlen((char*)p_str) - 1;
    871e:	0020      	movs	r0, r4
    8720:	f012 fe3d 	bl	1b39e <strlen>
    8724:	3801      	subs	r0, #1
    while (p_str[i] == AT_CMD_WHITE_SPACE)
    8726:	5c23      	ldrb	r3, [r4, r0]
    8728:	2b20      	cmp	r3, #32
    872a:	d06b      	beq.n	8804 <at_main+0x300>
    if (in_double_quotes)
    872c:	9b02      	ldr	r3, [sp, #8]
    872e:	2b00      	cmp	r3, #0
    8730:	d141      	bne.n	87b6 <at_main+0x2b2>
            *(str + count) = (uint8) toupper( *(str + count));//lint !e1058 !e866
    8732:	2003      	movs	r0, #3
    8734:	493b      	ldr	r1, [pc, #236]	; (8824 <at_main+0x320>)
    8736:	7823      	ldrb	r3, [r4, #0]
    8738:	680a      	ldr	r2, [r1, #0]
    873a:	18d2      	adds	r2, r2, r3
    873c:	7852      	ldrb	r2, [r2, #1]
    873e:	4002      	ands	r2, r0
    8740:	2a02      	cmp	r2, #2
    8742:	d100      	bne.n	8746 <at_main+0x242>
    8744:	3b20      	subs	r3, #32
    8746:	7023      	strb	r3, [r4, #0]
    8748:	680a      	ldr	r2, [r1, #0]
    874a:	2103      	movs	r1, #3
    874c:	7863      	ldrb	r3, [r4, #1]
    874e:	18d2      	adds	r2, r2, r3
    8750:	7852      	ldrb	r2, [r2, #1]
    8752:	400a      	ands	r2, r1
    8754:	2a02      	cmp	r2, #2
    8756:	d100      	bne.n	875a <at_main+0x256>
    8758:	3b20      	subs	r3, #32
    875a:	7063      	strb	r3, [r4, #1]
        if(at_strncmp( AT_CMD_PREFIX, str, AT_CMD_PREFIX_LEN) != 0)
    875c:	2202      	movs	r2, #2
    875e:	0021      	movs	r1, r4
    8760:	4831      	ldr	r0, [pc, #196]	; (8828 <at_main+0x324>)
    8762:	f012 fe28 	bl	1b3b6 <strncmp>
    8766:	9004      	str	r0, [sp, #16]
    8768:	2800      	cmp	r0, #0
    876a:	d124      	bne.n	87b6 <at_main+0x2b2>
        if(at_strlen(str) == AT_CMD_PREFIX_LEN)
    876c:	0020      	movs	r0, r4
    876e:	f012 fe16 	bl	1b39e <strlen>
    8772:	2802      	cmp	r0, #2
    8774:	d15c      	bne.n	8830 <at_main+0x32c>
            return AT_RET_OK;
    8776:	2600      	movs	r6, #0
    8778:	e01e      	b.n	87b8 <at_main+0x2b4>
        if ((p_str[i] == AT_CMD_EQUAL_MARK) && (!in_double_quotes))
    877a:	2d3d      	cmp	r5, #61	; 0x3d
    877c:	d195      	bne.n	86aa <at_main+0x1a6>
    877e:	9b02      	ldr	r3, [sp, #8]
    8780:	2b00      	cmp	r3, #0
    8782:	d192      	bne.n	86aa <at_main+0x1a6>
            j = i + 1;
    8784:	1c7e      	adds	r6, r7, #1
    8786:	0035      	movs	r5, r6
    8788:	1963      	adds	r3, r4, r5
    878a:	9305      	str	r3, [sp, #20]
            while (p_str[j] == AT_CMD_WHITE_SPACE)
    878c:	5d63      	ldrb	r3, [r4, r5]
    878e:	2b20      	cmp	r3, #32
    8790:	d00d      	beq.n	87ae <at_main+0x2aa>
            if (j != (i + 1))
    8792:	42ae      	cmp	r6, r5
    8794:	d089      	beq.n	86aa <at_main+0x1a6>
                memmove((p_str + i + 1), (p_str + j), (strlen((char*)p_str) - j) + 1); // +1 for '\0'
    8796:	0020      	movs	r0, r4
    8798:	f012 fe01 	bl	1b39e <strlen>
    879c:	2301      	movs	r3, #1
    879e:	19a6      	adds	r6, r4, r6
    87a0:	1b5a      	subs	r2, r3, r5
    87a2:	1812      	adds	r2, r2, r0
    87a4:	9905      	ldr	r1, [sp, #20]
    87a6:	0030      	movs	r0, r6
    87a8:	f012 fdaf 	bl	1b30a <memmove>
    87ac:	e77d      	b.n	86aa <at_main+0x1a6>
                j++;
    87ae:	3501      	adds	r5, #1
                if (p_str[j] == AT_CMD_QUESTION_MARK)
    87b0:	5d63      	ldrb	r3, [r4, r5]
    87b2:	2b3f      	cmp	r3, #63	; 0x3f
    87b4:	d1e8      	bne.n	8788 <at_main+0x284>
            return AT_RET_OK;
    87b6:	2601      	movs	r6, #1
    87b8:	2401      	movs	r4, #1
    87ba:	0022      	movs	r2, r4
    87bc:	40b2      	lsls	r2, r6
    87be:	4b1b      	ldr	r3, [pc, #108]	; (882c <at_main+0x328>)
    87c0:	421a      	tst	r2, r3
    87c2:	d010      	beq.n	87e6 <at_main+0x2e2>
    if (at_dump_uart_receive_buffer(cause) && (log_get_verbosity() != LOG_VERBOSITY_VERBOSE)) // Prevent whole at_uart_receive_buffer printed twice
    87c4:	f7fd ff34 	bl	6630 <log_get_verbosity>
    87c8:	2800      	cmp	r0, #0
    87ca:	d00c      	beq.n	87e6 <at_main+0x2e2>
        log_event(APPS_SW_MODULE_AT, LOG_VERBOSITY_NORMAL, LOG_FLAGS_RESTRICTED, NEUL_LOG_TYPE_STRING, (uint16)strlen((const char *)receive_buffer), receive_buffer);
    87cc:	9803      	ldr	r0, [sp, #12]
    87ce:	f012 fde6 	bl	1b39e <strlen>
    87d2:	9b03      	ldr	r3, [sp, #12]
    87d4:	b280      	uxth	r0, r0
    87d6:	9301      	str	r3, [sp, #4]
    87d8:	9000      	str	r0, [sp, #0]
    87da:	2300      	movs	r3, #0
    87dc:	2204      	movs	r2, #4
    87de:	0021      	movs	r1, r4
    87e0:	2008      	movs	r0, #8
    87e2:	f7fd ff2b 	bl	663c <log_event>
    if (cause != AT_RET_SYNTAX_ERROR)
    87e6:	2e01      	cmp	r6, #1
    87e8:	d166      	bne.n	88b8 <at_main+0x3b4>
        at_status_output(cause);
    87ea:	0030      	movs	r0, r6
    87ec:	f000 fe06 	bl	93fc <at_status_output>
        if(cause == AT_RET_OK)
    87f0:	2e00      	cmp	r6, #0
    87f2:	d000      	beq.n	87f6 <at_main+0x2f2>
    87f4:	e6d1      	b.n	859a <at_main+0x96>
            app_at_send_next_command();
    87f6:	f7ff fdcb 	bl	8390 <app_at_send_next_command>
    87fa:	e6ce      	b.n	859a <at_main+0x96>
                    j--;
    87fc:	3d01      	subs	r5, #1
    87fe:	e761      	b.n	86c4 <at_main+0x1c0>
                j++;
    8800:	3501      	adds	r5, #1
    8802:	e774      	b.n	86ee <at_main+0x1ea>
        p_str[i--] = AT_CMD_END_MARK;
    8804:	5425      	strb	r5, [r4, r0]
    8806:	e78d      	b.n	8724 <at_main+0x220>
    8808:	01001985 	.word	0x01001985
    880c:	01001978 	.word	0x01001978
    8810:	01001970 	.word	0x01001970
    8814:	01001984 	.word	0x01001984
    8818:	01001968 	.word	0x01001968
    881c:	00022df7 	.word	0x00022df7
    8820:	00022e00 	.word	0x00022e00
    8824:	010005dc 	.word	0x010005dc
    8828:	00023a9a 	.word	0x00023a9a
    882c:	0000200e 	.word	0x0000200e
        str = str + AT_CMD_PREFIX_LEN; //+CABCD=1,2,3;+CDE=4,5
    8830:	3402      	adds	r4, #2
        at_cmd_len = (uint16)at_strlen(str) + 1;
    8832:	0020      	movs	r0, r4
    8834:	f012 fdb3 	bl	1b39e <strlen>
    8838:	3001      	adds	r0, #1
        g_at_cmd_info.str = at_alloc(at_cmd_len);
    883a:	b285      	uxth	r5, r0
    883c:	0028      	movs	r0, r5
    883e:	f00a f8e9 	bl	12a14 <irzalloc>
    8842:	4f35      	ldr	r7, [pc, #212]	; (8918 <at_main+0x414>)
    8844:	1e06      	subs	r6, r0, #0
    8846:	6038      	str	r0, [r7, #0]
        if (g_at_cmd_info.str == NULL)
    8848:	d05a      	beq.n	8900 <at_main+0x3fc>
        g_at_cmd_info.offset = 0;
    884a:	466b      	mov	r3, sp
    884c:	8a1b      	ldrh	r3, [r3, #16]
        memcpy(g_at_cmd_info.str, str, at_cmd_len);
    884e:	002a      	movs	r2, r5
    8850:	0021      	movs	r1, r4
        g_at_cmd_info.offset = 0;
    8852:	80bb      	strh	r3, [r7, #4]
        memcpy(g_at_cmd_info.str, str, at_cmd_len);
    8854:	f7f7 fccc 	bl	1f0 <memcpy>
        at_cmd_len = at_get_cmd_length(g_at_cmd_info.str); //one AT command len
    8858:	0030      	movs	r0, r6
    885a:	f001 fc5a 	bl	a112 <at_get_cmd_length>
        if(g_at_cmd_info.str[at_cmd_len ] == '\0')
    885e:	683b      	ldr	r3, [r7, #0]
        at_cmd_len = at_get_cmd_length(g_at_cmd_info.str); //one AT command len
    8860:	0005      	movs	r5, r0
        if(g_at_cmd_info.str[at_cmd_len ] == '\0')
    8862:	5c1a      	ldrb	r2, [r3, r0]
    8864:	2301      	movs	r3, #1
    8866:	2a00      	cmp	r2, #0
    8868:	d02c      	beq.n	88c4 <at_main+0x3c0>
        else if(g_at_cmd_info.str[at_cmd_len ] == ';')
    886a:	2a3b      	cmp	r2, #59	; 0x3b
    886c:	d102      	bne.n	8874 <at_main+0x370>
            str[at_cmd_len] = '\0'; //+1
    886e:	466a      	mov	r2, sp
    8870:	7c12      	ldrb	r2, [r2, #16]
    8872:	5422      	strb	r2, [r4, r0]
    g_at_cmd_in_progress = status;
    8874:	4f29      	ldr	r7, [pc, #164]	; (891c <at_main+0x418>)
        cause = at_perform_one_atcommand(str);
    8876:	0020      	movs	r0, r4
    g_at_cmd_in_progress = status;
    8878:	703b      	strb	r3, [r7, #0]
        cause = at_perform_one_atcommand(str);
    887a:	f7ff fd1b 	bl	82b4 <at_perform_one_atcommand>
    887e:	0004      	movs	r4, r0
    8880:	0006      	movs	r6, r0
        if(cause == AT_RET_CMD_IN_PROGRESS_BLOCK)
    8882:	2809      	cmp	r0, #9
    8884:	d120      	bne.n	88c8 <at_main+0x3c4>
            blocking_begin_time = rtc_get_time_ms();
    8886:	f00f febd 	bl	18604 <rtc_get_time_ms>
    888a:	4b25      	ldr	r3, [pc, #148]	; (8920 <at_main+0x41c>)
    888c:	6018      	str	r0, [r3, #0]
    888e:	6059      	str	r1, [r3, #4]
        if(end_flag)
    8890:	9b02      	ldr	r3, [sp, #8]
    8892:	2b00      	cmp	r3, #0
    8894:	d01f      	beq.n	88d6 <at_main+0x3d2>
            at_free_cmd_memory();
    8896:	f7ff fd6d 	bl	8374 <at_free_cmd_memory>
        if( (cause != AT_RET_OK) && (cause != AT_RET_CMD_IN_PROGRESS_BLOCK))
    889a:	2c00      	cmp	r4, #0
    889c:	d100      	bne.n	88a0 <at_main+0x39c>
    889e:	e76a      	b.n	8776 <at_main+0x272>
    88a0:	2c09      	cmp	r4, #9
    88a2:	d089      	beq.n	87b8 <at_main+0x2b4>
            at_processing_cmd_cb            = NULL;
    88a4:	2300      	movs	r3, #0
    88a6:	4a1f      	ldr	r2, [pc, #124]	; (8924 <at_main+0x420>)
    88a8:	6013      	str	r3, [r2, #0]
            g_at_processing_cmd_abortable   = false;
    88aa:	4a1f      	ldr	r2, [pc, #124]	; (8928 <at_main+0x424>)
    88ac:	7013      	strb	r3, [r2, #0]
            at_free_cmd_memory();
    88ae:	f7ff fd61 	bl	8374 <at_free_cmd_memory>
    88b2:	2e0d      	cmp	r6, #13
    88b4:	d800      	bhi.n	88b8 <at_main+0x3b4>
    88b6:	e77f      	b.n	87b8 <at_main+0x2b4>
        at_uart_mark_ensure_change_config();
    88b8:	f001 fa56 	bl	9d68 <at_uart_mark_ensure_change_config>
    if(cause != AT_RET_CMD_IN_PROGRESS_BLOCK)
    88bc:	2e09      	cmp	r6, #9
    88be:	d100      	bne.n	88c2 <at_main+0x3be>
    88c0:	e66b      	b.n	859a <at_main+0x96>
    88c2:	e792      	b.n	87ea <at_main+0x2e6>
            end_flag = true;
    88c4:	9302      	str	r3, [sp, #8]
    88c6:	e7d5      	b.n	8874 <at_main+0x370>
    g_at_cmd_in_progress = status;
    88c8:	2300      	movs	r3, #0
            g_at_processing_cmd_abortable   = false;
    88ca:	4a17      	ldr	r2, [pc, #92]	; (8928 <at_main+0x424>)
    g_at_cmd_in_progress = status;
    88cc:	703b      	strb	r3, [r7, #0]
            g_at_processing_cmd_abortable   = false;
    88ce:	7013      	strb	r3, [r2, #0]
            at_processing_cmd_cb            = NULL;
    88d0:	4a14      	ldr	r2, [pc, #80]	; (8924 <at_main+0x420>)
    88d2:	6013      	str	r3, [r2, #0]
    88d4:	e7dc      	b.n	8890 <at_main+0x38c>
            g_at_cmd_info.offset += (at_cmd_len + 1);        //+ 1 for ;
    88d6:	4a10      	ldr	r2, [pc, #64]	; (8918 <at_main+0x414>)
    88d8:	8893      	ldrh	r3, [r2, #4]
    88da:	3301      	adds	r3, #1
    88dc:	18ed      	adds	r5, r5, r3
    88de:	8095      	strh	r5, [r2, #4]
    88e0:	e7db      	b.n	889a <at_main+0x396>
            set_sms_uart_pdu_len(get_sms_uart_pdu_len()-1);
    88e2:	f000 fa0b 	bl	8cfc <get_sms_uart_pdu_len>
    88e6:	3801      	subs	r0, #1
    88e8:	b280      	uxth	r0, r0
            p_str++;
    88ea:	3401      	adds	r4, #1
            set_sms_uart_pdu_len(get_sms_uart_pdu_len()-1);
    88ec:	f000 fa00 	bl	8cf0 <set_sms_uart_pdu_len>
    88f0:	e6b9      	b.n	8666 <at_main+0x162>
    g_at_cmd_in_progress = status;
    88f2:	2300      	movs	r3, #0
            cause = at_parse_convert_sms_result(cause);
    88f4:	0030      	movs	r0, r6
    g_at_cmd_in_progress = status;
    88f6:	702b      	strb	r3, [r5, #0]
            cause = at_parse_convert_sms_result(cause);
    88f8:	f001 fcd4 	bl	a2a4 <at_parse_convert_sms_result>
    88fc:	0006      	movs	r6, r0
    88fe:	e6c7      	b.n	8690 <at_main+0x18c>
            return AT_RET_MEMORY_ERROR;
    8900:	2604      	movs	r6, #4
    8902:	e759      	b.n	87b8 <at_main+0x2b4>
    else if (at_uart_should_restart_at())
    8904:	f001 fbc0 	bl	a088 <at_uart_should_restart_at>
    8908:	2800      	cmp	r0, #0
    890a:	d100      	bne.n	890e <at_main+0x40a>
    890c:	e64f      	b.n	85ae <at_main+0xaa>
        app_at_send_callback_response(AT_RET_OK);
    890e:	2000      	movs	r0, #0
    8910:	f7ff fdda 	bl	84c8 <app_at_send_callback_response>
}
    8914:	e64b      	b.n	85ae <at_main+0xaa>
    8916:	46c0      	nop			; (mov r8, r8)
    8918:	0100197c 	.word	0x0100197c
    891c:	01001978 	.word	0x01001978
    8920:	01001970 	.word	0x01001970
    8924:	01001968 	.word	0x01001968
    8928:	01001984 	.word	0x01001984

0000892c <app_at_send_sms_callback_response>:
{
    892c:	b510      	push	{r4, lr}
    at_status_sms_output(result);
    892e:	f000 fd21 	bl	9374 <at_status_sms_output>
    g_at_cmd_in_progress = status;
    8932:	2300      	movs	r3, #0
    8934:	4a05      	ldr	r2, [pc, #20]	; (894c <app_at_send_sms_callback_response+0x20>)
    8936:	7013      	strb	r3, [r2, #0]
    g_blocking_at_command_protected = false;
    8938:	4a05      	ldr	r2, [pc, #20]	; (8950 <app_at_send_sms_callback_response+0x24>)
    893a:	7013      	strb	r3, [r2, #0]
    g_at_processing_cmd_abortable   = false;
    893c:	4a05      	ldr	r2, [pc, #20]	; (8954 <app_at_send_sms_callback_response+0x28>)
    893e:	7013      	strb	r3, [r2, #0]
    at_processing_cmd_cb            = NULL;
    8940:	4a05      	ldr	r2, [pc, #20]	; (8958 <app_at_send_sms_callback_response+0x2c>)
    8942:	6013      	str	r3, [r2, #0]
    at_free_cmd_memory();
    8944:	f7ff fd16 	bl	8374 <at_free_cmd_memory>
}
    8948:	bd10      	pop	{r4, pc}
    894a:	46c0      	nop			; (mov r8, r8)
    894c:	01001978 	.word	0x01001978
    8950:	01001985 	.word	0x01001985
    8954:	01001984 	.word	0x01001984
    8958:	01001968 	.word	0x01001968

0000895c <at_init>:

}
#endif

void at_init(at_uart_received_at_notify callback)
{
    895c:	b530      	push	{r4, r5, lr}
    895e:	b099      	sub	sp, #100	; 0x64
    if (callback != NULL)
    8960:	2800      	cmp	r0, #0
    8962:	d001      	beq.n	8968 <at_init+0xc>
    {
        at_uart_set_received_at_notify_callback(callback);
    8964:	f001 f81a 	bl	999c <at_uart_set_received_at_notify_callback>
    }
    at_uart_init();
    8968:	f001 fa4a 	bl	9e00 <at_uart_init>

    app_at_async_notify_init();
    896c:	f002 fa00 	bl	ad70 <app_at_async_notify_init>
    app_at_ip_mtu_init();
    8970:	f000 fc9c 	bl	92ac <app_at_ip_mtu_init>
    activity_indication_init();
    8974:	f014 fed0 	bl	1d718 <activity_indication_init>
    (void)activity_indication_output(true);
    8978:	2001      	movs	r0, #1
    897a:	f014 ff17 	bl	1d7ac <activity_indication_output>
    switch(reboot_get_reset_reason())
    897e:	f00f fca9 	bl	182d4 <reboot_get_reset_reason>
    8982:	4b62      	ldr	r3, [pc, #392]	; (8b0c <at_init+0x1b0>)
            str = AT_REBOOT_CAUSE_SECURITY_WATCHDOG;
    8984:	4c62      	ldr	r4, [pc, #392]	; (8b10 <at_init+0x1b4>)
    switch(reboot_get_reset_reason())
    8986:	4298      	cmp	r0, r3
    8988:	d015      	beq.n	89b6 <at_init+0x5a>
    898a:	d900      	bls.n	898e <at_init+0x32>
    898c:	e08b      	b.n	8aa6 <at_init+0x14a>
    898e:	4b61      	ldr	r3, [pc, #388]	; (8b14 <at_init+0x1b8>)
            str = AT_REBOOT_CAUSE_PROTOCOL_WATCHDOG;
    8990:	4c61      	ldr	r4, [pc, #388]	; (8b18 <at_init+0x1bc>)
    switch(reboot_get_reset_reason())
    8992:	4298      	cmp	r0, r3
    8994:	d00f      	beq.n	89b6 <at_init+0x5a>
    8996:	d900      	bls.n	899a <at_init+0x3e>
    8998:	e06f      	b.n	8a7a <at_init+0x11e>
    899a:	4b60      	ldr	r3, [pc, #384]	; (8b1c <at_init+0x1c0>)
            str = AT_REBOOT_CAUSE_APPLICATION_AT;
    899c:	4c60      	ldr	r4, [pc, #384]	; (8b20 <at_init+0x1c4>)
    switch(reboot_get_reset_reason())
    899e:	4298      	cmp	r0, r3
    89a0:	d009      	beq.n	89b6 <at_init+0x5a>
    89a2:	d863      	bhi.n	8a6c <at_init+0x110>
    89a4:	4b5f      	ldr	r3, [pc, #380]	; (8b24 <at_init+0x1c8>)
            str = AT_REBOOT_CAUSE_APPLICATION_SYSRESETREQ;
    89a6:	4c60      	ldr	r4, [pc, #384]	; (8b28 <at_init+0x1cc>)
    switch(reboot_get_reset_reason())
    89a8:	4298      	cmp	r0, r3
    89aa:	d004      	beq.n	89b6 <at_init+0x5a>
    89ac:	4b5f      	ldr	r3, [pc, #380]	; (8b2c <at_init+0x1d0>)
            str = AT_REBOOT_CAUSE_APPLICATION_WATCHDOG;
    89ae:	4c60      	ldr	r4, [pc, #384]	; (8b30 <at_init+0x1d4>)
    switch(reboot_get_reset_reason())
    89b0:	4298      	cmp	r0, r3
    89b2:	d000      	beq.n	89b6 <at_init+0x5a>
            str = AT_REBOOT_CAUSE_UNKNOWN;
    89b4:	4c5f      	ldr	r4, [pc, #380]	; (8b34 <at_init+0x1d8>)
    at_uart_write((uint8*)AT_REBOOT_CAUSE_PREFIX, strlen(AT_REBOOT_CAUSE_PREFIX));
    89b6:	4d60      	ldr	r5, [pc, #384]	; (8b38 <at_init+0x1dc>)
    89b8:	0028      	movs	r0, r5
    89ba:	f012 fcf0 	bl	1b39e <strlen>
    89be:	0001      	movs	r1, r0
    89c0:	0028      	movs	r0, r5
    89c2:	f001 f813 	bl	99ec <at_uart_write>
    at_uart_write((uint8*)str, strlen(str));
    89c6:	0020      	movs	r0, r4
    89c8:	f012 fce9 	bl	1b39e <strlen>
    89cc:	0001      	movs	r1, r0
    89ce:	0020      	movs	r0, r4
    89d0:	f001 f80c 	bl	99ec <at_uart_write>
    at_print_reboot_reason();
    at_uart_write((uint8*)AT_MAIN_START_UP, strlen(AT_MAIN_START_UP));
    89d4:	4c59      	ldr	r4, [pc, #356]	; (8b3c <at_init+0x1e0>)
    (void)activity_indication_output(false);
    set_psm_status_reporting_callback(psm_status_callback);
    at_initialized = true;
    89d6:	2501      	movs	r5, #1
    at_uart_write((uint8*)AT_MAIN_START_UP, strlen(AT_MAIN_START_UP));
    89d8:	0020      	movs	r0, r4
    89da:	f012 fce0 	bl	1b39e <strlen>
    89de:	0001      	movs	r1, r0
    89e0:	0020      	movs	r0, r4
    89e2:	f001 f803 	bl	99ec <at_uart_write>
    (void)activity_indication_output(false);
    89e6:	2000      	movs	r0, #0
    89e8:	f014 fee0 	bl	1d7ac <activity_indication_output>
    set_psm_status_reporting_callback(psm_status_callback);
    89ec:	4854      	ldr	r0, [pc, #336]	; (8b40 <at_init+0x1e4>)
    89ee:	f013 fd39 	bl	1c464 <set_psm_status_reporting_callback>
    at_initialized = true;
    89f2:	4b54      	ldr	r3, [pc, #336]	; (8b44 <at_init+0x1e8>)

    neul_radio_register_abort_handler(at_radio_cmd_abort_callback);
    89f4:	4854      	ldr	r0, [pc, #336]	; (8b48 <at_init+0x1ec>)
    at_initialized = true;
    89f6:	701d      	strb	r5, [r3, #0]
    neul_radio_register_abort_handler(at_radio_cmd_abort_callback);
    89f8:	f013 ff8c 	bl	1c914 <neul_radio_register_abort_handler>

    set_non_ip_sent_callback(at_non_ip_sent_callback);
    89fc:	4853      	ldr	r0, [pc, #332]	; (8b4c <at_init+0x1f0>)
    89fe:	f013 f93f 	bl	1bc80 <set_non_ip_sent_callback>
    neul_radio_register_pin_handler(at_sim_pin_ind_callback);
    8a02:	4853      	ldr	r0, [pc, #332]	; (8b50 <at_init+0x1f4>)
    8a04:	f013 fdec 	bl	1c5e0 <neul_radio_register_pin_handler>
    if (get_backtrace(&backtrace))
    8a08:	a80d      	add	r0, sp, #52	; 0x34
    8a0a:	f009 ffdb 	bl	129c4 <get_backtrace>
    8a0e:	2800      	cmp	r0, #0
    8a10:	d02a      	beq.n	8a68 <at_init+0x10c>
        uint8* buff = (uint8*)irmalloc(APPS_BACKTRACE_BUFF_SIZE);
    8a12:	2096      	movs	r0, #150	; 0x96
    8a14:	f009 fff4 	bl	12a00 <irmalloc>
    8a18:	1e04      	subs	r4, r0, #0
        if (buff)
    8a1a:	d025      	beq.n	8a68 <at_init+0x10c>
            (void)snprintf((char *)buff, APPS_BACKTRACE_BUFF_SIZE, "Backtrace Depth:[0x%08x] Data[0x%08x,0x%08x,0x%08x,0x%08x,0x%08x,0x%08x,0x%08x,0x%08x,0x%08x,0x%08x]", backtrace.depth, \
    8a1c:	9b17      	ldr	r3, [sp, #92]	; 0x5c
    8a1e:	4a4d      	ldr	r2, [pc, #308]	; (8b54 <at_init+0x1f8>)
    8a20:	9309      	str	r3, [sp, #36]	; 0x24
    8a22:	9b16      	ldr	r3, [sp, #88]	; 0x58
    8a24:	2196      	movs	r1, #150	; 0x96
    8a26:	9308      	str	r3, [sp, #32]
    8a28:	9b15      	ldr	r3, [sp, #84]	; 0x54
    8a2a:	9307      	str	r3, [sp, #28]
    8a2c:	9b14      	ldr	r3, [sp, #80]	; 0x50
    8a2e:	9306      	str	r3, [sp, #24]
    8a30:	9b13      	ldr	r3, [sp, #76]	; 0x4c
    8a32:	9305      	str	r3, [sp, #20]
    8a34:	9b12      	ldr	r3, [sp, #72]	; 0x48
    8a36:	9304      	str	r3, [sp, #16]
    8a38:	9b11      	ldr	r3, [sp, #68]	; 0x44
    8a3a:	9303      	str	r3, [sp, #12]
    8a3c:	9b10      	ldr	r3, [sp, #64]	; 0x40
    8a3e:	9302      	str	r3, [sp, #8]
    8a40:	9b0f      	ldr	r3, [sp, #60]	; 0x3c
    8a42:	9301      	str	r3, [sp, #4]
    8a44:	9b0e      	ldr	r3, [sp, #56]	; 0x38
    8a46:	930b      	str	r3, [sp, #44]	; 0x2c
    8a48:	9300      	str	r3, [sp, #0]
    8a4a:	9b0d      	ldr	r3, [sp, #52]	; 0x34
    8a4c:	f011 ff0e 	bl	1a86c <snprintf>
            log_event(APPS_SW_MODULE_LOG, LOG_VERBOSITY_ERROR, LOG_FLAGS_XLOG, NEUL_LOG_TYPE_STRING, APPS_BACKTRACE_BUFF_SIZE, (const uint8 *)buff);
    8a50:	2396      	movs	r3, #150	; 0x96
    8a52:	200c      	movs	r0, #12
    8a54:	9300      	str	r3, [sp, #0]
    8a56:	9401      	str	r4, [sp, #4]
    8a58:	2300      	movs	r3, #0
    8a5a:	002a      	movs	r2, r5
    8a5c:	2103      	movs	r1, #3
    8a5e:	f7fd fded 	bl	663c <log_event>
            irfree((void*)buff);
    8a62:	0020      	movs	r0, r4
    8a64:	f009 ffe8 	bl	12a38 <irfree>
#if defined(LIBBACKTRACE)
    apps_backtrace_record();
#endif
}
    8a68:	b019      	add	sp, #100	; 0x64
    8a6a:	bd30      	pop	{r4, r5, pc}
    switch(reboot_get_reset_reason())
    8a6c:	4b3a      	ldr	r3, [pc, #232]	; (8b58 <at_init+0x1fc>)
            str = AT_REBOOT_CAUSE_APPLICATION_RPC_TIMEOUT;
    8a6e:	4c3b      	ldr	r4, [pc, #236]	; (8b5c <at_init+0x200>)
    switch(reboot_get_reset_reason())
    8a70:	4298      	cmp	r0, r3
    8a72:	d0a0      	beq.n	89b6 <at_init+0x5a>
    8a74:	4b3a      	ldr	r3, [pc, #232]	; (8b60 <at_init+0x204>)
            str = AT_REBOOT_CAUSE_PROTOCOL_SYSRESETREQ;
    8a76:	4c3b      	ldr	r4, [pc, #236]	; (8b64 <at_init+0x208>)
    8a78:	e79a      	b.n	89b0 <at_init+0x54>
    switch(reboot_get_reset_reason())
    8a7a:	4b3b      	ldr	r3, [pc, #236]	; (8b68 <at_init+0x20c>)
            str = AT_REBOOT_CAUSE_PROTOCOL_IMSI_UPDATE;
    8a7c:	4c3b      	ldr	r4, [pc, #236]	; (8b6c <at_init+0x210>)
    switch(reboot_get_reset_reason())
    8a7e:	4298      	cmp	r0, r3
    8a80:	d099      	beq.n	89b6 <at_init+0x5a>
    8a82:	d807      	bhi.n	8a94 <at_init+0x138>
    8a84:	3b02      	subs	r3, #2
            str = AT_REBOOT_CAUSE_PROTOCOL_MONITOR_REBOOT_REQ;
    8a86:	4c3a      	ldr	r4, [pc, #232]	; (8b70 <at_init+0x214>)
    switch(reboot_get_reset_reason())
    8a88:	4298      	cmp	r0, r3
    8a8a:	d100      	bne.n	8a8e <at_init+0x132>
    8a8c:	e793      	b.n	89b6 <at_init+0x5a>
    8a8e:	4b39      	ldr	r3, [pc, #228]	; (8b74 <at_init+0x218>)
            str = AT_REBOOT_CAUSE_PROTOCOL_RPC_TIMEOUT;
    8a90:	4c39      	ldr	r4, [pc, #228]	; (8b78 <at_init+0x21c>)
    8a92:	e78d      	b.n	89b0 <at_init+0x54>
    switch(reboot_get_reset_reason())
    8a94:	2380      	movs	r3, #128	; 0x80
            str = AT_REBOOT_CAUSE_SECURITY_RESET_UNKNOWN;
    8a96:	4c39      	ldr	r4, [pc, #228]	; (8b7c <at_init+0x220>)
    switch(reboot_get_reset_reason())
    8a98:	021b      	lsls	r3, r3, #8
    8a9a:	4298      	cmp	r0, r3
    8a9c:	d100      	bne.n	8aa0 <at_init+0x144>
    8a9e:	e78a      	b.n	89b6 <at_init+0x5a>
    8aa0:	4b37      	ldr	r3, [pc, #220]	; (8b80 <at_init+0x224>)
            str = AT_REBOOT_CAUSE_SECURITY_SYSRESETREQ;
    8aa2:	4c38      	ldr	r4, [pc, #224]	; (8b84 <at_init+0x228>)
    8aa4:	e784      	b.n	89b0 <at_init+0x54>
    switch(reboot_get_reset_reason())
    8aa6:	4b38      	ldr	r3, [pc, #224]	; (8b88 <at_init+0x22c>)
            str = AT_REBOOT_CAUSE_SECURITY_SCAN_ENTER_EXIT;
    8aa8:	4c38      	ldr	r4, [pc, #224]	; (8b8c <at_init+0x230>)
    switch(reboot_get_reset_reason())
    8aaa:	4298      	cmp	r0, r3
    8aac:	d100      	bne.n	8ab0 <at_init+0x154>
    8aae:	e782      	b.n	89b6 <at_init+0x5a>
    8ab0:	d815      	bhi.n	8ade <at_init+0x182>
    8ab2:	4b37      	ldr	r3, [pc, #220]	; (8b90 <at_init+0x234>)
            str = AT_REBOOT_CAUSE_SECURITY_RESET_REG_0;
    8ab4:	4c37      	ldr	r4, [pc, #220]	; (8b94 <at_init+0x238>)
    switch(reboot_get_reset_reason())
    8ab6:	4298      	cmp	r0, r3
    8ab8:	d100      	bne.n	8abc <at_init+0x160>
    8aba:	e77c      	b.n	89b6 <at_init+0x5a>
    8abc:	d807      	bhi.n	8ace <at_init+0x172>
    8abe:	4b36      	ldr	r3, [pc, #216]	; (8b98 <at_init+0x23c>)
            str = AT_REBOOT_CAUSE_SECURITY_SELF;
    8ac0:	4c36      	ldr	r4, [pc, #216]	; (8b9c <at_init+0x240>)
    switch(reboot_get_reset_reason())
    8ac2:	4298      	cmp	r0, r3
    8ac4:	d100      	bne.n	8ac8 <at_init+0x16c>
    8ac6:	e776      	b.n	89b6 <at_init+0x5a>
    8ac8:	4b35      	ldr	r3, [pc, #212]	; (8ba0 <at_init+0x244>)
            str = AT_REBOOT_CAUSE_SECURITY_ALTBOOT;
    8aca:	4c36      	ldr	r4, [pc, #216]	; (8ba4 <at_init+0x248>)
    8acc:	e770      	b.n	89b0 <at_init+0x54>
    switch(reboot_get_reset_reason())
    8ace:	4b36      	ldr	r3, [pc, #216]	; (8ba8 <at_init+0x24c>)
            str = AT_REBOOT_CAUSE_SECURITY_RESET_REG_3;
    8ad0:	4c36      	ldr	r4, [pc, #216]	; (8bac <at_init+0x250>)
    switch(reboot_get_reset_reason())
    8ad2:	4298      	cmp	r0, r3
    8ad4:	d100      	bne.n	8ad8 <at_init+0x17c>
    8ad6:	e76e      	b.n	89b6 <at_init+0x5a>
    8ad8:	4b35      	ldr	r3, [pc, #212]	; (8bb0 <at_init+0x254>)
            str = AT_REBOOT_CAUSE_SECURITY_STANDARD_CHIP_WATCHDOG;
    8ada:	4c36      	ldr	r4, [pc, #216]	; (8bb4 <at_init+0x258>)
    8adc:	e768      	b.n	89b0 <at_init+0x54>
    switch(reboot_get_reset_reason())
    8ade:	4b36      	ldr	r3, [pc, #216]	; (8bb8 <at_init+0x25c>)
            str = AT_REBOOT_CAUSE_SECURITY_REGIONS_UPDATED;
    8ae0:	4c36      	ldr	r4, [pc, #216]	; (8bbc <at_init+0x260>)
    switch(reboot_get_reset_reason())
    8ae2:	4298      	cmp	r0, r3
    8ae4:	d100      	bne.n	8ae8 <at_init+0x18c>
    8ae6:	e766      	b.n	89b6 <at_init+0x5a>
    8ae8:	d807      	bhi.n	8afa <at_init+0x19e>
    8aea:	4b35      	ldr	r3, [pc, #212]	; (8bc0 <at_init+0x264>)
            str = AT_REBOOT_CAUSE_SECURITY_PMU_POR;
    8aec:	4c35      	ldr	r4, [pc, #212]	; (8bc4 <at_init+0x268>)
    switch(reboot_get_reset_reason())
    8aee:	4298      	cmp	r0, r3
    8af0:	d100      	bne.n	8af4 <at_init+0x198>
    8af2:	e760      	b.n	89b6 <at_init+0x5a>
    8af4:	4b34      	ldr	r3, [pc, #208]	; (8bc8 <at_init+0x26c>)
            str = AT_REBOOT_CAUSE_SECURITY_RESET_PIN;
    8af6:	4c35      	ldr	r4, [pc, #212]	; (8bcc <at_init+0x270>)
    8af8:	e75a      	b.n	89b0 <at_init+0x54>
    switch(reboot_get_reset_reason())
    8afa:	4b35      	ldr	r3, [pc, #212]	; (8bd0 <at_init+0x274>)
            str = AT_REBOOT_CAUSE_SECURITY_FOTA_UPGRADE;
    8afc:	4c35      	ldr	r4, [pc, #212]	; (8bd4 <at_init+0x278>)
    switch(reboot_get_reset_reason())
    8afe:	4298      	cmp	r0, r3
    8b00:	d100      	bne.n	8b04 <at_init+0x1a8>
    8b02:	e758      	b.n	89b6 <at_init+0x5a>
    8b04:	4b34      	ldr	r3, [pc, #208]	; (8bd8 <at_init+0x27c>)
            str = AT_REBOOT_CAUSE_SECURITY_UPDATER_CHIP_WATCHDOG;
    8b06:	4c35      	ldr	r4, [pc, #212]	; (8bdc <at_init+0x280>)
    8b08:	e752      	b.n	89b0 <at_init+0x54>
    8b0a:	46c0      	nop			; (mov r8, r8)
    8b0c:	00008002 	.word	0x00008002
    8b10:	00022bae 	.word	0x00022bae
    8b14:	00004002 	.word	0x00004002
    8b18:	00022cc8 	.word	0x00022cc8
    8b1c:	00002101 	.word	0x00002101
    8b20:	00022d38 	.word	0x00022d38
    8b24:	00002001 	.word	0x00002001
    8b28:	00022d0b 	.word	0x00022d0b
    8b2c:	00002002 	.word	0x00002002
    8b30:	00022d23 	.word	0x00022d23
    8b34:	0002344d 	.word	0x0002344d
    8b38:	00022d74 	.word	0x00022d74
    8b3c:	00022d84 	.word	0x00022d84
    8b40:	000119d9 	.word	0x000119d9
    8b44:	01001964 	.word	0x01001964
    8b48:	00008421 	.word	0x00008421
    8b4c:	00011a1d 	.word	0x00011a1d
    8b50:	0000845d 	.word	0x0000845d
    8b54:	00022d92 	.word	0x00022d92
    8b58:	00002102 	.word	0x00002102
    8b5c:	00022d47 	.word	0x00022d47
    8b60:	00004001 	.word	0x00004001
    8b64:	00022cb3 	.word	0x00022cb3
    8b68:	00004102 	.word	0x00004102
    8b6c:	00022d5f 	.word	0x00022d5f
    8b70:	00022cda 	.word	0x00022cda
    8b74:	00004101 	.word	0x00004101
    8b78:	00022cf6 	.word	0x00022cf6
    8b7c:	00022b82 	.word	0x00022b82
    8b80:	00008001 	.word	0x00008001
    8b84:	00022b99 	.word	0x00022b99
    8b88:	00008008 	.word	0x00008008
    8b8c:	00022c3c 	.word	0x00022c3c
    8b90:	00008005 	.word	0x00008005
    8b94:	00022bdf 	.word	0x00022bdf
    8b98:	00008003 	.word	0x00008003
    8b9c:	00022bc0 	.word	0x00022bc0
    8ba0:	00008004 	.word	0x00008004
    8ba4:	00022bce 	.word	0x00022bce
    8ba8:	00008006 	.word	0x00008006
    8bac:	00022bee 	.word	0x00022bee
    8bb0:	00008007 	.word	0x00008007
    8bb4:	00022bfd 	.word	0x00022bfd
    8bb8:	00008101 	.word	0x00008101
    8bbc:	00022c84 	.word	0x00022c84
    8bc0:	00008009 	.word	0x00008009
    8bc4:	00022c55 	.word	0x00022c55
    8bc8:	0000800a 	.word	0x0000800a
    8bcc:	00022c71 	.word	0x00022c71
    8bd0:	00008102 	.word	0x00008102
    8bd4:	00022c9d 	.word	0x00022c9d
    8bd8:	00008103 	.word	0x00008103
    8bdc:	00022c1d 	.word	0x00022c1d

00008be0 <app_at_clean_ip_mtu>:
    *mtu = app_at_active_cid_ip_min_mtu;
    return AT_RET_OK;
}

static void app_at_clean_ip_mtu(uint8 cid)                                      //lint !e759
{
    8be0:	b510      	push	{r4, lr}
    UNUSED(cid);
    memset(app_at_ip_mtu_info, 0, sizeof(app_at_ip_mtu_info));
    8be2:	2216      	movs	r2, #22
    8be4:	2100      	movs	r1, #0
    8be6:	4803      	ldr	r0, [pc, #12]	; (8bf4 <app_at_clean_ip_mtu+0x14>)
    8be8:	f7f7 fb7a 	bl	2e0 <memset>
    app_at_active_cid_ip_min_mtu = 0;
    8bec:	2200      	movs	r2, #0
    8bee:	4b02      	ldr	r3, [pc, #8]	; (8bf8 <app_at_clean_ip_mtu+0x18>)
    8bf0:	801a      	strh	r2, [r3, #0]
}
    8bf2:	bd10      	pop	{r4, pc}
    8bf4:	01001988 	.word	0x01001988
    8bf8:	01001986 	.word	0x01001986

00008bfc <at_common_non_ip_data_report_callback>:
{
    8bfc:	b5f0      	push	{r4, r5, r6, r7, lr}
    8bfe:	0007      	movs	r7, r0
    rsp_string = (uint8*)irzalloc(length + APP_AT_CRTDCP_MAX_LEN);
    8c00:	0008      	movs	r0, r1
{
    8c02:	b085      	sub	sp, #20
    rsp_string = (uint8*)irzalloc(length + APP_AT_CRTDCP_MAX_LEN);
    8c04:	3013      	adds	r0, #19
{
    8c06:	000d      	movs	r5, r1
    8c08:	0016      	movs	r6, r2
    8c0a:	9303      	str	r3, [sp, #12]
    rsp_string = (uint8*)irzalloc(length + APP_AT_CRTDCP_MAX_LEN);
    8c0c:	f009 ff02 	bl	12a14 <irzalloc>
    8c10:	1e04      	subs	r4, r0, #0
    if (rsp_string == NULL)
    8c12:	d016      	beq.n	8c42 <at_common_non_ip_data_report_callback+0x46>
    len = (uint16)snprintf((char*)rsp_string, APP_AT_CRTDCP_MAX_LEN, "%s:%d,%d,", prefix, cid, length);
    8c14:	9b03      	ldr	r3, [sp, #12]
    8c16:	9700      	str	r7, [sp, #0]
    8c18:	4a0b      	ldr	r2, [pc, #44]	; (8c48 <at_common_non_ip_data_report_callback+0x4c>)
    8c1a:	2113      	movs	r1, #19
    8c1c:	9501      	str	r5, [sp, #4]
    8c1e:	f011 fe25 	bl	1a86c <snprintf>
    8c22:	0007      	movs	r7, r0
    memcpy(rsp_string + len, message, length);
    8c24:	b280      	uxth	r0, r0
    8c26:	002a      	movs	r2, r5
    8c28:	0031      	movs	r1, r6
    8c2a:	1820      	adds	r0, r4, r0
    8c2c:	f7f7 fae0 	bl	1f0 <memcpy>
    app_at_send_at_string_delayed_async((char*)rsp_string, AT_FLAG_CONVERT_2_HEX, len, length);
    8c30:	0020      	movs	r0, r4
    8c32:	b2ba      	uxth	r2, r7
    8c34:	002b      	movs	r3, r5
    8c36:	2110      	movs	r1, #16
    8c38:	f000 fd3e 	bl	96b8 <app_at_send_at_string_delayed_async>
    at_free(rsp_string);
    8c3c:	0020      	movs	r0, r4
    8c3e:	f009 fefb 	bl	12a38 <irfree>
}
    8c42:	b005      	add	sp, #20
    8c44:	bdf0      	pop	{r4, r5, r6, r7, pc}
    8c46:	46c0      	nop			; (mov r8, r8)
    8c48:	00022e52 	.word	0x00022e52

00008c4c <at_crtdcp_callback>:
{
    8c4c:	b510      	push	{r4, lr}
    at_common_non_ip_data_report_callback(cid, length, message, APP_AT_STR_CRTDCP);
    8c4e:	4b02      	ldr	r3, [pc, #8]	; (8c58 <at_crtdcp_callback+0xc>)
    8c50:	f7ff ffd4 	bl	8bfc <at_common_non_ip_data_report_callback>
}
    8c54:	bd10      	pop	{r4, pc}
    8c56:	46c0      	nop			; (mov r8, r8)
    8c58:	00022e5c 	.word	0x00022e5c

00008c5c <at_nrnpdm_callback>:
{
    8c5c:	b510      	push	{r4, lr}
    at_common_non_ip_data_report_callback(cid, length, message, APP_AT_STR_NRNPDM);
    8c5e:	4b02      	ldr	r3, [pc, #8]	; (8c68 <at_nrnpdm_callback+0xc>)
    8c60:	f7ff ffcc 	bl	8bfc <at_common_non_ip_data_report_callback>
}
    8c64:	bd10      	pop	{r4, pc}
    8c66:	46c0      	nop			; (mov r8, r8)
    8c68:	00022e64 	.word	0x00022e64

00008c6c <sms_send_cmd_result_callback>:
{
    8c6c:	b530      	push	{r4, r5, lr}
    8c6e:	0004      	movs	r4, r0
    8c70:	b089      	sub	sp, #36	; 0x24
    8c72:	000d      	movs	r5, r1
    if(result == SMS_RESPONSE_OK)
    8c74:	2800      	cmp	r0, #0
    8c76:	d10f      	bne.n	8c98 <sms_send_cmd_result_callback+0x2c>
        char   rsp_string[APP_AT_RESPONSE_MAX_LEN]={0};
    8c78:	0001      	movs	r1, r0
    8c7a:	221e      	movs	r2, #30
    8c7c:	4668      	mov	r0, sp
    8c7e:	f7f7 fb2f 	bl	2e0 <memset>
        (void)snprintf(rsp_string, APP_AT_RESPONSE_MAX_LEN, "+CMGC: %d", mr);
    8c82:	4a08      	ldr	r2, [pc, #32]	; (8ca4 <sms_send_cmd_result_callback+0x38>)
    8c84:	211e      	movs	r1, #30
    8c86:	002b      	movs	r3, r5
    8c88:	4668      	mov	r0, sp
    8c8a:	f011 fdef 	bl	1a86c <snprintf>
        app_at_send_at_rsp_string_lines(rsp_string, true, AT_FLAG_UNLOGABLE);
    8c8e:	2204      	movs	r2, #4
    8c90:	2101      	movs	r1, #1
    8c92:	4668      	mov	r0, sp
    8c94:	f000 fc9f 	bl	95d6 <app_at_send_at_rsp_string_lines>
    app_at_send_sms_callback_response((AT_SMS_RET)result);
    8c98:	0020      	movs	r0, r4
    8c9a:	f7ff fe47 	bl	892c <app_at_send_sms_callback_response>
}
    8c9e:	b009      	add	sp, #36	; 0x24
    8ca0:	bd30      	pop	{r4, r5, pc}
    8ca2:	46c0      	nop			; (mov r8, r8)
    8ca4:	00022e88 	.word	0x00022e88

00008ca8 <sms_send_msg_result_callback>:
{
    8ca8:	b530      	push	{r4, r5, lr}
    8caa:	0004      	movs	r4, r0
    8cac:	b089      	sub	sp, #36	; 0x24
    8cae:	000d      	movs	r5, r1
    if(result == SMS_RESPONSE_OK)
    8cb0:	2800      	cmp	r0, #0
    8cb2:	d10f      	bne.n	8cd4 <sms_send_msg_result_callback+0x2c>
        char   rsp_string[APP_AT_RESPONSE_MAX_LEN]={0};
    8cb4:	0001      	movs	r1, r0
    8cb6:	221e      	movs	r2, #30
    8cb8:	4668      	mov	r0, sp
    8cba:	f7f7 fb11 	bl	2e0 <memset>
        (void)snprintf(rsp_string, APP_AT_RESPONSE_MAX_LEN, "+CMGS: %d", mr);
    8cbe:	4a08      	ldr	r2, [pc, #32]	; (8ce0 <sms_send_msg_result_callback+0x38>)
    8cc0:	211e      	movs	r1, #30
    8cc2:	002b      	movs	r3, r5
    8cc4:	4668      	mov	r0, sp
    8cc6:	f011 fdd1 	bl	1a86c <snprintf>
        app_at_send_at_rsp_string_lines(rsp_string, true, AT_FLAG_UNLOGABLE);
    8cca:	2204      	movs	r2, #4
    8ccc:	2101      	movs	r1, #1
    8cce:	4668      	mov	r0, sp
    8cd0:	f000 fc81 	bl	95d6 <app_at_send_at_rsp_string_lines>
    app_at_send_sms_callback_response((AT_SMS_RET)result);
    8cd4:	0020      	movs	r0, r4
    8cd6:	f7ff fe29 	bl	892c <app_at_send_sms_callback_response>
}
    8cda:	b009      	add	sp, #36	; 0x24
    8cdc:	bd30      	pop	{r4, r5, pc}
    8cde:	46c0      	nop			; (mov r8, r8)
    8ce0:	00022e92 	.word	0x00022e92

00008ce4 <set_sms_len>:
    sms_len = len;
    8ce4:	4b01      	ldr	r3, [pc, #4]	; (8cec <set_sms_len+0x8>)
    8ce6:	8018      	strh	r0, [r3, #0]
}
    8ce8:	4770      	bx	lr
    8cea:	46c0      	nop			; (mov r8, r8)
    8cec:	01002e3a 	.word	0x01002e3a

00008cf0 <set_sms_uart_pdu_len>:
    sms_uart_pdu_len = len;
    8cf0:	4b01      	ldr	r3, [pc, #4]	; (8cf8 <set_sms_uart_pdu_len+0x8>)
    8cf2:	8018      	strh	r0, [r3, #0]
}
    8cf4:	4770      	bx	lr
    8cf6:	46c0      	nop			; (mov r8, r8)
    8cf8:	01002e3c 	.word	0x01002e3c

00008cfc <get_sms_uart_pdu_len>:
    return sms_uart_pdu_len;
    8cfc:	4b01      	ldr	r3, [pc, #4]	; (8d04 <get_sms_uart_pdu_len+0x8>)
    8cfe:	8818      	ldrh	r0, [r3, #0]
}
    8d00:	4770      	bx	lr
    8d02:	46c0      	nop			; (mov r8, r8)
    8d04:	01002e3c 	.word	0x01002e3c

00008d08 <plmn_select>:
{
    8d08:	b5f0      	push	{r4, r5, r6, r7, lr}
    8d0a:	b087      	sub	sp, #28
    char plmn_numeric_format[7] = {0};
    8d0c:	ac04      	add	r4, sp, #16
{
    8d0e:	0005      	movs	r5, r0
    8d10:	9101      	str	r1, [sp, #4]
    8d12:	0016      	movs	r6, r2
    char plmn_numeric_format[7] = {0};
    8d14:	2100      	movs	r1, #0
    8d16:	2207      	movs	r2, #7
    8d18:	0020      	movs	r0, r4
{
    8d1a:	001f      	movs	r7, r3
    char plmn_numeric_format[7] = {0};
    8d1c:	f7f7 fae0 	bl	2e0 <memset>
    if (plmn_mode == AT_COPS_MODE_MANUAL || plmn_mode == AT_COPS_MODE_MANUAL_THEN_AUTOMATIC)
    8d20:	2d01      	cmp	r5, #1
    8d22:	d001      	beq.n	8d28 <plmn_select+0x20>
    8d24:	2d04      	cmp	r5, #4
    8d26:	d12e      	bne.n	8d86 <plmn_select+0x7e>
        if (format == 0)
    8d28:	9b01      	ldr	r3, [sp, #4]
            return NEUL_RET_ERROR;
    8d2a:	2001      	movs	r0, #1
        if (format == 0)
    8d2c:	2b02      	cmp	r3, #2
    8d2e:	d12f      	bne.n	8d90 <plmn_select+0x88>
            if ((buffer_length < 5) || (buffer_length > 6))
    8d30:	1f73      	subs	r3, r6, #5
    8d32:	4283      	cmp	r3, r0
    8d34:	d82c      	bhi.n	8d90 <plmn_select+0x88>
    8d36:	2300      	movs	r3, #0
            for(i = 0; i < buffer_length; i++)
    8d38:	b29a      	uxth	r2, r3
    8d3a:	4296      	cmp	r6, r2
    8d3c:	d82a      	bhi.n	8d94 <plmn_select+0x8c>
            memset(plmn_numeric_format, 0, sizeof(plmn_numeric_format));
    8d3e:	2207      	movs	r2, #7
    8d40:	2100      	movs	r1, #0
    8d42:	0020      	movs	r0, r4
    8d44:	f7f7 facc 	bl	2e0 <memset>
            strncpy(plmn_numeric_format,(char *)buffer,sizeof(plmn_numeric_format) - 1);
    8d48:	2206      	movs	r2, #6
    8d4a:	0039      	movs	r1, r7
    8d4c:	0020      	movs	r0, r4
    8d4e:	f012 fb59 	bl	1b404 <strncpy>
    uint32 length = strlen(numeric_format);
    8d52:	0020      	movs	r0, r4
    8d54:	f012 fb23 	bl	1b39e <strlen>
    protocol_format[0] = (numeric_format[0] - '0') | ((numeric_format[1] - '0') << 4);
    8d58:	7863      	ldrb	r3, [r4, #1]
    8d5a:	7821      	ldrb	r1, [r4, #0]
    8d5c:	3b30      	subs	r3, #48	; 0x30
    8d5e:	3930      	subs	r1, #48	; 0x30
    8d60:	011b      	lsls	r3, r3, #4
    8d62:	430b      	orrs	r3, r1
    8d64:	aa03      	add	r2, sp, #12
    8d66:	7013      	strb	r3, [r2, #0]
    protocol_format[2] = (numeric_format[3] - '0') | ((numeric_format[4] - '0') << 4);
    8d68:	7923      	ldrb	r3, [r4, #4]
    8d6a:	78e1      	ldrb	r1, [r4, #3]
    8d6c:	3b30      	subs	r3, #48	; 0x30
    8d6e:	3930      	subs	r1, #48	; 0x30
    8d70:	011b      	lsls	r3, r3, #4
    8d72:	430b      	orrs	r3, r1
    8d74:	7093      	strb	r3, [r2, #2]
    8d76:	78a1      	ldrb	r1, [r4, #2]
    if (length == 5)
    8d78:	2805      	cmp	r0, #5
    8d7a:	d112      	bne.n	8da2 <plmn_select+0x9a>
        protocol_format[1] = (numeric_format[2] - '0') | (0x0f << 4);
    8d7c:	2310      	movs	r3, #16
    8d7e:	3930      	subs	r1, #48	; 0x30
    8d80:	425b      	negs	r3, r3
    8d82:	4319      	orrs	r1, r3
    8d84:	7051      	strb	r1, [r2, #1]
    return set_plmn_state(plmn_mode, plmn_protocol_format, NULL);
    8d86:	2200      	movs	r2, #0
    8d88:	a903      	add	r1, sp, #12
    8d8a:	0028      	movs	r0, r5
    8d8c:	f013 f93a 	bl	1c004 <set_plmn_state>
}
    8d90:	b007      	add	sp, #28
    8d92:	bdf0      	pop	{r4, r5, r6, r7, pc}
                if((buffer[i] < '0') || (buffer[i] > '9'))  // when the format = 2, plmn must be numeric format
    8d94:	5cfa      	ldrb	r2, [r7, r3]
    8d96:	3301      	adds	r3, #1
    8d98:	3a30      	subs	r2, #48	; 0x30
    8d9a:	2a09      	cmp	r2, #9
    8d9c:	d9cc      	bls.n	8d38 <plmn_select+0x30>
            return NEUL_RET_ERROR;
    8d9e:	2001      	movs	r0, #1
    8da0:	e7f6      	b.n	8d90 <plmn_select+0x88>
        protocol_format[1] = (numeric_format[2] - '0') | ((numeric_format[5] - '0') << 4);
    8da2:	7963      	ldrb	r3, [r4, #5]
    8da4:	3930      	subs	r1, #48	; 0x30
    8da6:	3b30      	subs	r3, #48	; 0x30
    8da8:	011b      	lsls	r3, r3, #4
    8daa:	430b      	orrs	r3, r1
    8dac:	7053      	strb	r3, [r2, #1]
    8dae:	e7ea      	b.n	8d86 <plmn_select+0x7e>

00008db0 <get_cgpaddr_cid>:
{
    8db0:	b5f0      	push	{r4, r5, r6, r7, lr}
    8db2:	b087      	sub	sp, #28
    8db4:	9301      	str	r3, [sp, #4]
    8db6:	ab0c      	add	r3, sp, #48	; 0x30
    8db8:	881b      	ldrh	r3, [r3, #0]
    8dba:	9003      	str	r0, [sp, #12]
    8dbc:	0015      	movs	r5, r2
    8dbe:	9300      	str	r3, [sp, #0]
    str_cid_len = (uint8)snprintf(str_cid, sizeof(str_cid), "%i", cid);
    8dc0:	4a35      	ldr	r2, [pc, #212]	; (8e98 <get_cgpaddr_cid+0xe8>)
    8dc2:	0003      	movs	r3, r0
{
    8dc4:	000c      	movs	r4, r1
    str_cid_len = (uint8)snprintf(str_cid, sizeof(str_cid), "%i", cid);
    8dc6:	a804      	add	r0, sp, #16
    8dc8:	2106      	movs	r1, #6
    8dca:	f011 fd4f 	bl	1a86c <snprintf>
    if ((*cgaddr_len + str_cid_len + strlen(prefix) + 4) < max_cgaddr_size )
    8dce:	4e33      	ldr	r6, [pc, #204]	; (8e9c <get_cgpaddr_cid+0xec>)
    8dd0:	b2c3      	uxtb	r3, r0
    8dd2:	9302      	str	r3, [sp, #8]
    8dd4:	682b      	ldr	r3, [r5, #0]
    8dd6:	0030      	movs	r0, r6
    8dd8:	1d1f      	adds	r7, r3, #4
    8dda:	f012 fae0 	bl	1b39e <strlen>
    8dde:	9b02      	ldr	r3, [sp, #8]
    8de0:	19c7      	adds	r7, r0, r7
    8de2:	18ff      	adds	r7, r7, r3
    8de4:	9b00      	ldr	r3, [sp, #0]
    8de6:	429f      	cmp	r7, r3
    8de8:	d219      	bcs.n	8e1e <get_cgpaddr_cid+0x6e>
        strncpy(cgaddr + *cgaddr_len, prefix, (max_cgaddr_size - *cgaddr_len) - 1);       //<"+CGPADDR:"
    8dea:	6828      	ldr	r0, [r5, #0]
    8dec:	1e5f      	subs	r7, r3, #1
    8dee:	9b01      	ldr	r3, [sp, #4]
    8df0:	1a3a      	subs	r2, r7, r0
    8df2:	0031      	movs	r1, r6
    8df4:	1818      	adds	r0, r3, r0
    8df6:	f012 fb05 	bl	1b404 <strncpy>
        *cgaddr_len += (uint16)strlen(prefix);
    8dfa:	0030      	movs	r0, r6
    8dfc:	f012 facf 	bl	1b39e <strlen>
    8e00:	682b      	ldr	r3, [r5, #0]
    8e02:	b280      	uxth	r0, r0
    8e04:	18c0      	adds	r0, r0, r3
        strncpy(cgaddr + *cgaddr_len, str_cid, (max_cgaddr_size - *cgaddr_len) - 1);      //<cid>
    8e06:	9b01      	ldr	r3, [sp, #4]
    8e08:	1a3a      	subs	r2, r7, r0
        *cgaddr_len += (uint16)strlen(prefix);
    8e0a:	6028      	str	r0, [r5, #0]
        strncpy(cgaddr + *cgaddr_len, str_cid, (max_cgaddr_size - *cgaddr_len) - 1);      //<cid>
    8e0c:	a904      	add	r1, sp, #16
    8e0e:	1818      	adds	r0, r3, r0
    8e10:	f012 faf8 	bl	1b404 <strncpy>
        *cgaddr_len += str_cid_len;
    8e14:	682a      	ldr	r2, [r5, #0]
    8e16:	9b02      	ldr	r3, [sp, #8]
    8e18:	4694      	mov	ip, r2
    8e1a:	4463      	add	r3, ip
    8e1c:	602b      	str	r3, [r5, #0]
    while (current)
    8e1e:	2c00      	cmp	r4, #0
    8e20:	d102      	bne.n	8e28 <get_cgpaddr_cid+0x78>
}
    8e22:	2000      	movs	r0, #0
    8e24:	b007      	add	sp, #28
    8e26:	bdf0      	pop	{r4, r5, r6, r7, pc}
        if ((cid == current->cid) && (!ip_addr_isany(&current->ifa_addr)))
    8e28:	2208      	movs	r2, #8
    8e2a:	5ea3      	ldrsh	r3, [r4, r2]
    8e2c:	9a03      	ldr	r2, [sp, #12]
    8e2e:	4293      	cmp	r3, r2
    8e30:	d128      	bne.n	8e84 <get_cgpaddr_cid+0xd4>
    8e32:	1c62      	adds	r2, r4, #1
    8e34:	7fd2      	ldrb	r2, [r2, #31]
    8e36:	6923      	ldr	r3, [r4, #16]
    8e38:	2a06      	cmp	r2, #6
    8e3a:	d125      	bne.n	8e88 <get_cgpaddr_cid+0xd8>
    8e3c:	2b00      	cmp	r3, #0
    8e3e:	d108      	bne.n	8e52 <get_cgpaddr_cid+0xa2>
    8e40:	6963      	ldr	r3, [r4, #20]
    8e42:	2b00      	cmp	r3, #0
    8e44:	d105      	bne.n	8e52 <get_cgpaddr_cid+0xa2>
    8e46:	69a3      	ldr	r3, [r4, #24]
    8e48:	2b00      	cmp	r3, #0
    8e4a:	d102      	bne.n	8e52 <get_cgpaddr_cid+0xa2>
    8e4c:	69e3      	ldr	r3, [r4, #28]
    8e4e:	2b00      	cmp	r3, #0
    8e50:	d018      	beq.n	8e84 <get_cgpaddr_cid+0xd4>
            char *addr_string = ipaddr_ntoa(&(current->ifa_addr));
    8e52:	0020      	movs	r0, r4
    8e54:	3010      	adds	r0, #16
    8e56:	f014 fb57 	bl	1d508 <ip6addr_ntoa>
    8e5a:	1e07      	subs	r7, r0, #0
            if (addr_string == NULL)    // should never happen
    8e5c:	d0e1      	beq.n	8e22 <get_cgpaddr_cid+0x72>
            if ((*cgaddr_len + strlen(addr_string) + 4) < max_cgaddr_size )
    8e5e:	682e      	ldr	r6, [r5, #0]
    8e60:	f012 fa9d 	bl	1b39e <strlen>
    8e64:	3604      	adds	r6, #4
    8e66:	9b00      	ldr	r3, [sp, #0]
    8e68:	1830      	adds	r0, r6, r0
    8e6a:	4283      	cmp	r3, r0
    8e6c:	d90a      	bls.n	8e84 <get_cgpaddr_cid+0xd4>
                *cgaddr_len += (uint32)snprintf((cgaddr + *cgaddr_len), (max_cgaddr_size - *cgaddr_len), ",%s", addr_string);
    8e6e:	6828      	ldr	r0, [r5, #0]
    8e70:	4a0b      	ldr	r2, [pc, #44]	; (8ea0 <get_cgpaddr_cid+0xf0>)
    8e72:	1a19      	subs	r1, r3, r0
    8e74:	9b01      	ldr	r3, [sp, #4]
    8e76:	1818      	adds	r0, r3, r0
    8e78:	003b      	movs	r3, r7
    8e7a:	f011 fcf7 	bl	1a86c <snprintf>
    8e7e:	682b      	ldr	r3, [r5, #0]
    8e80:	1818      	adds	r0, r3, r0
    8e82:	6028      	str	r0, [r5, #0]
        current = current->ifa_next;
    8e84:	6824      	ldr	r4, [r4, #0]
    8e86:	e7ca      	b.n	8e1e <get_cgpaddr_cid+0x6e>
        if ((cid == current->cid) && (!ip_addr_isany(&current->ifa_addr)))
    8e88:	2b00      	cmp	r3, #0
    8e8a:	d0fb      	beq.n	8e84 <get_cgpaddr_cid+0xd4>
            char *addr_string = ipaddr_ntoa(&(current->ifa_addr));
    8e8c:	0020      	movs	r0, r4
    8e8e:	3010      	adds	r0, #16
    8e90:	f014 fa00 	bl	1d294 <ip4addr_ntoa>
    8e94:	e7e1      	b.n	8e5a <get_cgpaddr_cid+0xaa>
    8e96:	46c0      	nop			; (mov r8, r8)
    8e98:	00022e6c 	.word	0x00022e6c
    8e9c:	00022e6f 	.word	0x00022e6f
    8ea0:	000237b2 	.word	0x000237b2

00008ea4 <get_cgpaddr_cid_range>:
{
    8ea4:	b5f0      	push	{r4, r5, r6, r7, lr}
    8ea6:	b08b      	sub	sp, #44	; 0x2c
    8ea8:	0004      	movs	r4, r0
    8eaa:	9203      	str	r2, [sp, #12]
    8eac:	000e      	movs	r6, r1
    uint8 cids[AT_MAX_CID + 1] = {0};
    8eae:	220b      	movs	r2, #11
    8eb0:	2100      	movs	r1, #0
    8eb2:	a807      	add	r0, sp, #28
    8eb4:	f7f7 fa14 	bl	2e0 <memset>
    NEUL_RET neul_return_code = get_defined_cids(AT_MAX_CID + 1, &returned_cids, cids);
    8eb8:	ab04      	add	r3, sp, #16
    8eba:	1c99      	adds	r1, r3, #2
    8ebc:	aa07      	add	r2, sp, #28
    8ebe:	200b      	movs	r0, #11
    8ec0:	f013 f9dd 	bl	1c27e <get_defined_cids>
    *cgaddr_len = 0;
    8ec4:	2300      	movs	r3, #0
    NEUL_RET neul_return_code = get_defined_cids(AT_MAX_CID + 1, &returned_cids, cids);
    8ec6:	0005      	movs	r5, r0
    *cgaddr_len = 0;
    8ec8:	6023      	str	r3, [r4, #0]
    if (neul_return_code != NEUL_RET_OK)
    8eca:	4298      	cmp	r0, r3
    8ecc:	d129      	bne.n	8f22 <get_cgpaddr_cid_range+0x7e>
    strncpy(cgaddr + *cgaddr_len, prefix, (max_cgaddr_size - *cgaddr_len) - 1);       //"+CGPADDR:("
    8ece:	9b03      	ldr	r3, [sp, #12]
    8ed0:	4f25      	ldr	r7, [pc, #148]	; (8f68 <get_cgpaddr_cid_range+0xc4>)
    8ed2:	3b01      	subs	r3, #1
    8ed4:	001a      	movs	r2, r3
    8ed6:	0039      	movs	r1, r7
    8ed8:	0030      	movs	r0, r6
    8eda:	9301      	str	r3, [sp, #4]
    8edc:	f012 fa92 	bl	1b404 <strncpy>
    *cgaddr_len += strlen(prefix);
    8ee0:	0038      	movs	r0, r7
    8ee2:	f012 fa5c 	bl	1b39e <strlen>
    uint8 count = 0;
    8ee6:	002f      	movs	r7, r5
    *cgaddr_len += strlen(prefix);
    8ee8:	6823      	ldr	r3, [r4, #0]
    8eea:	1818      	adds	r0, r3, r0
    8eec:	6020      	str	r0, [r4, #0]
    for( cid = 0 ; cid < returned_cids; cid++)
    8eee:	ab04      	add	r3, sp, #16
    8ef0:	3302      	adds	r3, #2
    8ef2:	881b      	ldrh	r3, [r3, #0]
    8ef4:	42ab      	cmp	r3, r5
    8ef6:	d816      	bhi.n	8f26 <get_cgpaddr_cid_range+0x82>
    if(count > 0)
    8ef8:	2f00      	cmp	r7, #0
    8efa:	d002      	beq.n	8f02 <get_cgpaddr_cid_range+0x5e>
        *cgaddr_len = *cgaddr_len - 1;  // delete the ',' at the end
    8efc:	6823      	ldr	r3, [r4, #0]
    8efe:	3b01      	subs	r3, #1
    8f00:	6023      	str	r3, [r4, #0]
    strncpy(cgaddr + *cgaddr_len, ")", (max_cgaddr_size - *cgaddr_len) - 1);
    8f02:	9b01      	ldr	r3, [sp, #4]
    8f04:	6820      	ldr	r0, [r4, #0]
    8f06:	4d19      	ldr	r5, [pc, #100]	; (8f6c <get_cgpaddr_cid_range+0xc8>)
    8f08:	1a1a      	subs	r2, r3, r0
    8f0a:	0029      	movs	r1, r5
    8f0c:	1830      	adds	r0, r6, r0
    8f0e:	f012 fa79 	bl	1b404 <strncpy>
    *cgaddr_len += strlen(")");
    8f12:	0028      	movs	r0, r5
    8f14:	f012 fa43 	bl	1b39e <strlen>
    8f18:	6823      	ldr	r3, [r4, #0]
    8f1a:	18c0      	adds	r0, r0, r3
    cgaddr[*cgaddr_len] = '\0';
    8f1c:	2300      	movs	r3, #0
    *cgaddr_len += strlen(")");
    8f1e:	6020      	str	r0, [r4, #0]
    cgaddr[*cgaddr_len] = '\0';
    8f20:	5433      	strb	r3, [r6, r0]
}
    8f22:	b00b      	add	sp, #44	; 0x2c
    8f24:	bdf0      	pop	{r4, r5, r6, r7, pc}
        str_cid_len = (uint8)snprintf(str_cid, sizeof(str_cid), "%i,", cids[cid]);
    8f26:	ab07      	add	r3, sp, #28
    8f28:	5d5b      	ldrb	r3, [r3, r5]
    8f2a:	4a11      	ldr	r2, [pc, #68]	; (8f70 <get_cgpaddr_cid_range+0xcc>)
    8f2c:	2106      	movs	r1, #6
    8f2e:	a805      	add	r0, sp, #20
    8f30:	f011 fc9c 	bl	1a86c <snprintf>
        if ((*cgaddr_len + str_cid_len + 4) < max_cgaddr_size )      // 4 is for trailing )\r\n\0
    8f34:	22ff      	movs	r2, #255	; 0xff
    8f36:	4002      	ands	r2, r0
    8f38:	9202      	str	r2, [sp, #8]
    8f3a:	6823      	ldr	r3, [r4, #0]
    8f3c:	9902      	ldr	r1, [sp, #8]
    8f3e:	1d1a      	adds	r2, r3, #4
    8f40:	1852      	adds	r2, r2, r1
    8f42:	9903      	ldr	r1, [sp, #12]
    8f44:	4291      	cmp	r1, r2
    8f46:	d90c      	bls.n	8f62 <get_cgpaddr_cid_range+0xbe>
            strncpy(cgaddr + *cgaddr_len, str_cid, (max_cgaddr_size - *cgaddr_len) - 1);      //<cid>,
    8f48:	9a01      	ldr	r2, [sp, #4]
    8f4a:	18f0      	adds	r0, r6, r3
    8f4c:	1ad2      	subs	r2, r2, r3
    8f4e:	a905      	add	r1, sp, #20
    8f50:	f012 fa58 	bl	1b404 <strncpy>
            *cgaddr_len += str_cid_len;
    8f54:	6822      	ldr	r2, [r4, #0]
    8f56:	9b02      	ldr	r3, [sp, #8]
    8f58:	4694      	mov	ip, r2
            count++;
    8f5a:	3701      	adds	r7, #1
            *cgaddr_len += str_cid_len;
    8f5c:	4463      	add	r3, ip
    8f5e:	6023      	str	r3, [r4, #0]
            count++;
    8f60:	b2ff      	uxtb	r7, r7
    for( cid = 0 ; cid < returned_cids; cid++)
    8f62:	3501      	adds	r5, #1
    8f64:	b2ed      	uxtb	r5, r5
    8f66:	e7c2      	b.n	8eee <get_cgpaddr_cid_range+0x4a>
    8f68:	00022e79 	.word	0x00022e79
    8f6c:	00023d40 	.word	0x00023d40
    8f70:	00022e84 	.word	0x00022e84

00008f74 <at_pre_process_sms_data>:
{
    8f74:	b570      	push	{r4, r5, r6, lr}
    return sms_uart_pdu_len;
    8f76:	4d12      	ldr	r5, [pc, #72]	; (8fc0 <at_pre_process_sms_data+0x4c>)
{
    8f78:	0004      	movs	r4, r0
    return sms_uart_pdu_len;
    8f7a:	882a      	ldrh	r2, [r5, #0]
    if((get_sms_uart_pdu_len() >= 2) && (p_str[get_sms_uart_pdu_len()-2] == '1') &&
    8f7c:	2a01      	cmp	r2, #1
    8f7e:	d801      	bhi.n	8f84 <at_pre_process_sms_data+0x10>
        result = AT_RET_SYNTAX_ERROR;
    8f80:	2001      	movs	r0, #1
}
    8f82:	bd70      	pop	{r4, r5, r6, pc}
    if((get_sms_uart_pdu_len() >= 2) && (p_str[get_sms_uart_pdu_len()-2] == '1') &&
    8f84:	1883      	adds	r3, r0, r2
    8f86:	1e99      	subs	r1, r3, #2
    8f88:	7809      	ldrb	r1, [r1, #0]
    8f8a:	2931      	cmp	r1, #49	; 0x31
    8f8c:	d1f8      	bne.n	8f80 <at_pre_process_sms_data+0xc>
        (p_str[get_sms_uart_pdu_len()-1]== 'A' || p_str[get_sms_uart_pdu_len()-1] == 'B'))//the last two oct of p_str is the ending of PDU ,which must be ctrl-Z(0x1A) or ESC(0x1B)
    8f8e:	3b01      	subs	r3, #1
    if((get_sms_uart_pdu_len() >= 2) && (p_str[get_sms_uart_pdu_len()-2] == '1') &&
    8f90:	781b      	ldrb	r3, [r3, #0]
    8f92:	3b41      	subs	r3, #65	; 0x41
    8f94:	2b01      	cmp	r3, #1
    8f96:	d8f3      	bhi.n	8f80 <at_pre_process_sms_data+0xc>
        if(!at_parse_buf_hex_to_uint8(p_str,p_str,get_sms_uart_pdu_len()))//convert every two hex into one hex
    8f98:	0001      	movs	r1, r0
    8f9a:	f001 f8f2 	bl	a182 <at_parse_buf_hex_to_uint8>
    8f9e:	2800      	cmp	r0, #0
    8fa0:	d0ee      	beq.n	8f80 <at_pre_process_sms_data+0xc>
    return sms_uart_pdu_len;
    8fa2:	882b      	ldrh	r3, [r5, #0]
            if(p_str[get_sms_uart_pdu_len()-1] == 'B')//the ending of PDU is ESC(0x1B)
    8fa4:	18e4      	adds	r4, r4, r3
    8fa6:	3c01      	subs	r4, #1
    8fa8:	7822      	ldrb	r2, [r4, #0]
    8faa:	2a42      	cmp	r2, #66	; 0x42
    8fac:	d102      	bne.n	8fb4 <at_pre_process_sms_data+0x40>
    is_ESC = true;
    8fae:	2101      	movs	r1, #1
    8fb0:	4a04      	ldr	r2, [pc, #16]	; (8fc4 <at_pre_process_sms_data+0x50>)
    8fb2:	7011      	strb	r1, [r2, #0]
            set_sms_uart_pdu_len((get_sms_uart_pdu_len()>>1)-1);//Subtract one byte occupied by 0x1A or 0x1B
    8fb4:	085b      	lsrs	r3, r3, #1
    8fb6:	3b01      	subs	r3, #1
    sms_uart_pdu_len = len;
    8fb8:	802b      	strh	r3, [r5, #0]
    AT_RET result = AT_RET_OK;
    8fba:	2000      	movs	r0, #0
    8fbc:	e7e1      	b.n	8f82 <at_pre_process_sms_data+0xe>
    8fbe:	46c0      	nop			; (mov r8, r8)
    8fc0:	01002e3c 	.word	0x01002e3c
    8fc4:	010019a1 	.word	0x010019a1

00008fc8 <at_set_crtdcp_mode>:
    crtdcp_mode = mode;
    8fc8:	4b05      	ldr	r3, [pc, #20]	; (8fe0 <at_set_crtdcp_mode+0x18>)
{
    8fca:	b510      	push	{r4, lr}
    crtdcp_mode = mode;
    8fcc:	7018      	strb	r0, [r3, #0]
    if(crtdcp_mode == AT_NON_IP_DATA_REPORT_MODE_DISABLE)
    8fce:	2800      	cmp	r0, #0
    8fd0:	d102      	bne.n	8fd8 <at_set_crtdcp_mode+0x10>
        nonip_set_cp_only_message_received_callback(at_crtdcp_callback);
    8fd2:	f012 fe0d 	bl	1bbf0 <nonip_set_cp_only_message_received_callback>
}
    8fd6:	bd10      	pop	{r4, pc}
    else if (crtdcp_mode == AT_NON_IP_DATA_REPORT_MODE_ENABLE)
    8fd8:	2801      	cmp	r0, #1
    8fda:	d1fc      	bne.n	8fd6 <at_set_crtdcp_mode+0xe>
        nonip_set_cp_only_message_received_callback(at_crtdcp_callback);
    8fdc:	4801      	ldr	r0, [pc, #4]	; (8fe4 <at_set_crtdcp_mode+0x1c>)
    8fde:	e7f8      	b.n	8fd2 <at_set_crtdcp_mode+0xa>
    8fe0:	010019a0 	.word	0x010019a0
    8fe4:	00008c4d 	.word	0x00008c4d

00008fe8 <at_query_crtdcp_mode>:
    *mode = crtdcp_mode;
    8fe8:	4b01      	ldr	r3, [pc, #4]	; (8ff0 <at_query_crtdcp_mode+0x8>)
    8fea:	781b      	ldrb	r3, [r3, #0]
    8fec:	7003      	strb	r3, [r0, #0]
}
    8fee:	4770      	bx	lr
    8ff0:	010019a0 	.word	0x010019a0

00008ff4 <at_set_non_ip_data_report_mode>:
    non_ip_data_report_mode = mode;
    8ff4:	4b05      	ldr	r3, [pc, #20]	; (900c <at_set_non_ip_data_report_mode+0x18>)
{
    8ff6:	b510      	push	{r4, lr}
    non_ip_data_report_mode = mode;
    8ff8:	7018      	strb	r0, [r3, #0]
    if (non_ip_data_report_mode == AT_NON_IP_DATA_REPORT_MODE_DISABLE)
    8ffa:	2800      	cmp	r0, #0
    8ffc:	d102      	bne.n	9004 <at_set_non_ip_data_report_mode+0x10>
        nonip_set_message_received_callback(at_nrnpdm_callback);
    8ffe:	f012 fdfd 	bl	1bbfc <nonip_set_message_received_callback>
}
    9002:	bd10      	pop	{r4, pc}
    else if (non_ip_data_report_mode == AT_NON_IP_DATA_REPORT_MODE_ENABLE)
    9004:	2801      	cmp	r0, #1
    9006:	d1fc      	bne.n	9002 <at_set_non_ip_data_report_mode+0xe>
        nonip_set_message_received_callback(at_nrnpdm_callback);
    9008:	4801      	ldr	r0, [pc, #4]	; (9010 <at_set_non_ip_data_report_mode+0x1c>)
    900a:	e7f8      	b.n	8ffe <at_set_non_ip_data_report_mode+0xa>
    900c:	010019a3 	.word	0x010019a3
    9010:	00008c5d 	.word	0x00008c5d

00009014 <at_get_non_ip_data_report_mode>:
    return non_ip_data_report_mode;
    9014:	4b01      	ldr	r3, [pc, #4]	; (901c <at_get_non_ip_data_report_mode+0x8>)
    9016:	7818      	ldrb	r0, [r3, #0]
}
    9018:	4770      	bx	lr
    901a:	46c0      	nop			; (mov r8, r8)
    901c:	010019a3 	.word	0x010019a3

00009020 <at_process_sms_data>:
{
    9020:	b530      	push	{r4, r5, lr}
    9022:	b0bb      	sub	sp, #236	; 0xec
    uint8   pdu[NEUL_SMS_MAX_TPDU_LEN]={0};
    9024:	22e8      	movs	r2, #232	; 0xe8
    9026:	2100      	movs	r1, #0
{
    9028:	0004      	movs	r4, r0
    uint8   pdu[NEUL_SMS_MAX_TPDU_LEN]={0};
    902a:	4668      	mov	r0, sp
    902c:	f7f7 f958 	bl	2e0 <memset>
    switch (get_at_sms_msg_type())
    9030:	4a41      	ldr	r2, [pc, #260]	; (9138 <at_process_sms_data+0x118>)
    9032:	4942      	ldr	r1, [pc, #264]	; (913c <at_process_sms_data+0x11c>)
    9034:	7812      	ldrb	r2, [r2, #0]
    9036:	880b      	ldrh	r3, [r1, #0]
    9038:	2a02      	cmp	r2, #2
    903a:	d029      	beq.n	9090 <at_process_sms_data+0x70>
    903c:	2a03      	cmp	r2, #3
    903e:	d04e      	beq.n	90de <at_process_sms_data+0xbe>
    9040:	2a01      	cmp	r2, #1
    9042:	d000      	beq.n	9046 <at_process_sms_data+0x26>
    9044:	e072      	b.n	912c <at_process_sms_data+0x10c>
    return sms_uart_pdu_len;
    9046:	4a3e      	ldr	r2, [pc, #248]	; (9140 <at_process_sms_data+0x120>)
    if(max_len != get_sms_uart_pdu_len())
    9048:	b2d8      	uxtb	r0, r3
    904a:	8812      	ldrh	r2, [r2, #0]
            sms_pdu_result = process_cnma_pdu_data(p_str, pdu,(uint8)get_sms_len());
    904c:	b2d9      	uxtb	r1, r3
        return false;
    904e:	2300      	movs	r3, #0
    if(max_len != get_sms_uart_pdu_len())
    9050:	4282      	cmp	r2, r0
    9052:	d103      	bne.n	905c <at_process_sms_data+0x3c>
    for(i=0;i<max_len;i++)
    9054:	b2da      	uxtb	r2, r3
    9056:	4291      	cmp	r1, r2
    9058:	d809      	bhi.n	906e <at_process_sms_data+0x4e>
    return true;
    905a:	2301      	movs	r3, #1
    return is_ESC;
    905c:	4a39      	ldr	r2, [pc, #228]	; (9144 <at_process_sms_data+0x124>)
            if(get_is_ESC())
    905e:	7812      	ldrb	r2, [r2, #0]
    9060:	2a00      	cmp	r2, #0
    9062:	d009      	beq.n	9078 <at_process_sms_data+0x58>
    is_ESC = false;
    9064:	2000      	movs	r0, #0
    9066:	4b37      	ldr	r3, [pc, #220]	; (9144 <at_process_sms_data+0x124>)
    9068:	7018      	strb	r0, [r3, #0]
}
    906a:	b03b      	add	sp, #236	; 0xec
    906c:	bd30      	pop	{r4, r5, pc}
        sms_pdu[i] = p_str[i];
    906e:	4668      	mov	r0, sp
    9070:	5ce2      	ldrb	r2, [r4, r3]
    9072:	54c2      	strb	r2, [r0, r3]
    9074:	3301      	adds	r3, #1
    9076:	e7ed      	b.n	9054 <at_process_sms_data+0x34>
                if (sms_pdu_result)
    9078:	2b00      	cmp	r3, #0
    907a:	d101      	bne.n	9080 <at_process_sms_data+0x60>
                    cause = AT_RET_SYNTAX_ERROR;
    907c:	2001      	movs	r0, #1
    907e:	e7f4      	b.n	906a <at_process_sms_data+0x4a>
    return report_type;
    9080:	4b31      	ldr	r3, [pc, #196]	; (9148 <at_process_sms_data+0x128>)
                    result = set_new_msg_ack((NEUL_SMS_RECEIVE_PDU_RES_TYPE)get_report_type(),(uint8)get_sms_len(), pdu);
    9082:	466a      	mov	r2, sp
    9084:	7818      	ldrb	r0, [r3, #0]
    9086:	f013 fdcf 	bl	1cc28 <set_new_msg_ack>
                    cause = at_parse_convert_neul_result(result);
    908a:	f001 f901 	bl	a290 <at_parse_convert_neul_result>
    908e:	e7ec      	b.n	906a <at_process_sms_data+0x4a>
    smsc_len = p_str[0] + 1;//fisrt oct of input string is length of smsc address,range 0-11. Add the oct of length itself
    9090:	7822      	ldrb	r2, [r4, #0]
    9092:	3201      	adds	r2, #1
    9094:	b2d2      	uxtb	r2, r2
    if(smsc_len > APP_SMSC_MAX_LEN)
    9096:	2a0c      	cmp	r2, #12
    9098:	d81e      	bhi.n	90d8 <at_process_sms_data+0xb8>
    max_len = smsc_len + sms_pdu_len;
    909a:	b2d8      	uxtb	r0, r3
    909c:	1880      	adds	r0, r0, r2
    return sms_uart_pdu_len;
    909e:	4a28      	ldr	r2, [pc, #160]	; (9140 <at_process_sms_data+0x120>)
    if(max_len != get_sms_uart_pdu_len())
    90a0:	8812      	ldrh	r2, [r2, #0]
    90a2:	4282      	cmp	r2, r0
    90a4:	d118      	bne.n	90d8 <at_process_sms_data+0xb8>
    for(i=0;i<max_len;i++)
    90a6:	2200      	movs	r2, #0
    90a8:	b291      	uxth	r1, r2
    90aa:	4288      	cmp	r0, r1
    90ac:	d80e      	bhi.n	90cc <at_process_sms_data+0xac>
    return true;
    90ae:	2201      	movs	r2, #1
            if(pdu_length > NEUL_SMS_MAX_TPDU_LEN)
    90b0:	29e8      	cmp	r1, #232	; 0xe8
    90b2:	d8e3      	bhi.n	907c <at_process_sms_data+0x5c>
    return is_ESC;
    90b4:	4823      	ldr	r0, [pc, #140]	; (9144 <at_process_sms_data+0x124>)
            if(get_is_ESC())
    90b6:	7800      	ldrb	r0, [r0, #0]
    90b8:	2800      	cmp	r0, #0
    90ba:	d1d3      	bne.n	9064 <at_process_sms_data+0x44>
                if (sms_pdu_result)
    90bc:	2a00      	cmp	r2, #0
    90be:	d0dd      	beq.n	907c <at_process_sms_data+0x5c>
                    result = send_short_message((uint8)get_sms_len(), pdu_length, pdu, sms_send_msg_result_callback);
    90c0:	b2d8      	uxtb	r0, r3
    90c2:	466a      	mov	r2, sp
    90c4:	4b21      	ldr	r3, [pc, #132]	; (914c <at_process_sms_data+0x12c>)
    90c6:	f013 fd83 	bl	1cbd0 <send_short_message>
    90ca:	e7de      	b.n	908a <at_process_sms_data+0x6a>
        sms_pdu[i] = p_str[i];
    90cc:	466d      	mov	r5, sp
    90ce:	5ca1      	ldrb	r1, [r4, r2]
    90d0:	54a9      	strb	r1, [r5, r2]
    for(i=0;i<max_len;i++)
    90d2:	3201      	adds	r2, #1
    90d4:	b2d2      	uxtb	r2, r2
    90d6:	e7e7      	b.n	90a8 <at_process_sms_data+0x88>
    uint16    pdu_length = 0;
    90d8:	2100      	movs	r1, #0
        return false;
    90da:	000a      	movs	r2, r1
    90dc:	e7ea      	b.n	90b4 <at_process_sms_data+0x94>
    smsc_len = p_str[0] + 1;//fisrt oct of input string is length of smsc address,range 0-11. Add the oct of length itself
    90de:	7822      	ldrb	r2, [r4, #0]
    90e0:	3201      	adds	r2, #1
    90e2:	b2d2      	uxtb	r2, r2
    if(smsc_len > APP_SMSC_MAX_LEN)
    90e4:	2a0c      	cmp	r2, #12
    90e6:	d81e      	bhi.n	9126 <at_process_sms_data+0x106>
    max_len = smsc_len + sms_pdu_len;
    90e8:	b2d8      	uxtb	r0, r3
    90ea:	1880      	adds	r0, r0, r2
    return sms_uart_pdu_len;
    90ec:	4a14      	ldr	r2, [pc, #80]	; (9140 <at_process_sms_data+0x120>)
    if(max_len != get_sms_uart_pdu_len())
    90ee:	8812      	ldrh	r2, [r2, #0]
    90f0:	4282      	cmp	r2, r0
    90f2:	d118      	bne.n	9126 <at_process_sms_data+0x106>
    for(i=0;i<max_len;i++)
    90f4:	2200      	movs	r2, #0
    90f6:	b291      	uxth	r1, r2
    90f8:	4288      	cmp	r0, r1
    90fa:	d80e      	bhi.n	911a <at_process_sms_data+0xfa>
    return true;
    90fc:	2201      	movs	r2, #1
            if(pdu_length > NEUL_SMS_MAX_TPDU_LEN)
    90fe:	29e8      	cmp	r1, #232	; 0xe8
    9100:	d8bc      	bhi.n	907c <at_process_sms_data+0x5c>
    return is_ESC;
    9102:	4810      	ldr	r0, [pc, #64]	; (9144 <at_process_sms_data+0x124>)
            if(get_is_ESC())
    9104:	7800      	ldrb	r0, [r0, #0]
    9106:	2800      	cmp	r0, #0
    9108:	d1ac      	bne.n	9064 <at_process_sms_data+0x44>
                if (sms_pdu_result)
    910a:	2a00      	cmp	r2, #0
    910c:	d0b6      	beq.n	907c <at_process_sms_data+0x5c>
                    result = send_command((uint8)get_sms_len(), pdu_length, pdu, sms_send_cmd_result_callback);
    910e:	b2d8      	uxtb	r0, r3
    9110:	466a      	mov	r2, sp
    9112:	4b0f      	ldr	r3, [pc, #60]	; (9150 <at_process_sms_data+0x130>)
    9114:	f013 fd72 	bl	1cbfc <send_command>
    9118:	e7b7      	b.n	908a <at_process_sms_data+0x6a>
        sms_pdu[i] = p_str[i];
    911a:	466d      	mov	r5, sp
    911c:	5ca1      	ldrb	r1, [r4, r2]
    911e:	54a9      	strb	r1, [r5, r2]
    for(i=0;i<max_len;i++)
    9120:	3201      	adds	r2, #1
    9122:	b2d2      	uxtb	r2, r2
    9124:	e7e7      	b.n	90f6 <at_process_sms_data+0xd6>
    uint16    pdu_length = 0;
    9126:	2100      	movs	r1, #0
        return false;
    9128:	000a      	movs	r2, r1
    912a:	e7ea      	b.n	9102 <at_process_sms_data+0xe2>
    912c:	2000      	movs	r0, #0
            if( get_sms_len() != 0 )
    912e:	4283      	cmp	r3, r0
    9130:	d09b      	beq.n	906a <at_process_sms_data+0x4a>
    sms_len = len;
    9132:	8008      	strh	r0, [r1, #0]
                cause = AT_RET_SYNTAX_ERROR;
    9134:	3001      	adds	r0, #1
    9136:	e798      	b.n	906a <at_process_sms_data+0x4a>
    9138:	01002e3f 	.word	0x01002e3f
    913c:	01002e3a 	.word	0x01002e3a
    9140:	01002e3c 	.word	0x01002e3c
    9144:	010019a1 	.word	0x010019a1
    9148:	01002e3e 	.word	0x01002e3e
    914c:	00008ca9 	.word	0x00008ca9
    9150:	00008c6d 	.word	0x00008c6d

00009154 <set_at_sms_msg_type>:
    at_sms_msg_type = type;
    9154:	4b01      	ldr	r3, [pc, #4]	; (915c <set_at_sms_msg_type+0x8>)
    9156:	7018      	strb	r0, [r3, #0]
}
    9158:	4770      	bx	lr
    915a:	46c0      	nop			; (mov r8, r8)
    915c:	01002e3f 	.word	0x01002e3f

00009160 <set_wait_for_sms_data>:
    wait_for_sms_data = true;
    9160:	2201      	movs	r2, #1
    9162:	4b01      	ldr	r3, [pc, #4]	; (9168 <set_wait_for_sms_data+0x8>)
    9164:	701a      	strb	r2, [r3, #0]
}
    9166:	4770      	bx	lr
    9168:	010019a4 	.word	0x010019a4

0000916c <clear_wait_for_sms_data>:
    wait_for_sms_data = false;
    916c:	2200      	movs	r2, #0
    916e:	4b01      	ldr	r3, [pc, #4]	; (9174 <clear_wait_for_sms_data+0x8>)
    9170:	701a      	strb	r2, [r3, #0]
}
    9172:	4770      	bx	lr
    9174:	010019a4 	.word	0x010019a4

00009178 <get_wait_for_sms_data>:
    return wait_for_sms_data;
    9178:	4b01      	ldr	r3, [pc, #4]	; (9180 <get_wait_for_sms_data+0x8>)
    917a:	7818      	ldrb	r0, [r3, #0]
}
    917c:	4770      	bx	lr
    917e:	46c0      	nop			; (mov r8, r8)
    9180:	010019a4 	.word	0x010019a4

00009184 <set_report_type>:
    report_type = type;
    9184:	4b01      	ldr	r3, [pc, #4]	; (918c <set_report_type+0x8>)
    9186:	7018      	strb	r0, [r3, #0]
}
    9188:	4770      	bx	lr
    918a:	46c0      	nop			; (mov r8, r8)
    918c:	01002e3e 	.word	0x01002e3e

00009190 <set_is_pdu>:
    is_pdu = true;
    9190:	2201      	movs	r2, #1
    9192:	4b01      	ldr	r3, [pc, #4]	; (9198 <set_is_pdu+0x8>)
    9194:	701a      	strb	r2, [r3, #0]
}
    9196:	4770      	bx	lr
    9198:	010019a2 	.word	0x010019a2

0000919c <clear_is_pdu>:
    is_pdu = false;
    919c:	2200      	movs	r2, #0
    919e:	4b01      	ldr	r3, [pc, #4]	; (91a4 <clear_is_pdu+0x8>)
    91a0:	701a      	strb	r2, [r3, #0]
}
    91a2:	4770      	bx	lr
    91a4:	010019a2 	.word	0x010019a2

000091a8 <get_is_pdu>:
    return is_pdu;
    91a8:	4b01      	ldr	r3, [pc, #4]	; (91b0 <get_is_pdu+0x8>)
    91aa:	7818      	ldrb	r0, [r3, #0]
}
    91ac:	4770      	bx	lr
    91ae:	46c0      	nop			; (mov r8, r8)
    91b0:	010019a2 	.word	0x010019a2

000091b4 <app_at_get_non_ip_mtu_size>:
{
    91b4:	b5f0      	push	{r4, r5, r6, r7, lr}
    91b6:	b0bb      	sub	sp, #236	; 0xec
    pdp_context context = {0};
    91b8:	ad1c      	add	r5, sp, #112	; 0x70
{
    91ba:	0007      	movs	r7, r0
    pdp_context context = {0};
    91bc:	2278      	movs	r2, #120	; 0x78
    91be:	2100      	movs	r1, #0
    91c0:	0028      	movs	r0, r5
    91c2:	f7f7 f88d 	bl	2e0 <memset>
    context.apn = apn_str;
    91c6:	ab02      	add	r3, sp, #8
    91c8:	60eb      	str	r3, [r5, #12]
    if (non_ip_mtu_size == NULL)
    91ca:	2f00      	cmp	r7, #0
    91cc:	d102      	bne.n	91d4 <app_at_get_non_ip_mtu_size+0x20>
        return AT_RET_PROGRESS_ERROR;
    91ce:	2006      	movs	r0, #6
}
    91d0:	b03b      	add	sp, #236	; 0xec
    91d2:	bdf0      	pop	{r4, r5, r6, r7, pc}
    if (app_at_non_ip_mtu_info == 0)
    91d4:	4e11      	ldr	r6, [pc, #68]	; (921c <app_at_get_non_ip_mtu_size+0x68>)
    91d6:	8834      	ldrh	r4, [r6, #0]
    91d8:	2c00      	cmp	r4, #0
    91da:	d115      	bne.n	9208 <app_at_get_non_ip_mtu_size+0x54>
            memset(context.apn, 0, NEUL_MAX_APN_SIZE);
    91dc:	2100      	movs	r1, #0
    91de:	2265      	movs	r2, #101	; 0x65
    91e0:	68e8      	ldr	r0, [r5, #12]
    91e2:	f7f7 f87d 	bl	2e0 <memset>
            if (get_pdp_context(cid, &context) == NEUL_RET_OK)
    91e6:	0029      	movs	r1, r5
    91e8:	0020      	movs	r0, r4
    91ea:	f013 f8ad 	bl	1c348 <get_pdp_context>
    91ee:	2800      	cmp	r0, #0
    91f0:	d10e      	bne.n	9210 <app_at_get_non_ip_mtu_size+0x5c>
                if (context.pdp_type == PDN_TYPE_NON_IP)
    91f2:	792b      	ldrb	r3, [r5, #4]
    91f4:	2b05      	cmp	r3, #5
    91f6:	d10b      	bne.n	9210 <app_at_get_non_ip_mtu_size+0x5c>
                    if (get_mtu_size(cid,&ip_mtu_size,&app_at_non_ip_mtu_info) != NEUL_RET_OK)
    91f8:	466b      	mov	r3, sp
    91fa:	0032      	movs	r2, r6
    91fc:	1d99      	adds	r1, r3, #6
    91fe:	0020      	movs	r0, r4
    9200:	f013 fae5 	bl	1c7ce <get_mtu_size>
    9204:	2800      	cmp	r0, #0
    9206:	d1e2      	bne.n	91ce <app_at_get_non_ip_mtu_size+0x1a>
    *non_ip_mtu_size = app_at_non_ip_mtu_info;
    9208:	8833      	ldrh	r3, [r6, #0]
    return AT_RET_OK;
    920a:	2000      	movs	r0, #0
    *non_ip_mtu_size = app_at_non_ip_mtu_info;
    920c:	803b      	strh	r3, [r7, #0]
    return AT_RET_OK;
    920e:	e7df      	b.n	91d0 <app_at_get_non_ip_mtu_size+0x1c>
        for (cid = 0; cid <= AT_MAX_CID; cid++)
    9210:	3401      	adds	r4, #1
    9212:	b2e4      	uxtb	r4, r4
    9214:	2c0b      	cmp	r4, #11
    9216:	d1e1      	bne.n	91dc <app_at_get_non_ip_mtu_size+0x28>
    9218:	e7f6      	b.n	9208 <app_at_get_non_ip_mtu_size+0x54>
    921a:	46c0      	nop			; (mov r8, r8)
    921c:	0100199e 	.word	0x0100199e

00009220 <app_at_min_ip_mtu_from_active_cids>:
{
    9220:	b5f0      	push	{r4, r5, r6, r7, lr}
    9222:	0006      	movs	r6, r0
    struct ifaddrs *ifa = NULL;
    9224:	2000      	movs	r0, #0
{
    9226:	b085      	sub	sp, #20
    struct ifaddrs *ifa = NULL;
    9228:	9003      	str	r0, [sp, #12]
    if (mtu == NULL)
    922a:	4286      	cmp	r6, r0
    922c:	d101      	bne.n	9232 <app_at_min_ip_mtu_from_active_cids+0x12>
            return AT_RET_PROGRESS_ERROR;
    922e:	2006      	movs	r0, #6
    9230:	e004      	b.n	923c <app_at_min_ip_mtu_from_active_cids+0x1c>
    if (app_at_active_cid_ip_min_mtu != 0)
    9232:	4d1c      	ldr	r5, [pc, #112]	; (92a4 <app_at_min_ip_mtu_from_active_cids+0x84>)
    9234:	882b      	ldrh	r3, [r5, #0]
    9236:	2b00      	cmp	r3, #0
    9238:	d002      	beq.n	9240 <app_at_min_ip_mtu_from_active_cids+0x20>
        *mtu = app_at_active_cid_ip_min_mtu;
    923a:	8033      	strh	r3, [r6, #0]
}
    923c:	b005      	add	sp, #20
    923e:	bdf0      	pop	{r4, r5, r6, r7, pc}
    if ((getifaddrs(&ifa) != NEUL_RET_OK))  // get IP addresses
    9240:	a803      	add	r0, sp, #12
    9242:	f013 fe41 	bl	1cec8 <getifaddrs>
    9246:	2800      	cmp	r0, #0
    9248:	d1f1      	bne.n	922e <app_at_min_ip_mtu_from_active_cids+0xe>
    if (ifa == NULL)
    924a:	9c03      	ldr	r4, [sp, #12]
    924c:	2c00      	cmp	r4, #0
    924e:	d0ee      	beq.n	922e <app_at_min_ip_mtu_from_active_cids+0xe>
        if (app_at_get_ip_mtu_size((uint8)(current->cid), &ip_mtu_size) != AT_RET_OK)
    9250:	7a20      	ldrb	r0, [r4, #8]
    if (cid > AT_MAX_CID)
    9252:	280a      	cmp	r0, #10
    9254:	d81f      	bhi.n	9296 <app_at_min_ip_mtu_from_active_cids+0x76>
    if (app_at_ip_mtu_info[cid] == 0)
    9256:	4f14      	ldr	r7, [pc, #80]	; (92a8 <app_at_min_ip_mtu_from_active_cids+0x88>)
    9258:	0043      	lsls	r3, r0, #1
    925a:	9301      	str	r3, [sp, #4]
    925c:	5bdb      	ldrh	r3, [r3, r7]
    925e:	2b00      	cmp	r3, #0
    9260:	d011      	beq.n	9286 <app_at_min_ip_mtu_from_active_cids+0x66>
    *ip_mtu_size = app_at_ip_mtu_info[cid];
    9262:	9b01      	ldr	r3, [sp, #4]
        if ((app_at_active_cid_ip_min_mtu == 0) || (app_at_active_cid_ip_min_mtu > ip_mtu_size))
    9264:	882a      	ldrh	r2, [r5, #0]
    *ip_mtu_size = app_at_ip_mtu_info[cid];
    9266:	5afb      	ldrh	r3, [r7, r3]
        if ((app_at_active_cid_ip_min_mtu == 0) || (app_at_active_cid_ip_min_mtu > ip_mtu_size))
    9268:	2a00      	cmp	r2, #0
    926a:	d001      	beq.n	9270 <app_at_min_ip_mtu_from_active_cids+0x50>
    926c:	429a      	cmp	r2, r3
    926e:	d900      	bls.n	9272 <app_at_min_ip_mtu_from_active_cids+0x52>
            app_at_active_cid_ip_min_mtu = ip_mtu_size;
    9270:	802b      	strh	r3, [r5, #0]
        current = current->ifa_next;
    9272:	6824      	ldr	r4, [r4, #0]
    while (current)
    9274:	2c00      	cmp	r4, #0
    9276:	d1eb      	bne.n	9250 <app_at_min_ip_mtu_from_active_cids+0x30>
    freeifaddrs(ifa);
    9278:	9803      	ldr	r0, [sp, #12]
    927a:	f013 fe15 	bl	1cea8 <freeifaddrs>
    *mtu = app_at_active_cid_ip_min_mtu;
    927e:	882b      	ldrh	r3, [r5, #0]
    return AT_RET_OK;
    9280:	0020      	movs	r0, r4
    *mtu = app_at_active_cid_ip_min_mtu;
    9282:	8033      	strh	r3, [r6, #0]
    return AT_RET_OK;
    9284:	e7da      	b.n	923c <app_at_min_ip_mtu_from_active_cids+0x1c>
        if (get_mtu_size(cid,&app_at_ip_mtu_info[cid],&non_ip_mtu_size) != NEUL_RET_OK)
    9286:	0043      	lsls	r3, r0, #1
    9288:	18f9      	adds	r1, r7, r3
    928a:	ab02      	add	r3, sp, #8
    928c:	1c9a      	adds	r2, r3, #2
    928e:	f013 fa9e 	bl	1c7ce <get_mtu_size>
    9292:	2800      	cmp	r0, #0
    9294:	d0e5      	beq.n	9262 <app_at_min_ip_mtu_from_active_cids+0x42>
            if (ifa != NULL)
    9296:	9803      	ldr	r0, [sp, #12]
    9298:	2800      	cmp	r0, #0
    929a:	d0c8      	beq.n	922e <app_at_min_ip_mtu_from_active_cids+0xe>
                freeifaddrs(ifa);
    929c:	f013 fe04 	bl	1cea8 <freeifaddrs>
    92a0:	e7c5      	b.n	922e <app_at_min_ip_mtu_from_active_cids+0xe>
    92a2:	46c0      	nop			; (mov r8, r8)
    92a4:	01001986 	.word	0x01001986
    92a8:	01001988 	.word	0x01001988

000092ac <app_at_ip_mtu_init>:

void app_at_ip_mtu_init(void)
{
    92ac:	b510      	push	{r4, lr}
    (void)set_ipaddr_callback(app_at_clean_ip_mtu);
    92ae:	4802      	ldr	r0, [pc, #8]	; (92b8 <app_at_ip_mtu_init+0xc>)
    92b0:	f013 ff20 	bl	1d0f4 <set_ipaddr_callback>
}
    92b4:	bd10      	pop	{r4, pc}
    92b6:	46c0      	nop			; (mov r8, r8)
    92b8:	00008be1 	.word	0x00008be1

000092bc <get_ip_addr>:

AT_RET get_ip_addr(uint8 cid, NEUL_PDN_TYPE ip_type, char *addr, uint8 max_addr_size)
{
    92bc:	b5f0      	push	{r4, r5, r6, r7, lr}
    92be:	b085      	sub	sp, #20
    92c0:	0006      	movs	r6, r0
    struct ifaddrs *ifa;
    struct ifaddrs *current;

    if ((getifaddrs(&ifa) != NEUL_RET_OK))  // get IP addresses
    92c2:	a803      	add	r0, sp, #12
{
    92c4:	9100      	str	r1, [sp, #0]
    92c6:	0017      	movs	r7, r2
    92c8:	9301      	str	r3, [sp, #4]
    if ((getifaddrs(&ifa) != NEUL_RET_OK))  // get IP addresses
    92ca:	f013 fdfd 	bl	1cec8 <getifaddrs>
    {
        return AT_RET_PROGRESS_ERROR;
    92ce:	2406      	movs	r4, #6
    if ((getifaddrs(&ifa) != NEUL_RET_OK))  // get IP addresses
    92d0:	2800      	cmp	r0, #0
    92d2:	d13f      	bne.n	9354 <get_ip_addr+0x98>
    }

    current = ifa;
    92d4:	9c03      	ldr	r4, [sp, #12]
    while (current)
    92d6:	2c00      	cmp	r4, #0
    92d8:	d036      	beq.n	9348 <get_ip_addr+0x8c>
    {
        if ((cid == current->cid) && (!ip_addr_isany(&current->ifa_addr)))
    92da:	2208      	movs	r2, #8
    92dc:	5ea3      	ldrsh	r3, [r4, r2]
    92de:	429e      	cmp	r6, r3
    92e0:	d11b      	bne.n	931a <get_ip_addr+0x5e>
    92e2:	1c62      	adds	r2, r4, #1
    92e4:	7fd2      	ldrb	r2, [r2, #31]
    92e6:	6923      	ldr	r3, [r4, #16]
    92e8:	2a06      	cmp	r2, #6
    92ea:	d118      	bne.n	931e <get_ip_addr+0x62>
    92ec:	2b00      	cmp	r3, #0
    92ee:	d108      	bne.n	9302 <get_ip_addr+0x46>
    92f0:	6963      	ldr	r3, [r4, #20]
    92f2:	2b00      	cmp	r3, #0
    92f4:	d105      	bne.n	9302 <get_ip_addr+0x46>
    92f6:	69a3      	ldr	r3, [r4, #24]
    92f8:	2b00      	cmp	r3, #0
    92fa:	d102      	bne.n	9302 <get_ip_addr+0x46>
    92fc:	69e3      	ldr	r3, [r4, #28]
    92fe:	2b00      	cmp	r3, #0
    9300:	d00b      	beq.n	931a <get_ip_addr+0x5e>
        {
            // this will format IPv4 or IPv6 address
            char *addr_string = ipaddr_ntoa(&(current->ifa_addr));
    9302:	0020      	movs	r0, r4
    9304:	3010      	adds	r0, #16
    9306:	f014 f8ff 	bl	1d508 <ip6addr_ntoa>
    930a:	1e05      	subs	r5, r0, #0

            if (addr_string == NULL)    // should never happen
    930c:	d01c      	beq.n	9348 <get_ip_addr+0x8c>
            {
                break;
            }

            if((ip_type == PDN_TYPE_IPV6) && (addr_string[3] == '.'))
    930e:	9b00      	ldr	r3, [sp, #0]
    9310:	2b02      	cmp	r3, #2
    9312:	d10b      	bne.n	932c <get_ip_addr+0x70>
    9314:	78c3      	ldrb	r3, [r0, #3]
    9316:	2b2e      	cmp	r3, #46	; 0x2e
    9318:	d108      	bne.n	932c <get_ip_addr+0x70>
            {
                strncpy(addr, addr_string, strlen(addr_string));
            }
            break;
        }
        current = current->ifa_next;
    931a:	6824      	ldr	r4, [r4, #0]
    931c:	e7db      	b.n	92d6 <get_ip_addr+0x1a>
        if ((cid == current->cid) && (!ip_addr_isany(&current->ifa_addr)))
    931e:	2b00      	cmp	r3, #0
    9320:	d0fb      	beq.n	931a <get_ip_addr+0x5e>
            char *addr_string = ipaddr_ntoa(&(current->ifa_addr));
    9322:	0020      	movs	r0, r4
    9324:	3010      	adds	r0, #16
    9326:	f013 ffb5 	bl	1d294 <ip4addr_ntoa>
    932a:	e7ee      	b.n	930a <get_ip_addr+0x4e>
            if (strlen(addr_string) < max_addr_size )
    932c:	0028      	movs	r0, r5
    932e:	f012 f836 	bl	1b39e <strlen>
    9332:	9b01      	ldr	r3, [sp, #4]
    9334:	4298      	cmp	r0, r3
    9336:	d207      	bcs.n	9348 <get_ip_addr+0x8c>
                strncpy(addr, addr_string, strlen(addr_string));
    9338:	0028      	movs	r0, r5
    933a:	f012 f830 	bl	1b39e <strlen>
    933e:	0029      	movs	r1, r5
    9340:	0002      	movs	r2, r0
    9342:	0038      	movs	r0, r7
    9344:	f012 f85e 	bl	1b404 <strncpy>

    if (ifa != NULL)
    {
        freeifaddrs(ifa);
    }
    return AT_RET_OK;
    9348:	2400      	movs	r4, #0
    if (ifa != NULL)
    934a:	9803      	ldr	r0, [sp, #12]
    934c:	42a0      	cmp	r0, r4
    934e:	d001      	beq.n	9354 <get_ip_addr+0x98>
        freeifaddrs(ifa);
    9350:	f013 fdaa 	bl	1cea8 <freeifaddrs>
}
    9354:	0020      	movs	r0, r4
    9356:	b005      	add	sp, #20
    9358:	bdf0      	pop	{r4, r5, r6, r7, pc}
	...

0000935c <get_cmee_error_type>:
{255, "EMM ERROR : EMM_CAUSE_UNKNOWN"}
};

CMEE_ERROR_TYPE get_cmee_error_type(void)
{
    return g_cmee_error_type;
    935c:	4b01      	ldr	r3, [pc, #4]	; (9364 <get_cmee_error_type+0x8>)
    935e:	7818      	ldrb	r0, [r3, #0]
}
    9360:	4770      	bx	lr
    9362:	46c0      	nop			; (mov r8, r8)
    9364:	010019a5 	.word	0x010019a5

00009368 <set_cmee_error_type>:

void set_cmee_error_type(CMEE_ERROR_TYPE error)
{
    g_cmee_error_type = error;
    9368:	4b01      	ldr	r3, [pc, #4]	; (9370 <set_cmee_error_type+0x8>)
    936a:	7018      	strb	r0, [r3, #0]
    return;
}
    936c:	4770      	bx	lr
    936e:	46c0      	nop			; (mov r8, r8)
    9370:	010019a5 	.word	0x010019a5

00009374 <at_status_sms_output>:
    // If not found the error number, return unknown errno
    return AT_CMEE_ERRNO_UNKNOWN;
}

void at_status_sms_output(AT_SMS_RET err)
{
    9374:	b570      	push	{r4, r5, r6, lr}
    9376:	b08a      	sub	sp, #40	; 0x28
    char  rsp_string[APP_AT_RESPONSE_MAX_LEN] = {0};
    9378:	ac02      	add	r4, sp, #8
    937a:	221e      	movs	r2, #30
{
    937c:	0006      	movs	r6, r0
    char  rsp_string[APP_AT_RESPONSE_MAX_LEN] = {0};
    937e:	2100      	movs	r1, #0
    9380:	0020      	movs	r0, r4
    9382:	f7f6 ffad 	bl	2e0 <memset>
    int len = 0;

    if (err == SMS_RESPONSE_OK)
    {
        len = snprintf(rsp_string, APP_AT_RESPONSE_MAX_LEN, APP_AT_STR_OK);
    9386:	4a19      	ldr	r2, [pc, #100]	; (93ec <at_status_sms_output+0x78>)
    if (err == SMS_RESPONSE_OK)
    9388:	2e00      	cmp	r6, #0
    938a:	d004      	beq.n	9396 <at_status_sms_output+0x22>
    return g_cmee_error_type;
    938c:	4b18      	ldr	r3, [pc, #96]	; (93f0 <at_status_sms_output+0x7c>)
    }
    else if (get_cmee_error_type() == CMEE_NONE)
    938e:	781b      	ldrb	r3, [r3, #0]
    9390:	2b00      	cmp	r3, #0
    9392:	d123      	bne.n	93dc <at_status_sms_output+0x68>
    {
        len = snprintf(rsp_string, APP_AT_RESPONSE_MAX_LEN, APP_AT_STR_ERROR);
    9394:	4a17      	ldr	r2, [pc, #92]	; (93f4 <at_status_sms_output+0x80>)
    9396:	211e      	movs	r1, #30
    9398:	0020      	movs	r0, r4
    939a:	f011 fa67 	bl	1a86c <snprintf>
    }
    else
    {
        len = snprintf(rsp_string, APP_AT_RESPONSE_MAX_LEN, "+CMS ERROR: %d", AT_CMEE_ERRNO_UNKNOWN);
    939e:	0005      	movs	r5, r0
    }

    app_at_send_at_rsp_string_lines(rsp_string, true, AT_FLAG_UNLOGABLE);
    93a0:	2204      	movs	r2, #4
    93a2:	2101      	movs	r1, #1
    93a4:	0020      	movs	r0, r4
    93a6:	f000 f916 	bl	95d6 <app_at_send_at_rsp_string_lines>

    if (err != SMS_RESPONSE_OK)
    93aa:	2e00      	cmp	r6, #0
    93ac:	d00b      	beq.n	93c6 <at_status_sms_output+0x52>
    {
        memset(rsp_string, 0, sizeof(rsp_string));
    93ae:	221e      	movs	r2, #30
    93b0:	2100      	movs	r1, #0
    93b2:	0020      	movs	r0, r4
    93b4:	f7f6 ff94 	bl	2e0 <memset>

        len = snprintf(rsp_string, APP_AT_RESPONSE_MAX_LEN, "+CMS ERROR: %d", AT_CMEE_ERRNO_UNKNOWN);
    93b8:	2364      	movs	r3, #100	; 0x64
    93ba:	4a0f      	ldr	r2, [pc, #60]	; (93f8 <at_status_sms_output+0x84>)
    93bc:	211e      	movs	r1, #30
    93be:	0020      	movs	r0, r4
    93c0:	f011 fa54 	bl	1a86c <snprintf>
    93c4:	0005      	movs	r5, r0
    }

    log_event(APPS_SW_MODULE_AT, LOG_VERBOSITY_NORMAL, LOG_FLAGS_NONE, NEUL_LOG_TYPE_STRING, (uint16)len, (const uint8*)rsp_string);
    93c6:	2300      	movs	r3, #0
    93c8:	b2ad      	uxth	r5, r5
    93ca:	9401      	str	r4, [sp, #4]
    93cc:	9500      	str	r5, [sp, #0]
    93ce:	001a      	movs	r2, r3
    93d0:	2101      	movs	r1, #1
    93d2:	2008      	movs	r0, #8
    93d4:	f7fd f932 	bl	663c <log_event>
}
    93d8:	b00a      	add	sp, #40	; 0x28
    93da:	bd70      	pop	{r4, r5, r6, pc}
        len = snprintf(rsp_string, APP_AT_RESPONSE_MAX_LEN, "+CMS ERROR: %d", AT_CMEE_ERRNO_UNKNOWN);
    93dc:	2364      	movs	r3, #100	; 0x64
    93de:	4a06      	ldr	r2, [pc, #24]	; (93f8 <at_status_sms_output+0x84>)
    93e0:	211e      	movs	r1, #30
    93e2:	0020      	movs	r0, r4
    93e4:	f011 fa42 	bl	1a86c <snprintf>
    93e8:	e7d9      	b.n	939e <at_status_sms_output+0x2a>
    93ea:	46c0      	nop			; (mov r8, r8)
    93ec:	000251fe 	.word	0x000251fe
    93f0:	010019a5 	.word	0x010019a5
    93f4:	000233d4 	.word	0x000233d4
    93f8:	00022eab 	.word	0x00022eab

000093fc <at_status_output>:

void at_status_output(AT_RET err)
{
    93fc:	b570      	push	{r4, r5, r6, lr}
    93fe:	b08a      	sub	sp, #40	; 0x28
    char  rsp_string[APP_AT_RESPONSE_MAX_LEN] = {0};
    9400:	ad02      	add	r5, sp, #8
    9402:	221e      	movs	r2, #30
{
    9404:	0004      	movs	r4, r0
    char  rsp_string[APP_AT_RESPONSE_MAX_LEN] = {0};
    9406:	2100      	movs	r1, #0
    9408:	0028      	movs	r0, r5
    940a:	f7f6 ff69 	bl	2e0 <memset>
    int len = 0;

    if (err == AT_RET_OK)
    {
        len = snprintf(rsp_string, APP_AT_RESPONSE_MAX_LEN, APP_AT_STR_OK);
    940e:	4a3e      	ldr	r2, [pc, #248]	; (9508 <at_status_output+0x10c>)
    if (err == AT_RET_OK)
    9410:	2c00      	cmp	r4, #0
    9412:	d01b      	beq.n	944c <at_status_output+0x50>
    }
    else if ((err == AT_RET_SMS_RESP_SENT) || (err == AT_RET_CMD_WAIT_RESPONSE))
    9414:	0023      	movs	r3, r4
    9416:	22ef      	movs	r2, #239	; 0xef
    9418:	3b14      	subs	r3, #20
    941a:	4213      	tst	r3, r2
    941c:	d04f      	beq.n	94be <at_status_output+0xc2>
    return g_cmee_error_type;
    941e:	4b3b      	ldr	r3, [pc, #236]	; (950c <at_status_output+0x110>)
    {
        return;
    }
    else if (get_cmee_error_type() == CMEE_NONE)
    9420:	781b      	ldrb	r3, [r3, #0]
    9422:	2b00      	cmp	r3, #0
    9424:	d011      	beq.n	944a <at_status_output+0x4e>
        if (err == g_cms_errno_table[i].cause)
    9426:	2c21      	cmp	r4, #33	; 0x21
    9428:	d04b      	beq.n	94c2 <at_status_output+0xc6>
    942a:	2c22      	cmp	r4, #34	; 0x22
    942c:	d056      	beq.n	94dc <at_status_output+0xe0>
    942e:	2c23      	cmp	r4, #35	; 0x23
    9430:	d056      	beq.n	94e0 <at_status_output+0xe4>
    9432:	2c27      	cmp	r4, #39	; 0x27
    9434:	d056      	beq.n	94e4 <at_status_output+0xe8>
    9436:	2300      	movs	r3, #0
        if (err == g_cmee_errno_table[i].cause)
    9438:	4935      	ldr	r1, [pc, #212]	; (9510 <at_status_output+0x114>)
    943a:	009a      	lsls	r2, r3, #2
    943c:	1852      	adds	r2, r2, r1
    943e:	7810      	ldrb	r0, [r2, #0]
    9440:	42a0      	cmp	r0, r4
    9442:	d151      	bne.n	94e8 <at_status_output+0xec>
            return g_cmee_errno_table[i].errno;
    9444:	8853      	ldrh	r3, [r2, #2]
        {
            len = snprintf(rsp_string, APP_AT_RESPONSE_MAX_LEN, "+CMS ERROR: %d", at_cause_to_sms_error(err));
        }
        else
        {
            len = snprintf(rsp_string, APP_AT_RESPONSE_MAX_LEN, "+CME ERROR: %d", at_cause_to_error(err));
    9446:	4a33      	ldr	r2, [pc, #204]	; (9514 <at_status_output+0x118>)
    9448:	e043      	b.n	94d2 <at_status_output+0xd6>
        len = snprintf(rsp_string, APP_AT_RESPONSE_MAX_LEN, APP_AT_STR_ERROR);
    944a:	4a33      	ldr	r2, [pc, #204]	; (9518 <at_status_output+0x11c>)
    944c:	211e      	movs	r1, #30
    944e:	0028      	movs	r0, r5
    9450:	f011 fa0c 	bl	1a86c <snprintf>
            len = snprintf(rsp_string, APP_AT_RESPONSE_MAX_LEN, "+CME ERROR: %d", at_cause_to_error(err));
    9454:	0006      	movs	r6, r0
        }
    }

    app_at_send_at_rsp_string_lines(rsp_string, true, AT_FLAG_UNLOGABLE);
    9456:	2204      	movs	r2, #4
    9458:	2101      	movs	r1, #1
    945a:	0028      	movs	r0, r5
    945c:	f000 f8bb 	bl	95d6 <app_at_send_at_rsp_string_lines>

    if (err != AT_RET_OK)
    9460:	2c00      	cmp	r4, #0
    9462:	d023      	beq.n	94ac <at_status_output+0xb0>
    {
        memset(rsp_string, 0, sizeof(rsp_string));
    9464:	221e      	movs	r2, #30
    9466:	2100      	movs	r1, #0
    9468:	0028      	movs	r0, r5
    946a:	f7f6 ff39 	bl	2e0 <memset>
        if (err == g_cms_errno_table[i].cause)
    946e:	2c21      	cmp	r4, #33	; 0x21
    9470:	d03f      	beq.n	94f2 <at_status_output+0xf6>
    9472:	2c22      	cmp	r4, #34	; 0x22
    9474:	d03f      	beq.n	94f6 <at_status_output+0xfa>
    9476:	2c23      	cmp	r4, #35	; 0x23
    9478:	d03f      	beq.n	94fa <at_status_output+0xfe>
    947a:	2300      	movs	r3, #0
    947c:	2c27      	cmp	r4, #39	; 0x27
    947e:	d108      	bne.n	9492 <at_status_output+0x96>
    for (i = 0; i < (sizeof(g_cms_errno_table)/sizeof(at_ret_errno_map_t)); i++)
    9480:	3303      	adds	r3, #3
            return g_cms_errno_table[i].errno;
    9482:	4a26      	ldr	r2, [pc, #152]	; (951c <at_status_output+0x120>)
    9484:	009b      	lsls	r3, r3, #2
    9486:	18d3      	adds	r3, r2, r3
    9488:	885b      	ldrh	r3, [r3, #2]
        if (at_cause_to_sms_error(err) != AT_CMEE_ERRNO_UNKNOWN)
        {
            len = snprintf(rsp_string, APP_AT_RESPONSE_MAX_LEN, "+CMS ERROR: %d", at_cause_to_sms_error(err));
    948a:	4a25      	ldr	r2, [pc, #148]	; (9520 <at_status_output+0x124>)
        if (at_cause_to_sms_error(err) != AT_CMEE_ERRNO_UNKNOWN)
    948c:	2b64      	cmp	r3, #100	; 0x64
    948e:	d108      	bne.n	94a2 <at_status_output+0xa6>
    9490:	2300      	movs	r3, #0
        if (err == g_cmee_errno_table[i].cause)
    9492:	491f      	ldr	r1, [pc, #124]	; (9510 <at_status_output+0x114>)
    9494:	009a      	lsls	r2, r3, #2
    9496:	1852      	adds	r2, r2, r1
    9498:	7810      	ldrb	r0, [r2, #0]
    949a:	42a0      	cmp	r0, r4
    949c:	d12f      	bne.n	94fe <at_status_output+0x102>
            return g_cmee_errno_table[i].errno;
    949e:	8853      	ldrh	r3, [r2, #2]
        }
        else
        {
            len = snprintf(rsp_string, APP_AT_RESPONSE_MAX_LEN, "+CME ERROR: %d", at_cause_to_error(err));
    94a0:	4a1c      	ldr	r2, [pc, #112]	; (9514 <at_status_output+0x118>)
    94a2:	211e      	movs	r1, #30
    94a4:	0028      	movs	r0, r5
    94a6:	f011 f9e1 	bl	1a86c <snprintf>
    94aa:	0006      	movs	r6, r0
        }
    }
    log_event(APPS_SW_MODULE_AT, LOG_VERBOSITY_NORMAL, LOG_FLAGS_NONE, NEUL_LOG_TYPE_STRING, (uint16)len, (const uint8*)rsp_string);
    94ac:	2300      	movs	r3, #0
    94ae:	b2b6      	uxth	r6, r6
    94b0:	9501      	str	r5, [sp, #4]
    94b2:	9600      	str	r6, [sp, #0]
    94b4:	001a      	movs	r2, r3
    94b6:	2101      	movs	r1, #1
    94b8:	2008      	movs	r0, #8
    94ba:	f7fd f8bf 	bl	663c <log_event>
}
    94be:	b00a      	add	sp, #40	; 0x28
    94c0:	bd70      	pop	{r4, r5, r6, pc}
    for (i = 0; i < (sizeof(g_cms_errno_table)/sizeof(at_ret_errno_map_t)); i++)
    94c2:	2300      	movs	r3, #0
            return g_cms_errno_table[i].errno;
    94c4:	4a15      	ldr	r2, [pc, #84]	; (951c <at_status_output+0x120>)
    94c6:	009b      	lsls	r3, r3, #2
    94c8:	18d3      	adds	r3, r2, r3
    94ca:	885b      	ldrh	r3, [r3, #2]
            len = snprintf(rsp_string, APP_AT_RESPONSE_MAX_LEN, "+CMS ERROR: %d", at_cause_to_sms_error(err));
    94cc:	4a14      	ldr	r2, [pc, #80]	; (9520 <at_status_output+0x124>)
        if (at_cause_to_sms_error(err) != AT_CMEE_ERRNO_UNKNOWN)
    94ce:	2b64      	cmp	r3, #100	; 0x64
    94d0:	d0b1      	beq.n	9436 <at_status_output+0x3a>
            len = snprintf(rsp_string, APP_AT_RESPONSE_MAX_LEN, "+CME ERROR: %d", at_cause_to_error(err));
    94d2:	211e      	movs	r1, #30
    94d4:	0028      	movs	r0, r5
    94d6:	f011 f9c9 	bl	1a86c <snprintf>
    94da:	e7bb      	b.n	9454 <at_status_output+0x58>
    for (i = 0; i < (sizeof(g_cms_errno_table)/sizeof(at_ret_errno_map_t)); i++)
    94dc:	2301      	movs	r3, #1
    94de:	e7f1      	b.n	94c4 <at_status_output+0xc8>
    94e0:	2302      	movs	r3, #2
    94e2:	e7ef      	b.n	94c4 <at_status_output+0xc8>
    94e4:	2303      	movs	r3, #3
    94e6:	e7ed      	b.n	94c4 <at_status_output+0xc8>
    for (i = 0; i < (sizeof(g_cmee_errno_table)/sizeof(at_ret_errno_map_t)); i++)
    94e8:	3301      	adds	r3, #1
    94ea:	2b28      	cmp	r3, #40	; 0x28
    94ec:	d1a5      	bne.n	943a <at_status_output+0x3e>
    return AT_CMEE_ERRNO_UNKNOWN;
    94ee:	333c      	adds	r3, #60	; 0x3c
    94f0:	e7a9      	b.n	9446 <at_status_output+0x4a>
    for (i = 0; i < (sizeof(g_cms_errno_table)/sizeof(at_ret_errno_map_t)); i++)
    94f2:	2300      	movs	r3, #0
    94f4:	e7c5      	b.n	9482 <at_status_output+0x86>
    94f6:	2301      	movs	r3, #1
    94f8:	e7c3      	b.n	9482 <at_status_output+0x86>
    94fa:	2302      	movs	r3, #2
    94fc:	e7c1      	b.n	9482 <at_status_output+0x86>
    for (i = 0; i < (sizeof(g_cmee_errno_table)/sizeof(at_ret_errno_map_t)); i++)
    94fe:	3301      	adds	r3, #1
    9500:	2b28      	cmp	r3, #40	; 0x28
    9502:	d1c7      	bne.n	9494 <at_status_output+0x98>
    return AT_CMEE_ERRNO_UNKNOWN;
    9504:	333c      	adds	r3, #60	; 0x3c
    9506:	e7cb      	b.n	94a0 <at_status_output+0xa4>
    9508:	000251fe 	.word	0x000251fe
    950c:	010019a5 	.word	0x010019a5
    9510:	00022fec 	.word	0x00022fec
    9514:	00022e9c 	.word	0x00022e9c
    9518:	000233d4 	.word	0x000233d4
    951c:	0002308c 	.word	0x0002308c
    9520:	00022eab 	.word	0x00022eab

00009524 <get_ceer_register_reject_cause>:

const char * get_ceer_register_reject_cause(uint8 cause)
{
    9524:	2300      	movs	r3, #0
    9526:	b510      	push	{r4, lr}
    uint8       i;
    const char  *string = NULL;

    for (i = 0; i < CEER_EMM_MAX_CAUSE_STR_SIZE; i++)
    {
        if (cause == g_ceer_emm_cause_str[i].cause)
    9528:	4906      	ldr	r1, [pc, #24]	; (9544 <get_ceer_register_reject_cause+0x20>)
    952a:	00da      	lsls	r2, r3, #3
    952c:	1852      	adds	r2, r2, r1
    952e:	7814      	ldrb	r4, [r2, #0]
    9530:	4284      	cmp	r4, r0
    9532:	d101      	bne.n	9538 <get_ceer_register_reject_cause+0x14>
        {
            string = g_ceer_emm_cause_str[i].str;
    9534:	6850      	ldr	r0, [r2, #4]
            break;
        }
    }

    return string;
}
    9536:	bd10      	pop	{r4, pc}
    9538:	3301      	adds	r3, #1
    for (i = 0; i < CEER_EMM_MAX_CAUSE_STR_SIZE; i++)
    953a:	2b26      	cmp	r3, #38	; 0x26
    953c:	d1f5      	bne.n	952a <get_ceer_register_reject_cause+0x6>
    const char  *string = NULL;
    953e:	2000      	movs	r0, #0
    return string;
    9540:	e7f9      	b.n	9536 <get_ceer_register_reject_cause+0x12>
    9542:	46c0      	nop			; (mov r8, r8)
    9544:	00022ebc 	.word	0x00022ebc

00009548 <app_at_send_at_rsp>:
 * @param rn With "\r\n" string before, after at string or not.
 * @param claim With Claim at uart before send and release at uart after send or not.
 * @param log_flag flag for log print.
 */
static void app_at_send_at_rsp(const char *at_string, bool rn, bool claim, AT_FLAG log_flag)
{
    9548:	b5f0      	push	{r4, r5, r6, r7, lr}
    954a:	b085      	sub	sp, #20
    954c:	0004      	movs	r4, r0
    954e:	000e      	movs	r6, r1
    9550:	1e15      	subs	r5, r2, #0
    9552:	9303      	str	r3, [sp, #12]
    log_flags_t         output_log_flag = LOG_FLAGS_NONE;
    
    //lint -esym(429, at_string) at_string will freed where it defined
    if (claim)
    9554:	d001      	beq.n	955a <app_at_send_at_rsp+0x12>
    {
        at_uart_claim();
    9556:	f000 fa27 	bl	99a8 <at_uart_claim>
    }

    if (rn)
    955a:	2e00      	cmp	r6, #0
    955c:	d007      	beq.n	956e <app_at_send_at_rsp+0x26>
    {
        at_uart_write((unsigned char*)APP_AT_STR_RN, strlen(APP_AT_STR_RN));
    955e:	4f19      	ldr	r7, [pc, #100]	; (95c4 <app_at_send_at_rsp+0x7c>)
    9560:	0038      	movs	r0, r7
    9562:	f011 ff1c 	bl	1b39e <strlen>
    9566:	0001      	movs	r1, r0
    9568:	0038      	movs	r0, r7
    956a:	f000 fa3f 	bl	99ec <at_uart_write>
    }
    at_uart_write((unsigned char*)at_string, strlen(at_string));
    956e:	0020      	movs	r0, r4
    9570:	f011 ff15 	bl	1b39e <strlen>
    9574:	0001      	movs	r1, r0
    9576:	0020      	movs	r0, r4
    9578:	f000 fa38 	bl	99ec <at_uart_write>
    if (rn)
    957c:	2e00      	cmp	r6, #0
    957e:	d007      	beq.n	9590 <app_at_send_at_rsp+0x48>
    {
        at_uart_write((unsigned char*)APP_AT_STR_RN, strlen(APP_AT_STR_RN));
    9580:	4e10      	ldr	r6, [pc, #64]	; (95c4 <app_at_send_at_rsp+0x7c>)
    9582:	0030      	movs	r0, r6
    9584:	f011 ff0b 	bl	1b39e <strlen>
    9588:	0001      	movs	r1, r0
    958a:	0030      	movs	r0, r6
    958c:	f000 fa2e 	bl	99ec <at_uart_write>
    }

    if (claim)
    9590:	2d00      	cmp	r5, #0
    9592:	d001      	beq.n	9598 <app_at_send_at_rsp+0x50>
    {
        at_uart_release();
    9594:	f000 fa1a 	bl	99cc <at_uart_release>
    }
    
    if (AT_IS_LOG_RESTRICTED(log_flag))
    9598:	2520      	movs	r5, #32
    959a:	9b03      	ldr	r3, [sp, #12]
    959c:	401d      	ands	r5, r3
    959e:	d10f      	bne.n	95c0 <app_at_send_at_rsp+0x78>
    {
        output_log_flag = LOG_FLAGS_RESTRICTED;
    }
    else if (!AT_IS_LOGABLE(log_flag))
    95a0:	071b      	lsls	r3, r3, #28
    95a2:	d50b      	bpl.n	95bc <app_at_send_at_rsp+0x74>
    {
        return;
    }

    log_event(APPS_SW_MODULE_AT, LOG_VERBOSITY_NORMAL, output_log_flag, NEUL_LOG_TYPE_STRING, (uint16)strlen(at_string), (const uint8*) at_string);
    95a4:	0020      	movs	r0, r4
    95a6:	f011 fefa 	bl	1b39e <strlen>
    95aa:	b280      	uxth	r0, r0
    95ac:	9000      	str	r0, [sp, #0]
    95ae:	9401      	str	r4, [sp, #4]
    95b0:	2300      	movs	r3, #0
    95b2:	002a      	movs	r2, r5
    95b4:	2101      	movs	r1, #1
    95b6:	2008      	movs	r0, #8
    95b8:	f7fd f840 	bl	663c <log_event>
}
    95bc:	b005      	add	sp, #20
    95be:	bdf0      	pop	{r4, r5, r6, r7, pc}
        output_log_flag = LOG_FLAGS_RESTRICTED;
    95c0:	2504      	movs	r5, #4
    95c2:	e7ef      	b.n	95a4 <app_at_send_at_rsp+0x5c>
    95c4:	00022d8f 	.word	0x00022d8f

000095c8 <app_at_send_at_rsp_string>:
 * @param at_string The at string to send out through at uart.
 * @param claim With Claim at uart before send and release at uart after send or not.
 * @param log_flag flag for log print.
 */
void app_at_send_at_rsp_string(const char *at_string, bool claim, AT_FLAG log_flag)
{
    95c8:	b510      	push	{r4, lr}
    95ca:	0013      	movs	r3, r2
    app_at_send_at_rsp(at_string, false, claim, log_flag);
    95cc:	000a      	movs	r2, r1
    95ce:	2100      	movs	r1, #0
    95d0:	f7ff ffba 	bl	9548 <app_at_send_at_rsp>
}
    95d4:	bd10      	pop	{r4, pc}

000095d6 <app_at_send_at_rsp_string_lines>:
 * @param at_string The at string to send out through at uart.
 * @param claim With Claim at uart before send and release at uart after send or not.
 * @param log_flag flag for log print.
 */
void app_at_send_at_rsp_string_lines(const char *at_string, bool claim, AT_FLAG log_flag)
{
    95d6:	b510      	push	{r4, lr}
    95d8:	0013      	movs	r3, r2
    app_at_send_at_rsp(at_string, true, claim, log_flag);
    95da:	000a      	movs	r2, r1
    95dc:	2101      	movs	r1, #1
    95de:	f7ff ffb3 	bl	9548 <app_at_send_at_rsp>
}
    95e2:	bd10      	pop	{r4, pc}

000095e4 <app_at_send_at_rsp_string_lines_with_claim_and_log>:
 * @With Claim at uart before send and release at uart after send. With log output after send.
 * @param at_string The at string to send out through at uart.
 */
void app_at_send_at_rsp_string_lines_with_claim_and_log(const char *at_string)
{
    app_at_send_at_rsp(at_string, true, true, AT_FLAG_LOGABLE);
    95e4:	2201      	movs	r2, #1
{
    95e6:	b510      	push	{r4, lr}
    app_at_send_at_rsp(at_string, true, true, AT_FLAG_LOGABLE);
    95e8:	2308      	movs	r3, #8
    95ea:	0011      	movs	r1, r2
    95ec:	f7ff ffac 	bl	9548 <app_at_send_at_rsp>
}
    95f0:	bd10      	pop	{r4, pc}

000095f2 <app_at_send_at_rsp_string_lines_with_claim_and_log_restricted>:
 * @With Claim at uart before send and release at uart after send. With log output after send.
 * @param at_string The at string to send out through at uart.
 */
void app_at_send_at_rsp_string_lines_with_claim_and_log_restricted(const char *at_string)
{
    app_at_send_at_rsp(at_string, true, true, AT_FLAG_LOGABLE | AT_FLAG_LOG_RESTRICTED);
    95f2:	2201      	movs	r2, #1
{
    95f4:	b510      	push	{r4, lr}
    app_at_send_at_rsp(at_string, true, true, AT_FLAG_LOGABLE | AT_FLAG_LOG_RESTRICTED);
    95f6:	2328      	movs	r3, #40	; 0x28
    95f8:	0011      	movs	r1, r2
    95fa:	f7ff ffa5 	bl	9548 <app_at_send_at_rsp>
}
    95fe:	bd10      	pop	{r4, pc}

00009600 <app_at_send_at_rsp_string_rn_no_claim>:
 * @brief send at string through at uart and "\r\n" string after at string. Without claim at uart and release at uart. With log.
 * @param at_string The at string to send out through at uart.
 * @param log_flag flag for log print.
 */
void app_at_send_at_rsp_string_rn_no_claim(const char *at_string, AT_FLAG log_flag)
{
    9600:	b573      	push	{r0, r1, r4, r5, r6, lr}
    9602:	000e      	movs	r6, r1
    9604:	0005      	movs	r5, r0
    log_flags_t  output_log_flag = LOG_FLAGS_NONE;
    
    at_uart_write((unsigned char*)at_string, strlen(at_string));
    9606:	f011 feca 	bl	1b39e <strlen>
    960a:	0001      	movs	r1, r0
    960c:	0028      	movs	r0, r5
    960e:	f000 f9ed 	bl	99ec <at_uart_write>
    at_uart_write((uint8*)APP_AT_STR_RN, strlen(APP_AT_STR_RN));
    9612:	4c0e      	ldr	r4, [pc, #56]	; (964c <app_at_send_at_rsp_string_rn_no_claim+0x4c>)
    9614:	0020      	movs	r0, r4
    9616:	f011 fec2 	bl	1b39e <strlen>
    961a:	0001      	movs	r1, r0
    961c:	0020      	movs	r0, r4

    if (AT_IS_LOG_RESTRICTED(log_flag))
    961e:	2420      	movs	r4, #32
    at_uart_write((uint8*)APP_AT_STR_RN, strlen(APP_AT_STR_RN));
    9620:	f000 f9e4 	bl	99ec <at_uart_write>
    if (AT_IS_LOG_RESTRICTED(log_flag))
    9624:	4034      	ands	r4, r6
    9626:	d10e      	bne.n	9646 <app_at_send_at_rsp_string_rn_no_claim+0x46>
    {
        output_log_flag = LOG_FLAGS_RESTRICTED;
    }
    else if (!AT_IS_LOGABLE(log_flag))
    9628:	0733      	lsls	r3, r6, #28
    962a:	d50b      	bpl.n	9644 <app_at_send_at_rsp_string_rn_no_claim+0x44>
    {
        return;
    }

    log_event(APPS_SW_MODULE_AT, LOG_VERBOSITY_NORMAL, output_log_flag, NEUL_LOG_TYPE_STRING, (uint16)strlen(at_string), (const uint8*) at_string);
    962c:	0028      	movs	r0, r5
    962e:	f011 feb6 	bl	1b39e <strlen>
    9632:	b280      	uxth	r0, r0
    9634:	9000      	str	r0, [sp, #0]
    9636:	9501      	str	r5, [sp, #4]
    9638:	2300      	movs	r3, #0
    963a:	0022      	movs	r2, r4
    963c:	2101      	movs	r1, #1
    963e:	2008      	movs	r0, #8
    9640:	f7fc fffc 	bl	663c <log_event>
}
    9644:	bd73      	pop	{r0, r1, r4, r5, r6, pc}
        output_log_flag = LOG_FLAGS_RESTRICTED;
    9646:	2404      	movs	r4, #4
    9648:	e7f0      	b.n	962c <app_at_send_at_rsp_string_rn_no_claim+0x2c>
    964a:	46c0      	nop			; (mov r8, r8)
    964c:	00022d8f 	.word	0x00022d8f

00009650 <app_at_send_convert_hexstring_no_claim>:
 * @param at_string The at hexstring to send out through at uart.
 * @param offset_to_convert The position need to convert to hexstring.
 * @param length_to_convert The length need to convert to hexstring.
 */
void app_at_send_convert_hexstring_no_claim(const char *at_string, uint16 offset_to_convert, uint16 length_to_convert)
{
    9650:	b5f0      	push	{r4, r5, r6, r7, lr}
    9652:	b085      	sub	sp, #20
    9654:	000e      	movs	r6, r1
    9656:	9201      	str	r2, [sp, #4]
    9658:	0007      	movs	r7, r0
    at_uart_claim();
    965a:	f000 f9a5 	bl	99a8 <at_uart_claim>
    uint8 op[2];
    at_uart_write((uint8*)APP_AT_STR_RN, strlen(APP_AT_STR_RN));
    965e:	4d15      	ldr	r5, [pc, #84]	; (96b4 <app_at_send_convert_hexstring_no_claim+0x64>)
    at_uart_write((uint8*)at_string, offset_to_convert);
    for (uint16 i = offset_to_convert; i < (offset_to_convert + length_to_convert); i++)
    9660:	0034      	movs	r4, r6
    at_uart_write((uint8*)APP_AT_STR_RN, strlen(APP_AT_STR_RN));
    9662:	0028      	movs	r0, r5
    9664:	f011 fe9b 	bl	1b39e <strlen>
    9668:	0001      	movs	r1, r0
    966a:	0028      	movs	r0, r5
    966c:	f000 f9be 	bl	99ec <at_uart_write>
    at_uart_write((uint8*)at_string, offset_to_convert);
    9670:	0031      	movs	r1, r6
    9672:	0038      	movs	r0, r7
    9674:	f000 f9ba 	bl	99ec <at_uart_write>
    for (uint16 i = offset_to_convert; i < (offset_to_convert + length_to_convert); i++)
    9678:	9b01      	ldr	r3, [sp, #4]
    967a:	18f3      	adds	r3, r6, r3
    967c:	429c      	cmp	r4, r3
    967e:	db07      	blt.n	9690 <app_at_send_convert_hexstring_no_claim+0x40>
            at_uart_release();
            return;
        }
        at_uart_write(op, 2);
    }
    at_uart_write((uint8*)APP_AT_STR_RN, strlen(APP_AT_STR_RN));
    9680:	0028      	movs	r0, r5
    9682:	f011 fe8c 	bl	1b39e <strlen>
    9686:	0001      	movs	r1, r0
    9688:	0028      	movs	r0, r5
    968a:	f000 f9af 	bl	99ec <at_uart_write>
    968e:	e006      	b.n	969e <app_at_send_convert_hexstring_no_claim+0x4e>
        if (at_parse_buf_to_hex_forward_order((uint8*)(at_string + i), op, 1) == false)
    9690:	1938      	adds	r0, r7, r4
    9692:	2201      	movs	r2, #1
    9694:	a903      	add	r1, sp, #12
    9696:	f000 fd50 	bl	a13a <at_parse_buf_to_hex_forward_order>
    969a:	2800      	cmp	r0, #0
    969c:	d103      	bne.n	96a6 <app_at_send_convert_hexstring_no_claim+0x56>
    at_uart_release();
    969e:	f000 f995 	bl	99cc <at_uart_release>
}
    96a2:	b005      	add	sp, #20
    96a4:	bdf0      	pop	{r4, r5, r6, r7, pc}
        at_uart_write(op, 2);
    96a6:	2102      	movs	r1, #2
    96a8:	a803      	add	r0, sp, #12
    for (uint16 i = offset_to_convert; i < (offset_to_convert + length_to_convert); i++)
    96aa:	3401      	adds	r4, #1
        at_uart_write(op, 2);
    96ac:	f000 f99e 	bl	99ec <at_uart_write>
    for (uint16 i = offset_to_convert; i < (offset_to_convert + length_to_convert); i++)
    96b0:	b2a4      	uxth	r4, r4
    96b2:	e7e1      	b.n	9678 <app_at_send_convert_hexstring_no_claim+0x28>
    96b4:	00022d8f 	.word	0x00022d8f

000096b8 <app_at_send_at_string_delayed_async>:
 * @param log_flag The attribute of message.
 * @param offset_to_convert The start offset in message should be convert to hexstring.
 * @param length_to_convert The length in message should be convert to hexstring.
 */
void app_at_send_at_string_delayed_async(const char *at_string, AT_FLAG log_flag, uint16 offset_to_convert, uint16 length_to_convert)
{
    96b8:	b510      	push	{r4, lr}
    delayed_async_print(at_string, log_flag, offset_to_convert, length_to_convert);
    96ba:	f001 faff 	bl	acbc <delayed_async_print>
}
    96be:	bd10      	pop	{r4, pc}

000096c0 <at_uart_trigger_received_at_notify_callback>:
{
    at_uart_received_at_notify_callback = callback;
}

static void at_uart_trigger_received_at_notify_callback(void)
{
    96c0:	b510      	push	{r4, lr}
    if (at_uart_received_at_notify_callback)
    96c2:	4b03      	ldr	r3, [pc, #12]	; (96d0 <at_uart_trigger_received_at_notify_callback+0x10>)
    96c4:	681b      	ldr	r3, [r3, #0]
    96c6:	2b00      	cmp	r3, #0
    96c8:	d000      	beq.n	96cc <at_uart_trigger_received_at_notify_callback+0xc>
    {
        (at_uart_received_at_notify_callback)();
    96ca:	4798      	blx	r3
    }
}
    96cc:	bd10      	pop	{r4, pc}
    96ce:	46c0      	nop			; (mov r8, r8)
    96d0:	0100249c 	.word	0x0100249c

000096d4 <at_uart_kick_recv_process>:
    at_uart_recv_queue = osMessageQueueNew( AT_UART_RECV_QUEUE_SIZE, sizeof(uint32), NULL );
    assert( at_uart_recv_queue != NULL );
}

static void at_uart_kick_recv_process( void )
{
    96d4:	b507      	push	{r0, r1, r2, lr}
    uint32 unused = 0;
    96d6:	2200      	movs	r2, #0
    (void)osMessageQueuePut(at_uart_recv_queue, (void*)&unused, 0, osNoWait);
    96d8:	4803      	ldr	r0, [pc, #12]	; (96e8 <at_uart_kick_recv_process+0x14>)
    96da:	0013      	movs	r3, r2
    96dc:	a901      	add	r1, sp, #4
    96de:	6800      	ldr	r0, [r0, #0]
    uint32 unused = 0;
    96e0:	9201      	str	r2, [sp, #4]
    (void)osMessageQueuePut(at_uart_recv_queue, (void*)&unused, 0, osNoWait);
    96e2:	f00b fa2d 	bl	14b40 <osMessageQueuePut>
}
    96e6:	bd07      	pop	{r0, r1, r2, pc}
    96e8:	010024a4 	.word	0x010024a4

000096ec <at_uart_main_normal_uart_callback>:
        }
    }
}

static void at_uart_main_normal_uart_callback(void * buffer, uint16 length, UART_RELEASE_FUNCTION release_func)
{
    96ec:	b510      	push	{r4, lr}
    at_uart_kick_recv_process();
    96ee:	f7ff fff1 	bl	96d4 <at_uart_kick_recv_process>

    // These parameters are not used as data is pulled from at_uart_main_uart_recv_process() thread
    UNUSED( buffer );
    UNUSED( length );
    UNUSED( release_func );
}
    96f2:	bd10      	pop	{r4, pc}

000096f4 <at_uart_main_lp_uart_callback>:
{
    96f4:	b510      	push	{r4, lr}
    at_uart_kick_recv_process();
    96f6:	f7ff ffed 	bl	96d4 <at_uart_kick_recv_process>
}
    96fa:	bd10      	pop	{r4, pc}

000096fc <at_uart_main_tx_uart_write_callback>:
{
    96fc:	b510      	push	{r4, lr}
    if(osSemaphoreRelease(at_uart_tx_data) != osOK)
    96fe:	4b06      	ldr	r3, [pc, #24]	; (9718 <at_uart_main_tx_uart_write_callback+0x1c>)
    9700:	4674      	mov	r4, lr
    9702:	6818      	ldr	r0, [r3, #0]
    9704:	f00b f9e6 	bl	14ad4 <osSemaphoreRelease>
    9708:	2800      	cmp	r0, #0
    970a:	d003      	beq.n	9714 <at_uart_main_tx_uart_write_callback+0x18>
        assert(false);
    970c:	0021      	movs	r1, r4
    970e:	2016      	movs	r0, #22
    9710:	f7f8 f9fe 	bl	1b10 <panic>
}
    9714:	bd10      	pop	{r4, pc}
    9716:	46c0      	nop			; (mov r8, r8)
    9718:	010024b0 	.word	0x010024b0

0000971c <at_uart_flush_data>:
{
    971c:	b510      	push	{r4, lr}
    if( !at_uart_high_speed_enable )
    971e:	4b06      	ldr	r3, [pc, #24]	; (9738 <at_uart_flush_data+0x1c>)
    9720:	781b      	ldrb	r3, [r3, #0]
    9722:	2b00      	cmp	r3, #0
    9724:	d102      	bne.n	972c <at_uart_flush_data+0x10>
        return lp_uart_flush_data();
    9726:	f00e fc67 	bl	17ff8 <lp_uart_flush_data>
}
    972a:	bd10      	pop	{r4, pc}
        return uart_flush_data( at_uart_handler );
    972c:	4b03      	ldr	r3, [pc, #12]	; (973c <at_uart_flush_data+0x20>)
    972e:	7818      	ldrb	r0, [r3, #0]
    9730:	f00c fe2a 	bl	16388 <uart_flush_data>
    9734:	e7f9      	b.n	972a <at_uart_flush_data+0xe>
    9736:	46c0      	nop			; (mov r8, r8)
    9738:	010019b1 	.word	0x010019b1
    973c:	010019b0 	.word	0x010019b0

00009740 <at_uart_enable_software_flow_control.isra.2>:
        at_uart_config_status = AT_UART_CONFIG_STATUS_SWITCHED;
    }
    non_os_exit_critical();
}

static void at_uart_enable_software_flow_control( UART_BUS at_uart, const at_uart_config *uart_config )
    9740:	b570      	push	{r4, r5, r6, lr}
    9742:	000d      	movs	r5, r1
{
    bool enable_flow_control = (uart_config->sw_flow_control == AT_UART_FLOW_CONTROL_ENABLED) ? true : false;
    9744:	7809      	ldrb	r1, [r1, #0]
static void at_uart_enable_software_flow_control( UART_BUS at_uart, const at_uart_config *uart_config )
    9746:	0004      	movs	r4, r0
    bool enable_flow_control = (uart_config->sw_flow_control == AT_UART_FLOW_CONTROL_ENABLED) ? true : false;
    9748:	3901      	subs	r1, #1
    974a:	424b      	negs	r3, r1
    974c:	4159      	adcs	r1, r3
    uart_enable_software_flow_control( at_uart, enable_flow_control );
    974e:	b2c9      	uxtb	r1, r1
    9750:	f00c faca 	bl	15ce8 <uart_enable_software_flow_control>
    (void) uart_set_software_flow_control_water_margin( at_uart, AT_UART_HIGH_SPEED_LOWER_WATER_MARGIN, AT_UART_HIGH_SPEED_UPPER_WATER_MARGIN );
    9754:	22e0      	movs	r2, #224	; 0xe0
    9756:	2120      	movs	r1, #32
    9758:	0020      	movs	r0, r4
    975a:	f00c fae3 	bl	15d24 <uart_set_software_flow_control_water_margin>

    if( uart_config->sw_flow_control == AT_UART_FLOW_CONTROL_ENABLED )
    975e:	782b      	ldrb	r3, [r5, #0]
    9760:	2b01      	cmp	r3, #1
    9762:	d10b      	bne.n	977c <at_uart_enable_software_flow_control.isra.2+0x3c>
    {
        LP_UART_SOFTWARE_FLOW_CONTROL_CALLBACK rx_flow_ctrl_callback;
        LP_UART_SOFTWARE_FLOW_CONTROL_CALLBACK tx_flow_ctrl_callback;
        rx_flow_ctrl_callback = (LP_UART_SOFTWARE_FLOW_CONTROL_CALLBACK)uart_get_software_rx_flow_control_assert_function(at_uart);
    9764:	0020      	movs	r0, r4
    9766:	f00c fb07 	bl	15d78 <uart_get_software_rx_flow_control_assert_function>
    976a:	0005      	movs	r5, r0
        tx_flow_ctrl_callback = (LP_UART_SOFTWARE_FLOW_CONTROL_CALLBACK)uart_get_software_tx_flow_control_assert_function(at_uart);
    976c:	0020      	movs	r0, r4
    976e:	f00c fb13 	bl	15d98 <uart_get_software_tx_flow_control_assert_function>
    9772:	0001      	movs	r1, r0
        lp_uart_enable_software_flow_control( rx_flow_ctrl_callback, tx_flow_ctrl_callback );
    9774:	0028      	movs	r0, r5
    9776:	f00e fc25 	bl	17fc4 <lp_uart_enable_software_flow_control>
    }
    else
    {
        lp_uart_disable_software_flow_control();
    }
}
    977a:	bd70      	pop	{r4, r5, r6, pc}
        lp_uart_disable_software_flow_control();
    977c:	f00e fc32 	bl	17fe4 <lp_uart_disable_software_flow_control>
    9780:	e7fb      	b.n	977a <at_uart_enable_software_flow_control.isra.2+0x3a>
	...

00009784 <at_uart_frame_error_lp_uart_callback>:
    at_uart_buffer_frame_err_flag = status;
    9784:	2301      	movs	r3, #1
{
    9786:	b510      	push	{r4, lr}
    at_uart_buffer_frame_err_flag = status;
    9788:	4c08      	ldr	r4, [pc, #32]	; (97ac <at_uart_frame_error_lp_uart_callback+0x28>)
    978a:	7023      	strb	r3, [r4, #0]
    if (at_uart_received_size == 0)
    978c:	4b08      	ldr	r3, [pc, #32]	; (97b0 <at_uart_frame_error_lp_uart_callback+0x2c>)
    978e:	881b      	ldrh	r3, [r3, #0]
    9790:	2b00      	cmp	r3, #0
    9792:	d109      	bne.n	97a8 <at_uart_frame_error_lp_uart_callback+0x24>
        if (!at_uart_high_speed_enable)
    9794:	4b07      	ldr	r3, [pc, #28]	; (97b4 <at_uart_frame_error_lp_uart_callback+0x30>)
    9796:	781b      	ldrb	r3, [r3, #0]
    9798:	2b00      	cmp	r3, #0
    979a:	d103      	bne.n	97a4 <at_uart_frame_error_lp_uart_callback+0x20>
            if (lp_uart_get_fifo_level() == 0)
    979c:	f00e fc74 	bl	18088 <lp_uart_get_fifo_level>
    97a0:	2800      	cmp	r0, #0
    97a2:	d101      	bne.n	97a8 <at_uart_frame_error_lp_uart_callback+0x24>
    at_uart_buffer_frame_err_flag = status;
    97a4:	2300      	movs	r3, #0
    97a6:	7023      	strb	r3, [r4, #0]
}
    97a8:	bd10      	pop	{r4, pc}
    97aa:	46c0      	nop			; (mov r8, r8)
    97ac:	010019a7 	.word	0x010019a7
    97b0:	010024a0 	.word	0x010024a0
    97b4:	010019b1 	.word	0x010019b1

000097b8 <at_uart_mark_can_receive>:
{
    97b8:	b510      	push	{r4, lr}
    non_os_enter_critical();
    97ba:	f00e fcfb 	bl	181b4 <non_os_enter_critical>
    at_uart_received_size = 0;
    97be:	2300      	movs	r3, #0
    97c0:	4a03      	ldr	r2, [pc, #12]	; (97d0 <at_uart_mark_can_receive+0x18>)
    97c2:	8013      	strh	r3, [r2, #0]
    at_uart_receive_status = AT_UART_STATUS_FREE;
    97c4:	4a03      	ldr	r2, [pc, #12]	; (97d4 <at_uart_mark_can_receive+0x1c>)
    97c6:	7013      	strb	r3, [r2, #0]
    non_os_exit_critical();
    97c8:	f00e fd08 	bl	181dc <non_os_exit_critical>
}
    97cc:	bd10      	pop	{r4, pc}
    97ce:	46c0      	nop			; (mov r8, r8)
    97d0:	010024a0 	.word	0x010024a0
    97d4:	010019d0 	.word	0x010019d0

000097d8 <at_uart_configure.constprop.6>:

static void at_uart_configure(const at_uart_config * uart_config, const uart_pin_configuration * uart_pins)
    97d8:	4673      	mov	r3, lr
    uart_line_config.baud_rate = uart_config->baudrate;
    uart_line_config.data_bits = TX_UART_DATA_BITS;                                 // Why is this hardcoded, but all the rest isn't?
    uart_line_config.parity = (UART_PARITY)uart_config->parity;
    uart_line_config.stop_bits = (UART_STOP_BITS)(uart_config->stopbits - 1); //-1 to match with UART_STOP_BIT

    if (uart_config->baudrate <= AT_UART_BAUD_RATE_57600)
    97da:	20e1      	movs	r0, #225	; 0xe1
static void at_uart_configure(const at_uart_config * uart_config, const uart_pin_configuration * uart_pins)
    97dc:	b5f0      	push	{r4, r5, r6, r7, lr}
    uart_line_config.baud_rate = uart_config->baudrate;
    97de:	4c3f      	ldr	r4, [pc, #252]	; (98dc <at_uart_configure.constprop.6+0x104>)
static void at_uart_configure(const at_uart_config * uart_config, const uart_pin_configuration * uart_pins)
    97e0:	b089      	sub	sp, #36	; 0x24
    97e2:	9301      	str	r3, [sp, #4]
    uart_line_config.baud_rate = uart_config->baudrate;
    97e4:	6823      	ldr	r3, [r4, #0]
    if (uart_config->baudrate <= AT_UART_BAUD_RATE_57600)
    97e6:	0200      	lsls	r0, r0, #8
    uart_line_config.baud_rate = uart_config->baudrate;
    97e8:	9306      	str	r3, [sp, #24]
    uart_line_config.data_bits = TX_UART_DATA_BITS;                                 // Why is this hardcoded, but all the rest isn't?
    97ea:	2303      	movs	r3, #3
    if (uart_config->baudrate <= AT_UART_BAUD_RATE_57600)
    97ec:	4684      	mov	ip, r0
    uart_line_config.baud_rate = uart_config->baudrate;
    97ee:	af06      	add	r7, sp, #24
    uart_line_config.data_bits = TX_UART_DATA_BITS;                                 // Why is this hardcoded, but all the rest isn't?
    97f0:	713b      	strb	r3, [r7, #4]
    uart_line_config.parity = (UART_PARITY)uart_config->parity;
    97f2:	79a3      	ldrb	r3, [r4, #6]
    if (uart_config->baudrate <= AT_UART_BAUD_RATE_57600)
    97f4:	6820      	ldr	r0, [r4, #0]
    uart_line_config.parity = (UART_PARITY)uart_config->parity;
    97f6:	717b      	strb	r3, [r7, #5]
    uart_line_config.stop_bits = (UART_STOP_BITS)(uart_config->stopbits - 1); //-1 to match with UART_STOP_BIT
    97f8:	7963      	ldrb	r3, [r4, #5]
    97fa:	ad05      	add	r5, sp, #20
    97fc:	3b01      	subs	r3, #1
    97fe:	71bb      	strb	r3, [r7, #6]
    9800:	4b37      	ldr	r3, [pc, #220]	; (98e0 <at_uart_configure.constprop.6+0x108>)
    9802:	781e      	ldrb	r6, [r3, #0]
    9804:	7859      	ldrb	r1, [r3, #1]
    9806:	789a      	ldrb	r2, [r3, #2]
    9808:	78db      	ldrb	r3, [r3, #3]
    if (uart_config->baudrate <= AT_UART_BAUD_RATE_57600)
    980a:	4560      	cmp	r0, ip
    980c:	d848      	bhi.n	98a0 <at_uart_configure.constprop.6+0xc8>
    {
        /* Using LP UART for RX and HP UART for TX. */
        lp_uart_pin_config.rx_pin = uart_pins->rx_pin;
    980e:	a803      	add	r0, sp, #12
        lp_uart_pin_config.rts_pin = uart_pins->rts_pin;
    9810:	7043      	strb	r3, [r0, #1]

        hp_uart_pin_config.tx_pin = uart_pins->tx_pin;
        hp_uart_pin_config.rx_pin = PIN_NONE;
    9812:	2328      	movs	r3, #40	; 0x28
        hp_uart_pin_config.tx_pin = uart_pins->tx_pin;
    9814:	702e      	strb	r6, [r5, #0]
        hp_uart_pin_config.cts_pin = uart_pins->cts_pin;
        hp_uart_pin_config.rts_pin = PIN_NONE;

        hp_uart_buffer_config_ptr = NULL;

        at_uart_high_speed_enable = false;
    9816:	2600      	movs	r6, #0
        hp_uart_pin_config.rx_pin = PIN_NONE;
    9818:	706b      	strb	r3, [r5, #1]
        hp_uart_pin_config.rts_pin = PIN_NONE;
    981a:	70eb      	strb	r3, [r5, #3]
        at_uart_high_speed_enable = false;
    981c:	4b31      	ldr	r3, [pc, #196]	; (98e4 <at_uart_configure.constprop.6+0x10c>)
        lp_uart_pin_config.rx_pin = uart_pins->rx_pin;
    981e:	7001      	strb	r1, [r0, #0]
        hp_uart_pin_config.cts_pin = uart_pins->cts_pin;
    9820:	70aa      	strb	r2, [r5, #2]
        at_uart_high_speed_enable = false;
    9822:	701e      	strb	r6, [r3, #0]
        at_uart_high_speed_enable = true;
    }


    // disable interrupts while the modules are configured
    non_os_enter_critical();
    9824:	f00e fcc6 	bl	181b4 <non_os_enter_critical>

    /* Configure HP UART. Always used, for at least TX. */
    at_uart_handler = uart_claim( &hp_uart_pin_config );
    9828:	0028      	movs	r0, r5
    982a:	f00b ff83 	bl	15734 <uart_claim>
    982e:	4d2e      	ldr	r5, [pc, #184]	; (98e8 <at_uart_configure.constprop.6+0x110>)
    uart_opened = uart_open ( at_uart_handler, &uart_line_config, hp_uart_buffer_config_ptr, NULL );
    9830:	2300      	movs	r3, #0
    9832:	0032      	movs	r2, r6
    9834:	0039      	movs	r1, r7
    at_uart_handler = uart_claim( &hp_uart_pin_config );
    9836:	7028      	strb	r0, [r5, #0]
    uart_opened = uart_open ( at_uart_handler, &uart_line_config, hp_uart_buffer_config_ptr, NULL );
    9838:	f00c f8aa 	bl	15990 <uart_open>
    assert( uart_opened );
    983c:	2800      	cmp	r0, #0
    983e:	d103      	bne.n	9848 <at_uart_configure.constprop.6+0x70>
    9840:	9901      	ldr	r1, [sp, #4]
    9842:	3016      	adds	r0, #22
    9844:	f7f8 f964 	bl	1b10 <panic>

    if (!at_uart_high_speed_enable)
    9848:	4b26      	ldr	r3, [pc, #152]	; (98e4 <at_uart_configure.constprop.6+0x10c>)
    984a:	4e28      	ldr	r6, [pc, #160]	; (98ec <at_uart_configure.constprop.6+0x114>)
    984c:	781f      	ldrb	r7, [r3, #0]
    984e:	2f00      	cmp	r7, #0
    9850:	d132      	bne.n	98b8 <at_uart_configure.constprop.6+0xe0>
    {
        /* Configure LP UART for RX */
        (void)lp_uart_init ( &lp_uart_pin_config, uart_config->baudrate, uart_config->syncmode, uart_config->parity);   //lint !e645   Lint incorrectly claiming lp_uart_pin_config isn't initialised.
    9852:	79a3      	ldrb	r3, [r4, #6]
    9854:	7922      	ldrb	r2, [r4, #4]
    9856:	6821      	ldr	r1, [r4, #0]
    9858:	a803      	add	r0, sp, #12
    985a:	f00e faf9 	bl	17e50 <lp_uart_init>

        // Enable interrupt and callback for received data bytes
        lp_uart_enable_irq ( LP_UART_INTERRUPT_SUCCESSFUL_WORD );
    985e:	2003      	movs	r0, #3
    9860:	f00e fc16 	bl	18090 <lp_uart_enable_irq>
        lp_uart_set_callback ( LP_UART_INTERRUPT_SUCCESSFUL_WORD, at_uart_main_lp_uart_callback );
    9864:	4922      	ldr	r1, [pc, #136]	; (98f0 <at_uart_configure.constprop.6+0x118>)
    9866:	2003      	movs	r0, #3
    9868:	f00e fc7c 	bl	18164 <lp_uart_set_callback>

        // Enable interrupt for parity and frame errors, so that they are tracked by the LP UART driver
        lp_uart_enable_irq ( LP_UART_INTERRUPT_PARITY_ERROR );
    986c:	2001      	movs	r0, #1
    986e:	f00e fc0f 	bl	18090 <lp_uart_enable_irq>
        lp_uart_enable_irq ( LP_UART_INTERRUPT_FRAME_ERROR );
    9872:	2002      	movs	r0, #2
    9874:	f00e fc0c 	bl	18090 <lp_uart_enable_irq>
        lp_uart_set_callback ( LP_UART_INTERRUPT_FRAME_ERROR, at_uart_frame_error_lp_uart_callback );
    9878:	491e      	ldr	r1, [pc, #120]	; (98f4 <at_uart_configure.constprop.6+0x11c>)
    987a:	2002      	movs	r0, #2
    987c:	f00e fc72 	bl	18164 <lp_uart_set_callback>

        at_uart_enable_software_flow_control( at_uart_handler, uart_config );
    9880:	1de1      	adds	r1, r4, #7
    9882:	7828      	ldrb	r0, [r5, #0]
    9884:	f7ff ff5c 	bl	9740 <at_uart_enable_software_flow_control.isra.2>
    if (at_uart_stop_sleep_vote_flag)
    9888:	7833      	ldrb	r3, [r6, #0]
    988a:	2b00      	cmp	r3, #0
    988c:	d002      	beq.n	9894 <at_uart_configure.constprop.6+0xbc>
        at_uart_stop_sleep_vote_flag = false;
    988e:	7037      	strb	r7, [r6, #0]
        osRemoveStopClocksVeto();
    9890:	f00b f9bc 	bl	14c0c <osRemoveStopClocksVeto>

        at_uart_disable_deep_sleep();
    }

    // RX configuration
    at_uart_mark_can_receive();
    9894:	f7ff ff90 	bl	97b8 <at_uart_mark_can_receive>

    non_os_exit_critical(); // enable interrupts again
    9898:	f00e fca0 	bl	181dc <non_os_exit_critical>

}
    989c:	b009      	add	sp, #36	; 0x24
    989e:	bdf0      	pop	{r4, r5, r6, r7, pc}
        hp_uart_pin_config.rts_pin = uart_pins->rts_pin;
    98a0:	70eb      	strb	r3, [r5, #3]
        hp_uart_buffer_config.rx_buffer_size = AT_UART_HIGH_SPEED_RX_BUFFER_SIZE;
    98a2:	2380      	movs	r3, #128	; 0x80
        hp_uart_pin_config.cts_pin = uart_pins->cts_pin;
    98a4:	70aa      	strb	r2, [r5, #2]
        at_uart_high_speed_enable = true;
    98a6:	2201      	movs	r2, #1
        hp_uart_buffer_config.rx_buffer_size = AT_UART_HIGH_SPEED_RX_BUFFER_SIZE;
    98a8:	005b      	lsls	r3, r3, #1
        hp_uart_pin_config.tx_pin = uart_pins->tx_pin;
    98aa:	702e      	strb	r6, [r5, #0]
        hp_uart_buffer_config.rx_buffer_size = AT_UART_HIGH_SPEED_RX_BUFFER_SIZE;
    98ac:	ae04      	add	r6, sp, #16
    98ae:	8033      	strh	r3, [r6, #0]
        at_uart_high_speed_enable = true;
    98b0:	4b0c      	ldr	r3, [pc, #48]	; (98e4 <at_uart_configure.constprop.6+0x10c>)
        hp_uart_pin_config.rx_pin = uart_pins->rx_pin;
    98b2:	7069      	strb	r1, [r5, #1]
        at_uart_high_speed_enable = true;
    98b4:	701a      	strb	r2, [r3, #0]
    98b6:	e7b5      	b.n	9824 <at_uart_configure.constprop.6+0x4c>
        uart_register_rx_callback(at_uart_handler, UART_RX_CONDITION_FULL_OR_SUFFICIENT_DATA_OR_IDLE, AT_UART_HIGH_SPEED_NOTIFICATION_SIZE, at_uart_main_normal_uart_callback);
    98b8:	4b0f      	ldr	r3, [pc, #60]	; (98f8 <at_uart_configure.constprop.6+0x120>)
    98ba:	7828      	ldrb	r0, [r5, #0]
    98bc:	2220      	movs	r2, #32
    98be:	2107      	movs	r1, #7
    98c0:	f00c faa2 	bl	15e08 <uart_register_rx_callback>
        at_uart_enable_software_flow_control( at_uart_handler, uart_config );
    98c4:	1de1      	adds	r1, r4, #7
    98c6:	7828      	ldrb	r0, [r5, #0]
    98c8:	f7ff ff3a 	bl	9740 <at_uart_enable_software_flow_control.isra.2>
    if (!at_uart_stop_sleep_vote_flag)
    98cc:	7833      	ldrb	r3, [r6, #0]
    98ce:	2b00      	cmp	r3, #0
    98d0:	d1e0      	bne.n	9894 <at_uart_configure.constprop.6+0xbc>
        at_uart_stop_sleep_vote_flag = true;
    98d2:	3301      	adds	r3, #1
    98d4:	7033      	strb	r3, [r6, #0]
        osAddStopClocksVeto();
    98d6:	f00b f995 	bl	14c04 <osAddStopClocksVeto>
    98da:	e7db      	b.n	9894 <at_uart_configure.constprop.6+0xbc>
    98dc:	010019c0 	.word	0x010019c0
    98e0:	010019c8 	.word	0x010019c8
    98e4:	010019b1 	.word	0x010019b1
    98e8:	010019b0 	.word	0x010019b0
    98ec:	010024a8 	.word	0x010024a8
    98f0:	000096f5 	.word	0x000096f5
    98f4:	00009785 	.word	0x00009785
    98f8:	000096ed 	.word	0x000096ed

000098fc <at_uart_reinit>:

static void at_uart_reinit(bool reset_state)
{
    98fc:	b570      	push	{r4, r5, r6, lr}

    // Do the following lines really need protecting?
    non_os_enter_critical();

    // RX configuration
    at_uart_quick_search_index = 0;
    98fe:	2400      	movs	r4, #0
{
    9900:	0005      	movs	r5, r0
    at_uart_configure(&at_uart_new_config, &at_uart_pin_config);
    9902:	f7ff ff69 	bl	97d8 <at_uart_configure.constprop.6>
    non_os_enter_critical();
    9906:	f00e fc55 	bl	181b4 <non_os_enter_critical>
    at_uart_quick_search_index = 0;
    990a:	4b08      	ldr	r3, [pc, #32]	; (992c <at_uart_reinit+0x30>)
    990c:	601c      	str	r4, [r3, #0]
    at_uart_recv_at_cmd_header_flag = false;
    990e:	4b08      	ldr	r3, [pc, #32]	; (9930 <at_uart_reinit+0x34>)
    9910:	701c      	strb	r4, [r3, #0]
    at_uart_buffer_err_flag = false;
    9912:	4b08      	ldr	r3, [pc, #32]	; (9934 <at_uart_reinit+0x38>)
    9914:	701c      	strb	r4, [r3, #0]
    at_uart_buffer_parity_err_flag = false;
    9916:	4b08      	ldr	r3, [pc, #32]	; (9938 <at_uart_reinit+0x3c>)
    9918:	701c      	strb	r4, [r3, #0]
    at_uart_mark_can_receive();
    991a:	f7ff ff4d 	bl	97b8 <at_uart_mark_can_receive>

    if (reset_state)
    991e:	42a5      	cmp	r5, r4
    9920:	d001      	beq.n	9926 <at_uart_reinit+0x2a>
    {
        at_uart_config_status = AT_UART_CONFIG_STATUS_NORMAL;
    9922:	4b06      	ldr	r3, [pc, #24]	; (993c <at_uart_reinit+0x40>)
    9924:	701c      	strb	r4, [r3, #0]
    }
    non_os_exit_critical();
    9926:	f00e fc59 	bl	181dc <non_os_exit_critical>
}
    992a:	bd70      	pop	{r4, r5, r6, pc}
    992c:	010019cc 	.word	0x010019cc
    9930:	010024a2 	.word	0x010024a2
    9934:	010019a6 	.word	0x010019a6
    9938:	010019a8 	.word	0x010019a8
    993c:	010019a9 	.word	0x010019a9

00009940 <at_uart_get_status>:
    return at_uart_receive_status;
    9940:	4b01      	ldr	r3, [pc, #4]	; (9948 <at_uart_get_status+0x8>)
    9942:	7818      	ldrb	r0, [r3, #0]
}
    9944:	4770      	bx	lr
    9946:	46c0      	nop			; (mov r8, r8)
    9948:	010019d0 	.word	0x010019d0

0000994c <at_uart_get_receive_buffer>:
}
    994c:	4800      	ldr	r0, [pc, #0]	; (9950 <at_uart_get_receive_buffer+0x4>)
    994e:	4770      	bx	lr
    9950:	010019d1 	.word	0x010019d1

00009954 <at_uart_get_parity_error_status>:
    return at_uart_buffer_parity_err_flag;
    9954:	4b01      	ldr	r3, [pc, #4]	; (995c <at_uart_get_parity_error_status+0x8>)
    9956:	7818      	ldrb	r0, [r3, #0]
}
    9958:	4770      	bx	lr
    995a:	46c0      	nop			; (mov r8, r8)
    995c:	010019a8 	.word	0x010019a8

00009960 <at_uart_get_frame_error_status>:
    return at_uart_buffer_frame_err_flag;
    9960:	4b01      	ldr	r3, [pc, #4]	; (9968 <at_uart_get_frame_error_status+0x8>)
    9962:	7818      	ldrb	r0, [r3, #0]
}
    9964:	4770      	bx	lr
    9966:	46c0      	nop			; (mov r8, r8)
    9968:	010019a7 	.word	0x010019a7

0000996c <at_uart_set_parity_error_status>:
    at_uart_buffer_parity_err_flag = status;
    996c:	4b01      	ldr	r3, [pc, #4]	; (9974 <at_uart_set_parity_error_status+0x8>)
    996e:	7018      	strb	r0, [r3, #0]
}
    9970:	4770      	bx	lr
    9972:	46c0      	nop			; (mov r8, r8)
    9974:	010019a8 	.word	0x010019a8

00009978 <at_uart_get_buffer_error_status>:
    return at_uart_buffer_err_flag;
    9978:	4b01      	ldr	r3, [pc, #4]	; (9980 <at_uart_get_buffer_error_status+0x8>)
    997a:	7818      	ldrb	r0, [r3, #0]
}
    997c:	4770      	bx	lr
    997e:	46c0      	nop			; (mov r8, r8)
    9980:	010019a6 	.word	0x010019a6

00009984 <at_uart_set_buffer_error_status>:
    at_uart_buffer_err_flag = status;
    9984:	4b01      	ldr	r3, [pc, #4]	; (998c <at_uart_set_buffer_error_status+0x8>)
    9986:	7018      	strb	r0, [r3, #0]
}
    9988:	4770      	bx	lr
    998a:	46c0      	nop			; (mov r8, r8)
    998c:	010019a6 	.word	0x010019a6

00009990 <at_uart_set_frame_error_status>:
    at_uart_buffer_frame_err_flag = status;
    9990:	4b01      	ldr	r3, [pc, #4]	; (9998 <at_uart_set_frame_error_status+0x8>)
    9992:	7018      	strb	r0, [r3, #0]
}
    9994:	4770      	bx	lr
    9996:	46c0      	nop			; (mov r8, r8)
    9998:	010019a7 	.word	0x010019a7

0000999c <at_uart_set_received_at_notify_callback>:
    at_uart_received_at_notify_callback = callback;
    999c:	4b01      	ldr	r3, [pc, #4]	; (99a4 <at_uart_set_received_at_notify_callback+0x8>)
    999e:	6018      	str	r0, [r3, #0]
}
    99a0:	4770      	bx	lr
    99a2:	46c0      	nop			; (mov r8, r8)
    99a4:	0100249c 	.word	0x0100249c

000099a8 <at_uart_claim>:
{
    99a8:	b510      	push	{r4, lr}
    if (at_uart_mutex != NULL)
    99aa:	4b07      	ldr	r3, [pc, #28]	; (99c8 <at_uart_claim+0x20>)
    99ac:	6818      	ldr	r0, [r3, #0]
    99ae:	2800      	cmp	r0, #0
    99b0:	d009      	beq.n	99c6 <at_uart_claim+0x1e>
        if(osMutexAcquire(at_uart_mutex, osWaitForever) != osOK)
    99b2:	2101      	movs	r1, #1
    99b4:	4249      	negs	r1, r1
    99b6:	f00a fff5 	bl	149a4 <osMutexAcquire>
    99ba:	2800      	cmp	r0, #0
    99bc:	d003      	beq.n	99c6 <at_uart_claim+0x1e>
            panic(PANIC_AT_CMD, APP_AT_PANIC_MUTEX_NOT_READY);
    99be:	2100      	movs	r1, #0
    99c0:	2002      	movs	r0, #2
    99c2:	f7f8 f8a5 	bl	1b10 <panic>
} //lint !e454 !e456 Semaphore not taken if error code returned, but Lint doesn't know that.
    99c6:	bd10      	pop	{r4, pc}
    99c8:	010019bc 	.word	0x010019bc

000099cc <at_uart_release>:
{
    99cc:	b510      	push	{r4, lr}
    if (at_uart_mutex != NULL)
    99ce:	4b06      	ldr	r3, [pc, #24]	; (99e8 <at_uart_release+0x1c>)
    99d0:	6818      	ldr	r0, [r3, #0]
    99d2:	2800      	cmp	r0, #0
    99d4:	d007      	beq.n	99e6 <at_uart_release+0x1a>
        if (osMutexRelease(at_uart_mutex) != osOK)//lint !e455
    99d6:	f00b f809 	bl	149ec <osMutexRelease>
    99da:	2800      	cmp	r0, #0
    99dc:	d003      	beq.n	99e6 <at_uart_release+0x1a>
          panic(PANIC_AT_CMD, APP_AT_PANIC_MUTEX_NOT_READY);
    99de:	2100      	movs	r1, #0
    99e0:	2002      	movs	r0, #2
    99e2:	f7f8 f895 	bl	1b10 <panic>
}
    99e6:	bd10      	pop	{r4, pc}
    99e8:	010019bc 	.word	0x010019bc

000099ec <at_uart_write>:
{
    99ec:	b573      	push	{r0, r1, r4, r5, r6, lr}
    99ee:	0005      	movs	r5, r0
    99f0:	000e      	movs	r6, r1
    if ((buffer == NULL) || (length == 0))
    99f2:	2800      	cmp	r0, #0
    99f4:	d001      	beq.n	99fa <at_uart_write+0xe>
    99f6:	2900      	cmp	r1, #0
    99f8:	d107      	bne.n	9a0a <at_uart_write+0x1e>
}//lint !e456
    99fa:	bd73      	pop	{r0, r1, r4, r5, r6, pc}
        if (osKernelGetState() == osKernelRunning)
    99fc:	f00a fe6a 	bl	146d4 <osKernelGetState>
    9a00:	2802      	cmp	r0, #2
    9a02:	d102      	bne.n	9a0a <at_uart_write+0x1e>
            (void)osDelay(AT_UART_DELAY_ON_UART_BUSY);
    9a04:	3801      	subs	r0, #1
    9a06:	f00a ff30 	bl	1486a <osDelay>
    while ( !uart_write(at_uart_handler, buffer, (uint16)length, NULL, at_uart_main_tx_uart_write_callback) )
    9a0a:	4b11      	ldr	r3, [pc, #68]	; (9a50 <at_uart_write+0x64>)
    9a0c:	4c11      	ldr	r4, [pc, #68]	; (9a54 <at_uart_write+0x68>)
    9a0e:	b2b2      	uxth	r2, r6
    9a10:	7820      	ldrb	r0, [r4, #0]
    9a12:	0029      	movs	r1, r5
    9a14:	9300      	str	r3, [sp, #0]
    9a16:	2300      	movs	r3, #0
    9a18:	f00c fb0e 	bl	16038 <uart_write>
    9a1c:	2800      	cmp	r0, #0
    9a1e:	d0ed      	beq.n	99fc <at_uart_write+0x10>
    if (osKernelGetState() == osKernelRunning)
    9a20:	f00a fe58 	bl	146d4 <osKernelGetState>
    9a24:	0005      	movs	r5, r0
    9a26:	2802      	cmp	r0, #2
    9a28:	d10c      	bne.n	9a44 <at_uart_write+0x58>
        if(osSemaphoreAcquire(at_uart_tx_data, osWaitForever) != osOK)
    9a2a:	2101      	movs	r1, #1
    9a2c:	4b0a      	ldr	r3, [pc, #40]	; (9a58 <at_uart_write+0x6c>)
    9a2e:	4249      	negs	r1, r1
    9a30:	6818      	ldr	r0, [r3, #0]
    9a32:	f00b f823 	bl	14a7c <osSemaphoreAcquire>
    9a36:	2800      	cmp	r0, #0
    9a38:	d0df      	beq.n	99fa <at_uart_write+0xe>
            panic(PANIC_AT_CMD, APP_AT_PANIC_MUTEX_NOT_READY); //lint !e454 !e456
    9a3a:	2100      	movs	r1, #0
    9a3c:	0028      	movs	r0, r5
    9a3e:	f7f8 f867 	bl	1b10 <panic>
    9a42:	e7da      	b.n	99fa <at_uart_write+0xe>
        while( uart_has_pending_transmissions(at_uart_handler) )
    9a44:	7820      	ldrb	r0, [r4, #0]
    9a46:	f00c f9b7 	bl	15db8 <uart_has_pending_transmissions>
    9a4a:	2800      	cmp	r0, #0
    9a4c:	d1fa      	bne.n	9a44 <at_uart_write+0x58>
    9a4e:	e7d4      	b.n	99fa <at_uart_write+0xe>
    9a50:	000096fd 	.word	0x000096fd
    9a54:	010019b0 	.word	0x010019b0
    9a58:	010024b0 	.word	0x010024b0

00009a5c <at_uart_create_queue>:
{
    9a5c:	b510      	push	{r4, lr}
    at_uart_recv_queue = osMessageQueueNew( AT_UART_RECV_QUEUE_SIZE, sizeof(uint32), NULL );
    9a5e:	2200      	movs	r2, #0
    9a60:	2104      	movs	r1, #4
    9a62:	2001      	movs	r0, #1
    9a64:	4674      	mov	r4, lr
    9a66:	f00b f849 	bl	14afc <osMessageQueueNew>
    9a6a:	4b04      	ldr	r3, [pc, #16]	; (9a7c <at_uart_create_queue+0x20>)
    9a6c:	6018      	str	r0, [r3, #0]
    assert( at_uart_recv_queue != NULL );
    9a6e:	2800      	cmp	r0, #0
    9a70:	d103      	bne.n	9a7a <at_uart_create_queue+0x1e>
    9a72:	0021      	movs	r1, r4
    9a74:	3016      	adds	r0, #22
    9a76:	f7f8 f84b 	bl	1b10 <panic>
}
    9a7a:	bd10      	pop	{r4, pc}
    9a7c:	010024a4 	.word	0x010024a4

00009a80 <at_uart_recv_process>:
{
    9a80:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
        if( osMessageQueueGet(at_uart_recv_queue, (void *)&unused, NULL, osWaitForever) == osOK )
    9a82:	2301      	movs	r3, #1
    9a84:	4873      	ldr	r0, [pc, #460]	; (9c54 <at_uart_recv_process+0x1d4>)
    9a86:	425b      	negs	r3, r3
    9a88:	2200      	movs	r2, #0
    9a8a:	a901      	add	r1, sp, #4
    9a8c:	6800      	ldr	r0, [r0, #0]
    9a8e:	f00b f883 	bl	14b98 <osMessageQueueGet>
    9a92:	1e05      	subs	r5, r0, #0
    9a94:	d1f5      	bne.n	9a82 <at_uart_recv_process+0x2>
    UART_ERROR uart_errors = UART_ERROR_NONE;
    9a96:	466b      	mov	r3, sp
    if (at_uart_received_size >= AT_UART_RECEIVE_BUFFER_SIZE)
    9a98:	4c6f      	ldr	r4, [pc, #444]	; (9c58 <at_uart_recv_process+0x1d8>)
    UART_ERROR uart_errors = UART_ERROR_NONE;
    9a9a:	1cde      	adds	r6, r3, #3
    if (at_uart_received_size >= AT_UART_RECEIVE_BUFFER_SIZE)
    9a9c:	4a6f      	ldr	r2, [pc, #444]	; (9c5c <at_uart_recv_process+0x1dc>)
    9a9e:	8823      	ldrh	r3, [r4, #0]
    UART_ERROR uart_errors = UART_ERROR_NONE;
    9aa0:	7030      	strb	r0, [r6, #0]
    if (at_uart_received_size >= AT_UART_RECEIVE_BUFFER_SIZE)
    9aa2:	4293      	cmp	r3, r2
    9aa4:	d907      	bls.n	9ab6 <at_uart_recv_process+0x36>
        (void)at_uart_flush_data();
    9aa6:	f7ff fe39 	bl	971c <at_uart_flush_data>
        at_uart_recv_at_cmd_header_flag = false;
    9aaa:	4b6d      	ldr	r3, [pc, #436]	; (9c60 <at_uart_recv_process+0x1e0>)
        at_uart_received_size = 0;
    9aac:	8025      	strh	r5, [r4, #0]
        at_uart_recv_at_cmd_header_flag = false;
    9aae:	701d      	strb	r5, [r3, #0]
        at_uart_quick_search_index = 0;
    9ab0:	4b6c      	ldr	r3, [pc, #432]	; (9c64 <at_uart_recv_process+0x1e4>)
    9ab2:	601d      	str	r5, [r3, #0]
    9ab4:	e7e5      	b.n	9a82 <at_uart_recv_process+0x2>
    if (at_uart_receive_status != AT_UART_STATUS_FREE)
    9ab6:	4b6c      	ldr	r3, [pc, #432]	; (9c68 <at_uart_recv_process+0x1e8>)
    9ab8:	781b      	ldrb	r3, [r3, #0]
    9aba:	2b00      	cmp	r3, #0
    9abc:	d002      	beq.n	9ac4 <at_uart_recv_process+0x44>
        (void)at_uart_flush_data();
    9abe:	f7ff fe2d 	bl	971c <at_uart_flush_data>
    9ac2:	e7de      	b.n	9a82 <at_uart_recv_process+0x2>
    if( get_at_cmd_in_progress() && get_at_processing_cmd_abortable() && (!get_at_blocking_at_command_protected()) )
    9ac4:	f7fe fcee 	bl	84a4 <get_at_cmd_in_progress>
    9ac8:	4f68      	ldr	r7, [pc, #416]	; (9c6c <at_uart_recv_process+0x1ec>)
    9aca:	2800      	cmp	r0, #0
    9acc:	d017      	beq.n	9afe <at_uart_recv_process+0x7e>
    9ace:	f7fe fcef 	bl	84b0 <get_at_processing_cmd_abortable>
    9ad2:	2800      	cmp	r0, #0
    9ad4:	d013      	beq.n	9afe <at_uart_recv_process+0x7e>
    9ad6:	f7fe fcf1 	bl	84bc <get_at_blocking_at_command_protected>
    9ada:	1e05      	subs	r5, r0, #0
    9adc:	d10f      	bne.n	9afe <at_uart_recv_process+0x7e>
        if( at_uart_flush_data() > 0 )
    9ade:	f7ff fe1d 	bl	971c <at_uart_flush_data>
    9ae2:	2800      	cmp	r0, #0
    9ae4:	d00b      	beq.n	9afe <at_uart_recv_process+0x7e>
    at_uart_receive_status = AT_UART_STATUS_IN_PROCESS;
    9ae6:	2201      	movs	r2, #1
    at_uart_recv_at_cmd_header_flag = false;
    9ae8:	4b5d      	ldr	r3, [pc, #372]	; (9c60 <at_uart_recv_process+0x1e0>)
    at_uart_receive_uart_buffer[0] = '\0';
    9aea:	703d      	strb	r5, [r7, #0]
    at_uart_recv_at_cmd_header_flag = false;
    9aec:	701d      	strb	r5, [r3, #0]
    at_uart_quick_search_index = 0;
    9aee:	4b5d      	ldr	r3, [pc, #372]	; (9c64 <at_uart_recv_process+0x1e4>)
    at_uart_received_size = 0;
    9af0:	8025      	strh	r5, [r4, #0]
    at_uart_quick_search_index = 0;
    9af2:	601d      	str	r5, [r3, #0]
    at_uart_receive_status = AT_UART_STATUS_IN_PROCESS;
    9af4:	4b5c      	ldr	r3, [pc, #368]	; (9c68 <at_uart_recv_process+0x1e8>)
    9af6:	701a      	strb	r2, [r3, #0]
    at_uart_trigger_received_at_notify_callback();
    9af8:	f7ff fde2 	bl	96c0 <at_uart_trigger_received_at_notify_callback>
    9afc:	e7c1      	b.n	9a82 <at_uart_recv_process+0x2>
    received_count = at_uart_get_data( at_uart_receive_uart_buffer + at_uart_received_size, AT_UART_RECEIVE_BUFFER_SIZE - at_uart_received_size, &uart_errors );
    9afe:	8823      	ldrh	r3, [r4, #0]
    9b00:	495b      	ldr	r1, [pc, #364]	; (9c70 <at_uart_recv_process+0x1f0>)
    9b02:	18f8      	adds	r0, r7, r3
    9b04:	1ac9      	subs	r1, r1, r3
    if( !at_uart_high_speed_enable )
    9b06:	4b5b      	ldr	r3, [pc, #364]	; (9c74 <at_uart_recv_process+0x1f4>)
    received_count = at_uart_get_data( at_uart_receive_uart_buffer + at_uart_received_size, AT_UART_RECEIVE_BUFFER_SIZE - at_uart_received_size, &uart_errors );
    9b08:	b289      	uxth	r1, r1
    if( !at_uart_high_speed_enable )
    9b0a:	781b      	ldrb	r3, [r3, #0]
    9b0c:	2b00      	cmp	r3, #0
    9b0e:	d12c      	bne.n	9b6a <at_uart_recv_process+0xea>
        return lp_uart_get_data( buffer, buffer_size, uart_errors );
    9b10:	0032      	movs	r2, r6
    9b12:	f00e fa85 	bl	18020 <lp_uart_get_data>
    if( uart_errors & UART_ERROR_FRAME )
    9b16:	2101      	movs	r1, #1
    9b18:	7833      	ldrb	r3, [r6, #0]
    9b1a:	420b      	tst	r3, r1
    9b1c:	d001      	beq.n	9b22 <at_uart_recv_process+0xa2>
        at_uart_buffer_frame_err_flag = true;
    9b1e:	4a56      	ldr	r2, [pc, #344]	; (9c78 <at_uart_recv_process+0x1f8>)
    9b20:	7011      	strb	r1, [r2, #0]
    if( uart_errors & UART_ERROR_PARITY )
    9b22:	079a      	lsls	r2, r3, #30
    9b24:	d502      	bpl.n	9b2c <at_uart_recv_process+0xac>
        at_uart_buffer_parity_err_flag = true;
    9b26:	2101      	movs	r1, #1
    9b28:	4a54      	ldr	r2, [pc, #336]	; (9c7c <at_uart_recv_process+0x1fc>)
    9b2a:	7011      	strb	r1, [r2, #0]
    9b2c:	4a54      	ldr	r2, [pc, #336]	; (9c80 <at_uart_recv_process+0x200>)
    if( uart_errors & UART_ERROR_OVERRUN )
    9b2e:	071b      	lsls	r3, r3, #28
    9b30:	d501      	bpl.n	9b36 <at_uart_recv_process+0xb6>
        at_uart_buffer_err_flag = true;
    9b32:	2301      	movs	r3, #1
    9b34:	7013      	strb	r3, [r2, #0]
    if (at_uart_buffer_err_flag || at_uart_buffer_parity_err_flag || at_uart_buffer_frame_err_flag)
    9b36:	7813      	ldrb	r3, [r2, #0]
    9b38:	2b00      	cmp	r3, #0
    9b3a:	d107      	bne.n	9b4c <at_uart_recv_process+0xcc>
    9b3c:	4b4f      	ldr	r3, [pc, #316]	; (9c7c <at_uart_recv_process+0x1fc>)
    9b3e:	781b      	ldrb	r3, [r3, #0]
    9b40:	2b00      	cmp	r3, #0
    9b42:	d103      	bne.n	9b4c <at_uart_recv_process+0xcc>
    9b44:	4b4c      	ldr	r3, [pc, #304]	; (9c78 <at_uart_recv_process+0x1f8>)
    9b46:	781e      	ldrb	r6, [r3, #0]
    9b48:	2e00      	cmp	r6, #0
    9b4a:	d017      	beq.n	9b7c <at_uart_recv_process+0xfc>
        at_uart_received_size = 0;
    9b4c:	2500      	movs	r5, #0
        at_uart_quick_search_index = 0;
    9b4e:	4b45      	ldr	r3, [pc, #276]	; (9c64 <at_uart_recv_process+0x1e4>)
        at_uart_received_size = 0;
    9b50:	8025      	strh	r5, [r4, #0]
        at_uart_quick_search_index = 0;
    9b52:	601d      	str	r5, [r3, #0]
        (void)at_uart_flush_data();
    9b54:	f7ff fde2 	bl	971c <at_uart_flush_data>
        at_uart_receive_status = AT_UART_STATUS_IN_PROCESS;
    9b58:	2201      	movs	r2, #1
    9b5a:	4b43      	ldr	r3, [pc, #268]	; (9c68 <at_uart_recv_process+0x1e8>)
        at_uart_receive_uart_buffer[0] = '\0';
    9b5c:	703d      	strb	r5, [r7, #0]
        at_uart_receive_status = AT_UART_STATUS_IN_PROCESS;
    9b5e:	701a      	strb	r2, [r3, #0]
        at_uart_trigger_received_at_notify_callback();
    9b60:	f7ff fdae 	bl	96c0 <at_uart_trigger_received_at_notify_callback>
        at_uart_recv_at_cmd_header_flag = false;
    9b64:	4b3e      	ldr	r3, [pc, #248]	; (9c60 <at_uart_recv_process+0x1e0>)
    9b66:	701d      	strb	r5, [r3, #0]
    9b68:	e78b      	b.n	9a82 <at_uart_recv_process+0x2>
        return uart_get_data( at_uart_handler, buffer, buffer_size, uart_errors );
    9b6a:	4b46      	ldr	r3, [pc, #280]	; (9c84 <at_uart_recv_process+0x204>)
    9b6c:	000a      	movs	r2, r1
    9b6e:	781d      	ldrb	r5, [r3, #0]
    9b70:	0001      	movs	r1, r0
    9b72:	0033      	movs	r3, r6
    9b74:	0028      	movs	r0, r5
    9b76:	f00c fc3f 	bl	163f8 <uart_get_data>
    9b7a:	e7cc      	b.n	9b16 <at_uart_recv_process+0x96>
    if( received_count > 0 )
    9b7c:	2800      	cmp	r0, #0
    9b7e:	d100      	bne.n	9b82 <at_uart_recv_process+0x102>
    9b80:	e77f      	b.n	9a82 <at_uart_recv_process+0x2>
        at_uart_received_size += received_count;
    9b82:	8823      	ldrh	r3, [r4, #0]
    9b84:	18c0      	adds	r0, r0, r3
    9b86:	b280      	uxth	r0, r0
    9b88:	8020      	strh	r0, [r4, #0]
        if ((at_uart_received_size >= AT_CMD_PREFIX_LEN) && (!at_uart_recv_at_cmd_header_flag) && (!get_is_pdu()))
    9b8a:	2801      	cmp	r0, #1
    9b8c:	d924      	bls.n	9bd8 <at_uart_recv_process+0x158>
    9b8e:	4b34      	ldr	r3, [pc, #208]	; (9c60 <at_uart_recv_process+0x1e0>)
    9b90:	781b      	ldrb	r3, [r3, #0]
    9b92:	2b00      	cmp	r3, #0
    9b94:	d120      	bne.n	9bd8 <at_uart_recv_process+0x158>
    9b96:	f7ff fb07 	bl	91a8 <get_is_pdu>
    9b9a:	2800      	cmp	r0, #0
    9b9c:	d11c      	bne.n	9bd8 <at_uart_recv_process+0x158>
            for (i = 0; i < (uint32)(at_uart_received_size - 1); i++)
    9b9e:	8822      	ldrh	r2, [r4, #0]
    9ba0:	0035      	movs	r5, r6
    9ba2:	1e53      	subs	r3, r2, #1
    9ba4:	469c      	mov	ip, r3
                if ((at_uart_receive_uart_buffer[i] == 'a') || (at_uart_receive_uart_buffer[i] == 'A'))
    9ba6:	2720      	movs	r7, #32
    9ba8:	4830      	ldr	r0, [pc, #192]	; (9c6c <at_uart_recv_process+0x1ec>)
            for (i = 0; i < (uint32)(at_uart_received_size - 1); i++)
    9baa:	4565      	cmp	r5, ip
    9bac:	d214      	bcs.n	9bd8 <at_uart_recv_process+0x158>
                if ((at_uart_receive_uart_buffer[i] == 'a') || (at_uart_receive_uart_buffer[i] == 'A'))
    9bae:	5d43      	ldrb	r3, [r0, r5]
    9bb0:	43bb      	bics	r3, r7
    9bb2:	2b41      	cmp	r3, #65	; 0x41
    9bb4:	d11a      	bne.n	9bec <at_uart_recv_process+0x16c>
                    if((at_uart_receive_uart_buffer[i + 1] == 't') || (at_uart_receive_uart_buffer[i + 1] == 'T'))
    9bb6:	1941      	adds	r1, r0, r5
    9bb8:	784b      	ldrb	r3, [r1, #1]
    9bba:	43bb      	bics	r3, r7
    9bbc:	2b54      	cmp	r3, #84	; 0x54
    9bbe:	d115      	bne.n	9bec <at_uart_recv_process+0x16c>
                        at_uart_recv_at_cmd_header_flag = true;
    9bc0:	2701      	movs	r7, #1
    9bc2:	4b27      	ldr	r3, [pc, #156]	; (9c60 <at_uart_recv_process+0x1e0>)
                        memmove(at_uart_receive_uart_buffer, at_uart_receive_uart_buffer + i, at_uart_received_size - i);
    9bc4:	1b52      	subs	r2, r2, r5
                        at_uart_recv_at_cmd_header_flag = true;
    9bc6:	701f      	strb	r7, [r3, #0]
                        at_uart_quick_search_index = AT_CMD_PREFIX_LEN;
    9bc8:	2702      	movs	r7, #2
    9bca:	4b26      	ldr	r3, [pc, #152]	; (9c64 <at_uart_recv_process+0x1e4>)
    9bcc:	601f      	str	r7, [r3, #0]
                        memmove(at_uart_receive_uart_buffer, at_uart_receive_uart_buffer + i, at_uart_received_size - i);
    9bce:	f011 fb9c 	bl	1b30a <memmove>
                        at_uart_received_size -= i;
    9bd2:	8823      	ldrh	r3, [r4, #0]
    9bd4:	1b5d      	subs	r5, r3, r5
    9bd6:	8025      	strh	r5, [r4, #0]
    9bd8:	4d22      	ldr	r5, [pc, #136]	; (9c64 <at_uart_recv_process+0x1e4>)
        for (; at_uart_quick_search_index < at_uart_received_size; at_uart_quick_search_index++)
    9bda:	8821      	ldrh	r1, [r4, #0]
    9bdc:	682b      	ldr	r3, [r5, #0]
            if ((at_uart_receive_uart_buffer[at_uart_quick_search_index] == '\r')
    9bde:	4f23      	ldr	r7, [pc, #140]	; (9c6c <at_uart_recv_process+0x1ec>)
        for (; at_uart_quick_search_index < at_uart_received_size; at_uart_quick_search_index++)
    9be0:	4299      	cmp	r1, r3
    9be2:	d806      	bhi.n	9bf2 <at_uart_recv_process+0x172>
    9be4:	2e00      	cmp	r6, #0
    9be6:	d100      	bne.n	9bea <at_uart_recv_process+0x16a>
    9be8:	e74b      	b.n	9a82 <at_uart_recv_process+0x2>
    9bea:	e020      	b.n	9c2e <at_uart_recv_process+0x1ae>
            for (i = 0; i < (uint32)(at_uart_received_size - 1); i++)
    9bec:	3501      	adds	r5, #1
    9bee:	b2ad      	uxth	r5, r5
    9bf0:	e7db      	b.n	9baa <at_uart_recv_process+0x12a>
            if ((at_uart_receive_uart_buffer[at_uart_quick_search_index] == '\r')
    9bf2:	5cfa      	ldrb	r2, [r7, r3]
    9bf4:	2a0d      	cmp	r2, #13
    9bf6:	d11c      	bne.n	9c32 <at_uart_recv_process+0x1b2>
    9bf8:	2e00      	cmp	r6, #0
    9bfa:	d000      	beq.n	9bfe <at_uart_recv_process+0x17e>
    9bfc:	602b      	str	r3, [r5, #0]
                if (at_uart_recv_at_cmd_header_flag || get_is_pdu())
    9bfe:	4e18      	ldr	r6, [pc, #96]	; (9c60 <at_uart_recv_process+0x1e0>)
    9c00:	7833      	ldrb	r3, [r6, #0]
    9c02:	2b00      	cmp	r3, #0
    9c04:	d020      	beq.n	9c48 <at_uart_recv_process+0x1c8>
                    at_uart_receive_status = AT_UART_STATUS_IN_PROCESS;
    9c06:	2201      	movs	r2, #1
    9c08:	4b17      	ldr	r3, [pc, #92]	; (9c68 <at_uart_recv_process+0x1e8>)
    9c0a:	701a      	strb	r2, [r3, #0]
                    at_uart_receive_uart_buffer[at_uart_quick_search_index] = '\0';
    9c0c:	2300      	movs	r3, #0
    9c0e:	682a      	ldr	r2, [r5, #0]
                    at_uart_recv_at_cmd_header_flag = false;
    9c10:	7033      	strb	r3, [r6, #0]
                    at_uart_receive_uart_buffer[at_uart_quick_search_index] = '\0';
    9c12:	54bb      	strb	r3, [r7, r2]
                    at_uart_trigger_received_at_notify_callback();
    9c14:	f7ff fd54 	bl	96c0 <at_uart_trigger_received_at_notify_callback>
                    if(get_is_pdu())
    9c18:	f7ff fac6 	bl	91a8 <get_is_pdu>
    9c1c:	2800      	cmp	r0, #0
    9c1e:	d005      	beq.n	9c2c <at_uart_recv_process+0x1ac>
                        clear_is_pdu();
    9c20:	f7ff fabc 	bl	919c <clear_is_pdu>
                        set_sms_uart_pdu_len((uint16)at_uart_quick_search_index);
    9c24:	682b      	ldr	r3, [r5, #0]
    9c26:	b298      	uxth	r0, r3
    9c28:	f7ff f862 	bl	8cf0 <set_sms_uart_pdu_len>
                at_uart_quick_search_index = 0;
    9c2c:	2300      	movs	r3, #0
    9c2e:	602b      	str	r3, [r5, #0]
    {
    9c30:	e727      	b.n	9a82 <at_uart_recv_process+0x2>
                || ((at_uart_receive_uart_buffer[at_uart_quick_search_index] == '\n') && (at_uart_quick_search_index != 0))
    9c32:	2a0a      	cmp	r2, #10
    9c34:	d104      	bne.n	9c40 <at_uart_recv_process+0x1c0>
    9c36:	2b00      	cmp	r3, #0
    9c38:	d1de      	bne.n	9bf8 <at_uart_recv_process+0x178>
    9c3a:	3301      	adds	r3, #1
    9c3c:	2601      	movs	r6, #1
    9c3e:	e7cf      	b.n	9be0 <at_uart_recv_process+0x160>
                || (at_uart_quick_search_index == AT_UART_RECEIVE_BUFFER_SIZE - 1))
    9c40:	4a06      	ldr	r2, [pc, #24]	; (9c5c <at_uart_recv_process+0x1dc>)
    9c42:	4293      	cmp	r3, r2
    9c44:	d1f9      	bne.n	9c3a <at_uart_recv_process+0x1ba>
    9c46:	e7d7      	b.n	9bf8 <at_uart_recv_process+0x178>
                if (at_uart_recv_at_cmd_header_flag || get_is_pdu())
    9c48:	f7ff faae 	bl	91a8 <get_is_pdu>
    9c4c:	2800      	cmp	r0, #0
    9c4e:	d1da      	bne.n	9c06 <at_uart_recv_process+0x186>
                    at_uart_received_size = 0;
    9c50:	8020      	strh	r0, [r4, #0]
    9c52:	e7eb      	b.n	9c2c <at_uart_recv_process+0x1ac>
    9c54:	010024a4 	.word	0x010024a4
    9c58:	010024a0 	.word	0x010024a0
    9c5c:	00000aca 	.word	0x00000aca
    9c60:	010024a2 	.word	0x010024a2
    9c64:	010019cc 	.word	0x010019cc
    9c68:	010019d0 	.word	0x010019d0
    9c6c:	010019d1 	.word	0x010019d1
    9c70:	00000acb 	.word	0x00000acb
    9c74:	010019b1 	.word	0x010019b1
    9c78:	010019a7 	.word	0x010019a7
    9c7c:	010019a8 	.word	0x010019a8
    9c80:	010019a6 	.word	0x010019a6
    9c84:	010019b0 	.word	0x010019b0

00009c88 <at_uart_read_current_config>:
    if (uart_config == NULL)
    9c88:	2800      	cmp	r0, #0
    9c8a:	d00b      	beq.n	9ca4 <at_uart_read_current_config+0x1c>
    uart_config->baudrate = at_uart_new_config.baudrate;
    9c8c:	4a06      	ldr	r2, [pc, #24]	; (9ca8 <at_uart_read_current_config+0x20>)
    9c8e:	6811      	ldr	r1, [r2, #0]
    9c90:	6001      	str	r1, [r0, #0]
    uart_config->syncmode = at_uart_new_config.syncmode;
    9c92:	7911      	ldrb	r1, [r2, #4]
    9c94:	7101      	strb	r1, [r0, #4]
    uart_config->stopbits = at_uart_new_config.stopbits;
    9c96:	7951      	ldrb	r1, [r2, #5]
    9c98:	7141      	strb	r1, [r0, #5]
    uart_config->parity = at_uart_new_config.parity;
    9c9a:	7991      	ldrb	r1, [r2, #6]
    9c9c:	7181      	strb	r1, [r0, #6]
    uart_config->sw_flow_control = at_uart_new_config.sw_flow_control;
    9c9e:	79d2      	ldrb	r2, [r2, #7]
    9ca0:	71c2      	strb	r2, [r0, #7]
    return true;
    9ca2:	2001      	movs	r0, #1
}
    9ca4:	4770      	bx	lr
    9ca6:	46c0      	nop			; (mov r8, r8)
    9ca8:	010019c0 	.word	0x010019c0

00009cac <at_uart_mark_need_change_config>:
{
    9cac:	b573      	push	{r0, r1, r4, r5, r6, lr}
    9cae:	0016      	movs	r6, r2
    9cb0:	001d      	movs	r5, r3
    9cb2:	9000      	str	r0, [sp, #0]
    9cb4:	9101      	str	r1, [sp, #4]
    non_os_enter_critical();
    9cb6:	f00e fa7d 	bl	181b4 <non_os_enter_critical>
    if (at_uart_config_status == AT_UART_CONFIG_STATUS_NORMAL)
    9cba:	4b16      	ldr	r3, [pc, #88]	; (9d14 <at_uart_mark_need_change_config+0x68>)
    9cbc:	781a      	ldrb	r2, [r3, #0]
    9cbe:	2a00      	cmp	r2, #0
    9cc0:	d123      	bne.n	9d0a <at_uart_mark_need_change_config+0x5e>
        at_uart_config_status = AT_UART_CONFIG_STATUS_MARK_NEW;
    9cc2:	2401      	movs	r4, #1
    9cc4:	701c      	strb	r4, [r3, #0]
        at_uart_last_config.baudrate = at_uart_new_config.baudrate;
    9cc6:	4b14      	ldr	r3, [pc, #80]	; (9d18 <at_uart_mark_need_change_config+0x6c>)
    9cc8:	4a14      	ldr	r2, [pc, #80]	; (9d1c <at_uart_mark_need_change_config+0x70>)
    9cca:	6819      	ldr	r1, [r3, #0]
    9ccc:	6011      	str	r1, [r2, #0]
        at_uart_last_config.syncmode = at_uart_new_config.syncmode;
    9cce:	7919      	ldrb	r1, [r3, #4]
    9cd0:	7111      	strb	r1, [r2, #4]
        at_uart_last_config.stopbits = at_uart_new_config.stopbits;
    9cd2:	7959      	ldrb	r1, [r3, #5]
    9cd4:	7151      	strb	r1, [r2, #5]
        at_uart_last_config.parity = at_uart_new_config.parity;
    9cd6:	7999      	ldrb	r1, [r3, #6]
    9cd8:	7191      	strb	r1, [r2, #6]
        at_uart_last_config.sw_flow_control = at_uart_new_config.sw_flow_control;
    9cda:	79d9      	ldrb	r1, [r3, #7]
    9cdc:	71d1      	strb	r1, [r2, #7]
        at_uart_new_config.baudrate = uart_config.baudrate;
    9cde:	9a00      	ldr	r2, [sp, #0]
    9ce0:	601a      	str	r2, [r3, #0]
        at_uart_new_config.syncmode = uart_config.syncmode;
    9ce2:	466a      	mov	r2, sp
    9ce4:	7912      	ldrb	r2, [r2, #4]
    9ce6:	711a      	strb	r2, [r3, #4]
        at_uart_new_config.stopbits = uart_config.stopbits;
    9ce8:	466a      	mov	r2, sp
    9cea:	7952      	ldrb	r2, [r2, #5]
    9cec:	715a      	strb	r2, [r3, #5]
        at_uart_new_config.parity = uart_config.parity;
    9cee:	466a      	mov	r2, sp
    9cf0:	7992      	ldrb	r2, [r2, #6]
    9cf2:	719a      	strb	r2, [r3, #6]
        at_uart_new_config.sw_flow_control = uart_config.sw_flow_control;
    9cf4:	466a      	mov	r2, sp
    9cf6:	79d2      	ldrb	r2, [r2, #7]
    9cf8:	71da      	strb	r2, [r3, #7]
        at_uart_config_store = store;
    9cfa:	4b09      	ldr	r3, [pc, #36]	; (9d20 <at_uart_mark_need_change_config+0x74>)
    9cfc:	701e      	strb	r6, [r3, #0]
        at_uart_config_timeout = timeout;
    9cfe:	4b09      	ldr	r3, [pc, #36]	; (9d24 <at_uart_mark_need_change_config+0x78>)
    9d00:	601d      	str	r5, [r3, #0]
        non_os_exit_critical();
    9d02:	f00e fa6b 	bl	181dc <non_os_exit_critical>
        return true;
    9d06:	0020      	movs	r0, r4
}
    9d08:	bd76      	pop	{r1, r2, r4, r5, r6, pc}
    non_os_exit_critical();
    9d0a:	f00e fa67 	bl	181dc <non_os_exit_critical>
    return false;
    9d0e:	2000      	movs	r0, #0
    9d10:	e7fa      	b.n	9d08 <at_uart_mark_need_change_config+0x5c>
    9d12:	46c0      	nop			; (mov r8, r8)
    9d14:	010019a9 	.word	0x010019a9
    9d18:	010019c0 	.word	0x010019c0
    9d1c:	010019b4 	.word	0x010019b4
    9d20:	010019aa 	.word	0x010019aa
    9d24:	010019ac 	.word	0x010019ac

00009d28 <at_uart_mark_need_change_to_ppp>:
{
    9d28:	b510      	push	{r4, lr}
    non_os_enter_critical();
    9d2a:	f00e fa43 	bl	181b4 <non_os_enter_critical>
    if (at_uart_config_status == AT_UART_CONFIG_STATUS_NORMAL)
    9d2e:	4b07      	ldr	r3, [pc, #28]	; (9d4c <at_uart_mark_need_change_to_ppp+0x24>)
    9d30:	781a      	ldrb	r2, [r3, #0]
    9d32:	2a00      	cmp	r2, #0
    9d34:	d105      	bne.n	9d42 <at_uart_mark_need_change_to_ppp+0x1a>
        at_uart_config_status = AT_UART_CONFIG_STATUS_START_PPP;
    9d36:	3204      	adds	r2, #4
    9d38:	701a      	strb	r2, [r3, #0]
        non_os_exit_critical();
    9d3a:	f00e fa4f 	bl	181dc <non_os_exit_critical>
        return true;
    9d3e:	2001      	movs	r0, #1
}
    9d40:	bd10      	pop	{r4, pc}
    non_os_exit_critical();
    9d42:	f00e fa4b 	bl	181dc <non_os_exit_critical>
    return false;
    9d46:	2000      	movs	r0, #0
    9d48:	e7fa      	b.n	9d40 <at_uart_mark_need_change_to_ppp+0x18>
    9d4a:	46c0      	nop			; (mov r8, r8)
    9d4c:	010019a9 	.word	0x010019a9

00009d50 <at_uart_mark_need_change_to_at>:
    at_uart_config_status = AT_UART_CONFIG_STATUS_START_AT;
    9d50:	2206      	movs	r2, #6
{
    9d52:	b510      	push	{r4, lr}
    at_uart_config_status = AT_UART_CONFIG_STATUS_START_AT;
    9d54:	4b02      	ldr	r3, [pc, #8]	; (9d60 <at_uart_mark_need_change_to_at+0x10>)
    9d56:	701a      	strb	r2, [r3, #0]
    at_uart_received_at_notify_callback();  //Kick the main thread so we can move onto the next stage
    9d58:	4b02      	ldr	r3, [pc, #8]	; (9d64 <at_uart_mark_need_change_to_at+0x14>)
    9d5a:	681b      	ldr	r3, [r3, #0]
    9d5c:	4798      	blx	r3
}
    9d5e:	bd10      	pop	{r4, pc}
    9d60:	010019a9 	.word	0x010019a9
    9d64:	0100249c 	.word	0x0100249c

00009d68 <at_uart_mark_ensure_change_config>:
{
    9d68:	b510      	push	{r4, lr}
    non_os_enter_critical();
    9d6a:	f00e fa23 	bl	181b4 <non_os_enter_critical>
    if (at_uart_config_status == AT_UART_CONFIG_STATUS_TEMP)
    9d6e:	4b04      	ldr	r3, [pc, #16]	; (9d80 <at_uart_mark_ensure_change_config+0x18>)
    9d70:	781a      	ldrb	r2, [r3, #0]
    9d72:	2a02      	cmp	r2, #2
    9d74:	d101      	bne.n	9d7a <at_uart_mark_ensure_change_config+0x12>
        at_uart_config_status = AT_UART_CONFIG_STATUS_SWITCHED;
    9d76:	3201      	adds	r2, #1
    9d78:	701a      	strb	r2, [r3, #0]
    non_os_exit_critical();
    9d7a:	f00e fa2f 	bl	181dc <non_os_exit_critical>
}
    9d7e:	bd10      	pop	{r4, pc}
    9d80:	010019a9 	.word	0x010019a9

00009d84 <at_uart_store_new_config>:
    }
    non_os_exit_critical();
}

bool at_uart_store_new_config(void)
{
    9d84:	b537      	push	{r0, r1, r2, r4, r5, lr}
    non_os_enter_critical();
    9d86:	f00e fa15 	bl	181b4 <non_os_enter_critical>
    if (at_uart_config_status == AT_UART_CONFIG_STATUS_SWITCHED)
    9d8a:	4b17      	ldr	r3, [pc, #92]	; (9de8 <at_uart_store_new_config+0x64>)
    9d8c:	781a      	ldrb	r2, [r3, #0]
    9d8e:	2a03      	cmp	r2, #3
    9d90:	d126      	bne.n	9de0 <at_uart_store_new_config+0x5c>
    {
        at_uart_config_status = AT_UART_CONFIG_STATUS_NORMAL;
    9d92:	2500      	movs	r5, #0
        if (at_uart_sys_timer_handle != NULL)
    9d94:	4c15      	ldr	r4, [pc, #84]	; (9dec <at_uart_store_new_config+0x68>)
        at_uart_config_status = AT_UART_CONFIG_STATUS_NORMAL;
    9d96:	701d      	strb	r5, [r3, #0]
        if (at_uart_sys_timer_handle != NULL)
    9d98:	6820      	ldr	r0, [r4, #0]
    9d9a:	42a8      	cmp	r0, r5
    9d9c:	d002      	beq.n	9da4 <at_uart_store_new_config+0x20>
        {
            (void)osTimerDelete(at_uart_sys_timer_handle);
    9d9e:	f00a fdcf 	bl	14940 <osTimerDelete>
            at_uart_sys_timer_handle = NULL;
    9da2:	6025      	str	r5, [r4, #0]
        }
        non_os_exit_critical();
    9da4:	f00e fa1a 	bl	181dc <non_os_exit_critical>

        if (at_uart_config_store)
    9da8:	4b11      	ldr	r3, [pc, #68]	; (9df0 <at_uart_store_new_config+0x6c>)
    9daa:	781b      	ldrb	r3, [r3, #0]
    9dac:	2b00      	cmp	r3, #0
    9dae:	d101      	bne.n	9db4 <at_uart_store_new_config+0x30>
    else
    {
        non_os_exit_critical();
    }

    return true;
    9db0:	2001      	movs	r0, #1
    9db2:	e014      	b.n	9dde <at_uart_store_new_config+0x5a>
            if (neul_kv_set(AT_KEYID_ATCMD_UART_CONFIG, (uint8*)&at_uart_new_config, sizeof(at_uart_config)) != NEUL_RET_OK)       //lint !e845
    9db4:	2208      	movs	r2, #8
    9db6:	490f      	ldr	r1, [pc, #60]	; (9df4 <at_uart_store_new_config+0x70>)
    9db8:	480f      	ldr	r0, [pc, #60]	; (9df8 <at_uart_store_new_config+0x74>)
    9dba:	f7fd fbf5 	bl	75a8 <neul_kv_set>
    9dbe:	2800      	cmp	r0, #0
    9dc0:	d0f6      	beq.n	9db0 <at_uart_store_new_config+0x2c>
                log_event(APPS_SW_MODULE_AT, LOG_VERBOSITY_NORMAL, LOG_FLAGS_NONE, NEUL_LOG_TYPE_STRING, (uint16)strlen(AT_UART_CONFIG_FAIL_STR), (const uint8*) AT_UART_CONFIG_FAIL_STR);
    9dc2:	4c0e      	ldr	r4, [pc, #56]	; (9dfc <at_uart_store_new_config+0x78>)
    9dc4:	0020      	movs	r0, r4
    9dc6:	f011 faea 	bl	1b39e <strlen>
    9dca:	2300      	movs	r3, #0
    9dcc:	b280      	uxth	r0, r0
    9dce:	9000      	str	r0, [sp, #0]
    9dd0:	9401      	str	r4, [sp, #4]
    9dd2:	2008      	movs	r0, #8
    9dd4:	001a      	movs	r2, r3
    9dd6:	2101      	movs	r1, #1
    9dd8:	f7fc fc30 	bl	663c <log_event>
                return false;
    9ddc:	2000      	movs	r0, #0
}
    9dde:	bd3e      	pop	{r1, r2, r3, r4, r5, pc}
        non_os_exit_critical();
    9de0:	f00e f9fc 	bl	181dc <non_os_exit_critical>
    9de4:	e7e4      	b.n	9db0 <at_uart_store_new_config+0x2c>
    9de6:	46c0      	nop			; (mov r8, r8)
    9de8:	010019a9 	.word	0x010019a9
    9dec:	010024ac 	.word	0x010024ac
    9df0:	010019aa 	.word	0x010019aa
    9df4:	010019c0 	.word	0x010019c0
    9df8:	00000801 	.word	0x00000801
    9dfc:	00023455 	.word	0x00023455

00009e00 <at_uart_init>:

void at_uart_init(void)
{
    9e00:	b57f      	push	{r0, r1, r2, r3, r4, r5, r6, lr}
    if( neul_kv_get(AT_KEYID_ATCMD_UART_CONFIG, sizeof(at_uart_config), &value_length, (uint8*)uart_config) != NEUL_RET_OK )
    9e02:	466a      	mov	r2, sp
    9e04:	4c29      	ldr	r4, [pc, #164]	; (9eac <at_uart_init+0xac>)
    9e06:	3206      	adds	r2, #6
    9e08:	0023      	movs	r3, r4
    9e0a:	2108      	movs	r1, #8
    9e0c:	4828      	ldr	r0, [pc, #160]	; (9eb0 <at_uart_init+0xb0>)
    9e0e:	f7fd fbd0 	bl	75b2 <neul_kv_get>
    9e12:	ae02      	add	r6, sp, #8
    9e14:	2800      	cmp	r0, #0
    9e16:	d013      	beq.n	9e40 <at_uart_init+0x40>
        if( neul_kv_get(AT_KEYID_ATCMD_UART_CONFIG_V1, sizeof(at_uart_config_v1), &value_length, (uint8*)&uart_config_v1) != NEUL_RET_OK )
    9e18:	466a      	mov	r2, sp
    9e1a:	2080      	movs	r0, #128	; 0x80
    9e1c:	0033      	movs	r3, r6
    9e1e:	3206      	adds	r2, #6
    9e20:	2108      	movs	r1, #8
    9e22:	0100      	lsls	r0, r0, #4
    9e24:	f7fd fbc5 	bl	75b2 <neul_kv_get>
    9e28:	2800      	cmp	r0, #0
    9e2a:	d037      	beq.n	9e9c <at_uart_init+0x9c>
            uart_config->baudrate = AT_UART_DEFAULT_BAUD_RATE;
    9e2c:	2396      	movs	r3, #150	; 0x96
    9e2e:	019b      	lsls	r3, r3, #6
    9e30:	6023      	str	r3, [r4, #0]
    9e32:	2381      	movs	r3, #129	; 0x81
    9e34:	005b      	lsls	r3, r3, #1
    9e36:	80a3      	strh	r3, [r4, #4]
            uart_config->stopbits = AT_UART_DEFAULT_STOPBITS;
    9e38:	2300      	movs	r3, #0
            uart_config->parity = uart_config_v1.parity;
    9e3a:	71a3      	strb	r3, [r4, #6]
        uart_config->sw_flow_control = AT_UART_DEFAULT_SW_FLOW_CONTROL;
    9e3c:	2300      	movs	r3, #0
    9e3e:	71e3      	strb	r3, [r4, #7]
    if (neul_kv_get(BASE_KEYID_UART_0_CONFIG, sizeof(uart_pin_configuration), &kvalue_length, (uint8 *)at_uart_pins) != NEUL_RET_OK)
    9e40:	4d1c      	ldr	r5, [pc, #112]	; (9eb4 <at_uart_init+0xb4>)
    9e42:	0032      	movs	r2, r6
    9e44:	002b      	movs	r3, r5
    9e46:	2104      	movs	r1, #4
    9e48:	2010      	movs	r0, #16
    9e4a:	f7fd fbb2 	bl	75b2 <neul_kv_get>
    9e4e:	2800      	cmp	r0, #0
    9e50:	d006      	beq.n	9e60 <at_uart_init+0x60>
        at_uart_pins->tx_pin = AT_TX_UART_PIN;
    9e52:	2312      	movs	r3, #18
    9e54:	702b      	strb	r3, [r5, #0]
        at_uart_pins->rx_pin = AT_RX_UART_PIN;
    9e56:	3b05      	subs	r3, #5
    9e58:	706b      	strb	r3, [r5, #1]
        at_uart_pins->rts_pin = PIN_NONE;
    9e5a:	331b      	adds	r3, #27
    9e5c:	70eb      	strb	r3, [r5, #3]
        at_uart_pins->cts_pin = PIN_NONE;
    9e5e:	70ab      	strb	r3, [r5, #2]
    /* Read the UART configuration and pin allocation from NV Keys into the GLOBAL variables for repeated use. */
    at_uart_config_read(&at_uart_new_config);
    at_uart_pin_config_read(&at_uart_pin_config);

    /* When using Hardware flow control, disable software flow control. */
    if (at_uart_pin_config.rts_pin != PIN_NONE)
    9e60:	78eb      	ldrb	r3, [r5, #3]
    9e62:	2b28      	cmp	r3, #40	; 0x28
    9e64:	d001      	beq.n	9e6a <at_uart_init+0x6a>
    {
        at_uart_new_config.sw_flow_control = AT_UART_FLOW_CONTROL_DISABLED;
    9e66:	2300      	movs	r3, #0
    9e68:	71e3      	strb	r3, [r4, #7]
    }

    /* Setup the UART control structure, based on the NV key values, read above. */
    at_uart_configure(&at_uart_new_config, &at_uart_pin_config);
    9e6a:	f7ff fcb5 	bl	97d8 <at_uart_configure.constprop.6>
    at_uart_mutex = osMutexNew(NULL);
    9e6e:	2000      	movs	r0, #0
    9e70:	f00a fd82 	bl	14978 <osMutexNew>
    9e74:	4b10      	ldr	r3, [pc, #64]	; (9eb8 <at_uart_init+0xb8>)
    9e76:	1e01      	subs	r1, r0, #0
    9e78:	6018      	str	r0, [r3, #0]
    if(!at_uart_mutex)
    9e7a:	d102      	bne.n	9e82 <at_uart_init+0x82>
        panic(PANIC_AT_CMD, APP_AT_PANIC_MUTEX_NOT_READY);
    9e7c:	2002      	movs	r0, #2
    9e7e:	f7f7 fe47 	bl	1b10 <panic>
    at_uart_tx_data = osSemaphoreNew(1, 0, NULL);
    9e82:	2200      	movs	r2, #0
    9e84:	2001      	movs	r0, #1
    9e86:	0011      	movs	r1, r2
    9e88:	f00a fddc 	bl	14a44 <osSemaphoreNew>
    9e8c:	4b0b      	ldr	r3, [pc, #44]	; (9ebc <at_uart_init+0xbc>)
    9e8e:	1e01      	subs	r1, r0, #0
    9e90:	6018      	str	r0, [r3, #0]
    if(!at_uart_tx_data)
    9e92:	d102      	bne.n	9e9a <at_uart_init+0x9a>
        panic(PANIC_AT_CMD, APP_AT_PANIC_MUTEX_NOT_READY);
    9e94:	2002      	movs	r0, #2
    9e96:	f7f7 fe3b 	bl	1b10 <panic>

    at_uart_create_mutex();
}
    9e9a:	bd7f      	pop	{r0, r1, r2, r3, r4, r5, r6, pc}
            uart_config->baudrate = uart_config_v1.baudrate;
    9e9c:	9b02      	ldr	r3, [sp, #8]
    9e9e:	6023      	str	r3, [r4, #0]
            uart_config->syncmode = uart_config_v1.syncmode;
    9ea0:	7933      	ldrb	r3, [r6, #4]
    9ea2:	7123      	strb	r3, [r4, #4]
            uart_config->stopbits = uart_config_v1.stopbits;
    9ea4:	7973      	ldrb	r3, [r6, #5]
    9ea6:	7163      	strb	r3, [r4, #5]
            uart_config->parity = uart_config_v1.parity;
    9ea8:	79b3      	ldrb	r3, [r6, #6]
    9eaa:	e7c6      	b.n	9e3a <at_uart_init+0x3a>
    9eac:	010019c0 	.word	0x010019c0
    9eb0:	00000801 	.word	0x00000801
    9eb4:	010019c8 	.word	0x010019c8
    9eb8:	010019bc 	.word	0x010019bc
    9ebc:	010024b0 	.word	0x010024b0

00009ec0 <at_uart_deinit>:

void at_uart_deinit(void)
{
    9ec0:	b570      	push	{r4, r5, r6, lr}
    while (uart_has_pending_transmissions(at_uart_handler))
    9ec2:	4c1e      	ldr	r4, [pc, #120]	; (9f3c <at_uart_deinit+0x7c>)
    9ec4:	7820      	ldrb	r0, [r4, #0]
    9ec6:	f00b ff77 	bl	15db8 <uart_has_pending_transmissions>
    9eca:	1e05      	subs	r5, r0, #0
    9ecc:	d1f9      	bne.n	9ec2 <at_uart_deinit+0x2>
    {

    }

    // disable interrupts while the modules are configured
    non_os_enter_critical();
    9ece:	f00e f971 	bl	181b4 <non_os_enter_critical>

    if (!at_uart_high_speed_enable)
    9ed2:	4b1b      	ldr	r3, [pc, #108]	; (9f40 <at_uart_deinit+0x80>)
    9ed4:	781b      	ldrb	r3, [r3, #0]
    9ed6:	2b00      	cmp	r3, #0
    9ed8:	d124      	bne.n	9f24 <at_uart_deinit+0x64>
    {
        lp_uart_deinit();
    9eda:	f00e f863 	bl	17fa4 <lp_uart_deinit>
        lp_uart_disable_irq ( LP_UART_INTERRUPT_SUCCESSFUL_WORD );
    9ede:	2003      	movs	r0, #3
    9ee0:	f00e f90a 	bl	180f8 <lp_uart_disable_irq>
        lp_uart_disable_irq ( LP_UART_INTERRUPT_PARITY_ERROR );
    9ee4:	2001      	movs	r0, #1
    9ee6:	f00e f907 	bl	180f8 <lp_uart_disable_irq>
        lp_uart_disable_irq ( LP_UART_INTERRUPT_FRAME_ERROR );
    9eea:	2002      	movs	r0, #2
    9eec:	f00e f904 	bl	180f8 <lp_uart_disable_irq>
        lp_uart_unset_callback(LP_UART_INTERRUPT_SUCCESSFUL_WORD);
    9ef0:	2003      	movs	r0, #3
    9ef2:	f00e f94f 	bl	18194 <lp_uart_unset_callback>
        lp_uart_unset_callback(LP_UART_INTERRUPT_PARITY_ERROR);
    9ef6:	2001      	movs	r0, #1
    9ef8:	f00e f94c 	bl	18194 <lp_uart_unset_callback>
        lp_uart_unset_callback(LP_UART_INTERRUPT_FRAME_ERROR);
    9efc:	2002      	movs	r0, #2
    9efe:	f00e f949 	bl	18194 <lp_uart_unset_callback>
        uart_unregister_rx_callback(at_uart_handler);
        uart_register_parity_error_callback(at_uart_handler, NULL);
        uart_register_frame_error_callback(at_uart_handler, NULL);
    }

    uart_close(at_uart_handler);
    9f02:	7820      	ldrb	r0, [r4, #0]
    9f04:	f00b fea8 	bl	15c58 <uart_close>
    uart_release(at_uart_handler);
    9f08:	7820      	ldrb	r0, [r4, #0]
    9f0a:	f00b fce9 	bl	158e0 <uart_release>
    if (at_uart_stop_sleep_vote_flag)
    9f0e:	4b0d      	ldr	r3, [pc, #52]	; (9f44 <at_uart_deinit+0x84>)
    9f10:	781a      	ldrb	r2, [r3, #0]
    9f12:	2a00      	cmp	r2, #0
    9f14:	d003      	beq.n	9f1e <at_uart_deinit+0x5e>
        at_uart_stop_sleep_vote_flag = false;
    9f16:	2200      	movs	r2, #0
    9f18:	701a      	strb	r2, [r3, #0]
        osRemoveStopClocksVeto();
    9f1a:	f00a fe77 	bl	14c0c <osRemoveStopClocksVeto>

    at_uart_enable_deep_sleep();   // Ensure we now remove any deep sleep veto that may have been setup

    non_os_exit_critical();
    9f1e:	f00e f95d 	bl	181dc <non_os_exit_critical>
}
    9f22:	bd70      	pop	{r4, r5, r6, pc}
        uart_unregister_rx_callback(at_uart_handler);
    9f24:	7820      	ldrb	r0, [r4, #0]
    9f26:	f00c f837 	bl	15f98 <uart_unregister_rx_callback>
        uart_register_parity_error_callback(at_uart_handler, NULL);
    9f2a:	7820      	ldrb	r0, [r4, #0]
    9f2c:	0029      	movs	r1, r5
    9f2e:	f00b ffc3 	bl	15eb8 <uart_register_parity_error_callback>
        uart_register_frame_error_callback(at_uart_handler, NULL);
    9f32:	7820      	ldrb	r0, [r4, #0]
    9f34:	0029      	movs	r1, r5
    9f36:	f00b fff7 	bl	15f28 <uart_register_frame_error_callback>
    9f3a:	e7e2      	b.n	9f02 <at_uart_deinit+0x42>
    9f3c:	010019b0 	.word	0x010019b0
    9f40:	010019b1 	.word	0x010019b1
    9f44:	010024a8 	.word	0x010024a8

00009f48 <at_uart_change_config>:
{
    9f48:	b510      	push	{r4, lr}
    while (uart_has_pending_transmissions(at_uart_handler))
    9f4a:	4b08      	ldr	r3, [pc, #32]	; (9f6c <at_uart_change_config+0x24>)
    9f4c:	7818      	ldrb	r0, [r3, #0]
    9f4e:	f00b ff33 	bl	15db8 <uart_has_pending_transmissions>
    9f52:	1e04      	subs	r4, r0, #0
    9f54:	d1f9      	bne.n	9f4a <at_uart_change_config+0x2>
    non_os_enter_critical();
    9f56:	f00e f92d 	bl	181b4 <non_os_enter_critical>
    at_uart_deinit();
    9f5a:	f7ff ffb1 	bl	9ec0 <at_uart_deinit>
    at_uart_reinit(false);
    9f5e:	0020      	movs	r0, r4
    9f60:	f7ff fccc 	bl	98fc <at_uart_reinit>
    non_os_exit_critical(); // enable interrupts again
    9f64:	f00e f93a 	bl	181dc <non_os_exit_critical>
}
    9f68:	bd10      	pop	{r4, pc}
    9f6a:	46c0      	nop			; (mov r8, r8)
    9f6c:	010019b0 	.word	0x010019b0

00009f70 <at_uart_switch_to_new_config>:
{
    9f70:	4673      	mov	r3, lr
    9f72:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
    9f74:	9301      	str	r3, [sp, #4]
    non_os_enter_critical();
    9f76:	f00e f91d 	bl	181b4 <non_os_enter_critical>
    if (at_uart_config_status != AT_UART_CONFIG_STATUS_MARK_NEW)
    9f7a:	4e19      	ldr	r6, [pc, #100]	; (9fe0 <at_uart_switch_to_new_config+0x70>)
    9f7c:	7833      	ldrb	r3, [r6, #0]
    9f7e:	2b01      	cmp	r3, #1
    9f80:	d002      	beq.n	9f88 <at_uart_switch_to_new_config+0x18>
            non_os_exit_critical();
    9f82:	f00e f92b 	bl	181dc <non_os_exit_critical>
}
    9f86:	bdf7      	pop	{r0, r1, r2, r4, r5, r6, r7, pc}
    at_uart_config_status = AT_UART_CONFIG_STATUS_TEMP;
    9f88:	2302      	movs	r3, #2
    9f8a:	7033      	strb	r3, [r6, #0]
    non_os_exit_critical();
    9f8c:	f00e f926 	bl	181dc <non_os_exit_critical>
    at_uart_change_config();
    9f90:	f7ff ffda 	bl	9f48 <at_uart_change_config>
    non_os_enter_critical();
    9f94:	f00e f90e 	bl	181b4 <non_os_enter_critical>
    if (at_uart_sys_timer_handle == NULL)
    9f98:	4f12      	ldr	r7, [pc, #72]	; (9fe4 <at_uart_switch_to_new_config+0x74>)
    9f9a:	683c      	ldr	r4, [r7, #0]
    9f9c:	2c00      	cmp	r4, #0
    9f9e:	d1f0      	bne.n	9f82 <at_uart_switch_to_new_config+0x12>
        at_uart_sys_timer_handle =osTimerNew((osTimerFunc_t)at_uart_change_config_timeout_callback, osTimerOnce, NULL, NULL);
    9fa0:	0023      	movs	r3, r4
    9fa2:	0022      	movs	r2, r4
    9fa4:	0021      	movs	r1, r4
    9fa6:	4810      	ldr	r0, [pc, #64]	; (9fe8 <at_uart_switch_to_new_config+0x78>)
    9fa8:	f00a fc66 	bl	14878 <osTimerNew>
    9fac:	1e05      	subs	r5, r0, #0
    9fae:	6038      	str	r0, [r7, #0]
        if (at_uart_sys_timer_handle == NULL)
    9fb0:	d101      	bne.n	9fb6 <at_uart_switch_to_new_config+0x46>
            at_uart_config_status = AT_UART_CONFIG_STATUS_NORMAL;
    9fb2:	7030      	strb	r0, [r6, #0]
    9fb4:	e7e5      	b.n	9f82 <at_uart_switch_to_new_config+0x12>
        if (osTimerStart(at_uart_sys_timer_handle, (uint32_t)osMs2Tick((uint64_t)at_uart_config_timeout * 1000)) != osOK)
    9fb6:	22fa      	movs	r2, #250	; 0xfa
    9fb8:	4b0c      	ldr	r3, [pc, #48]	; (9fec <at_uart_switch_to_new_config+0x7c>)
    9fba:	0092      	lsls	r2, r2, #2
    9fbc:	6818      	ldr	r0, [r3, #0]
    9fbe:	0021      	movs	r1, r4
    9fc0:	2300      	movs	r3, #0
    9fc2:	f7f6 fb8f 	bl	6e4 <__aeabi_lmul>
    9fc6:	f00a fc0d 	bl	147e4 <osMs2Tick>
    9fca:	0001      	movs	r1, r0
    9fcc:	0028      	movs	r0, r5
    9fce:	f00a fc7b 	bl	148c8 <osTimerStart>
    9fd2:	2800      	cmp	r0, #0
    9fd4:	d0d5      	beq.n	9f82 <at_uart_switch_to_new_config+0x12>
            assert(false);
    9fd6:	9901      	ldr	r1, [sp, #4]
    9fd8:	2016      	movs	r0, #22
    9fda:	f7f7 fd99 	bl	1b10 <panic>
    9fde:	e7d0      	b.n	9f82 <at_uart_switch_to_new_config+0x12>
    9fe0:	010019a9 	.word	0x010019a9
    9fe4:	010024ac 	.word	0x010024ac
    9fe8:	00009ff1 	.word	0x00009ff1
    9fec:	010019ac 	.word	0x010019ac

00009ff0 <at_uart_change_config_timeout_callback>:
{
    9ff0:	b510      	push	{r4, lr}
    non_os_enter_critical();
    9ff2:	f00e f8df 	bl	181b4 <non_os_enter_critical>
    at_uart_new_config.baudrate = at_uart_last_config.baudrate;
    9ff6:	4a10      	ldr	r2, [pc, #64]	; (a038 <at_uart_change_config_timeout_callback+0x48>)
    9ff8:	4b10      	ldr	r3, [pc, #64]	; (a03c <at_uart_change_config_timeout_callback+0x4c>)
    9ffa:	6811      	ldr	r1, [r2, #0]
    9ffc:	6019      	str	r1, [r3, #0]
    at_uart_new_config.syncmode = at_uart_last_config.syncmode;
    9ffe:	7911      	ldrb	r1, [r2, #4]
    a000:	7119      	strb	r1, [r3, #4]
    at_uart_new_config.stopbits = at_uart_last_config.stopbits;
    a002:	7951      	ldrb	r1, [r2, #5]
    a004:	7159      	strb	r1, [r3, #5]
    at_uart_new_config.parity = at_uart_last_config.parity;
    a006:	7991      	ldrb	r1, [r2, #6]
    a008:	7199      	strb	r1, [r3, #6]
    at_uart_new_config.sw_flow_control = at_uart_last_config.sw_flow_control;
    a00a:	79d2      	ldrb	r2, [r2, #7]
    a00c:	71da      	strb	r2, [r3, #7]
    non_os_exit_critical();
    a00e:	f00e f8e5 	bl	181dc <non_os_exit_critical>
    at_uart_change_config();
    a012:	f7ff ff99 	bl	9f48 <at_uart_change_config>
    non_os_enter_critical();
    a016:	f00e f8cd 	bl	181b4 <non_os_enter_critical>
    if (at_uart_sys_timer_handle != NULL)
    a01a:	4c09      	ldr	r4, [pc, #36]	; (a040 <at_uart_change_config_timeout_callback+0x50>)
    a01c:	6820      	ldr	r0, [r4, #0]
    a01e:	2800      	cmp	r0, #0
    a020:	d003      	beq.n	a02a <at_uart_change_config_timeout_callback+0x3a>
        (void)osTimerDelete(at_uart_sys_timer_handle);
    a022:	f00a fc8d 	bl	14940 <osTimerDelete>
        at_uart_sys_timer_handle = NULL;
    a026:	2300      	movs	r3, #0
    a028:	6023      	str	r3, [r4, #0]
    at_uart_config_status = AT_UART_CONFIG_STATUS_NORMAL;
    a02a:	2200      	movs	r2, #0
    a02c:	4b05      	ldr	r3, [pc, #20]	; (a044 <at_uart_change_config_timeout_callback+0x54>)
    a02e:	701a      	strb	r2, [r3, #0]
    non_os_exit_critical();
    a030:	f00e f8d4 	bl	181dc <non_os_exit_critical>
}
    a034:	bd10      	pop	{r4, pc}
    a036:	46c0      	nop			; (mov r8, r8)
    a038:	010019b4 	.word	0x010019b4
    a03c:	010019c0 	.word	0x010019c0
    a040:	010024ac 	.word	0x010024ac
    a044:	010019a9 	.word	0x010019a9

0000a048 <at_uart_switch_to_ppp>:

void at_uart_switch_to_ppp(void)
{
    a048:	b510      	push	{r4, lr}
#ifdef LIBPPP
    non_os_enter_critical();
    a04a:	f00e f8b3 	bl	181b4 <non_os_enter_critical>
    if (at_uart_config_status == AT_UART_CONFIG_STATUS_START_PPP)
    a04e:	4b0c      	ldr	r3, [pc, #48]	; (a080 <at_uart_switch_to_ppp+0x38>)
    a050:	781a      	ldrb	r2, [r3, #0]
    a052:	2a04      	cmp	r2, #4
    a054:	d110      	bne.n	a078 <at_uart_switch_to_ppp+0x30>
    {
        at_uart_config_status = AT_UART_CONFIG_STATUS_IN_PPP;
    a056:	3201      	adds	r2, #1
    a058:	701a      	strb	r2, [r3, #0]
        non_os_exit_critical();
    a05a:	f00e f8bf 	bl	181dc <non_os_exit_critical>
        at_uart_deinit();
    a05e:	f7ff ff2f 	bl	9ec0 <at_uart_deinit>
        pppd_go();
    a062:	f013 fd87 	bl	1db74 <pppd_go>
    if (!at_uart_stop_sleep_vote_flag)
    a066:	4b07      	ldr	r3, [pc, #28]	; (a084 <at_uart_switch_to_ppp+0x3c>)
    a068:	781a      	ldrb	r2, [r3, #0]
    a06a:	2a00      	cmp	r2, #0
    a06c:	d103      	bne.n	a076 <at_uart_switch_to_ppp+0x2e>
        at_uart_stop_sleep_vote_flag = true;
    a06e:	3201      	adds	r2, #1
    a070:	701a      	strb	r2, [r3, #0]
        osAddStopClocksVeto();
    a072:	f00a fdc7 	bl	14c04 <osAddStopClocksVeto>
        at_uart_disable_deep_sleep();   // Ensure deep sleep is veto'd now that a HP UART is being used
        return;
    }
    non_os_exit_critical();
#endif
}
    a076:	bd10      	pop	{r4, pc}
    non_os_exit_critical();
    a078:	f00e f8b0 	bl	181dc <non_os_exit_critical>
    a07c:	e7fb      	b.n	a076 <at_uart_switch_to_ppp+0x2e>
    a07e:	46c0      	nop			; (mov r8, r8)
    a080:	010019a9 	.word	0x010019a9
    a084:	010024a8 	.word	0x010024a8

0000a088 <at_uart_should_restart_at>:

/**
 * reinit uart and reset state to AT_UART_CONFIG_STATUS_NORMAL if we're in AT_UART_CONFIG_STATUS_START_AT
 */
bool at_uart_should_restart_at(void)
{
    a088:	b510      	push	{r4, lr}
    if (at_uart_config_status == AT_UART_CONFIG_STATUS_START_AT)
    a08a:	4b05      	ldr	r3, [pc, #20]	; (a0a0 <at_uart_should_restart_at+0x18>)
    {
        at_uart_reinit(true);
        return true;
    }
    return false;
    a08c:	2000      	movs	r0, #0
    if (at_uart_config_status == AT_UART_CONFIG_STATUS_START_AT)
    a08e:	781b      	ldrb	r3, [r3, #0]
    a090:	2b06      	cmp	r3, #6
    a092:	d103      	bne.n	a09c <at_uart_should_restart_at+0x14>
        at_uart_reinit(true);
    a094:	3001      	adds	r0, #1
    a096:	f7ff fc31 	bl	98fc <at_uart_reinit>
        return true;
    a09a:	2001      	movs	r0, #1
}
    a09c:	bd10      	pop	{r4, pc}
    a09e:	46c0      	nop			; (mov r8, r8)
    a0a0:	010019a9 	.word	0x010019a9

0000a0a4 <at_uart_baud_rate_valid_check>:

bool at_uart_baud_rate_valid_check(uint32 baud_rate, bool* high_speed)
{
    a0a4:	b5f0      	push	{r4, r5, r6, r7, lr}
    a0a6:	b089      	sub	sp, #36	; 0x24
    const AT_UART_BAUD_RATE valid_baud_rate[] ={AT_UART_BAUD_RATE_2400, AT_UART_BAUD_RATE_4800, AT_UART_BAUD_RATE_9600, AT_UART_BAUD_RATE_57600, AT_UART_BAUD_RATE_115200,
    a0a8:	466c      	mov	r4, sp
    a0aa:	0022      	movs	r2, r4
    a0ac:	4b0d      	ldr	r3, [pc, #52]	; (a0e4 <at_uart_baud_rate_valid_check+0x40>)
    a0ae:	cbe0      	ldmia	r3!, {r5, r6, r7}
    a0b0:	c2e0      	stmia	r2!, {r5, r6, r7}
    a0b2:	cbe0      	ldmia	r3!, {r5, r6, r7}
    a0b4:	c2e0      	stmia	r2!, {r5, r6, r7}
    a0b6:	cb60      	ldmia	r3!, {r5, r6}
    a0b8:	c260      	stmia	r2!, {r5, r6}
        AT_UART_BAUD_RATE_230400, AT_UART_BAUD_RATE_460800, AT_UART_BAUD_RATE_921600};

    if (baud_rate <= AT_UART_BAUD_RATE_57600)
    a0ba:	23e1      	movs	r3, #225	; 0xe1
    a0bc:	021b      	lsls	r3, r3, #8
    a0be:	4298      	cmp	r0, r3
    a0c0:	d80c      	bhi.n	a0dc <at_uart_baud_rate_valid_check+0x38>
    {
        (*high_speed) = false;
    a0c2:	2300      	movs	r3, #0
    }
    else
    {
        (*high_speed) = true;
    a0c4:	700b      	strb	r3, [r1, #0]
{
    a0c6:	2300      	movs	r3, #0
    }

    for (uint8 i = 0; i < sizeof(valid_baud_rate)/sizeof(AT_UART_BAUD_RATE); i++)
    {
        if (valid_baud_rate[i] == baud_rate)
    a0c8:	009a      	lsls	r2, r3, #2
    a0ca:	58a2      	ldr	r2, [r4, r2]
    a0cc:	4282      	cmp	r2, r0
    a0ce:	d007      	beq.n	a0e0 <at_uart_baud_rate_valid_check+0x3c>
    a0d0:	3301      	adds	r3, #1
    for (uint8 i = 0; i < sizeof(valid_baud_rate)/sizeof(AT_UART_BAUD_RATE); i++)
    a0d2:	2b08      	cmp	r3, #8
    a0d4:	d1f8      	bne.n	a0c8 <at_uart_baud_rate_valid_check+0x24>
        {
            return true;
        }
    }
    return false;
    a0d6:	2000      	movs	r0, #0
}
    a0d8:	b009      	add	sp, #36	; 0x24
    a0da:	bdf0      	pop	{r4, r5, r6, r7, pc}
        (*high_speed) = true;
    a0dc:	2301      	movs	r3, #1
    a0de:	e7f1      	b.n	a0c4 <at_uart_baud_rate_valid_check+0x20>
            return true;
    a0e0:	2001      	movs	r0, #1
    a0e2:	e7f9      	b.n	a0d8 <at_uart_baud_rate_valid_check+0x34>
    a0e4:	000229b8 	.word	0x000229b8

0000a0e8 <at_parse_char_to_hex>:
        return (hex - 0x0a) + 'A';
    }
}

static bool at_parse_char_to_hex(uint8 character, uint8 *hex)
{
    a0e8:	0003      	movs	r3, r0
    if (hex == NULL)
    {
        return false;
    }

    if((character >= '0') && (character <= '9'))
    a0ea:	3830      	subs	r0, #48	; 0x30
    a0ec:	b2c0      	uxtb	r0, r0
    a0ee:	2809      	cmp	r0, #9
    a0f0:	d905      	bls.n	a0fe <at_parse_char_to_hex+0x16>
    {
        temp_hex = character - '0';
    }
    else if((character >= 'a') && (character <= 'f'))
    a0f2:	001a      	movs	r2, r3
    a0f4:	3a61      	subs	r2, #97	; 0x61
    a0f6:	2a05      	cmp	r2, #5
    a0f8:	d804      	bhi.n	a104 <at_parse_char_to_hex+0x1c>
    {
        temp_hex = (character - 'a') + 10;
    a0fa:	3b57      	subs	r3, #87	; 0x57
    }
    else if((character >= 'A') && (character <= 'F'))
    {
        temp_hex = (character - 'A') + 10;
    a0fc:	b2d8      	uxtb	r0, r3
    }
    else
    {
        return false;
    }
    *hex = temp_hex;
    a0fe:	7008      	strb	r0, [r1, #0]
    return true;
    a100:	2001      	movs	r0, #1
}
    a102:	4770      	bx	lr
    else if((character >= 'A') && (character <= 'F'))
    a104:	001a      	movs	r2, r3
    a106:	3a41      	subs	r2, #65	; 0x41
        return false;
    a108:	2000      	movs	r0, #0
    else if((character >= 'A') && (character <= 'F'))
    a10a:	2a05      	cmp	r2, #5
    a10c:	d8f9      	bhi.n	a102 <at_parse_char_to_hex+0x1a>
        temp_hex = (character - 'A') + 10;
    a10e:	3b37      	subs	r3, #55	; 0x37
    a110:	e7f4      	b.n	a0fc <at_parse_char_to_hex+0x14>

0000a112 <at_get_cmd_length>:
{
    a112:	b530      	push	{r4, r5, lr}
    a114:	1e01      	subs	r1, r0, #0
    if(!p_str)
    a116:	d00a      	beq.n	a12e <at_get_cmd_length+0x1c>
    a118:	2300      	movs	r3, #0
            in_double_quotes = !in_double_quotes;
    a11a:	2501      	movs	r5, #1
    bool in_double_quotes = false;
    a11c:	001a      	movs	r2, r3
    while(*p_str && (*p_str != AT_CMD_SEPARATOR || in_double_quotes))
    a11e:	5ccc      	ldrb	r4, [r1, r3]
    a120:	b298      	uxth	r0, r3
    a122:	2c00      	cmp	r4, #0
    a124:	d003      	beq.n	a12e <at_get_cmd_length+0x1c>
    a126:	2c3b      	cmp	r4, #59	; 0x3b
    a128:	d102      	bne.n	a130 <at_get_cmd_length+0x1e>
    a12a:	2a00      	cmp	r2, #0
    a12c:	d103      	bne.n	a136 <at_get_cmd_length+0x24>
}
    a12e:	bd30      	pop	{r4, r5, pc}
        if (*p_str == AT_CMD_DOUBLE_QUOTATION)
    a130:	2c22      	cmp	r4, #34	; 0x22
    a132:	d100      	bne.n	a136 <at_get_cmd_length+0x24>
            in_double_quotes = !in_double_quotes;
    a134:	406a      	eors	r2, r5
    a136:	3301      	adds	r3, #1
    a138:	e7f1      	b.n	a11e <at_get_cmd_length+0xc>

0000a13a <at_parse_buf_to_hex_forward_order>:

bool at_parse_buf_to_hex_forward_order(const uint8* source_buf, uint8* dest_buf_hex, uint16 source_length)
{
    a13a:	b570      	push	{r4, r5, r6, lr}
    a13c:	1e05      	subs	r5, r0, #0
    uint16 i;
    uint8  temp_ch;

    if ((source_buf == NULL) || (dest_buf_hex == NULL) || (source_length == 0))
    a13e:	d00a      	beq.n	a156 <at_parse_buf_to_hex_forward_order+0x1c>
    {
        return false;
    a140:	1e08      	subs	r0, r1, #0
    if ((source_buf == NULL) || (dest_buf_hex == NULL) || (source_length == 0))
    a142:	d008      	beq.n	a156 <at_parse_buf_to_hex_forward_order+0x1c>
        return false;
    a144:	2000      	movs	r0, #0
    if ((source_buf == NULL) || (dest_buf_hex == NULL) || (source_length == 0))
    a146:	4282      	cmp	r2, r0
    a148:	d005      	beq.n	a156 <at_parse_buf_to_hex_forward_order+0x1c>
    a14a:	0003      	movs	r3, r0
    for (i = 0; i < source_length; i++)
    {
        temp_ch = source_buf[i] >> 4;
        dest_buf_hex[2 * i] = at_parse_hex_to_char(temp_ch);

        temp_ch = (source_buf[i] & 0x0f);
    a14c:	300f      	adds	r0, #15
    for (i = 0; i < source_length; i++)
    a14e:	b29c      	uxth	r4, r3
    a150:	42a2      	cmp	r2, r4
    a152:	d801      	bhi.n	a158 <at_parse_buf_to_hex_forward_order+0x1e>
    a154:	2001      	movs	r0, #1
        dest_buf_hex[2 * i + 1] = at_parse_hex_to_char(temp_ch);
    }
    return true;
}
    a156:	bd70      	pop	{r4, r5, r6, pc}
        temp_ch = source_buf[i] >> 4;
    a158:	5cec      	ldrb	r4, [r5, r3]
    a15a:	0924      	lsrs	r4, r4, #4
        return (hex - 0x0a) + 'A';
    a15c:	0026      	movs	r6, r4
    a15e:	3637      	adds	r6, #55	; 0x37
    if(hex < 10)
    a160:	2c09      	cmp	r4, #9
    a162:	d801      	bhi.n	a168 <at_parse_buf_to_hex_forward_order+0x2e>
        return hex + '0';
    a164:	3430      	adds	r4, #48	; 0x30
    a166:	0026      	movs	r6, r4
        dest_buf_hex[2 * i] = at_parse_hex_to_char(temp_ch);
    a168:	700e      	strb	r6, [r1, #0]
        temp_ch = (source_buf[i] & 0x0f);
    a16a:	5cec      	ldrb	r4, [r5, r3]
    a16c:	4004      	ands	r4, r0
        return (hex - 0x0a) + 'A';
    a16e:	0026      	movs	r6, r4
    a170:	3637      	adds	r6, #55	; 0x37
    if(hex < 10)
    a172:	2c09      	cmp	r4, #9
    a174:	d801      	bhi.n	a17a <at_parse_buf_to_hex_forward_order+0x40>
        return hex + '0';
    a176:	3430      	adds	r4, #48	; 0x30
    a178:	0026      	movs	r6, r4
        dest_buf_hex[2 * i + 1] = at_parse_hex_to_char(temp_ch);
    a17a:	704e      	strb	r6, [r1, #1]
    a17c:	3301      	adds	r3, #1
    a17e:	3102      	adds	r1, #2
    a180:	e7e5      	b.n	a14e <at_parse_buf_to_hex_forward_order+0x14>

0000a182 <at_parse_buf_hex_to_uint8>:
    }
    return true;
}

bool at_parse_buf_hex_to_uint8(const uint8* source_buf_hex, uint8* dest_buf, uint16 source_length)
{
    a182:	b5f0      	push	{r4, r5, r6, r7, lr}
    a184:	b085      	sub	sp, #20
    a186:	0006      	movs	r6, r0
    a188:	000f      	movs	r7, r1
    a18a:	9201      	str	r2, [sp, #4]
    uint16 i;
    uint8 hex;

    if ((source_buf_hex == NULL) || (dest_buf == NULL) || ((source_length % 2) != 0))
    a18c:	2800      	cmp	r0, #0
    a18e:	d102      	bne.n	a196 <at_parse_buf_hex_to_uint8+0x14>
    {
        return false;
    a190:	2000      	movs	r0, #0
        dest_buf[i / 2] |= hex;
        i++;
    }
    return true;

}
    a192:	b005      	add	sp, #20
    a194:	bdf0      	pop	{r4, r5, r6, r7, pc}
    if ((source_buf_hex == NULL) || (dest_buf == NULL) || ((source_length % 2) != 0))
    a196:	2900      	cmp	r1, #0
    a198:	d0fa      	beq.n	a190 <at_parse_buf_hex_to_uint8+0xe>
    a19a:	2401      	movs	r4, #1
    a19c:	9b01      	ldr	r3, [sp, #4]
    a19e:	401c      	ands	r4, r3
    a1a0:	d1f6      	bne.n	a190 <at_parse_buf_hex_to_uint8+0xe>
    for (i = 0; i < source_length;)
    a1a2:	9b01      	ldr	r3, [sp, #4]
    a1a4:	429c      	cmp	r4, r3
    a1a6:	d301      	bcc.n	a1ac <at_parse_buf_hex_to_uint8+0x2a>
    return true;
    a1a8:	2001      	movs	r0, #1
    a1aa:	e7f2      	b.n	a192 <at_parse_buf_hex_to_uint8+0x10>
        if (at_parse_char_to_hex(*(source_buf_hex + i), &hex) == false)
    a1ac:	ab02      	add	r3, sp, #8
    a1ae:	1ddd      	adds	r5, r3, #7
    a1b0:	5d30      	ldrb	r0, [r6, r4]
    a1b2:	0029      	movs	r1, r5
    a1b4:	f7ff ff98 	bl	a0e8 <at_parse_char_to_hex>
    a1b8:	2800      	cmp	r0, #0
    a1ba:	d0e9      	beq.n	a190 <at_parse_buf_hex_to_uint8+0xe>
        dest_buf[i / 2] = (uint8)(hex << 4);
    a1bc:	782a      	ldrb	r2, [r5, #0]
    a1be:	0863      	lsrs	r3, r4, #1
    a1c0:	0112      	lsls	r2, r2, #4
    a1c2:	54fa      	strb	r2, [r7, r3]
        i++;
    a1c4:	1c63      	adds	r3, r4, #1
    a1c6:	b29b      	uxth	r3, r3
        if (at_parse_char_to_hex(*(source_buf_hex + i), &hex) == false)
    a1c8:	5cf0      	ldrb	r0, [r6, r3]
    a1ca:	0029      	movs	r1, r5
        i++;
    a1cc:	9300      	str	r3, [sp, #0]
        if (at_parse_char_to_hex(*(source_buf_hex + i), &hex) == false)
    a1ce:	f7ff ff8b 	bl	a0e8 <at_parse_char_to_hex>
    a1d2:	2800      	cmp	r0, #0
    a1d4:	d0dc      	beq.n	a190 <at_parse_buf_hex_to_uint8+0xe>
        dest_buf[i / 2] |= hex;
    a1d6:	9b00      	ldr	r3, [sp, #0]
    a1d8:	7829      	ldrb	r1, [r5, #0]
    a1da:	085b      	lsrs	r3, r3, #1
    a1dc:	18fb      	adds	r3, r7, r3
    a1de:	781a      	ldrb	r2, [r3, #0]
        i++;
    a1e0:	3402      	adds	r4, #2
        dest_buf[i / 2] |= hex;
    a1e2:	430a      	orrs	r2, r1
    a1e4:	701a      	strb	r2, [r3, #0]
        i++;
    a1e6:	b2a4      	uxth	r4, r4
    a1e8:	e7db      	b.n	a1a2 <at_parse_buf_hex_to_uint8+0x20>

0000a1ea <at_parse_buf_hex_to_uint16>:

bool at_parse_buf_hex_to_uint16(const uint8* source_buf_hex, uint16 *dest_value, uint16 source_length)
{
    a1ea:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
    uint16 i;
    uint8  nible = 0;
    a1ec:	466b      	mov	r3, sp
    a1ee:	1ddf      	adds	r7, r3, #7
    a1f0:	2300      	movs	r3, #0
{
    a1f2:	000d      	movs	r5, r1
    uint8  nible = 0;
    a1f4:	703b      	strb	r3, [r7, #0]

    if ((source_buf_hex == NULL) || (dest_value == NULL))
    a1f6:	4298      	cmp	r0, r3
    a1f8:	d101      	bne.n	a1fe <at_parse_buf_hex_to_uint16+0x14>
    {
        return false;
    a1fa:	2000      	movs	r0, #0
        }

        *dest_value = (uint16)(*dest_value << 4) + (uint16)nible;
    }
    return true;
}
    a1fc:	bdfe      	pop	{r1, r2, r3, r4, r5, r6, r7, pc}
    if ((source_buf_hex == NULL) || (dest_value == NULL))
    a1fe:	2900      	cmp	r1, #0
    a200:	d0fb      	beq.n	a1fa <at_parse_buf_hex_to_uint16+0x10>
    a202:	0004      	movs	r4, r0
    *dest_value = 0;
    a204:	800b      	strh	r3, [r1, #0]
    a206:	1886      	adds	r6, r0, r2
    for (i = 0; i < source_length; i++)
    a208:	42b4      	cmp	r4, r6
    a20a:	d101      	bne.n	a210 <at_parse_buf_hex_to_uint16+0x26>
    return true;
    a20c:	2001      	movs	r0, #1
    a20e:	e7f5      	b.n	a1fc <at_parse_buf_hex_to_uint16+0x12>
        if (at_parse_char_to_hex(*(source_buf_hex + i), &nible) == false)
    a210:	7820      	ldrb	r0, [r4, #0]
    a212:	0039      	movs	r1, r7
    a214:	f7ff ff68 	bl	a0e8 <at_parse_char_to_hex>
    a218:	3401      	adds	r4, #1
    a21a:	2800      	cmp	r0, #0
    a21c:	d0ed      	beq.n	a1fa <at_parse_buf_hex_to_uint16+0x10>
        *dest_value = (uint16)(*dest_value << 4) + (uint16)nible;
    a21e:	882a      	ldrh	r2, [r5, #0]
    a220:	783b      	ldrb	r3, [r7, #0]
    a222:	0112      	lsls	r2, r2, #4
    a224:	189b      	adds	r3, r3, r2
    a226:	802b      	strh	r3, [r5, #0]
    a228:	e7ee      	b.n	a208 <at_parse_buf_hex_to_uint16+0x1e>

0000a22a <at_parse_buf_hex_to_uint64>:

bool at_parse_buf_hex_to_uint64(const uint8* source_buf_hex, uint64 *dest_value, uint16 source_length)
{
    a22a:	b5f0      	push	{r4, r5, r6, r7, lr}
    a22c:	000d      	movs	r5, r1
    a22e:	b087      	sub	sp, #28
    uint16 i;
    uint8  nible = 0;

    if ((source_buf_hex == NULL) || (dest_value == NULL))
    a230:	2800      	cmp	r0, #0
    a232:	d102      	bne.n	a23a <at_parse_buf_hex_to_uint64+0x10>
    {
        return false;
    a234:	2000      	movs	r0, #0

        *dest_value = (uint64)(*dest_value << 4) + (uint64)nible;
    }

    return true;
}
    a236:	b007      	add	sp, #28
    a238:	bdf0      	pop	{r4, r5, r6, r7, pc}
    if ((source_buf_hex == NULL) || (dest_value == NULL))
    a23a:	2900      	cmp	r1, #0
    a23c:	d0fa      	beq.n	a234 <at_parse_buf_hex_to_uint64+0xa>
    *dest_value = 0;
    a23e:	2600      	movs	r6, #0
    a240:	2700      	movs	r7, #0
    a242:	0004      	movs	r4, r0
    a244:	600e      	str	r6, [r1, #0]
    a246:	604f      	str	r7, [r1, #4]
    a248:	1886      	adds	r6, r0, r2
    for (i = 0; i < source_length; i++)
    a24a:	42b4      	cmp	r4, r6
    a24c:	d101      	bne.n	a252 <at_parse_buf_hex_to_uint64+0x28>
    return true;
    a24e:	2001      	movs	r0, #1
    a250:	e7f1      	b.n	a236 <at_parse_buf_hex_to_uint64+0xc>
        nible = (uint8)(*(source_buf_hex + i));
    a252:	ab04      	add	r3, sp, #16
    a254:	7820      	ldrb	r0, [r4, #0]
    a256:	1ddf      	adds	r7, r3, #7
        if (at_parse_char_to_hex(*(source_buf_hex + i), &nible) == false)
    a258:	0039      	movs	r1, r7
        nible = (uint8)(*(source_buf_hex + i));
    a25a:	71d8      	strb	r0, [r3, #7]
        if (at_parse_char_to_hex(*(source_buf_hex + i), &nible) == false)
    a25c:	f7ff ff44 	bl	a0e8 <at_parse_char_to_hex>
    a260:	3401      	adds	r4, #1
    a262:	2800      	cmp	r0, #0
    a264:	d0e6      	beq.n	a234 <at_parse_buf_hex_to_uint64+0xa>
        *dest_value = (uint64)(*dest_value << 4) + (uint64)nible;
    a266:	682b      	ldr	r3, [r5, #0]
    a268:	6869      	ldr	r1, [r5, #4]
    a26a:	0f1a      	lsrs	r2, r3, #28
    a26c:	011b      	lsls	r3, r3, #4
    a26e:	9300      	str	r3, [sp, #0]
    a270:	783b      	ldrb	r3, [r7, #0]
    a272:	0109      	lsls	r1, r1, #4
    a274:	9302      	str	r3, [sp, #8]
    a276:	2300      	movs	r3, #0
    a278:	4311      	orrs	r1, r2
    a27a:	9101      	str	r1, [sp, #4]
    a27c:	9303      	str	r3, [sp, #12]
    a27e:	9802      	ldr	r0, [sp, #8]
    a280:	9903      	ldr	r1, [sp, #12]
    a282:	9a00      	ldr	r2, [sp, #0]
    a284:	9b01      	ldr	r3, [sp, #4]
    a286:	1812      	adds	r2, r2, r0
    a288:	414b      	adcs	r3, r1
    a28a:	602a      	str	r2, [r5, #0]
    a28c:	606b      	str	r3, [r5, #4]
    a28e:	e7dc      	b.n	a24a <at_parse_buf_hex_to_uint64+0x20>

0000a290 <at_parse_convert_neul_result>:

    return AT_RET_OK;
}

AT_RET at_parse_convert_neul_result(NEUL_RET result)
{
    a290:	2306      	movs	r3, #6
    a292:	282b      	cmp	r0, #43	; 0x2b
    a294:	d801      	bhi.n	a29a <at_parse_convert_neul_result+0xa>
    a296:	4b02      	ldr	r3, [pc, #8]	; (a2a0 <at_parse_convert_neul_result+0x10>)
    a298:	5c1b      	ldrb	r3, [r3, r0]
        case NEUL_RET_CONDITIONS_OF_USE_NOT_SATISFIED:
            return AT_RET_CONDITIONS_OF_USE_NOT_SATISFIED;
        default:
            return AT_RET_PROGRESS_ERROR;
    }
}
    a29a:	0018      	movs	r0, r3
    a29c:	4770      	bx	lr
    a29e:	46c0      	nop			; (mov r8, r8)
    a2a0:	0002346f 	.word	0x0002346f

0000a2a4 <at_parse_convert_sms_result>:

AT_RET at_parse_convert_sms_result(AT_RET result)
{
    a2a4:	2322      	movs	r3, #34	; 0x22
    a2a6:	2827      	cmp	r0, #39	; 0x27
    a2a8:	d801      	bhi.n	a2ae <at_parse_convert_sms_result+0xa>
    a2aa:	4b02      	ldr	r3, [pc, #8]	; (a2b4 <at_parse_convert_sms_result+0x10>)
    a2ac:	5c1b      	ldrb	r3, [r3, r0]
        case AT_RET_SMS_NO_CNMA_ACKNOWLEDGEMENT_EXPECTED:
            return AT_RET_SMS_NO_CNMA_ACKNOWLEDGEMENT_EXPECTED;
        default:
            return AT_RET_SMS_OPERATION_NOT_SUPPORTED;
    }
}
    a2ae:	0018      	movs	r0, r3
    a2b0:	4770      	bx	lr
    a2b2:	46c0      	nop			; (mov r8, r8)
    a2b4:	0002349b 	.word	0x0002349b

0000a2b8 <at_free_at_params>:

    return param_num;
}

void at_free_at_params(void)
{
    a2b8:	b510      	push	{r4, lr}
    if(app_at_param_table != NULL)
    a2ba:	4c09      	ldr	r4, [pc, #36]	; (a2e0 <at_free_at_params+0x28>)
    a2bc:	6823      	ldr	r3, [r4, #0]
    a2be:	2b00      	cmp	r3, #0
    a2c0:	d00c      	beq.n	a2dc <at_free_at_params+0x24>
    {
        if (app_at_param_table->params_array != NULL)
    a2c2:	6858      	ldr	r0, [r3, #4]
    a2c4:	2800      	cmp	r0, #0
    a2c6:	d004      	beq.n	a2d2 <at_free_at_params+0x1a>
        {
            at_free(app_at_param_table->params_array);
    a2c8:	f008 fbb6 	bl	12a38 <irfree>
    a2cc:	2200      	movs	r2, #0
    a2ce:	6823      	ldr	r3, [r4, #0]
    a2d0:	605a      	str	r2, [r3, #4]
        }
        at_free(app_at_param_table);
    a2d2:	6820      	ldr	r0, [r4, #0]
    a2d4:	f008 fbb0 	bl	12a38 <irfree>
    a2d8:	2300      	movs	r3, #0
    a2da:	6023      	str	r3, [r4, #0]
    }
}
    a2dc:	bd10      	pop	{r4, pc}
    a2de:	46c0      	nop			; (mov r8, r8)
    a2e0:	010024b4 	.word	0x010024b4

0000a2e4 <at_create_param_array>:

    return AT_RET_OK;
}

AT_RET at_create_param_array(uint8 *p_atparams_string, uint8 *p_param_num, uint8 param_minnum, uint8 param_maxnum)
{
    a2e4:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    a2e6:	0005      	movs	r5, r0
        return 0;
    a2e8:	1e04      	subs	r4, r0, #0
    if (p_atparams_string == NULL || *p_atparams_string == '\0')
    a2ea:	d00c      	beq.n	a306 <at_create_param_array+0x22>
        return 0;
    a2ec:	2400      	movs	r4, #0
    if (p_atparams_string == NULL || *p_atparams_string == '\0')
    a2ee:	7800      	ldrb	r0, [r0, #0]
    a2f0:	42a0      	cmp	r0, r4
    a2f2:	d008      	beq.n	a306 <at_create_param_array+0x22>
    bool     in_double_quotes = false;
    a2f4:	0020      	movs	r0, r4
    uint8    param_num = 1;
    a2f6:	3401      	adds	r4, #1
    if (p_atparams_string == NULL || *p_atparams_string == '\0')
    a2f8:	002f      	movs	r7, r5
            in_double_quotes = !in_double_quotes;
    a2fa:	46a4      	mov	ip, r4
    while ((*p_atparams_string != AT_CMD_END_MARK) && (*p_atparams_string != AT_CMD_SEPARATOR))
    a2fc:	783e      	ldrb	r6, [r7, #0]
    a2fe:	2e00      	cmp	r6, #0
    a300:	d001      	beq.n	a306 <at_create_param_array+0x22>
    a302:	2e3b      	cmp	r6, #59	; 0x3b
    a304:	d121      	bne.n	a34a <at_create_param_array+0x66>
    uint16      str_len = 0;
    AT_RET     cause = AT_RET_SYNTAX_ERROR;
    uint8       param_num;

    param_num = at_get_num_of_recv_params(p_atparams_string);
    *p_param_num = param_num;
    a306:	700c      	strb	r4, [r1, #0]
    if ((param_num < param_minnum) || (param_num > param_maxnum))
    {
        return AT_RET_INTERNAL_ERROR;
    a308:	200d      	movs	r0, #13
    if ((param_num < param_minnum) || (param_num > param_maxnum))
    a30a:	42a2      	cmp	r2, r4
    a30c:	d81c      	bhi.n	a348 <at_create_param_array+0x64>
    a30e:	42a3      	cmp	r3, r4
    a310:	d31a      	bcc.n	a348 <at_create_param_array+0x64>
    }

    app_at_param_table = at_alloc(sizeof(AT_PARAM_TABLE_s));
    a312:	3805      	subs	r0, #5
    a314:	f008 fb7e 	bl	12a14 <irzalloc>
    a318:	4e30      	ldr	r6, [pc, #192]	; (a3dc <at_create_param_array+0xf8>)
    a31a:	0007      	movs	r7, r0
    a31c:	6030      	str	r0, [r6, #0]
    if(app_at_param_table == NULL)
    {
        return AT_RET_MEMORY_ERROR;
    a31e:	2004      	movs	r0, #4
    if(app_at_param_table == NULL)
    a320:	2f00      	cmp	r7, #0
    a322:	d011      	beq.n	a348 <at_create_param_array+0x64>
    }

    app_at_param_table->param_count = param_num;
    app_at_param_table->params_array = at_alloc(sizeof(AT_PARAM_s) * param_num);
    a324:	3008      	adds	r0, #8
    app_at_param_table->param_count = param_num;
    a326:	703c      	strb	r4, [r7, #0]
    app_at_param_table->params_array = at_alloc(sizeof(AT_PARAM_s) * param_num);
    a328:	4360      	muls	r0, r4
    a32a:	f008 fb73 	bl	12a14 <irzalloc>
    a32e:	2300      	movs	r3, #0
    a330:	6078      	str	r0, [r7, #4]
    if(app_at_param_table->params_array == NULL && param_num != 0)
    a332:	6830      	ldr	r0, [r6, #0]
    a334:	6847      	ldr	r7, [r0, #4]
    a336:	429f      	cmp	r7, r3
    a338:	d126      	bne.n	a388 <at_create_param_array+0xa4>
    a33a:	003b      	movs	r3, r7
    a33c:	2c00      	cmp	r4, #0
    a33e:	d023      	beq.n	a388 <at_create_param_array+0xa4>
    {
        at_free(app_at_param_table);
    a340:	f008 fb7a 	bl	12a38 <irfree>
        return AT_RET_MEMORY_ERROR;
    a344:	2004      	movs	r0, #4
        at_free(app_at_param_table);
    a346:	6037      	str	r7, [r6, #0]
        }
        app_at_param_table->params_array[count].str_len = str_len;
    }

    return AT_RET_OK;
}
    a348:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
        if (*p_atparams_string == AT_CMD_DOUBLE_QUOTATION)
    a34a:	2e22      	cmp	r6, #34	; 0x22
    a34c:	d104      	bne.n	a358 <at_create_param_array+0x74>
            in_double_quotes = !in_double_quotes;
    a34e:	4666      	mov	r6, ip
    a350:	4070      	eors	r0, r6
    a352:	b2c0      	uxtb	r0, r0
        p_atparams_string++;
    a354:	3701      	adds	r7, #1
    a356:	e7d1      	b.n	a2fc <at_create_param_array+0x18>
        if ((AT_CMD_PARAM_SEPARATOR == *p_atparams_string) && (!in_double_quotes))
    a358:	2e2c      	cmp	r6, #44	; 0x2c
    a35a:	d1fb      	bne.n	a354 <at_create_param_array+0x70>
    a35c:	2800      	cmp	r0, #0
    a35e:	d1f9      	bne.n	a354 <at_create_param_array+0x70>
            param_num++;
    a360:	3401      	adds	r4, #1
    a362:	b2e4      	uxtb	r4, r4
    a364:	e7f6      	b.n	a354 <at_create_param_array+0x70>
        at_init_param(&(app_at_param_table->params_array[count]));
    a366:	0032      	movs	r2, r6
    a368:	435a      	muls	r2, r3
    a36a:	6847      	ldr	r7, [r0, #4]
    a36c:	3301      	adds	r3, #1
    a36e:	18ba      	adds	r2, r7, r2
    p_param->str = NULL;
    a370:	6051      	str	r1, [r2, #4]
    p_param->str_len = 0;
    a372:	8111      	strh	r1, [r2, #8]
    p_param->is_in_double_quotes = false;
    a374:	7011      	strb	r1, [r2, #0]
    for(count = 0; count < param_num; count++)
    a376:	b2da      	uxtb	r2, r3
    a378:	42a2      	cmp	r2, r4
    a37a:	d3f4      	bcc.n	a366 <at_create_param_array+0x82>
    a37c:	2100      	movs	r1, #0
    for(count = 0; count < param_num; count++)
    a37e:	b2cb      	uxtb	r3, r1
    a380:	42a3      	cmp	r3, r4
    a382:	d323      	bcc.n	a3cc <at_create_param_array+0xe8>
    return AT_RET_OK;
    a384:	2000      	movs	r0, #0
    a386:	e7df      	b.n	a348 <at_create_param_array+0x64>
        at_init_param(&(app_at_param_table->params_array[count]));
    a388:	260c      	movs	r6, #12
    p_param->str = NULL;
    a38a:	2100      	movs	r1, #0
    a38c:	e7f3      	b.n	a376 <at_create_param_array+0x92>
        if (*s == AT_CMD_DOUBLE_QUOTATION)
    a38e:	2e22      	cmp	r6, #34	; 0x22
    a390:	d103      	bne.n	a39a <at_create_param_array+0xb6>
            in_double_quotes = !in_double_quotes;
    a392:	4662      	mov	r2, ip
    a394:	3e21      	subs	r6, #33	; 0x21
    a396:	4072      	eors	r2, r6
    a398:	4694      	mov	ip, r2
        s++;
    a39a:	3301      	adds	r3, #1
    while (((in_double_quotes) || (*s != seperate)) && (*s != AT_CMD_END_MARK))
    a39c:	4667      	mov	r7, ip
    a39e:	1b5a      	subs	r2, r3, r5
    a3a0:	b292      	uxth	r2, r2
    a3a2:	781e      	ldrb	r6, [r3, #0]
    a3a4:	2f00      	cmp	r7, #0
    a3a6:	d101      	bne.n	a3ac <at_create_param_array+0xc8>
    a3a8:	2e2c      	cmp	r6, #44	; 0x2c
    a3aa:	d015      	beq.n	a3d8 <at_create_param_array+0xf4>
    a3ac:	2e00      	cmp	r6, #0
    a3ae:	d1ee      	bne.n	a38e <at_create_param_array+0xaa>
    a3b0:	260c      	movs	r6, #12
    a3b2:	434e      	muls	r6, r1
    a3b4:	46b4      	mov	ip, r6
    a3b6:	6846      	ldr	r6, [r0, #4]
    a3b8:	4466      	add	r6, ip
        if (str_len == 0)
    a3ba:	2a00      	cmp	r2, #0
    a3bc:	d10a      	bne.n	a3d4 <at_create_param_array+0xf0>
            app_at_param_table->params_array[count].str = NULL;
    a3be:	6072      	str	r2, [r6, #4]
        app_at_param_table->params_array[count].str_len = str_len;
    a3c0:	6845      	ldr	r5, [r0, #4]
    a3c2:	3101      	adds	r1, #1
    a3c4:	4465      	add	r5, ip
    a3c6:	812a      	strh	r2, [r5, #8]
    *source = s;
    a3c8:	001d      	movs	r5, r3
    a3ca:	e7d8      	b.n	a37e <at_create_param_array+0x9a>
    bool     in_double_quotes = false;
    a3cc:	2200      	movs	r2, #0
    s = *source;
    a3ce:	002b      	movs	r3, r5
    bool     in_double_quotes = false;
    a3d0:	4694      	mov	ip, r2
    a3d2:	e7e3      	b.n	a39c <at_create_param_array+0xb8>
            app_at_param_table->params_array[count].str = s;
    a3d4:	6075      	str	r5, [r6, #4]
    a3d6:	e7f3      	b.n	a3c0 <at_create_param_array+0xdc>
        s++; // skip comma
    a3d8:	3301      	adds	r3, #1
    a3da:	e7e9      	b.n	a3b0 <at_create_param_array+0xcc>
    a3dc:	010024b4 	.word	0x010024b4

0000a3e0 <at_check_hex_string_prefix>:

    return cause;
}

bool at_check_hex_string_prefix(const uint8 *p_string, uint16 str_len)
{
    a3e0:	b510      	push	{r4, lr}
    a3e2:	0004      	movs	r4, r0
        {
            return true;
        }
    }

    return false;
    a3e4:	2000      	movs	r0, #0
    if((str_len > AT_CMD_HEX_PREFIX_LENGTH) && (p_string != NULL))
    a3e6:	2902      	cmp	r1, #2
    a3e8:	d912      	bls.n	a410 <at_check_hex_string_prefix+0x30>
    a3ea:	4284      	cmp	r4, r0
    a3ec:	d010      	beq.n	a410 <at_check_hex_string_prefix+0x30>
        if ((memcmp(p_string, AT_CMD_HEX_PREFIX_1,AT_CMD_HEX_PREFIX_LENGTH) == 0) || (memcmp(p_string, AT_CMD_HEX_PREFIX_2,AT_CMD_HEX_PREFIX_LENGTH) == 0))
    a3ee:	2202      	movs	r2, #2
    a3f0:	4908      	ldr	r1, [pc, #32]	; (a414 <at_check_hex_string_prefix+0x34>)
    a3f2:	0020      	movs	r0, r4
    a3f4:	f010 ff6a 	bl	1b2cc <memcmp>
    a3f8:	0003      	movs	r3, r0
            return true;
    a3fa:	2001      	movs	r0, #1
        if ((memcmp(p_string, AT_CMD_HEX_PREFIX_1,AT_CMD_HEX_PREFIX_LENGTH) == 0) || (memcmp(p_string, AT_CMD_HEX_PREFIX_2,AT_CMD_HEX_PREFIX_LENGTH) == 0))
    a3fc:	2b00      	cmp	r3, #0
    a3fe:	d007      	beq.n	a410 <at_check_hex_string_prefix+0x30>
    a400:	2202      	movs	r2, #2
    a402:	4905      	ldr	r1, [pc, #20]	; (a418 <at_check_hex_string_prefix+0x38>)
    a404:	0020      	movs	r0, r4
    a406:	f010 ff61 	bl	1b2cc <memcmp>
    a40a:	4243      	negs	r3, r0
    a40c:	4158      	adcs	r0, r3
    a40e:	b2c0      	uxtb	r0, r0
}
    a410:	bd10      	pop	{r4, pc}
    a412:	46c0      	nop			; (mov r8, r8)
    a414:	000234c3 	.word	0x000234c3
    a418:	000234c6 	.word	0x000234c6

0000a41c <at_get_uint32_param>:
{
    a41c:	b5f0      	push	{r4, r5, r6, r7, lr}
    if( seqno >= app_at_param_table->param_count)
    a41e:	4b39      	ldr	r3, [pc, #228]	; (a504 <at_get_uint32_param+0xe8>)
{
    a420:	000e      	movs	r6, r1
    if( seqno >= app_at_param_table->param_count)
    a422:	6819      	ldr	r1, [r3, #0]
{
    a424:	b085      	sub	sp, #20
    if( seqno >= app_at_param_table->param_count)
    a426:	780c      	ldrb	r4, [r1, #0]
        return AT_RET_PARAM_MISSING;
    a428:	2303      	movs	r3, #3
    if( seqno >= app_at_param_table->param_count)
    a42a:	4284      	cmp	r4, r0
    a42c:	d934      	bls.n	a498 <at_get_uint32_param+0x7c>
    if(app_at_param_table->params_array[seqno].str == NULL)
    a42e:	3309      	adds	r3, #9
    a430:	4343      	muls	r3, r0
    a432:	6848      	ldr	r0, [r1, #4]
    a434:	18c0      	adds	r0, r0, r3
    a436:	6844      	ldr	r4, [r0, #4]
    a438:	2c00      	cmp	r4, #0
    a43a:	d106      	bne.n	a44a <at_get_uint32_param+0x2e>
        return AT_RET_PARAM_MISSING;
    a43c:	2303      	movs	r3, #3
        if(mandatory)
    a43e:	2a00      	cmp	r2, #0
    a440:	d12a      	bne.n	a498 <at_get_uint32_param+0x7c>
            *p_uint32 = AT_INT32_NO_VALUE;
    a442:	3b04      	subs	r3, #4
    *p_val = value;
    a444:	6033      	str	r3, [r6, #0]
    return AT_RET_OK;
    a446:	2300      	movs	r3, #0
    a448:	e026      	b.n	a498 <at_get_uint32_param+0x7c>
        if(at_check_hex_string_prefix(app_at_param_table->params_array[seqno].str, app_at_param_table->params_array[seqno].str_len))
    a44a:	8905      	ldrh	r5, [r0, #8]
    a44c:	0020      	movs	r0, r4
    a44e:	0029      	movs	r1, r5
    a450:	f7ff ffc6 	bl	a3e0 <at_check_hex_string_prefix>
    a454:	1e07      	subs	r7, r0, #0
    a456:	d043      	beq.n	a4e0 <at_get_uint32_param+0xc4>
            return at_parse_hex_uint32(app_at_param_table->params_array[seqno].str + AT_CMD_HEX_PREFIX_LENGTH, p_uint32, app_at_param_table->params_array[seqno].str_len - AT_CMD_HEX_PREFIX_LENGTH);
    a458:	1ca2      	adds	r2, r4, #2
        return AT_RET_INTERNAL_ERROR;
    a45a:	230d      	movs	r3, #13
    if ((p_str == NULL) || (p_val == NULL))
    a45c:	2a00      	cmp	r2, #0
    a45e:	d01b      	beq.n	a498 <at_get_uint32_param+0x7c>
    a460:	2e00      	cmp	r6, #0
    a462:	d019      	beq.n	a498 <at_get_uint32_param+0x7c>
        if (!isxdigit(*p_temp_string))      //lint !e866
    a464:	2044      	movs	r0, #68	; 0x44
    a466:	4f28      	ldr	r7, [pc, #160]	; (a508 <at_get_uint32_param+0xec>)
    a468:	6839      	ldr	r1, [r7, #0]
    while ((*p_temp_string != AT_CMD_END_MARK) && (*p_temp_string != AT_CMD_PARAM_SEPARATOR) && (*p_temp_string != AT_CMD_SEPARATOR))
    a46a:	7813      	ldrb	r3, [r2, #0]
    a46c:	2b00      	cmp	r3, #0
    a46e:	d001      	beq.n	a474 <at_get_uint32_param+0x58>
    a470:	2b2c      	cmp	r3, #44	; 0x2c
    a472:	d114      	bne.n	a49e <at_get_uint32_param+0x82>
            return at_parse_hex_uint32(app_at_param_table->params_array[seqno].str + AT_CMD_HEX_PREFIX_LENGTH, p_uint32, app_at_param_table->params_array[seqno].str_len - AT_CMD_HEX_PREFIX_LENGTH);
    a474:	3d02      	subs	r5, #2
    a476:	b2ab      	uxth	r3, r5
    a478:	2500      	movs	r5, #0
    a47a:	9300      	str	r3, [sp, #0]
    a47c:	002b      	movs	r3, r5
    while (i < str_len)
    a47e:	9900      	ldr	r1, [sp, #0]
    a480:	b2ea      	uxtb	r2, r5
    a482:	428a      	cmp	r2, r1
    a484:	d2de      	bcs.n	a444 <at_get_uint32_param+0x28>
        if(!isxdigit(*p_str))               //lint !e866
    a486:	2144      	movs	r1, #68	; 0x44
    a488:	1962      	adds	r2, r4, r5
    a48a:	7890      	ldrb	r0, [r2, #2]
    a48c:	683a      	ldr	r2, [r7, #0]
    a48e:	1812      	adds	r2, r2, r0
    a490:	7852      	ldrb	r2, [r2, #1]
    a492:	420a      	tst	r2, r1
    a494:	d10b      	bne.n	a4ae <at_get_uint32_param+0x92>
            return AT_RET_SYNTAX_ERROR;
    a496:	2301      	movs	r3, #1
}
    a498:	0018      	movs	r0, r3
    a49a:	b005      	add	sp, #20
    a49c:	bdf0      	pop	{r4, r5, r6, r7, pc}
    while ((*p_temp_string != AT_CMD_END_MARK) && (*p_temp_string != AT_CMD_PARAM_SEPARATOR) && (*p_temp_string != AT_CMD_SEPARATOR))
    a49e:	2b3b      	cmp	r3, #59	; 0x3b
    a4a0:	d0e8      	beq.n	a474 <at_get_uint32_param+0x58>
        if (!isxdigit(*p_temp_string))      //lint !e866
    a4a2:	18cb      	adds	r3, r1, r3
    a4a4:	785b      	ldrb	r3, [r3, #1]
    a4a6:	4203      	tst	r3, r0
    a4a8:	d018      	beq.n	a4dc <at_get_uint32_param+0xc0>
        p_temp_string++;
    a4aa:	3201      	adds	r2, #1
    a4ac:	e7dd      	b.n	a46a <at_get_uint32_param+0x4e>
        value = (uint32)(value << 4);
    a4ae:	011b      	lsls	r3, r3, #4
        if (at_parse_char_to_hex(*p_str, &value1) == false)
    a4b0:	a903      	add	r1, sp, #12
        value = (uint32)(value << 4);
    a4b2:	9301      	str	r3, [sp, #4]
        if (at_parse_char_to_hex(*p_str, &value1) == false)
    a4b4:	f7ff fe18 	bl	a0e8 <at_parse_char_to_hex>
    a4b8:	2800      	cmp	r0, #0
    a4ba:	d0ec      	beq.n	a496 <at_get_uint32_param+0x7a>
        value  += value1;
    a4bc:	ab02      	add	r3, sp, #8
    a4be:	791a      	ldrb	r2, [r3, #4]
    a4c0:	9b01      	ldr	r3, [sp, #4]
    a4c2:	189b      	adds	r3, r3, r2
        if( (value < value1) || ((value == 0xFFFFFFFF) && (i != str_len - 1)))
    a4c4:	429a      	cmp	r2, r3
    a4c6:	d8e6      	bhi.n	a496 <at_get_uint32_param+0x7a>
    a4c8:	1c5a      	adds	r2, r3, #1
    a4ca:	d105      	bne.n	a4d8 <at_get_uint32_param+0xbc>
    a4cc:	9a00      	ldr	r2, [sp, #0]
    a4ce:	1e51      	subs	r1, r2, #1
    a4d0:	22ff      	movs	r2, #255	; 0xff
    a4d2:	402a      	ands	r2, r5
    a4d4:	428a      	cmp	r2, r1
    a4d6:	d1de      	bne.n	a496 <at_get_uint32_param+0x7a>
    a4d8:	3501      	adds	r5, #1
    a4da:	e7d0      	b.n	a47e <at_get_uint32_param+0x62>
            return AT_RET_NOT_NUMERIC;
    a4dc:	2302      	movs	r3, #2
            return at_parse_hex_uint32(app_at_param_table->params_array[seqno].str + AT_CMD_HEX_PREFIX_LENGTH, p_uint32, app_at_param_table->params_array[seqno].str_len - AT_CMD_HEX_PREFIX_LENGTH);
    a4de:	e7db      	b.n	a498 <at_get_uint32_param+0x7c>
        return AT_RET_SYNTAX_ERROR;
    a4e0:	2301      	movs	r3, #1
    if ((p_str == NULL) || (p_val == NULL))
    a4e2:	2e00      	cmp	r6, #0
    a4e4:	d0d8      	beq.n	a498 <at_get_uint32_param+0x7c>
    if (str_len > AT_MAX_UINT32_STRING_LENGTH)
    a4e6:	2d0a      	cmp	r5, #10
    a4e8:	d8d6      	bhi.n	a498 <at_get_uint32_param+0x7c>
    value = strtoul((char*)p_str, &s, 10);
    a4ea:	0020      	movs	r0, r4
    a4ec:	220a      	movs	r2, #10
    a4ee:	a903      	add	r1, sp, #12
    a4f0:	f010 fe72 	bl	1b1d8 <strtoul>
    if (str_len != s - (char*)p_str)
    a4f4:	9b03      	ldr	r3, [sp, #12]
    a4f6:	1b1c      	subs	r4, r3, r4
        return AT_RET_NOT_NUMERIC;
    a4f8:	2302      	movs	r3, #2
    if (str_len != s - (char*)p_str)
    a4fa:	42a5      	cmp	r5, r4
    a4fc:	d1cc      	bne.n	a498 <at_get_uint32_param+0x7c>
    *p_val = (uint32)value;
    a4fe:	6030      	str	r0, [r6, #0]
    return AT_RET_OK;
    a500:	003b      	movs	r3, r7
    a502:	e7c9      	b.n	a498 <at_get_uint32_param+0x7c>
    a504:	010024b4 	.word	0x010024b4
    a508:	010005dc 	.word	0x010005dc

0000a50c <at_get_uint16_param>:
    return AT_RET_OK;
}


AT_RET at_get_uint16_param(uint8 seqno, uint16 *p_uint16, bool mandatory)
{
    a50c:	b5f0      	push	{r4, r5, r6, r7, lr}
    AT_RET cause = AT_RET_OK;

    if ((app_at_param_table == NULL) || (p_uint16 == NULL))
    a50e:	4b3c      	ldr	r3, [pc, #240]	; (a600 <at_get_uint16_param+0xf4>)
{
    a510:	000e      	movs	r6, r1
    if ((app_at_param_table == NULL) || (p_uint16 == NULL))
    a512:	6819      	ldr	r1, [r3, #0]
{
    a514:	b085      	sub	sp, #20
    {
        return AT_RET_INTERNAL_ERROR;
    a516:	230d      	movs	r3, #13
    if ((app_at_param_table == NULL) || (p_uint16 == NULL))
    a518:	2900      	cmp	r1, #0
    a51a:	d012      	beq.n	a542 <at_get_uint16_param+0x36>
    a51c:	2e00      	cmp	r6, #0
    a51e:	d010      	beq.n	a542 <at_get_uint16_param+0x36>
    }

    if( seqno >= app_at_param_table->param_count)
    a520:	780c      	ldrb	r4, [r1, #0]
    {
        //Error , reading more param than that present in AT command
        return AT_RET_PARAM_MISSING;
    a522:	3b0a      	subs	r3, #10
    if( seqno >= app_at_param_table->param_count)
    a524:	4284      	cmp	r4, r0
    a526:	d90c      	bls.n	a542 <at_get_uint16_param+0x36>
    }
    if(app_at_param_table->params_array[seqno].str == NULL)
    a528:	3309      	adds	r3, #9
    a52a:	4343      	muls	r3, r0
    a52c:	6848      	ldr	r0, [r1, #4]
    a52e:	18c0      	adds	r0, r0, r3
    a530:	6844      	ldr	r4, [r0, #4]
    a532:	2c00      	cmp	r4, #0
    a534:	d108      	bne.n	a548 <at_get_uint16_param+0x3c>
        return AT_RET_PARAM_MISSING;
    a536:	2303      	movs	r3, #3
    {
        if(mandatory)
    a538:	2a00      	cmp	r2, #0
    a53a:	d102      	bne.n	a542 <at_get_uint16_param+0x36>
        {
            cause = AT_RET_PARAM_MISSING;
        }
        else
        {
            *p_uint16 = AT_UINT16_NO_VALUE;
    a53c:	3b04      	subs	r3, #4
    *p_val = value;
    a53e:	8033      	strh	r3, [r6, #0]
    return AT_RET_OK;
    a540:	2300      	movs	r3, #0

        cause = at_parse_uint16(app_at_param_table->params_array[seqno].str, p_uint16, app_at_param_table->params_array[seqno].str_len);
    }

    return cause;
}
    a542:	0018      	movs	r0, r3
    a544:	b005      	add	sp, #20
    a546:	bdf0      	pop	{r4, r5, r6, r7, pc}
        if(at_check_hex_string_prefix(app_at_param_table->params_array[seqno].str, app_at_param_table->params_array[seqno].str_len))
    a548:	8905      	ldrh	r5, [r0, #8]
    a54a:	0020      	movs	r0, r4
    a54c:	0029      	movs	r1, r5
    a54e:	f7ff ff47 	bl	a3e0 <at_check_hex_string_prefix>
    a552:	1e07      	subs	r7, r0, #0
    a554:	d042      	beq.n	a5dc <at_get_uint16_param+0xd0>
            return at_parse_hex_uint16(app_at_param_table->params_array[seqno].str + AT_CMD_HEX_PREFIX_LENGTH, p_uint16, app_at_param_table->params_array[seqno].str_len - AT_CMD_HEX_PREFIX_LENGTH);
    a556:	1ca2      	adds	r2, r4, #2
        return AT_RET_INTERNAL_ERROR;
    a558:	230d      	movs	r3, #13
    if ((p_str == NULL) || (p_val == NULL))
    a55a:	2a00      	cmp	r2, #0
    a55c:	d0f1      	beq.n	a542 <at_get_uint16_param+0x36>
        if (!isxdigit(*p_temp_string))      //lint !e866
    a55e:	2044      	movs	r0, #68	; 0x44
    a560:	4f28      	ldr	r7, [pc, #160]	; (a604 <at_get_uint16_param+0xf8>)
    a562:	6839      	ldr	r1, [r7, #0]
    while ((*p_temp_string != AT_CMD_END_MARK) && (*p_temp_string != AT_CMD_PARAM_SEPARATOR) && (*p_temp_string != AT_CMD_SEPARATOR))
    a564:	7813      	ldrb	r3, [r2, #0]
    a566:	2b00      	cmp	r3, #0
    a568:	d001      	beq.n	a56e <at_get_uint16_param+0x62>
    a56a:	2b2c      	cmp	r3, #44	; 0x2c
    a56c:	d112      	bne.n	a594 <at_get_uint16_param+0x88>
            return at_parse_hex_uint16(app_at_param_table->params_array[seqno].str + AT_CMD_HEX_PREFIX_LENGTH, p_uint16, app_at_param_table->params_array[seqno].str_len - AT_CMD_HEX_PREFIX_LENGTH);
    a56e:	3d02      	subs	r5, #2
    a570:	b2ab      	uxth	r3, r5
    a572:	2500      	movs	r5, #0
    a574:	9300      	str	r3, [sp, #0]
    a576:	002b      	movs	r3, r5
    while (i < str_len)
    a578:	9900      	ldr	r1, [sp, #0]
    a57a:	b2ea      	uxtb	r2, r5
    a57c:	428a      	cmp	r2, r1
    a57e:	d2de      	bcs.n	a53e <at_get_uint16_param+0x32>
        if(!isxdigit(*p_str))               //lint !e866
    a580:	2144      	movs	r1, #68	; 0x44
    a582:	1962      	adds	r2, r4, r5
    a584:	7890      	ldrb	r0, [r2, #2]
    a586:	683a      	ldr	r2, [r7, #0]
    a588:	1812      	adds	r2, r2, r0
    a58a:	7852      	ldrb	r2, [r2, #1]
    a58c:	420a      	tst	r2, r1
    a58e:	d109      	bne.n	a5a4 <at_get_uint16_param+0x98>
        return AT_RET_SYNTAX_ERROR;
    a590:	2301      	movs	r3, #1
    a592:	e7d6      	b.n	a542 <at_get_uint16_param+0x36>
    while ((*p_temp_string != AT_CMD_END_MARK) && (*p_temp_string != AT_CMD_PARAM_SEPARATOR) && (*p_temp_string != AT_CMD_SEPARATOR))
    a594:	2b3b      	cmp	r3, #59	; 0x3b
    a596:	d0ea      	beq.n	a56e <at_get_uint16_param+0x62>
        if (!isxdigit(*p_temp_string))      //lint !e866
    a598:	18cb      	adds	r3, r1, r3
    a59a:	785b      	ldrb	r3, [r3, #1]
    a59c:	4203      	tst	r3, r0
    a59e:	d01b      	beq.n	a5d8 <at_get_uint16_param+0xcc>
        p_temp_string++;
    a5a0:	3201      	adds	r2, #1
    a5a2:	e7df      	b.n	a564 <at_get_uint16_param+0x58>
        value = (uint16)(value << 4);
    a5a4:	011b      	lsls	r3, r3, #4
    a5a6:	b29b      	uxth	r3, r3
        if (at_parse_char_to_hex(*p_str, &value1) == false)
    a5a8:	a903      	add	r1, sp, #12
        value = (uint16)(value << 4);
    a5aa:	9301      	str	r3, [sp, #4]
        if (at_parse_char_to_hex(*p_str, &value1) == false)
    a5ac:	f7ff fd9c 	bl	a0e8 <at_parse_char_to_hex>
    a5b0:	2800      	cmp	r0, #0
    a5b2:	d0ed      	beq.n	a590 <at_get_uint16_param+0x84>
        value  += value1;
    a5b4:	ab02      	add	r3, sp, #8
    a5b6:	791a      	ldrb	r2, [r3, #4]
    a5b8:	9b01      	ldr	r3, [sp, #4]
    a5ba:	189b      	adds	r3, r3, r2
    a5bc:	b29b      	uxth	r3, r3
        if( (value < value1) || ((value == 0xFFFF) && (i != str_len - 1)))
    a5be:	429a      	cmp	r2, r3
    a5c0:	d8e6      	bhi.n	a590 <at_get_uint16_param+0x84>
    a5c2:	4a11      	ldr	r2, [pc, #68]	; (a608 <at_get_uint16_param+0xfc>)
    a5c4:	4293      	cmp	r3, r2
    a5c6:	d105      	bne.n	a5d4 <at_get_uint16_param+0xc8>
    a5c8:	9a00      	ldr	r2, [sp, #0]
    a5ca:	1e51      	subs	r1, r2, #1
    a5cc:	22ff      	movs	r2, #255	; 0xff
    a5ce:	402a      	ands	r2, r5
    a5d0:	428a      	cmp	r2, r1
    a5d2:	d1dd      	bne.n	a590 <at_get_uint16_param+0x84>
    a5d4:	3501      	adds	r5, #1
    a5d6:	e7cf      	b.n	a578 <at_get_uint16_param+0x6c>
            return AT_RET_NOT_NUMERIC;
    a5d8:	2302      	movs	r3, #2
            return at_parse_hex_uint16(app_at_param_table->params_array[seqno].str + AT_CMD_HEX_PREFIX_LENGTH, p_uint16, app_at_param_table->params_array[seqno].str_len - AT_CMD_HEX_PREFIX_LENGTH);
    a5da:	e7b2      	b.n	a542 <at_get_uint16_param+0x36>
    if (str_len > AT_MAX_UINT16_STRING_LENGTH)
    a5dc:	2d05      	cmp	r5, #5
    a5de:	d8d7      	bhi.n	a590 <at_get_uint16_param+0x84>
    value = strtoul((char*)p_str, &s, 10);
    a5e0:	0020      	movs	r0, r4
    a5e2:	220a      	movs	r2, #10
    a5e4:	a903      	add	r1, sp, #12
    a5e6:	f010 fdf7 	bl	1b1d8 <strtoul>
    if (str_len != s - (char*)p_str)
    a5ea:	9b03      	ldr	r3, [sp, #12]
    a5ec:	1b1c      	subs	r4, r3, r4
        return AT_RET_NOT_NUMERIC;
    a5ee:	2302      	movs	r3, #2
    if (str_len != s - (char*)p_str)
    a5f0:	42a5      	cmp	r5, r4
    a5f2:	d1a6      	bne.n	a542 <at_get_uint16_param+0x36>
    if (value > MAX_UINT16)
    a5f4:	4b04      	ldr	r3, [pc, #16]	; (a608 <at_get_uint16_param+0xfc>)
    a5f6:	4298      	cmp	r0, r3
    a5f8:	d8ca      	bhi.n	a590 <at_get_uint16_param+0x84>
    *p_val = (uint16)value;
    a5fa:	8030      	strh	r0, [r6, #0]
    return AT_RET_OK;
    a5fc:	003b      	movs	r3, r7
    a5fe:	e7a0      	b.n	a542 <at_get_uint16_param+0x36>
    a600:	010024b4 	.word	0x010024b4
    a604:	010005dc 	.word	0x010005dc
    a608:	0000ffff 	.word	0x0000ffff

0000a60c <at_get_uint8_param>:

AT_RET at_get_uint8_param(uint8 seqno, uint8 *p_uint8, bool mandatory)
{
    a60c:	b573      	push	{r0, r1, r4, r5, r6, lr}
    AT_RET cause = AT_RET_OK;

    if ((app_at_param_table == NULL) || (p_uint8 == NULL))
    a60e:	4b17      	ldr	r3, [pc, #92]	; (a66c <at_get_uint8_param+0x60>)
{
    a610:	000c      	movs	r4, r1
    if ((app_at_param_table == NULL) || (p_uint8 == NULL))
    a612:	6819      	ldr	r1, [r3, #0]
    {
        return AT_RET_INTERNAL_ERROR;
    a614:	230d      	movs	r3, #13
    if ((app_at_param_table == NULL) || (p_uint8 == NULL))
    a616:	2900      	cmp	r1, #0
    a618:	d017      	beq.n	a64a <at_get_uint8_param+0x3e>
    a61a:	2c00      	cmp	r4, #0
    a61c:	d015      	beq.n	a64a <at_get_uint8_param+0x3e>
    }

    if( seqno >= app_at_param_table->param_count)
    a61e:	780d      	ldrb	r5, [r1, #0]
    {
        //Error , reading more param than that present in AT command
        return AT_RET_PARAM_MISSING;
    a620:	3b0a      	subs	r3, #10
    if( seqno >= app_at_param_table->param_count)
    a622:	4285      	cmp	r5, r0
    a624:	d911      	bls.n	a64a <at_get_uint8_param+0x3e>
    }
    if(app_at_param_table->params_array[seqno].str == NULL)
    a626:	3309      	adds	r3, #9
    a628:	4343      	muls	r3, r0
    a62a:	6848      	ldr	r0, [r1, #4]
    a62c:	18c0      	adds	r0, r0, r3
    a62e:	6846      	ldr	r6, [r0, #4]
    a630:	2e00      	cmp	r6, #0
    a632:	d106      	bne.n	a642 <at_get_uint8_param+0x36>
        return AT_RET_PARAM_MISSING;
    a634:	2303      	movs	r3, #3
    {
        if(mandatory)
    a636:	2a00      	cmp	r2, #0
    a638:	d107      	bne.n	a64a <at_get_uint8_param+0x3e>
        {
            cause = AT_RET_PARAM_MISSING;
        }
        else
        {
            *p_uint8 = AT_UINT8_NO_VALUE;
    a63a:	33fc      	adds	r3, #252	; 0xfc
    a63c:	7023      	strb	r3, [r4, #0]
    return AT_RET_OK;
    a63e:	2300      	movs	r3, #0
    a640:	e003      	b.n	a64a <at_get_uint8_param+0x3e>
        }
    }
    else
    {
        cause = at_parse_uint8(app_at_param_table->params_array[seqno].str, p_uint8, app_at_param_table->params_array[seqno].str_len);
    a642:	8905      	ldrh	r5, [r0, #8]
    if (str_len > AT_MAX_UINT8_STRING_LENGTH)
    a644:	2d03      	cmp	r5, #3
    a646:	d902      	bls.n	a64e <at_get_uint8_param+0x42>
        return AT_RET_SYNTAX_ERROR;
    a648:	2301      	movs	r3, #1
    }

    return cause;
}
    a64a:	0018      	movs	r0, r3
    a64c:	bd76      	pop	{r1, r2, r4, r5, r6, pc}
    value = (uint16)strtoul((char*)p_str, &s, 10);
    a64e:	0030      	movs	r0, r6
    a650:	220a      	movs	r2, #10
    a652:	a901      	add	r1, sp, #4
    a654:	f010 fdc0 	bl	1b1d8 <strtoul>
    if (str_len != s - (char*)p_str)
    a658:	9b01      	ldr	r3, [sp, #4]
    a65a:	1b9e      	subs	r6, r3, r6
        return AT_RET_NOT_NUMERIC;
    a65c:	2302      	movs	r3, #2
    if (str_len != s - (char*)p_str)
    a65e:	42b5      	cmp	r5, r6
    a660:	d1f3      	bne.n	a64a <at_get_uint8_param+0x3e>
    if (value > MAX_UINT8)
    a662:	b283      	uxth	r3, r0
    a664:	2bff      	cmp	r3, #255	; 0xff
    a666:	d8ef      	bhi.n	a648 <at_get_uint8_param+0x3c>
    *p_val = (uint8)value;
    a668:	7020      	strb	r0, [r4, #0]
    a66a:	e7e8      	b.n	a63e <at_get_uint8_param+0x32>
    a66c:	010024b4 	.word	0x010024b4

0000a670 <at_get_int16_param>:

AT_RET at_get_int16_param(uint8 seqno, int16 *p_int16, bool mandatory)
{
    a670:	b573      	push	{r0, r1, r4, r5, r6, lr}
    AT_RET cause = AT_RET_OK;

    if ((app_at_param_table == NULL) || (p_int16 == NULL))
    a672:	4b19      	ldr	r3, [pc, #100]	; (a6d8 <at_get_int16_param+0x68>)
{
    a674:	000c      	movs	r4, r1
    if ((app_at_param_table == NULL) || (p_int16 == NULL))
    a676:	6819      	ldr	r1, [r3, #0]
    {
        return AT_RET_INTERNAL_ERROR;
    a678:	230d      	movs	r3, #13
    if ((app_at_param_table == NULL) || (p_int16 == NULL))
    a67a:	2900      	cmp	r1, #0
    a67c:	d017      	beq.n	a6ae <at_get_int16_param+0x3e>
    a67e:	2c00      	cmp	r4, #0
    a680:	d015      	beq.n	a6ae <at_get_int16_param+0x3e>
    }

    if( seqno >= app_at_param_table->param_count)
    a682:	780d      	ldrb	r5, [r1, #0]
    {
        //Error , reading more param than that present in AT command
        return AT_RET_PARAM_MISSING;
    a684:	3b0a      	subs	r3, #10
    if( seqno >= app_at_param_table->param_count)
    a686:	4285      	cmp	r5, r0
    a688:	d911      	bls.n	a6ae <at_get_int16_param+0x3e>
    }
    if(app_at_param_table->params_array[seqno].str == NULL)
    a68a:	3309      	adds	r3, #9
    a68c:	4343      	muls	r3, r0
    a68e:	6848      	ldr	r0, [r1, #4]
    a690:	18c0      	adds	r0, r0, r3
    a692:	6846      	ldr	r6, [r0, #4]
    a694:	2e00      	cmp	r6, #0
    a696:	d106      	bne.n	a6a6 <at_get_int16_param+0x36>
        return AT_RET_PARAM_MISSING;
    a698:	2303      	movs	r3, #3
    {
        if(mandatory)
    a69a:	2a00      	cmp	r2, #0
    a69c:	d107      	bne.n	a6ae <at_get_int16_param+0x3e>
        {
            cause = AT_RET_PARAM_MISSING;
        }
        else
        {
            *p_int16 = AT_INT16_NO_VALUE;
    a69e:	4b0f      	ldr	r3, [pc, #60]	; (a6dc <at_get_int16_param+0x6c>)
    a6a0:	8023      	strh	r3, [r4, #0]
    return AT_RET_OK;
    a6a2:	2300      	movs	r3, #0
    a6a4:	e003      	b.n	a6ae <at_get_int16_param+0x3e>
        }
    }
    else
    {
        cause = at_parse_int16(app_at_param_table->params_array[seqno].str, p_int16, app_at_param_table->params_array[seqno].str_len);
    a6a6:	8905      	ldrh	r5, [r0, #8]
    if (str_len > AT_MAX_INT16_STRING_LENGTH)
    a6a8:	2d06      	cmp	r5, #6
    a6aa:	d902      	bls.n	a6b2 <at_get_int16_param+0x42>
        return AT_RET_SYNTAX_ERROR;
    a6ac:	2301      	movs	r3, #1
    }

    return cause;
}
    a6ae:	0018      	movs	r0, r3
    a6b0:	bd76      	pop	{r1, r2, r4, r5, r6, pc}
    value = strtol((char*)p_str, &s, 10);
    a6b2:	0030      	movs	r0, r6
    a6b4:	220a      	movs	r2, #10
    a6b6:	a901      	add	r1, sp, #4
    a6b8:	f010 fd6e 	bl	1b198 <strtol>
    if (str_len != s - (char*)p_str)
    a6bc:	9b01      	ldr	r3, [sp, #4]
    a6be:	1b9e      	subs	r6, r3, r6
        return AT_RET_NOT_NUMERIC;
    a6c0:	2302      	movs	r3, #2
    if (str_len != s - (char*)p_str)
    a6c2:	42b5      	cmp	r5, r6
    a6c4:	d1f3      	bne.n	a6ae <at_get_int16_param+0x3e>
    if ((value < MIN_INT16) || (value > MAX_INT16))
    a6c6:	2380      	movs	r3, #128	; 0x80
    a6c8:	4a05      	ldr	r2, [pc, #20]	; (a6e0 <at_get_int16_param+0x70>)
    a6ca:	021b      	lsls	r3, r3, #8
    a6cc:	18c3      	adds	r3, r0, r3
    a6ce:	4293      	cmp	r3, r2
    a6d0:	d8ec      	bhi.n	a6ac <at_get_int16_param+0x3c>
    *p_val = (int16)value;
    a6d2:	8020      	strh	r0, [r4, #0]
    a6d4:	e7e5      	b.n	a6a2 <at_get_int16_param+0x32>
    a6d6:	46c0      	nop			; (mov r8, r8)
    a6d8:	010024b4 	.word	0x010024b4
    a6dc:	00007fff 	.word	0x00007fff
    a6e0:	0000ffff 	.word	0x0000ffff

0000a6e4 <at_get_1dp_to_int16_param>:

AT_RET at_get_1dp_to_int16_param(uint8 seqno, int16 *p_int16, bool mandatory)
{
    a6e4:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    AT_RET cause = AT_RET_OK;
    char *fraction;

    if ((app_at_param_table == NULL) || (p_int16 == NULL))
    a6e6:	4d26      	ldr	r5, [pc, #152]	; (a780 <at_get_1dp_to_int16_param+0x9c>)
{
    a6e8:	000e      	movs	r6, r1
    if ((app_at_param_table == NULL) || (p_int16 == NULL))
    a6ea:	682b      	ldr	r3, [r5, #0]
    {
        return AT_RET_INTERNAL_ERROR;
    a6ec:	240d      	movs	r4, #13
    if ((app_at_param_table == NULL) || (p_int16 == NULL))
    a6ee:	2b00      	cmp	r3, #0
    a6f0:	d041      	beq.n	a776 <at_get_1dp_to_int16_param+0x92>
    a6f2:	2900      	cmp	r1, #0
    a6f4:	d03f      	beq.n	a776 <at_get_1dp_to_int16_param+0x92>
    }

    if (seqno >= app_at_param_table->param_count)
    a6f6:	7819      	ldrb	r1, [r3, #0]
    {
        // Error, reading more param than that present in AT command
        return AT_RET_PARAM_MISSING;
    a6f8:	3c0a      	subs	r4, #10
    if (seqno >= app_at_param_table->param_count)
    a6fa:	4281      	cmp	r1, r0
    a6fc:	d93b      	bls.n	a776 <at_get_1dp_to_int16_param+0x92>
    }

    if (app_at_param_table->params_array[seqno].str == NULL)
    a6fe:	3409      	adds	r4, #9
    a700:	4344      	muls	r4, r0
    a702:	685b      	ldr	r3, [r3, #4]
    a704:	191b      	adds	r3, r3, r4
    a706:	6858      	ldr	r0, [r3, #4]
    a708:	2800      	cmp	r0, #0
    a70a:	d025      	beq.n	a758 <at_get_1dp_to_int16_param+0x74>
    }
    else
    {
        // check that the parameter string is in the correct format to be converted
        // examples of the format could be N, NN, N.N, NN.N etc
        for (int i = 0; i < app_at_param_table->params_array[seqno].str_len; i++)
    a70c:	8919      	ldrh	r1, [r3, #8]
    a70e:	0003      	movs	r3, r0
    a710:	1a1a      	subs	r2, r3, r0
    a712:	4291      	cmp	r1, r2
    a714:	dc27      	bgt.n	a766 <at_get_1dp_to_int16_param+0x82>
                return AT_RET_SYNTAX_ERROR;
            }
        }

        // evaluate the integral part of the parameter - this will be the final result if no fractional part is provided
        *p_int16 = (int16) atoi((const char*) app_at_param_table->params_array[seqno].str) * 10; //lint !e734 There is no loss in precision
    a716:	f010 fd2f 	bl	1b178 <atoi>
    a71a:	230a      	movs	r3, #10
    a71c:	4358      	muls	r0, r3

        // has a fractional part also been passed in the parameter - i.e. is there a decimal point?
        fraction = (char*) strchr((const char*) app_at_param_table->params_array[seqno].str, '.');
    a71e:	682b      	ldr	r3, [r5, #0]
        *p_int16 = (int16) atoi((const char*) app_at_param_table->params_array[seqno].str) * 10; //lint !e734 There is no loss in precision
    a720:	8030      	strh	r0, [r6, #0]
        fraction = (char*) strchr((const char*) app_at_param_table->params_array[seqno].str, '.');
    a722:	6858      	ldr	r0, [r3, #4]
    a724:	212e      	movs	r1, #46	; 0x2e
    a726:	1904      	adds	r4, r0, r4
    a728:	6860      	ldr	r0, [r4, #4]
    a72a:	f010 fe07 	bl	1b33c <strchr>
    AT_RET cause = AT_RET_OK;
    a72e:	2400      	movs	r4, #0
        fraction = (char*) strchr((const char*) app_at_param_table->params_array[seqno].str, '.');
    a730:	0005      	movs	r5, r0
        if (fraction != NULL)
    a732:	42a0      	cmp	r0, r4
    a734:	d01f      	beq.n	a776 <at_get_1dp_to_int16_param+0x92>
        {
            // yes, so make sure there is also a fractional digit
            if (strlen(fraction) > 1)
    a736:	f010 fe32 	bl	1b39e <strlen>
    a73a:	2801      	cmp	r0, #1
    a73c:	d91a      	bls.n	a774 <at_get_1dp_to_int16_param+0x90>
            {
                // there is but truncate to only one digit after the decimal point
                if (strlen(fraction) > 2)
    a73e:	0028      	movs	r0, r5
    a740:	f010 fe2d 	bl	1b39e <strlen>
    a744:	2802      	cmp	r0, #2
    a746:	d900      	bls.n	a74a <at_get_1dp_to_int16_param+0x66>
                {
                    *(fraction + 2) = '\0';
    a748:	70ac      	strb	r4, [r5, #2]
                }

                // add the fist digit after the decimal point as the least significant part of the value
                *p_int16 += atoi((const char*) &fraction[1]); //lint !e734 There is no loss in precision
    a74a:	1c68      	adds	r0, r5, #1
    a74c:	f010 fd14 	bl	1b178 <atoi>
    a750:	8833      	ldrh	r3, [r6, #0]
    a752:	1818      	adds	r0, r3, r0
    a754:	8030      	strh	r0, [r6, #0]
    a756:	e004      	b.n	a762 <at_get_1dp_to_int16_param+0x7e>
        return AT_RET_PARAM_MISSING;
    a758:	2403      	movs	r4, #3
        if (mandatory)
    a75a:	2a00      	cmp	r2, #0
    a75c:	d10b      	bne.n	a776 <at_get_1dp_to_int16_param+0x92>
            *p_int16 = AT_INT16_NO_VALUE;
    a75e:	4b09      	ldr	r3, [pc, #36]	; (a784 <at_get_1dp_to_int16_param+0xa0>)
    a760:	8033      	strh	r3, [r6, #0]
    AT_RET cause = AT_RET_OK;
    a762:	2400      	movs	r4, #0
    a764:	e007      	b.n	a776 <at_get_1dp_to_int16_param+0x92>
            if (!((app_at_param_table->params_array[seqno].str[i] >= '0'  && \
    a766:	781a      	ldrb	r2, [r3, #0]
    a768:	0017      	movs	r7, r2
    a76a:	3f30      	subs	r7, #48	; 0x30
    a76c:	2f09      	cmp	r7, #9
    a76e:	d904      	bls.n	a77a <at_get_1dp_to_int16_param+0x96>
    a770:	2a2e      	cmp	r2, #46	; 0x2e
    a772:	d002      	beq.n	a77a <at_get_1dp_to_int16_param+0x96>
                return AT_RET_SYNTAX_ERROR;
    a774:	2401      	movs	r4, #1
            }
        }
    }

    return cause;
}
    a776:	0020      	movs	r0, r4
    a778:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    a77a:	3301      	adds	r3, #1
    a77c:	e7c8      	b.n	a710 <at_get_1dp_to_int16_param+0x2c>
    a77e:	46c0      	nop			; (mov r8, r8)
    a780:	010024b4 	.word	0x010024b4
    a784:	00007fff 	.word	0x00007fff

0000a788 <at_get_string_param>:

AT_RET at_get_string_param(uint8 seqno, uint8 *p_string, uint16 max_len, bool mandatory)
{
    a788:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    a78a:	000e      	movs	r6, r1
    uint8   *s;
    uint16   str_len;
    uint16   paramstr_offset;

    if ((app_at_param_table == NULL) || (p_string == NULL))
    a78c:	4925      	ldr	r1, [pc, #148]	; (a824 <at_get_string_param+0x9c>)
    {
        return AT_RET_INTERNAL_ERROR;
    a78e:	240d      	movs	r4, #13
    if ((app_at_param_table == NULL) || (p_string == NULL))
    a790:	680d      	ldr	r5, [r1, #0]
    a792:	2d00      	cmp	r5, #0
    a794:	d010      	beq.n	a7b8 <at_get_string_param+0x30>
    a796:	2e00      	cmp	r6, #0
    a798:	d00e      	beq.n	a7b8 <at_get_string_param+0x30>
    }

    if( seqno >= app_at_param_table->param_count)
    a79a:	7829      	ldrb	r1, [r5, #0]
    {
        //Error , reading more param than that present in AT command
        return AT_RET_PARAM_MISSING;
    a79c:	3c0a      	subs	r4, #10
    if( seqno >= app_at_param_table->param_count)
    a79e:	4281      	cmp	r1, r0
    a7a0:	d90a      	bls.n	a7b8 <at_get_string_param+0x30>
    }

    s = app_at_param_table->params_array[seqno].str;
    a7a2:	210c      	movs	r1, #12
    a7a4:	4348      	muls	r0, r1
    a7a6:	6869      	ldr	r1, [r5, #4]
    a7a8:	1808      	adds	r0, r1, r0
    a7aa:	6841      	ldr	r1, [r0, #4]
    str_len = app_at_param_table->params_array[seqno].str_len;

    if (s == NULL)
    a7ac:	2900      	cmp	r1, #0
    a7ae:	d105      	bne.n	a7bc <at_get_string_param+0x34>
        {
            return AT_RET_PARAM_MISSING;
        }
        else
        {
            return AT_RET_OK;
    a7b0:	000c      	movs	r4, r1
        if (mandatory)
    a7b2:	2b00      	cmp	r3, #0
    a7b4:	d000      	beq.n	a7b8 <at_get_string_param+0x30>
        return AT_RET_PARAM_MISSING;
    a7b6:	3403      	adds	r4, #3

    at_strncpy(p_string, s, str_len);
    p_string[str_len] = AT_CMD_END_MARK;

    return AT_RET_OK;
}/*lint !e429  p_string not custodial. */
    a7b8:	0020      	movs	r0, r4
    a7ba:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    if ((s[0] == AT_CMD_DOUBLE_QUOTATION) && (s[str_len - 1] == AT_CMD_DOUBLE_QUOTATION))
    a7bc:	780b      	ldrb	r3, [r1, #0]
    str_len = app_at_param_table->params_array[seqno].str_len;
    a7be:	8905      	ldrh	r5, [r0, #8]
    if ((s[0] == AT_CMD_DOUBLE_QUOTATION) && (s[str_len - 1] == AT_CMD_DOUBLE_QUOTATION))
    a7c0:	2b22      	cmp	r3, #34	; 0x22
    a7c2:	d113      	bne.n	a7ec <at_get_string_param+0x64>
    a7c4:	194b      	adds	r3, r1, r5
    a7c6:	3b01      	subs	r3, #1
    a7c8:	781b      	ldrb	r3, [r3, #0]
    a7ca:	2b22      	cmp	r3, #34	; 0x22
    a7cc:	d10e      	bne.n	a7ec <at_get_string_param+0x64>
        if (str_len > max_len + 1)
    a7ce:	3201      	adds	r2, #1
    a7d0:	2401      	movs	r4, #1
    a7d2:	4295      	cmp	r5, r2
    a7d4:	dcf0      	bgt.n	a7b8 <at_get_string_param+0x30>
        app_at_param_table->params_array[seqno].is_in_double_quotes = true;
    a7d6:	7004      	strb	r4, [r0, #0]
        at_strncpy(p_string, (s + 1), (str_len - 2));
    a7d8:	1909      	adds	r1, r1, r4
        p_string[str_len - 2] = AT_CMD_END_MARK;
    a7da:	2400      	movs	r4, #0
        at_strncpy(p_string, (s + 1), (str_len - 2));
    a7dc:	1eaa      	subs	r2, r5, #2
        p_string[str_len - 2] = AT_CMD_END_MARK;
    a7de:	1975      	adds	r5, r6, r5
        at_strncpy(p_string, (s + 1), (str_len - 2));
    a7e0:	0030      	movs	r0, r6
        p_string[str_len - 2] = AT_CMD_END_MARK;
    a7e2:	3d02      	subs	r5, #2
        at_strncpy(p_string, (s + 1), (str_len - 2));
    a7e4:	f010 fe0e 	bl	1b404 <strncpy>
        p_string[str_len - 2] = AT_CMD_END_MARK;
    a7e8:	702c      	strb	r4, [r5, #0]
        return AT_RET_OK;
    a7ea:	e7e5      	b.n	a7b8 <at_get_string_param+0x30>
            return AT_RET_SYNTAX_ERROR;
    a7ec:	2401      	movs	r4, #1
    if (str_len > max_len - 1)
    a7ee:	4295      	cmp	r5, r2
    a7f0:	d2e2      	bcs.n	a7b8 <at_get_string_param+0x30>
    a7f2:	2300      	movs	r3, #0
        *(s + paramstr_offset) = (uint8) toupper( *(s + paramstr_offset));//lint !e1058
    a7f4:	2703      	movs	r7, #3
    a7f6:	4c0c      	ldr	r4, [pc, #48]	; (a828 <at_get_string_param+0xa0>)
    for(paramstr_offset = 0; paramstr_offset < str_len; paramstr_offset++)
    a7f8:	b29a      	uxth	r2, r3
    a7fa:	4295      	cmp	r5, r2
    a7fc:	d806      	bhi.n	a80c <at_get_string_param+0x84>
    p_string[str_len] = AT_CMD_END_MARK;
    a7fe:	2400      	movs	r4, #0
    at_strncpy(p_string, s, str_len);
    a800:	002a      	movs	r2, r5
    a802:	0030      	movs	r0, r6
    a804:	f010 fdfe 	bl	1b404 <strncpy>
    p_string[str_len] = AT_CMD_END_MARK;
    a808:	5574      	strb	r4, [r6, r5]
    return AT_RET_OK;
    a80a:	e7d5      	b.n	a7b8 <at_get_string_param+0x30>
        *(s + paramstr_offset) = (uint8) toupper( *(s + paramstr_offset));//lint !e1058
    a80c:	5cca      	ldrb	r2, [r1, r3]
    a80e:	6820      	ldr	r0, [r4, #0]
    a810:	1880      	adds	r0, r0, r2
    a812:	7840      	ldrb	r0, [r0, #1]
    a814:	4038      	ands	r0, r7
    a816:	2802      	cmp	r0, #2
    a818:	d100      	bne.n	a81c <at_get_string_param+0x94>
    a81a:	3a20      	subs	r2, #32
    a81c:	54ca      	strb	r2, [r1, r3]
    a81e:	3301      	adds	r3, #1
    a820:	e7ea      	b.n	a7f8 <at_get_string_param+0x70>
    a822:	46c0      	nop			; (mov r8, r8)
    a824:	010024b4 	.word	0x010024b4
    a828:	010005dc 	.word	0x010005dc

0000a82c <at_get_hexstring_param>:

AT_RET at_get_hexstring_param(uint8 seqno, uint8 **p_hexstring, uint16 *p_hexstring_len, bool mandatory)
{
    a82c:	b5f0      	push	{r4, r5, r6, r7, lr}
    uint8       *s;
    AT_RET   cause;

    if ((app_at_param_table == NULL) || (p_hexstring == NULL))
    a82e:	4c21      	ldr	r4, [pc, #132]	; (a8b4 <at_get_hexstring_param+0x88>)
    a830:	6825      	ldr	r5, [r4, #0]
    {
        return AT_RET_INTERNAL_ERROR;
    a832:	240d      	movs	r4, #13
    if ((app_at_param_table == NULL) || (p_hexstring == NULL))
    a834:	2d00      	cmp	r5, #0
    a836:	d005      	beq.n	a844 <at_get_hexstring_param+0x18>
    a838:	2900      	cmp	r1, #0
    a83a:	d003      	beq.n	a844 <at_get_hexstring_param+0x18>
    }

    if( seqno >= app_at_param_table->param_count)
    a83c:	782c      	ldrb	r4, [r5, #0]
    a83e:	4284      	cmp	r4, r0
    a840:	d802      	bhi.n	a848 <at_get_hexstring_param+0x1c>
    {
        //Error , reading more param than that present in AT command
        return AT_RET_PARAM_MISSING;
    a842:	2403      	movs	r4, #3

    *p_hexstring = s;
    *p_hexstring_len = app_at_param_table->params_array[seqno].str_len;

    return AT_RET_OK;
}
    a844:	0020      	movs	r0, r4
    a846:	bdf0      	pop	{r4, r5, r6, r7, pc}
    s = app_at_param_table->params_array[seqno].str;
    a848:	240c      	movs	r4, #12
    a84a:	4344      	muls	r4, r0
    a84c:	46a4      	mov	ip, r4
    a84e:	6868      	ldr	r0, [r5, #4]
    a850:	4460      	add	r0, ip
    a852:	0004      	movs	r4, r0
    a854:	6840      	ldr	r0, [r0, #4]
    if (s == NULL)
    a856:	2800      	cmp	r0, #0
    a858:	d128      	bne.n	a8ac <at_get_hexstring_param+0x80>
        *p_hexstring = NULL;
    a85a:	6008      	str	r0, [r1, #0]
        if (mandatory)
    a85c:	2b00      	cmp	r3, #0
    a85e:	d1f0      	bne.n	a842 <at_get_hexstring_param+0x16>
    return AT_RET_OK;
    a860:	2400      	movs	r4, #0
    a862:	e7ef      	b.n	a844 <at_get_hexstring_param+0x18>
        if (*p_atparams_string == AT_CMD_DOUBLE_QUOTATION)
    a864:	2b22      	cmp	r3, #34	; 0x22
    a866:	d11b      	bne.n	a8a0 <at_get_hexstring_param+0x74>
            in_double_quotes = !in_double_quotes;
    a868:	3b21      	subs	r3, #33	; 0x21
    a86a:	405e      	eors	r6, r3
        p_atparams_string++;
    a86c:	3701      	adds	r7, #1
    while((*p_atparams_string !='\0')&&(*p_atparams_string !=AT_CMD_PARAM_SEPARATOR)&&(*p_atparams_string != AT_CMD_SEPARATOR))
    a86e:	783b      	ldrb	r3, [r7, #0]
    a870:	2b00      	cmp	r3, #0
    a872:	d003      	beq.n	a87c <at_get_hexstring_param+0x50>
    a874:	2b2c      	cmp	r3, #44	; 0x2c
    a876:	d001      	beq.n	a87c <at_get_hexstring_param+0x50>
    a878:	2b3b      	cmp	r3, #59	; 0x3b
    a87a:	d1f3      	bne.n	a864 <at_get_hexstring_param+0x38>
    if ((s[0] == AT_CMD_DOUBLE_QUOTATION) && (s[app_at_param_table->params_array[seqno].str_len - 1] == AT_CMD_DOUBLE_QUOTATION))
    a87c:	7803      	ldrb	r3, [r0, #0]
    a87e:	2b22      	cmp	r3, #34	; 0x22
    a880:	d108      	bne.n	a894 <at_get_hexstring_param+0x68>
    a882:	8923      	ldrh	r3, [r4, #8]
    a884:	18c6      	adds	r6, r0, r3
    a886:	3e01      	subs	r6, #1
    a888:	7836      	ldrb	r6, [r6, #0]
    a88a:	2e22      	cmp	r6, #34	; 0x22
    a88c:	d102      	bne.n	a894 <at_get_hexstring_param+0x68>
        app_at_param_table->params_array[seqno].str_len -= 2;
    a88e:	3b02      	subs	r3, #2
    a890:	8123      	strh	r3, [r4, #8]
        s++;
    a892:	3001      	adds	r0, #1
    *p_hexstring = s;
    a894:	6008      	str	r0, [r1, #0]
    *p_hexstring_len = app_at_param_table->params_array[seqno].str_len;
    a896:	6868      	ldr	r0, [r5, #4]
    a898:	4460      	add	r0, ip
    a89a:	8903      	ldrh	r3, [r0, #8]
    a89c:	8013      	strh	r3, [r2, #0]
    a89e:	e7df      	b.n	a860 <at_get_hexstring_param+0x34>
        if ((*p_atparams_string == AT_CMD_WHITE_SPACE) && (in_double_quotes))
    a8a0:	2b20      	cmp	r3, #32
    a8a2:	d1e3      	bne.n	a86c <at_get_hexstring_param+0x40>
    a8a4:	2e00      	cmp	r6, #0
    a8a6:	d0e1      	beq.n	a86c <at_get_hexstring_param+0x40>
    a8a8:	2401      	movs	r4, #1
    a8aa:	e7cb      	b.n	a844 <at_get_hexstring_param+0x18>
    a8ac:	0007      	movs	r7, r0
    bool in_double_quotes = false;
    a8ae:	2600      	movs	r6, #0
    a8b0:	e7dd      	b.n	a86e <at_get_hexstring_param+0x42>
    a8b2:	46c0      	nop			; (mov r8, r8)
    a8b4:	010024b4 	.word	0x010024b4

0000a8b8 <at_get_ip_param>:

AT_RET at_get_ip_param(uint8 seqno, uint8 *p_ip, uint16 max_len, bool mandatory, ip_addr_t *server_addr)
{
    a8b8:	b510      	push	{r4, lr}
    a8ba:	1e0c      	subs	r4, r1, #0
    AT_RET            cause;

    if (p_ip == NULL || server_addr == NULL)
    a8bc:	d101      	bne.n	a8c2 <at_get_ip_param+0xa>
    {
        return AT_RET_SYNTAX_ERROR;
    a8be:	2001      	movs	r0, #1
    {
        return AT_RET_SYNTAX_ERROR;
    }

    return AT_RET_OK;
}
    a8c0:	bd10      	pop	{r4, pc}
    if (p_ip == NULL || server_addr == NULL)
    a8c2:	9902      	ldr	r1, [sp, #8]
    a8c4:	2900      	cmp	r1, #0
    a8c6:	d0fa      	beq.n	a8be <at_get_ip_param+0x6>
    cause = at_get_string_param(seqno, p_ip, max_len, mandatory);
    a8c8:	0021      	movs	r1, r4
    a8ca:	f7ff ff5d 	bl	a788 <at_get_string_param>
    if(cause != AT_RET_OK)
    a8ce:	2800      	cmp	r0, #0
    a8d0:	d1f5      	bne.n	a8be <at_get_ip_param+0x6>
    if (ipaddr_aton((const char*)(p_ip), server_addr) != 1)
    a8d2:	9902      	ldr	r1, [sp, #8]
    a8d4:	0020      	movs	r0, r4
    a8d6:	f012 fc7b 	bl	1d1d0 <ipaddr_aton>
    a8da:	3801      	subs	r0, #1
    a8dc:	1e43      	subs	r3, r0, #1
    a8de:	4198      	sbcs	r0, r3
        return AT_RET_SYNTAX_ERROR;
    a8e0:	b2c0      	uxtb	r0, r0
    a8e2:	e7ed      	b.n	a8c0 <at_get_ip_param+0x8>

0000a8e4 <at_is_param_in_double_quotes>:

}

bool at_is_param_in_double_quotes(uint8 position)
{
    if (app_at_param_table == NULL)
    a8e4:	4b05      	ldr	r3, [pc, #20]	; (a8fc <at_is_param_in_double_quotes+0x18>)
    a8e6:	681a      	ldr	r2, [r3, #0]
    {
        return true;
    a8e8:	2301      	movs	r3, #1
    if (app_at_param_table == NULL)
    a8ea:	2a00      	cmp	r2, #0
    a8ec:	d003      	beq.n	a8f6 <at_is_param_in_double_quotes+0x12>
    }
    if (app_at_param_table->params_array[position].is_in_double_quotes)
    a8ee:	330b      	adds	r3, #11
    a8f0:	4358      	muls	r0, r3
    a8f2:	6852      	ldr	r2, [r2, #4]
    a8f4:	5c83      	ldrb	r3, [r0, r2]
    {
        return true;
    }
    return false;
}
    a8f6:	0018      	movs	r0, r3
    a8f8:	4770      	bx	lr
    a8fa:	46c0      	nop			; (mov r8, r8)
    a8fc:	010024b4 	.word	0x010024b4

0000a900 <at_get_atcmd_cb_from_atstring>:

const AT_CMD_CB_s * at_get_atcmd_cb_from_atstring(uint8 *p_atstring, uint16 *len)
{
    a900:	b5f0      	push	{r4, r5, r6, r7, lr}
    a902:	b085      	sub	sp, #20
    a904:	9102      	str	r1, [sp, #8]
    a906:	0007      	movs	r7, r0
    const AT_CMD_CB_s     *cmd_cb;
    const AT_CMD_CB_s     *p_at_cmd_table = at_get_internal_cmd_table_address();
    a908:	f007 f8b4 	bl	11a74 <at_get_internal_cmd_table_address>
    a90c:	0004      	movs	r4, r0
    struct AT_CMD_CB_node  *current_at_cmd_registered_node = at_get_registered_cmd_table_address();
    a90e:	f007 f905 	bl	11b1c <at_get_registered_cmd_table_address>
    a912:	0005      	movs	r5, r0
    uint16           i, at_cmd_length;
    uint8            count;

    count = at_get_internal_cmd_table_size();
    a914:	f007 f8ac 	bl	11a70 <at_get_internal_cmd_table_size>
        return 0;
    a918:	9700      	str	r7, [sp, #0]
    if(p_str == NULL)
    a91a:	2f00      	cmp	r7, #0
    a91c:	d020      	beq.n	a960 <at_get_atcmd_cb_from_atstring+0x60>
    a91e:	2200      	movs	r2, #0
    while((*p_str != '\0') && (*p_str != '=') && (*p_str != '?') && (*p_str != AT_CMD_SEPARATOR))
    a920:	2104      	movs	r1, #4
    a922:	b293      	uxth	r3, r2
    a924:	9300      	str	r3, [sp, #0]
    a926:	5cbb      	ldrb	r3, [r7, r2]
    a928:	2b00      	cmp	r3, #0
    a92a:	d006      	beq.n	a93a <at_get_atcmd_cb_from_atstring+0x3a>
    a92c:	2b3d      	cmp	r3, #61	; 0x3d
    a92e:	d003      	beq.n	a938 <at_get_atcmd_cb_from_atstring+0x38>
    a930:	3201      	adds	r2, #1
    a932:	438b      	bics	r3, r1
    a934:	2b3b      	cmp	r3, #59	; 0x3b
    a936:	d1f4      	bne.n	a922 <at_get_atcmd_cb_from_atstring+0x22>
    a938:	2300      	movs	r3, #0
    at_cmd_length = at_get_cmd_name_length(p_atstring);

    for(i = 0; i < at_cmd_length; i++)
    {
        *(p_atstring + i) = (uint8) toupper( *(p_atstring + i));//lint !e1058
    a93a:	2203      	movs	r2, #3
    a93c:	4694      	mov	ip, r2
    a93e:	e00b      	b.n	a958 <at_get_atcmd_cb_from_atstring+0x58>
    a940:	4666      	mov	r6, ip
    a942:	4926      	ldr	r1, [pc, #152]	; (a9dc <at_get_atcmd_cb_from_atstring+0xdc>)
    a944:	5cfa      	ldrb	r2, [r7, r3]
    a946:	6809      	ldr	r1, [r1, #0]
    a948:	1889      	adds	r1, r1, r2
    a94a:	7849      	ldrb	r1, [r1, #1]
    a94c:	4031      	ands	r1, r6
    a94e:	2902      	cmp	r1, #2
    a950:	d100      	bne.n	a954 <at_get_atcmd_cb_from_atstring+0x54>
    a952:	3a20      	subs	r2, #32
    a954:	54fa      	strb	r2, [r7, r3]
    a956:	3301      	adds	r3, #1
    for(i = 0; i < at_cmd_length; i++)
    a958:	9900      	ldr	r1, [sp, #0]
    a95a:	b29a      	uxth	r2, r3
    a95c:	4291      	cmp	r1, r2
    a95e:	d8ef      	bhi.n	a940 <at_get_atcmd_cb_from_atstring+0x40>
    a960:	2318      	movs	r3, #24
    a962:	4358      	muls	r0, r3
    a964:	1823      	adds	r3, r4, r0
    a966:	9303      	str	r3, [sp, #12]
    }

    for( i = 0; i < count; i++)
    a968:	9b03      	ldr	r3, [sp, #12]
    a96a:	429c      	cmp	r4, r3
    a96c:	d103      	bne.n	a976 <at_get_atcmd_cb_from_atstring+0x76>
            *len = (uint16)at_strlen(cmd_cb->cmd_str);
            return cmd_cb;
        }
    }

    while(current_at_cmd_registered_node != NULL)
    a96e:	2d00      	cmp	r5, #0
    a970:	d11e      	bne.n	a9b0 <at_get_atcmd_cb_from_atstring+0xb0>
            return cmd_cb;
        }
        current_at_cmd_registered_node = current_at_cmd_registered_node->next;
    }

    return NULL;
    a972:	002e      	movs	r6, r5
    a974:	e017      	b.n	a9a6 <at_get_atcmd_cb_from_atstring+0xa6>
        if( ((at_strncmp(cmd_cb->cmd_str, p_atstring, at_strlen(cmd_cb->cmd_str) )) == 0)
    a976:	6863      	ldr	r3, [r4, #4]
        cmd_cb = &(p_at_cmd_table[i]);
    a978:	0026      	movs	r6, r4
        if( ((at_strncmp(cmd_cb->cmd_str, p_atstring, at_strlen(cmd_cb->cmd_str) )) == 0)
    a97a:	0018      	movs	r0, r3
    a97c:	9301      	str	r3, [sp, #4]
    a97e:	f010 fd0e 	bl	1b39e <strlen>
    a982:	0039      	movs	r1, r7
    a984:	0002      	movs	r2, r0
    a986:	9801      	ldr	r0, [sp, #4]
    a988:	f010 fd15 	bl	1b3b6 <strncmp>
    a98c:	2800      	cmp	r0, #0
    a98e:	d10d      	bne.n	a9ac <at_get_atcmd_cb_from_atstring+0xac>
            && (at_cmd_length == at_strlen(cmd_cb->cmd_str)))
    a990:	6860      	ldr	r0, [r4, #4]
    a992:	f010 fd04 	bl	1b39e <strlen>
    a996:	9b00      	ldr	r3, [sp, #0]
    a998:	4283      	cmp	r3, r0
    a99a:	d107      	bne.n	a9ac <at_get_atcmd_cb_from_atstring+0xac>
            *len = (uint16)at_strlen(cmd_cb->cmd_str);
    a99c:	6870      	ldr	r0, [r6, #4]
    a99e:	f010 fcfe 	bl	1b39e <strlen>
    a9a2:	9b02      	ldr	r3, [sp, #8]
    a9a4:	8018      	strh	r0, [r3, #0]
}
    a9a6:	0030      	movs	r0, r6
    a9a8:	b005      	add	sp, #20
    a9aa:	bdf0      	pop	{r4, r5, r6, r7, pc}
    a9ac:	3418      	adds	r4, #24
    a9ae:	e7db      	b.n	a968 <at_get_atcmd_cb_from_atstring+0x68>
        if( ((at_strncmp(cmd_cb->cmd_str, p_atstring, at_strlen(cmd_cb->cmd_str) )) == 0)
    a9b0:	686c      	ldr	r4, [r5, #4]
    a9b2:	0020      	movs	r0, r4
    a9b4:	f010 fcf3 	bl	1b39e <strlen>
    a9b8:	0039      	movs	r1, r7
    a9ba:	0002      	movs	r2, r0
    a9bc:	0020      	movs	r0, r4
    a9be:	f010 fcfa 	bl	1b3b6 <strncmp>
    a9c2:	2800      	cmp	r0, #0
    a9c4:	d107      	bne.n	a9d6 <at_get_atcmd_cb_from_atstring+0xd6>
            && (at_cmd_length == at_strlen(cmd_cb->cmd_str)))
    a9c6:	6868      	ldr	r0, [r5, #4]
    a9c8:	f010 fce9 	bl	1b39e <strlen>
    a9cc:	9b00      	ldr	r3, [sp, #0]
    a9ce:	4283      	cmp	r3, r0
    a9d0:	d101      	bne.n	a9d6 <at_get_atcmd_cb_from_atstring+0xd6>
        cmd_cb = &(current_at_cmd_registered_node->at_cmd_cb);
    a9d2:	002e      	movs	r6, r5
    a9d4:	e7e2      	b.n	a99c <at_get_atcmd_cb_from_atstring+0x9c>
        current_at_cmd_registered_node = current_at_cmd_registered_node->next;
    a9d6:	69ad      	ldr	r5, [r5, #24]
    a9d8:	e7c9      	b.n	a96e <at_get_atcmd_cb_from_atstring+0x6e>
    a9da:	46c0      	nop			; (mov r8, r8)
    a9dc:	010005dc 	.word	0x010005dc

0000a9e0 <at_parse_calculate_crc8>:

AT_RET at_parse_calculate_crc8(const uint8* data, uint16 len, uint8* crc)
{
    a9e0:	b510      	push	{r4, lr}
    uint8 value = 0;

    if ((data == NULL) || (crc == NULL))
    {
        return AT_RET_SYNTAX_ERROR;
    a9e2:	2301      	movs	r3, #1
    if ((data == NULL) || (crc == NULL))
    a9e4:	2800      	cmp	r0, #0
    a9e6:	d006      	beq.n	a9f6 <at_parse_calculate_crc8+0x16>
    a9e8:	2a00      	cmp	r2, #0
    a9ea:	d004      	beq.n	a9f6 <at_parse_calculate_crc8+0x16>
    uint8 value = 0;
    a9ec:	2300      	movs	r3, #0
    }

    while(len > 0)
    a9ee:	2900      	cmp	r1, #0
    a9f0:	d103      	bne.n	a9fa <at_parse_calculate_crc8+0x1a>
    {
        value = value ^ (*(data++));
        len--;
    }

    *crc = value;
    a9f2:	7013      	strb	r3, [r2, #0]

    return AT_RET_OK;
    a9f4:	000b      	movs	r3, r1

}
    a9f6:	0018      	movs	r0, r3
    a9f8:	bd10      	pop	{r4, pc}
        value = value ^ (*(data++));
    a9fa:	7804      	ldrb	r4, [r0, #0]
        len--;
    a9fc:	3901      	subs	r1, #1
        value = value ^ (*(data++));
    a9fe:	4063      	eors	r3, r4
        len--;
    aa00:	b289      	uxth	r1, r1
    aa02:	3001      	adds	r0, #1
    aa04:	e7f3      	b.n	a9ee <at_parse_calculate_crc8+0xe>
	...

0000aa08 <at_check_num_sc_for_sc_index>:

AT_RET at_check_num_sc_for_sc_index(uint16 num_subcarrier, uint16 subcarrier_index)
{
    aa08:	b500      	push	{lr}
    AT_RET       cause = AT_RET_OK;

    switch (num_subcarrier)
    aa0a:	280c      	cmp	r0, #12
    aa0c:	d808      	bhi.n	aa20 <at_check_num_sc_for_sc_index+0x18>
    aa0e:	f7f5 fcc9 	bl	3a4 <__gnu_thumb1_case_uqi>
    aa12:	091e      	.short	0x091e
    aa14:	07070e07 	.word	0x07070e07
    aa18:	07070715 	.word	0x07070715
    aa1c:	0707      	.short	0x0707
    aa1e:	19          	.byte	0x19
    aa1f:	00          	.byte	0x00
            {
                cause = AT_RET_SYNTAX_ERROR;
            }
            break;
        default:
            cause = AT_RET_SYNTAX_ERROR;
    aa20:	2001      	movs	r0, #1
            break;
    }

    return cause;
}
    aa22:	bd00      	pop	{pc}
    AT_RET       cause = AT_RET_OK;
    aa24:	200b      	movs	r0, #11
    aa26:	4288      	cmp	r0, r1
    aa28:	4180      	sbcs	r0, r0
    aa2a:	4240      	negs	r0, r0
    aa2c:	e7f9      	b.n	aa22 <at_check_num_sc_for_sc_index+0x1a>
    aa2e:	2001      	movs	r0, #1
            if (subcarrier_index != 0 && subcarrier_index != 3 && subcarrier_index != 6 && subcarrier_index != 9)
    aa30:	2909      	cmp	r1, #9
    aa32:	d8f6      	bhi.n	aa22 <at_check_num_sc_for_sc_index+0x1a>
    aa34:	4b07      	ldr	r3, [pc, #28]	; (aa54 <at_check_num_sc_for_sc_index+0x4c>)
    aa36:	40cb      	lsrs	r3, r1
    AT_RET       cause = AT_RET_OK;
    aa38:	4398      	bics	r0, r3
    aa3a:	e7f2      	b.n	aa22 <at_check_num_sc_for_sc_index+0x1a>
    aa3c:	2000      	movs	r0, #0
            if (subcarrier_index != 0 && subcarrier_index != 6)
    aa3e:	4281      	cmp	r1, r0
    aa40:	d0ef      	beq.n	aa22 <at_check_num_sc_for_sc_index+0x1a>
    aa42:	3906      	subs	r1, #6
            if (subcarrier_index != 0)
    aa44:	0008      	movs	r0, r1
    aa46:	1e41      	subs	r1, r0, #1
    aa48:	4188      	sbcs	r0, r1
    AT_RET       cause = AT_RET_OK;
    aa4a:	b2c0      	uxtb	r0, r0
    aa4c:	e7e9      	b.n	aa22 <at_check_num_sc_for_sc_index+0x1a>
    aa4e:	2000      	movs	r0, #0
    aa50:	e7e7      	b.n	aa22 <at_check_num_sc_for_sc_index+0x1a>
    aa52:	46c0      	nop			; (mov r8, r8)
    aa54:	00000249 	.word	0x00000249

0000aa58 <at_get_tm_param>:

    return is_valid_time(time_struct, *time_zone);
}

AT_RET at_get_tm_param(uint8 seqno, struct tm *time_struct, int8 *time_zone, bool mandatory)
{
    aa58:	b5f0      	push	{r4, r5, r6, r7, lr}
    aa5a:	0005      	movs	r5, r0
    aa5c:	001e      	movs	r6, r3
    aa5e:	b095      	sub	sp, #84	; 0x54
    aa60:	9201      	str	r2, [sp, #4]
    aa62:	000c      	movs	r4, r1
    AT_RET            cause;
    uint8             time_string[AT_TIME_STRING_LENGTH + 1] = {0};
    aa64:	2215      	movs	r2, #21
    aa66:	2100      	movs	r1, #0
    aa68:	a80e      	add	r0, sp, #56	; 0x38
    aa6a:	f7f5 fc39 	bl	2e0 <memset>

    cause = at_get_string_param(seqno, time_string, AT_TIME_STRING_LENGTH + 1, mandatory);
    aa6e:	0033      	movs	r3, r6
    aa70:	2215      	movs	r2, #21
    aa72:	a90e      	add	r1, sp, #56	; 0x38
    aa74:	0028      	movs	r0, r5
    aa76:	f7ff fe87 	bl	a788 <at_get_string_param>
    aa7a:	1e07      	subs	r7, r0, #0
    if (cause != AT_RET_OK)
    aa7c:	d178      	bne.n	ab70 <at_get_tm_param+0x118>
    {
        return cause;
    }

    if (!at_is_param_in_double_quotes(AT_PARSE_FIRST_PARAM_POS))
    aa7e:	f7ff ff31 	bl	a8e4 <at_is_param_in_double_quotes>
    aa82:	9003      	str	r0, [sp, #12]
    aa84:	2800      	cmp	r0, #0
    aa86:	d001      	beq.n	aa8c <at_get_tm_param+0x34>
    if (time_string == NULL || time_struct == NULL || time_zone == NULL)
    aa88:	2c00      	cmp	r4, #0
    aa8a:	d101      	bne.n	aa90 <at_get_tm_param+0x38>
    {
        return AT_RET_SYNTAX_ERROR;
    aa8c:	2701      	movs	r7, #1
    aa8e:	e06f      	b.n	ab70 <at_get_tm_param+0x118>
    if (time_string == NULL || time_struct == NULL || time_zone == NULL)
    aa90:	9b01      	ldr	r3, [sp, #4]
    aa92:	2b00      	cmp	r3, #0
    aa94:	d0fa      	beq.n	aa8c <at_get_tm_param+0x34>
    for (uint8 i = 0; i < strlen((char*)time_string); i++)
    aa96:	003d      	movs	r5, r7
    uint8 time_formate_array[AT_TIME_STRING_LENGTH] = {TIME_FORMAT_DIGIT_VALUE, TIME_FORMAT_DIGIT_VALUE, TIME_FORMAT_SLASH,
    aa98:	2214      	movs	r2, #20
    aa9a:	495e      	ldr	r1, [pc, #376]	; (ac14 <at_get_tm_param+0x1bc>)
    aa9c:	a809      	add	r0, sp, #36	; 0x24
    aa9e:	f7f5 fba7 	bl	1f0 <memcpy>
    uint8 time_parse_array[AT_TIME_ARRAY_LENGTH] = {0};
    aaa2:	2207      	movs	r2, #7
    aaa4:	0039      	movs	r1, r7
    aaa6:	a804      	add	r0, sp, #16
    aaa8:	f7f5 fc1a 	bl	2e0 <memset>
    bool    is_negative_number = false;
    aaac:	9702      	str	r7, [sp, #8]
    for (uint8 i = 0; i < strlen((char*)time_string); i++)
    aaae:	ae0e      	add	r6, sp, #56	; 0x38
    aab0:	0030      	movs	r0, r6
    aab2:	f010 fc74 	bl	1b39e <strlen>
    aab6:	4285      	cmp	r5, r0
    aab8:	d35d      	bcc.n	ab76 <at_get_tm_param+0x11e>
    memset(time_struct, 0, sizeof(struct tm));
    aaba:	2224      	movs	r2, #36	; 0x24
    aabc:	2100      	movs	r1, #0
    aabe:	0020      	movs	r0, r4
    aac0:	f7f5 fc0e 	bl	2e0 <memset>
    time_struct->tm_year  = time_parse_array[index++];
    aac4:	ab04      	add	r3, sp, #16
    aac6:	781b      	ldrb	r3, [r3, #0]
    time_struct->tm_year += (time_struct->tm_year < 70) ? 100 : 0;
    aac8:	2264      	movs	r2, #100	; 0x64
    aaca:	2b45      	cmp	r3, #69	; 0x45
    aacc:	dd00      	ble.n	aad0 <at_get_tm_param+0x78>
    aace:	2200      	movs	r2, #0
    aad0:	189b      	adds	r3, r3, r2
    aad2:	6163      	str	r3, [r4, #20]
    time_struct->tm_mon   = time_parse_array[index++] - 1;  
    aad4:	ab04      	add	r3, sp, #16
    aad6:	785b      	ldrb	r3, [r3, #1]
    if (is_negative_number)
    aad8:	9a02      	ldr	r2, [sp, #8]
    time_struct->tm_mon   = time_parse_array[index++] - 1;  
    aada:	3b01      	subs	r3, #1
    aadc:	6123      	str	r3, [r4, #16]
    time_struct->tm_mday  = time_parse_array[index++];
    aade:	ab04      	add	r3, sp, #16
    aae0:	789b      	ldrb	r3, [r3, #2]
    aae2:	60e3      	str	r3, [r4, #12]
    time_struct->tm_hour  = time_parse_array[index++]; 
    aae4:	ab04      	add	r3, sp, #16
    aae6:	78db      	ldrb	r3, [r3, #3]
    aae8:	60a3      	str	r3, [r4, #8]
    time_struct->tm_min   = time_parse_array[index++];
    aaea:	ab04      	add	r3, sp, #16
    aaec:	791b      	ldrb	r3, [r3, #4]
    aaee:	6063      	str	r3, [r4, #4]
    time_struct->tm_sec   = time_parse_array[index++];
    aaf0:	ab04      	add	r3, sp, #16
    aaf2:	795b      	ldrb	r3, [r3, #5]
    aaf4:	6023      	str	r3, [r4, #0]
    *time_zone = (int8)(time_parse_array[index++]);
    aaf6:	ab04      	add	r3, sp, #16
    aaf8:	799b      	ldrb	r3, [r3, #6]
    if (is_negative_number)
    aafa:	2a00      	cmp	r2, #0
    aafc:	d000      	beq.n	ab00 <at_get_tm_param+0xa8>
    aafe:	e084      	b.n	ac0a <at_get_tm_param+0x1b2>
    return is_valid_time(time_struct, *time_zone);
    ab00:	2500      	movs	r5, #0
        *time_zone = -*time_zone;
    ab02:	9a01      	ldr	r2, [sp, #4]
    uint8  days_in_month_array[] = {31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31};
    ab04:	4943      	ldr	r1, [pc, #268]	; (ac14 <at_get_tm_param+0x1bc>)
        *time_zone = -*time_zone;
    ab06:	7013      	strb	r3, [r2, #0]
    uint8  days_in_month_array[] = {31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31};
    ab08:	ae06      	add	r6, sp, #24
    return is_valid_time(time_struct, *time_zone);
    ab0a:	9b01      	ldr	r3, [sp, #4]
    uint8  days_in_month_array[] = {31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31};
    ab0c:	220c      	movs	r2, #12
    ab0e:	3114      	adds	r1, #20
    ab10:	0030      	movs	r0, r6
    return is_valid_time(time_struct, *time_zone);
    ab12:	575d      	ldrsb	r5, [r3, r5]
    uint8  days_in_month_array[] = {31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31};
    ab14:	f7f5 fb6c 	bl	1f0 <memcpy>
    if (time_struct->tm_mon  <  0 || time_struct->tm_mon + 1  >  AT_MONTHS_IN_YEAR  ||  // struct tm uses 0 based months
    ab18:	6923      	ldr	r3, [r4, #16]
    ab1a:	2b0b      	cmp	r3, #11
    ab1c:	d8b6      	bhi.n	aa8c <at_get_tm_param+0x34>
    ab1e:	68a2      	ldr	r2, [r4, #8]
    ab20:	2a17      	cmp	r2, #23
    ab22:	dcb3      	bgt.n	aa8c <at_get_tm_param+0x34>
        time_struct->tm_hour >= AT_HOURS_IN_DAY    ||
    ab24:	6862      	ldr	r2, [r4, #4]
    ab26:	2a3b      	cmp	r2, #59	; 0x3b
    ab28:	dcb0      	bgt.n	aa8c <at_get_tm_param+0x34>
        time_struct->tm_min  >= AT_MINUTES_IN_HOUR ||
    ab2a:	6822      	ldr	r2, [r4, #0]
    ab2c:	2a3b      	cmp	r2, #59	; 0x3b
    ab2e:	dcad      	bgt.n	aa8c <at_get_tm_param+0x34>
    if (time_struct->tm_mon + 1 == 2) 
    ab30:	2b01      	cmp	r3, #1
    ab32:	d000      	beq.n	ab36 <at_get_tm_param+0xde>
    ab34:	e06b      	b.n	ac0e <at_get_tm_param+0x1b6>
        if (at_is_leap_year(time_struct->tm_year + 1900)) //years since 1900
    ab36:	6963      	ldr	r3, [r4, #20]
    ab38:	4a37      	ldr	r2, [pc, #220]	; (ac18 <at_get_tm_param+0x1c0>)
    ab3a:	189e      	adds	r6, r3, r2
    if(((year % 4 == 0) && (year % 100 != 0)) || year % 400 == 0)
    ab3c:	07b3      	lsls	r3, r6, #30
    ab3e:	d106      	bne.n	ab4e <at_get_tm_param+0xf6>
    ab40:	2164      	movs	r1, #100	; 0x64
    ab42:	0030      	movs	r0, r6
    ab44:	f7f5 fda8 	bl	698 <__aeabi_idivmod>
            days = AT_DAYS_IN_FEBRUARY_OF_LEAP_YEAR;
    ab48:	231d      	movs	r3, #29
    if(((year % 4 == 0) && (year % 100 != 0)) || year % 400 == 0)
    ab4a:	2900      	cmp	r1, #0
    ab4c:	d107      	bne.n	ab5e <at_get_tm_param+0x106>
    ab4e:	21c8      	movs	r1, #200	; 0xc8
    ab50:	0030      	movs	r0, r6
    ab52:	0049      	lsls	r1, r1, #1
    ab54:	f7f5 fda0 	bl	698 <__aeabi_idivmod>
            days = AT_DAYS_IN_FEBRUARY_OF_COMMON_YEAR;
    ab58:	424b      	negs	r3, r1
    ab5a:	414b      	adcs	r3, r1
    ab5c:	331c      	adds	r3, #28
    if (time_struct->tm_mday <= 0 || time_struct->tm_mday > days)
    ab5e:	68e2      	ldr	r2, [r4, #12]
    ab60:	2a00      	cmp	r2, #0
    ab62:	dd93      	ble.n	aa8c <at_get_tm_param+0x34>
    ab64:	429a      	cmp	r2, r3
    ab66:	dc91      	bgt.n	aa8c <at_get_tm_param+0x34>
    if (time_zone < AT_MIN_TIME_ZONE || time_zone > AT_MAX_TIME_ZONE)
    ab68:	3560      	adds	r5, #96	; 0x60
    ab6a:	b2ed      	uxtb	r5, r5
    ab6c:	2dc0      	cmp	r5, #192	; 0xc0
    ab6e:	d88d      	bhi.n	aa8c <at_get_tm_param+0x34>
    {
        return AT_RET_SYNTAX_ERROR;
    }

    return AT_RET_OK;
}
    ab70:	0038      	movs	r0, r7
    ab72:	b015      	add	sp, #84	; 0x54
    ab74:	bdf0      	pop	{r4, r5, r6, r7, pc}
        switch (time_formate_array[i])
    ab76:	ab09      	add	r3, sp, #36	; 0x24
    ab78:	5d58      	ldrb	r0, [r3, r5]
    ab7a:	2804      	cmp	r0, #4
    ab7c:	d900      	bls.n	ab80 <at_get_tm_param+0x128>
    ab7e:	e785      	b.n	aa8c <at_get_tm_param+0x34>
    ab80:	f7f5 fc10 	bl	3a4 <__gnu_thumb1_case_uqi>
    ab84:	34302c03 	.word	0x34302c03
    ab88:	38          	.byte	0x38
    ab89:	00          	.byte	0x00
                if (!isdigit(time_string[i]))  //lint !e866
    ab8a:	2204      	movs	r2, #4
    ab8c:	4b23      	ldr	r3, [pc, #140]	; (ac1c <at_get_tm_param+0x1c4>)
    ab8e:	5d76      	ldrb	r6, [r6, r5]
    ab90:	681b      	ldr	r3, [r3, #0]
    ab92:	199b      	adds	r3, r3, r6
    ab94:	785b      	ldrb	r3, [r3, #1]
    ab96:	4213      	tst	r3, r2
    ab98:	d100      	bne.n	ab9c <at_get_tm_param+0x144>
    ab9a:	e777      	b.n	aa8c <at_get_tm_param+0x34>
                if (i % 3 == 0)
    ab9c:	2103      	movs	r1, #3
    ab9e:	0028      	movs	r0, r5
    aba0:	f7f5 fc90 	bl	4c4 <__aeabi_uidivmod>
    aba4:	b2c9      	uxtb	r1, r1
    aba6:	2900      	cmp	r1, #0
    aba8:	d10c      	bne.n	abc4 <at_get_tm_param+0x16c>
                    time_parse_array[i/3] = (time_string[i] - '0') * 10;  //lint !e734 There is no loss in precision, time_parse_array[i/3] <=99
    abaa:	3103      	adds	r1, #3
    abac:	0028      	movs	r0, r5
    abae:	f7f5 fc03 	bl	3b8 <__udivsi3>
    abb2:	230a      	movs	r3, #10
    abb4:	435e      	muls	r6, r3
    abb6:	b2c0      	uxtb	r0, r0
    abb8:	3620      	adds	r6, #32
                    time_parse_array[i/3] += (time_string[i] - '0');   //lint !e734 There is no loss in precision, time_parse_array[i/3] <=99
    abba:	ab04      	add	r3, sp, #16
    abbc:	541e      	strb	r6, [r3, r0]
    for (uint8 i = 0; i < strlen((char*)time_string); i++)
    abbe:	3501      	adds	r5, #1
    abc0:	b2ed      	uxtb	r5, r5
    abc2:	e774      	b.n	aaae <at_get_tm_param+0x56>
                else if (i % 3 == 1)
    abc4:	2901      	cmp	r1, #1
    abc6:	d1fa      	bne.n	abbe <at_get_tm_param+0x166>
                    time_parse_array[i/3] += (time_string[i] - '0');   //lint !e734 There is no loss in precision, time_parse_array[i/3] <=99
    abc8:	3102      	adds	r1, #2
    abca:	0028      	movs	r0, r5
    abcc:	f7f5 fbf4 	bl	3b8 <__udivsi3>
    abd0:	ab04      	add	r3, sp, #16
    abd2:	b2c0      	uxtb	r0, r0
    abd4:	5c1b      	ldrb	r3, [r3, r0]
    abd6:	18f6      	adds	r6, r6, r3
    abd8:	3e30      	subs	r6, #48	; 0x30
    abda:	e7ee      	b.n	abba <at_get_tm_param+0x162>
                if (time_string[i] != '/')
    abdc:	5d73      	ldrb	r3, [r6, r5]
    abde:	2b2f      	cmp	r3, #47	; 0x2f
    abe0:	d0ed      	beq.n	abbe <at_get_tm_param+0x166>
    abe2:	e753      	b.n	aa8c <at_get_tm_param+0x34>
                if (time_string[i] != ',')
    abe4:	5d73      	ldrb	r3, [r6, r5]
    abe6:	2b2c      	cmp	r3, #44	; 0x2c
    abe8:	d0e9      	beq.n	abbe <at_get_tm_param+0x166>
    abea:	e74f      	b.n	aa8c <at_get_tm_param+0x34>
                if (time_string[i] != ':')
    abec:	5d73      	ldrb	r3, [r6, r5]
    abee:	2b3a      	cmp	r3, #58	; 0x3a
    abf0:	d0e5      	beq.n	abbe <at_get_tm_param+0x166>
    abf2:	e74b      	b.n	aa8c <at_get_tm_param+0x34>
                if (time_string[i] == '+')
    abf4:	5d73      	ldrb	r3, [r6, r5]
    abf6:	2b2b      	cmp	r3, #43	; 0x2b
    abf8:	d005      	beq.n	ac06 <at_get_tm_param+0x1ae>
                else if (time_string[i] == '-')
    abfa:	2b2d      	cmp	r3, #45	; 0x2d
    abfc:	d000      	beq.n	ac00 <at_get_tm_param+0x1a8>
    abfe:	e745      	b.n	aa8c <at_get_tm_param+0x34>
                    is_negative_number = true;
    ac00:	9b03      	ldr	r3, [sp, #12]
                    is_negative_number = false;
    ac02:	9302      	str	r3, [sp, #8]
    ac04:	e7db      	b.n	abbe <at_get_tm_param+0x166>
    ac06:	2300      	movs	r3, #0
    ac08:	e7fb      	b.n	ac02 <at_get_tm_param+0x1aa>
        *time_zone = -*time_zone;
    ac0a:	425b      	negs	r3, r3
    ac0c:	e778      	b.n	ab00 <at_get_tm_param+0xa8>
        days = days_in_month_array[time_struct->tm_mon];
    ac0e:	5cf3      	ldrb	r3, [r6, r3]
    ac10:	e7a5      	b.n	ab5e <at_get_tm_param+0x106>
    ac12:	46c0      	nop			; (mov r8, r8)
    ac14:	000229d8 	.word	0x000229d8
    ac18:	0000076c 	.word	0x0000076c
    ac1c:	010005dc 	.word	0x010005dc

0000ac20 <app_at_asnyc_take_semaphore>:
 * Takes the semaphore.
 */
static void app_at_asnyc_take_semaphore(void)
{

    if(osMutexAcquire(app_at_asyc_semaphore, osWaitForever) != osOK)
    ac20:	2101      	movs	r1, #1
{
    ac22:	b510      	push	{r4, lr}
    if(osMutexAcquire(app_at_asyc_semaphore, osWaitForever) != osOK)
    ac24:	4b06      	ldr	r3, [pc, #24]	; (ac40 <app_at_asnyc_take_semaphore+0x20>)
    ac26:	4249      	negs	r1, r1
    ac28:	6818      	ldr	r0, [r3, #0]
    ac2a:	4674      	mov	r4, lr
    ac2c:	f009 feba 	bl	149a4 <osMutexAcquire>
    ac30:	2800      	cmp	r0, #0
    ac32:	d003      	beq.n	ac3c <app_at_asnyc_take_semaphore+0x1c>
    {
        assert(false);
    ac34:	0021      	movs	r1, r4
    ac36:	2016      	movs	r0, #22
    ac38:	f7f6 ff6a 	bl	1b10 <panic>
    }
}//lint !e454
    ac3c:	bd10      	pop	{r4, pc}
    ac3e:	46c0      	nop			; (mov r8, r8)
    ac40:	010024b8 	.word	0x010024b8

0000ac44 <app_at_asnyc_give_semaphore>:

/**
 * Gives the semaphore.
 */
static void app_at_asnyc_give_semaphore(void)
{
    ac44:	b510      	push	{r4, lr}

    if (osMutexRelease(app_at_asyc_semaphore) != osOK)
    ac46:	4b06      	ldr	r3, [pc, #24]	; (ac60 <app_at_asnyc_give_semaphore+0x1c>)
    ac48:	4674      	mov	r4, lr
    ac4a:	6818      	ldr	r0, [r3, #0]
    ac4c:	f009 fece 	bl	149ec <osMutexRelease>
    ac50:	2800      	cmp	r0, #0
    ac52:	d003      	beq.n	ac5c <app_at_asnyc_give_semaphore+0x18>
        assert(false);
    ac54:	0021      	movs	r1, r4
    ac56:	2016      	movs	r0, #22
    ac58:	f7f6 ff5a 	bl	1b10 <panic>
    {
        assert(false);
    }
}
    ac5c:	bd10      	pop	{r4, pc}
    ac5e:	46c0      	nop			; (mov r8, r8)
    ac60:	010024b8 	.word	0x010024b8

0000ac64 <delayed_async_output_list>:
    app_at_asnyc_give_semaphore();
    return;
}

void delayed_async_output_list(void)
{
    ac64:	b570      	push	{r4, r5, r6, lr}
    bool list_not_empty = false;
    app_at_async_notify_t *previous;

    app_at_asnyc_take_semaphore();
    ac66:	f7ff ffdb 	bl	ac20 <app_at_asnyc_take_semaphore>

    if(async_list != NULL)
    ac6a:	4c13      	ldr	r4, [pc, #76]	; (acb8 <delayed_async_output_list+0x54>)
    ac6c:	6823      	ldr	r3, [r4, #0]
    ac6e:	2b00      	cmp	r3, #0
    ac70:	d009      	beq.n	ac86 <delayed_async_output_list+0x22>
    {
        (void)activity_indication_output(true);
    ac72:	2001      	movs	r0, #1
    ac74:	f012 fd9a 	bl	1d7ac <activity_indication_output>
        list_not_empty = true;
    }
    while(async_list != NULL)
    {
        if (AT_IS_HEXSTRING(async_list->flag))
    ac78:	2510      	movs	r5, #16
    while(async_list != NULL)
    ac7a:	6823      	ldr	r3, [r4, #0]
    ac7c:	2b00      	cmp	r3, #0
    ac7e:	d105      	bne.n	ac8c <delayed_async_output_list+0x28>
        async_list = async_list->next;
        irfree(previous);
    }
    if(list_not_empty)
    {
        (void)activity_indication_output(false);
    ac80:	0018      	movs	r0, r3
    ac82:	f012 fd93 	bl	1d7ac <activity_indication_output>
    }
    app_at_asnyc_give_semaphore();
    ac86:	f7ff ffdd 	bl	ac44 <app_at_asnyc_give_semaphore>
}
    ac8a:	bd70      	pop	{r4, r5, r6, pc}
        if (AT_IS_HEXSTRING(async_list->flag))
    ac8c:	889a      	ldrh	r2, [r3, #4]
    ac8e:	6818      	ldr	r0, [r3, #0]
    ac90:	422a      	tst	r2, r5
    ac92:	d00d      	beq.n	acb0 <delayed_async_output_list+0x4c>
            app_at_send_convert_hexstring_no_claim(async_list->rsp_string, async_list->hexstring_offset, async_list->hexstring_length);
    ac94:	891a      	ldrh	r2, [r3, #8]
    ac96:	88d9      	ldrh	r1, [r3, #6]
    ac98:	f7fe fcda 	bl	9650 <app_at_send_convert_hexstring_no_claim>
        irfree(async_list->rsp_string);
    ac9c:	6823      	ldr	r3, [r4, #0]
    ac9e:	6818      	ldr	r0, [r3, #0]
    aca0:	f007 feca 	bl	12a38 <irfree>
        previous = async_list;
    aca4:	6820      	ldr	r0, [r4, #0]
        async_list = async_list->next;
    aca6:	68c3      	ldr	r3, [r0, #12]
    aca8:	6023      	str	r3, [r4, #0]
        irfree(previous);
    acaa:	f007 fec5 	bl	12a38 <irfree>
    acae:	e7e4      	b.n	ac7a <delayed_async_output_list+0x16>
            app_at_send_at_rsp_string_lines(async_list->rsp_string, true, async_list->flag);  //Output the new message
    acb0:	2101      	movs	r1, #1
    acb2:	f7fe fc90 	bl	95d6 <app_at_send_at_rsp_string_lines>
    acb6:	e7f1      	b.n	ac9c <delayed_async_output_list+0x38>
    acb8:	010024bc 	.word	0x010024bc

0000acbc <delayed_async_print>:
{
    acbc:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
    acbe:	0005      	movs	r5, r0
    acc0:	000f      	movs	r7, r1
    acc2:	9200      	str	r2, [sp, #0]
    acc4:	9301      	str	r3, [sp, #4]
    if (message == NULL)
    acc6:	2800      	cmp	r0, #0
    acc8:	d012      	beq.n	acf0 <delayed_async_print+0x34>
    if (at_uart_get_status() == AT_UART_STATUS_FREE)
    acca:	f7fe fe39 	bl	9940 <at_uart_get_status>
    acce:	2800      	cmp	r0, #0
    acd0:	d115      	bne.n	acfe <delayed_async_print+0x42>
        delayed_async_output_list();  //Output any queued messages in order
    acd2:	f7ff ffc7 	bl	ac64 <delayed_async_output_list>
        (void)activity_indication_output(true);
    acd6:	2001      	movs	r0, #1
    acd8:	f012 fd68 	bl	1d7ac <activity_indication_output>
        if(AT_IS_HEXSTRING(flag))
    acdc:	06fb      	lsls	r3, r7, #27
    acde:	d508      	bpl.n	acf2 <delayed_async_print+0x36>
            app_at_send_convert_hexstring_no_claim(message, offset_to_convert, length_to_convert);
    ace0:	9a01      	ldr	r2, [sp, #4]
    ace2:	9900      	ldr	r1, [sp, #0]
    ace4:	0028      	movs	r0, r5
    ace6:	f7fe fcb3 	bl	9650 <app_at_send_convert_hexstring_no_claim>
        (void)activity_indication_output(false);
    acea:	2000      	movs	r0, #0
    acec:	f012 fd5e 	bl	1d7ac <activity_indication_output>
}
    acf0:	bdf7      	pop	{r0, r1, r2, r4, r5, r6, r7, pc}
            app_at_send_at_rsp_string_lines(message, true, flag);  //Output the new message
    acf2:	003a      	movs	r2, r7
    acf4:	2101      	movs	r1, #1
    acf6:	0028      	movs	r0, r5
    acf8:	f7fe fc6d 	bl	95d6 <app_at_send_at_rsp_string_lines>
    acfc:	e7f5      	b.n	acea <delayed_async_print+0x2e>
    node = (app_at_async_notify_t*)irmalloc(sizeof(app_at_async_notify_t));
    acfe:	2010      	movs	r0, #16
    ad00:	f007 fe7e 	bl	12a00 <irmalloc>
    ad04:	1e04      	subs	r4, r0, #0
    if (node == NULL)
    ad06:	d0f3      	beq.n	acf0 <delayed_async_print+0x34>
    if (AT_IS_HEXSTRING(flag))
    ad08:	06fb      	lsls	r3, r7, #27
    ad0a:	d50c      	bpl.n	ad26 <delayed_async_print+0x6a>
        rsp_length = offset_to_convert + length_to_convert;
    ad0c:	9b00      	ldr	r3, [sp, #0]
    ad0e:	9a01      	ldr	r2, [sp, #4]
    ad10:	189e      	adds	r6, r3, r2
    node->rsp_string = irmalloc(rsp_length);
    ad12:	0030      	movs	r0, r6
    ad14:	f007 fe74 	bl	12a00 <irmalloc>
    ad18:	6020      	str	r0, [r4, #0]
    if (node->rsp_string == NULL)
    ad1a:	2800      	cmp	r0, #0
    ad1c:	d108      	bne.n	ad30 <delayed_async_print+0x74>
        irfree(node);
    ad1e:	0020      	movs	r0, r4
    ad20:	f007 fe8a 	bl	12a38 <irfree>
        return;
    ad24:	e7e4      	b.n	acf0 <delayed_async_print+0x34>
        rsp_length = strlen(message) + 1;
    ad26:	0028      	movs	r0, r5
    ad28:	f010 fb39 	bl	1b39e <strlen>
    ad2c:	1c46      	adds	r6, r0, #1
    ad2e:	e7f0      	b.n	ad12 <delayed_async_print+0x56>
    node->hexstring_offset = offset_to_convert;
    ad30:	466b      	mov	r3, sp
    ad32:	881b      	ldrh	r3, [r3, #0]
    memcpy(node->rsp_string, message, rsp_length);
    ad34:	0032      	movs	r2, r6
    node->hexstring_offset = offset_to_convert;
    ad36:	80e3      	strh	r3, [r4, #6]
    node->hexstring_length = length_to_convert;
    ad38:	466b      	mov	r3, sp
    ad3a:	889b      	ldrh	r3, [r3, #4]
    memcpy(node->rsp_string, message, rsp_length);
    ad3c:	0029      	movs	r1, r5
    node->hexstring_length = length_to_convert;
    ad3e:	8123      	strh	r3, [r4, #8]
    node->flag = flag;
    ad40:	80a7      	strh	r7, [r4, #4]
    memcpy(node->rsp_string, message, rsp_length);
    ad42:	f7f5 fa55 	bl	1f0 <memcpy>
    node->next = NULL;
    ad46:	2300      	movs	r3, #0
    ad48:	60e3      	str	r3, [r4, #12]
    app_at_asnyc_take_semaphore();
    ad4a:	f7ff ff69 	bl	ac20 <app_at_asnyc_take_semaphore>
    if (async_list == NULL)
    ad4e:	4a07      	ldr	r2, [pc, #28]	; (ad6c <delayed_async_print+0xb0>)
    ad50:	6813      	ldr	r3, [r2, #0]
    ad52:	2b00      	cmp	r3, #0
    ad54:	d104      	bne.n	ad60 <delayed_async_print+0xa4>
        async_list = node;
    ad56:	6014      	str	r4, [r2, #0]
    app_at_asnyc_give_semaphore();
    ad58:	f7ff ff74 	bl	ac44 <app_at_asnyc_give_semaphore>
    return;
    ad5c:	e7c8      	b.n	acf0 <delayed_async_print+0x34>
    ad5e:	0013      	movs	r3, r2
    while(next_node->next != NULL)
    ad60:	68da      	ldr	r2, [r3, #12]
    ad62:	2a00      	cmp	r2, #0
    ad64:	d1fb      	bne.n	ad5e <delayed_async_print+0xa2>
    next_node->next = node;
    ad66:	60dc      	str	r4, [r3, #12]
    ad68:	e7f6      	b.n	ad58 <delayed_async_print+0x9c>
    ad6a:	46c0      	nop			; (mov r8, r8)
    ad6c:	010024bc 	.word	0x010024bc

0000ad70 <app_at_async_notify_init>:

void app_at_async_notify_init(void)
{
    ad70:	b510      	push	{r4, lr}
    app_at_asyc_semaphore = osMutexNew(NULL);
    ad72:	2000      	movs	r0, #0
    ad74:	4674      	mov	r4, lr
    ad76:	f009 fdff 	bl	14978 <osMutexNew>
    ad7a:	4b04      	ldr	r3, [pc, #16]	; (ad8c <app_at_async_notify_init+0x1c>)
    ad7c:	6018      	str	r0, [r3, #0]
    if (!app_at_asyc_semaphore)
    ad7e:	2800      	cmp	r0, #0
    ad80:	d103      	bne.n	ad8a <app_at_async_notify_init+0x1a>
    {
        assert(false);
    ad82:	0021      	movs	r1, r4
    ad84:	3016      	adds	r0, #22
    ad86:	f7f6 fec3 	bl	1b10 <panic>
    }
}
    ad8a:	bd10      	pop	{r4, pc}
    ad8c:	010024b8 	.word	0x010024b8

0000ad90 <at_handle_NDIEID_cmd_test>:
}

static AT_RET at_handle_NDIEID_cmd_test(void)
{
    return AT_RET_OK;
}
    ad90:	2000      	movs	r0, #0
    ad92:	4770      	bx	lr

0000ad94 <at_set_ciot_opt_callback>:
    app_at_send_at_rsp_string_lines_with_claim_and_log(cgeqos_rsp);

    return AT_RET_OK;
}
static void at_set_ciot_opt_callback(uint8 network_opt_support)
{
    ad94:	b530      	push	{r4, r5, lr}
    char reporting_rsp[AT_MAX_CCIOTOPTI_STR_LEN]       = {0};
    ad96:	240f      	movs	r4, #15
{
    ad98:	0005      	movs	r5, r0
    ad9a:	b087      	sub	sp, #28
    char reporting_rsp[AT_MAX_CCIOTOPTI_STR_LEN]       = {0};
    ad9c:	0022      	movs	r2, r4
    ad9e:	2100      	movs	r1, #0
    ada0:	a802      	add	r0, sp, #8
    ada2:	f7f5 fa9d 	bl	2e0 <memset>

    (void)snprintf(reporting_rsp, AT_MAX_CCIOTOPTI_STR_LEN, "%s%d", AT_CCIOTOPTI_PREFIX_STR, network_opt_support);
    ada6:	0021      	movs	r1, r4
    ada8:	9500      	str	r5, [sp, #0]
    adaa:	4b06      	ldr	r3, [pc, #24]	; (adc4 <at_set_ciot_opt_callback+0x30>)
    adac:	4a06      	ldr	r2, [pc, #24]	; (adc8 <at_set_ciot_opt_callback+0x34>)
    adae:	a802      	add	r0, sp, #8
    adb0:	f00f fd5c 	bl	1a86c <snprintf>
    delayed_async_print(reporting_rsp, AT_FLAG_LOGABLE, 0, 0);
    adb4:	2300      	movs	r3, #0
    adb6:	2108      	movs	r1, #8
    adb8:	001a      	movs	r2, r3
    adba:	a802      	add	r0, sp, #8
    adbc:	f7ff ff7e 	bl	acbc <delayed_async_print>
}
    adc0:	b007      	add	sp, #28
    adc2:	bd30      	pop	{r4, r5, pc}
    adc4:	00023e1e 	.word	0x00023e1e
    adc8:	000248db 	.word	0x000248db

0000adcc <npin_result_callback>:
{
    adcc:	b5f0      	push	{r4, r5, r6, r7, lr}
    adce:	b093      	sub	sp, #76	; 0x4c
    char        rsp_string[AT_MAX_NPIN_RESULT_RSP_LEN] = {0};
    add0:	221e      	movs	r2, #30
{
    add2:	0004      	movs	r4, r0
    add4:	000e      	movs	r6, r1
    char        rsp_string[AT_MAX_NPIN_RESULT_RSP_LEN] = {0};
    add6:	a801      	add	r0, sp, #4
    add8:	2100      	movs	r1, #0
    const char *str_table[9] = {"OK", NULL, "ERROR PIN disabled", "PIN already enabled", "PIN required", "ERROR PIN blocked", NULL, "ERROR wrong format", "ERROR PUK blocked"};
    adda:	ad09      	add	r5, sp, #36	; 0x24
    char        rsp_string[AT_MAX_NPIN_RESULT_RSP_LEN] = {0};
    addc:	f7f5 fa80 	bl	2e0 <memset>
    const char *str_table[9] = {"OK", NULL, "ERROR PIN disabled", "PIN already enabled", "PIN required", "ERROR PIN blocked", NULL, "ERROR wrong format", "ERROR PUK blocked"};
    ade0:	002a      	movs	r2, r5
    ade2:	4b17      	ldr	r3, [pc, #92]	; (ae40 <npin_result_callback+0x74>)
    ade4:	cb83      	ldmia	r3!, {r0, r1, r7}
    ade6:	c283      	stmia	r2!, {r0, r1, r7}
    ade8:	cb83      	ldmia	r3!, {r0, r1, r7}
    adea:	c283      	stmia	r2!, {r0, r1, r7}
    adec:	cb83      	ldmia	r3!, {r0, r1, r7}
    adee:	c283      	stmia	r2!, {r0, r1, r7}
    rsp_len += (uint16)snprintf(rsp_string, AT_MAX_NPIN_RESULT_RSP_LEN, "%s", AT_CMD_NPIN_PREFIX);
    adf0:	4a14      	ldr	r2, [pc, #80]	; (ae44 <npin_result_callback+0x78>)
    adf2:	4b15      	ldr	r3, [pc, #84]	; (ae48 <npin_result_callback+0x7c>)
    adf4:	211e      	movs	r1, #30
    adf6:	a801      	add	r0, sp, #4
    adf8:	f00f fd38 	bl	1a86c <snprintf>
    adfc:	2201      	movs	r2, #1
    if (result == SIM_OK || result == SIM_PIN_DISABLED ||
    adfe:	2c08      	cmp	r4, #8
    ae00:	d803      	bhi.n	ae0a <npin_result_callback+0x3e>
    ae02:	23be      	movs	r3, #190	; 0xbe
    ae04:	33ff      	adds	r3, #255	; 0xff
    ae06:	40e3      	lsrs	r3, r4
    ae08:	439a      	bics	r2, r3
    ae0a:	b283      	uxth	r3, r0
    ae0c:	a901      	add	r1, sp, #4
    ae0e:	18c8      	adds	r0, r1, r3
    ae10:	211e      	movs	r1, #30
    ae12:	1ac9      	subs	r1, r1, r3
    ae14:	2a00      	cmp	r2, #0
    ae16:	d00e      	beq.n	ae36 <npin_result_callback+0x6a>
        (void)snprintf(rsp_string+rsp_len, AT_MAX_NPIN_RESULT_RSP_LEN-rsp_len,"ERROR");
    ae18:	4a0c      	ldr	r2, [pc, #48]	; (ae4c <npin_result_callback+0x80>)
    else if (result == SIM_PIN_MISMATCH)
    ae1a:	2c06      	cmp	r4, #6
    ae1c:	d10d      	bne.n	ae3a <npin_result_callback+0x6e>
        (void)snprintf(rsp_string+rsp_len, AT_MAX_NPIN_RESULT_RSP_LEN-rsp_len, "ERROR wrong PIN (%d)", retries_remaining);
    ae1e:	0033      	movs	r3, r6
    ae20:	4a0b      	ldr	r2, [pc, #44]	; (ae50 <npin_result_callback+0x84>)
    ae22:	f00f fd23 	bl	1a86c <snprintf>
    delayed_async_print(rsp_string, AT_FLAG_LOGABLE, 0, 0);
    ae26:	2300      	movs	r3, #0
    ae28:	2108      	movs	r1, #8
    ae2a:	001a      	movs	r2, r3
    ae2c:	a801      	add	r0, sp, #4
    ae2e:	f7ff ff45 	bl	acbc <delayed_async_print>
}
    ae32:	b013      	add	sp, #76	; 0x4c
    ae34:	bdf0      	pop	{r4, r5, r6, r7, pc}
        (void)snprintf(rsp_string+rsp_len, AT_MAX_NPIN_RESULT_RSP_LEN-rsp_len, str_table[result]);
    ae36:	00a4      	lsls	r4, r4, #2
    ae38:	592a      	ldr	r2, [r5, r4]
        (void)snprintf(rsp_string+rsp_len, AT_MAX_NPIN_RESULT_RSP_LEN-rsp_len,"ERROR");
    ae3a:	f00f fd17 	bl	1a86c <snprintf>
    ae3e:	e7f2      	b.n	ae26 <npin_result_callback+0x5a>
    ae40:	000229f8 	.word	0x000229f8
    ae44:	000237d7 	.word	0x000237d7
    ae48:	000248a3 	.word	0x000248a3
    ae4c:	000233d4 	.word	0x000233d4
    ae50:	000248ab 	.word	0x000248ab

0000ae54 <pdp_context_activate_or_deactivate_callback>:
    return AT_RET_OK;
}


static void pdp_context_activate_or_deactivate_callback(uint8 cid, PDP_CONTEXT_REPORT_RESULT_STATE state, PDP_CONTEXT_REPORT_RESULT result)
{
    ae54:	b5f0      	push	{r4, r5, r6, r7, lr}
    char    auc_rsp_data[AT_CMD_NGACTR_CALLBACK_MAX_LEN]  = {0};
    ae56:	240f      	movs	r4, #15
{
    ae58:	0005      	movs	r5, r0
    ae5a:	000e      	movs	r6, r1
    ae5c:	0017      	movs	r7, r2
    ae5e:	b089      	sub	sp, #36	; 0x24
    char    auc_rsp_data[AT_CMD_NGACTR_CALLBACK_MAX_LEN]  = {0};
    ae60:	0022      	movs	r2, r4
    ae62:	2100      	movs	r1, #0
    ae64:	a804      	add	r0, sp, #16
    ae66:	f7f5 fa3b 	bl	2e0 <memset>

    (void)snprintf(auc_rsp_data, AT_CMD_NGACTR_CALLBACK_MAX_LEN, "%s:%d,%d,%d",AT_CMD_NGACTR_PREFIX, cid, state, result);
    ae6a:	0021      	movs	r1, r4
    ae6c:	9702      	str	r7, [sp, #8]
    ae6e:	9601      	str	r6, [sp, #4]
    ae70:	9500      	str	r5, [sp, #0]
    ae72:	4b06      	ldr	r3, [pc, #24]	; (ae8c <pdp_context_activate_or_deactivate_callback+0x38>)
    ae74:	4a06      	ldr	r2, [pc, #24]	; (ae90 <pdp_context_activate_or_deactivate_callback+0x3c>)
    ae76:	a804      	add	r0, sp, #16
    ae78:	f00f fcf8 	bl	1a86c <snprintf>

    delayed_async_print(auc_rsp_data, AT_FLAG_LOGABLE, 0, 0);
    ae7c:	2300      	movs	r3, #0
    ae7e:	2108      	movs	r1, #8
    ae80:	001a      	movs	r2, r3
    ae82:	a804      	add	r0, sp, #16
    ae84:	f7ff ff1a 	bl	acbc <delayed_async_print>
}
    ae88:	b009      	add	sp, #36	; 0x24
    ae8a:	bdf0      	pop	{r4, r5, r6, r7, pc}
    ae8c:	0002492b 	.word	0x0002492b
    ae90:	00024933 	.word	0x00024933

0000ae94 <at_socket_sent_callback>:
{
    ae94:	b570      	push	{r4, r5, r6, lr}
    ae96:	b08a      	sub	sp, #40	; 0x28
    ae98:	0006      	movs	r6, r0
    ae9a:	000c      	movs	r4, r1
    ae9c:	0015      	movs	r5, r2
    char rsp_string[AT_MAX_SENT_DATA_RSP_LEN] = {0};
    ae9e:	2100      	movs	r1, #0
    aea0:	2214      	movs	r2, #20
    aea2:	a805      	add	r0, sp, #20
    aea4:	f7f5 fa1c 	bl	2e0 <memset>
    if (sock_num != 0xFF)
    aea8:	2eff      	cmp	r6, #255	; 0xff
    aeaa:	d010      	beq.n	aece <at_socket_sent_callback+0x3a>
        (void)snprintf(rsp_string, AT_MAX_SENT_DATA_RSP_LEN, "%s%d,%d,%d", AT_CMD_SENT_DATA_RSP_STR, sock_num, seq_num, (uint8)data_status);
    aeac:	9502      	str	r5, [sp, #8]
    aeae:	9401      	str	r4, [sp, #4]
    aeb0:	9600      	str	r6, [sp, #0]
    aeb2:	4b0b      	ldr	r3, [pc, #44]	; (aee0 <at_socket_sent_callback+0x4c>)
    aeb4:	4a0b      	ldr	r2, [pc, #44]	; (aee4 <at_socket_sent_callback+0x50>)
    aeb6:	2114      	movs	r1, #20
    aeb8:	a805      	add	r0, sp, #20
    aeba:	f00f fcd7 	bl	1a86c <snprintf>
    delayed_async_print(rsp_string, AT_FLAG_LOGABLE, 0, 0);
    aebe:	2300      	movs	r3, #0
    aec0:	2108      	movs	r1, #8
    aec2:	001a      	movs	r2, r3
    aec4:	a805      	add	r0, sp, #20
    aec6:	f7ff fef9 	bl	acbc <delayed_async_print>
}
    aeca:	b00a      	add	sp, #40	; 0x28
    aecc:	bd70      	pop	{r4, r5, r6, pc}
        (void)snprintf(rsp_string, AT_MAX_SENT_DATA_RSP_LEN, "%s%d,%d", AT_CMD_NONIP_SENT_DATA_STPR, seq_num, (uint8)data_status);
    aece:	9501      	str	r5, [sp, #4]
    aed0:	9400      	str	r4, [sp, #0]
    aed2:	4b05      	ldr	r3, [pc, #20]	; (aee8 <at_socket_sent_callback+0x54>)
    aed4:	4a05      	ldr	r2, [pc, #20]	; (aeec <at_socket_sent_callback+0x58>)
    aed6:	2114      	movs	r1, #20
    aed8:	a805      	add	r0, sp, #20
    aeda:	f00f fcc7 	bl	1a86c <snprintf>
    aede:	e7ee      	b.n	aebe <at_socket_sent_callback+0x2a>
    aee0:	00023e66 	.word	0x00023e66
    aee4:	00023e6f 	.word	0x00023e6f
    aee8:	00023e7a 	.word	0x00023e7a
    aeec:	00023e83 	.word	0x00023e83

0000aef0 <socket_callback>:
{
    aef0:	b570      	push	{r4, r5, r6, lr}
    char  rsp_string[7 + 1 + MAX_UINT16_CHARACTERS + 1 + MAX_UINT32_CHARACTERS + 1] = {0};//strlen(AT_NSONMI=7 + colon + socket(max 5 digits) + comma + length(max 10 digits)
    aef2:	2419      	movs	r4, #25
{
    aef4:	0005      	movs	r5, r0
    aef6:	000e      	movs	r6, r1
    aef8:	b08a      	sub	sp, #40	; 0x28
    char  rsp_string[7 + 1 + MAX_UINT16_CHARACTERS + 1 + MAX_UINT32_CHARACTERS + 1] = {0};//strlen(AT_NSONMI=7 + colon + socket(max 5 digits) + comma + length(max 10 digits)
    aefa:	0022      	movs	r2, r4
    aefc:	2100      	movs	r1, #0
    aefe:	a803      	add	r0, sp, #12
    af00:	f7f5 f9ee 	bl	2e0 <memset>
     (void)snprintf(rsp_string, sizeof(rsp_string), "%s:%d,%d", AT_NSONMI, socket, length);
    af04:	0021      	movs	r1, r4
    af06:	9601      	str	r6, [sp, #4]
    af08:	9500      	str	r5, [sp, #0]
    af0a:	4b06      	ldr	r3, [pc, #24]	; (af24 <socket_callback+0x34>)
    af0c:	4a06      	ldr	r2, [pc, #24]	; (af28 <socket_callback+0x38>)
    af0e:	a803      	add	r0, sp, #12
    af10:	f00f fcac 	bl	1a86c <snprintf>
    delayed_async_print(rsp_string, AT_FLAG_LOGABLE, 0, 0);
    af14:	2300      	movs	r3, #0
    af16:	2108      	movs	r1, #8
    af18:	001a      	movs	r2, r3
    af1a:	a803      	add	r0, sp, #12
    af1c:	f7ff fece 	bl	acbc <delayed_async_print>
}
    af20:	b00a      	add	sp, #40	; 0x28
    af22:	bd70      	pop	{r4, r5, r6, pc}
    af24:	00024977 	.word	0x00024977
    af28:	0002497f 	.word	0x0002497f

0000af2c <connection_status_callback>:
{
    af2c:	b530      	push	{r4, r5, lr}
    char    auc_rsp_data[AT_MAX_RSP_LEN]  = {0};
    af2e:	24c8      	movs	r4, #200	; 0xc8
{
    af30:	0005      	movs	r5, r0
    af32:	b0b5      	sub	sp, #212	; 0xd4
    char    auc_rsp_data[AT_MAX_RSP_LEN]  = {0};
    af34:	0022      	movs	r2, r4
    af36:	2100      	movs	r1, #0
    af38:	a802      	add	r0, sp, #8
    af3a:	f7f5 f9d1 	bl	2e0 <memset>
    uc_len = (uint16)snprintf(auc_rsp_data, AT_MAX_RSP_LEN, "+CSCON:%d",connection_status);
    af3e:	002b      	movs	r3, r5
    af40:	4a12      	ldr	r2, [pc, #72]	; (af8c <connection_status_callback+0x60>)
    af42:	0021      	movs	r1, r4
    af44:	a802      	add	r0, sp, #8
    af46:	f00f fc91 	bl	1a86c <snprintf>
    if(app_at_state_info.read_connection_state_mode == 2)
    af4a:	4b11      	ldr	r3, [pc, #68]	; (af90 <connection_status_callback+0x64>)
    af4c:	785b      	ldrb	r3, [r3, #1]
    af4e:	2b02      	cmp	r3, #2
    af50:	d10f      	bne.n	af72 <connection_status_callback+0x46>
    af52:	b280      	uxth	r0, r0
        uc_len += (uint16)snprintf(auc_rsp_data + uc_len, AT_MAX_RSP_LEN - uc_len, ",%d", ACT_VALUE_E_UTRAN_NB_S1_MODE);
    af54:	ab02      	add	r3, sp, #8
    af56:	1a21      	subs	r1, r4, r0
    af58:	4a0e      	ldr	r2, [pc, #56]	; (af94 <connection_status_callback+0x68>)
    af5a:	1818      	adds	r0, r3, r0
    af5c:	2309      	movs	r3, #9
    af5e:	f00f fc85 	bl	1a86c <snprintf>
    delayed_async_print(auc_rsp_data, AT_FLAG_LOGABLE, 0, 0);
    af62:	2300      	movs	r3, #0
    af64:	2108      	movs	r1, #8
    af66:	001a      	movs	r2, r3
    af68:	a802      	add	r0, sp, #8
    af6a:	f7ff fea7 	bl	acbc <delayed_async_print>
}
    af6e:	b035      	add	sp, #212	; 0xd4
    af70:	bd30      	pop	{r4, r5, pc}
    else if(app_at_state_info.read_connection_state_mode == 3)
    af72:	2b03      	cmp	r3, #3
    af74:	d1f5      	bne.n	af62 <connection_status_callback+0x36>
        uc_len += (uint16)snprintf(auc_rsp_data + uc_len, AT_MAX_RSP_LEN - uc_len, ",%d,%d", ACT_VALUE_E_UTRAN_NB_S1_MODE, ACCESS_E_UTRAN_FDD);
    af76:	ab02      	add	r3, sp, #8
    af78:	b280      	uxth	r0, r0
    af7a:	1a21      	subs	r1, r4, r0
    af7c:	1818      	adds	r0, r3, r0
    af7e:	2304      	movs	r3, #4
    af80:	4a05      	ldr	r2, [pc, #20]	; (af98 <connection_status_callback+0x6c>)
    af82:	9300      	str	r3, [sp, #0]
    af84:	3305      	adds	r3, #5
    af86:	f00f fc71 	bl	1a86c <snprintf>
    af8a:	e7ea      	b.n	af62 <connection_status_callback+0x36>
    af8c:	00023f5d 	.word	0x00023f5d
    af90:	010024c2 	.word	0x010024c2
    af94:	0002394e 	.word	0x0002394e
    af98:	00023734 	.word	0x00023734

0000af9c <at_handle_NCIDSTATUS_cmd_test>:

    return AT_RET_OK;
}

static AT_RET at_handle_NCIDSTATUS_cmd_test(void)
{
    af9c:	b510      	push	{r4, lr}
    app_at_send_at_rsp_string_lines_with_claim_and_log("+NCIDSTATUS:(0-10)");
    af9e:	4802      	ldr	r0, [pc, #8]	; (afa8 <at_handle_NCIDSTATUS_cmd_test+0xc>)
    afa0:	f7fe fb20 	bl	95e4 <app_at_send_at_rsp_string_lines_with_claim_and_log>

    return AT_RET_OK;
}
    afa4:	2000      	movs	r0, #0
    afa6:	bd10      	pop	{r4, pc}
    afa8:	00023ad1 	.word	0x00023ad1

0000afac <at_handle_NSOSTATUS_cmd_test>:
{
    afac:	b510      	push	{r4, lr}
    app_at_send_at_rsp_string_lines_with_claim_and_log("+NSOSTATUS:(0-6)");
    afae:	4802      	ldr	r0, [pc, #8]	; (afb8 <at_handle_NSOSTATUS_cmd_test+0xc>)
    afb0:	f7fe fb18 	bl	95e4 <app_at_send_at_rsp_string_lines_with_claim_and_log>
}
    afb4:	2000      	movs	r0, #0
    afb6:	bd10      	pop	{r4, pc}
    afb8:	00023d8d 	.word	0x00023d8d

0000afbc <at_handle_CGEQOS_cmd_test>:
{
    afbc:	b5f0      	push	{r4, r5, r6, r7, lr}
    afbe:	b093      	sub	sp, #76	; 0x4c
    uint8         cids[AT_MAX_CID + 1]                  = {0};
    afc0:	ae02      	add	r6, sp, #8
    afc2:	220b      	movs	r2, #11
    afc4:	2100      	movs	r1, #0
    afc6:	0030      	movs	r0, r6
    afc8:	f7f5 f98a 	bl	2e0 <memset>
    char          cgeqos_rsp[AT_MAX_CGEQOS_TEST_RSP_LEN]       = {0};
    afcc:	2232      	movs	r2, #50	; 0x32
    afce:	2100      	movs	r1, #0
    afd0:	a805      	add	r0, sp, #20
    afd2:	f7f5 f985 	bl	2e0 <memset>
    result = get_defined_cids(AT_MAX_CID + 1, &cids_num, cids);
    afd6:	466b      	mov	r3, sp
    afd8:	0032      	movs	r2, r6
    afda:	1d99      	adds	r1, r3, #6
    afdc:	200b      	movs	r0, #11
    afde:	f011 f94e 	bl	1c27e <get_defined_cids>
    afe2:	1e05      	subs	r5, r0, #0
    if (result != NEUL_RET_OK)
    afe4:	d12f      	bne.n	b046 <at_handle_CGEQOS_cmd_test+0x8a>
    rsp_len = (uint16)snprintf(cgeqos_rsp, AT_MAX_CGEQOS_TEST_RSP_LEN, "%s(", AT_CGEQOS_PRE_STRING);
    afe6:	4b1f      	ldr	r3, [pc, #124]	; (b064 <at_handle_CGEQOS_cmd_test+0xa8>)
    afe8:	4a1f      	ldr	r2, [pc, #124]	; (b068 <at_handle_CGEQOS_cmd_test+0xac>)
    afea:	2132      	movs	r1, #50	; 0x32
    afec:	a805      	add	r0, sp, #20
    afee:	f00f fc3d 	bl	1a86c <snprintf>
    aff2:	b284      	uxth	r4, r0
    for(i = 0 ; i < cids_num; i++)
    aff4:	466b      	mov	r3, sp
    aff6:	88db      	ldrh	r3, [r3, #6]
    aff8:	4f1c      	ldr	r7, [pc, #112]	; (b06c <at_handle_CGEQOS_cmd_test+0xb0>)
    affa:	42ab      	cmp	r3, r5
    affc:	d826      	bhi.n	b04c <at_handle_CGEQOS_cmd_test+0x90>
    if (i != 0)
    affe:	2d00      	cmp	r5, #0
    b000:	d001      	beq.n	b006 <at_handle_CGEQOS_cmd_test+0x4a>
        rsp_len--;
    b002:	3c01      	subs	r4, #1
    b004:	b2a4      	uxth	r4, r4
    rsp_len += (uint16)snprintf(cgeqos_rsp + rsp_len, AT_MAX_CGEQOS_TEST_RSP_LEN, "),(");
    b006:	ab05      	add	r3, sp, #20
    b008:	1918      	adds	r0, r3, r4
    b00a:	4a19      	ldr	r2, [pc, #100]	; (b070 <at_handle_CGEQOS_cmd_test+0xb4>)
    b00c:	2132      	movs	r1, #50	; 0x32
    b00e:	f00f fc2d 	bl	1a86c <snprintf>
    b012:	2500      	movs	r5, #0
    b014:	1824      	adds	r4, r4, r0
    b016:	b2a4      	uxth	r4, r4
       rsp_len += (uint16)snprintf(cgeqos_rsp + rsp_len, AT_MAX_CGEQOS_TEST_RSP_LEN, "%d,", at_cgeqos_support_qci_value[i]);
    b018:	4b16      	ldr	r3, [pc, #88]	; (b074 <at_handle_CGEQOS_cmd_test+0xb8>)
    b01a:	aa05      	add	r2, sp, #20
    b01c:	1910      	adds	r0, r2, r4
    b01e:	5ceb      	ldrb	r3, [r5, r3]
    b020:	003a      	movs	r2, r7
    b022:	2132      	movs	r1, #50	; 0x32
    b024:	f00f fc22 	bl	1a86c <snprintf>
    b028:	3501      	adds	r5, #1
    b02a:	1824      	adds	r4, r4, r0
    b02c:	b2a4      	uxth	r4, r4
    for(i = 0 ; i < sizeof(at_cgeqos_support_qci_value); i++)
    b02e:	2d07      	cmp	r5, #7
    b030:	d1f2      	bne.n	b018 <at_handle_CGEQOS_cmd_test+0x5c>
    rsp_len += (uint16)snprintf(cgeqos_rsp + rsp_len - 1, AT_MAX_CGEQOS_TEST_RSP_LEN, ")");
    b032:	ab05      	add	r3, sp, #20
    b034:	3c01      	subs	r4, #1
    b036:	1918      	adds	r0, r3, r4
    b038:	4a0f      	ldr	r2, [pc, #60]	; (b078 <at_handle_CGEQOS_cmd_test+0xbc>)
    b03a:	2132      	movs	r1, #50	; 0x32
    b03c:	f00f fc16 	bl	1a86c <snprintf>
    app_at_send_at_rsp_string_lines_with_claim_and_log(cgeqos_rsp);
    b040:	a805      	add	r0, sp, #20
    b042:	f7fe facf 	bl	95e4 <app_at_send_at_rsp_string_lines_with_claim_and_log>
}
    b046:	2000      	movs	r0, #0
    b048:	b013      	add	sp, #76	; 0x4c
    b04a:	bdf0      	pop	{r4, r5, r6, r7, pc}
       rsp_len += (uint16)snprintf(cgeqos_rsp + rsp_len, AT_MAX_CGEQOS_TEST_RSP_LEN, "%d,", cids[i]);
    b04c:	aa05      	add	r2, sp, #20
    b04e:	1910      	adds	r0, r2, r4
    b050:	5d73      	ldrb	r3, [r6, r5]
    b052:	003a      	movs	r2, r7
    b054:	2132      	movs	r1, #50	; 0x32
    b056:	f00f fc09 	bl	1a86c <snprintf>
    for(i = 0 ; i < cids_num; i++)
    b05a:	3501      	adds	r5, #1
       rsp_len += (uint16)snprintf(cgeqos_rsp + rsp_len, AT_MAX_CGEQOS_TEST_RSP_LEN, "%d,", cids[i]);
    b05c:	1824      	adds	r4, r4, r0
    b05e:	b2a4      	uxth	r4, r4
    for(i = 0 ; i < cids_num; i++)
    b060:	b2ad      	uxth	r5, r5
    b062:	e7c7      	b.n	aff4 <at_handle_CGEQOS_cmd_test+0x38>
    b064:	00023796 	.word	0x00023796
    b068:	0002379f 	.word	0x0002379f
    b06c:	000234e4 	.word	0x000234e4
    b070:	000237a3 	.word	0x000237a3
    b074:	00023529 	.word	0x00023529
    b078:	00023d40 	.word	0x00023d40

0000b07c <at_handle_CCIOTOPT_cmd_test>:
{
    b07c:	b510      	push	{r4, lr}
    app_at_send_at_rsp_string_lines_with_claim_and_log("+CCIOTOPT:(0,1,3),(1,3),(1,2)");
    b07e:	4802      	ldr	r0, [pc, #8]	; (b088 <at_handle_CCIOTOPT_cmd_test+0xc>)
    b080:	f7fe fab0 	bl	95e4 <app_at_send_at_rsp_string_lines_with_claim_and_log>
}
    b084:	2000      	movs	r0, #0
    b086:	bd10      	pop	{r4, pc}
    b088:	000235a9 	.word	0x000235a9

0000b08c <at_handle_NCPCDPR_cmd_test>:
{
    b08c:	b530      	push	{r4, r5, lr}
    char             rsp_string[AT_CMD_NCPCNPR_TEST_RES_MAX_LEN]      = {0};
    b08e:	251b      	movs	r5, #27
{
    b090:	b08b      	sub	sp, #44	; 0x2c
    char             rsp_string[AT_CMD_NCPCNPR_TEST_RES_MAX_LEN]      = {0};
    b092:	002a      	movs	r2, r5
    b094:	2100      	movs	r1, #0
    b096:	a803      	add	r0, sp, #12
    b098:	f7f5 f922 	bl	2e0 <memset>
    (void)snprintf(rsp_string, AT_CMD_NCPCNPR_TEST_RES_MAX_LEN, "%s(%d,%d),(0,1)", AT_CMD_NCPCDPR_STR, DNS_SERVER_IPV4_ADDR_REQUEST, DNS_SERVER_IPV6_ADDR_REQUEST);
    b09c:	2400      	movs	r4, #0
    b09e:	2301      	movs	r3, #1
    b0a0:	4a06      	ldr	r2, [pc, #24]	; (b0bc <at_handle_NCPCDPR_cmd_test+0x30>)
    b0a2:	9301      	str	r3, [sp, #4]
    b0a4:	0029      	movs	r1, r5
    b0a6:	4b06      	ldr	r3, [pc, #24]	; (b0c0 <at_handle_NCPCDPR_cmd_test+0x34>)
    b0a8:	9400      	str	r4, [sp, #0]
    b0aa:	a803      	add	r0, sp, #12
    b0ac:	f00f fbde 	bl	1a86c <snprintf>
    app_at_send_at_rsp_string_lines_with_claim_and_log(rsp_string);
    b0b0:	a803      	add	r0, sp, #12
    b0b2:	f7fe fa97 	bl	95e4 <app_at_send_at_rsp_string_lines_with_claim_and_log>
}
    b0b6:	0020      	movs	r0, r4
    b0b8:	b00b      	add	sp, #44	; 0x2c
    b0ba:	bd30      	pop	{r4, r5, pc}
    b0bc:	00023bb5 	.word	0x00023bb5
    b0c0:	00023bab 	.word	0x00023bab

0000b0c4 <at_handle_NXLOG_cmd_test>:
{
    b0c4:	b510      	push	{r4, lr}
    app_at_send_at_rsp_string_lines_with_claim_and_log("+NXLOG:(DUMP)");
    b0c6:	4802      	ldr	r0, [pc, #8]	; (b0d0 <at_handle_NXLOG_cmd_test+0xc>)
    b0c8:	f7fe fa8c 	bl	95e4 <app_at_send_at_rsp_string_lines_with_claim_and_log>
}
    b0cc:	2000      	movs	r0, #0
    b0ce:	bd10      	pop	{r4, pc}
    b0d0:	00023db9 	.word	0x00023db9

0000b0d4 <at_handle_NIPINFO_cmd_test>:
{
    b0d4:	b510      	push	{r4, lr}
    app_at_send_at_rsp_string_lines_with_claim_and_log("+NIPINFO:(0,1)");
    b0d6:	4802      	ldr	r0, [pc, #8]	; (b0e0 <at_handle_NIPINFO_cmd_test+0xc>)
    b0d8:	f7fe fa84 	bl	95e4 <app_at_send_at_rsp_string_lines_with_claim_and_log>
}
    b0dc:	2000      	movs	r0, #0
    b0de:	bd10      	pop	{r4, pc}
    b0e0:	00023bfc 	.word	0x00023bfc

0000b0e4 <at_handle_NIPINFO_cmd_read>:
{
    b0e4:	b51f      	push	{r0, r1, r2, r3, r4, lr}
    char rsp_string[AT_IPINFO_READ_RSP_LEN] = {0};
    b0e6:	240b      	movs	r4, #11
    b0e8:	2100      	movs	r1, #0
    b0ea:	0022      	movs	r2, r4
    b0ec:	a801      	add	r0, sp, #4
    b0ee:	f7f5 f8f7 	bl	2e0 <memset>
    (void)snprintf(rsp_string, AT_IPINFO_READ_RSP_LEN, "+NIPINFO:%d", app_at_ip_info);
    b0f2:	4b06      	ldr	r3, [pc, #24]	; (b10c <at_handle_NIPINFO_cmd_read+0x28>)
    b0f4:	4a06      	ldr	r2, [pc, #24]	; (b110 <at_handle_NIPINFO_cmd_read+0x2c>)
    b0f6:	781b      	ldrb	r3, [r3, #0]
    b0f8:	0021      	movs	r1, r4
    b0fa:	a801      	add	r0, sp, #4
    b0fc:	f00f fbb6 	bl	1a86c <snprintf>
    app_at_send_at_rsp_string_lines_with_claim_and_log(rsp_string);
    b100:	a801      	add	r0, sp, #4
    b102:	f7fe fa6f 	bl	95e4 <app_at_send_at_rsp_string_lines_with_claim_and_log>
}
    b106:	2000      	movs	r0, #0
    b108:	b004      	add	sp, #16
    b10a:	bd10      	pop	{r4, pc}
    b10c:	010024c1 	.word	0x010024c1
    b110:	00023bf0 	.word	0x00023bf0

0000b114 <at_handle_CGDATA_cmd_test>:
{
    b114:	b510      	push	{r4, lr}
    app_at_send_at_rsp_string_lines_with_claim_and_log(CGDATA_TEST_STRING);
    b116:	4802      	ldr	r0, [pc, #8]	; (b120 <at_handle_CGDATA_cmd_test+0xc>)
    b118:	f7fe fa64 	bl	95e4 <app_at_send_at_rsp_string_lines_with_claim_and_log>
}
    b11c:	2000      	movs	r0, #0
    b11e:	bd10      	pop	{r4, pc}
    b120:	00023702 	.word	0x00023702

0000b124 <at_handle_CIPCA_cmd_test>:
{
    b124:	b510      	push	{r4, lr}
    app_at_send_at_rsp_string_lines_with_claim_and_log("+CIPCA:(3),(0,1)");
    b126:	4802      	ldr	r0, [pc, #8]	; (b130 <at_handle_CIPCA_cmd_test+0xc>)
    b128:	f7fe fa5c 	bl	95e4 <app_at_send_at_rsp_string_lines_with_claim_and_log>
}
    b12c:	2000      	movs	r0, #0
    b12e:	bd10      	pop	{r4, pc}
    b130:	00023871 	.word	0x00023871

0000b134 <at_handle_NPRDEFLASH_cmd_test>:
{
    b134:	b510      	push	{r4, lr}
    app_at_send_at_rsp_string_lines_with_claim_and_log("+NPRDFLASH:(WRITE,READ,ERASE)");
    b136:	4802      	ldr	r0, [pc, #8]	; (b140 <at_handle_NPRDEFLASH_cmd_test+0xc>)
    b138:	f7fe fa54 	bl	95e4 <app_at_send_at_rsp_string_lines_with_claim_and_log>
}
    b13c:	2000      	movs	r0, #0
    b13e:	bd10      	pop	{r4, pc}
    b140:	00023cd6 	.word	0x00023cd6

0000b144 <at_handle_NFWUPD_cmd_test>:
{
    b144:	b510      	push	{r4, lr}
    app_at_send_at_rsp_string_lines_with_claim_and_log("+NFWUPD:(0-5)");
    b146:	4802      	ldr	r0, [pc, #8]	; (b150 <at_handle_NFWUPD_cmd_test+0xc>)
    b148:	f7fe fa4c 	bl	95e4 <app_at_send_at_rsp_string_lines_with_claim_and_log>
}
    b14c:	2000      	movs	r0, #0
    b14e:	bd10      	pop	{r4, pc}
    b150:	00023bce 	.word	0x00023bce

0000b154 <at_handle_NPTWEDRXS_cmd_test>:
{
    b154:	b510      	push	{r4, lr}
    app_at_send_at_rsp_string_lines_with_claim_and_log("+NPTWEDRXS:(0,1,2,3),(5),(\"0000\"-\"1111\"),(\"0000\"-\"1111\")");
    b156:	4802      	ldr	r0, [pc, #8]	; (b160 <at_handle_NPTWEDRXS_cmd_test+0xc>)
    b158:	f7fe fa44 	bl	95e4 <app_at_send_at_rsp_string_lines_with_claim_and_log>
}
    b15c:	2000      	movs	r0, #0
    b15e:	bd10      	pop	{r4, pc}
    b160:	00023d09 	.word	0x00023d09

0000b164 <at_handle_CEDRXS_cmd_test>:
{
    b164:	b510      	push	{r4, lr}
    app_at_send_at_rsp_string_lines_with_claim_and_log("+CEDRXS:(0,1,2,3),(5),(\"0000\"-\"1111\")");
    b166:	4802      	ldr	r0, [pc, #8]	; (b170 <at_handle_CEDRXS_cmd_test+0xc>)
    b168:	f7fe fa3c 	bl	95e4 <app_at_send_at_rsp_string_lines_with_claim_and_log>
}
    b16c:	2000      	movs	r0, #0
    b16e:	bd10      	pop	{r4, pc}
    b170:	000235fc 	.word	0x000235fc

0000b174 <at_handle_NGACTR_cmd_test>:
{
    b174:	b510      	push	{r4, lr}
    app_at_send_at_rsp_string_lines_with_claim_and_log("+NGACTR:(0,1)");
    b176:	4802      	ldr	r0, [pc, #8]	; (b180 <at_handle_NGACTR_cmd_test+0xc>)
    b178:	f7fe fa34 	bl	95e4 <app_at_send_at_rsp_string_lines_with_claim_and_log>
}
    b17c:	2000      	movs	r0, #0
    b17e:	bd10      	pop	{r4, pc}
    b180:	00023be2 	.word	0x00023be2

0000b184 <at_handle_NGACTR_cmd_read>:
{
    b184:	b510      	push	{r4, lr}
    char      auc_rsp_data[AT_CMD_NGACTR_READ_RSP_MAX_LEN] = {0};
    b186:	240a      	movs	r4, #10
{
    b188:	b086      	sub	sp, #24
    char      auc_rsp_data[AT_CMD_NGACTR_READ_RSP_MAX_LEN] = {0};
    b18a:	0022      	movs	r2, r4
    b18c:	2100      	movs	r1, #0
    b18e:	a803      	add	r0, sp, #12
    b190:	f7f5 f8a6 	bl	2e0 <memset>
    (void)snprintf(auc_rsp_data, AT_CMD_NGACTR_READ_RSP_MAX_LEN, "%s:%d", AT_CMD_NGACTR_PREFIX, app_at_state_info.ngactr_mode);
    b194:	4b07      	ldr	r3, [pc, #28]	; (b1b4 <at_handle_NGACTR_cmd_read+0x30>)
    b196:	4a08      	ldr	r2, [pc, #32]	; (b1b8 <at_handle_NGACTR_cmd_read+0x34>)
    b198:	795b      	ldrb	r3, [r3, #5]
    b19a:	0021      	movs	r1, r4
    b19c:	9300      	str	r3, [sp, #0]
    b19e:	a803      	add	r0, sp, #12
    b1a0:	4b06      	ldr	r3, [pc, #24]	; (b1bc <at_handle_NGACTR_cmd_read+0x38>)
    b1a2:	f00f fb63 	bl	1a86c <snprintf>
    app_at_send_at_rsp_string_lines_with_claim_and_log(auc_rsp_data);
    b1a6:	a803      	add	r0, sp, #12
    b1a8:	f7fe fa1c 	bl	95e4 <app_at_send_at_rsp_string_lines_with_claim_and_log>
}
    b1ac:	2000      	movs	r0, #0
    b1ae:	b006      	add	sp, #24
    b1b0:	bd10      	pop	{r4, pc}
    b1b2:	46c0      	nop			; (mov r8, r8)
    b1b4:	010024c2 	.word	0x010024c2
    b1b8:	00023bdc 	.word	0x00023bdc
    b1bc:	0002492b 	.word	0x0002492b

0000b1c0 <at_handle_CGACT_cmd_test>:
{
    b1c0:	b510      	push	{r4, lr}
    app_at_send_at_rsp_string_lines_with_claim_and_log("+CGACT:(0,1)");
    b1c2:	4802      	ldr	r0, [pc, #8]	; (b1cc <at_handle_CGACT_cmd_test+0xc>)
    b1c4:	f7fe fa0e 	bl	95e4 <app_at_send_at_rsp_string_lines_with_claim_and_log>
}
    b1c8:	2000      	movs	r0, #0
    b1ca:	bd10      	pop	{r4, pc}
    b1cc:	0002367b 	.word	0x0002367b

0000b1d0 <at_handle_CNMA_cmd_test>:
{
    b1d0:	b510      	push	{r4, lr}
    app_at_send_at_rsp_string_lines_with_claim_and_log("+CNMA:(1,2)");
    b1d2:	4802      	ldr	r0, [pc, #8]	; (b1dc <at_handle_CNMA_cmd_test+0xc>)
    b1d4:	f7fe fa06 	bl	95e4 <app_at_send_at_rsp_string_lines_with_claim_and_log>
}
    b1d8:	2000      	movs	r0, #0
    b1da:	bd10      	pop	{r4, pc}
    b1dc:	000238b4 	.word	0x000238b4

0000b1e0 <at_handle_CMMS_cmd_test>:
{
    b1e0:	b510      	push	{r4, lr}
    app_at_send_at_rsp_string_lines_with_claim_and_log("+CMMS:(0,1,2)");
    b1e2:	4802      	ldr	r0, [pc, #8]	; (b1ec <at_handle_CMMS_cmd_test+0xc>)
    b1e4:	f7fe f9fe 	bl	95e4 <app_at_send_at_rsp_string_lines_with_claim_and_log>
}
    b1e8:	2000      	movs	r0, #0
    b1ea:	bd10      	pop	{r4, pc}
    b1ec:	000238a6 	.word	0x000238a6

0000b1f0 <at_handle_CSMS_cmd_test>:
{
    b1f0:	b510      	push	{r4, lr}
    app_at_send_at_rsp_string_lines_with_claim_and_log("+CSMS:(0,1)");
    b1f2:	4802      	ldr	r0, [pc, #8]	; (b1fc <at_handle_CSMS_cmd_test+0xc>)
    b1f4:	f7fe f9f6 	bl	95e4 <app_at_send_at_rsp_string_lines_with_claim_and_log>
}
    b1f8:	2000      	movs	r0, #0
    b1fa:	bd10      	pop	{r4, pc}
    b1fc:	0002397f 	.word	0x0002397f

0000b200 <at_handle_CPSMS_cmd_test>:
{
    b200:	b510      	push	{r4, lr}
    app_at_send_at_rsp_string_lines_with_claim_and_log(AT_CPSMS_TEST_RSP);
    b202:	4802      	ldr	r0, [pc, #8]	; (b20c <at_handle_CPSMS_cmd_test+0xc>)
    b204:	f7fe f9ee 	bl	95e4 <app_at_send_at_rsp_string_lines_with_claim_and_log>
}
    b208:	2000      	movs	r0, #0
    b20a:	bd10      	pop	{r4, pc}
    b20c:	000238fe 	.word	0x000238fe

0000b210 <at_handle_NTPERMID_cmd_test>:
{
    b210:	b510      	push	{r4, lr}
    app_at_send_at_rsp_string_lines_with_claim_and_log("+NTPERMID:(0,1),(1,2)");
    b212:	4802      	ldr	r0, [pc, #8]	; (b21c <at_handle_NTPERMID_cmd_test+0xc>)
    b214:	f7fe f9e6 	bl	95e4 <app_at_send_at_rsp_string_lines_with_claim_and_log>
}
    b218:	2000      	movs	r0, #0
    b21a:	bd10      	pop	{r4, pc}
    b21c:	00023d9e 	.word	0x00023d9e

0000b220 <at_handle_NATSPEED_cmd_test>:
{
    b220:	b510      	push	{r4, lr}
    app_at_send_at_rsp_string_lines_with_claim_and_log(AT_NATSPEED_TEST_STRING);
    b222:	4802      	ldr	r0, [pc, #8]	; (b22c <at_handle_NATSPEED_cmd_test+0xc>)
    b224:	f7fe f9de 	bl	95e4 <app_at_send_at_rsp_string_lines_with_claim_and_log>
}
    b228:	2000      	movs	r0, #0
    b22a:	bd10      	pop	{r4, pc}
    b22c:	00023a02 	.word	0x00023a02

0000b230 <at_handle_CGSN_cmd_test>:
{
    b230:	b510      	push	{r4, lr}
    app_at_send_at_rsp_string_lines_with_claim_and_log("+CGSN:(0,1,2,3)");
    b232:	4802      	ldr	r0, [pc, #8]	; (b23c <at_handle_CGSN_cmd_test+0xc>)
    b234:	f7fe f9d6 	bl	95e4 <app_at_send_at_rsp_string_lines_with_claim_and_log>
}
    b238:	2000      	movs	r0, #0
    b23a:	bd10      	pop	{r4, pc}
    b23c:	000237bd 	.word	0x000237bd

0000b240 <at_handle_NLOGLEVEL_cmd_test>:
{
    b240:	b510      	push	{r4, lr}
    app_at_send_at_rsp_string_lines_with_claim_and_log(AT_NLOGLEVEL_TEST_STRING);
    b242:	4802      	ldr	r0, [pc, #8]	; (b24c <at_handle_NLOGLEVEL_cmd_test+0xc>)
    b244:	f7fe f9ce 	bl	95e4 <app_at_send_at_rsp_string_lines_with_claim_and_log>
}
    b248:	2000      	movs	r0, #0
    b24a:	bd10      	pop	{r4, pc}
    b24c:	00023c4c 	.word	0x00023c4c

0000b250 <at_handle_CTZR_cmd_test>:
{
    b250:	b510      	push	{r4, lr}
    app_at_send_at_rsp_string_lines_with_claim_and_log("+CTZR:(0,1,2,3)");
    b252:	4802      	ldr	r0, [pc, #8]	; (b25c <at_handle_CTZR_cmd_test+0xc>)
    b254:	f7fe f9c6 	bl	95e4 <app_at_send_at_rsp_string_lines_with_claim_and_log>
}
    b258:	2000      	movs	r0, #0
    b25a:	bd10      	pop	{r4, pc}
    b25c:	000239bc 	.word	0x000239bc

0000b260 <at_handle_CTZR_cmd_read>:
{
    b260:	b510      	push	{r4, lr}
    char        ctzr_read_rsp_str[AT_MAX_CTZR_READ_RSP_LEN] = {0};
    b262:	2409      	movs	r4, #9
{
    b264:	b086      	sub	sp, #24
    char        ctzr_read_rsp_str[AT_MAX_CTZR_READ_RSP_LEN] = {0};
    b266:	0022      	movs	r2, r4
    b268:	2100      	movs	r1, #0
    b26a:	a803      	add	r0, sp, #12
    b26c:	f7f5 f838 	bl	2e0 <memset>
    (void)snprintf(ctzr_read_rsp_str, AT_MAX_CTZR_READ_RSP_LEN, "%s%d", AT_CTZR_RPEFIX, app_at_state_info.ctzr_mode);
    b270:	4b07      	ldr	r3, [pc, #28]	; (b290 <at_handle_CTZR_cmd_read+0x30>)
    b272:	4a08      	ldr	r2, [pc, #32]	; (b294 <at_handle_CTZR_cmd_read+0x34>)
    b274:	789b      	ldrb	r3, [r3, #2]
    b276:	0021      	movs	r1, r4
    b278:	9300      	str	r3, [sp, #0]
    b27a:	a803      	add	r0, sp, #12
    b27c:	4b06      	ldr	r3, [pc, #24]	; (b298 <at_handle_CTZR_cmd_read+0x38>)
    b27e:	f00f faf5 	bl	1a86c <snprintf>
    app_at_send_at_rsp_string_lines_with_claim_and_log(ctzr_read_rsp_str);
    b282:	a803      	add	r0, sp, #12
    b284:	f7fe f9ae 	bl	95e4 <app_at_send_at_rsp_string_lines_with_claim_and_log>
}
    b288:	2000      	movs	r0, #0
    b28a:	b006      	add	sp, #24
    b28c:	bd10      	pop	{r4, pc}
    b28e:	46c0      	nop			; (mov r8, r8)
    b290:	010024c2 	.word	0x010024c2
    b294:	000248db 	.word	0x000248db
    b298:	000239b5 	.word	0x000239b5

0000b29c <at_handle_NITZ_cmd_test>:
{
    b29c:	b510      	push	{r4, lr}
    app_at_send_at_rsp_string_lines_with_claim_and_log("+NITZ:(0,1)");
    b29e:	4802      	ldr	r0, [pc, #8]	; (b2a8 <at_handle_NITZ_cmd_test+0xc>)
    b2a0:	f7fe f9a0 	bl	95e4 <app_at_send_at_rsp_string_lines_with_claim_and_log>
}
    b2a4:	2000      	movs	r0, #0
    b2a6:	bd10      	pop	{r4, pc}
    b2a8:	00023c11 	.word	0x00023c11

0000b2ac <at_handle_CGAUTH_cmd_test>:
{
    b2ac:	b510      	push	{r4, lr}
    app_at_send_at_rsp_string_lines_with_claim_and_log("+CGAUTH:(0-10),(0,1,2),(0-60),(0-60)");
    b2ae:	4802      	ldr	r0, [pc, #8]	; (b2b8 <at_handle_CGAUTH_cmd_test+0xc>)
    b2b0:	f7fe f998 	bl	95e4 <app_at_send_at_rsp_string_lines_with_claim_and_log>
}
    b2b4:	2000      	movs	r0, #0
    b2b6:	bd10      	pop	{r4, pc}
    b2b8:	000236ba 	.word	0x000236ba

0000b2bc <at_handle_CGDCONT_cmd_test>:
{
    b2bc:	b510      	push	{r4, lr}
    app_at_send_at_rsp_string_lines_with_claim_and_log("+CGDCONT:(0-10),(\"IP\",\"NONIP\",\"IPV6\",\"IPV4V6\"),,,(0),(0),,,,,(0,1),(0,1)");
    b2be:	4802      	ldr	r0, [pc, #8]	; (b2c8 <at_handle_CGDCONT_cmd_test+0xc>)
    b2c0:	f7fe f990 	bl	95e4 <app_at_send_at_rsp_string_lines_with_claim_and_log>
}
    b2c4:	2000      	movs	r0, #0
    b2c6:	bd10      	pop	{r4, pc}
    b2c8:	0002374d 	.word	0x0002374d

0000b2cc <at_handle_CMEE_cmd_test>:
{
    b2cc:	b510      	push	{r4, lr}
    app_at_send_at_rsp_string_lines_with_claim_and_log("+CMEE:(0,1)");
    b2ce:	4802      	ldr	r0, [pc, #8]	; (b2d8 <at_handle_CMEE_cmd_test+0xc>)
    b2d0:	f7fe f988 	bl	95e4 <app_at_send_at_rsp_string_lines_with_claim_and_log>
}
    b2d4:	2000      	movs	r0, #0
    b2d6:	bd10      	pop	{r4, pc}
    b2d8:	00023890 	.word	0x00023890

0000b2dc <at_handle_NPSMR_cmd_test>:
{
    b2dc:	b510      	push	{r4, lr}
    app_at_send_at_rsp_string_lines_with_claim_and_log("+NPSMR:(0,1)");
    b2de:	4802      	ldr	r0, [pc, #8]	; (b2e8 <at_handle_NPSMR_cmd_test+0xc>)
    b2e0:	f7fe f980 	bl	95e4 <app_at_send_at_rsp_string_lines_with_claim_and_log>
}
    b2e4:	2000      	movs	r0, #0
    b2e6:	bd10      	pop	{r4, pc}
    b2e8:	00023cfc 	.word	0x00023cfc

0000b2ec <at_handle_NPSMR_cmd_read>:
{
    b2ec:	b530      	push	{r4, r5, lr}
    char      auc_rsp_data[AT_MAX_NPSMR_READ_RSP_LEN] = {0};
    b2ee:	240b      	movs	r4, #11
{
    b2f0:	b087      	sub	sp, #28
    char      auc_rsp_data[AT_MAX_NPSMR_READ_RSP_LEN] = {0};
    b2f2:	0022      	movs	r2, r4
    b2f4:	2100      	movs	r1, #0
    b2f6:	a803      	add	r0, sp, #12
    b2f8:	f7f4 fff2 	bl	2e0 <memset>
    rsp_len = (uint8)snprintf(auc_rsp_data, AT_MAX_NPSMR_READ_RSP_LEN, "%s%d", AT_CMD_NPSMR_PREFIX, app_at_state_info.npsmr_mode);
    b2fc:	4d0c      	ldr	r5, [pc, #48]	; (b330 <at_handle_NPSMR_cmd_read+0x44>)
    b2fe:	4a0d      	ldr	r2, [pc, #52]	; (b334 <at_handle_NPSMR_cmd_read+0x48>)
    b300:	792b      	ldrb	r3, [r5, #4]
    b302:	0021      	movs	r1, r4
    b304:	9300      	str	r3, [sp, #0]
    b306:	a803      	add	r0, sp, #12
    b308:	4b0b      	ldr	r3, [pc, #44]	; (b338 <at_handle_NPSMR_cmd_read+0x4c>)
    b30a:	f00f faaf 	bl	1a86c <snprintf>
    if (app_at_state_info.npsmr_mode == NPSMR_MODE_ENUM_ENABLE_REPORT)
    b30e:	792b      	ldrb	r3, [r5, #4]
    b310:	2b01      	cmp	r3, #1
    b312:	d107      	bne.n	b324 <at_handle_NPSMR_cmd_read+0x38>
    b314:	b2c0      	uxtb	r0, r0
        (void)snprintf(auc_rsp_data + rsp_len, AT_MAX_NPSMR_READ_RSP_LEN - rsp_len, ",%u", app_at_state_info.npsmr_state);
    b316:	aa03      	add	r2, sp, #12
    b318:	1a21      	subs	r1, r4, r0
    b31a:	78eb      	ldrb	r3, [r5, #3]
    b31c:	1810      	adds	r0, r2, r0
    b31e:	4a07      	ldr	r2, [pc, #28]	; (b33c <at_handle_NPSMR_cmd_read+0x50>)
    b320:	f00f faa4 	bl	1a86c <snprintf>
    app_at_send_at_rsp_string_lines_with_claim_and_log(auc_rsp_data);
    b324:	a803      	add	r0, sp, #12
    b326:	f7fe f95d 	bl	95e4 <app_at_send_at_rsp_string_lines_with_claim_and_log>
}
    b32a:	2000      	movs	r0, #0
    b32c:	b007      	add	sp, #28
    b32e:	bd30      	pop	{r4, r5, pc}
    b330:	010024c2 	.word	0x010024c2
    b334:	000248db 	.word	0x000248db
    b338:	00023cf4 	.word	0x00023cf4
    b33c:	00024fe1 	.word	0x00024fe1

0000b340 <at_handle_CSCON_cmd_test>:
{
    b340:	b510      	push	{r4, lr}
    app_at_send_at_rsp_string_lines_with_claim_and_log("+CSCON:(0,1)");
    b342:	4802      	ldr	r0, [pc, #8]	; (b34c <at_handle_CSCON_cmd_test+0xc>)
    b344:	f7fe f94e 	bl	95e4 <app_at_send_at_rsp_string_lines_with_claim_and_log>
}
    b348:	2000      	movs	r0, #0
    b34a:	bd10      	pop	{r4, pc}
    b34c:	0002395d 	.word	0x0002395d

0000b350 <at_handle_CEREG_cmd_test>:
{
    b350:	b510      	push	{r4, lr}
    app_at_send_at_rsp_string_lines_with_claim_and_log("+CEREG:(0,1,2,3,4,5)");
    b352:	4802      	ldr	r0, [pc, #8]	; (b35c <at_handle_CEREG_cmd_test+0xc>)
    b354:	f7fe f946 	bl	95e4 <app_at_send_at_rsp_string_lines_with_claim_and_log>
}
    b358:	2000      	movs	r0, #0
    b35a:	bd10      	pop	{r4, pc}
    b35c:	0002363e 	.word	0x0002363e

0000b360 <at_handle_CSQ_cmd_test>:
{
    b360:	b510      	push	{r4, lr}
    app_at_send_at_rsp_string_lines_with_claim_and_log("+CSQ:(0-31,99),(99)");
    b362:	4802      	ldr	r0, [pc, #8]	; (b36c <at_handle_CSQ_cmd_test+0xc>)
    b364:	f7fe f93e 	bl	95e4 <app_at_send_at_rsp_string_lines_with_claim_and_log>
}
    b368:	2000      	movs	r0, #0
    b36a:	bd10      	pop	{r4, pc}
    b36c:	000239a1 	.word	0x000239a1

0000b370 <at_handle_CFUN_cmd_test>:
{
    b370:	b510      	push	{r4, lr}
    app_at_send_at_rsp_string_lines_with_claim_and_log("+CFUN:(0,1),(0,1)");
    b372:	4802      	ldr	r0, [pc, #8]	; (b37c <at_handle_CFUN_cmd_test+0xc>)
    b374:	f7fe f936 	bl	95e4 <app_at_send_at_rsp_string_lines_with_claim_and_log>
}
    b378:	2000      	movs	r0, #0
    b37a:	bd10      	pop	{r4, pc}
    b37c:	0002365c 	.word	0x0002365c

0000b380 <at_handle_NCHIPINFO_cmd_test>:
{
    b380:	b510      	push	{r4, lr}
    app_at_send_at_rsp_string_lines_with_claim_and_log(AT_NCHIPINFO_TEST_RSP);
    b382:	4802      	ldr	r0, [pc, #8]	; (b38c <at_handle_NCHIPINFO_cmd_test+0xc>)
    b384:	f7fe f92e 	bl	95e4 <app_at_send_at_rsp_string_lines_with_claim_and_log>
}
    b388:	2000      	movs	r0, #0
    b38a:	bd10      	pop	{r4, pc}
    b38c:	00023aaa 	.word	0x00023aaa

0000b390 <at_handle_UE_STATS_cmd_test>:
{
    b390:	b510      	push	{r4, lr}
    app_at_send_at_rsp_string_lines_with_claim_and_log("NUESTATS:(RADIO,CELL,BLER,THP,APPSMEM,ALL)");
    b392:	4802      	ldr	r0, [pc, #8]	; (b39c <at_handle_UE_STATS_cmd_test+0xc>)
    b394:	f7fe f926 	bl	95e4 <app_at_send_at_rsp_string_lines_with_claim_and_log>
}
    b398:	2000      	movs	r0, #0
    b39a:	bd10      	pop	{r4, pc}
    b39c:	00023dc7 	.word	0x00023dc7

0000b3a0 <at_handle_CGATT_cmd_test>:
{
    b3a0:	b510      	push	{r4, lr}
    app_at_send_at_rsp_string_lines_with_claim_and_log("+CGATT:(0,1)");
    b3a2:	4802      	ldr	r0, [pc, #8]	; (b3ac <at_handle_CGATT_cmd_test+0xc>)
    b3a4:	f7fe f91e 	bl	95e4 <app_at_send_at_rsp_string_lines_with_claim_and_log>
}
    b3a8:	2000      	movs	r0, #0
    b3aa:	bd10      	pop	{r4, pc}
    b3ac:	00023692 	.word	0x00023692

0000b3b0 <app_at_send_socket_or_cid_status_string>:
{
    b3b0:	b5f0      	push	{r4, r5, r6, r7, lr}
    char          rsp_string[AT_CMD_SOCKET_OR_CID_STATUS_MAX_LEN] = {0};
    b3b2:	2418      	movs	r4, #24
{
    b3b4:	0015      	movs	r5, r2
    b3b6:	000f      	movs	r7, r1
    b3b8:	b08b      	sub	sp, #44	; 0x2c
    b3ba:	001e      	movs	r6, r3
    b3bc:	ab10      	add	r3, sp, #64	; 0x40
    b3be:	781b      	ldrb	r3, [r3, #0]
    b3c0:	9002      	str	r0, [sp, #8]
    char          rsp_string[AT_CMD_SOCKET_OR_CID_STATUS_MAX_LEN] = {0};
    b3c2:	0022      	movs	r2, r4
    b3c4:	2100      	movs	r1, #0
    b3c6:	a804      	add	r0, sp, #16
{
    b3c8:	9303      	str	r3, [sp, #12]
    char          rsp_string[AT_CMD_SOCKET_OR_CID_STATUS_MAX_LEN] = {0};
    b3ca:	f7f4 ff89 	bl	2e0 <memset>
    len = (uint8)snprintf(rsp_string, AT_CMD_SOCKET_OR_CID_STATUS_MAX_LEN, "%s:%d,%d", cmd_prefix, id, status);
    b3ce:	9501      	str	r5, [sp, #4]
    b3d0:	9700      	str	r7, [sp, #0]
    b3d2:	9b02      	ldr	r3, [sp, #8]
    b3d4:	4a12      	ldr	r2, [pc, #72]	; (b420 <app_at_send_socket_or_cid_status_string+0x70>)
    b3d6:	0021      	movs	r1, r4
    b3d8:	a804      	add	r0, sp, #16
    b3da:	f00f fa47 	bl	1a86c <snprintf>
    if(status == SOCKET_OR_CID_STATUS_BACK_OFF)
    b3de:	2d03      	cmp	r5, #3
    b3e0:	d107      	bne.n	b3f2 <app_at_send_socket_or_cid_status_string+0x42>
    b3e2:	b2c0      	uxtb	r0, r0
        (void)snprintf(rsp_string + len, AT_CMD_SOCKET_OR_CID_STATUS_MAX_LEN - len, ",%d", backoff);
    b3e4:	ab04      	add	r3, sp, #16
    b3e6:	1a21      	subs	r1, r4, r0
    b3e8:	4a0e      	ldr	r2, [pc, #56]	; (b424 <app_at_send_socket_or_cid_status_string+0x74>)
    b3ea:	1818      	adds	r0, r3, r0
    b3ec:	0033      	movs	r3, r6
    b3ee:	f00f fa3d 	bl	1a86c <snprintf>
    if (full_output)
    b3f2:	9b03      	ldr	r3, [sp, #12]
    b3f4:	2b00      	cmp	r3, #0
    b3f6:	d004      	beq.n	b402 <app_at_send_socket_or_cid_status_string+0x52>
         app_at_send_at_rsp_string_lines_with_claim_and_log(rsp_string);
    b3f8:	a804      	add	r0, sp, #16
    b3fa:	f7fe f8f3 	bl	95e4 <app_at_send_at_rsp_string_lines_with_claim_and_log>
}
    b3fe:	b00b      	add	sp, #44	; 0x2c
    b400:	bdf0      	pop	{r4, r5, r6, r7, pc}
        app_at_send_at_rsp_string(rsp_string, true, AT_FLAG_LOGABLE);
    b402:	2208      	movs	r2, #8
    b404:	2101      	movs	r1, #1
    b406:	a804      	add	r0, sp, #16
    b408:	f7fe f8de 	bl	95c8 <app_at_send_at_rsp_string>
        at_uart_write((unsigned char*)APP_AT_STR_RN, strlen(APP_AT_STR_RN));
    b40c:	4c06      	ldr	r4, [pc, #24]	; (b428 <app_at_send_socket_or_cid_status_string+0x78>)
    b40e:	0020      	movs	r0, r4
    b410:	f00f ffc5 	bl	1b39e <strlen>
    b414:	0001      	movs	r1, r0
    b416:	0020      	movs	r0, r4
    b418:	f7fe fae8 	bl	99ec <at_uart_write>
}
    b41c:	e7ef      	b.n	b3fe <app_at_send_socket_or_cid_status_string+0x4e>
    b41e:	46c0      	nop			; (mov r8, r8)
    b420:	0002497f 	.word	0x0002497f
    b424:	0002394e 	.word	0x0002394e
    b428:	00022d8f 	.word	0x00022d8f

0000b42c <at_handle_NCIDSTATUS_cmd_exec>:
{
    b42c:	b5f0      	push	{r4, r5, r6, r7, lr}
    b42e:	b089      	sub	sp, #36	; 0x24
    uint8                   cids[AT_MAX_CID + 1]      = {0};
    b430:	ae05      	add	r6, sp, #20
    b432:	220b      	movs	r2, #11
    b434:	2100      	movs	r1, #0
    b436:	0030      	movs	r0, r6
    b438:	f7f4 ff52 	bl	2e0 <memset>
    result = get_defined_cids(AT_MAX_CID + 1, &cids_num, cids);
    b43c:	2112      	movs	r1, #18
    b43e:	0032      	movs	r2, r6
    b440:	4469      	add	r1, sp
    b442:	200b      	movs	r0, #11
    b444:	f010 ff1b 	bl	1c27e <get_defined_cids>
    if (result != NEUL_RET_OK)
    b448:	2800      	cmp	r0, #0
    b44a:	d023      	beq.n	b494 <at_handle_NCIDSTATUS_cmd_exec+0x68>
}
    b44c:	2000      	movs	r0, #0
    b44e:	b009      	add	sp, #36	; 0x24
    b450:	bdf0      	pop	{r4, r5, r6, r7, pc}
        result = get_cid_status(cids[i], &status, &backoff);
    b452:	230f      	movs	r3, #15
    b454:	446b      	add	r3, sp
    b456:	5d30      	ldrb	r0, [r6, r4]
    b458:	aa04      	add	r2, sp, #16
    b45a:	0019      	movs	r1, r3
    b45c:	f011 fb4e 	bl	1cafc <get_cid_status>
    b460:	1e07      	subs	r7, r0, #0
        if (result == NEUL_RET_OK)
    b462:	d10b      	bne.n	b47c <at_handle_NCIDSTATUS_cmd_exec+0x50>
    b464:	466b      	mov	r3, sp
    b466:	5d31      	ldrb	r1, [r6, r4]
    b468:	7bda      	ldrb	r2, [r3, #15]
    b46a:	480c      	ldr	r0, [pc, #48]	; (b49c <at_handle_NCIDSTATUS_cmd_exec+0x70>)
    b46c:	8a1b      	ldrh	r3, [r3, #16]
            if (first_output)
    b46e:	2d00      	cmp	r5, #0
    b470:	d00c      	beq.n	b48c <at_handle_NCIDSTATUS_cmd_exec+0x60>
                app_at_send_socket_or_cid_status_string(AT_CMD_NCIDSTATUS_RSP_PREFIX, cids[i], status, backoff, true);
    b472:	2501      	movs	r5, #1
    b474:	9500      	str	r5, [sp, #0]
    b476:	f7ff ff9b 	bl	b3b0 <app_at_send_socket_or_cid_status_string>
                first_output = false;
    b47a:	003d      	movs	r5, r7
    for (uint8 i= 0; i < cids_num; i++)
    b47c:	3401      	adds	r4, #1
    b47e:	b2e4      	uxtb	r4, r4
    b480:	2312      	movs	r3, #18
    b482:	446b      	add	r3, sp
    b484:	881b      	ldrh	r3, [r3, #0]
    b486:	42a3      	cmp	r3, r4
    b488:	d8e3      	bhi.n	b452 <at_handle_NCIDSTATUS_cmd_exec+0x26>
    b48a:	e7df      	b.n	b44c <at_handle_NCIDSTATUS_cmd_exec+0x20>
                app_at_send_socket_or_cid_status_string(AT_CMD_NCIDSTATUS_RSP_PREFIX, cids[i], status, backoff, false);
    b48c:	9500      	str	r5, [sp, #0]
    b48e:	f7ff ff8f 	bl	b3b0 <app_at_send_socket_or_cid_status_string>
    b492:	e7f3      	b.n	b47c <at_handle_NCIDSTATUS_cmd_exec+0x50>
    for (uint8 i= 0; i < cids_num; i++)
    b494:	0004      	movs	r4, r0
    bool                    first_output = true;
    b496:	2501      	movs	r5, #1
    b498:	e7f2      	b.n	b480 <at_handle_NCIDSTATUS_cmd_exec+0x54>
    b49a:	46c0      	nop			; (mov r8, r8)
    b49c:	00023ac5 	.word	0x00023ac5

0000b4a0 <app_at_send_at_rsp_apnrc_string>:
{
    b4a0:	b5f0      	push	{r4, r5, r6, r7, lr}
    char          apnrc_string[AT_APNRC_MAX_STR_LEN] = {0};
    b4a2:	2423      	movs	r4, #35	; 0x23
{
    b4a4:	b091      	sub	sp, #68	; 0x44
    b4a6:	9304      	str	r3, [sp, #16]
    b4a8:	ab16      	add	r3, sp, #88	; 0x58
    b4aa:	781b      	ldrb	r3, [r3, #0]
    b4ac:	0006      	movs	r6, r0
    b4ae:	000f      	movs	r7, r1
    b4b0:	0015      	movs	r5, r2
    char          apnrc_string[AT_APNRC_MAX_STR_LEN] = {0};
    b4b2:	2100      	movs	r1, #0
    b4b4:	0022      	movs	r2, r4
    b4b6:	a807      	add	r0, sp, #28
{
    b4b8:	9305      	str	r3, [sp, #20]
    char          apnrc_string[AT_APNRC_MAX_STR_LEN] = {0};
    b4ba:	f7f4 ff11 	bl	2e0 <memset>
    len = (uint16)snprintf(apnrc_string, AT_APNRC_MAX_STR_LEN, "%s", AT_APNRC_PREFIX_STR);
    b4be:	4b1a      	ldr	r3, [pc, #104]	; (b528 <app_at_send_at_rsp_apnrc_string+0x88>)
    b4c0:	0021      	movs	r1, r4
    b4c2:	4a1a      	ldr	r2, [pc, #104]	; (b52c <app_at_send_at_rsp_apnrc_string+0x8c>)
    b4c4:	a807      	add	r0, sp, #28
    b4c6:	f00f f9d1 	bl	1a86c <snprintf>
    b4ca:	ab07      	add	r3, sp, #28
    b4cc:	b281      	uxth	r1, r0
    b4ce:	1858      	adds	r0, r3, r1
    b4d0:	1a61      	subs	r1, r4, r1
    if (APN_RATE_CTRL_UNRESTRICTED == uplink_time_unit)
    b4d2:	2d00      	cmp	r5, #0
    b4d4:	d11e      	bne.n	b514 <app_at_send_at_rsp_apnrc_string+0x74>
        (void)snprintf(apnrc_string + len, AT_APNRC_MAX_STR_LEN - len, "%d,%d,%d,", cid, additional_exception_reports, uplink_time_unit);
    b4d6:	9501      	str	r5, [sp, #4]
    b4d8:	9700      	str	r7, [sp, #0]
    b4da:	0033      	movs	r3, r6
    b4dc:	4a14      	ldr	r2, [pc, #80]	; (b530 <app_at_send_at_rsp_apnrc_string+0x90>)
    b4de:	f00f f9c5 	bl	1a86c <snprintf>
    if (!line_feed_flag)
    b4e2:	9b05      	ldr	r3, [sp, #20]
    b4e4:	4c13      	ldr	r4, [pc, #76]	; (b534 <app_at_send_at_rsp_apnrc_string+0x94>)
    b4e6:	2b00      	cmp	r3, #0
    b4e8:	d106      	bne.n	b4f8 <app_at_send_at_rsp_apnrc_string+0x58>
        at_uart_write((unsigned char*)APP_AT_STR_RN, strlen(APP_AT_STR_RN));
    b4ea:	0020      	movs	r0, r4
    b4ec:	f00f ff57 	bl	1b39e <strlen>
    b4f0:	0001      	movs	r1, r0
    b4f2:	0020      	movs	r0, r4
    b4f4:	f7fe fa7a 	bl	99ec <at_uart_write>
    app_at_send_at_rsp_string(apnrc_string, true, AT_FLAG_LOGABLE);
    b4f8:	2208      	movs	r2, #8
    b4fa:	2101      	movs	r1, #1
    b4fc:	a807      	add	r0, sp, #28
    b4fe:	f7fe f863 	bl	95c8 <app_at_send_at_rsp_string>
    at_uart_write((unsigned char*)APP_AT_STR_RN, strlen(APP_AT_STR_RN));
    b502:	0020      	movs	r0, r4
    b504:	f00f ff4b 	bl	1b39e <strlen>
    b508:	0001      	movs	r1, r0
    b50a:	0020      	movs	r0, r4
    b50c:	f7fe fa6e 	bl	99ec <at_uart_write>
}
    b510:	b011      	add	sp, #68	; 0x44
    b512:	bdf0      	pop	{r4, r5, r6, r7, pc}
        (void)snprintf(apnrc_string + len, AT_APNRC_MAX_STR_LEN - len, "%d,%d,%d,%ld", cid, additional_exception_reports, uplink_time_unit, maximum_uplink_rate);
    b514:	9b04      	ldr	r3, [sp, #16]
    b516:	9501      	str	r5, [sp, #4]
    b518:	9302      	str	r3, [sp, #8]
    b51a:	9700      	str	r7, [sp, #0]
    b51c:	0033      	movs	r3, r6
    b51e:	4a06      	ldr	r2, [pc, #24]	; (b538 <app_at_send_at_rsp_apnrc_string+0x98>)
    b520:	f00f f9a4 	bl	1a86c <snprintf>
    b524:	e7dd      	b.n	b4e2 <app_at_send_at_rsp_apnrc_string+0x42>
    b526:	46c0      	nop			; (mov r8, r8)
    b528:	000234d4 	.word	0x000234d4
    b52c:	000237d7 	.word	0x000237d7
    b530:	000234de 	.word	0x000234de
    b534:	00022d8f 	.word	0x00022d8f
    b538:	000234e8 	.word	0x000234e8

0000b53c <at_handle_NSOSTATUS_cmd_exec>:
{
    b53c:	b5f0      	push	{r4, r5, r6, r7, lr}
    for(socketid = 0; socketid < NUM_SOCKETS; socketid++)
    b53e:	2400      	movs	r4, #0
    bool                    first_output = true;
    b540:	2501      	movs	r5, #1
{
    b542:	b085      	sub	sp, #20
        result = get_socket_status(socketid, &status, &backoff);
    b544:	270d      	movs	r7, #13
    b546:	230e      	movs	r3, #14
    b548:	446f      	add	r7, sp
    b54a:	446b      	add	r3, sp
    b54c:	001a      	movs	r2, r3
    b54e:	0039      	movs	r1, r7
    b550:	0020      	movs	r0, r4
    b552:	f7fc fd9b 	bl	808c <get_socket_status>
    b556:	1e06      	subs	r6, r0, #0
        if (result == NEUL_RET_OK)
    b558:	d10b      	bne.n	b572 <at_handle_NSOSTATUS_cmd_exec+0x36>
    b55a:	466b      	mov	r3, sp
    b55c:	783a      	ldrb	r2, [r7, #0]
    b55e:	89db      	ldrh	r3, [r3, #14]
    b560:	480a      	ldr	r0, [pc, #40]	; (b58c <at_handle_NSOSTATUS_cmd_exec+0x50>)
            if (first_output)
    b562:	2d00      	cmp	r5, #0
    b564:	d00c      	beq.n	b580 <at_handle_NSOSTATUS_cmd_exec+0x44>
                app_at_send_socket_or_cid_status_string(AT_CMD_NSOSTATUS_RSP_PREFIX, socketid, status, backoff, true);
    b566:	2101      	movs	r1, #1
    b568:	9100      	str	r1, [sp, #0]
    b56a:	0021      	movs	r1, r4
    b56c:	f7ff ff20 	bl	b3b0 <app_at_send_socket_or_cid_status_string>
                first_output = false;
    b570:	0035      	movs	r5, r6
    for(socketid = 0; socketid < NUM_SOCKETS; socketid++)
    b572:	3401      	adds	r4, #1
    b574:	b2e4      	uxtb	r4, r4
    b576:	2c07      	cmp	r4, #7
    b578:	d1e4      	bne.n	b544 <at_handle_NSOSTATUS_cmd_exec+0x8>
}
    b57a:	2000      	movs	r0, #0
    b57c:	b005      	add	sp, #20
    b57e:	bdf0      	pop	{r4, r5, r6, r7, pc}
                app_at_send_socket_or_cid_status_string(AT_CMD_NSOSTATUS_RSP_PREFIX, socketid, status, backoff, false);
    b580:	9500      	str	r5, [sp, #0]
    b582:	0021      	movs	r1, r4
    b584:	f7ff ff14 	bl	b3b0 <app_at_send_socket_or_cid_status_string>
    b588:	e7f3      	b.n	b572 <at_handle_NSOSTATUS_cmd_exec+0x36>
    b58a:	46c0      	nop			; (mov r8, r8)
    b58c:	00023d82 	.word	0x00023d82

0000b590 <output_ue_stats_bler>:
{
    b590:	b570      	push	{r4, r5, r6, lr}
    b592:	0004      	movs	r4, r0
    b594:	b098      	sub	sp, #96	; 0x60
    char     ue_stats_rsp[AT_MAX_UESTATS_RSP_LEN]   = {0};
    b596:	2228      	movs	r2, #40	; 0x28
    b598:	2100      	movs	r1, #0
    b59a:	a803      	add	r0, sp, #12
    b59c:	f7f4 fea0 	bl	2e0 <memset>
    bler_value [UE_STATS_BLER_RLC_UL] = ue_stats_bin->rlc_ul_bler;
    b5a0:	6b23      	ldr	r3, [r4, #48]	; 0x30
    b5a2:	ad0d      	add	r5, sp, #52	; 0x34
    b5a4:	606b      	str	r3, [r5, #4]
    bler_value [UE_STATS_BLER_RLC_DL] = ue_stats_bin->rlc_dl_bler;
    b5a6:	6b63      	ldr	r3, [r4, #52]	; 0x34
        memset(ue_stats_rsp, 0, sizeof(ue_stats_rsp));
    b5a8:	2628      	movs	r6, #40	; 0x28
    bler_value [UE_STATS_BLER_RLC_DL] = ue_stats_bin->rlc_dl_bler;
    b5aa:	60ab      	str	r3, [r5, #8]
    bler_value [UE_STATS_BLER_MAC_UL] = ue_stats_bin->mac_ul_bler;
    b5ac:	6ba3      	ldr	r3, [r4, #56]	; 0x38
    b5ae:	60eb      	str	r3, [r5, #12]
    bler_value [UE_STATS_BLER_MAC_DL] = ue_stats_bin->mac_dl_bler;
    b5b0:	6be3      	ldr	r3, [r4, #60]	; 0x3c
    b5b2:	612b      	str	r3, [r5, #16]
    bler_value [UE_STATS_BLER_TX_BYTES] = ue_stats_bin->ll1_transmitted_bytes;
    b5b4:	6c23      	ldr	r3, [r4, #64]	; 0x40
    b5b6:	616b      	str	r3, [r5, #20]
    bler_value [UE_STATS_BLER_RX_BYTES] = ue_stats_bin->ll1_received_bytes;
    b5b8:	6c63      	ldr	r3, [r4, #68]	; 0x44
    b5ba:	61ab      	str	r3, [r5, #24]
    bler_value [UE_STATS_BLER_TX_BLOCKS] = (uint32)ue_stats_bin->total_tb_tx;
    b5bc:	0023      	movs	r3, r4
    b5be:	3348      	adds	r3, #72	; 0x48
    b5c0:	881b      	ldrh	r3, [r3, #0]
    b5c2:	61eb      	str	r3, [r5, #28]
    bler_value [UE_STATS_BLER_RX_BLOCKS] = (uint32)ue_stats_bin->total_tb_rx;
    b5c4:	0023      	movs	r3, r4
    b5c6:	334a      	adds	r3, #74	; 0x4a
    b5c8:	881b      	ldrh	r3, [r3, #0]
    b5ca:	622b      	str	r3, [r5, #32]
    bler_value [UE_STATS_BLER_RTX_BLOCKS] = (uint32)ue_stats_bin->total_tb_retx;
    b5cc:	0023      	movs	r3, r4
    b5ce:	334c      	adds	r3, #76	; 0x4c
    b5d0:	881b      	ldrh	r3, [r3, #0]
    bler_value [UE_STATS_BLER_ACK_NACK_BLOCKS] = (uint32)ue_stats_bin->total_harq_nack_received;
    b5d2:	344e      	adds	r4, #78	; 0x4e
    bler_value [UE_STATS_BLER_RTX_BLOCKS] = (uint32)ue_stats_bin->total_tb_retx;
    b5d4:	626b      	str	r3, [r5, #36]	; 0x24
    bler_value [UE_STATS_BLER_ACK_NACK_BLOCKS] = (uint32)ue_stats_bin->total_harq_nack_received;
    b5d6:	8823      	ldrh	r3, [r4, #0]
    b5d8:	2404      	movs	r4, #4
    b5da:	62ab      	str	r3, [r5, #40]	; 0x28
        memset(ue_stats_rsp, 0, sizeof(ue_stats_rsp));
    b5dc:	0032      	movs	r2, r6
    b5de:	2100      	movs	r1, #0
    b5e0:	a803      	add	r0, sp, #12
    b5e2:	f7f4 fe7d 	bl	2e0 <memset>
        rsp_len = (uint16)snprintf(ue_stats_rsp, AT_MAX_UESTATS_RSP_LEN, "%s%s,", AT_CMD_NEUSTATS_RSP_PREFIX, AT_CMD_NUESTATS_BLER);
    b5e6:	4b0c      	ldr	r3, [pc, #48]	; (b618 <output_ue_stats_bler+0x88>)
    b5e8:	4a0c      	ldr	r2, [pc, #48]	; (b61c <output_ue_stats_bler+0x8c>)
    b5ea:	9300      	str	r3, [sp, #0]
    b5ec:	0031      	movs	r1, r6
    b5ee:	4b0c      	ldr	r3, [pc, #48]	; (b620 <output_ue_stats_bler+0x90>)
    b5f0:	a803      	add	r0, sp, #12
    b5f2:	f00f f93b 	bl	1a86c <snprintf>
        (void)snprintf(ue_stats_rsp + rsp_len, AT_MAX_UESTATS_RSP_LEN - rsp_len, ue_stats_bler_labels[index], bler_value[index]);    //lint !e644
    b5f6:	4a0b      	ldr	r2, [pc, #44]	; (b624 <output_ue_stats_bler+0x94>)
    b5f8:	b280      	uxth	r0, r0
    b5fa:	ab03      	add	r3, sp, #12
    b5fc:	1a31      	subs	r1, r6, r0
    b5fe:	58a2      	ldr	r2, [r4, r2]
    b600:	1818      	adds	r0, r3, r0
    b602:	592b      	ldr	r3, [r5, r4]
    b604:	f00f f932 	bl	1a86c <snprintf>
    b608:	3404      	adds	r4, #4
        app_at_send_at_rsp_string_lines_with_claim_and_log(ue_stats_rsp);
    b60a:	a803      	add	r0, sp, #12
    b60c:	f7fd ffea 	bl	95e4 <app_at_send_at_rsp_string_lines_with_claim_and_log>
    for (int index = UE_STATS_BLER_RLC_UL; index < UE_STATS_BLER_LAST_LABEL; index++)
    b610:	2c2c      	cmp	r4, #44	; 0x2c
    b612:	d1e3      	bne.n	b5dc <output_ue_stats_bler+0x4c>
}
    b614:	b018      	add	sp, #96	; 0x60
    b616:	bd70      	pop	{r4, r5, r6, pc}
    b618:	000248f8 	.word	0x000248f8
    b61c:	000248f2 	.word	0x000248f2
    b620:	000248e8 	.word	0x000248e8
    b624:	000250f8 	.word	0x000250f8

0000b628 <output_ue_statshp>:
{
    b628:	b5f0      	push	{r4, r5, r6, r7, lr}
    b62a:	0004      	movs	r4, r0
    b62c:	b097      	sub	sp, #92	; 0x5c
    char     ue_stats_rsp[AT_MAX_UESTATS_RSP_LEN]   = {0};
    b62e:	2228      	movs	r2, #40	; 0x28
    b630:	2100      	movs	r1, #0
    b632:	a80c      	add	r0, sp, #48	; 0x30
    b634:	f7f4 fe54 	bl	2e0 <memset>
    uint32   statshp_value[4] = {ue_stats_bin->rlc_ul_data_rate,ue_stats_bin->rlc_dl_data_rate,ue_stats_bin->mac_ul_data_rate,ue_stats_bin->mac_dl_data_rate};
    b638:	6d23      	ldr	r3, [r4, #80]	; 0x50
    b63a:	ad04      	add	r5, sp, #16
    b63c:	9304      	str	r3, [sp, #16]
    b63e:	6d63      	ldr	r3, [r4, #84]	; 0x54
        memset(ue_stats_rsp, 0, sizeof(ue_stats_rsp));
    b640:	2728      	movs	r7, #40	; 0x28
    uint32   statshp_value[4] = {ue_stats_bin->rlc_ul_data_rate,ue_stats_bin->rlc_dl_data_rate,ue_stats_bin->mac_ul_data_rate,ue_stats_bin->mac_dl_data_rate};
    b642:	606b      	str	r3, [r5, #4]
    b644:	6da3      	ldr	r3, [r4, #88]	; 0x58
    b646:	60ab      	str	r3, [r5, #8]
    b648:	6de3      	ldr	r3, [r4, #92]	; 0x5c
    const char *statshp_str[4] =
    b64a:	ac08      	add	r4, sp, #32
    b64c:	0022      	movs	r2, r4
    uint32   statshp_value[4] = {ue_stats_bin->rlc_ul_data_rate,ue_stats_bin->rlc_dl_data_rate,ue_stats_bin->mac_ul_data_rate,ue_stats_bin->mac_dl_data_rate};
    b64e:	60eb      	str	r3, [r5, #12]
    const char *statshp_str[4] =
    b650:	4b0f      	ldr	r3, [pc, #60]	; (b690 <output_ue_statshp+0x68>)
    b652:	3324      	adds	r3, #36	; 0x24
    b654:	cb43      	ldmia	r3!, {r0, r1, r6}
    b656:	c243      	stmia	r2!, {r0, r1, r6}
    b658:	2600      	movs	r6, #0
    b65a:	681b      	ldr	r3, [r3, #0]
    b65c:	6013      	str	r3, [r2, #0]
        memset(ue_stats_rsp, 0, sizeof(ue_stats_rsp));
    b65e:	003a      	movs	r2, r7
    b660:	2100      	movs	r1, #0
    b662:	a80c      	add	r0, sp, #48	; 0x30
    b664:	f7f4 fe3c 	bl	2e0 <memset>
        (void)snprintf(ue_stats_rsp, AT_MAX_UESTATS_RSP_LEN, "%s%s,%s,%u", AT_CMD_NEUSTATS_RSP_PREFIX, AT_CMD_NUESTATS_THP, statshp_str[i] ,statshp_value[i]);
    b668:	59ab      	ldr	r3, [r5, r6]
    b66a:	4a0a      	ldr	r2, [pc, #40]	; (b694 <output_ue_statshp+0x6c>)
    b66c:	9302      	str	r3, [sp, #8]
    b66e:	59a3      	ldr	r3, [r4, r6]
    b670:	0039      	movs	r1, r7
    b672:	9301      	str	r3, [sp, #4]
    b674:	4b08      	ldr	r3, [pc, #32]	; (b698 <output_ue_statshp+0x70>)
    b676:	a80c      	add	r0, sp, #48	; 0x30
    b678:	9300      	str	r3, [sp, #0]
    b67a:	4b08      	ldr	r3, [pc, #32]	; (b69c <output_ue_statshp+0x74>)
    b67c:	f00f f8f6 	bl	1a86c <snprintf>
    b680:	3604      	adds	r6, #4
        app_at_send_at_rsp_string_lines_with_claim_and_log(ue_stats_rsp);
    b682:	a80c      	add	r0, sp, #48	; 0x30
    b684:	f7fd ffae 	bl	95e4 <app_at_send_at_rsp_string_lines_with_claim_and_log>
    for (uint8 i = 0; i < 4; i++)
    b688:	2e10      	cmp	r6, #16
    b68a:	d1e8      	bne.n	b65e <output_ue_statshp+0x36>
}
    b68c:	b017      	add	sp, #92	; 0x5c
    b68e:	bdf0      	pop	{r4, r5, r6, r7, pc}
    b690:	000229f8 	.word	0x000229f8
    b694:	0002491c 	.word	0x0002491c
    b698:	00024927 	.word	0x00024927
    b69c:	000248e8 	.word	0x000248e8

0000b6a0 <at_handle_CRSM_cmd_set>:
    memset(&cmd, 0, sizeof(crsm_command));
    b6a0:	228b      	movs	r2, #139	; 0x8b
    uint8               *data = NULL;
    b6a2:	2100      	movs	r1, #0
{
    b6a4:	b5f0      	push	{r4, r5, r6, r7, lr}
    if (at_create_param_array(p_atparams_string, &num_recvparams, 1, 7) != AT_RET_OK)
    b6a6:	260f      	movs	r6, #15
{
    b6a8:	0004      	movs	r4, r0
    b6aa:	b0cf      	sub	sp, #316	; 0x13c
    memset(&cmd, 0, sizeof(crsm_command));
    b6ac:	ad08      	add	r5, sp, #32
    b6ae:	0052      	lsls	r2, r2, #1
    b6b0:	0028      	movs	r0, r5
    uint8               *data = NULL;
    b6b2:	9107      	str	r1, [sp, #28]
    memset(&cmd, 0, sizeof(crsm_command));
    b6b4:	f7f4 fe14 	bl	2e0 <memset>
    if (at_create_param_array(p_atparams_string, &num_recvparams, 1, 7) != AT_RET_OK)
    b6b8:	ab02      	add	r3, sp, #8
    b6ba:	18f6      	adds	r6, r6, r3
    b6bc:	2201      	movs	r2, #1
    b6be:	2307      	movs	r3, #7
    b6c0:	0031      	movs	r1, r6
    b6c2:	0020      	movs	r0, r4
    b6c4:	f7fe fe0e 	bl	a2e4 <at_create_param_array>
    b6c8:	2800      	cmp	r0, #0
    b6ca:	d002      	beq.n	b6d2 <at_handle_CRSM_cmd_set+0x32>
       return AT_RET_SYNTAX_ERROR;
    b6cc:	2001      	movs	r0, #1
}
    b6ce:	b04f      	add	sp, #316	; 0x13c
    b6d0:	bdf0      	pop	{r4, r5, r6, r7, pc}
    cause = at_get_uint8_param(AT_PARSE_FIRST_PARAM_POS, &cmd.type, true);
    b6d2:	2119      	movs	r1, #25
    b6d4:	ab02      	add	r3, sp, #8
    b6d6:	2201      	movs	r2, #1
    b6d8:	18c9      	adds	r1, r1, r3
    b6da:	f7fe ff97 	bl	a60c <at_get_uint8_param>
    if(cause != AT_RET_OK)
    b6de:	2800      	cmp	r0, #0
    b6e0:	d1f4      	bne.n	b6cc <at_handle_CRSM_cmd_set+0x2c>
    if((cmd.type != AT_CMD_CRSM_READ_BINARY) && (cmd.type != AT_CMD_CRSM_READ_RECORD) &&
    b6e2:	786a      	ldrb	r2, [r5, #1]
    b6e4:	2ab0      	cmp	r2, #176	; 0xb0
    b6e6:	d05a      	beq.n	b79e <at_handle_CRSM_cmd_set+0xfe>
    b6e8:	2340      	movs	r3, #64	; 0x40
    b6ea:	0011      	movs	r1, r2
    b6ec:	4399      	bics	r1, r3
    b6ee:	29b2      	cmp	r1, #178	; 0xb2
    b6f0:	d008      	beq.n	b704 <at_handle_CRSM_cmd_set+0x64>
    b6f2:	0013      	movs	r3, r2
    b6f4:	3340      	adds	r3, #64	; 0x40
    b6f6:	b2db      	uxtb	r3, r3
    b6f8:	2b1c      	cmp	r3, #28
    b6fa:	d8e7      	bhi.n	b6cc <at_handle_CRSM_cmd_set+0x2c>
    b6fc:	4989      	ldr	r1, [pc, #548]	; (b924 <at_handle_CRSM_cmd_set+0x284>)
    b6fe:	40d9      	lsrs	r1, r3
    b700:	07cb      	lsls	r3, r1, #31
    b702:	d5e3      	bpl.n	b6cc <at_handle_CRSM_cmd_set+0x2c>
    if(cmd.type != AT_CMD_CRSM_STATUS)
    b704:	3af2      	subs	r2, #242	; 0xf2
    b706:	1e53      	subs	r3, r2, #1
    b708:	419a      	sbcs	r2, r3
    b70a:	b2d2      	uxtb	r2, r2
    if (num_recvparams > 1)
    b70c:	7833      	ldrb	r3, [r6, #0]
    b70e:	2b01      	cmp	r3, #1
    b710:	d847      	bhi.n	b7a2 <at_handle_CRSM_cmd_set+0x102>
    if(cmd.type != AT_CMD_CRSM_GET_RESPONSE && cmd.type != AT_CMD_CRSM_STATUS)
    b712:	786c      	ldrb	r4, [r5, #1]
    b714:	2cc0      	cmp	r4, #192	; 0xc0
    b716:	d14d      	bne.n	b7b4 <at_handle_CRSM_cmd_set+0x114>
        mandatory = false;
    b718:	2400      	movs	r4, #0
    if (num_recvparams > 2)
    b71a:	7833      	ldrb	r3, [r6, #0]
    b71c:	2b02      	cmp	r3, #2
    b71e:	d921      	bls.n	b764 <at_handle_CRSM_cmd_set+0xc4>
        cause = at_get_uint16_param(AT_PARSE_THIRD_PARAM_POS, &cmd.p1, mandatory);
    b720:	0022      	movs	r2, r4
    b722:	a909      	add	r1, sp, #36	; 0x24
    b724:	2002      	movs	r0, #2
    b726:	f7fe fef1 	bl	a50c <at_get_uint16_param>
        if(cause != AT_RET_OK)
    b72a:	2800      	cmp	r0, #0
    b72c:	d1cf      	bne.n	b6ce <at_handle_CRSM_cmd_set+0x2e>
        cause = at_get_uint16_param(AT_PARSE_FOURTH_PARAM_POS, &cmd.p2, mandatory);
    b72e:	211e      	movs	r1, #30
    b730:	ab02      	add	r3, sp, #8
    b732:	0022      	movs	r2, r4
    b734:	18c9      	adds	r1, r1, r3
    b736:	3003      	adds	r0, #3
    b738:	f7fe fee8 	bl	a50c <at_get_uint16_param>
        if(cause != AT_RET_OK)
    b73c:	2800      	cmp	r0, #0
    b73e:	d1c6      	bne.n	b6ce <at_handle_CRSM_cmd_set+0x2e>
        cause = at_get_uint16_param(AT_PARSE_FIFTH_PARAM_POS, &cmd.p3, mandatory);
    b740:	0022      	movs	r2, r4
    b742:	a90a      	add	r1, sp, #40	; 0x28
    b744:	3004      	adds	r0, #4
    b746:	f7fe fee1 	bl	a50c <at_get_uint16_param>
        if(cause != AT_RET_OK)
    b74a:	2800      	cmp	r0, #0
    b74c:	d1bf      	bne.n	b6ce <at_handle_CRSM_cmd_set+0x2e>
        if((cmd.p1 <= MAX_UINT8) && (cmd.p2 <= MAX_UINT8) && (cmd.p3 <= MAX_UINT8))
    b74e:	88ab      	ldrh	r3, [r5, #4]
    b750:	2bff      	cmp	r3, #255	; 0xff
    b752:	d834      	bhi.n	b7be <at_handle_CRSM_cmd_set+0x11e>
    b754:	88eb      	ldrh	r3, [r5, #6]
    b756:	2bff      	cmp	r3, #255	; 0xff
    b758:	d831      	bhi.n	b7be <at_handle_CRSM_cmd_set+0x11e>
    b75a:	892b      	ldrh	r3, [r5, #8]
    b75c:	2bff      	cmp	r3, #255	; 0xff
    b75e:	d82e      	bhi.n	b7be <at_handle_CRSM_cmd_set+0x11e>
            cmd.p1_p2_p3_valid = true;
    b760:	2301      	movs	r3, #1
    b762:	702b      	strb	r3, [r5, #0]
    if (num_recvparams > 5)
    b764:	7833      	ldrb	r3, [r6, #0]
    b766:	2b05      	cmp	r3, #5
    b768:	d82e      	bhi.n	b7c8 <at_handle_CRSM_cmd_set+0x128>
    if (num_recvparams > 6)
    b76a:	7833      	ldrb	r3, [r6, #0]
    b76c:	2b06      	cmp	r3, #6
    b76e:	d859      	bhi.n	b824 <at_handle_CRSM_cmd_set+0x184>
    response = (uint8 *)at_alloc(MAX_RECV_DATA_LEN);
    b770:	2081      	movs	r0, #129	; 0x81
    b772:	0040      	lsls	r0, r0, #1
    b774:	f007 f94e 	bl	12a14 <irzalloc>
    b778:	0004      	movs	r4, r0
        return AT_RET_MEMORY_ERROR;
    b77a:	2004      	movs	r0, #4
    if (!response)
    b77c:	2c00      	cmp	r4, #0
    b77e:	d0a6      	beq.n	b6ce <at_handle_CRSM_cmd_set+0x2e>
    result = restricted_sim_access(&cmd, response, &response_length);
    b780:	ae06      	add	r6, sp, #24
    b782:	0032      	movs	r2, r6
    b784:	0021      	movs	r1, r4
    b786:	0028      	movs	r0, r5
    b788:	f007 f8cd 	bl	12926 <restricted_sim_access>
    b78c:	1e07      	subs	r7, r0, #0
    if (result != NEUL_RET_OK)
    b78e:	d078      	beq.n	b882 <at_handle_CRSM_cmd_set+0x1e2>
        at_free(response);
    b790:	0020      	movs	r0, r4
    b792:	f007 f951 	bl	12a38 <irfree>
        return at_parse_convert_neul_result(result);        //lint !e438   at_free sets response to NULL
    b796:	0038      	movs	r0, r7
    b798:	f7fe fd7a 	bl	a290 <at_parse_convert_neul_result>
    b79c:	e797      	b.n	b6ce <at_handle_CRSM_cmd_set+0x2e>
        mandatory = true;
    b79e:	2201      	movs	r2, #1
    b7a0:	e7b4      	b.n	b70c <at_handle_CRSM_cmd_set+0x6c>
        cause = at_get_uint16_param(AT_PARSE_SECOND_PARAM_POS, &cmd.file_id, mandatory);
    b7a2:	2122      	movs	r1, #34	; 0x22
    b7a4:	ab02      	add	r3, sp, #8
    b7a6:	18c9      	adds	r1, r1, r3
    b7a8:	2001      	movs	r0, #1
    b7aa:	f7fe feaf 	bl	a50c <at_get_uint16_param>
        if(cause != AT_RET_OK)
    b7ae:	2800      	cmp	r0, #0
    b7b0:	d0af      	beq.n	b712 <at_handle_CRSM_cmd_set+0x72>
    b7b2:	e78c      	b.n	b6ce <at_handle_CRSM_cmd_set+0x2e>
    if(cmd.type != AT_CMD_CRSM_GET_RESPONSE && cmd.type != AT_CMD_CRSM_STATUS)
    b7b4:	3cf2      	subs	r4, #242	; 0xf2
    b7b6:	1e63      	subs	r3, r4, #1
    b7b8:	419c      	sbcs	r4, r3
    b7ba:	b2e4      	uxtb	r4, r4
    b7bc:	e7ad      	b.n	b71a <at_handle_CRSM_cmd_set+0x7a>
        else if(!mandatory)
    b7be:	2c00      	cmp	r4, #0
    b7c0:	d000      	beq.n	b7c4 <at_handle_CRSM_cmd_set+0x124>
    b7c2:	e783      	b.n	b6cc <at_handle_CRSM_cmd_set+0x2c>
            cmd.p1_p2_p3_valid = false;
    b7c4:	702c      	strb	r4, [r5, #0]
    b7c6:	e7cd      	b.n	b764 <at_handle_CRSM_cmd_set+0xc4>
        cause = at_get_hexstring_param(AT_PARSE_SIXTH_PARAM_POS, &data, &data_len, false);
    b7c8:	2412      	movs	r4, #18
    b7ca:	ab02      	add	r3, sp, #8
    b7cc:	18e4      	adds	r4, r4, r3
    b7ce:	0022      	movs	r2, r4
    b7d0:	2300      	movs	r3, #0
    b7d2:	a907      	add	r1, sp, #28
    b7d4:	2005      	movs	r0, #5
    b7d6:	f7ff f829 	bl	a82c <at_get_hexstring_param>
        if(cause != AT_RET_OK)
    b7da:	2800      	cmp	r0, #0
    b7dc:	d000      	beq.n	b7e0 <at_handle_CRSM_cmd_set+0x140>
    b7de:	e776      	b.n	b6ce <at_handle_CRSM_cmd_set+0x2e>
        if(data != NULL)
    b7e0:	9807      	ldr	r0, [sp, #28]
    b7e2:	2800      	cmp	r0, #0
    b7e4:	d0c1      	beq.n	b76a <at_handle_CRSM_cmd_set+0xca>
            if ((data_len % 2 != 0) || (data_len > NEUL_MAX_CRSM_DATA_SIZE * 2))
    b7e6:	8822      	ldrh	r2, [r4, #0]
    b7e8:	07d3      	lsls	r3, r2, #31
    b7ea:	d500      	bpl.n	b7ee <at_handle_CRSM_cmd_set+0x14e>
    b7ec:	e76e      	b.n	b6cc <at_handle_CRSM_cmd_set+0x2c>
    b7ee:	23ff      	movs	r3, #255	; 0xff
    b7f0:	005b      	lsls	r3, r3, #1
    b7f2:	429a      	cmp	r2, r3
    b7f4:	d900      	bls.n	b7f8 <at_handle_CRSM_cmd_set+0x158>
    b7f6:	e769      	b.n	b6cc <at_handle_CRSM_cmd_set+0x2c>
            if (at_parse_buf_hex_to_uint8(data, data, data_len) == false)
    b7f8:	0001      	movs	r1, r0
    b7fa:	f7fe fcc2 	bl	a182 <at_parse_buf_hex_to_uint8>
    b7fe:	2800      	cmp	r0, #0
    b800:	d100      	bne.n	b804 <at_handle_CRSM_cmd_set+0x164>
    b802:	e763      	b.n	b6cc <at_handle_CRSM_cmd_set+0x2c>
            memcpy(cmd.data, data, cmd.data_len);
    b804:	202e      	movs	r0, #46	; 0x2e
            cmd.data_len = (uint8)(data_len / 2);
    b806:	8824      	ldrh	r4, [r4, #0]
            memcpy(cmd.data, data, cmd.data_len);
    b808:	ab02      	add	r3, sp, #8
            cmd.data_len = (uint8)(data_len / 2);
    b80a:	0864      	lsrs	r4, r4, #1
    b80c:	b2e2      	uxtb	r2, r4
            memcpy(cmd.data, data, cmd.data_len);
    b80e:	18c0      	adds	r0, r0, r3
    b810:	9907      	ldr	r1, [sp, #28]
            cmd.data_len = (uint8)(data_len / 2);
    b812:	70ea      	strb	r2, [r5, #3]
            memcpy(cmd.data, data, cmd.data_len);
    b814:	f7f4 fcec 	bl	1f0 <memcpy>
            if(cmd.data_len != cmd.p3)
    b818:	892b      	ldrh	r3, [r5, #8]
    b81a:	b2e4      	uxtb	r4, r4
    b81c:	42a3      	cmp	r3, r4
    b81e:	d000      	beq.n	b822 <at_handle_CRSM_cmd_set+0x182>
    b820:	e754      	b.n	b6cc <at_handle_CRSM_cmd_set+0x2c>
    b822:	e7a2      	b.n	b76a <at_handle_CRSM_cmd_set+0xca>
        cause = at_get_hexstring_param(AT_PARSE_SEVENTH_PARAM_POS, &data, &data_len, false);
    b824:	2412      	movs	r4, #18
    b826:	ab02      	add	r3, sp, #8
    b828:	18e4      	adds	r4, r4, r3
    b82a:	0022      	movs	r2, r4
    b82c:	2300      	movs	r3, #0
    b82e:	a907      	add	r1, sp, #28
    b830:	2006      	movs	r0, #6
    b832:	f7fe fffb 	bl	a82c <at_get_hexstring_param>
        if(cause != AT_RET_OK)
    b836:	2800      	cmp	r0, #0
    b838:	d000      	beq.n	b83c <at_handle_CRSM_cmd_set+0x19c>
    b83a:	e748      	b.n	b6ce <at_handle_CRSM_cmd_set+0x2e>
        if(data != NULL)
    b83c:	9807      	ldr	r0, [sp, #28]
    b83e:	2800      	cmp	r0, #0
    b840:	d096      	beq.n	b770 <at_handle_CRSM_cmd_set+0xd0>
            if ((data_len % 4 != 0) || (data_len > NEUL_MAX_PATH_SIZE * 2))
    b842:	8822      	ldrh	r2, [r4, #0]
    b844:	0793      	lsls	r3, r2, #30
    b846:	d000      	beq.n	b84a <at_handle_CRSM_cmd_set+0x1aa>
    b848:	e740      	b.n	b6cc <at_handle_CRSM_cmd_set+0x2c>
    b84a:	2a14      	cmp	r2, #20
    b84c:	d900      	bls.n	b850 <at_handle_CRSM_cmd_set+0x1b0>
    b84e:	e73d      	b.n	b6cc <at_handle_CRSM_cmd_set+0x2c>
            if (at_parse_buf_hex_to_uint8(data, data, data_len) == false)
    b850:	0001      	movs	r1, r0
    b852:	f7fe fc96 	bl	a182 <at_parse_buf_hex_to_uint8>
    b856:	2800      	cmp	r0, #0
    b858:	d100      	bne.n	b85c <at_handle_CRSM_cmd_set+0x1bc>
    b85a:	e737      	b.n	b6cc <at_handle_CRSM_cmd_set+0x2c>
            cmd.path_len = (uint8)(data_len / 2);
    b85c:	8824      	ldrh	r4, [r4, #0]
            memcpy(cmd.path_id, data, cmd.path_len);
    b85e:	9907      	ldr	r1, [sp, #28]
            cmd.path_len = (uint8)(data_len / 2);
    b860:	0864      	lsrs	r4, r4, #1
    b862:	b2e4      	uxtb	r4, r4
            memcpy(cmd.path_id, data, cmd.path_len);
    b864:	0022      	movs	r2, r4
            cmd.path_len = (uint8)(data_len / 2);
    b866:	70ac      	strb	r4, [r5, #2]
            memcpy(cmd.path_id, data, cmd.path_len);
    b868:	a80b      	add	r0, sp, #44	; 0x2c
            if(((cmd.path_id[cmd.path_len - 2] << 8) | (cmd.path_id[cmd.path_len - 1])) != cmd.file_id)
    b86a:	192c      	adds	r4, r5, r4
            memcpy(cmd.path_id, data, cmd.path_len);
    b86c:	f7f4 fcc0 	bl	1f0 <memcpy>
            if(((cmd.path_id[cmd.path_len - 2] << 8) | (cmd.path_id[cmd.path_len - 1])) != cmd.file_id)
    b870:	7aa3      	ldrb	r3, [r4, #10]
    b872:	7ae2      	ldrb	r2, [r4, #11]
    b874:	021b      	lsls	r3, r3, #8
    b876:	4313      	orrs	r3, r2
    b878:	896a      	ldrh	r2, [r5, #10]
    b87a:	4293      	cmp	r3, r2
    b87c:	d000      	beq.n	b880 <at_handle_CRSM_cmd_set+0x1e0>
    b87e:	e725      	b.n	b6cc <at_handle_CRSM_cmd_set+0x2c>
    b880:	e776      	b.n	b770 <at_handle_CRSM_cmd_set+0xd0>
    rsp_string = at_alloc(response_length * 2 + AT_MAX_CRSM_PREFIX_RSP_LEN);
    b882:	8830      	ldrh	r0, [r6, #0]
    b884:	0040      	lsls	r0, r0, #1
    b886:	300f      	adds	r0, #15
    b888:	f007 f8c4 	bl	12a14 <irzalloc>
    b88c:	1e05      	subs	r5, r0, #0
    if(!rsp_string)
    b88e:	d104      	bne.n	b89a <at_handle_CRSM_cmd_set+0x1fa>
        at_free(response);
    b890:	0020      	movs	r0, r4
    b892:	f007 f8d1 	bl	12a38 <irfree>
        return AT_RET_MEMORY_ERROR;     //lint !e438   at_free sets response to NULL
    b896:	2004      	movs	r0, #4
    b898:	e719      	b.n	b6ce <at_handle_CRSM_cmd_set+0x2e>
    memset(rsp_string, 0, response_length * 2 + AT_MAX_CRSM_PREFIX_RSP_LEN);
    b89a:	8832      	ldrh	r2, [r6, #0]
    b89c:	0039      	movs	r1, r7
    b89e:	0052      	lsls	r2, r2, #1
    b8a0:	320f      	adds	r2, #15
    b8a2:	f7f4 fd1d 	bl	2e0 <memset>
    rsp_len = (uint16)snprintf(rsp_string, response_length * 2 + AT_MAX_CRSM_PREFIX_RSP_LEN, "%s%d,%d", AT_CMD_CRSM_PREFIX_STR, response[response_length-2], response[response_length-1]);
    b8a6:	8833      	ldrh	r3, [r6, #0]
    b8a8:	0028      	movs	r0, r5
    b8aa:	0059      	lsls	r1, r3, #1
    b8ac:	18e3      	adds	r3, r4, r3
    b8ae:	1e5a      	subs	r2, r3, #1
    b8b0:	7812      	ldrb	r2, [r2, #0]
    b8b2:	3b02      	subs	r3, #2
    b8b4:	9201      	str	r2, [sp, #4]
    b8b6:	781b      	ldrb	r3, [r3, #0]
    b8b8:	310f      	adds	r1, #15
    b8ba:	9300      	str	r3, [sp, #0]
    b8bc:	4a1a      	ldr	r2, [pc, #104]	; (b928 <at_handle_CRSM_cmd_set+0x288>)
    b8be:	4b1b      	ldr	r3, [pc, #108]	; (b92c <at_handle_CRSM_cmd_set+0x28c>)
    b8c0:	f00e ffd4 	bl	1a86c <snprintf>
    if(response_length > 2)
    b8c4:	8831      	ldrh	r1, [r6, #0]
    rsp_len = (uint16)snprintf(rsp_string, response_length * 2 + AT_MAX_CRSM_PREFIX_RSP_LEN, "%s%d,%d", AT_CMD_CRSM_PREFIX_STR, response[response_length-2], response[response_length-1]);
    b8c6:	9003      	str	r0, [sp, #12]
    if(response_length > 2)
    b8c8:	2902      	cmp	r1, #2
    b8ca:	d80a      	bhi.n	b8e2 <at_handle_CRSM_cmd_set+0x242>
    app_at_send_at_rsp_string_lines_with_claim_and_log(rsp_string);
    b8cc:	0028      	movs	r0, r5
    b8ce:	f7fd fe89 	bl	95e4 <app_at_send_at_rsp_string_lines_with_claim_and_log>
    at_free(response);
    b8d2:	0020      	movs	r0, r4
    b8d4:	f007 f8b0 	bl	12a38 <irfree>
    at_free(rsp_string);
    b8d8:	0028      	movs	r0, r5
    b8da:	f007 f8ad 	bl	12a38 <irfree>
    return AT_RET_OK;       //lint !e438   at_free sets response to NULL
    b8de:	2000      	movs	r0, #0
    b8e0:	e6f5      	b.n	b6ce <at_handle_CRSM_cmd_set+0x2e>
    b8e2:	466b      	mov	r3, sp
        rsp_len += (uint16)snprintf(rsp_string + rsp_len, response_length * 2 + AT_MAX_CRSM_PREFIX_RSP_LEN - rsp_len, ",");
    b8e4:	0049      	lsls	r1, r1, #1
    b8e6:	8998      	ldrh	r0, [r3, #12]
    b8e8:	310f      	adds	r1, #15
    b8ea:	1a09      	subs	r1, r1, r0
    b8ec:	4a10      	ldr	r2, [pc, #64]	; (b930 <at_handle_CRSM_cmd_set+0x290>)
    b8ee:	1828      	adds	r0, r5, r0
    b8f0:	f00e ffbc 	bl	1a86c <snprintf>
    b8f4:	9b03      	ldr	r3, [sp, #12]
    b8f6:	1818      	adds	r0, r3, r0
    b8f8:	b283      	uxth	r3, r0
    b8fa:	9303      	str	r3, [sp, #12]
        for(index = 0;index < response_length - 2; index++)
    b8fc:	8831      	ldrh	r1, [r6, #0]
    b8fe:	1e8b      	subs	r3, r1, #2
    b900:	429f      	cmp	r7, r3
    b902:	dae3      	bge.n	b8cc <at_handle_CRSM_cmd_set+0x22c>
            rsp_len += (uint16)snprintf(rsp_string + rsp_len, response_length * 2 + AT_MAX_CRSM_PREFIX_RSP_LEN - rsp_len, "%02x", response[index]);
    b904:	9a03      	ldr	r2, [sp, #12]
    b906:	0049      	lsls	r1, r1, #1
    b908:	310f      	adds	r1, #15
    b90a:	5de3      	ldrb	r3, [r4, r7]
    b90c:	1a89      	subs	r1, r1, r2
    b90e:	18a8      	adds	r0, r5, r2
    b910:	4a08      	ldr	r2, [pc, #32]	; (b934 <at_handle_CRSM_cmd_set+0x294>)
    b912:	f00e ffab 	bl	1a86c <snprintf>
    b916:	9b03      	ldr	r3, [sp, #12]
        for(index = 0;index < response_length - 2; index++)
    b918:	3701      	adds	r7, #1
            rsp_len += (uint16)snprintf(rsp_string + rsp_len, response_length * 2 + AT_MAX_CRSM_PREFIX_RSP_LEN - rsp_len, "%02x", response[index]);
    b91a:	1818      	adds	r0, r3, r0
    b91c:	b283      	uxth	r3, r0
    b91e:	9303      	str	r3, [sp, #12]
        for(index = 0;index < response_length - 2; index++)
    b920:	b2bf      	uxth	r7, r7
    b922:	e7eb      	b.n	b8fc <at_handle_CRSM_cmd_set+0x25c>
    b924:	10400001 	.word	0x10400001
    b928:	00023e83 	.word	0x00023e83
    b92c:	00023937 	.word	0x00023937
    b930:	00024ab6 	.word	0x00024ab6
    b934:	0002393f 	.word	0x0002393f

0000b938 <at_handle_CSIM_cmd_set>:
{
    b938:	b5f0      	push	{r4, r5, r6, r7, lr}
    uint16              command_len = 0;
    b93a:	260e      	movs	r6, #14
{
    b93c:	b089      	sub	sp, #36	; 0x24
    uint16              command_len = 0;
    b93e:	ab02      	add	r3, sp, #8
    b940:	18f6      	adds	r6, r6, r3
    b942:	2300      	movs	r3, #0
    if (at_create_param_array(p_atparams_string, &num_recvparams, 2, 2) != AT_RET_OK)
    b944:	210d      	movs	r1, #13
    uint16              command_len = 0;
    b946:	8033      	strh	r3, [r6, #0]
    uint8               *command = NULL;
    b948:	9307      	str	r3, [sp, #28]
    if (at_create_param_array(p_atparams_string, &num_recvparams, 2, 2) != AT_RET_OK)
    b94a:	ac02      	add	r4, sp, #8
    b94c:	3302      	adds	r3, #2
    b94e:	001a      	movs	r2, r3
    b950:	1909      	adds	r1, r1, r4
    b952:	f7fe fcc7 	bl	a2e4 <at_create_param_array>
    b956:	2800      	cmp	r0, #0
    b958:	d003      	beq.n	b962 <at_handle_CSIM_cmd_set+0x2a>
       return AT_RET_SYNTAX_ERROR;
    b95a:	2401      	movs	r4, #1
}
    b95c:	0020      	movs	r0, r4
    b95e:	b009      	add	sp, #36	; 0x24
    b960:	bdf0      	pop	{r4, r5, r6, r7, pc}
    cause = at_get_uint16_param(AT_PARSE_FIRST_PARAM_POS, &command_length, true);
    b962:	ad06      	add	r5, sp, #24
    b964:	2201      	movs	r2, #1
    b966:	0029      	movs	r1, r5
    b968:	f7fe fdd0 	bl	a50c <at_get_uint16_param>
    b96c:	1e04      	subs	r4, r0, #0
    if (cause != AT_RET_OK)
    b96e:	d1f5      	bne.n	b95c <at_handle_CSIM_cmd_set+0x24>
    cause = at_get_hexstring_param(AT_PARSE_SECOND_PARAM_POS, &command, &command_len, true);
    b970:	2301      	movs	r3, #1
    b972:	0032      	movs	r2, r6
    b974:	a907      	add	r1, sp, #28
    b976:	0018      	movs	r0, r3
    b978:	f7fe ff58 	bl	a82c <at_get_hexstring_param>
    b97c:	1e04      	subs	r4, r0, #0
    if (cause != AT_RET_OK)
    b97e:	d1ed      	bne.n	b95c <at_handle_CSIM_cmd_set+0x24>
    if ((command_length != command_len) || (command_length % 2 != 0))
    b980:	882a      	ldrh	r2, [r5, #0]
    b982:	8833      	ldrh	r3, [r6, #0]
    b984:	429a      	cmp	r2, r3
    b986:	d1e8      	bne.n	b95a <at_handle_CSIM_cmd_set+0x22>
    b988:	07d3      	lsls	r3, r2, #31
    b98a:	d4e6      	bmi.n	b95a <at_handle_CSIM_cmd_set+0x22>
    if (at_parse_buf_hex_to_uint8(command, command, command_len) == false)
    b98c:	9907      	ldr	r1, [sp, #28]
    b98e:	0008      	movs	r0, r1
    b990:	f7fe fbf7 	bl	a182 <at_parse_buf_hex_to_uint8>
    b994:	2800      	cmp	r0, #0
    b996:	d0e0      	beq.n	b95a <at_handle_CSIM_cmd_set+0x22>
    response = (uint8 *)at_alloc(MAX_RECV_DATA_LEN);
    b998:	2081      	movs	r0, #129	; 0x81
    b99a:	0040      	lsls	r0, r0, #1
    b99c:	f007 f83a 	bl	12a14 <irzalloc>
    b9a0:	1e06      	subs	r6, r0, #0
    if (!response)
    b9a2:	d01e      	beq.n	b9e2 <at_handle_CSIM_cmd_set+0xaa>
    result = generic_uicc_logical_channel_access(FIRST_CHANNEL_NB, command, command_length / 2, response, &response_length);
    b9a4:	2712      	movs	r7, #18
    b9a6:	882a      	ldrh	r2, [r5, #0]
    b9a8:	ab02      	add	r3, sp, #8
    b9aa:	18ff      	adds	r7, r7, r3
    b9ac:	0852      	lsrs	r2, r2, #1
    b9ae:	0003      	movs	r3, r0
    b9b0:	9700      	str	r7, [sp, #0]
    b9b2:	9907      	ldr	r1, [sp, #28]
    b9b4:	0020      	movs	r0, r4
    b9b6:	f006 ff7e 	bl	128b6 <generic_uicc_logical_channel_access>
    b9ba:	1e05      	subs	r5, r0, #0
    if (result != NEUL_RET_OK)
    b9bc:	d007      	beq.n	b9ce <at_handle_CSIM_cmd_set+0x96>
        at_free(response);
    b9be:	0030      	movs	r0, r6
    b9c0:	f007 f83a 	bl	12a38 <irfree>
        return at_parse_convert_neul_result(result);        //lint !e438   at_free sets response to NULL
    b9c4:	0028      	movs	r0, r5
    b9c6:	f7fe fc63 	bl	a290 <at_parse_convert_neul_result>
    b9ca:	0004      	movs	r4, r0
    b9cc:	e7c6      	b.n	b95c <at_handle_CSIM_cmd_set+0x24>
    rsp_string = at_alloc(response_length * 2 + AT_MAX_CSIM_PREFIX_RSP_LEN);
    b9ce:	8838      	ldrh	r0, [r7, #0]
    b9d0:	0040      	lsls	r0, r0, #1
    b9d2:	300b      	adds	r0, #11
    b9d4:	f007 f81e 	bl	12a14 <irzalloc>
    b9d8:	1e05      	subs	r5, r0, #0
    if(!rsp_string)
    b9da:	d104      	bne.n	b9e6 <at_handle_CSIM_cmd_set+0xae>
        at_free(response);
    b9dc:	0030      	movs	r0, r6
    b9de:	f007 f82b 	bl	12a38 <irfree>
        return AT_RET_MEMORY_ERROR;
    b9e2:	2404      	movs	r4, #4
    b9e4:	e7ba      	b.n	b95c <at_handle_CSIM_cmd_set+0x24>
    memset(rsp_string, 0, response_length * 2 + AT_MAX_CSIM_PREFIX_RSP_LEN);
    b9e6:	883a      	ldrh	r2, [r7, #0]
    b9e8:	0021      	movs	r1, r4
    b9ea:	0052      	lsls	r2, r2, #1
    b9ec:	320b      	adds	r2, #11
    b9ee:	f7f4 fc77 	bl	2e0 <memset>
    rsp_len = (uint16)snprintf(rsp_string, response_length * 2 + AT_MAX_CSIM_PREFIX_RSP_LEN, "%s%d,",AT_CMD_CSIM_PREFIX_STR,response_length * 2);
    b9f2:	883b      	ldrh	r3, [r7, #0]
    b9f4:	4a15      	ldr	r2, [pc, #84]	; (ba4c <at_handle_CSIM_cmd_set+0x114>)
    b9f6:	005b      	lsls	r3, r3, #1
    b9f8:	0019      	movs	r1, r3
    b9fa:	9300      	str	r3, [sp, #0]
    b9fc:	310b      	adds	r1, #11
    b9fe:	4b14      	ldr	r3, [pc, #80]	; (ba50 <at_handle_CSIM_cmd_set+0x118>)
    ba00:	0028      	movs	r0, r5
    ba02:	f00e ff33 	bl	1a86c <snprintf>
    for(index = 0;index < response_length; index++)
    ba06:	9403      	str	r4, [sp, #12]
    rsp_len = (uint16)snprintf(rsp_string, response_length * 2 + AT_MAX_CSIM_PREFIX_RSP_LEN, "%s%d,",AT_CMD_CSIM_PREFIX_STR,response_length * 2);
    ba08:	b287      	uxth	r7, r0
    for(index = 0;index < response_length; index++)
    ba0a:	2312      	movs	r3, #18
    ba0c:	aa02      	add	r2, sp, #8
    ba0e:	189b      	adds	r3, r3, r2
    ba10:	8819      	ldrh	r1, [r3, #0]
    ba12:	9b03      	ldr	r3, [sp, #12]
    ba14:	4299      	cmp	r1, r3
    ba16:	d809      	bhi.n	ba2c <at_handle_CSIM_cmd_set+0xf4>
    app_at_send_at_rsp_string_lines_with_claim_and_log(rsp_string);
    ba18:	0028      	movs	r0, r5
    ba1a:	f7fd fde3 	bl	95e4 <app_at_send_at_rsp_string_lines_with_claim_and_log>
    at_free(response);
    ba1e:	0030      	movs	r0, r6
    ba20:	f007 f80a 	bl	12a38 <irfree>
    at_free(rsp_string);
    ba24:	0028      	movs	r0, r5
    ba26:	f007 f807 	bl	12a38 <irfree>
    return AT_RET_OK;       //lint !e438   at_free sets response to NULL
    ba2a:	e797      	b.n	b95c <at_handle_CSIM_cmd_set+0x24>
        rsp_len += (uint16)snprintf(rsp_string + rsp_len, response_length * 2 + AT_MAX_CSIM_PREFIX_RSP_LEN - rsp_len, "%02x", response[index]);
    ba2c:	9b03      	ldr	r3, [sp, #12]
    ba2e:	0049      	lsls	r1, r1, #1
    ba30:	310b      	adds	r1, #11
    ba32:	5cf3      	ldrb	r3, [r6, r3]
    ba34:	1bc9      	subs	r1, r1, r7
    ba36:	19e8      	adds	r0, r5, r7
    ba38:	4a06      	ldr	r2, [pc, #24]	; (ba54 <at_handle_CSIM_cmd_set+0x11c>)
    ba3a:	f00e ff17 	bl	1a86c <snprintf>
    for(index = 0;index < response_length; index++)
    ba3e:	9b03      	ldr	r3, [sp, #12]
        rsp_len += (uint16)snprintf(rsp_string + rsp_len, response_length * 2 + AT_MAX_CSIM_PREFIX_RSP_LEN - rsp_len, "%02x", response[index]);
    ba40:	183f      	adds	r7, r7, r0
    for(index = 0;index < response_length; index++)
    ba42:	3301      	adds	r3, #1
    ba44:	b29b      	uxth	r3, r3
        rsp_len += (uint16)snprintf(rsp_string + rsp_len, response_length * 2 + AT_MAX_CSIM_PREFIX_RSP_LEN - rsp_len, "%02x", response[index]);
    ba46:	b2bf      	uxth	r7, r7
    for(index = 0;index < response_length; index++)
    ba48:	9303      	str	r3, [sp, #12]
    ba4a:	e7de      	b.n	ba0a <at_handle_CSIM_cmd_set+0xd2>
    ba4c:	00023972 	.word	0x00023972
    ba50:	0002396a 	.word	0x0002396a
    ba54:	0002393f 	.word	0x0002393f

0000ba58 <at_handle_CGLA_cmd_set>:
{
    ba58:	b5f0      	push	{r4, r5, r6, r7, lr}
    uint16              command_len = 0;
    ba5a:	260e      	movs	r6, #14
{
    ba5c:	b089      	sub	sp, #36	; 0x24
    uint16              command_len = 0;
    ba5e:	ab02      	add	r3, sp, #8
    ba60:	18f6      	adds	r6, r6, r3
    ba62:	2300      	movs	r3, #0
    ba64:	8033      	strh	r3, [r6, #0]
    uint8               *command = NULL;
    ba66:	9307      	str	r3, [sp, #28]
    if (at_create_param_array(p_atparams_string, &num_recvparams, 3, 3) != AT_RET_OK)
    ba68:	3303      	adds	r3, #3
    ba6a:	001a      	movs	r2, r3
    ba6c:	a905      	add	r1, sp, #20
    ba6e:	f7fe fc39 	bl	a2e4 <at_create_param_array>
    ba72:	2800      	cmp	r0, #0
    ba74:	d003      	beq.n	ba7e <at_handle_CGLA_cmd_set+0x26>
       return AT_RET_SYNTAX_ERROR;
    ba76:	2401      	movs	r4, #1
}
    ba78:	0020      	movs	r0, r4
    ba7a:	b009      	add	sp, #36	; 0x24
    ba7c:	bdf0      	pop	{r4, r5, r6, r7, pc}
    cause = at_get_uint8_param(AT_PARSE_FIRST_PARAM_POS, &sessionid, true);
    ba7e:	250d      	movs	r5, #13
    ba80:	ab02      	add	r3, sp, #8
    ba82:	18ed      	adds	r5, r5, r3
    ba84:	2201      	movs	r2, #1
    ba86:	0029      	movs	r1, r5
    ba88:	f7fe fdc0 	bl	a60c <at_get_uint8_param>
    ba8c:	1e04      	subs	r4, r0, #0
    if (cause != AT_RET_OK)
    ba8e:	d1f3      	bne.n	ba78 <at_handle_CGLA_cmd_set+0x20>
    if ((sessionid == FIRST_CHANNEL_NB) || (sessionid > LAST_CHANNEL_NB))
    ba90:	782b      	ldrb	r3, [r5, #0]
    ba92:	3b01      	subs	r3, #1
    ba94:	2b02      	cmp	r3, #2
    ba96:	d8ee      	bhi.n	ba76 <at_handle_CGLA_cmd_set+0x1e>
    cause = at_get_uint16_param(AT_PARSE_SECOND_PARAM_POS, &command_length, true);
    ba98:	2201      	movs	r2, #1
    ba9a:	af06      	add	r7, sp, #24
    ba9c:	0039      	movs	r1, r7
    ba9e:	0010      	movs	r0, r2
    baa0:	f7fe fd34 	bl	a50c <at_get_uint16_param>
    baa4:	1e04      	subs	r4, r0, #0
    if (cause != AT_RET_OK)
    baa6:	d1e7      	bne.n	ba78 <at_handle_CGLA_cmd_set+0x20>
    cause = at_get_hexstring_param(AT_PARSE_THIRD_PARAM_POS, &command, &command_len, true);
    baa8:	2301      	movs	r3, #1
    baaa:	0032      	movs	r2, r6
    baac:	a907      	add	r1, sp, #28
    baae:	2002      	movs	r0, #2
    bab0:	f7fe febc 	bl	a82c <at_get_hexstring_param>
    bab4:	1e04      	subs	r4, r0, #0
    if (cause != AT_RET_OK)
    bab6:	d1df      	bne.n	ba78 <at_handle_CGLA_cmd_set+0x20>
    if ((command_length != command_len) || (command_length % 2 != 0))
    bab8:	883a      	ldrh	r2, [r7, #0]
    baba:	8833      	ldrh	r3, [r6, #0]
    babc:	429a      	cmp	r2, r3
    babe:	d1da      	bne.n	ba76 <at_handle_CGLA_cmd_set+0x1e>
    bac0:	07d3      	lsls	r3, r2, #31
    bac2:	d4d8      	bmi.n	ba76 <at_handle_CGLA_cmd_set+0x1e>
    if (at_parse_buf_hex_to_uint8(command, command, command_len) == false)
    bac4:	9907      	ldr	r1, [sp, #28]
    bac6:	0008      	movs	r0, r1
    bac8:	f7fe fb5b 	bl	a182 <at_parse_buf_hex_to_uint8>
    bacc:	2800      	cmp	r0, #0
    bace:	d0d2      	beq.n	ba76 <at_handle_CGLA_cmd_set+0x1e>
    response = (uint8 *)at_alloc(MAX_RECV_DATA_LEN);
    bad0:	2081      	movs	r0, #129	; 0x81
    bad2:	0040      	lsls	r0, r0, #1
    bad4:	f006 ff9e 	bl	12a14 <irzalloc>
    bad8:	1e06      	subs	r6, r0, #0
    if (!response)
    bada:	d01e      	beq.n	bb1a <at_handle_CGLA_cmd_set+0xc2>
    result = generic_uicc_logical_channel_access(sessionid, command, command_length / 2, response, &response_length);
    badc:	883a      	ldrh	r2, [r7, #0]
    bade:	2712      	movs	r7, #18
    bae0:	ab02      	add	r3, sp, #8
    bae2:	18ff      	adds	r7, r7, r3
    bae4:	7828      	ldrb	r0, [r5, #0]
    bae6:	0852      	lsrs	r2, r2, #1
    bae8:	9700      	str	r7, [sp, #0]
    baea:	0033      	movs	r3, r6
    baec:	9907      	ldr	r1, [sp, #28]
    baee:	f006 fee2 	bl	128b6 <generic_uicc_logical_channel_access>
    baf2:	1e05      	subs	r5, r0, #0
    if (result != NEUL_RET_OK)
    baf4:	d007      	beq.n	bb06 <at_handle_CGLA_cmd_set+0xae>
        at_free(response);
    baf6:	0030      	movs	r0, r6
    baf8:	f006 ff9e 	bl	12a38 <irfree>
        return at_parse_convert_neul_result(result);        //lint !e438   at_free sets response to NULL
    bafc:	0028      	movs	r0, r5
    bafe:	f7fe fbc7 	bl	a290 <at_parse_convert_neul_result>
    bb02:	0004      	movs	r4, r0
    bb04:	e7b8      	b.n	ba78 <at_handle_CGLA_cmd_set+0x20>
    rsp_string = at_alloc(response_length * 2 + AT_MAX_CGLA_PREFIX_RSP_LEN);
    bb06:	8838      	ldrh	r0, [r7, #0]
    bb08:	0040      	lsls	r0, r0, #1
    bb0a:	300b      	adds	r0, #11
    bb0c:	f006 ff82 	bl	12a14 <irzalloc>
    bb10:	1e05      	subs	r5, r0, #0
    if(!rsp_string)
    bb12:	d104      	bne.n	bb1e <at_handle_CGLA_cmd_set+0xc6>
        at_free(response);
    bb14:	0030      	movs	r0, r6
    bb16:	f006 ff8f 	bl	12a38 <irfree>
        return AT_RET_MEMORY_ERROR;
    bb1a:	2404      	movs	r4, #4
    bb1c:	e7ac      	b.n	ba78 <at_handle_CGLA_cmd_set+0x20>
    memset(rsp_string, 0, response_length * 2 + AT_MAX_CGLA_PREFIX_RSP_LEN);
    bb1e:	883a      	ldrh	r2, [r7, #0]
    bb20:	2100      	movs	r1, #0
    bb22:	0052      	lsls	r2, r2, #1
    bb24:	320b      	adds	r2, #11
    bb26:	f7f4 fbdb 	bl	2e0 <memset>
    rsp_len = (uint16)snprintf(rsp_string, response_length * 2 + AT_MAX_CGLA_PREFIX_RSP_LEN, "%s%d,",AT_CMD_CGLA_PREFIX_STR,response_length * 2);
    bb2a:	883b      	ldrh	r3, [r7, #0]
    bb2c:	4a15      	ldr	r2, [pc, #84]	; (bb84 <at_handle_CGLA_cmd_set+0x12c>)
    bb2e:	005b      	lsls	r3, r3, #1
    bb30:	0019      	movs	r1, r3
    bb32:	9300      	str	r3, [sp, #0]
    bb34:	310b      	adds	r1, #11
    bb36:	4b14      	ldr	r3, [pc, #80]	; (bb88 <at_handle_CGLA_cmd_set+0x130>)
    bb38:	0028      	movs	r0, r5
    bb3a:	f00e fe97 	bl	1a86c <snprintf>
    for(index = 0;index < response_length; index++)
    bb3e:	2300      	movs	r3, #0
    rsp_len = (uint16)snprintf(rsp_string, response_length * 2 + AT_MAX_CGLA_PREFIX_RSP_LEN, "%s%d,",AT_CMD_CGLA_PREFIX_STR,response_length * 2);
    bb40:	b287      	uxth	r7, r0
    for(index = 0;index < response_length; index++)
    bb42:	9303      	str	r3, [sp, #12]
    bb44:	2312      	movs	r3, #18
    bb46:	aa02      	add	r2, sp, #8
    bb48:	189b      	adds	r3, r3, r2
    bb4a:	8819      	ldrh	r1, [r3, #0]
    bb4c:	9b03      	ldr	r3, [sp, #12]
    bb4e:	4299      	cmp	r1, r3
    bb50:	d809      	bhi.n	bb66 <at_handle_CGLA_cmd_set+0x10e>
    app_at_send_at_rsp_string_lines_with_claim_and_log(rsp_string);
    bb52:	0028      	movs	r0, r5
    bb54:	f7fd fd46 	bl	95e4 <app_at_send_at_rsp_string_lines_with_claim_and_log>
    at_free(response);
    bb58:	0030      	movs	r0, r6
    bb5a:	f006 ff6d 	bl	12a38 <irfree>
    at_free(rsp_string);
    bb5e:	0028      	movs	r0, r5
    bb60:	f006 ff6a 	bl	12a38 <irfree>
    return AT_RET_OK;       //lint !e438   at_free sets response to NULL
    bb64:	e788      	b.n	ba78 <at_handle_CGLA_cmd_set+0x20>
        rsp_len += (uint16)snprintf(rsp_string + rsp_len, response_length * 2 + AT_MAX_CGLA_PREFIX_RSP_LEN - rsp_len, "%02x", response[index]);
    bb66:	9b03      	ldr	r3, [sp, #12]
    bb68:	0049      	lsls	r1, r1, #1
    bb6a:	310b      	adds	r1, #11
    bb6c:	5cf3      	ldrb	r3, [r6, r3]
    bb6e:	1bc9      	subs	r1, r1, r7
    bb70:	19e8      	adds	r0, r5, r7
    bb72:	4a06      	ldr	r2, [pc, #24]	; (bb8c <at_handle_CGLA_cmd_set+0x134>)
    bb74:	f00e fe7a 	bl	1a86c <snprintf>
    for(index = 0;index < response_length; index++)
    bb78:	9b03      	ldr	r3, [sp, #12]
        rsp_len += (uint16)snprintf(rsp_string + rsp_len, response_length * 2 + AT_MAX_CGLA_PREFIX_RSP_LEN - rsp_len, "%02x", response[index]);
    bb7a:	183f      	adds	r7, r7, r0
    for(index = 0;index < response_length; index++)
    bb7c:	3301      	adds	r3, #1
        rsp_len += (uint16)snprintf(rsp_string + rsp_len, response_length * 2 + AT_MAX_CGLA_PREFIX_RSP_LEN - rsp_len, "%02x", response[index]);
    bb7e:	b2bf      	uxth	r7, r7
    for(index = 0;index < response_length; index++)
    bb80:	b29b      	uxth	r3, r3
    bb82:	e7de      	b.n	bb42 <at_handle_CGLA_cmd_set+0xea>
    bb84:	00023972 	.word	0x00023972
    bb88:	000237a7 	.word	0x000237a7
    bb8c:	0002393f 	.word	0x0002393f

0000bb90 <at_handle_CCHO_cmd_set>:
{
    bb90:	b570      	push	{r4, r5, r6, lr}
    bb92:	b086      	sub	sp, #24
    bb94:	0004      	movs	r4, r0
    char                rsp_string[MAX_UINT32_CHARACTERS + 1] = {0};
    bb96:	220b      	movs	r2, #11
    bb98:	2100      	movs	r1, #0
    bb9a:	a803      	add	r0, sp, #12
    bb9c:	f7f4 fba0 	bl	2e0 <memset>
    uint16              df_name_len = 0;
    bba0:	466b      	mov	r3, sp
    uint8               sessionid = 0;
    bba2:	466a      	mov	r2, sp
    uint16              df_name_len = 0;
    bba4:	1d9d      	adds	r5, r3, #6
    bba6:	2300      	movs	r3, #0
    uint8               sessionid = 0;
    bba8:	1d56      	adds	r6, r2, #5
    uint16              df_name_len = 0;
    bbaa:	802b      	strh	r3, [r5, #0]
    uint8               *df_name = NULL;
    bbac:	9302      	str	r3, [sp, #8]
    uint8               sessionid = 0;
    bbae:	7033      	strb	r3, [r6, #0]
    if (at_create_param_array(p_atparams_string, &num_recvparams, 1, 1) != AT_RET_OK)
    bbb0:	3301      	adds	r3, #1
    bbb2:	001a      	movs	r2, r3
    bbb4:	a901      	add	r1, sp, #4
    bbb6:	0020      	movs	r0, r4
    bbb8:	f7fe fb94 	bl	a2e4 <at_create_param_array>
    bbbc:	2800      	cmp	r0, #0
    bbbe:	d003      	beq.n	bbc8 <at_handle_CCHO_cmd_set+0x38>
       return AT_RET_SYNTAX_ERROR;
    bbc0:	2401      	movs	r4, #1
}
    bbc2:	0020      	movs	r0, r4
    bbc4:	b006      	add	sp, #24
    bbc6:	bd70      	pop	{r4, r5, r6, pc}
    cause = at_get_hexstring_param(AT_PARSE_FIRST_PARAM_POS, &df_name, &df_name_len, true);
    bbc8:	2301      	movs	r3, #1
    bbca:	002a      	movs	r2, r5
    bbcc:	a902      	add	r1, sp, #8
    bbce:	f7fe fe2d 	bl	a82c <at_get_hexstring_param>
    bbd2:	1e04      	subs	r4, r0, #0
    if (cause != AT_RET_OK)
    bbd4:	d1f5      	bne.n	bbc2 <at_handle_CCHO_cmd_set+0x32>
    if ((df_name_len > 2 * APP_ID_MAX_LENGTH) || (df_name_len % 2 != 0))
    bbd6:	882a      	ldrh	r2, [r5, #0]
    bbd8:	2a20      	cmp	r2, #32
    bbda:	d8f1      	bhi.n	bbc0 <at_handle_CCHO_cmd_set+0x30>
    bbdc:	07d3      	lsls	r3, r2, #31
    bbde:	d4ef      	bmi.n	bbc0 <at_handle_CCHO_cmd_set+0x30>
    if (at_parse_buf_hex_to_uint8(df_name, df_name, df_name_len) == false)
    bbe0:	9902      	ldr	r1, [sp, #8]
    bbe2:	0008      	movs	r0, r1
    bbe4:	f7fe facd 	bl	a182 <at_parse_buf_hex_to_uint8>
    bbe8:	2800      	cmp	r0, #0
    bbea:	d0e9      	beq.n	bbc0 <at_handle_CCHO_cmd_set+0x30>
    result = open_logical_channel(df_name, df_name_len / 2, &sessionid);
    bbec:	8829      	ldrh	r1, [r5, #0]
    bbee:	0032      	movs	r2, r6
    bbf0:	0849      	lsrs	r1, r1, #1
    bbf2:	9802      	ldr	r0, [sp, #8]
    bbf4:	f006 fe32 	bl	1285c <open_logical_channel>
    if (result != NEUL_RET_OK)
    bbf8:	2800      	cmp	r0, #0
    bbfa:	d003      	beq.n	bc04 <at_handle_CCHO_cmd_set+0x74>
        return at_parse_convert_neul_result(result);
    bbfc:	f7fe fb48 	bl	a290 <at_parse_convert_neul_result>
    bc00:	0004      	movs	r4, r0
    bc02:	e7de      	b.n	bbc2 <at_handle_CCHO_cmd_set+0x32>
    (void)snprintf(rsp_string, MAX_UINT32_CHARACTERS + 1, "%ld", sessionid);
    bc04:	7833      	ldrb	r3, [r6, #0]
    bc06:	4a04      	ldr	r2, [pc, #16]	; (bc18 <at_handle_CCHO_cmd_set+0x88>)
    bc08:	210b      	movs	r1, #11
    bc0a:	a803      	add	r0, sp, #12
    bc0c:	f00e fe2e 	bl	1a86c <snprintf>
    app_at_send_at_rsp_string_lines_with_claim_and_log(rsp_string);
    bc10:	a803      	add	r0, sp, #12
    bc12:	f7fd fce7 	bl	95e4 <app_at_send_at_rsp_string_lines_with_claim_and_log>
    return AT_RET_OK;
    bc16:	e7d4      	b.n	bbc2 <at_handle_CCHO_cmd_set+0x32>
    bc18:	000234f1 	.word	0x000234f1

0000bc1c <at_handle_CPINR_cmd_exec>:
{
    bc1c:	b5f0      	push	{r4, r5, r6, r7, lr}
    const char          *str_table[AT_CPINR_CODE_NUM] = {"SIM PIN", "SIM PUK"};
    bc1e:	2401      	movs	r4, #1
    bool                first_flag = true;
    bc20:	0025      	movs	r5, r4
{
    bc22:	b08f      	sub	sp, #60	; 0x3c
    char                rsp_string[AT_MAX_CPINR_RESULT_RSP_LEN]   = {0};
    bc24:	2216      	movs	r2, #22
    bc26:	2100      	movs	r1, #0
    bc28:	a808      	add	r0, sp, #32
    bc2a:	f7f4 fb59 	bl	2e0 <memset>
    const char          *str_table[AT_CPINR_CODE_NUM] = {"SIM PIN", "SIM PUK"};
    bc2e:	4b1f      	ldr	r3, [pc, #124]	; (bcac <at_handle_CPINR_cmd_exec+0x90>)
    bc30:	9306      	str	r3, [sp, #24]
    bc32:	4b1f      	ldr	r3, [pc, #124]	; (bcb0 <at_handle_CPINR_cmd_exec+0x94>)
    bc34:	9307      	str	r3, [sp, #28]
        result = get_pin_remaining_retries(loop + 1, &retries, &default_retries);
    bc36:	2717      	movs	r7, #23
    bc38:	2116      	movs	r1, #22
    bc3a:	446f      	add	r7, sp
    bc3c:	b2e0      	uxtb	r0, r4
    bc3e:	003a      	movs	r2, r7
    bc40:	4469      	add	r1, sp
    bc42:	f010 fcba 	bl	1c5ba <get_pin_remaining_retries>
    bc46:	1e06      	subs	r6, r0, #0
        if (result == NEUL_RET_OK)
    bc48:	d126      	bne.n	bc98 <at_handle_CPINR_cmd_exec+0x7c>
            if(first_flag)  //first reply need add "\r\n"
    bc4a:	2d00      	cmp	r5, #0
    bc4c:	d009      	beq.n	bc62 <at_handle_CPINR_cmd_exec+0x46>
                at_uart_claim();
    bc4e:	f7fd feab 	bl	99a8 <at_uart_claim>
                at_uart_write((uint8*)APP_AT_STR_RN, strlen(APP_AT_STR_RN));
    bc52:	4d18      	ldr	r5, [pc, #96]	; (bcb4 <at_handle_CPINR_cmd_exec+0x98>)
    bc54:	0028      	movs	r0, r5
    bc56:	f00f fba2 	bl	1b39e <strlen>
    bc5a:	0001      	movs	r1, r0
    bc5c:	0028      	movs	r0, r5
    bc5e:	f7fd fec5 	bl	99ec <at_uart_write>
            (void)snprintf(rsp_string, AT_MAX_CPINR_RESULT_RSP_LEN, "%s%s,%d,%d", AT_CMD_CPINR_PREFIX, str_table[loop], retries, default_retries);
    bc62:	783b      	ldrb	r3, [r7, #0]
    bc64:	aa0e      	add	r2, sp, #56	; 0x38
    bc66:	9302      	str	r3, [sp, #8]
    bc68:	2316      	movs	r3, #22
    bc6a:	446b      	add	r3, sp
    bc6c:	781b      	ldrb	r3, [r3, #0]
    bc6e:	2116      	movs	r1, #22
    bc70:	9301      	str	r3, [sp, #4]
    bc72:	00a3      	lsls	r3, r4, #2
    bc74:	18d3      	adds	r3, r2, r3
    bc76:	3b24      	subs	r3, #36	; 0x24
    bc78:	681b      	ldr	r3, [r3, #0]
    bc7a:	4a0f      	ldr	r2, [pc, #60]	; (bcb8 <at_handle_CPINR_cmd_exec+0x9c>)
    bc7c:	9300      	str	r3, [sp, #0]
    bc7e:	a808      	add	r0, sp, #32
    bc80:	4b0e      	ldr	r3, [pc, #56]	; (bcbc <at_handle_CPINR_cmd_exec+0xa0>)
    bc82:	f00e fdf3 	bl	1a86c <snprintf>
            app_at_send_at_rsp_string_rn_no_claim(rsp_string, AT_FLAG_LOGABLE | AT_FLAG_LOG_RESTRICTED);
    bc86:	2128      	movs	r1, #40	; 0x28
    bc88:	a808      	add	r0, sp, #32
    bc8a:	f7fd fcb9 	bl	9600 <app_at_send_at_rsp_string_rn_no_claim>
    bc8e:	2500      	movs	r5, #0
    for (loop = 0; loop < AT_CPINR_CODE_NUM; loop++)
    bc90:	2c02      	cmp	r4, #2
    bc92:	d003      	beq.n	bc9c <at_handle_CPINR_cmd_exec+0x80>
    bc94:	2402      	movs	r4, #2
    bc96:	e7ce      	b.n	bc36 <at_handle_CPINR_cmd_exec+0x1a>
    if (!first_flag)
    bc98:	2d00      	cmp	r5, #0
    bc9a:	d101      	bne.n	bca0 <at_handle_CPINR_cmd_exec+0x84>
        at_uart_release();
    bc9c:	f7fd fe96 	bl	99cc <at_uart_release>
    return at_parse_convert_neul_result(result);
    bca0:	0030      	movs	r0, r6
    bca2:	f7fe faf5 	bl	a290 <at_parse_convert_neul_result>
}
    bca6:	b00f      	add	sp, #60	; 0x3c
    bca8:	bdf0      	pop	{r4, r5, r6, r7, pc}
    bcaa:	46c0      	nop			; (mov r8, r8)
    bcac:	00024988 	.word	0x00024988
    bcb0:	00024990 	.word	0x00024990
    bcb4:	00022d8f 	.word	0x00022d8f
    bcb8:	000238d6 	.word	0x000238d6
    bcbc:	000238cd 	.word	0x000238cd

0000bcc0 <nxlog_output_response_to_at_uart_callback>:
{
    bcc0:	b570      	push	{r4, r5, r6, lr}
    bcc2:	000d      	movs	r5, r1
    bcc4:	0004      	movs	r4, r0
    at_uart_claim();
    bcc6:	f7fd fe6f 	bl	99a8 <at_uart_claim>
    at_uart_write((unsigned char*)at_string, len);
    bcca:	0029      	movs	r1, r5
    bccc:	0020      	movs	r0, r4
    bcce:	f7fd fe8d 	bl	99ec <at_uart_write>
    at_uart_release();
    bcd2:	f7fd fe7b 	bl	99cc <at_uart_release>
}
    bcd6:	bd70      	pop	{r4, r5, r6, pc}

0000bcd8 <at_handle_NCONFIG_cmd_test>:
{
    bcd8:	b570      	push	{r4, r5, r6, lr}
    bcda:	b092      	sub	sp, #72	; 0x48
    at_uart_claim();
    bcdc:	f7fd fe64 	bl	99a8 <at_uart_claim>
    at_uart_write((uint8*)APP_AT_STR_RN, strlen(APP_AT_STR_RN));
    bce0:	4c32      	ldr	r4, [pc, #200]	; (bdac <at_handle_NCONFIG_cmd_test+0xd4>)
            (void)snprintf(rsp_string, AT_MAX_NCONFIG_TEST_RSP_LEN, "%s(%s,(%d,%d))",
    bce2:	2502      	movs	r5, #2
    at_uart_write((uint8*)APP_AT_STR_RN, strlen(APP_AT_STR_RN));
    bce4:	0020      	movs	r0, r4
    bce6:	f00f fb5a 	bl	1b39e <strlen>
    bcea:	0001      	movs	r1, r0
    bcec:	0020      	movs	r0, r4
    bcee:	f7fd fe7d 	bl	99ec <at_uart_write>
    bcf2:	2400      	movs	r4, #0
            (void)snprintf(rsp_string, AT_MAX_NCONFIG_TEST_RSP_LEN, "%s(%s,(%d,%d))",
    bcf4:	2601      	movs	r6, #1
        memset(rsp_string, 0, AT_MAX_NCONFIG_TEST_RSP_LEN);
    bcf6:	2100      	movs	r1, #0
    bcf8:	2237      	movs	r2, #55	; 0x37
    bcfa:	a804      	add	r0, sp, #16
    bcfc:	f7f4 faf0 	bl	2e0 <memset>
    bd00:	b2e1      	uxtb	r1, r4
    bd02:	4b2b      	ldr	r3, [pc, #172]	; (bdb0 <at_handle_NCONFIG_cmd_test+0xd8>)
        if (function_loop == NEUL_BARRING_RELEASE_DELAY)
    bd04:	2c08      	cmp	r4, #8
    bd06:	d114      	bne.n	bd32 <at_handle_NCONFIG_cmd_test+0x5a>
            (void)snprintf(rsp_string, AT_MAX_NCONFIG_TEST_RSP_LEN, "%s(%s,(%s))",
    bd08:	2137      	movs	r1, #55	; 0x37
    bd0a:	4a2a      	ldr	r2, [pc, #168]	; (bdb4 <at_handle_NCONFIG_cmd_test+0xdc>)
    bd0c:	9201      	str	r2, [sp, #4]
    bd0e:	4a2a      	ldr	r2, [pc, #168]	; (bdb8 <at_handle_NCONFIG_cmd_test+0xe0>)
    bd10:	9200      	str	r2, [sp, #0]
    bd12:	4a2a      	ldr	r2, [pc, #168]	; (bdbc <at_handle_NCONFIG_cmd_test+0xe4>)
            (void)snprintf(rsp_string, AT_MAX_NCONFIG_TEST_RSP_LEN, "%s(%s,(%s))",
    bd14:	a804      	add	r0, sp, #16
    bd16:	f00e fda9 	bl	1a86c <snprintf>
        app_at_send_at_rsp_string_rn_no_claim(rsp_string, AT_FLAG_LOGABLE | AT_FLAG_LOG_RESTRICTED);
    bd1a:	2128      	movs	r1, #40	; 0x28
    bd1c:	a804      	add	r0, sp, #16
    bd1e:	3401      	adds	r4, #1
    bd20:	f7fd fc6e 	bl	9600 <app_at_send_at_rsp_string_rn_no_claim>
    for (function_loop = 0; function_loop < NEUL_NCONFIG_FUNCTION_NUM; function_loop++)
    bd24:	2c17      	cmp	r4, #23
    bd26:	d1e6      	bne.n	bcf6 <at_handle_NCONFIG_cmd_test+0x1e>
    at_uart_release();
    bd28:	f7fd fe50 	bl	99cc <at_uart_release>
}
    bd2c:	2000      	movs	r0, #0
    bd2e:	b012      	add	sp, #72	; 0x48
    bd30:	bd70      	pop	{r4, r5, r6, pc}
        else if (function_loop == NEUL_SYNC_TIME_PERIOD)
    bd32:	290b      	cmp	r1, #11
    bd34:	d106      	bne.n	bd44 <at_handle_NCONFIG_cmd_test+0x6c>
            (void)snprintf(rsp_string, AT_MAX_NCONFIG_TEST_RSP_LEN, "%s(%s,(%s))",
    bd36:	4a22      	ldr	r2, [pc, #136]	; (bdc0 <at_handle_NCONFIG_cmd_test+0xe8>)
    bd38:	312c      	adds	r1, #44	; 0x2c
    bd3a:	9201      	str	r2, [sp, #4]
    bd3c:	4a21      	ldr	r2, [pc, #132]	; (bdc4 <at_handle_NCONFIG_cmd_test+0xec>)
    bd3e:	9200      	str	r2, [sp, #0]
    bd40:	4a1e      	ldr	r2, [pc, #120]	; (bdbc <at_handle_NCONFIG_cmd_test+0xe4>)
    bd42:	e7e7      	b.n	bd14 <at_handle_NCONFIG_cmd_test+0x3c>
        else if (function_loop == NEUL_RELEASE_VERSION)
    bd44:	2909      	cmp	r1, #9
    bd46:	d10b      	bne.n	bd60 <at_handle_NCONFIG_cmd_test+0x88>
            (void)snprintf(rsp_string, AT_MAX_NCONFIG_TEST_RSP_LEN, "%s(%s,(%d,%d))",
    bd48:	220e      	movs	r2, #14
    bd4a:	9202      	str	r2, [sp, #8]
    bd4c:	3a01      	subs	r2, #1
    bd4e:	9201      	str	r2, [sp, #4]
    bd50:	4a1d      	ldr	r2, [pc, #116]	; (bdc8 <at_handle_NCONFIG_cmd_test+0xf0>)
    bd52:	312e      	adds	r1, #46	; 0x2e
    bd54:	9200      	str	r2, [sp, #0]
    bd56:	4a1d      	ldr	r2, [pc, #116]	; (bdcc <at_handle_NCONFIG_cmd_test+0xf4>)
            (void)snprintf(rsp_string, AT_MAX_NCONFIG_TEST_RSP_LEN, "%s(%s,(%s,%s))",
    bd58:	a804      	add	r0, sp, #16
    bd5a:	f00e fd87 	bl	1a86c <snprintf>
    bd5e:	e7dc      	b.n	bd1a <at_handle_NCONFIG_cmd_test+0x42>
        else if (function_loop == NEUL_IPV6_GET_PREFIX_TIME)
    bd60:	290c      	cmp	r1, #12
    bd62:	d106      	bne.n	bd72 <at_handle_NCONFIG_cmd_test+0x9a>
            (void)snprintf(rsp_string, AT_MAX_NCONFIG_TEST_RSP_LEN, "%s(%s,(%s))",
    bd64:	4a16      	ldr	r2, [pc, #88]	; (bdc0 <at_handle_NCONFIG_cmd_test+0xe8>)
    bd66:	312b      	adds	r1, #43	; 0x2b
    bd68:	9201      	str	r2, [sp, #4]
    bd6a:	4a19      	ldr	r2, [pc, #100]	; (bdd0 <at_handle_NCONFIG_cmd_test+0xf8>)
    bd6c:	9200      	str	r2, [sp, #0]
    bd6e:	4a13      	ldr	r2, [pc, #76]	; (bdbc <at_handle_NCONFIG_cmd_test+0xe4>)
    bd70:	e7d0      	b.n	bd14 <at_handle_NCONFIG_cmd_test+0x3c>
        else if (function_loop == NEUL_NB_CATEGORY)
    bd72:	290d      	cmp	r1, #13
    bd74:	d106      	bne.n	bd84 <at_handle_NCONFIG_cmd_test+0xac>
            (void)snprintf(rsp_string, AT_MAX_NCONFIG_TEST_RSP_LEN, "%s(%s,(%d,%d))",
    bd76:	4a17      	ldr	r2, [pc, #92]	; (bdd4 <at_handle_NCONFIG_cmd_test+0xfc>)
    bd78:	9502      	str	r5, [sp, #8]
    bd7a:	9200      	str	r2, [sp, #0]
    bd7c:	9601      	str	r6, [sp, #4]
    bd7e:	4a13      	ldr	r2, [pc, #76]	; (bdcc <at_handle_NCONFIG_cmd_test+0xf4>)
    bd80:	312a      	adds	r1, #42	; 0x2a
    bd82:	e7e9      	b.n	bd58 <at_handle_NCONFIG_cmd_test+0x80>
    bd84:	4a14      	ldr	r2, [pc, #80]	; (bdd8 <at_handle_NCONFIG_cmd_test+0x100>)
        else if (function_loop == NEUL_PCO_TYPE)
    bd86:	2913      	cmp	r1, #19
    bd88:	d107      	bne.n	bd9a <at_handle_NCONFIG_cmd_test+0xc2>
            (void)snprintf(rsp_string, AT_MAX_NCONFIG_TEST_RSP_LEN, "%s(%s,(%s,%s))",
    bd8a:	4914      	ldr	r1, [pc, #80]	; (bddc <at_handle_NCONFIG_cmd_test+0x104>)
    bd8c:	9102      	str	r1, [sp, #8]
    bd8e:	4914      	ldr	r1, [pc, #80]	; (bde0 <at_handle_NCONFIG_cmd_test+0x108>)
    bd90:	9101      	str	r1, [sp, #4]
    bd92:	4914      	ldr	r1, [pc, #80]	; (bde4 <at_handle_NCONFIG_cmd_test+0x10c>)
            (void)snprintf(rsp_string, AT_MAX_NCONFIG_TEST_RSP_LEN, "%s(%s,(%s,%s))",
    bd94:	9100      	str	r1, [sp, #0]
    bd96:	2137      	movs	r1, #55	; 0x37
    bd98:	e7de      	b.n	bd58 <at_handle_NCONFIG_cmd_test+0x80>
    bd9a:	4913      	ldr	r1, [pc, #76]	; (bde8 <at_handle_NCONFIG_cmd_test+0x110>)
    bd9c:	00a0      	lsls	r0, r4, #2
    bd9e:	9102      	str	r1, [sp, #8]
    bda0:	4912      	ldr	r1, [pc, #72]	; (bdec <at_handle_NCONFIG_cmd_test+0x114>)
    bda2:	9101      	str	r1, [sp, #4]
    bda4:	4912      	ldr	r1, [pc, #72]	; (bdf0 <at_handle_NCONFIG_cmd_test+0x118>)
    bda6:	5841      	ldr	r1, [r0, r1]
    bda8:	e7f4      	b.n	bd94 <at_handle_NCONFIG_cmd_test+0xbc>
    bdaa:	46c0      	nop			; (mov r8, r8)
    bdac:	00022d8f 	.word	0x00022d8f
    bdb0:	00023af4 	.word	0x00023af4
    bdb4:	00023b0a 	.word	0x00023b0a
    bdb8:	00023b11 	.word	0x00023b11
    bdbc:	00023afe 	.word	0x00023afe
    bdc0:	00023b27 	.word	0x00023b27
    bdc4:	00023b2f 	.word	0x00023b2f
    bdc8:	00023b4f 	.word	0x00023b4f
    bdcc:	00023b40 	.word	0x00023b40
    bdd0:	00023b5f 	.word	0x00023b5f
    bdd4:	00023b74 	.word	0x00023b74
    bdd8:	00023b80 	.word	0x00023b80
    bddc:	00023b8f 	.word	0x00023b8f
    bde0:	00023b90 	.word	0x00023b90
    bde4:	00023b94 	.word	0x00023b94
    bde8:	00023ba0 	.word	0x00023ba0
    bdec:	00023ba5 	.word	0x00023ba5
    bdf0:	00024818 	.word	0x00024818

0000bdf4 <at_handle_CPINR_cmd_set>:
{
    bdf4:	b5f0      	push	{r4, r5, r6, r7, lr}
    bdf6:	b08f      	sub	sp, #60	; 0x3c
    bdf8:	0004      	movs	r4, r0
    uint8               str_code[AT_MAX_CPINR_CODE_LEN]   = {0};
    bdfa:	2208      	movs	r2, #8
    bdfc:	2100      	movs	r1, #0
    bdfe:	a806      	add	r0, sp, #24
    be00:	f7f4 fa6e 	bl	2e0 <memset>
    char                rsp_string[AT_MAX_CPINR_RESULT_RSP_LEN]   = {0};
    be04:	2216      	movs	r2, #22
    be06:	2100      	movs	r1, #0
    be08:	a808      	add	r0, sp, #32
    be0a:	f7f4 fa69 	bl	2e0 <memset>
    if (at_create_param_array(p_atparams_string, &num_recvparams, 1, 1) != AT_RET_OK)
    be0e:	2301      	movs	r3, #1
    be10:	2115      	movs	r1, #21
    be12:	001a      	movs	r2, r3
    be14:	4469      	add	r1, sp
    be16:	0020      	movs	r0, r4
    be18:	f7fe fa64 	bl	a2e4 <at_create_param_array>
    be1c:	2800      	cmp	r0, #0
    be1e:	d002      	beq.n	be26 <at_handle_CPINR_cmd_set+0x32>
       return AT_RET_SYNTAX_ERROR;
    be20:	2001      	movs	r0, #1
}
    be22:	b00f      	add	sp, #60	; 0x3c
    be24:	bdf0      	pop	{r4, r5, r6, r7, pc}
    if (at_get_string_param(AT_PARSE_FIRST_PARAM_POS, str_code, AT_MAX_CPINR_CODE_LEN, true) != AT_RET_OK)
    be26:	2301      	movs	r3, #1
    be28:	2208      	movs	r2, #8
    be2a:	a906      	add	r1, sp, #24
    be2c:	f7fe fcac 	bl	a788 <at_get_string_param>
    be30:	2800      	cmp	r0, #0
    be32:	d1f5      	bne.n	be20 <at_handle_CPINR_cmd_set+0x2c>
        if (at_strcmp(str_code, str_table[loop]) == 0)
    be34:	4c15      	ldr	r4, [pc, #84]	; (be8c <at_handle_CPINR_cmd_set+0x98>)
    be36:	a806      	add	r0, sp, #24
    be38:	0021      	movs	r1, r4
    be3a:	f00f fa91 	bl	1b360 <strcmp>
    be3e:	2800      	cmp	r0, #0
    be40:	d007      	beq.n	be52 <at_handle_CPINR_cmd_set+0x5e>
    be42:	4c13      	ldr	r4, [pc, #76]	; (be90 <at_handle_CPINR_cmd_set+0x9c>)
    be44:	a806      	add	r0, sp, #24
    be46:	0021      	movs	r1, r4
    be48:	f00f fa8a 	bl	1b360 <strcmp>
    be4c:	2800      	cmp	r0, #0
    be4e:	d1e7      	bne.n	be20 <at_handle_CPINR_cmd_set+0x2c>
    for (loop = 0; loop < AT_CPINR_CODE_NUM; loop++)
    be50:	3001      	adds	r0, #1
            result = get_pin_remaining_retries(loop + 1, &retries, &default_retries);
    be52:	2617      	movs	r6, #23
    be54:	2516      	movs	r5, #22
    be56:	446e      	add	r6, sp
    be58:	446d      	add	r5, sp
    be5a:	3001      	adds	r0, #1
    be5c:	0032      	movs	r2, r6
    be5e:	0029      	movs	r1, r5
    be60:	f010 fbab 	bl	1c5ba <get_pin_remaining_retries>
    be64:	1e07      	subs	r7, r0, #0
            if (result == NEUL_RET_OK)
    be66:	d10d      	bne.n	be84 <at_handle_CPINR_cmd_set+0x90>
                (void)snprintf(rsp_string, AT_MAX_CPINR_RESULT_RSP_LEN, "%s%s,%d,%d", AT_CMD_CPINR_PREFIX, str_table[loop], retries, default_retries);
    be68:	7833      	ldrb	r3, [r6, #0]
    be6a:	4a0a      	ldr	r2, [pc, #40]	; (be94 <at_handle_CPINR_cmd_set+0xa0>)
    be6c:	9302      	str	r3, [sp, #8]
    be6e:	782b      	ldrb	r3, [r5, #0]
    be70:	2116      	movs	r1, #22
    be72:	9301      	str	r3, [sp, #4]
    be74:	9400      	str	r4, [sp, #0]
    be76:	4b08      	ldr	r3, [pc, #32]	; (be98 <at_handle_CPINR_cmd_set+0xa4>)
    be78:	a808      	add	r0, sp, #32
    be7a:	f00e fcf7 	bl	1a86c <snprintf>
                app_at_send_at_rsp_string_lines_with_claim_and_log(rsp_string);
    be7e:	a808      	add	r0, sp, #32
    be80:	f7fd fbb0 	bl	95e4 <app_at_send_at_rsp_string_lines_with_claim_and_log>
            return at_parse_convert_neul_result(result);
    be84:	0038      	movs	r0, r7
    be86:	f7fe fa03 	bl	a290 <at_parse_convert_neul_result>
    be8a:	e7ca      	b.n	be22 <at_handle_CPINR_cmd_set+0x2e>
    be8c:	00024988 	.word	0x00024988
    be90:	00024990 	.word	0x00024990
    be94:	000238d6 	.word	0x000238d6
    be98:	000238cd 	.word	0x000238cd

0000be9c <at_handle_CPIN_cmd_read>:
{
    be9c:	b570      	push	{r4, r5, r6, lr}
    be9e:	b08e      	sub	sp, #56	; 0x38
    char             rsp_string[AT_MAX_CPIN_RESULT_RSP_LEN]    = {0};
    bea0:	2100      	movs	r1, #0
    bea2:	2217      	movs	r2, #23
    bea4:	a808      	add	r0, sp, #32
    const char      *str_table[4] = {"READY", "SIM PIN", "SIM PUK", "SIM PUK BLOCKED"};
    bea6:	ac04      	add	r4, sp, #16
    char             rsp_string[AT_MAX_CPIN_RESULT_RSP_LEN]    = {0};
    bea8:	f7f4 fa1a 	bl	2e0 <memset>
    const char      *str_table[4] = {"READY", "SIM PIN", "SIM PUK", "SIM PUK BLOCKED"};
    beac:	0022      	movs	r2, r4
    result = get_pin_state(&state);
    beae:	260f      	movs	r6, #15
    const char      *str_table[4] = {"READY", "SIM PIN", "SIM PUK", "SIM PUK BLOCKED"};
    beb0:	4b0e      	ldr	r3, [pc, #56]	; (beec <at_handle_CPIN_cmd_read+0x50>)
    result = get_pin_state(&state);
    beb2:	446e      	add	r6, sp
    const char      *str_table[4] = {"READY", "SIM PIN", "SIM PUK", "SIM PUK BLOCKED"};
    beb4:	3334      	adds	r3, #52	; 0x34
    beb6:	cb23      	ldmia	r3!, {r0, r1, r5}
    beb8:	c223      	stmia	r2!, {r0, r1, r5}
    beba:	681b      	ldr	r3, [r3, #0]
    result = get_pin_state(&state);
    bebc:	0030      	movs	r0, r6
    const char      *str_table[4] = {"READY", "SIM PIN", "SIM PUK", "SIM PUK BLOCKED"};
    bebe:	6013      	str	r3, [r2, #0]
    result = get_pin_state(&state);
    bec0:	f010 fb6c 	bl	1c59c <get_pin_state>
    bec4:	1e05      	subs	r5, r0, #0
    if (result == NEUL_RET_OK)
    bec6:	d10c      	bne.n	bee2 <at_handle_CPIN_cmd_read+0x46>
        (void)snprintf(rsp_string, AT_MAX_CPIN_RESULT_RSP_LEN, "%s%s", AT_CMD_CPIN_PREFIX, str_table[state]);
    bec8:	7833      	ldrb	r3, [r6, #0]
    beca:	4a09      	ldr	r2, [pc, #36]	; (bef0 <at_handle_CPIN_cmd_read+0x54>)
    becc:	009b      	lsls	r3, r3, #2
    bece:	591b      	ldr	r3, [r3, r4]
    bed0:	2117      	movs	r1, #23
    bed2:	9300      	str	r3, [sp, #0]
    bed4:	a808      	add	r0, sp, #32
    bed6:	4b07      	ldr	r3, [pc, #28]	; (bef4 <at_handle_CPIN_cmd_read+0x58>)
    bed8:	f00e fcc8 	bl	1a86c <snprintf>
        app_at_send_at_rsp_string_lines_with_claim_and_log(rsp_string);
    bedc:	a808      	add	r0, sp, #32
    bede:	f7fd fb81 	bl	95e4 <app_at_send_at_rsp_string_lines_with_claim_and_log>
    return at_parse_convert_neul_result(result);
    bee2:	0028      	movs	r0, r5
    bee4:	f7fe f9d4 	bl	a290 <at_parse_convert_neul_result>
}
    bee8:	b00e      	add	sp, #56	; 0x38
    beea:	bd70      	pop	{r4, r5, r6, pc}
    beec:	000229f8 	.word	0x000229f8
    bef0:	000238e9 	.word	0x000238e9
    bef4:	000238e1 	.word	0x000238e1

0000bef8 <at_handle_CPIN_cmd_set>:
{
    bef8:	b5f0      	push	{r4, r5, r6, r7, lr}
    befa:	0004      	movs	r4, r0
    befc:	b08b      	sub	sp, #44	; 0x2c
    uint8    pin1_str[9] = {0};
    befe:	ad04      	add	r5, sp, #16
    bf00:	2209      	movs	r2, #9
    bf02:	2100      	movs	r1, #0
    bf04:	0028      	movs	r0, r5
    uint8    pin2_str[9] = {0};
    bf06:	ae07      	add	r6, sp, #28
    uint8    pin1_str[9] = {0};
    bf08:	f7f4 f9ea 	bl	2e0 <memset>
    uint8    pin2_str[9] = {0};
    bf0c:	2209      	movs	r2, #9
    bf0e:	2100      	movs	r1, #0
    bf10:	0030      	movs	r0, r6
    bf12:	f7f4 f9e5 	bl	2e0 <memset>
    cause = at_create_param_array(p_atparams_string, &num_recvparams, 1, 2);
    bf16:	a902      	add	r1, sp, #8
    bf18:	2302      	movs	r3, #2
    bf1a:	2201      	movs	r2, #1
    bf1c:	3107      	adds	r1, #7
    bf1e:	0020      	movs	r0, r4
    bf20:	f7fe f9e0 	bl	a2e4 <at_create_param_array>
    if(cause != AT_RET_OK)
    bf24:	2800      	cmp	r0, #0
    bf26:	d10b      	bne.n	bf40 <at_handle_CPIN_cmd_set+0x48>
    cause = at_get_string_param(AT_PARSE_FIRST_PARAM_POS, pin1_str, AT_MAX_PIN_LEN, true);
    bf28:	2301      	movs	r3, #1
    bf2a:	2209      	movs	r2, #9
    bf2c:	0029      	movs	r1, r5
    bf2e:	f7fe fc2b 	bl	a788 <at_get_string_param>
    bf32:	0004      	movs	r4, r0
    pin_len = (uint8)strlen((char*)pin1_str);
    bf34:	0028      	movs	r0, r5
    bf36:	f00f fa32 	bl	1b39e <strlen>
    if((cause != AT_RET_OK) ||  (pin_len < AT_MIN_PIN_LEN))
    bf3a:	2c00      	cmp	r4, #0
    bf3c:	d002      	beq.n	bf44 <at_handle_CPIN_cmd_set+0x4c>
        return AT_RET_SYNTAX_ERROR;
    bf3e:	2001      	movs	r0, #1
}
    bf40:	b00b      	add	sp, #44	; 0x2c
    bf42:	bdf0      	pop	{r4, r5, r6, r7, pc}
    pin_len = (uint8)strlen((char*)pin1_str);
    bf44:	b2c3      	uxtb	r3, r0
    bf46:	9301      	str	r3, [sp, #4]
    if((cause != AT_RET_OK) ||  (pin_len < AT_MIN_PIN_LEN))
    bf48:	2b03      	cmp	r3, #3
    bf4a:	d9f8      	bls.n	bf3e <at_handle_CPIN_cmd_set+0x46>
        if (!isdigit(pin1_str[i]))      //lint !e866
    bf4c:	2104      	movs	r1, #4
    bf4e:	4f1e      	ldr	r7, [pc, #120]	; (bfc8 <at_handle_CPIN_cmd_set+0xd0>)
    bf50:	683a      	ldr	r2, [r7, #0]
    bf52:	5d2b      	ldrb	r3, [r5, r4]
    bf54:	18d3      	adds	r3, r2, r3
    bf56:	785b      	ldrb	r3, [r3, #1]
    bf58:	420b      	tst	r3, r1
    bf5a:	d0f0      	beq.n	bf3e <at_handle_CPIN_cmd_set+0x46>
    bf5c:	3401      	adds	r4, #1
    for (i=0; i< pin_len; i++)
    bf5e:	9801      	ldr	r0, [sp, #4]
    bf60:	b2e3      	uxtb	r3, r4
    bf62:	4298      	cmp	r0, r3
    bf64:	d8f5      	bhi.n	bf52 <at_handle_CPIN_cmd_set+0x5a>
    cause = at_get_string_param(AT_PARSE_SECOND_PARAM_POS, pin2_str, AT_MAX_PIN_LEN, true);
    bf66:	2301      	movs	r3, #1
    bf68:	2209      	movs	r2, #9
    bf6a:	0031      	movs	r1, r6
    bf6c:	0018      	movs	r0, r3
    bf6e:	f7fe fc0b 	bl	a788 <at_get_string_param>
    bf72:	0004      	movs	r4, r0
    if(cause != AT_RET_PARAM_MISSING)
    bf74:	2803      	cmp	r0, #3
    bf76:	d024      	beq.n	bfc2 <at_handle_CPIN_cmd_set+0xca>
        if (pin_len != AT_PUK_LEN)
    bf78:	9b01      	ldr	r3, [sp, #4]
    bf7a:	2b08      	cmp	r3, #8
    bf7c:	d1df      	bne.n	bf3e <at_handle_CPIN_cmd_set+0x46>
        pin_len = (uint8)strlen((char*)pin2_str);
    bf7e:	0030      	movs	r0, r6
    bf80:	f00f fa0d 	bl	1b39e <strlen>
        if((cause != AT_RET_OK) ||  (pin_len < AT_MIN_PIN_LEN))
    bf84:	2c00      	cmp	r4, #0
    bf86:	d1da      	bne.n	bf3e <at_handle_CPIN_cmd_set+0x46>
        pin_len = (uint8)strlen((char*)pin2_str);
    bf88:	b2c0      	uxtb	r0, r0
        if((cause != AT_RET_OK) ||  (pin_len < AT_MIN_PIN_LEN))
    bf8a:	2803      	cmp	r0, #3
    bf8c:	d9d7      	bls.n	bf3e <at_handle_CPIN_cmd_set+0x46>
            if (!isdigit(pin2_str[i]))      //lint !e866
    bf8e:	2104      	movs	r1, #4
    bf90:	683a      	ldr	r2, [r7, #0]
    bf92:	5d33      	ldrb	r3, [r6, r4]
    bf94:	18d3      	adds	r3, r2, r3
    bf96:	785b      	ldrb	r3, [r3, #1]
    bf98:	420b      	tst	r3, r1
    bf9a:	d0d0      	beq.n	bf3e <at_handle_CPIN_cmd_set+0x46>
    bf9c:	3401      	adds	r4, #1
        for (i=0; i< pin_len; i++)
    bf9e:	b2e3      	uxtb	r3, r4
    bfa0:	4298      	cmp	r0, r3
    bfa2:	d8f6      	bhi.n	bf92 <at_handle_CPIN_cmd_set+0x9a>
        command = PIN_COMMAND_UNBLOCK;
    bfa4:	2004      	movs	r0, #4
    neul_result = pin_command((uint8)command, pin1_str, pin2_str, cpin_result_callback);
    bfa6:	4b09      	ldr	r3, [pc, #36]	; (bfcc <at_handle_CPIN_cmd_set+0xd4>)
    bfa8:	b2c0      	uxtb	r0, r0
    bfaa:	0032      	movs	r2, r6
    bfac:	0029      	movs	r1, r5
    bfae:	f010 fae1 	bl	1c574 <pin_command>
    bfb2:	0003      	movs	r3, r0
        cause = AT_RET_CMD_IN_PROGRESS_BLOCK;
    bfb4:	2009      	movs	r0, #9
    if (neul_result == NEUL_RET_OK)
    bfb6:	2b00      	cmp	r3, #0
    bfb8:	d0c2      	beq.n	bf40 <at_handle_CPIN_cmd_set+0x48>
        cause = at_parse_convert_neul_result(neul_result);
    bfba:	0018      	movs	r0, r3
    bfbc:	f7fe f968 	bl	a290 <at_parse_convert_neul_result>
    bfc0:	e7be      	b.n	bf40 <at_handle_CPIN_cmd_set+0x48>
    command = PIN_COMMAND_VERIFY;
    bfc2:	2000      	movs	r0, #0
    bfc4:	e7ef      	b.n	bfa6 <at_handle_CPIN_cmd_set+0xae>
    bfc6:	46c0      	nop			; (mov r8, r8)
    bfc8:	010005dc 	.word	0x010005dc
    bfcc:	0000c0d1 	.word	0x0000c0d1

0000bfd0 <at_handle_NPIN_cmd_set>:
{
    bfd0:	b5f0      	push	{r4, r5, r6, r7, lr}
    bfd2:	0007      	movs	r7, r0
    bfd4:	b08b      	sub	sp, #44	; 0x2c
    uint8    pin1_str[9] = {0};
    bfd6:	ad04      	add	r5, sp, #16
    bfd8:	2209      	movs	r2, #9
    bfda:	2100      	movs	r1, #0
    bfdc:	0028      	movs	r0, r5
    uint8    pin2_str[9] = {0};
    bfde:	ae07      	add	r6, sp, #28
    uint8    pin1_str[9] = {0};
    bfe0:	f7f4 f97e 	bl	2e0 <memset>
    uint8    pin2_str[9] = {0};
    bfe4:	2209      	movs	r2, #9
    bfe6:	2100      	movs	r1, #0
    bfe8:	0030      	movs	r0, r6
    bfea:	f7f4 f979 	bl	2e0 <memset>
    cause = at_create_param_array(p_atparams_string, &num_recvparams, 2, 3);
    bfee:	ab02      	add	r3, sp, #8
    bff0:	1d5c      	adds	r4, r3, #5
    bff2:	2202      	movs	r2, #2
    bff4:	2303      	movs	r3, #3
    bff6:	0021      	movs	r1, r4
    bff8:	0038      	movs	r0, r7
    bffa:	f7fe f973 	bl	a2e4 <at_create_param_array>
    if(cause != AT_RET_OK)
    bffe:	2800      	cmp	r0, #0
    c000:	d108      	bne.n	c014 <at_handle_NPIN_cmd_set+0x44>
    cause = at_get_uint16_param(AT_PARSE_FIRST_PARAM_POS, &command, true);
    c002:	ab02      	add	r3, sp, #8
    c004:	1d9f      	adds	r7, r3, #6
    c006:	2201      	movs	r2, #1
    c008:	0039      	movs	r1, r7
    c00a:	f7fe fa7f 	bl	a50c <at_get_uint16_param>
    if((cause != AT_RET_OK) || (command > PIN_COMMAND_UNBLOCK) ||
    c00e:	2800      	cmp	r0, #0
    c010:	d002      	beq.n	c018 <at_handle_NPIN_cmd_set+0x48>
        return AT_RET_SYNTAX_ERROR;
    c012:	2001      	movs	r0, #1
}
    c014:	b00b      	add	sp, #44	; 0x2c
    c016:	bdf0      	pop	{r4, r5, r6, r7, pc}
    if((cause != AT_RET_OK) || (command > PIN_COMMAND_UNBLOCK) ||
    c018:	883b      	ldrh	r3, [r7, #0]
    c01a:	2b04      	cmp	r3, #4
    c01c:	d8f9      	bhi.n	c012 <at_handle_NPIN_cmd_set+0x42>
    c01e:	2b01      	cmp	r3, #1
    c020:	d001      	beq.n	c026 <at_handle_NPIN_cmd_set+0x56>
       (((command == PIN_COMMAND_CHANGE) || (command == PIN_COMMAND_UNBLOCK)) && (num_recvparams < 3)))
    c022:	2b04      	cmp	r3, #4
    c024:	d102      	bne.n	c02c <at_handle_NPIN_cmd_set+0x5c>
    c026:	7823      	ldrb	r3, [r4, #0]
    c028:	2b02      	cmp	r3, #2
    c02a:	d9f2      	bls.n	c012 <at_handle_NPIN_cmd_set+0x42>
    cause = at_get_string_param(AT_PARSE_SECOND_PARAM_POS, pin1_str, AT_MAX_PIN_LEN, true);
    c02c:	2301      	movs	r3, #1
    c02e:	2209      	movs	r2, #9
    c030:	0029      	movs	r1, r5
    c032:	0018      	movs	r0, r3
    c034:	f7fe fba8 	bl	a788 <at_get_string_param>
    c038:	0004      	movs	r4, r0
    pin_len = (uint8)strlen((char*)pin1_str);
    c03a:	0028      	movs	r0, r5
    c03c:	f00f f9af 	bl	1b39e <strlen>
    if((cause != AT_RET_OK) ||  (pin_len < AT_MIN_PIN_LEN) || ((command == PIN_COMMAND_UNBLOCK) && (pin_len != AT_PUK_LEN)))
    c040:	2c00      	cmp	r4, #0
    c042:	d1e6      	bne.n	c012 <at_handle_NPIN_cmd_set+0x42>
    pin_len = (uint8)strlen((char*)pin1_str);
    c044:	b2c0      	uxtb	r0, r0
    if((cause != AT_RET_OK) ||  (pin_len < AT_MIN_PIN_LEN) || ((command == PIN_COMMAND_UNBLOCK) && (pin_len != AT_PUK_LEN)))
    c046:	2803      	cmp	r0, #3
    c048:	d9e3      	bls.n	c012 <at_handle_NPIN_cmd_set+0x42>
    c04a:	883a      	ldrh	r2, [r7, #0]
    c04c:	2a04      	cmp	r2, #4
    c04e:	d101      	bne.n	c054 <at_handle_NPIN_cmd_set+0x84>
    c050:	2808      	cmp	r0, #8
    c052:	d1de      	bne.n	c012 <at_handle_NPIN_cmd_set+0x42>
        if (!isdigit(pin1_str[i]))      //lint !e866
    c054:	2104      	movs	r1, #4
    c056:	4b1c      	ldr	r3, [pc, #112]	; (c0c8 <at_handle_NPIN_cmd_set+0xf8>)
    c058:	468c      	mov	ip, r1
    c05a:	681b      	ldr	r3, [r3, #0]
    c05c:	9301      	str	r3, [sp, #4]
    c05e:	2300      	movs	r3, #0
    c060:	9c01      	ldr	r4, [sp, #4]
    c062:	5ce9      	ldrb	r1, [r5, r3]
    c064:	1861      	adds	r1, r4, r1
    c066:	4664      	mov	r4, ip
    c068:	7849      	ldrb	r1, [r1, #1]
    c06a:	4221      	tst	r1, r4
    c06c:	d0d1      	beq.n	c012 <at_handle_NPIN_cmd_set+0x42>
    c06e:	3301      	adds	r3, #1
    for (i=0; i< pin_len; i++)
    c070:	b2d9      	uxtb	r1, r3
    c072:	4288      	cmp	r0, r1
    c074:	d8f4      	bhi.n	c060 <at_handle_NPIN_cmd_set+0x90>
    if ((command == PIN_COMMAND_CHANGE) || (command == PIN_COMMAND_UNBLOCK))
    c076:	2a01      	cmp	r2, #1
    c078:	d001      	beq.n	c07e <at_handle_NPIN_cmd_set+0xae>
    c07a:	2a04      	cmp	r2, #4
    c07c:	d11a      	bne.n	c0b4 <at_handle_NPIN_cmd_set+0xe4>
        cause = at_get_string_param(AT_PARSE_THIRD_PARAM_POS, pin2_str, AT_MAX_PIN_LEN, true);
    c07e:	2301      	movs	r3, #1
    c080:	2209      	movs	r2, #9
    c082:	0031      	movs	r1, r6
    c084:	2002      	movs	r0, #2
    c086:	f7fe fb7f 	bl	a788 <at_get_string_param>
    c08a:	0004      	movs	r4, r0
        pin_len = (uint8)strlen((char*)pin2_str);
    c08c:	0030      	movs	r0, r6
    c08e:	f00f f986 	bl	1b39e <strlen>
        if((cause != AT_RET_OK) ||  (pin_len < AT_MIN_PIN_LEN))
    c092:	2c00      	cmp	r4, #0
    c094:	d1bd      	bne.n	c012 <at_handle_NPIN_cmd_set+0x42>
        pin_len = (uint8)strlen((char*)pin2_str);
    c096:	b2c0      	uxtb	r0, r0
        if((cause != AT_RET_OK) ||  (pin_len < AT_MIN_PIN_LEN))
    c098:	2803      	cmp	r0, #3
    c09a:	d9ba      	bls.n	c012 <at_handle_NPIN_cmd_set+0x42>
            if (!isdigit(pin2_str[i]))      //lint !e866
    c09c:	2104      	movs	r1, #4
    c09e:	4b0a      	ldr	r3, [pc, #40]	; (c0c8 <at_handle_NPIN_cmd_set+0xf8>)
    c0a0:	681a      	ldr	r2, [r3, #0]
    c0a2:	5d33      	ldrb	r3, [r6, r4]
    c0a4:	18d3      	adds	r3, r2, r3
    c0a6:	785b      	ldrb	r3, [r3, #1]
    c0a8:	420b      	tst	r3, r1
    c0aa:	d0b2      	beq.n	c012 <at_handle_NPIN_cmd_set+0x42>
    c0ac:	3401      	adds	r4, #1
        for (i=0; i< pin_len; i++)
    c0ae:	b2e3      	uxtb	r3, r4
    c0b0:	4298      	cmp	r0, r3
    c0b2:	d8f6      	bhi.n	c0a2 <at_handle_NPIN_cmd_set+0xd2>
    neul_result = pin_command((uint8)command, pin1_str, pin2_str, npin_result_callback);
    c0b4:	4b05      	ldr	r3, [pc, #20]	; (c0cc <at_handle_NPIN_cmd_set+0xfc>)
    c0b6:	0032      	movs	r2, r6
    c0b8:	0029      	movs	r1, r5
    c0ba:	7838      	ldrb	r0, [r7, #0]
    c0bc:	f010 fa5a 	bl	1c574 <pin_command>
    return at_parse_convert_neul_result(neul_result);
    c0c0:	f7fe f8e6 	bl	a290 <at_parse_convert_neul_result>
    c0c4:	e7a6      	b.n	c014 <at_handle_NPIN_cmd_set+0x44>
    c0c6:	46c0      	nop			; (mov r8, r8)
    c0c8:	010005dc 	.word	0x010005dc
    c0cc:	0000adcd 	.word	0x0000adcd

0000c0d0 <cpin_result_callback>:
{
    c0d0:	b510      	push	{r4, lr}
    c0d2:	2306      	movs	r3, #6
    c0d4:	280a      	cmp	r0, #10
    c0d6:	d801      	bhi.n	c0dc <cpin_result_callback+0xc>
    c0d8:	4b02      	ldr	r3, [pc, #8]	; (c0e4 <cpin_result_callback+0x14>)
    c0da:	5c1b      	ldrb	r3, [r3, r0]
    app_at_send_callback_response(ret);
    c0dc:	0018      	movs	r0, r3
    c0de:	f7fc f9f3 	bl	84c8 <app_at_send_callback_response>
}
    c0e2:	bd10      	pop	{r4, pc}
    c0e4:	000234c9 	.word	0x000234c9

0000c0e8 <modify_pdp_callback>:
{
    c0e8:	b510      	push	{r4, lr}
    app_at_send_callback_response(at_parse_convert_neul_result(result));
    c0ea:	f7fe f8d1 	bl	a290 <at_parse_convert_neul_result>
    c0ee:	f7fc f9eb 	bl	84c8 <app_at_send_callback_response>
}
    c0f2:	bd10      	pop	{r4, pc}

0000c0f4 <cfun_result_callback>:
{
    c0f4:	b510      	push	{r4, lr}
            ret = AT_RET_SIM_PIN_REQUIRED;
    c0f6:	2315      	movs	r3, #21
    switch(result)
    c0f8:	2816      	cmp	r0, #22
    c0fa:	d00b      	beq.n	c114 <cfun_result_callback+0x20>
    c0fc:	d804      	bhi.n	c108 <cfun_result_callback+0x14>
            ret = AT_RET_OK;
    c0fe:	2300      	movs	r3, #0
    switch(result)
    c100:	4298      	cmp	r0, r3
    c102:	d007      	beq.n	c114 <cfun_result_callback+0x20>
            ret = AT_RET_PROGRESS_ERROR;
    c104:	2306      	movs	r3, #6
            break;
    c106:	e005      	b.n	c114 <cfun_result_callback+0x20>
            ret = AT_RET_SIM_PUK_REQUIRED;
    c108:	232a      	movs	r3, #42	; 0x2a
    switch(result)
    c10a:	2827      	cmp	r0, #39	; 0x27
    c10c:	d002      	beq.n	c114 <cfun_result_callback+0x20>
            ret = AT_RET_SIM_PUK_BLOCKED;
    c10e:	3302      	adds	r3, #2
    switch(result)
    c110:	2828      	cmp	r0, #40	; 0x28
    c112:	d1f7      	bne.n	c104 <cfun_result_callback+0x10>
    app_at_send_callback_response(ret);
    c114:	0018      	movs	r0, r3
    c116:	f7fc f9d7 	bl	84c8 <app_at_send_callback_response>
}
    c11a:	bd10      	pop	{r4, pc}

0000c11c <at_handle_CGTFT_cmd_test>:
    char *pdn_type_str[AT_CMD_CGTFT_PDN_TYPES] = {"\"IP\"", "\"NONIP\"", "\"IPV6\"", "\"IPV4V6\""};
    c11c:	4b1f      	ldr	r3, [pc, #124]	; (c19c <at_handle_CGTFT_cmd_test+0x80>)
{
    c11e:	b5f0      	push	{r4, r5, r6, r7, lr}
    char *pdn_type_str[AT_CMD_CGTFT_PDN_TYPES] = {"\"IP\"", "\"NONIP\"", "\"IPV6\"", "\"IPV4V6\""};
    c120:	001a      	movs	r2, r3
{
    c122:	b08f      	sub	sp, #60	; 0x3c
    char *pdn_type_str[AT_CMD_CGTFT_PDN_TYPES] = {"\"IP\"", "\"NONIP\"", "\"IPV6\"", "\"IPV4V6\""};
    c124:	3244      	adds	r2, #68	; 0x44
    c126:	a902      	add	r1, sp, #8
    c128:	ca31      	ldmia	r2!, {r0, r4, r5}
    c12a:	c131      	stmia	r1!, {r0, r4, r5}
    c12c:	6812      	ldr	r2, [r2, #0]
    char *remote_addr_subnet_mask[AT_CMD_CGTFT_PDN_TYPES] = {"\"(0.0.0.1,255.255.255.255).(0.0.0.1,255.255.255.255)\",", ",", "\"(::1,FFFF:FFFF:FFFF:FFFF:FFFF:FFFF:FFFF:FFFF).(::1,FFFF:FFFF:FFFF:FFFF:FFFF:FFFF:FFFF:FFFF)\",", "\"(0.0.0.1,255.255.255.255)\\(::1,FFFF:FFFF:FFFF:FFFF:FFFF:FFFF:FFFF:FFFF).(0.0.0.1,255.255.255.255)\\(::1,FFFF:FFFF:FFFF:FFFF:FFFF:FFFF:FFFF:FFFF)\","};
    c12e:	ae06      	add	r6, sp, #24
    char *pdn_type_str[AT_CMD_CGTFT_PDN_TYPES] = {"\"IP\"", "\"NONIP\"", "\"IPV6\"", "\"IPV4V6\""};
    c130:	600a      	str	r2, [r1, #0]
    char *remote_addr_subnet_mask[AT_CMD_CGTFT_PDN_TYPES] = {"\"(0.0.0.1,255.255.255.255).(0.0.0.1,255.255.255.255)\",", ",", "\"(::1,FFFF:FFFF:FFFF:FFFF:FFFF:FFFF:FFFF:FFFF).(::1,FFFF:FFFF:FFFF:FFFF:FFFF:FFFF:FFFF:FFFF)\",", "\"(0.0.0.1,255.255.255.255)\\(::1,FFFF:FFFF:FFFF:FFFF:FFFF:FFFF:FFFF:FFFF).(0.0.0.1,255.255.255.255)\\(::1,FFFF:FFFF:FFFF:FFFF:FFFF:FFFF:FFFF:FFFF)\","};
    c132:	001a      	movs	r2, r3
    c134:	0031      	movs	r1, r6
    c136:	3254      	adds	r2, #84	; 0x54
    c138:	ca31      	ldmia	r2!, {r0, r4, r5}
    c13a:	c131      	stmia	r1!, {r0, r4, r5}
    c13c:	6812      	ldr	r2, [r2, #0]
    char *flow_label[AT_CMD_CGTFT_PDN_TYPES] = {",", ",", "(0x0,0xFFFFF),", "(0x0,0xFFFFF),"};
    c13e:	af0a      	add	r7, sp, #40	; 0x28
    char *remote_addr_subnet_mask[AT_CMD_CGTFT_PDN_TYPES] = {"\"(0.0.0.1,255.255.255.255).(0.0.0.1,255.255.255.255)\",", ",", "\"(::1,FFFF:FFFF:FFFF:FFFF:FFFF:FFFF:FFFF:FFFF).(::1,FFFF:FFFF:FFFF:FFFF:FFFF:FFFF:FFFF:FFFF)\",", "\"(0.0.0.1,255.255.255.255)\\(::1,FFFF:FFFF:FFFF:FFFF:FFFF:FFFF:FFFF:FFFF).(0.0.0.1,255.255.255.255)\\(::1,FFFF:FFFF:FFFF:FFFF:FFFF:FFFF:FFFF:FFFF)\","};
    c140:	600a      	str	r2, [r1, #0]
    char *flow_label[AT_CMD_CGTFT_PDN_TYPES] = {",", ",", "(0x0,0xFFFFF),", "(0x0,0xFFFFF),"};
    c142:	003a      	movs	r2, r7
    c144:	3364      	adds	r3, #100	; 0x64
    c146:	cb13      	ldmia	r3!, {r0, r1, r4}
    c148:	c213      	stmia	r2!, {r0, r1, r4}
    rsp_string = (char *)irmalloc(AT_MAX_CGTFT_TEST_RSP_LEN);
    c14a:	2091      	movs	r0, #145	; 0x91
    char *flow_label[AT_CMD_CGTFT_PDN_TYPES] = {",", ",", "(0x0,0xFFFFF),", "(0x0,0xFFFFF),"};
    c14c:	681b      	ldr	r3, [r3, #0]
    rsp_string = (char *)irmalloc(AT_MAX_CGTFT_TEST_RSP_LEN);
    c14e:	0040      	lsls	r0, r0, #1
    char *flow_label[AT_CMD_CGTFT_PDN_TYPES] = {",", ",", "(0x0,0xFFFFF),", "(0x0,0xFFFFF),"};
    c150:	6013      	str	r3, [r2, #0]
    rsp_string = (char *)irmalloc(AT_MAX_CGTFT_TEST_RSP_LEN);
    c152:	f006 fc55 	bl	12a00 <irmalloc>
    c156:	1e05      	subs	r5, r0, #0
    if (rsp_string == NULL)
    c158:	d01d      	beq.n	c196 <at_handle_CGTFT_cmd_test+0x7a>
    c15a:	2400      	movs	r4, #0
        memset(rsp_string, 0, AT_MAX_CGTFT_TEST_RSP_LEN);
    c15c:	2291      	movs	r2, #145	; 0x91
    c15e:	2100      	movs	r1, #0
    c160:	0052      	lsls	r2, r2, #1
    c162:	0028      	movs	r0, r5
    c164:	f7f4 f8bc 	bl	2e0 <memset>
        (void)snprintf(rsp_string, AT_MAX_CGTFT_TEST_RSP_LEN, "+CGTFT:%s,(1,16),(0,255),%s(0,255),\"(0,65535).(0,65535)\",\"(0,65535).(0,65535)\",(0x0,0xFFFFFFFF),\"(0,255).(0,255)\",%s(0,3))", pdn_type_str[i], remote_addr_subnet_mask[i], flow_label[i]);
    c168:	593b      	ldr	r3, [r7, r4]
    c16a:	2208      	movs	r2, #8
    c16c:	9301      	str	r3, [sp, #4]
    c16e:	5933      	ldr	r3, [r6, r4]
    c170:	2191      	movs	r1, #145	; 0x91
    c172:	9300      	str	r3, [sp, #0]
    c174:	466b      	mov	r3, sp
    c176:	189b      	adds	r3, r3, r2
    c178:	591b      	ldr	r3, [r3, r4]
    c17a:	4a09      	ldr	r2, [pc, #36]	; (c1a0 <at_handle_CGTFT_cmd_test+0x84>)
    c17c:	0049      	lsls	r1, r1, #1
    c17e:	0028      	movs	r0, r5
    c180:	f00e fb74 	bl	1a86c <snprintf>
    c184:	3404      	adds	r4, #4
        app_at_send_at_rsp_string_lines_with_claim_and_log(rsp_string);
    c186:	0028      	movs	r0, r5
    c188:	f7fd fa2c 	bl	95e4 <app_at_send_at_rsp_string_lines_with_claim_and_log>
    for (uint8 i = 0; i < AT_CMD_CGTFT_PDN_TYPES ; i++)
    c18c:	2c10      	cmp	r4, #16
    c18e:	d1e5      	bne.n	c15c <at_handle_CGTFT_cmd_test+0x40>
    irfree(rsp_string);
    c190:	0028      	movs	r0, r5
    c192:	f006 fc51 	bl	12a38 <irfree>
}
    c196:	2000      	movs	r0, #0
    c198:	b00f      	add	sp, #60	; 0x3c
    c19a:	bdf0      	pop	{r4, r5, r6, r7, pc}
    c19c:	000229f8 	.word	0x000229f8
    c1a0:	000237ee 	.word	0x000237ee

0000c1a4 <at_get_available_plmn_callback>:
{
    c1a4:	b5f0      	push	{r4, r5, r6, r7, lr}
    rsp_total_len = plmn_num * AT_CMD_COPS_PLMN_LIST_MAX_LEN + AT_CMD_COPS_PREFIX_LENTH + sizeof(rsp_rest_string);
    c1a6:	270f      	movs	r7, #15
{
    c1a8:	b089      	sub	sp, #36	; 0x24
    c1aa:	9103      	str	r1, [sp, #12]
    c1ac:	9205      	str	r2, [sp, #20]
    uint8               plmn_data[APP_AT_MAX_PLMN_LEN]         = {0};
    c1ae:	2100      	movs	r1, #0
    c1b0:	2207      	movs	r2, #7
{
    c1b2:	0005      	movs	r5, r0
    uint8               plmn_data[APP_AT_MAX_PLMN_LEN]         = {0};
    c1b4:	a806      	add	r0, sp, #24
    c1b6:	f7f4 f893 	bl	2e0 <memset>
    rsp_total_len = plmn_num * AT_CMD_COPS_PLMN_LIST_MAX_LEN + AT_CMD_COPS_PREFIX_LENTH + sizeof(rsp_rest_string);
    c1ba:	9903      	ldr	r1, [sp, #12]
    c1bc:	4379      	muls	r1, r7
    c1be:	3112      	adds	r1, #18
    rsp_string = (char*)irmalloc(rsp_total_len);
    c1c0:	0008      	movs	r0, r1
    rsp_total_len = plmn_num * AT_CMD_COPS_PLMN_LIST_MAX_LEN + AT_CMD_COPS_PREFIX_LENTH + sizeof(rsp_rest_string);
    c1c2:	9102      	str	r1, [sp, #8]
    rsp_string = (char*)irmalloc(rsp_total_len);
    c1c4:	f006 fc1c 	bl	12a00 <irmalloc>
    c1c8:	0006      	movs	r6, r0
        app_at_send_callback_response(AT_RET_MEMORY_ERROR);
    c1ca:	2004      	movs	r0, #4
    if (rsp_string == NULL)
    c1cc:	2e00      	cmp	r6, #0
    c1ce:	d021      	beq.n	c214 <at_get_available_plmn_callback+0x70>
    rsp_len = (uint16)snprintf(rsp_string, rsp_total_len, AT_CMD_COPS_PREFIX);  //lint !e845
    c1d0:	4a26      	ldr	r2, [pc, #152]	; (c26c <at_get_available_plmn_callback+0xc8>)
    c1d2:	9902      	ldr	r1, [sp, #8]
    c1d4:	0030      	movs	r0, r6
    c1d6:	f00e fb49 	bl	1a86c <snprintf>
    c1da:	9b03      	ldr	r3, [sp, #12]
    c1dc:	b284      	uxth	r4, r0
    c1de:	009b      	lsls	r3, r3, #2
    c1e0:	18eb      	adds	r3, r5, r3
    c1e2:	9304      	str	r3, [sp, #16]
    for (loop = 0; loop < plmn_num; loop++)
    c1e4:	9b04      	ldr	r3, [sp, #16]
    c1e6:	429d      	cmp	r5, r3
    c1e8:	d118      	bne.n	c21c <at_get_available_plmn_callback+0x78>
    if (plmn_num != 0)
    c1ea:	9b03      	ldr	r3, [sp, #12]
    c1ec:	2b00      	cmp	r3, #0
    c1ee:	d001      	beq.n	c1f4 <at_get_available_plmn_callback+0x50>
        rsp_len--;
    c1f0:	3c01      	subs	r4, #1
    c1f2:	b2a4      	uxth	r4, r4
    (void)snprintf(rsp_string + rsp_len, rsp_total_len - rsp_len, "%s", rsp_rest_string);
    c1f4:	9b02      	ldr	r3, [sp, #8]
    c1f6:	4a1e      	ldr	r2, [pc, #120]	; (c270 <at_get_available_plmn_callback+0xcc>)
    c1f8:	1b19      	subs	r1, r3, r4
    c1fa:	1930      	adds	r0, r6, r4
    c1fc:	4b1d      	ldr	r3, [pc, #116]	; (c274 <at_get_available_plmn_callback+0xd0>)
    c1fe:	f00e fb35 	bl	1a86c <snprintf>
    app_at_send_at_rsp_string_lines_with_claim_and_log(rsp_string);
    c202:	0030      	movs	r0, r6
    c204:	f7fd f9ee 	bl	95e4 <app_at_send_at_rsp_string_lines_with_claim_and_log>
    irfree(rsp_string);
    c208:	0030      	movs	r0, r6
    c20a:	f006 fc15 	bl	12a38 <irfree>
    cause = at_parse_convert_neul_result((NEUL_RET)result);
    c20e:	9805      	ldr	r0, [sp, #20]
    c210:	f7fe f83e 	bl	a290 <at_parse_convert_neul_result>
    app_at_send_callback_response(cause);
    c214:	f7fc f958 	bl	84c8 <app_at_send_callback_response>
}
    c218:	b009      	add	sp, #36	; 0x24
    c21a:	bdf0      	pop	{r4, r5, r6, r7, pc}
        plmn_digit = plmn[0] & 0x0F;
    c21c:	782b      	ldrb	r3, [r5, #0]
        *a_char = '0' + plmn_digit;
    c21e:	aa06      	add	r2, sp, #24
        plmn_digit = plmn[0] & 0x0F;
    c220:	0019      	movs	r1, r3
        plmn_digit = (plmn[0] >> 4) & 0x0F;
    c222:	091b      	lsrs	r3, r3, #4
        *a_char = '0' + plmn_digit;
    c224:	3330      	adds	r3, #48	; 0x30
        plmn_digit = plmn[0] & 0x0F;
    c226:	4039      	ands	r1, r7
        *a_char = '0' + plmn_digit;
    c228:	7053      	strb	r3, [r2, #1]
        plmn_digit = plmn[1] & 0x0F;
    c22a:	786b      	ldrb	r3, [r5, #1]
        *a_char = '0' + plmn_digit;
    c22c:	3130      	adds	r1, #48	; 0x30
    c22e:	7011      	strb	r1, [r2, #0]
        plmn_digit = plmn[1] & 0x0F;
    c230:	0019      	movs	r1, r3
    c232:	4039      	ands	r1, r7
        *a_char = '0' + plmn_digit;
    c234:	3130      	adds	r1, #48	; 0x30
    c236:	7091      	strb	r1, [r2, #2]
        plmn_digit = plmn[2] & 0x0F;
    c238:	78a9      	ldrb	r1, [r5, #2]
        plmn_digit = (plmn[1] >> 4) & 0x0F;
    c23a:	091b      	lsrs	r3, r3, #4
        plmn_digit = plmn[2] & 0x0F;
    c23c:	0008      	movs	r0, r1
        plmn_digit = (plmn[2] >> 4) & 0x0F;
    c23e:	0909      	lsrs	r1, r1, #4
        plmn_digit = plmn[2] & 0x0F;
    c240:	4038      	ands	r0, r7
        *a_char = '0' + plmn_digit;
    c242:	3030      	adds	r0, #48	; 0x30
        *a_char = '0' + plmn_digit;
    c244:	3130      	adds	r1, #48	; 0x30
        *a_char = '0' + plmn_digit;
    c246:	70d0      	strb	r0, [r2, #3]
        *a_char = '0' + plmn_digit;
    c248:	7111      	strb	r1, [r2, #4]
        if( plmn_digit != 0x0F)
    c24a:	2b0f      	cmp	r3, #15
    c24c:	d001      	beq.n	c252 <at_get_available_plmn_callback+0xae>
            *a_char = '0' + plmn_digit;
    c24e:	3330      	adds	r3, #48	; 0x30
    c250:	7153      	strb	r3, [r2, #5]
        rsp_len += (uint16)snprintf(rsp_string + rsp_len, rsp_total_len - rsp_len, "(%d,,,\"%s\"),", available_plmn[loop].plmn_state, plmn_data);
    c252:	9a02      	ldr	r2, [sp, #8]
    c254:	78eb      	ldrb	r3, [r5, #3]
    c256:	1b11      	subs	r1, r2, r4
    c258:	aa06      	add	r2, sp, #24
    c25a:	1930      	adds	r0, r6, r4
    c25c:	9200      	str	r2, [sp, #0]
    c25e:	4a06      	ldr	r2, [pc, #24]	; (c278 <at_get_available_plmn_callback+0xd4>)
    c260:	f00e fb04 	bl	1a86c <snprintf>
    c264:	1824      	adds	r4, r4, r0
    c266:	b2a4      	uxth	r4, r4
    c268:	3504      	adds	r5, #4
    c26a:	e7bb      	b.n	c1e4 <at_get_available_plmn_callback+0x40>
    c26c:	0002356f 	.word	0x0002356f
    c270:	000237d7 	.word	0x000237d7
    c274:	0002493f 	.word	0x0002493f
    c278:	00023576 	.word	0x00023576

0000c27c <at_handle_nping_callback>:
{
    c27c:	b5f0      	push	{r4, r5, r6, r7, lr}
    c27e:	b0b5      	sub	sp, #212	; 0xd4
    c280:	000f      	movs	r7, r1
    c282:	0004      	movs	r4, r0
    c284:	0015      	movs	r5, r2
    char    rsp_string[AT_MAX_RSP_LEN] = {0};
    c286:	2100      	movs	r1, #0
    c288:	22c8      	movs	r2, #200	; 0xc8
    c28a:	a802      	add	r0, sp, #8
{
    c28c:	001e      	movs	r6, r3
    char    rsp_string[AT_MAX_RSP_LEN] = {0};
    c28e:	f7f4 f827 	bl	2e0 <memset>
    if(success)
    c292:	2f00      	cmp	r7, #0
    c294:	d01b      	beq.n	c2ce <at_handle_nping_callback+0x52>
        (void)snprintf(rsp_string, AT_NPING_RSP_MAX_LEN, "+NPING:%s,%d,%d", ipaddr_ntoa(remote_addr), ttl, rtt);
    c296:	4811      	ldr	r0, [pc, #68]	; (c2dc <at_handle_nping_callback+0x60>)
    c298:	2c00      	cmp	r4, #0
    c29a:	d005      	beq.n	c2a8 <at_handle_nping_callback+0x2c>
    c29c:	7c23      	ldrb	r3, [r4, #16]
    c29e:	0020      	movs	r0, r4
    c2a0:	2b06      	cmp	r3, #6
    c2a2:	d111      	bne.n	c2c8 <at_handle_nping_callback+0x4c>
    c2a4:	f011 f930 	bl	1d508 <ip6addr_ntoa>
    c2a8:	0003      	movs	r3, r0
    c2aa:	9601      	str	r6, [sp, #4]
    c2ac:	9500      	str	r5, [sp, #0]
    c2ae:	4a0c      	ldr	r2, [pc, #48]	; (c2e0 <at_handle_nping_callback+0x64>)
    c2b0:	2132      	movs	r1, #50	; 0x32
    c2b2:	a802      	add	r0, sp, #8
    c2b4:	f00e fada 	bl	1a86c <snprintf>
    delayed_async_print(rsp_string, AT_FLAG_LOGABLE | AT_FLAG_LOG_RESTRICTED, 0, 0);
    c2b8:	2300      	movs	r3, #0
    c2ba:	2128      	movs	r1, #40	; 0x28
    c2bc:	001a      	movs	r2, r3
    c2be:	a802      	add	r0, sp, #8
    c2c0:	f7fe fcfc 	bl	acbc <delayed_async_print>
}
    c2c4:	b035      	add	sp, #212	; 0xd4
    c2c6:	bdf0      	pop	{r4, r5, r6, r7, pc}
        (void)snprintf(rsp_string, AT_NPING_RSP_MAX_LEN, "+NPING:%s,%d,%d", ipaddr_ntoa(remote_addr), ttl, rtt);
    c2c8:	f010 ffe4 	bl	1d294 <ip4addr_ntoa>
    c2cc:	e7ec      	b.n	c2a8 <at_handle_nping_callback+0x2c>
        (void)snprintf(rsp_string, AT_NPING_RSP_MAX_LEN, "+NPINGERR:%d", NPING_NO_RESPONSE);
    c2ce:	2301      	movs	r3, #1
    c2d0:	4a04      	ldr	r2, [pc, #16]	; (c2e4 <at_handle_nping_callback+0x68>)
    c2d2:	2132      	movs	r1, #50	; 0x32
    c2d4:	a802      	add	r0, sp, #8
    c2d6:	f00e fac9 	bl	1a86c <snprintf>
    c2da:	e7ed      	b.n	c2b8 <at_handle_nping_callback+0x3c>
    c2dc:	00023df2 	.word	0x00023df2
    c2e0:	00023df7 	.word	0x00023df7
    c2e4:	00023e07 	.word	0x00023e07

0000c2e8 <at_handle_CGEQOS_cmd_read>:
{
    c2e8:	b5f0      	push	{r4, r5, r6, r7, lr}
    result = get_defined_cids(AT_MAX_CID + 1, &cids_num, cids);
    c2ea:	260a      	movs	r6, #10
{
    c2ec:	b08b      	sub	sp, #44	; 0x2c
    uint8         cids[AT_MAX_CID + 1]                  = {0};
    c2ee:	ad03      	add	r5, sp, #12
    c2f0:	220b      	movs	r2, #11
    c2f2:	2100      	movs	r1, #0
    c2f4:	0028      	movs	r0, r5
    c2f6:	f7f3 fff3 	bl	2e0 <memset>
    result = get_defined_cids(AT_MAX_CID + 1, &cids_num, cids);
    c2fa:	446e      	add	r6, sp
    char          cgeqos_rsp[AT_MAX_CGEQOS_READ_RSP_LEN]       = {0};
    c2fc:	220f      	movs	r2, #15
    c2fe:	2100      	movs	r1, #0
    c300:	a806      	add	r0, sp, #24
    c302:	f7f3 ffed 	bl	2e0 <memset>
    result = get_defined_cids(AT_MAX_CID + 1, &cids_num, cids);
    c306:	002a      	movs	r2, r5
    c308:	0031      	movs	r1, r6
    c30a:	200b      	movs	r0, #11
    c30c:	f00f ffb7 	bl	1c27e <get_defined_cids>
    for(int16 i = 0 ; i < cids_num; i++)
    c310:	2400      	movs	r4, #0
    if (result != NEUL_RET_OK)
    c312:	42a0      	cmp	r0, r4
    c314:	d01b      	beq.n	c34e <at_handle_CGEQOS_cmd_read+0x66>
}
    c316:	2000      	movs	r0, #0
    c318:	b00b      	add	sp, #44	; 0x2c
    c31a:	bdf0      	pop	{r4, r5, r6, r7, pc}
        result = get_qos(cids[i], &qci);
    c31c:	2709      	movs	r7, #9
    c31e:	446f      	add	r7, sp
    c320:	5d28      	ldrb	r0, [r5, r4]
    c322:	0039      	movs	r1, r7
    c324:	f010 fba5 	bl	1ca72 <get_qos>
        if( NEUL_RET_OK == result)
    c328:	2800      	cmp	r0, #0
    c32a:	d10e      	bne.n	c34a <at_handle_CGEQOS_cmd_read+0x62>
            (void)snprintf(cgeqos_rsp, AT_MAX_CGEQOS_READ_RSP_LEN, "%s%d,%d", AT_CGEQOS_PRE_STRING, cids[i], qci);
    c32c:	783b      	ldrb	r3, [r7, #0]
    c32e:	4a11      	ldr	r2, [pc, #68]	; (c374 <at_handle_CGEQOS_cmd_read+0x8c>)
    c330:	9301      	str	r3, [sp, #4]
    c332:	5d2b      	ldrb	r3, [r5, r4]
    c334:	210f      	movs	r1, #15
    c336:	9300      	str	r3, [sp, #0]
    c338:	a806      	add	r0, sp, #24
    c33a:	4b0f      	ldr	r3, [pc, #60]	; (c378 <at_handle_CGEQOS_cmd_read+0x90>)
    c33c:	f00e fa96 	bl	1a86c <snprintf>
            if (i == 0)
    c340:	2c00      	cmp	r4, #0
    c342:	d108      	bne.n	c356 <at_handle_CGEQOS_cmd_read+0x6e>
                app_at_send_at_rsp_string_lines_with_claim_and_log(cgeqos_rsp);
    c344:	a806      	add	r0, sp, #24
    c346:	f7fd f94d 	bl	95e4 <app_at_send_at_rsp_string_lines_with_claim_and_log>
    c34a:	3401      	adds	r4, #1
    c34c:	b224      	sxth	r4, r4
    for(int16 i = 0 ; i < cids_num; i++)
    c34e:	8833      	ldrh	r3, [r6, #0]
    c350:	429c      	cmp	r4, r3
    c352:	dbe3      	blt.n	c31c <at_handle_CGEQOS_cmd_read+0x34>
    c354:	e7df      	b.n	c316 <at_handle_CGEQOS_cmd_read+0x2e>
                app_at_send_at_rsp_string(cgeqos_rsp, true, AT_FLAG_LOGABLE);
    c356:	2208      	movs	r2, #8
    c358:	2101      	movs	r1, #1
    c35a:	a806      	add	r0, sp, #24
    c35c:	f7fd f934 	bl	95c8 <app_at_send_at_rsp_string>
                at_uart_write((unsigned char*)APP_AT_STR_RN, strlen(APP_AT_STR_RN));
    c360:	4f06      	ldr	r7, [pc, #24]	; (c37c <at_handle_CGEQOS_cmd_read+0x94>)
    c362:	0038      	movs	r0, r7
    c364:	f00f f81b 	bl	1b39e <strlen>
    c368:	0001      	movs	r1, r0
    c36a:	0038      	movs	r0, r7
    c36c:	f7fd fb3e 	bl	99ec <at_uart_write>
    c370:	e7eb      	b.n	c34a <at_handle_CGEQOS_cmd_read+0x62>
    c372:	46c0      	nop			; (mov r8, r8)
    c374:	00023e83 	.word	0x00023e83
    c378:	00023796 	.word	0x00023796
    c37c:	00022d8f 	.word	0x00022d8f

0000c380 <at_handle_CGEQOS_cmd_set>:
{
    c380:	b573      	push	{r0, r1, r4, r5, r6, lr}
    uint16        cid             = 0;
    c382:	466b      	mov	r3, sp
    c384:	1d9c      	adds	r4, r3, #6
    c386:	2300      	movs	r3, #0
    c388:	8023      	strh	r3, [r4, #0]
    uint8         qci             = NEUL_CGEQOS_INVALID_QCI;
    c38a:	466b      	mov	r3, sp
    c38c:	1d5d      	adds	r5, r3, #5
    c38e:	23ff      	movs	r3, #255	; 0xff
    cause = at_create_param_array(p_atparams_string, &num_recvparams, AT_MIN_CGEQOS_PARAM, AT_MAX_CGEQOS_PARAM);
    c390:	2201      	movs	r2, #1
    uint8         qci             = NEUL_CGEQOS_INVALID_QCI;
    c392:	702b      	strb	r3, [r5, #0]
    cause = at_create_param_array(p_atparams_string, &num_recvparams, AT_MIN_CGEQOS_PARAM, AT_MAX_CGEQOS_PARAM);
    c394:	a901      	add	r1, sp, #4
    c396:	3bfd      	subs	r3, #253	; 0xfd
    c398:	f7fd ffa4 	bl	a2e4 <at_create_param_array>
    if(cause != AT_RET_OK)
    c39c:	2800      	cmp	r0, #0
    c39e:	d106      	bne.n	c3ae <at_handle_CGEQOS_cmd_set+0x2e>
    cause = at_get_uint16_param(AT_PARSE_FIRST_PARAM_POS, &cid, true);
    c3a0:	2201      	movs	r2, #1
    c3a2:	0021      	movs	r1, r4
    c3a4:	f7fe f8b2 	bl	a50c <at_get_uint16_param>
    if(cause != AT_RET_OK)
    c3a8:	2800      	cmp	r0, #0
    c3aa:	d001      	beq.n	c3b0 <at_handle_CGEQOS_cmd_set+0x30>
        return AT_RET_SYNTAX_ERROR;
    c3ac:	2001      	movs	r0, #1
}
    c3ae:	bd76      	pop	{r1, r2, r4, r5, r6, pc}
    cause = at_get_uint8_param(AT_PARSE_SECOND_PARAM_POS, &qci, true);
    c3b0:	2201      	movs	r2, #1
    c3b2:	0029      	movs	r1, r5
    c3b4:	0010      	movs	r0, r2
    c3b6:	f7fe f929 	bl	a60c <at_get_uint8_param>
    if(cause == AT_RET_OK)
    c3ba:	2800      	cmp	r0, #0
    c3bc:	d113      	bne.n	c3e6 <at_handle_CGEQOS_cmd_set+0x66>
            if (at_cgeqos_support_qci_value[i] == qci)
    c3be:	7829      	ldrb	r1, [r5, #0]
    bool          is_variable_qci = false;
    c3c0:	0003      	movs	r3, r0
                is_variable_qci = true;
    c3c2:	2501      	movs	r5, #1
            if (at_cgeqos_support_qci_value[i] == qci)
    c3c4:	4a0b      	ldr	r2, [pc, #44]	; (c3f4 <at_handle_CGEQOS_cmd_set+0x74>)
    c3c6:	5c86      	ldrb	r6, [r0, r2]
    c3c8:	428e      	cmp	r6, r1
    c3ca:	d100      	bne.n	c3ce <at_handle_CGEQOS_cmd_set+0x4e>
                is_variable_qci = true;
    c3cc:	002b      	movs	r3, r5
    c3ce:	3001      	adds	r0, #1
        for (uint8 i = 0; i < sizeof(at_cgeqos_support_qci_value); i++)
    c3d0:	2807      	cmp	r0, #7
    c3d2:	d1f8      	bne.n	c3c6 <at_handle_CGEQOS_cmd_set+0x46>
            return AT_RET_UNSUPPORTED_QCI_VAULE;
    c3d4:	3026      	adds	r0, #38	; 0x26
        if (!is_variable_qci)
    c3d6:	2b00      	cmp	r3, #0
    c3d8:	d0e9      	beq.n	c3ae <at_handle_CGEQOS_cmd_set+0x2e>
        neul_ret = set_qos_req(cid, qci);
    c3da:	8820      	ldrh	r0, [r4, #0]
    c3dc:	f010 fb3d 	bl	1ca5a <set_qos_req>
    return at_parse_convert_neul_result(neul_ret);
    c3e0:	f7fd ff56 	bl	a290 <at_parse_convert_neul_result>
    c3e4:	e7e3      	b.n	c3ae <at_handle_CGEQOS_cmd_set+0x2e>
    else if (cause == AT_RET_PARAM_MISSING)
    c3e6:	2803      	cmp	r0, #3
    c3e8:	d1e0      	bne.n	c3ac <at_handle_CGEQOS_cmd_set+0x2c>
        neul_ret = delete_qos(cid);
    c3ea:	8820      	ldrh	r0, [r4, #0]
    c3ec:	f010 fb29 	bl	1ca42 <delete_qos>
    c3f0:	e7f6      	b.n	c3e0 <at_handle_CGEQOS_cmd_set+0x60>
    c3f2:	46c0      	nop			; (mov r8, r8)
    c3f4:	00023529 	.word	0x00023529

0000c3f8 <at_handle_CCIOTOPT_cmd_read>:
{
    c3f8:	b570      	push	{r4, r5, r6, lr}
    result = get_ciot_opt(&supported_ue_opt,&preferred_ue_opt);
    c3fa:	2613      	movs	r6, #19
    c3fc:	2512      	movs	r5, #18
{
    c3fe:	b08a      	sub	sp, #40	; 0x28
    char  rsp_string[AT_MAX_CCIOTOPT_STR_LEN] = {0};
    c400:	2214      	movs	r2, #20
    c402:	2100      	movs	r1, #0
    c404:	a805      	add	r0, sp, #20
    result = get_ciot_opt(&supported_ue_opt,&preferred_ue_opt);
    c406:	446e      	add	r6, sp
    c408:	446d      	add	r5, sp
    char  rsp_string[AT_MAX_CCIOTOPT_STR_LEN] = {0};
    c40a:	f7f3 ff69 	bl	2e0 <memset>
    result = get_ciot_opt(&supported_ue_opt,&preferred_ue_opt);
    c40e:	0031      	movs	r1, r6
    c410:	0028      	movs	r0, r5
    c412:	f010 fb01 	bl	1ca18 <get_ciot_opt>
    c416:	0004      	movs	r4, r0
    cause = at_parse_convert_neul_result(result);
    c418:	f7fd ff3a 	bl	a290 <at_parse_convert_neul_result>
    if (result != NEUL_RET_OK)
    c41c:	2c00      	cmp	r4, #0
    c41e:	d110      	bne.n	c442 <at_handle_CCIOTOPT_cmd_read+0x4a>
    (void)snprintf(rsp_string, AT_MAX_CCIOTOPT_STR_LEN, "%s%d,%d,%d", AT_CCIOTOPT_PREFIX_STR, app_at_ciot_reporting, supported_ue_opt, preferred_ue_opt);
    c420:	7833      	ldrb	r3, [r6, #0]
    c422:	4a09      	ldr	r2, [pc, #36]	; (c448 <at_handle_CCIOTOPT_cmd_read+0x50>)
    c424:	9302      	str	r3, [sp, #8]
    c426:	782b      	ldrb	r3, [r5, #0]
    c428:	2114      	movs	r1, #20
    c42a:	9301      	str	r3, [sp, #4]
    c42c:	4b07      	ldr	r3, [pc, #28]	; (c44c <at_handle_CCIOTOPT_cmd_read+0x54>)
    c42e:	a805      	add	r0, sp, #20
    c430:	781b      	ldrb	r3, [r3, #0]
    c432:	9300      	str	r3, [sp, #0]
    c434:	4b06      	ldr	r3, [pc, #24]	; (c450 <at_handle_CCIOTOPT_cmd_read+0x58>)
    c436:	f00e fa19 	bl	1a86c <snprintf>
    app_at_send_at_rsp_string_lines_with_claim_and_log(rsp_string);
    c43a:	a805      	add	r0, sp, #20
    c43c:	f7fd f8d2 	bl	95e4 <app_at_send_at_rsp_string_lines_with_claim_and_log>
    return AT_RET_OK;
    c440:	0020      	movs	r0, r4
}
    c442:	b00a      	add	sp, #40	; 0x28
    c444:	bd70      	pop	{r4, r5, r6, pc}
    c446:	46c0      	nop			; (mov r8, r8)
    c448:	00023e6f 	.word	0x00023e6f
    c44c:	010024c0 	.word	0x010024c0
    c450:	0002359e 	.word	0x0002359e

0000c454 <at_handle_CCIOTOPT_cmd_set>:
{
    c454:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
    uint8               supported_ue_opt                 = CIOT_EPS_OPT_SUPPORT_INVALID;
    c456:	466b      	mov	r3, sp
    c458:	1d9f      	adds	r7, r3, #6
    c45a:	2304      	movs	r3, #4
    c45c:	703b      	strb	r3, [r7, #0]
    uint8               preferred_ue_opt                 = CIOT_EPS_OPT_PREFERENCE_INVALID;
    c45e:	466b      	mov	r3, sp
    if (at_create_param_array(p_atparams_string, &num_recvparams, 0, 3) != AT_RET_OK)
    c460:	466a      	mov	r2, sp
    uint8               preferred_ue_opt                 = CIOT_EPS_OPT_PREFERENCE_INVALID;
    c462:	1ddc      	adds	r4, r3, #7
    c464:	2303      	movs	r3, #3
    if (at_create_param_array(p_atparams_string, &num_recvparams, 0, 3) != AT_RET_OK)
    c466:	1d56      	adds	r6, r2, #5
    c468:	0031      	movs	r1, r6
    c46a:	2200      	movs	r2, #0
    uint8               preferred_ue_opt                 = CIOT_EPS_OPT_PREFERENCE_INVALID;
    c46c:	7023      	strb	r3, [r4, #0]
    if (at_create_param_array(p_atparams_string, &num_recvparams, 0, 3) != AT_RET_OK)
    c46e:	f7fd ff39 	bl	a2e4 <at_create_param_array>
    c472:	1e05      	subs	r5, r0, #0
    c474:	d002      	beq.n	c47c <at_handle_CCIOTOPT_cmd_set+0x28>
       return AT_RET_SYNTAX_ERROR;
    c476:	2501      	movs	r5, #1
}
    c478:	0028      	movs	r0, r5
    c47a:	bdfe      	pop	{r1, r2, r3, r4, r5, r6, r7, pc}
    if (num_recvparams > 0)
    c47c:	7833      	ldrb	r3, [r6, #0]
    c47e:	2b00      	cmp	r3, #0
    c480:	d138      	bne.n	c4f4 <at_handle_CCIOTOPT_cmd_set+0xa0>
    if (num_recvparams > 1)
    c482:	7833      	ldrb	r3, [r6, #0]
    c484:	2b01      	cmp	r3, #1
    c486:	d90e      	bls.n	c4a6 <at_handle_CCIOTOPT_cmd_set+0x52>
         cause = at_get_uint8_param(AT_PARSE_SECOND_PARAM_POS, &supported_ue_opt, true);
    c488:	2201      	movs	r2, #1
    c48a:	0039      	movs	r1, r7
    c48c:	0010      	movs	r0, r2
    c48e:	f7fe f8bd 	bl	a60c <at_get_uint8_param>
         if (((cause != AT_RET_OK) && (cause != AT_RET_PARAM_MISSING)) || (supported_ue_opt > CIOT_EPS_OPT_SUPPORT_CP_UP) || (supported_ue_opt == CIOT_EPS_OPT_SUPPORT_UP) || (supported_ue_opt == CIOT_EPS_OPT_NO_SUPPORT))
    c492:	2800      	cmp	r0, #0
    c494:	d001      	beq.n	c49a <at_handle_CCIOTOPT_cmd_set+0x46>
    c496:	2803      	cmp	r0, #3
    c498:	d1ed      	bne.n	c476 <at_handle_CCIOTOPT_cmd_set+0x22>
    c49a:	783b      	ldrb	r3, [r7, #0]
    c49c:	2b02      	cmp	r3, #2
    c49e:	d0ea      	beq.n	c476 <at_handle_CCIOTOPT_cmd_set+0x22>
    c4a0:	3b01      	subs	r3, #1
    c4a2:	2b02      	cmp	r3, #2
    c4a4:	d8e7      	bhi.n	c476 <at_handle_CCIOTOPT_cmd_set+0x22>
    if (num_recvparams > 2)
    c4a6:	7833      	ldrb	r3, [r6, #0]
    c4a8:	2b02      	cmp	r3, #2
    c4aa:	d90c      	bls.n	c4c6 <at_handle_CCIOTOPT_cmd_set+0x72>
        cause = at_get_uint8_param(AT_PARSE_THIRD_PARAM_POS, &preferred_ue_opt, true);
    c4ac:	2201      	movs	r2, #1
    c4ae:	0021      	movs	r1, r4
    c4b0:	2002      	movs	r0, #2
    c4b2:	f7fe f8ab 	bl	a60c <at_get_uint8_param>
        if (((cause != AT_RET_OK) && (cause != AT_RET_PARAM_MISSING)) || (preferred_ue_opt > CIOT_EPS_OPT_PREFERENCE_UP) || (preferred_ue_opt == CIOT_EPS_OPT_NO_PREFERENCE))
    c4b6:	2800      	cmp	r0, #0
    c4b8:	d001      	beq.n	c4be <at_handle_CCIOTOPT_cmd_set+0x6a>
    c4ba:	2803      	cmp	r0, #3
    c4bc:	d1db      	bne.n	c476 <at_handle_CCIOTOPT_cmd_set+0x22>
    c4be:	7823      	ldrb	r3, [r4, #0]
    c4c0:	3b01      	subs	r3, #1
    c4c2:	2b01      	cmp	r3, #1
    c4c4:	d8d7      	bhi.n	c476 <at_handle_CCIOTOPT_cmd_set+0x22>
    if ((supported_ue_opt != CIOT_EPS_OPT_SUPPORT_CP) && (supported_ue_opt != CIOT_EPS_OPT_SUPPORT_CP_UP)
    c4c6:	7838      	ldrb	r0, [r7, #0]
    c4c8:	2302      	movs	r3, #2
    c4ca:	0002      	movs	r2, r0
    c4cc:	439a      	bics	r2, r3
    c4ce:	2a01      	cmp	r2, #1
    c4d0:	d11f      	bne.n	c512 <at_handle_CCIOTOPT_cmd_set+0xbe>
    if ((supported_ue_opt != CIOT_EPS_OPT_SUPPORT_UP) && (supported_ue_opt != CIOT_EPS_OPT_SUPPORT_CP_UP)
    c4d2:	1e83      	subs	r3, r0, #2
    c4d4:	2b01      	cmp	r3, #1
    c4d6:	d902      	bls.n	c4de <at_handle_CCIOTOPT_cmd_set+0x8a>
       && (preferred_ue_opt == CIOT_EPS_OPT_PREFERENCE_UP))
    c4d8:	7823      	ldrb	r3, [r4, #0]
    c4da:	2b02      	cmp	r3, #2
    c4dc:	d0cb      	beq.n	c476 <at_handle_CCIOTOPT_cmd_set+0x22>
    if (app_at_ciot_reporting == CIOT_EPS_OPT_DISABLE_REPORTING_AND_RESET)
    c4de:	4b14      	ldr	r3, [pc, #80]	; (c530 <at_handle_CCIOTOPT_cmd_set+0xdc>)
    c4e0:	781b      	ldrb	r3, [r3, #0]
    c4e2:	2b03      	cmp	r3, #3
    c4e4:	d119      	bne.n	c51a <at_handle_CCIOTOPT_cmd_set+0xc6>
        supported_ue_opt = CIOT_EPS_OPT_SUPPORT_CP;
    c4e6:	3b02      	subs	r3, #2
    c4e8:	703b      	strb	r3, [r7, #0]
        preferred_ue_opt = CIOT_EPS_OPT_PREFERENCE_CP;
    c4ea:	7023      	strb	r3, [r4, #0]
        if (set_ciot_opt(supported_ue_opt, preferred_ue_opt, NULL) != NEUL_RET_OK)
    c4ec:	7821      	ldrb	r1, [r4, #0]
    c4ee:	7838      	ldrb	r0, [r7, #0]
    c4f0:	2200      	movs	r2, #0
    c4f2:	e016      	b.n	c522 <at_handle_CCIOTOPT_cmd_set+0xce>
        cause = at_get_uint8_param(AT_PARSE_FIRST_PARAM_POS, &app_at_ciot_reporting, true);
    c4f4:	2201      	movs	r2, #1
    c4f6:	490e      	ldr	r1, [pc, #56]	; (c530 <at_handle_CCIOTOPT_cmd_set+0xdc>)
    c4f8:	f7fe f888 	bl	a60c <at_get_uint8_param>
        if (((cause != AT_RET_OK) && (cause != AT_RET_PARAM_MISSING)) ||
    c4fc:	2800      	cmp	r0, #0
    c4fe:	d001      	beq.n	c504 <at_handle_CCIOTOPT_cmd_set+0xb0>
    c500:	2803      	cmp	r0, #3
    c502:	d1b8      	bne.n	c476 <at_handle_CCIOTOPT_cmd_set+0x22>
        (app_at_ciot_reporting != CIOT_EPS_OPT_DISABLE_REPORTING &&
    c504:	4b0a      	ldr	r3, [pc, #40]	; (c530 <at_handle_CCIOTOPT_cmd_set+0xdc>)
    c506:	781b      	ldrb	r3, [r3, #0]
        if (((cause != AT_RET_OK) && (cause != AT_RET_PARAM_MISSING)) ||
    c508:	2b01      	cmp	r3, #1
    c50a:	d9ba      	bls.n	c482 <at_handle_CCIOTOPT_cmd_set+0x2e>
         app_at_ciot_reporting != CIOT_EPS_OPT_ENABLE_REPORTING &&
    c50c:	2b03      	cmp	r3, #3
    c50e:	d1b2      	bne.n	c476 <at_handle_CCIOTOPT_cmd_set+0x22>
    c510:	e7b7      	b.n	c482 <at_handle_CCIOTOPT_cmd_set+0x2e>
       && (preferred_ue_opt == CIOT_EPS_OPT_PREFERENCE_CP))
    c512:	7823      	ldrb	r3, [r4, #0]
    c514:	2b01      	cmp	r3, #1
    c516:	d1dc      	bne.n	c4d2 <at_handle_CCIOTOPT_cmd_set+0x7e>
    c518:	e7ad      	b.n	c476 <at_handle_CCIOTOPT_cmd_set+0x22>
    if (app_at_ciot_reporting == CIOT_EPS_OPT_ENABLE_REPORTING)
    c51a:	2b01      	cmp	r3, #1
    c51c:	d1e6      	bne.n	c4ec <at_handle_CCIOTOPT_cmd_set+0x98>
        if (set_ciot_opt(supported_ue_opt, preferred_ue_opt, at_set_ciot_opt_callback) != NEUL_RET_OK)
    c51e:	7821      	ldrb	r1, [r4, #0]
    c520:	4a04      	ldr	r2, [pc, #16]	; (c534 <at_handle_CCIOTOPT_cmd_set+0xe0>)
    c522:	f010 fa63 	bl	1c9ec <set_ciot_opt>
    c526:	2800      	cmp	r0, #0
    c528:	d0a6      	beq.n	c478 <at_handle_CCIOTOPT_cmd_set+0x24>
            return AT_RET_PROGRESS_ERROR;
    c52a:	2506      	movs	r5, #6
    c52c:	e7a4      	b.n	c478 <at_handle_CCIOTOPT_cmd_set+0x24>
    c52e:	46c0      	nop			; (mov r8, r8)
    c530:	010024c0 	.word	0x010024c0
    c534:	0000ad95 	.word	0x0000ad95

0000c538 <app_at_send_at_rsp_active_string>:
{
    c538:	b5f0      	push	{r4, r5, r6, r7, lr}
    c53a:	000f      	movs	r7, r1
    c53c:	b08d      	sub	sp, #52	; 0x34
    uint8       cids[AT_MAX_CID + 1]                     = {0};
    c53e:	220b      	movs	r2, #11
    c540:	2100      	movs	r1, #0
{
    c542:	0004      	movs	r4, r0
    uint8       cids[AT_MAX_CID + 1]                     = {0};
    c544:	a809      	add	r0, sp, #36	; 0x24
    c546:	f7f3 fecb 	bl	2e0 <memset>
    active_cids_string = (char*)irmalloc(sizeof(char)*max_length);
    c54a:	0038      	movs	r0, r7
    c54c:	f006 fa58 	bl	12a00 <irmalloc>
    c550:	0006      	movs	r6, r0
        return AT_RET_MEMORY_ERROR;
    c552:	2004      	movs	r0, #4
    if (active_cids_string == NULL)
    c554:	2e00      	cmp	r6, #0
    c556:	d00c      	beq.n	c572 <app_at_send_at_rsp_active_string+0x3a>
    result = get_defined_cids(AT_MAX_CID + 1, &cids_num, cids);
    c558:	2112      	movs	r1, #18
    c55a:	ab02      	add	r3, sp, #8
    c55c:	aa09      	add	r2, sp, #36	; 0x24
    c55e:	18c9      	adds	r1, r1, r3
    c560:	3007      	adds	r0, #7
    c562:	f00f fe8c 	bl	1c27e <get_defined_cids>
    c566:	1e05      	subs	r5, r0, #0
    if (result != NEUL_RET_OK)
    c568:	d005      	beq.n	c576 <app_at_send_at_rsp_active_string+0x3e>
    irfree(active_cids_string);
    c56a:	0030      	movs	r0, r6
    c56c:	f006 fa64 	bl	12a38 <irfree>
    return AT_RET_OK;
    c570:	2000      	movs	r0, #0
}
    c572:	b00d      	add	sp, #52	; 0x34
    c574:	bdf0      	pop	{r4, r5, r6, r7, pc}
    len = (uint16)snprintf(active_cids_string, max_length, "%s(", at_command_prefix);
    c576:	0023      	movs	r3, r4
    c578:	4a1f      	ldr	r2, [pc, #124]	; (c5f8 <app_at_send_at_rsp_active_string+0xc0>)
    c57a:	0039      	movs	r1, r7
    c57c:	0030      	movs	r0, r6
    c57e:	f00e f975 	bl	1a86c <snprintf>
    bool        cid_valid                                = false;
    c582:	9503      	str	r5, [sp, #12]
    len = (uint16)snprintf(active_cids_string, max_length, "%s(", at_command_prefix);
    c584:	b284      	uxth	r4, r0
    for (int16 i = 0 ; i < cids_num; i++)
    c586:	2312      	movs	r3, #18
    c588:	aa02      	add	r2, sp, #8
    c58a:	189b      	adds	r3, r3, r2
    c58c:	881b      	ldrh	r3, [r3, #0]
    c58e:	429d      	cmp	r5, r3
    c590:	db0d      	blt.n	c5ae <app_at_send_at_rsp_active_string+0x76>
    if (cid_valid)
    c592:	9b03      	ldr	r3, [sp, #12]
    c594:	2b00      	cmp	r3, #0
    c596:	d001      	beq.n	c59c <app_at_send_at_rsp_active_string+0x64>
        len--;
    c598:	3c01      	subs	r4, #1
    c59a:	b2a4      	uxth	r4, r4
    len += (uint16)snprintf(active_cids_string + len, max_length - len, ")");
    c59c:	1b39      	subs	r1, r7, r4
    c59e:	1930      	adds	r0, r6, r4
    c5a0:	4a16      	ldr	r2, [pc, #88]	; (c5fc <app_at_send_at_rsp_active_string+0xc4>)
    c5a2:	f00e f963 	bl	1a86c <snprintf>
    app_at_send_at_rsp_string_lines_with_claim_and_log(active_cids_string);
    c5a6:	0030      	movs	r0, r6
    c5a8:	f7fd f81c 	bl	95e4 <app_at_send_at_rsp_string_lines_with_claim_and_log>
    c5ac:	e7dd      	b.n	c56a <app_at_send_at_rsp_active_string+0x32>
        result = get_apn_rate_control_context(cids[i], &additional_exception_reports, &uplink_time_unit, &maximum_uplink_rate, &except_uplink_time_unit, &except_maximum_uplink_rate);
    c5ae:	221c      	movs	r2, #28
    c5b0:	ab02      	add	r3, sp, #8
    c5b2:	189b      	adds	r3, r3, r2
    c5b4:	5d5b      	ldrb	r3, [r3, r5]
    c5b6:	210f      	movs	r1, #15
    c5b8:	469c      	mov	ip, r3
    c5ba:	ab08      	add	r3, sp, #32
    c5bc:	9301      	str	r3, [sp, #4]
    c5be:	2311      	movs	r3, #17
    c5c0:	aa02      	add	r2, sp, #8
    c5c2:	189b      	adds	r3, r3, r2
    c5c4:	a802      	add	r0, sp, #8
    c5c6:	9300      	str	r3, [sp, #0]
    c5c8:	1809      	adds	r1, r1, r0
    c5ca:	ab07      	add	r3, sp, #28
    c5cc:	aa06      	add	r2, sp, #24
    c5ce:	4660      	mov	r0, ip
    c5d0:	f010 f91e 	bl	1c810 <get_apn_rate_control_context>
        if (result == NEUL_RET_OK)
    c5d4:	2800      	cmp	r0, #0
    c5d6:	d10c      	bne.n	c5f2 <app_at_send_at_rsp_active_string+0xba>
            len += (uint16)snprintf(active_cids_string + len, max_length - len, "%d,", cids[i]);
    c5d8:	221c      	movs	r2, #28
    c5da:	ab02      	add	r3, sp, #8
    c5dc:	189b      	adds	r3, r3, r2
    c5de:	5d5b      	ldrb	r3, [r3, r5]
    c5e0:	1b39      	subs	r1, r7, r4
    c5e2:	1930      	adds	r0, r6, r4
    c5e4:	4a06      	ldr	r2, [pc, #24]	; (c600 <app_at_send_at_rsp_active_string+0xc8>)
    c5e6:	f00e f941 	bl	1a86c <snprintf>
            cid_valid = true;
    c5ea:	2301      	movs	r3, #1
            len += (uint16)snprintf(active_cids_string + len, max_length - len, "%d,", cids[i]);
    c5ec:	1824      	adds	r4, r4, r0
    c5ee:	b2a4      	uxth	r4, r4
            cid_valid = true;
    c5f0:	9303      	str	r3, [sp, #12]
    c5f2:	3501      	adds	r5, #1
    c5f4:	b22d      	sxth	r5, r5
    c5f6:	e7c6      	b.n	c586 <app_at_send_at_rsp_active_string+0x4e>
    c5f8:	0002379f 	.word	0x0002379f
    c5fc:	00023d40 	.word	0x00023d40
    c600:	000234e4 	.word	0x000234e4

0000c604 <at_handle_CGCMOD_cmd_test>:
{
    c604:	b510      	push	{r4, lr}
    return app_at_send_at_rsp_active_string(AT_CGCMOD_PREFIX_STR, AT_CGCMOD_MAX_STR_LEN);
    c606:	2122      	movs	r1, #34	; 0x22
    c608:	4801      	ldr	r0, [pc, #4]	; (c610 <at_handle_CGCMOD_cmd_test+0xc>)
    c60a:	f7ff ff95 	bl	c538 <app_at_send_at_rsp_active_string>
}
    c60e:	bd10      	pop	{r4, pc}
    c610:	000236df 	.word	0x000236df

0000c614 <at_handle_CGCONTRDP_cmd_test>:
{
    c614:	b510      	push	{r4, lr}
    return app_at_send_at_rsp_active_string(AT_CGCONTRDP_PREFIX_STR, AT_CGCONTRDP_TEXT_MAX_STR_LEN);
    c616:	2125      	movs	r1, #37	; 0x25
    c618:	4801      	ldr	r0, [pc, #4]	; (c620 <at_handle_CGCONTRDP_cmd_test+0xc>)
    c61a:	f7ff ff8d 	bl	c538 <app_at_send_at_rsp_active_string>
}
    c61e:	bd10      	pop	{r4, pc}
    c620:	000236e8 	.word	0x000236e8

0000c624 <at_handle_CGAPNRC_cmd_test>:
{
    c624:	b510      	push	{r4, lr}
    return app_at_send_at_rsp_active_string(AT_APNRC_PREFIX_STR, AT_APNRC_MAX_STR_LEN);
    c626:	2123      	movs	r1, #35	; 0x23
    c628:	4801      	ldr	r0, [pc, #4]	; (c630 <at_handle_CGAPNRC_cmd_test+0xc>)
    c62a:	f7ff ff85 	bl	c538 <app_at_send_at_rsp_active_string>
}
    c62e:	bd10      	pop	{r4, pc}
    c630:	000234d4 	.word	0x000234d4

0000c634 <at_handle_CGAPNRC_cmd_exec>:
{
    c634:	b5f0      	push	{r4, r5, r6, r7, lr}
    c636:	b08d      	sub	sp, #52	; 0x34
    uint8         cids[AT_MAX_CID + 1]                  = {0};
    c638:	220b      	movs	r2, #11
    c63a:	2100      	movs	r1, #0
    c63c:	a809      	add	r0, sp, #36	; 0x24
    c63e:	f7f3 fe4f 	bl	2e0 <memset>
    result = get_defined_cids(AT_MAX_CID + 1, &cids_num, cids);
    c642:	2112      	movs	r1, #18
    c644:	ab02      	add	r3, sp, #8
    c646:	aa09      	add	r2, sp, #36	; 0x24
    c648:	18c9      	adds	r1, r1, r3
    c64a:	200b      	movs	r0, #11
    c64c:	f00f fe17 	bl	1c27e <get_defined_cids>
    if (result != NEUL_RET_OK)
    c650:	2800      	cmp	r0, #0
    c652:	d028      	beq.n	c6a6 <at_handle_CGAPNRC_cmd_exec+0x72>
}
    c654:	2000      	movs	r0, #0
    c656:	b00d      	add	sp, #52	; 0x34
    c658:	bdf0      	pop	{r4, r5, r6, r7, pc}
        result = get_apn_rate_control_context(cids[i], &additional_exception_reports, &uplink_time_unit, &maximum_uplink_rate, &except_uplink_time_unit, &except_maximum_uplink_rate);
    c65a:	260f      	movs	r6, #15
    c65c:	ab02      	add	r3, sp, #8
    c65e:	18f6      	adds	r6, r6, r3
    c660:	ad09      	add	r5, sp, #36	; 0x24
    c662:	ab08      	add	r3, sp, #32
    c664:	5d28      	ldrb	r0, [r5, r4]
    c666:	9301      	str	r3, [sp, #4]
    c668:	2311      	movs	r3, #17
    c66a:	aa02      	add	r2, sp, #8
    c66c:	189b      	adds	r3, r3, r2
    c66e:	af06      	add	r7, sp, #24
    c670:	9300      	str	r3, [sp, #0]
    c672:	003a      	movs	r2, r7
    c674:	ab07      	add	r3, sp, #28
    c676:	0031      	movs	r1, r6
    c678:	f010 f8ca 	bl	1c810 <get_apn_rate_control_context>
        if( NEUL_RET_OK == result)
    c67c:	2800      	cmp	r0, #0
    c67e:	d109      	bne.n	c694 <at_handle_CGAPNRC_cmd_exec+0x60>
            app_at_send_at_rsp_apnrc_string(cids[i], additional_exception_reports, uplink_time_unit, maximum_uplink_rate, line_feed_flag);
    c680:	9b03      	ldr	r3, [sp, #12]
    c682:	783a      	ldrb	r2, [r7, #0]
    c684:	7831      	ldrb	r1, [r6, #0]
    c686:	5d28      	ldrb	r0, [r5, r4]
    c688:	9300      	str	r3, [sp, #0]
    c68a:	9b07      	ldr	r3, [sp, #28]
    c68c:	f7fe ff08 	bl	b4a0 <app_at_send_at_rsp_apnrc_string>
            line_feed_flag = true;
    c690:	2301      	movs	r3, #1
    c692:	9303      	str	r3, [sp, #12]
    c694:	3401      	adds	r4, #1
    c696:	b224      	sxth	r4, r4
    for(int16 i = 0 ; i < cids_num; i++)
    c698:	2312      	movs	r3, #18
    c69a:	aa02      	add	r2, sp, #8
    c69c:	189b      	adds	r3, r3, r2
    c69e:	881b      	ldrh	r3, [r3, #0]
    c6a0:	429c      	cmp	r4, r3
    c6a2:	dbda      	blt.n	c65a <at_handle_CGAPNRC_cmd_exec+0x26>
    c6a4:	e7d6      	b.n	c654 <at_handle_CGAPNRC_cmd_exec+0x20>
    c6a6:	0004      	movs	r4, r0
    bool          line_feed_flag                        = false;
    c6a8:	9003      	str	r0, [sp, #12]
    c6aa:	e7f5      	b.n	c698 <at_handle_CGAPNRC_cmd_exec+0x64>

0000c6ac <at_handle_CGAPNRC_cmd_set>:
{
    c6ac:	b5f0      	push	{r4, r5, r6, r7, lr}
    uint8         param_num = 0;
    c6ae:	210a      	movs	r1, #10
    uint16        cid = 0;
    c6b0:	250e      	movs	r5, #14
    uint8         param_num = 0;
    c6b2:	2300      	movs	r3, #0
{
    c6b4:	b087      	sub	sp, #28
    uint8         param_num = 0;
    c6b6:	4469      	add	r1, sp
    uint16        cid = 0;
    c6b8:	446d      	add	r5, sp
    uint8         param_num = 0;
    c6ba:	700b      	strb	r3, [r1, #0]
    uint16        cid = 0;
    c6bc:	802b      	strh	r3, [r5, #0]
    cause = at_create_param_array(p_atparams_string, &param_num, 1, 1);
    c6be:	3301      	adds	r3, #1
    c6c0:	001a      	movs	r2, r3
    c6c2:	f7fd fe0f 	bl	a2e4 <at_create_param_array>
    c6c6:	1e04      	subs	r4, r0, #0
    if (cause != AT_RET_OK)
    c6c8:	d11f      	bne.n	c70a <at_handle_CGAPNRC_cmd_set+0x5e>
    cause = at_get_uint16_param(AT_PARSE_FIRST_PARAM_POS, &cid, true);
    c6ca:	2201      	movs	r2, #1
    c6cc:	0029      	movs	r1, r5
    c6ce:	f7fd ff1d 	bl	a50c <at_get_uint16_param>
        return AT_RET_SYNTAX_ERROR;
    c6d2:	3401      	adds	r4, #1
    if(cause != AT_RET_OK)
    c6d4:	2800      	cmp	r0, #0
    c6d6:	d118      	bne.n	c70a <at_handle_CGAPNRC_cmd_set+0x5e>
    result = get_apn_rate_control_context((uint8)cid, &additional_exception_reports, &uplink_time_unit, &maximum_uplink_rate, &except_uplink_time_unit, &except_maximum_uplink_rate);
    c6d8:	ab05      	add	r3, sp, #20
    c6da:	7828      	ldrb	r0, [r5, #0]
    c6dc:	260b      	movs	r6, #11
    c6de:	9301      	str	r3, [sp, #4]
    c6e0:	230d      	movs	r3, #13
    c6e2:	af03      	add	r7, sp, #12
    c6e4:	446b      	add	r3, sp
    c6e6:	446e      	add	r6, sp
    c6e8:	9300      	str	r3, [sp, #0]
    c6ea:	003a      	movs	r2, r7
    c6ec:	ab04      	add	r3, sp, #16
    c6ee:	0031      	movs	r1, r6
    c6f0:	f010 f88e 	bl	1c810 <get_apn_rate_control_context>
    cause = at_parse_convert_neul_result(result);
    c6f4:	f7fd fdcc 	bl	a290 <at_parse_convert_neul_result>
    c6f8:	1e04      	subs	r4, r0, #0
    if(cause == AT_RET_OK)
    c6fa:	d106      	bne.n	c70a <at_handle_CGAPNRC_cmd_set+0x5e>
        app_at_send_at_rsp_apnrc_string((uint8)cid, additional_exception_reports, uplink_time_unit, maximum_uplink_rate, false);
    c6fc:	783a      	ldrb	r2, [r7, #0]
    c6fe:	7831      	ldrb	r1, [r6, #0]
    c700:	7828      	ldrb	r0, [r5, #0]
    c702:	9b04      	ldr	r3, [sp, #16]
    c704:	9400      	str	r4, [sp, #0]
    c706:	f7fe fecb 	bl	b4a0 <app_at_send_at_rsp_apnrc_string>
}
    c70a:	0020      	movs	r0, r4
    c70c:	b007      	add	sp, #28
    c70e:	bdf0      	pop	{r4, r5, r6, r7, pc}

0000c710 <at_handle_CGCMOD_cmd_set>:
{
    c710:	b513      	push	{r0, r1, r4, lr}
    uint16         cid = 0;
    c712:	466b      	mov	r3, sp
    c714:	1d9c      	adds	r4, r3, #6
    c716:	2300      	movs	r3, #0
    cause = at_create_param_array(p_atparams_string, &num_recvparams, AT_MAX_CGCMOD_PARAM, AT_MAX_CGCMOD_PARAM);
    c718:	4669      	mov	r1, sp
    uint16         cid = 0;
    c71a:	8023      	strh	r3, [r4, #0]
    cause = at_create_param_array(p_atparams_string, &num_recvparams, AT_MAX_CGCMOD_PARAM, AT_MAX_CGCMOD_PARAM);
    c71c:	3301      	adds	r3, #1
    c71e:	001a      	movs	r2, r3
    c720:	3105      	adds	r1, #5
    c722:	f7fd fddf 	bl	a2e4 <at_create_param_array>
    if(cause != AT_RET_OK)
    c726:	2800      	cmp	r0, #0
    c728:	d10d      	bne.n	c746 <at_handle_CGCMOD_cmd_set+0x36>
    cause = at_get_uint16_param(AT_PARSE_FIRST_PARAM_POS, &cid, true);
    c72a:	2201      	movs	r2, #1
    c72c:	0021      	movs	r1, r4
    c72e:	f7fd feed 	bl	a50c <at_get_uint16_param>
    c732:	0003      	movs	r3, r0
        return AT_RET_SYNTAX_ERROR;
    c734:	2001      	movs	r0, #1
    if(cause != AT_RET_OK)
    c736:	2b00      	cmp	r3, #0
    c738:	d105      	bne.n	c746 <at_handle_CGCMOD_cmd_set+0x36>
    neul_ret = modify_pdp_req(cid, modify_pdp_callback);
    c73a:	4903      	ldr	r1, [pc, #12]	; (c748 <at_handle_CGCMOD_cmd_set+0x38>)
    c73c:	8820      	ldrh	r0, [r4, #0]
    c73e:	f010 f923 	bl	1c988 <modify_pdp_req>
    return at_parse_convert_neul_result(neul_ret);
    c742:	f7fd fda5 	bl	a290 <at_parse_convert_neul_result>
}
    c746:	bd16      	pop	{r1, r2, r4, pc}
    c748:	0000c0e9 	.word	0x0000c0e9

0000c74c <at_handle_NCPCDPR_cmd_read>:
{
    c74c:	b5f0      	push	{r4, r5, r6, r7, lr}
    c74e:	b089      	sub	sp, #36	; 0x24
    char             rsp_string[AT_CMD_NCPCNPR_READ_RES_MAX_LEN]    = {0};
    c750:	2210      	movs	r2, #16
    c752:	2100      	movs	r1, #0
    c754:	a804      	add	r0, sp, #16
    c756:	f7f3 fdc3 	bl	2e0 <memset>
    c75a:	2400      	movs	r4, #0
    bool             first_line                                     = true;
    c75c:	2601      	movs	r6, #1
        if (get_pdp_context_dynamic_param_request_state(i, &state) == NEUL_RET_OK)
    c75e:	270f      	movs	r7, #15
    c760:	446f      	add	r7, sp
    c762:	b2e0      	uxtb	r0, r4
    c764:	0039      	movs	r1, r7
    c766:	f010 f902 	bl	1c96e <get_pdp_context_dynamic_param_request_state>
    c76a:	2800      	cmp	r0, #0
    c76c:	d11f      	bne.n	c7ae <at_handle_NCPCDPR_cmd_read+0x62>
    c76e:	4d13      	ldr	r5, [pc, #76]	; (c7bc <at_handle_NCPCDPR_cmd_read+0x70>)
            if (first_line)
    c770:	2e00      	cmp	r6, #0
    c772:	d006      	beq.n	c782 <at_handle_NCPCDPR_cmd_read+0x36>
                at_uart_write((unsigned char*)APP_AT_STR_RN, strlen(APP_AT_STR_RN));
    c774:	0028      	movs	r0, r5
    c776:	f00e fe12 	bl	1b39e <strlen>
    c77a:	0001      	movs	r1, r0
    c77c:	0028      	movs	r0, r5
    c77e:	f7fd f935 	bl	99ec <at_uart_write>
            (void)snprintf(rsp_string, AT_CMD_NCPCNPR_READ_RES_MAX_LEN, "%s%d,%d", AT_CMD_NCPCDPR_STR, i, (uint8)state);
    c782:	783b      	ldrb	r3, [r7, #0]
    c784:	4a0e      	ldr	r2, [pc, #56]	; (c7c0 <at_handle_NCPCDPR_cmd_read+0x74>)
    c786:	9301      	str	r3, [sp, #4]
    c788:	2110      	movs	r1, #16
    c78a:	4b0e      	ldr	r3, [pc, #56]	; (c7c4 <at_handle_NCPCDPR_cmd_read+0x78>)
    c78c:	9400      	str	r4, [sp, #0]
    c78e:	a804      	add	r0, sp, #16
    c790:	f00e f86c 	bl	1a86c <snprintf>
            app_at_send_at_rsp_string(rsp_string, true, AT_FLAG_LOGABLE);
    c794:	2208      	movs	r2, #8
    c796:	2101      	movs	r1, #1
    c798:	a804      	add	r0, sp, #16
    c79a:	f7fc ff15 	bl	95c8 <app_at_send_at_rsp_string>
            at_uart_write((unsigned char*)APP_AT_STR_RN, strlen(APP_AT_STR_RN));
    c79e:	0028      	movs	r0, r5
    c7a0:	f00e fdfd 	bl	1b39e <strlen>
    c7a4:	0001      	movs	r1, r0
    c7a6:	0028      	movs	r0, r5
    c7a8:	f7fd f920 	bl	99ec <at_uart_write>
    c7ac:	2600      	movs	r6, #0
    for(PDP_CONTEXT_DYNAMIC_PARAM i = DNS_SERVER_IPV4_ADDR_REQUEST; i < NUM_PDP_CONTEXT_DYNAMIC_PARAM; i++)
    c7ae:	2c01      	cmp	r4, #1
    c7b0:	d102      	bne.n	c7b8 <at_handle_NCPCDPR_cmd_read+0x6c>
}
    c7b2:	2000      	movs	r0, #0
    c7b4:	b009      	add	sp, #36	; 0x24
    c7b6:	bdf0      	pop	{r4, r5, r6, r7, pc}
    c7b8:	2401      	movs	r4, #1
    c7ba:	e7d0      	b.n	c75e <at_handle_NCPCDPR_cmd_read+0x12>
    c7bc:	00022d8f 	.word	0x00022d8f
    c7c0:	00023e83 	.word	0x00023e83
    c7c4:	00023bab 	.word	0x00023bab

0000c7c8 <app_at_send_at_rsp_cgcontrdp_string>:
{
    c7c8:	b5f0      	push	{r4, r5, r6, r7, lr}
    c7ca:	b0c1      	sub	sp, #260	; 0x104
    c7cc:	9104      	str	r1, [sp, #16]
    current_pdp_context.apn = apn_str;
    c7ce:	ab08      	add	r3, sp, #32
    if (get_pdp_context(cid, &current_pdp_context) != NEUL_RET_OK)
    c7d0:	a922      	add	r1, sp, #136	; 0x88
{
    c7d2:	0004      	movs	r4, r0
    current_pdp_context.apn = apn_str;
    c7d4:	9325      	str	r3, [sp, #148]	; 0x94
    if (get_pdp_context(cid, &current_pdp_context) != NEUL_RET_OK)
    c7d6:	f00f fdb7 	bl	1c348 <get_pdp_context>
    c7da:	2800      	cmp	r0, #0
    c7dc:	d000      	beq.n	c7e0 <app_at_send_at_rsp_cgcontrdp_string+0x18>
    c7de:	e0a8      	b.n	c932 <app_at_send_at_rsp_cgcontrdp_string+0x16a>
    if (getdnsaddr(cid, &dnsap) != NEUL_RET_OK)
    c7e0:	a907      	add	r1, sp, #28
    c7e2:	0020      	movs	r0, r4
    c7e4:	f010 fc1e 	bl	1d024 <getdnsaddr>
    c7e8:	2800      	cmp	r0, #0
    c7ea:	d000      	beq.n	c7ee <app_at_send_at_rsp_cgcontrdp_string+0x26>
    c7ec:	e0a1      	b.n	c932 <app_at_send_at_rsp_cgcontrdp_string+0x16a>
    char  *cgcontrdp_string = (char *)irzalloc(AT_CGCONTRDP_MAX_STR_LEN);
    c7ee:	30c8      	adds	r0, #200	; 0xc8
    current = dnsap;
    c7f0:	9e07      	ldr	r6, [sp, #28]
    char  *cgcontrdp_string = (char *)irzalloc(AT_CGCONTRDP_MAX_STR_LEN);
    c7f2:	f006 f90f 	bl	12a14 <irzalloc>
    c7f6:	1e05      	subs	r5, r0, #0
    if(cgcontrdp_string == NULL)
    c7f8:	d100      	bne.n	c7fc <app_at_send_at_rsp_cgcontrdp_string+0x34>
    c7fa:	e09a      	b.n	c932 <app_at_send_at_rsp_cgcontrdp_string+0x16a>
    len = (uint16)snprintf(cgcontrdp_string, AT_CGCONTRDP_MAX_STR_LEN, "%s%d", AT_CGCONTRDP_PREFIX_STR, cid);
    c7fc:	9400      	str	r4, [sp, #0]
    c7fe:	4b53      	ldr	r3, [pc, #332]	; (c94c <app_at_send_at_rsp_cgcontrdp_string+0x184>)
    c800:	4a53      	ldr	r2, [pc, #332]	; (c950 <app_at_send_at_rsp_cgcontrdp_string+0x188>)
    c802:	21c8      	movs	r1, #200	; 0xc8
    c804:	f00e f832 	bl	1a86c <snprintf>
    c808:	0007      	movs	r7, r0
    c80a:	b284      	uxth	r4, r0
    if((at_strlen(current_pdp_context.apn_nw) != 0) || current != NULL)
    c80c:	a826      	add	r0, sp, #152	; 0x98
    c80e:	f00e fdc6 	bl	1b39e <strlen>
    c812:	2800      	cmp	r0, #0
    c814:	d101      	bne.n	c81a <app_at_send_at_rsp_cgcontrdp_string+0x52>
    c816:	2e00      	cmp	r6, #0
    c818:	d008      	beq.n	c82c <app_at_send_at_rsp_cgcontrdp_string+0x64>
         len += (uint16)snprintf(cgcontrdp_string + len, AT_CGCONTRDP_MAX_STR_LEN - len, ",,");
    c81a:	21c8      	movs	r1, #200	; 0xc8
    c81c:	b2b8      	uxth	r0, r7
    c81e:	1a09      	subs	r1, r1, r0
    c820:	4a4c      	ldr	r2, [pc, #304]	; (c954 <app_at_send_at_rsp_cgcontrdp_string+0x18c>)
    c822:	1828      	adds	r0, r5, r0
    c824:	f00e f822 	bl	1a86c <snprintf>
    c828:	1824      	adds	r4, r4, r0
    c82a:	b2a4      	uxth	r4, r4
    if(at_strlen(current_pdp_context.apn_nw) != 0)
    c82c:	a826      	add	r0, sp, #152	; 0x98
    c82e:	f00e fdb6 	bl	1b39e <strlen>
    c832:	2800      	cmp	r0, #0
    c834:	d01e      	beq.n	c874 <app_at_send_at_rsp_cgcontrdp_string+0xac>
        len += (uint16)snprintf(cgcontrdp_string + len,  AT_CGCONTRDP_MAX_STR_LEN - len, "\"");
    c836:	27c8      	movs	r7, #200	; 0xc8
    c838:	1928      	adds	r0, r5, r4
    c83a:	1b39      	subs	r1, r7, r4
    c83c:	4a46      	ldr	r2, [pc, #280]	; (c958 <app_at_send_at_rsp_cgcontrdp_string+0x190>)
    c83e:	f00e f815 	bl	1a86c <snprintf>
    uint16                       uc_count = 0;
    c842:	2300      	movs	r3, #0
        len += (uint16)snprintf(cgcontrdp_string + len,  AT_CGCONTRDP_MAX_STR_LEN - len, "\"");
    c844:	1824      	adds	r4, r4, r0
    c846:	b2a4      	uxth	r4, r4
    uint16                       uc_count = 0;
    c848:	9303      	str	r3, [sp, #12]
            len += (uint16)snprintf(cgcontrdp_string + len,  AT_CGCONTRDP_MAX_STR_LEN - len, "%.*s.", uc_piece_data_len, current_pdp_context.apn_nw + uc_count + 1);
    c84a:	9705      	str	r7, [sp, #20]
        while((*(current_pdp_context.apn_nw + uc_count) != '\0') && (len < AT_CGCONTRDP_MAX_STR_LEN))
    c84c:	9a03      	ldr	r2, [sp, #12]
    c84e:	ab26      	add	r3, sp, #152	; 0x98
    c850:	5c9f      	ldrb	r7, [r3, r2]
    c852:	2f00      	cmp	r7, #0
    c854:	d001      	beq.n	c85a <app_at_send_at_rsp_cgcontrdp_string+0x92>
    c856:	2cc7      	cmp	r4, #199	; 0xc7
    c858:	d918      	bls.n	c88c <app_at_send_at_rsp_cgcontrdp_string+0xc4>
    if (uc_count > 0)
    c85a:	9b03      	ldr	r3, [sp, #12]
    c85c:	2b00      	cmp	r3, #0
    c85e:	d009      	beq.n	c874 <app_at_send_at_rsp_cgcontrdp_string+0xac>
         len += (uint16)snprintf(cgcontrdp_string + len,  AT_CGCONTRDP_MAX_STR_LEN - len, "\"");   //right quotes around APN
    c860:	21c8      	movs	r1, #200	; 0xc8
         len = len - 1;          //Remove the '.'
    c862:	3c01      	subs	r4, #1
    c864:	b2a4      	uxth	r4, r4
         len += (uint16)snprintf(cgcontrdp_string + len,  AT_CGCONTRDP_MAX_STR_LEN - len, "\"");   //right quotes around APN
    c866:	1b09      	subs	r1, r1, r4
    c868:	1928      	adds	r0, r5, r4
    c86a:	4a3b      	ldr	r2, [pc, #236]	; (c958 <app_at_send_at_rsp_cgcontrdp_string+0x190>)
    c86c:	f00d fffe 	bl	1a86c <snprintf>
    c870:	1824      	adds	r4, r4, r0
    c872:	b2a4      	uxth	r4, r4
    uint16                       uc_count = 0;
    c874:	2700      	movs	r7, #0
    while(current)
    c876:	2e00      	cmp	r6, #0
    c878:	d03e      	beq.n	c8f8 <app_at_send_at_rsp_cgcontrdp_string+0x130>
        if ((current_pdp_context.pdp_type == PDN_TYPE_IPV4 && IP_IS_V4_VAL(current->dns_addr))
    c87a:	ab22      	add	r3, sp, #136	; 0x88
    c87c:	791b      	ldrb	r3, [r3, #4]
    c87e:	2b01      	cmp	r3, #1
    c880:	d117      	bne.n	c8b2 <app_at_send_at_rsp_cgcontrdp_string+0xea>
    c882:	7e33      	ldrb	r3, [r6, #24]
    c884:	2b00      	cmp	r3, #0
    c886:	d059      	beq.n	c93c <app_at_send_at_rsp_cgcontrdp_string+0x174>
        current = current->dnsa_next;
    c888:	6836      	ldr	r6, [r6, #0]
    c88a:	e7f4      	b.n	c876 <app_at_send_at_rsp_cgcontrdp_string+0xae>
            len += (uint16)snprintf(cgcontrdp_string + len,  AT_CGCONTRDP_MAX_STR_LEN - len, "%.*s.", uc_piece_data_len, current_pdp_context.apn_nw + uc_count + 1);
    c88c:	9a05      	ldr	r2, [sp, #20]
    c88e:	1928      	adds	r0, r5, r4
    c890:	1b11      	subs	r1, r2, r4
    c892:	9a03      	ldr	r2, [sp, #12]
    c894:	3201      	adds	r2, #1
    c896:	189b      	adds	r3, r3, r2
    c898:	9300      	str	r3, [sp, #0]
    c89a:	4a30      	ldr	r2, [pc, #192]	; (c95c <app_at_send_at_rsp_cgcontrdp_string+0x194>)
    c89c:	003b      	movs	r3, r7
    c89e:	f00d ffe5 	bl	1a86c <snprintf>
            uc_count += (uc_piece_data_len + 1);
    c8a2:	9b03      	ldr	r3, [sp, #12]
    c8a4:	3701      	adds	r7, #1
    c8a6:	19df      	adds	r7, r3, r7
            len += (uint16)snprintf(cgcontrdp_string + len,  AT_CGCONTRDP_MAX_STR_LEN - len, "%.*s.", uc_piece_data_len, current_pdp_context.apn_nw + uc_count + 1);
    c8a8:	1824      	adds	r4, r4, r0
            uc_count += (uc_piece_data_len + 1);
    c8aa:	b2bb      	uxth	r3, r7
            len += (uint16)snprintf(cgcontrdp_string + len,  AT_CGCONTRDP_MAX_STR_LEN - len, "%.*s.", uc_piece_data_len, current_pdp_context.apn_nw + uc_count + 1);
    c8ac:	b2a4      	uxth	r4, r4
            uc_count += (uc_piece_data_len + 1);
    c8ae:	9303      	str	r3, [sp, #12]
    c8b0:	e7cc      	b.n	c84c <app_at_send_at_rsp_cgcontrdp_string+0x84>
        || (current_pdp_context.pdp_type == PDN_TYPE_IPV6 && IP_IS_V6_VAL(current->dns_addr)))
    c8b2:	2b02      	cmp	r3, #2
    c8b4:	d1e8      	bne.n	c888 <app_at_send_at_rsp_cgcontrdp_string+0xc0>
    c8b6:	7e33      	ldrb	r3, [r6, #24]
    c8b8:	2b06      	cmp	r3, #6
    c8ba:	d1e5      	bne.n	c888 <app_at_send_at_rsp_cgcontrdp_string+0xc0>
            if (dns_count == 0)
    c8bc:	2f00      	cmp	r7, #0
    c8be:	d10a      	bne.n	c8d6 <app_at_send_at_rsp_cgcontrdp_string+0x10e>
                len += (uint16)snprintf(cgcontrdp_string + len, AT_CGCONTRDP_MAX_STR_LEN - len, ",,");
    c8c0:	23c8      	movs	r3, #200	; 0xc8
    c8c2:	1928      	adds	r0, r5, r4
    c8c4:	1b19      	subs	r1, r3, r4
    c8c6:	4a23      	ldr	r2, [pc, #140]	; (c954 <app_at_send_at_rsp_cgcontrdp_string+0x18c>)
    c8c8:	f00d ffd0 	bl	1a86c <snprintf>
            addr = ipaddr_ntoa(&current->dns_addr); //lint !e506 Constant value Boolean
    c8cc:	7e33      	ldrb	r3, [r6, #24]
                len += (uint16)snprintf(cgcontrdp_string + len, AT_CGCONTRDP_MAX_STR_LEN - len, ",,");
    c8ce:	1824      	adds	r4, r4, r0
    c8d0:	b2a4      	uxth	r4, r4
            addr = ipaddr_ntoa(&current->dns_addr); //lint !e506 Constant value Boolean
    c8d2:	2b06      	cmp	r3, #6
    c8d4:	d134      	bne.n	c940 <app_at_send_at_rsp_cgcontrdp_string+0x178>
    c8d6:	0030      	movs	r0, r6
    c8d8:	3008      	adds	r0, #8
    c8da:	f010 fe15 	bl	1d508 <ip6addr_ntoa>
            len += (uint16)snprintf(cgcontrdp_string + len, AT_CGCONTRDP_MAX_STR_LEN - len, ",%s", addr);
    c8de:	22c8      	movs	r2, #200	; 0xc8
            addr = ipaddr_ntoa(&current->dns_addr); //lint !e506 Constant value Boolean
    c8e0:	0003      	movs	r3, r0
            len += (uint16)snprintf(cgcontrdp_string + len, AT_CGCONTRDP_MAX_STR_LEN - len, ",%s", addr);
    c8e2:	1b11      	subs	r1, r2, r4
    c8e4:	1928      	adds	r0, r5, r4
    c8e6:	4a1e      	ldr	r2, [pc, #120]	; (c960 <app_at_send_at_rsp_cgcontrdp_string+0x198>)
    c8e8:	f00d ffc0 	bl	1a86c <snprintf>
            dns_count++;
    c8ec:	3701      	adds	r7, #1
            len += (uint16)snprintf(cgcontrdp_string + len, AT_CGCONTRDP_MAX_STR_LEN - len, ",%s", addr);
    c8ee:	1824      	adds	r4, r4, r0
            dns_count++;
    c8f0:	b2ff      	uxtb	r7, r7
            len += (uint16)snprintf(cgcontrdp_string + len, AT_CGCONTRDP_MAX_STR_LEN - len, ",%s", addr);
    c8f2:	b2a4      	uxth	r4, r4
        if (dns_count >= AT_MAX_DNS_SERVER_NUMBER)
    c8f4:	2f02      	cmp	r7, #2
    c8f6:	d1c7      	bne.n	c888 <app_at_send_at_rsp_cgcontrdp_string+0xc0>
    if (dnsap != NULL)
    c8f8:	9807      	ldr	r0, [sp, #28]
    c8fa:	2800      	cmp	r0, #0
    c8fc:	d11b      	bne.n	c936 <app_at_send_at_rsp_cgcontrdp_string+0x16e>
    if (line_feed_flag)
    c8fe:	9b04      	ldr	r3, [sp, #16]
    c900:	4c18      	ldr	r4, [pc, #96]	; (c964 <app_at_send_at_rsp_cgcontrdp_string+0x19c>)
    c902:	2b00      	cmp	r3, #0
    c904:	d006      	beq.n	c914 <app_at_send_at_rsp_cgcontrdp_string+0x14c>
        at_uart_write((unsigned char*)APP_AT_STR_RN, strlen(APP_AT_STR_RN));
    c906:	0020      	movs	r0, r4
    c908:	f00e fd49 	bl	1b39e <strlen>
    c90c:	0001      	movs	r1, r0
    c90e:	0020      	movs	r0, r4
    c910:	f7fd f86c 	bl	99ec <at_uart_write>
    app_at_send_at_rsp_string(cgcontrdp_string, true, AT_FLAG_LOGABLE);
    c914:	2208      	movs	r2, #8
    c916:	2101      	movs	r1, #1
    c918:	0028      	movs	r0, r5
    c91a:	f7fc fe55 	bl	95c8 <app_at_send_at_rsp_string>
    at_uart_write((unsigned char*)APP_AT_STR_RN, strlen(APP_AT_STR_RN));
    c91e:	0020      	movs	r0, r4
    c920:	f00e fd3d 	bl	1b39e <strlen>
    c924:	0001      	movs	r1, r0
    c926:	0020      	movs	r0, r4
    c928:	f7fd f860 	bl	99ec <at_uart_write>
    irfree(cgcontrdp_string);
    c92c:	0028      	movs	r0, r5
    c92e:	f006 f883 	bl	12a38 <irfree>
}
    c932:	b041      	add	sp, #260	; 0x104
    c934:	bdf0      	pop	{r4, r5, r6, r7, pc}
        freednsaddrs(dnsap);
    c936:	f010 fb6c 	bl	1d012 <freednsaddrs>
    c93a:	e7e0      	b.n	c8fe <app_at_send_at_rsp_cgcontrdp_string+0x136>
            if (dns_count == 0)
    c93c:	2f00      	cmp	r7, #0
    c93e:	d0bf      	beq.n	c8c0 <app_at_send_at_rsp_cgcontrdp_string+0xf8>
            addr = ipaddr_ntoa(&current->dns_addr); //lint !e506 Constant value Boolean
    c940:	0030      	movs	r0, r6
    c942:	3008      	adds	r0, #8
    c944:	f010 fca6 	bl	1d294 <ip4addr_ntoa>
    c948:	e7c9      	b.n	c8de <app_at_send_at_rsp_cgcontrdp_string+0x116>
    c94a:	46c0      	nop			; (mov r8, r8)
    c94c:	000236e8 	.word	0x000236e8
    c950:	000248db 	.word	0x000248db
    c954:	000238fb 	.word	0x000238fb
    c958:	00024bc5 	.word	0x00024bc5
    c95c:	000234f5 	.word	0x000234f5
    c960:	000237b2 	.word	0x000237b2
    c964:	00022d8f 	.word	0x00022d8f

0000c968 <at_handle_CGCONTRDP_cmd_exec>:
{
    c968:	b57f      	push	{r0, r1, r2, r3, r4, r5, r6, lr}
    uint8                       cids[AT_MAX_CID + 1]      = {0};
    c96a:	ad01      	add	r5, sp, #4
    c96c:	220b      	movs	r2, #11
    c96e:	2100      	movs	r1, #0
    c970:	0028      	movs	r0, r5
    c972:	f7f3 fcb5 	bl	2e0 <memset>
    result = get_defined_cids(AT_MAX_CID + 1, &cids_num, cids);
    c976:	466b      	mov	r3, sp
    c978:	1c9e      	adds	r6, r3, #2
    c97a:	002a      	movs	r2, r5
    c97c:	0031      	movs	r1, r6
    c97e:	200b      	movs	r0, #11
    c980:	f00f fc7d 	bl	1c27e <get_defined_cids>
    if (result != NEUL_RET_OK)
    c984:	2800      	cmp	r0, #0
    c986:	d00c      	beq.n	c9a2 <at_handle_CGCONTRDP_cmd_exec+0x3a>
}
    c988:	2000      	movs	r0, #0
    c98a:	b004      	add	sp, #16
    c98c:	bd70      	pop	{r4, r5, r6, pc}
        app_at_send_at_rsp_cgcontrdp_string(cids[i], line_feed_flag);
    c98e:	5d28      	ldrb	r0, [r5, r4]
    c990:	f7ff ff1a 	bl	c7c8 <app_at_send_at_rsp_cgcontrdp_string>
        line_feed_flag = false;
    c994:	2100      	movs	r1, #0
    c996:	3401      	adds	r4, #1
    c998:	b224      	sxth	r4, r4
    for(int16 i = 0 ; i < cids_num; i++)
    c99a:	8833      	ldrh	r3, [r6, #0]
    c99c:	429c      	cmp	r4, r3
    c99e:	dbf6      	blt.n	c98e <at_handle_CGCONTRDP_cmd_exec+0x26>
    c9a0:	e7f2      	b.n	c988 <at_handle_CGCONTRDP_cmd_exec+0x20>
    c9a2:	0004      	movs	r4, r0
    bool                        line_feed_flag            = true;
    c9a4:	2101      	movs	r1, #1
    c9a6:	e7f8      	b.n	c99a <at_handle_CGCONTRDP_cmd_exec+0x32>

0000c9a8 <at_handle_CGCONTRDP_cmd_set>:
{
    c9a8:	b537      	push	{r0, r1, r2, r4, r5, lr}
    uint8                       param_num       = 0;
    c9aa:	466b      	mov	r3, sp
    uint16                      cid             = 0;
    c9ac:	466a      	mov	r2, sp
    uint8                       param_num       = 0;
    c9ae:	1d59      	adds	r1, r3, #5
    c9b0:	2300      	movs	r3, #0
    uint16                      cid             = 0;
    c9b2:	80d3      	strh	r3, [r2, #6]
    uint8                       param_num       = 0;
    c9b4:	700b      	strb	r3, [r1, #0]
    cause = at_create_param_array(p_atparams_string, &param_num, 1, 1);
    c9b6:	3301      	adds	r3, #1
    uint16                      cid             = 0;
    c9b8:	1d95      	adds	r5, r2, #6
    cause = at_create_param_array(p_atparams_string, &param_num, 1, 1);
    c9ba:	001a      	movs	r2, r3
    c9bc:	f7fd fc92 	bl	a2e4 <at_create_param_array>
    c9c0:	1e04      	subs	r4, r0, #0
    if (cause != AT_RET_OK)
    c9c2:	d109      	bne.n	c9d8 <at_handle_CGCONTRDP_cmd_set+0x30>
    cause = at_get_uint16_param(AT_PARSE_FIRST_PARAM_POS, &cid, true);
    c9c4:	2201      	movs	r2, #1
    c9c6:	0029      	movs	r1, r5
    c9c8:	f7fd fda0 	bl	a50c <at_get_uint16_param>
    c9cc:	1e04      	subs	r4, r0, #0
    if(cause != AT_RET_OK)
    c9ce:	d105      	bne.n	c9dc <at_handle_CGCONTRDP_cmd_set+0x34>
    app_at_send_at_rsp_cgcontrdp_string((uint8)cid, true);
    c9d0:	7828      	ldrb	r0, [r5, #0]
    c9d2:	2101      	movs	r1, #1
    c9d4:	f7ff fef8 	bl	c7c8 <app_at_send_at_rsp_cgcontrdp_string>
}
    c9d8:	0020      	movs	r0, r4
    c9da:	bd3e      	pop	{r1, r2, r3, r4, r5, pc}
        return AT_RET_SYNTAX_ERROR;
    c9dc:	2401      	movs	r4, #1
    c9de:	e7fb      	b.n	c9d8 <at_handle_CGCONTRDP_cmd_set+0x30>

0000c9e0 <at_handle_NDIEID_cmd_exec>:
{
    c9e0:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
    uint16   dieid_length                           = 0;
    c9e2:	466a      	mov	r2, sp
    uint8*    dieid                                     = NULL;
    c9e4:	2300      	movs	r3, #0
    uint16   dieid_length                           = 0;
    c9e6:	1c96      	adds	r6, r2, #2
    if (get_dieid(&dieid_length, &dieid) != NEUL_RET_OK)
    c9e8:	a901      	add	r1, sp, #4
    c9ea:	0030      	movs	r0, r6
    uint8*    dieid                                     = NULL;
    c9ec:	9301      	str	r3, [sp, #4]
    uint16   dieid_length                           = 0;
    c9ee:	8033      	strh	r3, [r6, #0]
    if (get_dieid(&dieid_length, &dieid) != NEUL_RET_OK)
    c9f0:	f00f f832 	bl	1ba58 <get_dieid>
    c9f4:	0004      	movs	r4, r0
        return AT_RET_PROGRESS_ERROR;
    c9f6:	2006      	movs	r0, #6
    if (get_dieid(&dieid_length, &dieid) != NEUL_RET_OK)
    c9f8:	2c00      	cmp	r4, #0
    c9fa:	d136      	bne.n	ca6a <at_handle_NDIEID_cmd_exec+0x8a>
    at_uart_claim();
    c9fc:	f7fc ffd4 	bl	99a8 <at_uart_claim>
    at_uart_write((uint8*)APP_AT_STR_RN, strlen(APP_AT_STR_RN));
    ca00:	4d1d      	ldr	r5, [pc, #116]	; (ca78 <at_handle_NDIEID_cmd_exec+0x98>)
    ca02:	0028      	movs	r0, r5
    ca04:	f00e fccb 	bl	1b39e <strlen>
    ca08:	0001      	movs	r1, r0
    ca0a:	0028      	movs	r0, r5
    ca0c:	f7fc ffee 	bl	99ec <at_uart_write>
    at_uart_write((uint8*)AT_CMD_DIEID_PREFIX, strlen(AT_CMD_DIEID_PREFIX));
    ca10:	4f1a      	ldr	r7, [pc, #104]	; (ca7c <at_handle_NDIEID_cmd_exec+0x9c>)
    ca12:	0038      	movs	r0, r7
    ca14:	f00e fcc3 	bl	1b39e <strlen>
    ca18:	0001      	movs	r1, r0
    ca1a:	0038      	movs	r0, r7
    ca1c:	f7fc ffe6 	bl	99ec <at_uart_write>
    for (int i=0; i< dieid_length; i++)
    ca20:	8833      	ldrh	r3, [r6, #0]
    ca22:	9801      	ldr	r0, [sp, #4]
    ca24:	42a3      	cmp	r3, r4
    ca26:	dc0c      	bgt.n	ca42 <at_handle_NDIEID_cmd_exec+0x62>
    free_dieid(dieid);
    ca28:	f00f f83e 	bl	1baa8 <free_dieid>
    at_uart_write((uint8*)APP_AT_STR_RN, strlen(APP_AT_STR_RN));
    ca2c:	0028      	movs	r0, r5
    ca2e:	f00e fcb6 	bl	1b39e <strlen>
    ca32:	0001      	movs	r1, r0
    ca34:	0028      	movs	r0, r5
    ca36:	f7fc ffd9 	bl	99ec <at_uart_write>
    at_uart_release();
    ca3a:	f7fc ffc7 	bl	99cc <at_uart_release>
    return AT_RET_OK;
    ca3e:	2000      	movs	r0, #0
    ca40:	e013      	b.n	ca6a <at_handle_NDIEID_cmd_exec+0x8a>
        if (at_parse_buf_to_hex_forward_order(dieid + i, (uint8*)op, 1) == false)//lint !e613
    ca42:	1900      	adds	r0, r0, r4
    ca44:	2201      	movs	r2, #1
    ca46:	4669      	mov	r1, sp
    ca48:	f7fd fb77 	bl	a13a <at_parse_buf_to_hex_forward_order>
    ca4c:	2800      	cmp	r0, #0
    ca4e:	d10d      	bne.n	ca6c <at_handle_NDIEID_cmd_exec+0x8c>
            free_dieid(dieid);
    ca50:	9801      	ldr	r0, [sp, #4]
    ca52:	f00f f829 	bl	1baa8 <free_dieid>
            at_uart_write((uint8*)APP_AT_STR_RN, strlen(APP_AT_STR_RN));
    ca56:	0028      	movs	r0, r5
    ca58:	f00e fca1 	bl	1b39e <strlen>
    ca5c:	0001      	movs	r1, r0
    ca5e:	0028      	movs	r0, r5
    ca60:	f7fc ffc4 	bl	99ec <at_uart_write>
            at_uart_release();
    ca64:	f7fc ffb2 	bl	99cc <at_uart_release>
            return AT_RET_PROGRESS_ERROR;
    ca68:	2006      	movs	r0, #6
}
    ca6a:	bdfe      	pop	{r1, r2, r3, r4, r5, r6, r7, pc}
        at_uart_write(op, 2);
    ca6c:	2102      	movs	r1, #2
    ca6e:	4668      	mov	r0, sp
    ca70:	f7fc ffbc 	bl	99ec <at_uart_write>
    for (int i=0; i< dieid_length; i++)
    ca74:	3401      	adds	r4, #1
    ca76:	e7d3      	b.n	ca20 <at_handle_NDIEID_cmd_exec+0x40>
    ca78:	00022d8f 	.word	0x00022d8f
    ca7c:	00023bc5 	.word	0x00023bc5

0000ca80 <at_handle_NXLOG_cmd_set>:
{
    ca80:	b57f      	push	{r0, r1, r2, r3, r4, r5, r6, lr}
    ca82:	0004      	movs	r4, r0
    uint8               str_function[AT_CMD_NRDCTRL_PREFIX_LEN]   = {0};
    ca84:	220b      	movs	r2, #11
    ca86:	2100      	movs	r1, #0
    ca88:	a801      	add	r0, sp, #4
    ca8a:	f7f3 fc29 	bl	2e0 <memset>
    uint16              uart_flag = 0;
    ca8e:	466b      	mov	r3, sp
    ca90:	1c9d      	adds	r5, r3, #2
    ca92:	2300      	movs	r3, #0
    ca94:	802b      	strh	r3, [r5, #0]
    if (at_create_param_array(p_atparams_string, &num_recvparams, 1, 2) != AT_RET_OK)
    ca96:	466b      	mov	r3, sp
    ca98:	1c5e      	adds	r6, r3, #1
    ca9a:	2201      	movs	r2, #1
    ca9c:	2302      	movs	r3, #2
    ca9e:	0031      	movs	r1, r6
    caa0:	0020      	movs	r0, r4
    caa2:	f7fd fc1f 	bl	a2e4 <at_create_param_array>
    caa6:	2800      	cmp	r0, #0
    caa8:	d003      	beq.n	cab2 <at_handle_NXLOG_cmd_set+0x32>
       return AT_RET_SYNTAX_ERROR;
    caaa:	2401      	movs	r4, #1
}
    caac:	0020      	movs	r0, r4
    caae:	b004      	add	sp, #16
    cab0:	bd70      	pop	{r4, r5, r6, pc}
    if (at_get_string_param(AT_PARSE_FIRST_PARAM_POS, str_function, AT_CMD_NRDCTRL_PREFIX_LEN, true) != AT_RET_OK)
    cab2:	2301      	movs	r3, #1
    cab4:	220b      	movs	r2, #11
    cab6:	a901      	add	r1, sp, #4
    cab8:	f7fd fe66 	bl	a788 <at_get_string_param>
    cabc:	1e04      	subs	r4, r0, #0
    cabe:	d1f4      	bne.n	caaa <at_handle_NXLOG_cmd_set+0x2a>
    if (at_strcmp(str_function, AT_CMD_NXLOG_DUMP) == 0)
    cac0:	490f      	ldr	r1, [pc, #60]	; (cb00 <at_handle_NXLOG_cmd_set+0x80>)
    cac2:	a801      	add	r0, sp, #4
    cac4:	f00e fc4c 	bl	1b360 <strcmp>
    cac8:	2800      	cmp	r0, #0
    caca:	d1ee      	bne.n	caaa <at_handle_NXLOG_cmd_set+0x2a>
        if(num_recvparams == 2)
    cacc:	7833      	ldrb	r3, [r6, #0]
    cace:	2b02      	cmp	r3, #2
    cad0:	d00a      	beq.n	cae8 <at_handle_NXLOG_cmd_set+0x68>
        if(0 == uart_flag)
    cad2:	882b      	ldrh	r3, [r5, #0]
    cad4:	2b00      	cmp	r3, #0
    cad6:	d00f      	beq.n	caf8 <at_handle_NXLOG_cmd_set+0x78>
    log_uart_output_response_to_at_uart_callback callback = NULL;
    cad8:	2100      	movs	r1, #0
            cmd_value = NXLOG_OPERATION_DUMP_TO_DEBUG_UART;
    cada:	2004      	movs	r0, #4
    if (log_uart_nxlog_ctrl(cmd_value, callback) != NEUL_RET_OK)
    cadc:	f7fa f81c 	bl	6b18 <log_uart_nxlog_ctrl>
    cae0:	2800      	cmp	r0, #0
    cae2:	d0e3      	beq.n	caac <at_handle_NXLOG_cmd_set+0x2c>
        return AT_RET_PROGRESS_ERROR;
    cae4:	2406      	movs	r4, #6
    cae6:	e7e1      	b.n	caac <at_handle_NXLOG_cmd_set+0x2c>
            cause = at_get_uint16_param(AT_PARSE_SECOND_PARAM_POS, &uart_flag, true);
    cae8:	2201      	movs	r2, #1
    caea:	0029      	movs	r1, r5
    caec:	0010      	movs	r0, r2
    caee:	f7fd fd0d 	bl	a50c <at_get_uint16_param>
            if(AT_RET_OK != cause)
    caf2:	2800      	cmp	r0, #0
    caf4:	d0ed      	beq.n	cad2 <at_handle_NXLOG_cmd_set+0x52>
    caf6:	e7d8      	b.n	caaa <at_handle_NXLOG_cmd_set+0x2a>
            callback  = nxlog_output_response_to_at_uart_callback;
    caf8:	4902      	ldr	r1, [pc, #8]	; (cb04 <at_handle_NXLOG_cmd_set+0x84>)
            cmd_value = NXLOG_OPERATION_DUMP_TO_AT_UART;
    cafa:	2003      	movs	r0, #3
    cafc:	e7ee      	b.n	cadc <at_handle_NXLOG_cmd_set+0x5c>
    cafe:	46c0      	nop			; (mov r8, r8)
    cb00:	00023db4 	.word	0x00023db4
    cb04:	0000bcc1 	.word	0x0000bcc1

0000cb08 <at_handle_CNMPSD_cmd_exec>:
{
    cb08:	b510      	push	{r4, lr}
    if (rai_req() != NEUL_RET_OK)
    cb0a:	f00f ff1d 	bl	1c948 <rai_req>
        return AT_RET_PROGRESS_ERROR;
    cb0e:	2306      	movs	r3, #6
    if (rai_req() != NEUL_RET_OK)
    cb10:	2800      	cmp	r0, #0
    cb12:	d100      	bne.n	cb16 <at_handle_CNMPSD_cmd_exec+0xe>
    return AT_RET_OK;
    cb14:	0003      	movs	r3, r0
}
    cb16:	0018      	movs	r0, r3
    cb18:	bd10      	pop	{r4, pc}
	...

0000cb1c <nipinfo_callback>:
{
    cb1c:	b5f0      	push	{r4, r5, r6, r7, lr}
    char        auc_rsp_data[AT_MAX_IP_INFO_LEN] = {0};
    cb1e:	2550      	movs	r5, #80	; 0x50
{
    cb20:	b0a3      	sub	sp, #140	; 0x8c
    cb22:	9000      	str	r0, [sp, #0]
    cb24:	9101      	str	r1, [sp, #4]
    cb26:	0017      	movs	r7, r2
    char        auc_rsp_data[AT_MAX_IP_INFO_LEN] = {0};
    cb28:	2100      	movs	r1, #0
    cb2a:	002a      	movs	r2, r5
    cb2c:	a80e      	add	r0, sp, #56	; 0x38
{
    cb2e:	001e      	movs	r6, r3
    char        auc_rsp_data[AT_MAX_IP_INFO_LEN] = {0};
    cb30:	f7f3 fbd6 	bl	2e0 <memset>
    uc_len = (uint16)snprintf(auc_rsp_data, AT_MAX_IP_INFO_LEN, "+NIPINFO:");
    cb34:	4a22      	ldr	r2, [pc, #136]	; (cbc0 <nipinfo_callback+0xa4>)
    cb36:	0029      	movs	r1, r5
    cb38:	a80e      	add	r0, sp, #56	; 0x38
    cb3a:	f00d fe97 	bl	1a86c <snprintf>
    uc_len += (uint16)snprintf(auc_rsp_data + uc_len, AT_MAX_IP_INFO_LEN - uc_len, "%d", cid);
    cb3e:	ab0e      	add	r3, sp, #56	; 0x38
    uc_len = (uint16)snprintf(auc_rsp_data, AT_MAX_IP_INFO_LEN, "+NIPINFO:");
    cb40:	b284      	uxth	r4, r0
    uc_len += (uint16)snprintf(auc_rsp_data + uc_len, AT_MAX_IP_INFO_LEN - uc_len, "%d", cid);
    cb42:	1b29      	subs	r1, r5, r4
    cb44:	1918      	adds	r0, r3, r4
    cb46:	4a1f      	ldr	r2, [pc, #124]	; (cbc4 <nipinfo_callback+0xa8>)
    cb48:	9b00      	ldr	r3, [sp, #0]
    cb4a:	f00d fe8f 	bl	1a86c <snprintf>
    cb4e:	1824      	adds	r4, r4, r0
    cb50:	b2a4      	uxth	r4, r4
    cb52:	ab0e      	add	r3, sp, #56	; 0x38
    cb54:	1918      	adds	r0, r3, r4
    cb56:	1b29      	subs	r1, r5, r4
        uc_len += (uint16)snprintf(auc_rsp_data + uc_len, AT_MAX_IP_INFO_LEN - uc_len, ",\"IP\",");
    cb58:	4a1b      	ldr	r2, [pc, #108]	; (cbc8 <nipinfo_callback+0xac>)
    if(requested_ip_type == PDN_TYPE_IPV4)
    cb5a:	2f01      	cmp	r7, #1
    cb5c:	d006      	beq.n	cb6c <nipinfo_callback+0x50>
        uc_len += (uint16)snprintf(auc_rsp_data + uc_len, AT_MAX_IP_INFO_LEN - uc_len, ",\"IPV6\",");
    cb5e:	4a1b      	ldr	r2, [pc, #108]	; (cbcc <nipinfo_callback+0xb0>)
    else if(requested_ip_type == PDN_TYPE_IPV6)
    cb60:	2f02      	cmp	r7, #2
    cb62:	d003      	beq.n	cb6c <nipinfo_callback+0x50>
        uc_len += (uint16)snprintf(auc_rsp_data + uc_len, AT_MAX_IP_INFO_LEN - uc_len, ",\"IPV4V6\",");
    cb64:	4a1a      	ldr	r2, [pc, #104]	; (cbd0 <nipinfo_callback+0xb4>)
    else if(requested_ip_type == PDN_TYPE_IPV4V6)
    cb66:	2f03      	cmp	r7, #3
    cb68:	d000      	beq.n	cb6c <nipinfo_callback+0x50>
        uc_len += (uint16)snprintf(auc_rsp_data + uc_len, AT_MAX_IP_INFO_LEN - uc_len, ",\"NONIP\",");
    cb6a:	4a1a      	ldr	r2, [pc, #104]	; (cbd4 <nipinfo_callback+0xb8>)
    cb6c:	f00d fe7e 	bl	1a86c <snprintf>
    cb70:	1824      	adds	r4, r4, r0
    cb72:	b2a4      	uxth	r4, r4
    if(!failure_cause)
    cb74:	2e00      	cmp	r6, #0
    cb76:	d11c      	bne.n	cbb2 <nipinfo_callback+0x96>
        char addr_string[AT_MAX_IP_ADDR_LEN] = {0};
    cb78:	222a      	movs	r2, #42	; 0x2a
    cb7a:	0031      	movs	r1, r6
    cb7c:	a803      	add	r0, sp, #12
    cb7e:	f7f3 fbaf 	bl	2e0 <memset>
        if (get_ip_addr(cid, current_ip_type, addr_string, AT_MAX_IP_ADDR_LEN) != AT_RET_OK)
    cb82:	232a      	movs	r3, #42	; 0x2a
    cb84:	aa03      	add	r2, sp, #12
    cb86:	9901      	ldr	r1, [sp, #4]
    cb88:	9800      	ldr	r0, [sp, #0]
    cb8a:	f7fc fb97 	bl	92bc <get_ip_addr>
    cb8e:	2800      	cmp	r0, #0
    cb90:	d10d      	bne.n	cbae <nipinfo_callback+0x92>
        uc_len += (uint16)snprintf(auc_rsp_data + uc_len, AT_MAX_IP_INFO_LEN - uc_len, "%s", addr_string);
    cb92:	2150      	movs	r1, #80	; 0x50
    cb94:	ab0e      	add	r3, sp, #56	; 0x38
    cb96:	4a10      	ldr	r2, [pc, #64]	; (cbd8 <nipinfo_callback+0xbc>)
    cb98:	1918      	adds	r0, r3, r4
    cb9a:	1b09      	subs	r1, r1, r4
    cb9c:	ab03      	add	r3, sp, #12
        uc_len += (uint16)snprintf(auc_rsp_data + uc_len, AT_MAX_IP_INFO_LEN - uc_len, ",%d", failure_cause);
    cb9e:	f00d fe65 	bl	1a86c <snprintf>
    delayed_async_print(auc_rsp_data, AT_FLAG_LOGABLE, 0, 0);
    cba2:	2300      	movs	r3, #0
    cba4:	2108      	movs	r1, #8
    cba6:	001a      	movs	r2, r3
    cba8:	a80e      	add	r0, sp, #56	; 0x38
    cbaa:	f7fe f887 	bl	acbc <delayed_async_print>
}
    cbae:	b023      	add	sp, #140	; 0x8c
    cbb0:	bdf0      	pop	{r4, r5, r6, r7, pc}
        uc_len += (uint16)snprintf(auc_rsp_data + uc_len, AT_MAX_IP_INFO_LEN - uc_len, ",%d", failure_cause);
    cbb2:	2150      	movs	r1, #80	; 0x50
    cbb4:	ab0e      	add	r3, sp, #56	; 0x38
    cbb6:	1918      	adds	r0, r3, r4
    cbb8:	1b09      	subs	r1, r1, r4
    cbba:	0033      	movs	r3, r6
    cbbc:	4a07      	ldr	r2, [pc, #28]	; (cbdc <nipinfo_callback+0xc0>)
    cbbe:	e7ee      	b.n	cb9e <nipinfo_callback+0x82>
    cbc0:	00024874 	.word	0x00024874
    cbc4:	00022e8f 	.word	0x00022e8f
    cbc8:	0002487e 	.word	0x0002487e
    cbcc:	00024885 	.word	0x00024885
    cbd0:	0002488e 	.word	0x0002488e
    cbd4:	00024899 	.word	0x00024899
    cbd8:	000237d7 	.word	0x000237d7
    cbdc:	0002394e 	.word	0x0002394e

0000cbe0 <at_handle_NATSPEED_cmd_read>:
{
    cbe0:	b510      	push	{r4, lr}
    cbe2:	b096      	sub	sp, #88	; 0x58
    char              rsp_string[AT_NATSPEED_RSP_MAX_LEN] = {0};
    cbe4:	2239      	movs	r2, #57	; 0x39
    cbe6:	2100      	movs	r1, #0
    cbe8:	a807      	add	r0, sp, #28
    if (!at_uart_read_current_config(&uart_config))
    cbea:	ac05      	add	r4, sp, #20
    char              rsp_string[AT_NATSPEED_RSP_MAX_LEN] = {0};
    cbec:	f7f3 fb78 	bl	2e0 <memset>
    if (!at_uart_read_current_config(&uart_config))
    cbf0:	0020      	movs	r0, r4
    cbf2:	f7fd f849 	bl	9c88 <at_uart_read_current_config>
        return AT_RET_PROGRESS_ERROR;
    cbf6:	2306      	movs	r3, #6
    if (!at_uart_read_current_config(&uart_config))
    cbf8:	2800      	cmp	r0, #0
    cbfa:	d011      	beq.n	cc20 <at_handle_NATSPEED_cmd_read+0x40>
    (void)snprintf(rsp_string, AT_NATSPEED_RSP_MAX_LEN, "+NATSPEED:%d,%d,%d,%d,%d", uart_config.baudrate, uart_config.syncmode, uart_config.stopbits, uart_config.parity, uart_config.sw_flow_control);
    cbfc:	79e3      	ldrb	r3, [r4, #7]
    cbfe:	4a0a      	ldr	r2, [pc, #40]	; (cc28 <at_handle_NATSPEED_cmd_read+0x48>)
    cc00:	9303      	str	r3, [sp, #12]
    cc02:	79a3      	ldrb	r3, [r4, #6]
    cc04:	2139      	movs	r1, #57	; 0x39
    cc06:	9302      	str	r3, [sp, #8]
    cc08:	7963      	ldrb	r3, [r4, #5]
    cc0a:	a807      	add	r0, sp, #28
    cc0c:	9301      	str	r3, [sp, #4]
    cc0e:	7923      	ldrb	r3, [r4, #4]
    cc10:	9300      	str	r3, [sp, #0]
    cc12:	9b05      	ldr	r3, [sp, #20]
    cc14:	f00d fe2a 	bl	1a86c <snprintf>
    app_at_send_at_rsp_string_lines_with_claim_and_log(rsp_string);
    cc18:	a807      	add	r0, sp, #28
    cc1a:	f7fc fce3 	bl	95e4 <app_at_send_at_rsp_string_lines_with_claim_and_log>
    return AT_RET_OK;
    cc1e:	2300      	movs	r3, #0
}
    cc20:	0018      	movs	r0, r3
    cc22:	b016      	add	sp, #88	; 0x58
    cc24:	bd10      	pop	{r4, pc}
    cc26:	46c0      	nop			; (mov r8, r8)
    cc28:	000239cc 	.word	0x000239cc

0000cc2c <output_ue_stats_radio>:
{
    cc2c:	b5f0      	push	{r4, r5, r6, r7, lr}
    cc2e:	b08d      	sub	sp, #52	; 0x34
    cc30:	000e      	movs	r6, r1
    cc32:	0004      	movs	r4, r0
    char        ue_stats_rsp[AT_MAX_UESTATS_RSP_LEN] = {0};
    cc34:	2228      	movs	r2, #40	; 0x28
    cc36:	2100      	movs	r1, #0
    cc38:	a802      	add	r0, sp, #8
    cc3a:	f7f3 fb51 	bl	2e0 <memset>
    at_uart_claim();
    cc3e:	f7fc feb3 	bl	99a8 <at_uart_claim>
    if (!prefix)
    cc42:	2e00      	cmp	r6, #0
    cc44:	d107      	bne.n	cc56 <output_ue_stats_radio+0x2a>
        at_uart_write((unsigned char*)APP_AT_STR_RN, strlen(APP_AT_STR_RN));
    cc46:	4d2f      	ldr	r5, [pc, #188]	; (cd04 <output_ue_stats_radio+0xd8>)
    cc48:	0028      	movs	r0, r5
    cc4a:	f00e fba8 	bl	1b39e <strlen>
    cc4e:	0001      	movs	r1, r0
    cc50:	0028      	movs	r0, r5
    cc52:	f7fc fecb 	bl	99ec <at_uart_write>
{
    cc56:	2501      	movs	r5, #1
        memset(ue_stats_rsp, 0, sizeof(ue_stats_rsp));
    cc58:	2228      	movs	r2, #40	; 0x28
    cc5a:	2100      	movs	r1, #0
    cc5c:	a802      	add	r0, sp, #8
    cc5e:	f7f3 fb3f 	bl	2e0 <memset>
            rsp_len = 0;
    cc62:	2200      	movs	r2, #0
        if (prefix)
    cc64:	4296      	cmp	r6, r2
    cc66:	d008      	beq.n	cc7a <output_ue_stats_radio+0x4e>
            rsp_len = (uint16)snprintf(ue_stats_rsp, AT_MAX_UESTATS_RSP_LEN, "%s%s,", AT_CMD_NEUSTATS_RSP_PREFIX, AT_CMD_NUESTATS_RADIO);
    cc68:	4b27      	ldr	r3, [pc, #156]	; (cd08 <output_ue_stats_radio+0xdc>)
    cc6a:	4a28      	ldr	r2, [pc, #160]	; (cd0c <output_ue_stats_radio+0xe0>)
    cc6c:	9300      	str	r3, [sp, #0]
    cc6e:	2128      	movs	r1, #40	; 0x28
    cc70:	4b27      	ldr	r3, [pc, #156]	; (cd10 <output_ue_stats_radio+0xe4>)
    cc72:	a802      	add	r0, sp, #8
    cc74:	f00d fdfa 	bl	1a86c <snprintf>
    cc78:	b282      	uxth	r2, r0
        switch (index) {
    cc7a:	1ea8      	subs	r0, r5, #2
    cc7c:	4925      	ldr	r1, [pc, #148]	; (cd14 <output_ue_stats_radio+0xe8>)
    cc7e:	00af      	lsls	r7, r5, #2
    cc80:	280b      	cmp	r0, #11
    cc82:	d807      	bhi.n	cc94 <output_ue_stats_radio+0x68>
    cc84:	f7f3 fb8e 	bl	3a4 <__gnu_thumb1_case_uqi>
    cc88:	2422201e 	.word	0x2422201e
    cc8c:	2c2a2826 	.word	0x2c2a2826
    cc90:	3532302e 	.word	0x3532302e
                output_int = ue_stats_bin->signal_power;
    cc94:	6863      	ldr	r3, [r4, #4]
                (void)snprintf(ue_stats_rsp + rsp_len, AT_MAX_UESTATS_RSP_LEN - rsp_len, ue_stats_labels[index], output_uint);
    cc96:	2028      	movs	r0, #40	; 0x28
    cc98:	1a80      	subs	r0, r0, r2
    cc9a:	4684      	mov	ip, r0
    cc9c:	a802      	add	r0, sp, #8
    cc9e:	1880      	adds	r0, r0, r2
    cca0:	59ca      	ldr	r2, [r1, r7]
    cca2:	4661      	mov	r1, ip
    cca4:	f00d fde2 	bl	1a86c <snprintf>
        if (prefix)
    cca8:	2e00      	cmp	r6, #0
    ccaa:	d026      	beq.n	ccfa <output_ue_stats_radio+0xce>
            app_at_send_at_rsp_string_lines(ue_stats_rsp, false, AT_FLAG_LOGABLE | AT_FLAG_LOG_RESTRICTED);
    ccac:	2228      	movs	r2, #40	; 0x28
    ccae:	2100      	movs	r1, #0
    ccb0:	a802      	add	r0, sp, #8
    ccb2:	f7fc fc90 	bl	95d6 <app_at_send_at_rsp_string_lines>
    for (int index = UE_STATS_SIGNAL_POWER; index < UE_STATS_LAST_LABEL; index++)
    ccb6:	3501      	adds	r5, #1
    ccb8:	2d0e      	cmp	r5, #14
    ccba:	d1cd      	bne.n	cc58 <output_ue_stats_radio+0x2c>
    at_uart_release();
    ccbc:	f7fc fe86 	bl	99cc <at_uart_release>
}
    ccc0:	b00d      	add	sp, #52	; 0x34
    ccc2:	bdf0      	pop	{r4, r5, r6, r7, pc}
                output_int = ue_stats_bin->total_power;
    ccc4:	68a3      	ldr	r3, [r4, #8]
                break;
    ccc6:	e7e6      	b.n	cc96 <output_ue_stats_radio+0x6a>
                output_int = ue_stats_bin->tx_power;
    ccc8:	68e3      	ldr	r3, [r4, #12]
                break;
    ccca:	e7e4      	b.n	cc96 <output_ue_stats_radio+0x6a>
                output_uint = ue_stats_bin->tx_time;
    cccc:	6923      	ldr	r3, [r4, #16]
                break;
    ccce:	e7e2      	b.n	cc96 <output_ue_stats_radio+0x6a>
                output_uint = ue_stats_bin->rx_time;
    ccd0:	6963      	ldr	r3, [r4, #20]
                break;
    ccd2:	e7e0      	b.n	cc96 <output_ue_stats_radio+0x6a>
                output_uint = ue_stats_bin->cell_id;
    ccd4:	69a3      	ldr	r3, [r4, #24]
                break;
    ccd6:	e7de      	b.n	cc96 <output_ue_stats_radio+0x6a>
                output_uint = (uint32)ue_stats_bin->current_ecl;
    ccd8:	7fe3      	ldrb	r3, [r4, #31]
                break;
    ccda:	e7dc      	b.n	cc96 <output_ue_stats_radio+0x6a>
                output_int = ue_stats_bin->snr;
    ccdc:	6a23      	ldr	r3, [r4, #32]
                break;
    ccde:	e7da      	b.n	cc96 <output_ue_stats_radio+0x6a>
                output_uint = ue_stats_bin->earfcn;
    cce0:	6a63      	ldr	r3, [r4, #36]	; 0x24
                break;
    cce2:	e7d8      	b.n	cc96 <output_ue_stats_radio+0x6a>
                output_uint = (uint32)ue_stats_bin->pci;
    cce4:	8863      	ldrh	r3, [r4, #2]
                break;
    cce6:	e7d6      	b.n	cc96 <output_ue_stats_radio+0x6a>
                output_int = ue_stats_bin->rsrq;
    cce8:	6aa3      	ldr	r3, [r4, #40]	; 0x28
                break;
    ccea:	e7d4      	b.n	cc96 <output_ue_stats_radio+0x6a>
                output_int = ue_stats_bin->operation_mode;
    ccec:	202c      	movs	r0, #44	; 0x2c
    ccee:	5e23      	ldrsh	r3, [r4, r0]
                break;
    ccf0:	e7d1      	b.n	cc96 <output_ue_stats_radio+0x6a>
                output_int = ue_stats_bin->current_band;
    ccf2:	0023      	movs	r3, r4
    ccf4:	332e      	adds	r3, #46	; 0x2e
    ccf6:	781b      	ldrb	r3, [r3, #0]
                break;
    ccf8:	e7cd      	b.n	cc96 <output_ue_stats_radio+0x6a>
            app_at_send_at_rsp_string_rn_no_claim(ue_stats_rsp, AT_FLAG_LOGABLE | AT_FLAG_LOG_RESTRICTED);
    ccfa:	2128      	movs	r1, #40	; 0x28
    ccfc:	a802      	add	r0, sp, #8
    ccfe:	f7fc fc7f 	bl	9600 <app_at_send_at_rsp_string_rn_no_claim>
    cd02:	e7d8      	b.n	ccb6 <output_ue_stats_radio+0x8a>
    cd04:	00022d8f 	.word	0x00022d8f
    cd08:	00024916 	.word	0x00024916
    cd0c:	000248f2 	.word	0x000248f2
    cd10:	000248e8 	.word	0x000248e8
    cd14:	00025124 	.word	0x00025124

0000cd18 <at_handle_CGDATA_cmd_set>:
{
    cd18:	b5f0      	push	{r4, r5, r6, r7, lr}
    cause = at_create_param_array(p_atparams_string, &num_recvparams, 0, 2);
    cd1a:	2709      	movs	r7, #9
{
    cd1c:	b0c1      	sub	sp, #260	; 0x104
    cd1e:	0004      	movs	r4, r0
    uint8            L2P_field[AT_MAX_L2P_SIZE] = {0};
    cd20:	2207      	movs	r2, #7
    cd22:	2100      	movs	r1, #0
    cd24:	a804      	add	r0, sp, #16
    uint16           cid = 0;
    cd26:	250a      	movs	r5, #10
    uint8            L2P_field[AT_MAX_L2P_SIZE] = {0};
    cd28:	f7f3 fada 	bl	2e0 <memset>
    uint16           cid = 0;
    cd2c:	2200      	movs	r2, #0
    context.apn = apn_str;
    cd2e:	ab08      	add	r3, sp, #32
    cd30:	ae22      	add	r6, sp, #136	; 0x88
    cause = at_create_param_array(p_atparams_string, &num_recvparams, 0, 2);
    cd32:	446f      	add	r7, sp
    uint16           cid = 0;
    cd34:	446d      	add	r5, sp
    context.apn = apn_str;
    cd36:	60f3      	str	r3, [r6, #12]
    cause = at_create_param_array(p_atparams_string, &num_recvparams, 0, 2);
    cd38:	0039      	movs	r1, r7
    cd3a:	2302      	movs	r3, #2
    cd3c:	0020      	movs	r0, r4
    uint16           cid = 0;
    cd3e:	802a      	strh	r2, [r5, #0]
    cause = at_create_param_array(p_atparams_string, &num_recvparams, 0, 2);
    cd40:	f7fd fad0 	bl	a2e4 <at_create_param_array>
    if (cause != AT_RET_OK)
    cd44:	2800      	cmp	r0, #0
    cd46:	d104      	bne.n	cd52 <at_handle_CGDATA_cmd_set+0x3a>
    if ((num_recvparams < 1) || (num_recvparams > 2))
    cd48:	783b      	ldrb	r3, [r7, #0]
    cd4a:	3b01      	subs	r3, #1
    cd4c:	2b01      	cmp	r3, #1
    cd4e:	d902      	bls.n	cd56 <at_handle_CGDATA_cmd_set+0x3e>
        return AT_RET_SYNTAX_ERROR;
    cd50:	2001      	movs	r0, #1
}
    cd52:	b041      	add	sp, #260	; 0x104
    cd54:	bdf0      	pop	{r4, r5, r6, r7, pc}
    cause = at_get_string_param(AT_PARSE_FIRST_PARAM_POS, L2P_field, AT_MAX_L2P_SIZE, true);
    cd56:	2301      	movs	r3, #1
    cd58:	2207      	movs	r2, #7
    cd5a:	a904      	add	r1, sp, #16
    cd5c:	f7fd fd14 	bl	a788 <at_get_string_param>
    if (cause != AT_RET_OK)
    cd60:	2800      	cmp	r0, #0
    cd62:	d1f6      	bne.n	cd52 <at_handle_CGDATA_cmd_set+0x3a>
    else  if (strcmp((char *)L2P_field, L2P_PPP) != 0)
    cd64:	4944      	ldr	r1, [pc, #272]	; (ce78 <at_handle_CGDATA_cmd_set+0x160>)
    cd66:	a804      	add	r0, sp, #16
    cd68:	f00e fafa 	bl	1b360 <strcmp>
    cd6c:	2800      	cmp	r0, #0
    cd6e:	d1ef      	bne.n	cd50 <at_handle_CGDATA_cmd_set+0x38>
    if (num_recvparams > 1)
    cd70:	783b      	ldrb	r3, [r7, #0]
        for(cid_loop = 0; cid_loop <= AT_MAX_CID; cid_loop++)
    cd72:	0004      	movs	r4, r0
                 if ((context.pdp_type == PDN_TYPE_IPV4) || (context.pdp_type == PDN_TYPE_IPV4V6))
    cd74:	2702      	movs	r7, #2
    if (num_recvparams > 1)
    cd76:	2b01      	cmp	r3, #1
    cd78:	d926      	bls.n	cdc8 <at_handle_CGDATA_cmd_set+0xb0>
        cause = at_get_uint16_param(AT_PARSE_SECOND_PARAM_POS, &cid, true);
    cd7a:	2201      	movs	r2, #1
    cd7c:	0029      	movs	r1, r5
    cd7e:	0010      	movs	r0, r2
    cd80:	f7fd fbc4 	bl	a50c <at_get_uint16_param>
        if (cause != AT_RET_OK)
    cd84:	2800      	cmp	r0, #0
    cd86:	d1e4      	bne.n	cd52 <at_handle_CGDATA_cmd_set+0x3a>
        else if (cid <= AT_MAX_CID)
    cd88:	882b      	ldrh	r3, [r5, #0]
    cd8a:	2b0a      	cmp	r3, #10
    cd8c:	d901      	bls.n	cd92 <at_handle_CGDATA_cmd_set+0x7a>
        return AT_RET_CID_INVALID;
    cd8e:	2011      	movs	r0, #17
    cd90:	e7df      	b.n	cd52 <at_handle_CGDATA_cmd_set+0x3a>
            memset(context.apn, 0, NEUL_MAX_APN_SIZE);
    cd92:	0001      	movs	r1, r0
    cd94:	2265      	movs	r2, #101	; 0x65
    cd96:	68f0      	ldr	r0, [r6, #12]
    cd98:	f7f3 faa2 	bl	2e0 <memset>
            if(get_pdp_context((uint8) cid, &context) == NEUL_RET_OK)
    cd9c:	7828      	ldrb	r0, [r5, #0]
    cd9e:	0031      	movs	r1, r6
    cda0:	f00f fad2 	bl	1c348 <get_pdp_context>
    cda4:	2800      	cmp	r0, #0
    cda6:	d1f2      	bne.n	cd8e <at_handle_CGDATA_cmd_set+0x76>
                if ((context.pdp_type == PDN_TYPE_IPV4) || (context.pdp_type == PDN_TYPE_IPV4V6))
    cda8:	2202      	movs	r2, #2
    cdaa:	7933      	ldrb	r3, [r6, #4]
    cdac:	4393      	bics	r3, r2
    cdae:	2b01      	cmp	r3, #1
    cdb0:	d1ed      	bne.n	cd8e <at_handle_CGDATA_cmd_set+0x76>
    if ((getifaddrs(&ifa) != NEUL_RET_OK))  // get IP addresses
    cdb2:	a803      	add	r0, sp, #12
    cdb4:	f010 f888 	bl	1cec8 <getifaddrs>
    cdb8:	2800      	cmp	r0, #0
    cdba:	d016      	beq.n	cdea <at_handle_CGDATA_cmd_set+0xd2>
    return AT_RET_INTERNAL_ERROR;
    cdbc:	200d      	movs	r0, #13
    cdbe:	e7c8      	b.n	cd52 <at_handle_CGDATA_cmd_set+0x3a>
        for(cid_loop = 0; cid_loop <= AT_MAX_CID; cid_loop++)
    cdc0:	3401      	adds	r4, #1
    cdc2:	b2e4      	uxtb	r4, r4
    cdc4:	2c0b      	cmp	r4, #11
    cdc6:	d0e2      	beq.n	cd8e <at_handle_CGDATA_cmd_set+0x76>
             memset(context.apn, 0, NEUL_MAX_APN_SIZE);
    cdc8:	2100      	movs	r1, #0
    cdca:	2265      	movs	r2, #101	; 0x65
    cdcc:	68f0      	ldr	r0, [r6, #12]
    cdce:	f7f3 fa87 	bl	2e0 <memset>
             if(get_pdp_context(cid_loop, &context) == NEUL_RET_OK)
    cdd2:	0031      	movs	r1, r6
    cdd4:	0020      	movs	r0, r4
    cdd6:	f00f fab7 	bl	1c348 <get_pdp_context>
    cdda:	2800      	cmp	r0, #0
    cddc:	d1f0      	bne.n	cdc0 <at_handle_CGDATA_cmd_set+0xa8>
                 if ((context.pdp_type == PDN_TYPE_IPV4) || (context.pdp_type == PDN_TYPE_IPV4V6))
    cdde:	7933      	ldrb	r3, [r6, #4]
    cde0:	43bb      	bics	r3, r7
    cde2:	2b01      	cmp	r3, #1
    cde4:	d1ec      	bne.n	cdc0 <at_handle_CGDATA_cmd_set+0xa8>
                     cid = cid_loop;
    cde6:	802c      	strh	r4, [r5, #0]
    cde8:	e7e3      	b.n	cdb2 <at_handle_CGDATA_cmd_set+0x9a>
    current = ifa;
    cdea:	9c03      	ldr	r4, [sp, #12]
        if ((current->cid == cid) && IP_IS_V4(ip_addr_ptr))  //lint !e774 always evaluates to false
    cdec:	882b      	ldrh	r3, [r5, #0]
    while (current)
    cdee:	2c00      	cmp	r4, #0
    cdf0:	d00f      	beq.n	ce12 <at_handle_CGDATA_cmd_set+0xfa>
        if ((current->cid == cid) && IP_IS_V4(ip_addr_ptr))  //lint !e774 always evaluates to false
    cdf2:	2108      	movs	r1, #8
    cdf4:	5e62      	ldrsh	r2, [r4, r1]
    cdf6:	429a      	cmp	r2, r3
    cdf8:	d137      	bne.n	ce6a <at_handle_CGDATA_cmd_set+0x152>
    cdfa:	1c62      	adds	r2, r4, #1
    cdfc:	7fd2      	ldrb	r2, [r2, #31]
    cdfe:	2a00      	cmp	r2, #0
    ce00:	d133      	bne.n	ce6a <at_handle_CGDATA_cmd_set+0x152>
           if (!ip_addr_isany(ip_addr_ptr))
    ce02:	6922      	ldr	r2, [r4, #16]
    ce04:	2a00      	cmp	r2, #0
    ce06:	d030      	beq.n	ce6a <at_handle_CGDATA_cmd_set+0x152>
        ip_addr_t *ip_addr_ptr = &current->ifa_addr;
    ce08:	0020      	movs	r0, r4
    ce0a:	3010      	adds	r0, #16
               pppd_set_ip_address(&current->ifa_addr);
    ce0c:	f010 fe9c 	bl	1db48 <pppd_set_ip_address>
               valid_address_set = true;
    ce10:	2401      	movs	r4, #1
    if (ifa != NULL)
    ce12:	9803      	ldr	r0, [sp, #12]
    ce14:	2800      	cmp	r0, #0
    ce16:	d001      	beq.n	ce1c <at_handle_CGDATA_cmd_set+0x104>
        freeifaddrs(ifa);
    ce18:	f010 f846 	bl	1cea8 <freeifaddrs>
    if (!valid_address_set)
    ce1c:	2c00      	cmp	r4, #0
    ce1e:	d0b6      	beq.n	cd8e <at_handle_CGDATA_cmd_set+0x76>
    if (at_uart_read_current_config(&config))
    ce20:	ac06      	add	r4, sp, #24
    ce22:	0020      	movs	r0, r4
    ce24:	f7fc ff30 	bl	9c88 <at_uart_read_current_config>
    ce28:	2800      	cmp	r0, #0
    ce2a:	d020      	beq.n	ce6e <at_handle_CGDATA_cmd_set+0x156>
        if (!ppp_set_serial_config(CHIP_FIXED_TX_PIN, CHIP_FIXED_RX_PIN, PIN_NONE, PIN_NONE, config.baudrate, (bool)config.sw_flow_control))
    ce2c:	79e3      	ldrb	r3, [r4, #7]
    ce2e:	210d      	movs	r1, #13
    ce30:	1e5a      	subs	r2, r3, #1
    ce32:	4193      	sbcs	r3, r2
    ce34:	9301      	str	r3, [sp, #4]
    ce36:	9b06      	ldr	r3, [sp, #24]
    ce38:	2012      	movs	r0, #18
    ce3a:	9300      	str	r3, [sp, #0]
    ce3c:	2328      	movs	r3, #40	; 0x28
    ce3e:	001a      	movs	r2, r3
    ce40:	f010 fe58 	bl	1daf4 <ppp_set_serial_config>
    ce44:	0003      	movs	r3, r0
            return AT_RET_CONFIGURATION_CONFLICTS;
    ce46:	2020      	movs	r0, #32
        if (!ppp_set_serial_config(CHIP_FIXED_TX_PIN, CHIP_FIXED_RX_PIN, PIN_NONE, PIN_NONE, config.baudrate, (bool)config.sw_flow_control))
    ce48:	2b00      	cmp	r3, #0
    ce4a:	d100      	bne.n	ce4e <at_handle_CGDATA_cmd_set+0x136>
    ce4c:	e781      	b.n	cd52 <at_handle_CGDATA_cmd_set+0x3a>
        ppp_set_ppp_exit_callback(at_uart_mark_need_change_to_at);
    ce4e:	480b      	ldr	r0, [pc, #44]	; (ce7c <at_handle_CGDATA_cmd_set+0x164>)
    ce50:	f010 fe74 	bl	1db3c <ppp_set_ppp_exit_callback>
        if (at_uart_mark_need_change_to_ppp())
    ce54:	f7fc ff68 	bl	9d28 <at_uart_mark_need_change_to_ppp>
    ce58:	2800      	cmp	r0, #0
    ce5a:	d0af      	beq.n	cdbc <at_handle_CGDATA_cmd_set+0xa4>
            app_at_send_at_rsp_string_lines("CONNECTED", true, AT_FLAG_LOGABLE);
    ce5c:	4808      	ldr	r0, [pc, #32]	; (ce80 <at_handle_CGDATA_cmd_set+0x168>)
    ce5e:	2208      	movs	r2, #8
    ce60:	2101      	movs	r1, #1
    ce62:	f7fc fbb8 	bl	95d6 <app_at_send_at_rsp_string_lines>
            return AT_RET_CMD_IN_PROGRESS_BLOCK;
    ce66:	2009      	movs	r0, #9
    ce68:	e773      	b.n	cd52 <at_handle_CGDATA_cmd_set+0x3a>
        current = current->ifa_next;
    ce6a:	6824      	ldr	r4, [r4, #0]
    ce6c:	e7bf      	b.n	cdee <at_handle_CGDATA_cmd_set+0xd6>
        panic(PANIC_AT_CMD, APP_AT_PANIC_INVALID_CONFIG);
    ce6e:	2101      	movs	r1, #1
    ce70:	2002      	movs	r0, #2
    ce72:	f7f4 fe4d 	bl	1b10 <panic>
    ce76:	e7a1      	b.n	cdbc <at_handle_CGDATA_cmd_set+0xa4>
    ce78:	000236f4 	.word	0x000236f4
    ce7c:	00009d51 	.word	0x00009d51
    ce80:	000236f8 	.word	0x000236f8

0000ce84 <at_handle_CIPCA_cmd_read>:
{
    ce84:	b530      	push	{r4, r5, lr}
    if (get_initial_pdp_context(&attach_without_pdn) != NEUL_RET_OK)
    ce86:	250b      	movs	r5, #11
{
    ce88:	b087      	sub	sp, #28
    char               rsp_string[AT_CMD_CIPCA_READ_RES_MAX_LEN]      = {0};
    ce8a:	220b      	movs	r2, #11
    ce8c:	2100      	movs	r1, #0
    ce8e:	a803      	add	r0, sp, #12
    if (get_initial_pdp_context(&attach_without_pdn) != NEUL_RET_OK)
    ce90:	446d      	add	r5, sp
    char               rsp_string[AT_CMD_CIPCA_READ_RES_MAX_LEN]      = {0};
    ce92:	f7f3 fa25 	bl	2e0 <memset>
    if (get_initial_pdp_context(&attach_without_pdn) != NEUL_RET_OK)
    ce96:	0028      	movs	r0, r5
    ce98:	f00f fd08 	bl	1c8ac <get_initial_pdp_context>
    ce9c:	0004      	movs	r4, r0
        return AT_RET_PROGRESS_ERROR;
    ce9e:	2006      	movs	r0, #6
    if (get_initial_pdp_context(&attach_without_pdn) != NEUL_RET_OK)
    cea0:	2c00      	cmp	r4, #0
    cea2:	d10d      	bne.n	cec0 <at_handle_CIPCA_cmd_read+0x3c>
    (void)snprintf(rsp_string, AT_CMD_CIPCA_READ_RES_MAX_LEN, "%s%d,%d", AT_CMD_CIPCA_STR, AT_CMD_CIPCA_PDP_CONTEXT_MODE, attach_without_pdn);
    cea4:	782b      	ldrb	r3, [r5, #0]
    cea6:	4a07      	ldr	r2, [pc, #28]	; (cec4 <at_handle_CIPCA_cmd_read+0x40>)
    cea8:	9301      	str	r3, [sp, #4]
    ceaa:	2303      	movs	r3, #3
    ceac:	210b      	movs	r1, #11
    ceae:	9300      	str	r3, [sp, #0]
    ceb0:	a803      	add	r0, sp, #12
    ceb2:	4b05      	ldr	r3, [pc, #20]	; (cec8 <at_handle_CIPCA_cmd_read+0x44>)
    ceb4:	f00d fcda 	bl	1a86c <snprintf>
    app_at_send_at_rsp_string_lines_with_claim_and_log(rsp_string);
    ceb8:	a803      	add	r0, sp, #12
    ceba:	f7fc fb93 	bl	95e4 <app_at_send_at_rsp_string_lines_with_claim_and_log>
    return AT_RET_OK;
    cebe:	0020      	movs	r0, r4
}
    cec0:	b007      	add	sp, #28
    cec2:	bd30      	pop	{r4, r5, pc}
    cec4:	00023e83 	.word	0x00023e83
    cec8:	00023869 	.word	0x00023869

0000cecc <at_handle_CIPCA_cmd_set>:
{
    cecc:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
    uint16             attach_without_pdn                = NEUL_CIPCA_WITHOUT_PDN_VALUE;
    cece:	466b      	mov	r3, sp
    ced0:	1d9d      	adds	r5, r3, #6
    ced2:	23ff      	movs	r3, #255	; 0xff
    ced4:	802b      	strh	r3, [r5, #0]
    cause = at_create_param_array(p_atparams_string, &num_recvparams, 0, 2);
    ced6:	466b      	mov	r3, sp
    ced8:	1cde      	adds	r6, r3, #3
    ceda:	2200      	movs	r2, #0
    cedc:	2302      	movs	r3, #2
    cede:	0031      	movs	r1, r6
    cee0:	f7fd fa00 	bl	a2e4 <at_create_param_array>
    cee4:	1e04      	subs	r4, r0, #0
    if (cause != AT_RET_OK)
    cee6:	d117      	bne.n	cf18 <at_handle_CIPCA_cmd_set+0x4c>
    if (num_recvparams > 0)
    cee8:	7833      	ldrb	r3, [r6, #0]
    ceea:	2b00      	cmp	r3, #0
    ceec:	d109      	bne.n	cf02 <at_handle_CIPCA_cmd_set+0x36>
    if (num_recvparams > 1)
    ceee:	7833      	ldrb	r3, [r6, #0]
    cef0:	2b01      	cmp	r3, #1
    cef2:	d813      	bhi.n	cf1c <at_handle_CIPCA_cmd_set+0x50>
    if (set_initial_pdp_context((uint8)attach_without_pdn) != NEUL_RET_OK)
    cef4:	7828      	ldrb	r0, [r5, #0]
    cef6:	f00f fccd 	bl	1c894 <set_initial_pdp_context>
    cefa:	2800      	cmp	r0, #0
    cefc:	d00c      	beq.n	cf18 <at_handle_CIPCA_cmd_set+0x4c>
        return AT_RET_PROGRESS_ERROR;
    cefe:	2406      	movs	r4, #6
    cf00:	e00a      	b.n	cf18 <at_handle_CIPCA_cmd_set+0x4c>
        cause = at_get_uint16_param(AT_PARSE_FIRST_PARAM_POS, &active_initial_pdp_context_mode, true);
    cf02:	af01      	add	r7, sp, #4
    cf04:	2201      	movs	r2, #1
    cf06:	0039      	movs	r1, r7
    cf08:	f7fd fb00 	bl	a50c <at_get_uint16_param>
        if (cause != AT_RET_OK)
    cf0c:	2800      	cmp	r0, #0
    cf0e:	d110      	bne.n	cf32 <at_handle_CIPCA_cmd_set+0x66>
        if (active_initial_pdp_context_mode != 3)
    cf10:	883b      	ldrh	r3, [r7, #0]
    cf12:	2b03      	cmp	r3, #3
    cf14:	d0eb      	beq.n	ceee <at_handle_CIPCA_cmd_set+0x22>
            return AT_RET_SYNTAX_ERROR;
    cf16:	2401      	movs	r4, #1
}
    cf18:	0020      	movs	r0, r4
    cf1a:	bdfe      	pop	{r1, r2, r3, r4, r5, r6, r7, pc}
        cause = at_get_uint16_param(AT_PARSE_SECOND_PARAM_POS, &attach_without_pdn, true);
    cf1c:	2201      	movs	r2, #1
    cf1e:	0029      	movs	r1, r5
    cf20:	0010      	movs	r0, r2
    cf22:	f7fd faf3 	bl	a50c <at_get_uint16_param>
        if (cause != AT_RET_OK)
    cf26:	2800      	cmp	r0, #0
    cf28:	d103      	bne.n	cf32 <at_handle_CIPCA_cmd_set+0x66>
        if (attach_without_pdn != 0 && attach_without_pdn != 1)
    cf2a:	882b      	ldrh	r3, [r5, #0]
    cf2c:	2b01      	cmp	r3, #1
    cf2e:	d8f2      	bhi.n	cf16 <at_handle_CIPCA_cmd_set+0x4a>
    cf30:	e7e0      	b.n	cef4 <at_handle_CIPCA_cmd_set+0x28>
    cf32:	0004      	movs	r4, r0
    cf34:	e7f0      	b.n	cf18 <at_handle_CIPCA_cmd_set+0x4c>
	...

0000cf38 <at_handle_NPOWERCLASS_cmd_test>:
{
    cf38:	b5f0      	push	{r4, r5, r6, r7, lr}
    cf3a:	b09d      	sub	sp, #116	; 0x74
    uint8   support_band_value[AT_MAX_BAND_NUMBER]           = {0};
    cf3c:	ae02      	add	r6, sp, #8
    cf3e:	2214      	movs	r2, #20
    cf40:	2100      	movs	r1, #0
    cf42:	0030      	movs	r0, r6
    cf44:	f7f3 f9cc 	bl	2e0 <memset>
    char    rsp_string[AT_MAX_NPOWERCLASS_TEST_RSP_LEN]      = {0};
    cf48:	2253      	movs	r2, #83	; 0x53
    cf4a:	2100      	movs	r1, #0
    cf4c:	a807      	add	r0, sp, #28
    cf4e:	f7f3 f9c7 	bl	2e0 <memset>
    len = (uint16)snprintf(rsp_string, AT_MAX_NPOWERCLASS_TEST_RSP_LEN, "%s(", AT_CMD_NPOWERCLASS_STR);
    cf52:	4b1b      	ldr	r3, [pc, #108]	; (cfc0 <__INTHEAP_SIZE__+0x80>)
    cf54:	4a1b      	ldr	r2, [pc, #108]	; (cfc4 <__INTHEAP_SIZE__+0x84>)
    cf56:	2153      	movs	r1, #83	; 0x53
    cf58:	a807      	add	r0, sp, #28
    cf5a:	f00d fc87 	bl	1a86c <snprintf>
    if (get_bands(AT_MAX_BAND_NUMBER, &support_band_num, support_band_value) == NEUL_RET_ERROR)
    cf5e:	466b      	mov	r3, sp
    len = (uint16)snprintf(rsp_string, AT_MAX_NPOWERCLASS_TEST_RSP_LEN, "%s(", AT_CMD_NPOWERCLASS_STR);
    cf60:	b284      	uxth	r4, r0
    if (get_bands(AT_MAX_BAND_NUMBER, &support_band_num, support_band_value) == NEUL_RET_ERROR)
    cf62:	1d99      	adds	r1, r3, #6
    cf64:	0032      	movs	r2, r6
    cf66:	2014      	movs	r0, #20
    cf68:	f00f f922 	bl	1c1b0 <get_bands>
         return AT_RET_PROGRESS_ERROR;
    cf6c:	2306      	movs	r3, #6
    if (get_bands(AT_MAX_BAND_NUMBER, &support_band_num, support_band_value) == NEUL_RET_ERROR)
    cf6e:	2801      	cmp	r0, #1
    cf70:	d010      	beq.n	cf94 <__INTHEAP_SIZE__+0x54>
    for (loop = 0; loop < support_band_num; loop++)
    cf72:	2500      	movs	r5, #0
    cf74:	2753      	movs	r7, #83	; 0x53
    cf76:	ab07      	add	r3, sp, #28
    cf78:	1918      	adds	r0, r3, r4
    cf7a:	466b      	mov	r3, sp
    cf7c:	3306      	adds	r3, #6
    cf7e:	881b      	ldrh	r3, [r3, #0]
    cf80:	1b39      	subs	r1, r7, r4
    cf82:	42ab      	cmp	r3, r5
    cf84:	d809      	bhi.n	cf9a <__INTHEAP_SIZE__+0x5a>
    (void)snprintf(rsp_string + len, AT_MAX_NPOWERCLASS_TEST_RSP_LEN - len, "),(3,5,6)");
    cf86:	4a10      	ldr	r2, [pc, #64]	; (cfc8 <__INTHEAP_SIZE__+0x88>)
    cf88:	f00d fc70 	bl	1a86c <snprintf>
    app_at_send_at_rsp_string_lines_with_claim_and_log(rsp_string);
    cf8c:	a807      	add	r0, sp, #28
    cf8e:	f7fc fb29 	bl	95e4 <app_at_send_at_rsp_string_lines_with_claim_and_log>
    return AT_RET_OK;
    cf92:	2300      	movs	r3, #0
}
    cf94:	0018      	movs	r0, r3
    cf96:	b01d      	add	sp, #116	; 0x74
    cf98:	bdf0      	pop	{r4, r5, r6, r7, pc}
        if ( loop != 0)
    cf9a:	2d00      	cmp	r5, #0
    cf9c:	d004      	beq.n	cfa8 <__INTHEAP_SIZE__+0x68>
            len += (uint16)snprintf(rsp_string + len, AT_MAX_NPOWERCLASS_TEST_RSP_LEN - len, ",");
    cf9e:	4a0b      	ldr	r2, [pc, #44]	; (cfcc <__INTHEAP_SIZE__+0x8c>)
    cfa0:	f00d fc64 	bl	1a86c <snprintf>
    cfa4:	1824      	adds	r4, r4, r0
    cfa6:	b2a4      	uxth	r4, r4
        len += (uint16)snprintf(rsp_string + len, AT_MAX_NPOWERCLASS_TEST_RSP_LEN - len, "%d", support_band_value[loop]);
    cfa8:	aa07      	add	r2, sp, #28
    cfaa:	1910      	adds	r0, r2, r4
    cfac:	5d73      	ldrb	r3, [r6, r5]
    cfae:	1b39      	subs	r1, r7, r4
    cfb0:	4a07      	ldr	r2, [pc, #28]	; (cfd0 <__INTHEAP_SIZE__+0x90>)
    cfb2:	f00d fc5b 	bl	1a86c <snprintf>
    for (loop = 0; loop < support_band_num; loop++)
    cfb6:	3501      	adds	r5, #1
        len += (uint16)snprintf(rsp_string + len, AT_MAX_NPOWERCLASS_TEST_RSP_LEN - len, "%d", support_band_value[loop]);
    cfb8:	1824      	adds	r4, r4, r0
    cfba:	b2a4      	uxth	r4, r4
    for (loop = 0; loop < support_band_num; loop++)
    cfbc:	b2ed      	uxtb	r5, r5
    cfbe:	e7da      	b.n	cf76 <__INTHEAP_SIZE__+0x36>
    cfc0:	00023c9b 	.word	0x00023c9b
    cfc4:	0002379f 	.word	0x0002379f
    cfc8:	00023ca9 	.word	0x00023ca9
    cfcc:	00024ab6 	.word	0x00024ab6
    cfd0:	00022e8f 	.word	0x00022e8f

0000cfd4 <at_handle_NBAND_read>:
{
    cfd4:	b5f0      	push	{r4, r5, r6, r7, lr}
    cfd6:	b099      	sub	sp, #100	; 0x64
    uint8   band_value[AT_MAX_BAND_NUMBER]          = {0};
    cfd8:	af02      	add	r7, sp, #8
    cfda:	2214      	movs	r2, #20
    cfdc:	2100      	movs	r1, #0
    cfde:	0038      	movs	r0, r7
    cfe0:	f7f3 f97e 	bl	2e0 <memset>
    uint16  band_num                                = 0;
    cfe4:	2400      	movs	r4, #0
    cfe6:	466b      	mov	r3, sp
    char    rsp_string[AT_MAX_NBAND_READ_RSP_LEN]   = {0};
    cfe8:	2243      	movs	r2, #67	; 0x43
    uint16  band_num                                = 0;
    cfea:	1d9e      	adds	r6, r3, #6
    char    rsp_string[AT_MAX_NBAND_READ_RSP_LEN]   = {0};
    cfec:	0021      	movs	r1, r4
    cfee:	a807      	add	r0, sp, #28
    uint16  band_num                                = 0;
    cff0:	8034      	strh	r4, [r6, #0]
    char    rsp_string[AT_MAX_NBAND_READ_RSP_LEN]   = {0};
    cff2:	f7f3 f975 	bl	2e0 <memset>
    len += (uint16)snprintf(rsp_string, AT_MAX_NBAND_READ_RSP_LEN, "%s", AT_CMD_NBAND_PREFIX);
    cff6:	4b18      	ldr	r3, [pc, #96]	; (d058 <at_handle_NBAND_read+0x84>)
    cff8:	4a18      	ldr	r2, [pc, #96]	; (d05c <at_handle_NBAND_read+0x88>)
    cffa:	2143      	movs	r1, #67	; 0x43
    cffc:	a807      	add	r0, sp, #28
    cffe:	f00d fc35 	bl	1a86c <snprintf>
    if (get_bands(AT_MAX_BAND_NUMBER, &band_num, band_value) == NEUL_RET_ERROR)
    d002:	003a      	movs	r2, r7
    len += (uint16)snprintf(rsp_string, AT_MAX_NBAND_READ_RSP_LEN, "%s", AT_CMD_NBAND_PREFIX);
    d004:	b285      	uxth	r5, r0
    if (get_bands(AT_MAX_BAND_NUMBER, &band_num, band_value) == NEUL_RET_ERROR)
    d006:	0031      	movs	r1, r6
    d008:	2014      	movs	r0, #20
    d00a:	f00f f8d1 	bl	1c1b0 <get_bands>
        return AT_RET_PROGRESS_ERROR;
    d00e:	2306      	movs	r3, #6
    if (get_bands(AT_MAX_BAND_NUMBER, &band_num, band_value) == NEUL_RET_ERROR)
    d010:	2801      	cmp	r0, #1
    d012:	d006      	beq.n	d022 <at_handle_NBAND_read+0x4e>
    for (loop = 0; loop < band_num; loop++)
    d014:	8833      	ldrh	r3, [r6, #0]
    d016:	42a3      	cmp	r3, r4
    d018:	d806      	bhi.n	d028 <at_handle_NBAND_read+0x54>
    app_at_send_at_rsp_string_lines_with_claim_and_log(rsp_string);
    d01a:	a807      	add	r0, sp, #28
    d01c:	f7fc fae2 	bl	95e4 <app_at_send_at_rsp_string_lines_with_claim_and_log>
    return AT_RET_OK;
    d020:	2300      	movs	r3, #0
}
    d022:	0018      	movs	r0, r3
    d024:	b019      	add	sp, #100	; 0x64
    d026:	bdf0      	pop	{r4, r5, r6, r7, pc}
        if (loop != 0)
    d028:	2c00      	cmp	r4, #0
    d02a:	d008      	beq.n	d03e <at_handle_NBAND_read+0x6a>
            len += (uint16)snprintf(rsp_string + len, AT_MAX_NBAND_READ_RSP_LEN - len, ",");
    d02c:	2343      	movs	r3, #67	; 0x43
    d02e:	1b59      	subs	r1, r3, r5
    d030:	ab07      	add	r3, sp, #28
    d032:	1958      	adds	r0, r3, r5
    d034:	4a0a      	ldr	r2, [pc, #40]	; (d060 <at_handle_NBAND_read+0x8c>)
    d036:	f00d fc19 	bl	1a86c <snprintf>
    d03a:	182d      	adds	r5, r5, r0
    d03c:	b2ad      	uxth	r5, r5
        len += (uint16)snprintf(rsp_string + len, AT_MAX_NBAND_READ_RSP_LEN - len, "%d", band_value[loop]);
    d03e:	2243      	movs	r2, #67	; 0x43
    d040:	1b51      	subs	r1, r2, r5
    d042:	aa07      	add	r2, sp, #28
    d044:	1950      	adds	r0, r2, r5
    d046:	5d3b      	ldrb	r3, [r7, r4]
    d048:	4a06      	ldr	r2, [pc, #24]	; (d064 <at_handle_NBAND_read+0x90>)
    d04a:	f00d fc0f 	bl	1a86c <snprintf>
    for (loop = 0; loop < band_num; loop++)
    d04e:	3401      	adds	r4, #1
        len += (uint16)snprintf(rsp_string + len, AT_MAX_NBAND_READ_RSP_LEN - len, "%d", band_value[loop]);
    d050:	182d      	adds	r5, r5, r0
    d052:	b2ad      	uxth	r5, r5
    for (loop = 0; loop < band_num; loop++)
    d054:	b2e4      	uxtb	r4, r4
    d056:	e7dd      	b.n	d014 <at_handle_NBAND_read+0x40>
    d058:	00023a64 	.word	0x00023a64
    d05c:	000237d7 	.word	0x000237d7
    d060:	00024ab6 	.word	0x00024ab6
    d064:	00022e8f 	.word	0x00022e8f

0000d068 <at_handle_NPOWERCLASS_cmd_read>:
{
    d068:	b5f0      	push	{r4, r5, r6, r7, lr}
    uint16                    support_band_num                                 = 0;
    d06a:	2400      	movs	r4, #0
    d06c:	260e      	movs	r6, #14
{
    d06e:	b08f      	sub	sp, #60	; 0x3c
    uint16                    support_band_num                                 = 0;
    d070:	446e      	add	r6, sp
    char                      rsp_string[AT_CMD_NPOWERCLASS_READ_RES_MAX_LEN]  = {0};
    d072:	2214      	movs	r2, #20
    d074:	0021      	movs	r1, r4
    uint8                     support_band_value[AT_MAX_BAND_NUMBER]           = {0};
    d076:	ad09      	add	r5, sp, #36	; 0x24
    char                      rsp_string[AT_CMD_NPOWERCLASS_READ_RES_MAX_LEN]  = {0};
    d078:	a804      	add	r0, sp, #16
    uint16                    support_band_num                                 = 0;
    d07a:	8034      	strh	r4, [r6, #0]
    char                      rsp_string[AT_CMD_NPOWERCLASS_READ_RES_MAX_LEN]  = {0};
    d07c:	f7f3 f930 	bl	2e0 <memset>
    uint8                     support_band_value[AT_MAX_BAND_NUMBER]           = {0};
    d080:	2214      	movs	r2, #20
    d082:	0021      	movs	r1, r4
    d084:	0028      	movs	r0, r5
    d086:	f7f3 f92b 	bl	2e0 <memset>
    if (get_bands(AT_MAX_BAND_NUMBER, &support_band_num, support_band_value) == NEUL_RET_ERROR)
    d08a:	002a      	movs	r2, r5
    d08c:	0031      	movs	r1, r6
    d08e:	2014      	movs	r0, #20
    d090:	f00f f88e 	bl	1c1b0 <get_bands>
    d094:	2801      	cmp	r0, #1
    d096:	d125      	bne.n	d0e4 <at_handle_NPOWERCLASS_cmd_read+0x7c>
         return AT_RET_PROGRESS_ERROR;
    d098:	2006      	movs	r0, #6
}
    d09a:	b00f      	add	sp, #60	; 0x3c
    d09c:	bdf0      	pop	{r4, r5, r6, r7, pc}
        if (get_power_band_class(support_band_value[loop], &power_class) != NEUL_RET_OK)
    d09e:	270d      	movs	r7, #13
    d0a0:	446f      	add	r7, sp
    d0a2:	5d28      	ldrb	r0, [r5, r4]
    d0a4:	0039      	movs	r1, r7
    d0a6:	f00f fbe5 	bl	1c874 <get_power_band_class>
    d0aa:	2800      	cmp	r0, #0
    d0ac:	d1f4      	bne.n	d098 <at_handle_NPOWERCLASS_cmd_read+0x30>
        (void)snprintf(rsp_string, AT_CMD_NPOWERCLASS_READ_RES_MAX_LEN, "%s%d,%d", AT_CMD_NPOWERCLASS_STR, support_band_value[loop], power_class);
    d0ae:	783b      	ldrb	r3, [r7, #0]
    d0b0:	4a11      	ldr	r2, [pc, #68]	; (d0f8 <at_handle_NPOWERCLASS_cmd_read+0x90>)
    d0b2:	9301      	str	r3, [sp, #4]
    d0b4:	5d2b      	ldrb	r3, [r5, r4]
    d0b6:	2114      	movs	r1, #20
    d0b8:	9300      	str	r3, [sp, #0]
    d0ba:	a804      	add	r0, sp, #16
    d0bc:	4b0f      	ldr	r3, [pc, #60]	; (d0fc <at_handle_NPOWERCLASS_cmd_read+0x94>)
    d0be:	f00d fbd5 	bl	1a86c <snprintf>
        if (loop != 0)
    d0c2:	2c00      	cmp	r4, #0
    d0c4:	d013      	beq.n	d0ee <at_handle_NPOWERCLASS_cmd_read+0x86>
            app_at_send_at_rsp_string(rsp_string, true, AT_FLAG_LOGABLE);
    d0c6:	2101      	movs	r1, #1
    d0c8:	2208      	movs	r2, #8
    d0ca:	a804      	add	r0, sp, #16
    d0cc:	f7fc fa7c 	bl	95c8 <app_at_send_at_rsp_string>
            at_uart_write((unsigned char*)APP_AT_STR_RN, strlen(APP_AT_STR_RN));
    d0d0:	4f0b      	ldr	r7, [pc, #44]	; (d100 <at_handle_NPOWERCLASS_cmd_read+0x98>)
    d0d2:	0038      	movs	r0, r7
    d0d4:	f00e f963 	bl	1b39e <strlen>
    d0d8:	0001      	movs	r1, r0
    d0da:	0038      	movs	r0, r7
    d0dc:	f7fc fc86 	bl	99ec <at_uart_write>
    for (loop = 0; loop < support_band_num; loop++)
    d0e0:	3401      	adds	r4, #1
    d0e2:	b2e4      	uxtb	r4, r4
    d0e4:	8833      	ldrh	r3, [r6, #0]
    d0e6:	42a3      	cmp	r3, r4
    d0e8:	d8d9      	bhi.n	d09e <at_handle_NPOWERCLASS_cmd_read+0x36>
    return AT_RET_OK;
    d0ea:	2000      	movs	r0, #0
    d0ec:	e7d5      	b.n	d09a <at_handle_NPOWERCLASS_cmd_read+0x32>
            app_at_send_at_rsp_string_lines_with_claim_and_log(rsp_string);
    d0ee:	a804      	add	r0, sp, #16
    d0f0:	f7fc fa78 	bl	95e4 <app_at_send_at_rsp_string_lines_with_claim_and_log>
    d0f4:	e7f4      	b.n	d0e0 <at_handle_NPOWERCLASS_cmd_read+0x78>
    d0f6:	46c0      	nop			; (mov r8, r8)
    d0f8:	00023e83 	.word	0x00023e83
    d0fc:	00023c9b 	.word	0x00023c9b
    d100:	00022d8f 	.word	0x00022d8f

0000d104 <at_handle_NPRDEFLASH_cmd_set>:
{
    d104:	b5f0      	push	{r4, r5, r6, r7, lr}
    d106:	b0a3      	sub	sp, #140	; 0x8c
    d108:	0004      	movs	r4, r0
    char        cmd[AT_MAX_NPRDEFLASH_SET_CMD_LEN] = {0};
    d10a:	2206      	movs	r2, #6
    d10c:	2100      	movs	r1, #0
    d10e:	a806      	add	r0, sp, #24
    d110:	f7f3 f8e6 	bl	2e0 <memset>
    uint8      *p_data_write = NULL;
    d114:	2300      	movs	r3, #0
    uint16      p_data_len = 0;
    d116:	ad03      	add	r5, sp, #12
    uint8      *p_data_write = NULL;
    d118:	9305      	str	r3, [sp, #20]
    uint16      p_data_len = 0;
    d11a:	802b      	strh	r3, [r5, #0]
    if (!eflash_is_available())
    d11c:	f00d fba0 	bl	1a860 <eflash_is_available>
    d120:	2800      	cmp	r0, #0
    d122:	d101      	bne.n	d128 <at_handle_NPRDEFLASH_cmd_set+0x24>
        return AT_RET_PROGRESS_ERROR;
    d124:	2406      	movs	r4, #6
    d126:	e00a      	b.n	d13e <at_handle_NPRDEFLASH_cmd_set+0x3a>
    if (at_create_param_array(p_atparams_string, &num_recvparams, 3, 4) != AT_RET_OK)
    d128:	ab02      	add	r3, sp, #8
    d12a:	1c5e      	adds	r6, r3, #1
    d12c:	2203      	movs	r2, #3
    d12e:	2304      	movs	r3, #4
    d130:	0031      	movs	r1, r6
    d132:	0020      	movs	r0, r4
    d134:	f7fd f8d6 	bl	a2e4 <at_create_param_array>
    d138:	2800      	cmp	r0, #0
    d13a:	d003      	beq.n	d144 <at_handle_NPRDEFLASH_cmd_set+0x40>
       return AT_RET_SYNTAX_ERROR;
    d13c:	2401      	movs	r4, #1
}
    d13e:	0020      	movs	r0, r4
    d140:	b023      	add	sp, #140	; 0x8c
    d142:	bdf0      	pop	{r4, r5, r6, r7, pc}
    cause = at_get_string_param(AT_PARSE_FIRST_PARAM_POS, (uint8 *)cmd, AT_MAX_NPRDEFLASH_SET_CMD_LEN, true);
    d144:	2301      	movs	r3, #1
    d146:	2206      	movs	r2, #6
    d148:	a906      	add	r1, sp, #24
    d14a:	f7fd fb1d 	bl	a788 <at_get_string_param>
    d14e:	1e04      	subs	r4, r0, #0
    if (cause != AT_RET_OK)
    d150:	d1f5      	bne.n	d13e <at_handle_NPRDEFLASH_cmd_set+0x3a>
    cause = at_get_uint32_param(AT_PARSE_SECOND_PARAM_POS, &address, true);
    d152:	2201      	movs	r2, #1
    d154:	a904      	add	r1, sp, #16
    d156:	0010      	movs	r0, r2
    d158:	f7fd f960 	bl	a41c <at_get_uint32_param>
    d15c:	1e04      	subs	r4, r0, #0
    if (cause != AT_RET_OK)
    d15e:	d1ee      	bne.n	d13e <at_handle_NPRDEFLASH_cmd_set+0x3a>
    cause = at_get_uint16_param(AT_PARSE_THIRD_PARAM_POS, &length, true);
    d160:	ab02      	add	r3, sp, #8
    d162:	1c9f      	adds	r7, r3, #2
    d164:	2201      	movs	r2, #1
    d166:	0039      	movs	r1, r7
    d168:	2002      	movs	r0, #2
    d16a:	f7fd f9cf 	bl	a50c <at_get_uint16_param>
    d16e:	1e04      	subs	r4, r0, #0
    if (cause != AT_RET_OK)
    d170:	d1e5      	bne.n	d13e <at_handle_NPRDEFLASH_cmd_set+0x3a>
    if (num_recvparams == 4)
    d172:	7833      	ldrb	r3, [r6, #0]
    d174:	2b04      	cmp	r3, #4
    d176:	d02c      	beq.n	d1d2 <at_handle_NPRDEFLASH_cmd_set+0xce>
    if ((at_strcmp(cmd, AT_CMD_NPRDEFLASH_WRITE) == 0) && (num_recvparams == 4))
    d178:	4959      	ldr	r1, [pc, #356]	; (d2e0 <at_handle_NPRDEFLASH_cmd_set+0x1dc>)
    d17a:	a806      	add	r0, sp, #24
    d17c:	f00e f8f0 	bl	1b360 <strcmp>
    d180:	2800      	cmp	r0, #0
    d182:	d03b      	beq.n	d1fc <at_handle_NPRDEFLASH_cmd_set+0xf8>
    else if ((at_strcmp(cmd, AT_CMD_NPRDEFLASH_READ) == 0) && (num_recvparams == 3))
    d184:	4957      	ldr	r1, [pc, #348]	; (d2e4 <at_handle_NPRDEFLASH_cmd_set+0x1e0>)
    d186:	a806      	add	r0, sp, #24
    d188:	f00e f8ea 	bl	1b360 <strcmp>
    d18c:	1e05      	subs	r5, r0, #0
    d18e:	d175      	bne.n	d27c <at_handle_NPRDEFLASH_cmd_set+0x178>
    d190:	7833      	ldrb	r3, [r6, #0]
    d192:	2b03      	cmp	r3, #3
    d194:	d172      	bne.n	d27c <at_handle_NPRDEFLASH_cmd_set+0x178>
        cause = at_nprdeflash_read_cmd(address, length);       // read
    d196:	883b      	ldrh	r3, [r7, #0]
    char    data_string[AT_MAX_NPRDEFLASH_RSP_LEN + 3] = {0};
    d198:	2267      	movs	r2, #103	; 0x67
    d19a:	0001      	movs	r1, r0
    d19c:	a808      	add	r0, sp, #32
        cause = at_nprdeflash_read_cmd(address, length);       // read
    d19e:	9301      	str	r3, [sp, #4]
    d1a0:	9e04      	ldr	r6, [sp, #16]
    char    data_string[AT_MAX_NPRDEFLASH_RSP_LEN + 3] = {0};
    d1a2:	f7f3 f89d 	bl	2e0 <memset>
    if (length > AT_MAX_NPRDEFLASH_READ_LEN)
    d1a6:	2380      	movs	r3, #128	; 0x80
    d1a8:	9a01      	ldr	r2, [sp, #4]
    d1aa:	009b      	lsls	r3, r3, #2
    d1ac:	429a      	cmp	r2, r3
    d1ae:	d8b9      	bhi.n	d124 <at_handle_NPRDEFLASH_cmd_set+0x20>
    buff = (uint8 *)irmalloc(length + 1);
    d1b0:	1c50      	adds	r0, r2, #1
    d1b2:	f005 fc25 	bl	12a00 <irmalloc>
    d1b6:	1e07      	subs	r7, r0, #0
    if (buff == NULL)
    d1b8:	d05e      	beq.n	d278 <at_handle_NPRDEFLASH_cmd_set+0x174>
    if (eflash_read_data(address, buff, length) != length)
    d1ba:	0001      	movs	r1, r0
    d1bc:	9a01      	ldr	r2, [sp, #4]
    d1be:	0030      	movs	r0, r6
    d1c0:	f00d faae 	bl	1a720 <eflash_read_data>
    d1c4:	9b01      	ldr	r3, [sp, #4]
    d1c6:	4283      	cmp	r3, r0
    d1c8:	d02b      	beq.n	d222 <at_handle_NPRDEFLASH_cmd_set+0x11e>
                irfree(buff);
    d1ca:	0038      	movs	r0, r7
    d1cc:	f005 fc34 	bl	12a38 <irfree>
    d1d0:	e7a8      	b.n	d124 <at_handle_NPRDEFLASH_cmd_set+0x20>
        cause = at_get_hexstring_param(AT_PARSE_FOURTH_PARAM_POS, &p_data_write, &p_data_len, true);
    d1d2:	2301      	movs	r3, #1
    d1d4:	002a      	movs	r2, r5
    d1d6:	a905      	add	r1, sp, #20
    d1d8:	2003      	movs	r0, #3
    d1da:	f7fd fb27 	bl	a82c <at_get_hexstring_param>
        if (cause != AT_RET_OK)
    d1de:	2800      	cmp	r0, #0
    d1e0:	d000      	beq.n	d1e4 <at_handle_NPRDEFLASH_cmd_set+0xe0>
    d1e2:	e07b      	b.n	d2dc <at_handle_NPRDEFLASH_cmd_set+0x1d8>
        if (length * 2 != p_data_len)
    d1e4:	883a      	ldrh	r2, [r7, #0]
    d1e6:	882b      	ldrh	r3, [r5, #0]
    d1e8:	0052      	lsls	r2, r2, #1
    d1ea:	429a      	cmp	r2, r3
    d1ec:	d1a6      	bne.n	d13c <at_handle_NPRDEFLASH_cmd_set+0x38>
        if (at_parse_buf_hex_to_uint8(p_data_write, p_data_write, (uint16)p_data_len) == false)
    d1ee:	9905      	ldr	r1, [sp, #20]
    d1f0:	0008      	movs	r0, r1
    d1f2:	f7fc ffc6 	bl	a182 <at_parse_buf_hex_to_uint8>
    d1f6:	2800      	cmp	r0, #0
    d1f8:	d1be      	bne.n	d178 <at_handle_NPRDEFLASH_cmd_set+0x74>
    d1fa:	e79f      	b.n	d13c <at_handle_NPRDEFLASH_cmd_set+0x38>
    if ((at_strcmp(cmd, AT_CMD_NPRDEFLASH_WRITE) == 0) && (num_recvparams == 4))
    d1fc:	7833      	ldrb	r3, [r6, #0]
    d1fe:	2b04      	cmp	r3, #4
    d200:	d1c0      	bne.n	d184 <at_handle_NPRDEFLASH_cmd_set+0x80>
        cause = at_nprdeflash_write_cmd(address, length, p_data_write);     // write
    d202:	ab02      	add	r3, sp, #8
    d204:	885d      	ldrh	r5, [r3, #2]
    if (length > AT_MAX_NPRDEFLASH_WRITE_LEN)
    d206:	2380      	movs	r3, #128	; 0x80
    d208:	009b      	lsls	r3, r3, #2
    d20a:	429d      	cmp	r5, r3
    d20c:	d900      	bls.n	d210 <at_handle_NPRDEFLASH_cmd_set+0x10c>
    d20e:	e789      	b.n	d124 <at_handle_NPRDEFLASH_cmd_set+0x20>
    if (eflash_write_data(address, pdata, length) != length)
    d210:	002a      	movs	r2, r5
    d212:	9905      	ldr	r1, [sp, #20]
    d214:	9804      	ldr	r0, [sp, #16]
    d216:	f00d f9eb 	bl	1a5f0 <eflash_write_data>
    d21a:	4285      	cmp	r5, r0
    d21c:	d100      	bne.n	d220 <at_handle_NPRDEFLASH_cmd_set+0x11c>
    d21e:	e78e      	b.n	d13e <at_handle_NPRDEFLASH_cmd_set+0x3a>
    d220:	e780      	b.n	d124 <at_handle_NPRDEFLASH_cmd_set+0x20>
    app_at_send_at_rsp_string("+NPRDEFLASH:",true, AT_FLAG_LOGABLE | AT_FLAG_LOG_RESTRICTED);
    d222:	2228      	movs	r2, #40	; 0x28
    d224:	2101      	movs	r1, #1
    d226:	4830      	ldr	r0, [pc, #192]	; (d2e8 <at_handle_NPRDEFLASH_cmd_set+0x1e4>)
    d228:	f7fc f9ce 	bl	95c8 <app_at_send_at_rsp_string>
    print_len = 0;
    d22c:	002e      	movs	r6, r5
    for (loop = 0; loop < length; loop++)
    d22e:	9a01      	ldr	r2, [sp, #4]
    d230:	b2ab      	uxth	r3, r5
    d232:	429a      	cmp	r2, r3
    d234:	d803      	bhi.n	d23e <at_handle_NPRDEFLASH_cmd_set+0x13a>
    irfree(buff);
    d236:	0038      	movs	r0, r7
    d238:	f005 fbfe 	bl	12a38 <irfree>
    d23c:	e77f      	b.n	d13e <at_handle_NPRDEFLASH_cmd_set+0x3a>
        print_len += (uint16)snprintf(data_string + print_len, AT_MAX_NPRDEFLASH_RSP_LEN, "%02X", *p_data++);
    d23e:	aa08      	add	r2, sp, #32
    d240:	1990      	adds	r0, r2, r6
    d242:	5d7b      	ldrb	r3, [r7, r5]
    d244:	4a29      	ldr	r2, [pc, #164]	; (d2ec <at_handle_NPRDEFLASH_cmd_set+0x1e8>)
    d246:	2164      	movs	r1, #100	; 0x64
    d248:	f00d fb10 	bl	1a86c <snprintf>
    d24c:	1836      	adds	r6, r6, r0
    d24e:	b2b6      	uxth	r6, r6
        if ((print_len >= AT_MAX_NPRDEFLASH_RSP_LEN) || (loop == length - 1))
    d250:	2e63      	cmp	r6, #99	; 0x63
    d252:	d80e      	bhi.n	d272 <at_handle_NPRDEFLASH_cmd_set+0x16e>
    d254:	9b01      	ldr	r3, [sp, #4]
    d256:	3b01      	subs	r3, #1
    d258:	42ab      	cmp	r3, r5
    d25a:	d108      	bne.n	d26e <at_handle_NPRDEFLASH_cmd_set+0x16a>
            data_string[print_len + 1] = '\0';
    d25c:	ab08      	add	r3, sp, #32
    d25e:	1998      	adds	r0, r3, r6
    d260:	2600      	movs	r6, #0
            app_at_send_at_rsp_string(data_string,true,AT_FLAG_LOGABLE | AT_FLAG_LOG_RESTRICTED);
    d262:	2228      	movs	r2, #40	; 0x28
            data_string[print_len + 1] = '\0';
    d264:	7046      	strb	r6, [r0, #1]
            app_at_send_at_rsp_string(data_string,true,AT_FLAG_LOGABLE | AT_FLAG_LOG_RESTRICTED);
    d266:	2101      	movs	r1, #1
    d268:	0018      	movs	r0, r3
    d26a:	f7fc f9ad 	bl	95c8 <app_at_send_at_rsp_string>
    d26e:	3501      	adds	r5, #1
    d270:	e7dd      	b.n	d22e <at_handle_NPRDEFLASH_cmd_set+0x12a>
            if (print_len > AT_MAX_NPRDEFLASH_RSP_LEN + 1)
    d272:	2e65      	cmp	r6, #101	; 0x65
    d274:	d9f2      	bls.n	d25c <at_handle_NPRDEFLASH_cmd_set+0x158>
    d276:	e7a8      	b.n	d1ca <at_handle_NPRDEFLASH_cmd_set+0xc6>
        return AT_RET_MEMORY_ERROR;
    d278:	2404      	movs	r4, #4
        cause = at_nprdeflash_read_cmd(address, length);       // read
    d27a:	e760      	b.n	d13e <at_handle_NPRDEFLASH_cmd_set+0x3a>
    else if ((at_strcmp(cmd, AT_CMD_NPRDEFLASH_ERASE) == 0) && (num_recvparams == 3))
    d27c:	491c      	ldr	r1, [pc, #112]	; (d2f0 <at_handle_NPRDEFLASH_cmd_set+0x1ec>)
    d27e:	a806      	add	r0, sp, #24
    d280:	f00e f86e 	bl	1b360 <strcmp>
    d284:	2800      	cmp	r0, #0
    d286:	d000      	beq.n	d28a <at_handle_NPRDEFLASH_cmd_set+0x186>
    d288:	e758      	b.n	d13c <at_handle_NPRDEFLASH_cmd_set+0x38>
    d28a:	7833      	ldrb	r3, [r6, #0]
    d28c:	2b03      	cmp	r3, #3
    d28e:	d000      	beq.n	d292 <at_handle_NPRDEFLASH_cmd_set+0x18e>
    d290:	e754      	b.n	d13c <at_handle_NPRDEFLASH_cmd_set+0x38>
        cause = at_nprdeflash_erase_cmd(address, length);                   // erase
    d292:	ab02      	add	r3, sp, #8
    d294:	885d      	ldrh	r5, [r3, #2]
    if (length == 0)
    d296:	2d00      	cmp	r5, #0
    d298:	d100      	bne.n	d29c <at_handle_NPRDEFLASH_cmd_set+0x198>
    d29a:	e750      	b.n	d13e <at_handle_NPRDEFLASH_cmd_set+0x3a>
        cause = at_nprdeflash_erase_cmd(address, length);                   // erase
    d29c:	9f04      	ldr	r7, [sp, #16]
    if (eflash_get_32kblock_id(address, &start_id) != EFLASH_RET_OK)
    d29e:	ab02      	add	r3, sp, #8
    d2a0:	1d9e      	adds	r6, r3, #6
    d2a2:	0031      	movs	r1, r6
    d2a4:	0038      	movs	r0, r7
    d2a6:	f00d facd 	bl	1a844 <eflash_get_32kblock_id>
    d2aa:	2800      	cmp	r0, #0
    d2ac:	d000      	beq.n	d2b0 <at_handle_NPRDEFLASH_cmd_set+0x1ac>
    d2ae:	e739      	b.n	d124 <at_handle_NPRDEFLASH_cmd_set+0x20>
    if (eflash_get_32kblock_id(address + length, &end_id) != EFLASH_RET_OK)
    d2b0:	19e8      	adds	r0, r5, r7
    d2b2:	a908      	add	r1, sp, #32
    d2b4:	f00d fac6 	bl	1a844 <eflash_get_32kblock_id>
    d2b8:	2800      	cmp	r0, #0
    d2ba:	d000      	beq.n	d2be <at_handle_NPRDEFLASH_cmd_set+0x1ba>
    d2bc:	e732      	b.n	d124 <at_handle_NPRDEFLASH_cmd_set+0x20>
    for (block_id = start_id; block_id <= end_id; block_id++)
    d2be:	8835      	ldrh	r5, [r6, #0]
    d2c0:	ab02      	add	r3, sp, #8
    d2c2:	8b1b      	ldrh	r3, [r3, #24]
    d2c4:	42ab      	cmp	r3, r5
    d2c6:	d200      	bcs.n	d2ca <at_handle_NPRDEFLASH_cmd_set+0x1c6>
    d2c8:	e739      	b.n	d13e <at_handle_NPRDEFLASH_cmd_set+0x3a>
        if (eflash_32kblock_erase(block_id) != EFLASH_RET_OK)
    d2ca:	0028      	movs	r0, r5
    d2cc:	f00d fa96 	bl	1a7fc <eflash_32kblock_erase>
    d2d0:	2800      	cmp	r0, #0
    d2d2:	d000      	beq.n	d2d6 <at_handle_NPRDEFLASH_cmd_set+0x1d2>
    d2d4:	e726      	b.n	d124 <at_handle_NPRDEFLASH_cmd_set+0x20>
    for (block_id = start_id; block_id <= end_id; block_id++)
    d2d6:	3501      	adds	r5, #1
    d2d8:	b2ad      	uxth	r5, r5
    d2da:	e7f1      	b.n	d2c0 <at_handle_NPRDEFLASH_cmd_set+0x1bc>
    d2dc:	0004      	movs	r4, r0
    d2de:	e72e      	b.n	d13e <at_handle_NPRDEFLASH_cmd_set+0x3a>
    d2e0:	00023cb3 	.word	0x00023cb3
    d2e4:	00023cb9 	.word	0x00023cb9
    d2e8:	00023cbe 	.word	0x00023cbe
    d2ec:	00023ccb 	.word	0x00023ccb
    d2f0:	00023cd0 	.word	0x00023cd0

0000d2f4 <at_handle_NFWUPD_cmd_set>:
{
    d2f4:	b5f0      	push	{r4, r5, r6, r7, lr}
    d2f6:	b087      	sub	sp, #28
    uint8  param_num = 0;
    d2f8:	466b      	mov	r3, sp
    uint16 len       = 0;
    d2fa:	260a      	movs	r6, #10
    uint16 cmd       = 0;
    d2fc:	466a      	mov	r2, sp
    uint8  param_num = 0;
    d2fe:	1d5d      	adds	r5, r3, #5
    d300:	2300      	movs	r3, #0
    uint16 len       = 0;
    d302:	446e      	add	r6, sp
    uint16 data_len  = 0;
    d304:	af03      	add	r7, sp, #12
    uint16 cmd       = 0;
    d306:	80d3      	strh	r3, [r2, #6]
    uint16 sn        = 0;
    d308:	8113      	strh	r3, [r2, #8]
    uint16 crc_len   = 0;
    d30a:	81d3      	strh	r3, [r2, #14]
    uint8  param_num = 0;
    d30c:	702b      	strb	r3, [r5, #0]
    uint16 cmd       = 0;
    d30e:	1d94      	adds	r4, r2, #6
    uint16 len       = 0;
    d310:	8033      	strh	r3, [r6, #0]
    uint8* data_str  = NULL;
    d312:	9304      	str	r3, [sp, #16]
    uint16 data_len  = 0;
    d314:	803b      	strh	r3, [r7, #0]
    uint8* crc_str   = NULL;
    d316:	9305      	str	r3, [sp, #20]
    cause = at_create_param_array(p_atparams_string, &param_num, 1, 5);
    d318:	2201      	movs	r2, #1
    d31a:	3305      	adds	r3, #5
    d31c:	0029      	movs	r1, r5
    d31e:	f7fc ffe1 	bl	a2e4 <at_create_param_array>
    if (cause != AT_RET_OK)
    d322:	2800      	cmp	r0, #0
    d324:	d131      	bne.n	d38a <at_handle_NFWUPD_cmd_set+0x96>
    cause = at_get_uint16_param(AT_PARSE_FIRST_PARAM_POS, &cmd, true);
    d326:	2201      	movs	r2, #1
    d328:	0021      	movs	r1, r4
    d32a:	f7fd f8ef 	bl	a50c <at_get_uint16_param>
    if (cause != AT_RET_OK)
    d32e:	2800      	cmp	r0, #0
    d330:	d12b      	bne.n	d38a <at_handle_NFWUPD_cmd_set+0x96>
    if (((AT_OTA_CMD)cmd) == AT_OTA_CMD_DOWNLOAD)
    d332:	7824      	ldrb	r4, [r4, #0]
    d334:	2c01      	cmp	r4, #1
    d336:	d145      	bne.n	d3c4 <at_handle_NFWUPD_cmd_set+0xd0>
        if (param_num != 5)
    d338:	782b      	ldrb	r3, [r5, #0]
            return AT_RET_PARAM_MISSING;
    d33a:	3003      	adds	r0, #3
        if (param_num != 5)
    d33c:	2b05      	cmp	r3, #5
    d33e:	d124      	bne.n	d38a <at_handle_NFWUPD_cmd_set+0x96>
        cause = at_get_uint16_param(AT_PARSE_SECOND_PARAM_POS, &sn, true);
    d340:	0022      	movs	r2, r4
    d342:	a902      	add	r1, sp, #8
    d344:	0020      	movs	r0, r4
    d346:	f7fd f8e1 	bl	a50c <at_get_uint16_param>
        if (cause != AT_RET_OK)
    d34a:	2800      	cmp	r0, #0
    d34c:	d11d      	bne.n	d38a <at_handle_NFWUPD_cmd_set+0x96>
        cause = at_get_uint16_param(AT_PARSE_THIRD_PARAM_POS, &len, true);
    d34e:	0022      	movs	r2, r4
    d350:	0031      	movs	r1, r6
    d352:	3002      	adds	r0, #2
    d354:	f7fd f8da 	bl	a50c <at_get_uint16_param>
        if (cause != AT_RET_OK)
    d358:	2800      	cmp	r0, #0
    d35a:	d116      	bne.n	d38a <at_handle_NFWUPD_cmd_set+0x96>
        cause = at_get_hexstring_param(AT_PARSE_FOURTH_PARAM_POS, &data_str, &data_len, true);
    d35c:	0023      	movs	r3, r4
    d35e:	003a      	movs	r2, r7
    d360:	a904      	add	r1, sp, #16
    d362:	3003      	adds	r0, #3
    d364:	f7fd fa62 	bl	a82c <at_get_hexstring_param>
        if (cause != AT_RET_OK)
    d368:	2800      	cmp	r0, #0
    d36a:	d10e      	bne.n	d38a <at_handle_NFWUPD_cmd_set+0x96>
        cause = at_get_hexstring_param(AT_PARSE_FIFTH_PARAM_POS, &crc_str, &crc_len, true);
    d36c:	220e      	movs	r2, #14
    d36e:	0023      	movs	r3, r4
    d370:	446a      	add	r2, sp
    d372:	a905      	add	r1, sp, #20
    d374:	3004      	adds	r0, #4
    d376:	f7fd fa59 	bl	a82c <at_get_hexstring_param>
        if (cause != AT_RET_OK)
    d37a:	2800      	cmp	r0, #0
    d37c:	d105      	bne.n	d38a <at_handle_NFWUPD_cmd_set+0x96>
        if (((len * 2) != data_len) || (crc_len != 2))
    d37e:	8833      	ldrh	r3, [r6, #0]
    d380:	883a      	ldrh	r2, [r7, #0]
    d382:	005b      	lsls	r3, r3, #1
    d384:	4293      	cmp	r3, r2
    d386:	d002      	beq.n	d38e <at_handle_NFWUPD_cmd_set+0x9a>
            return AT_RET_SYNTAX_ERROR;
    d388:	2001      	movs	r0, #1
}
    d38a:	b007      	add	sp, #28
    d38c:	bdf0      	pop	{r4, r5, r6, r7, pc}
        if (((len * 2) != data_len) || (crc_len != 2))
    d38e:	466b      	mov	r3, sp
    d390:	89db      	ldrh	r3, [r3, #14]
    d392:	2b02      	cmp	r3, #2
    d394:	d1f8      	bne.n	d388 <at_handle_NFWUPD_cmd_set+0x94>
        if (at_parse_buf_hex_to_uint8(data_str, data_str, data_len) == false)
    d396:	9904      	ldr	r1, [sp, #16]
    d398:	0008      	movs	r0, r1
    d39a:	f7fc fef2 	bl	a182 <at_parse_buf_hex_to_uint8>
    d39e:	2800      	cmp	r0, #0
    d3a0:	d0f2      	beq.n	d388 <at_handle_NFWUPD_cmd_set+0x94>
        if (at_parse_buf_hex_to_uint8(crc_str, crc_str, crc_len) == false)
    d3a2:	230e      	movs	r3, #14
    d3a4:	9905      	ldr	r1, [sp, #20]
    d3a6:	446b      	add	r3, sp
    d3a8:	881a      	ldrh	r2, [r3, #0]
    d3aa:	0008      	movs	r0, r1
    d3ac:	f7fc fee9 	bl	a182 <at_parse_buf_hex_to_uint8>
    d3b0:	2800      	cmp	r0, #0
    d3b2:	d0e9      	beq.n	d388 <at_handle_NFWUPD_cmd_set+0x94>
        return at_ota_download_package(sn, len, data_str, crc_str);
    d3b4:	466b      	mov	r3, sp
    d3b6:	8831      	ldrh	r1, [r6, #0]
    d3b8:	8918      	ldrh	r0, [r3, #8]
    d3ba:	9a04      	ldr	r2, [sp, #16]
    d3bc:	9b05      	ldr	r3, [sp, #20]
    d3be:	f004 fd01 	bl	11dc4 <at_ota_download_package>
    d3c2:	e7e2      	b.n	d38a <at_handle_NFWUPD_cmd_set+0x96>
    else if ((AT_OTA_CMD)cmd < AT_OTA_CMD_MAX_NUM)
    d3c4:	2c05      	cmp	r4, #5
    d3c6:	d8df      	bhi.n	d388 <at_handle_NFWUPD_cmd_set+0x94>
        if (param_num != 1)
    d3c8:	782b      	ldrb	r3, [r5, #0]
    d3ca:	2b01      	cmp	r3, #1
    d3cc:	d1dc      	bne.n	d388 <at_handle_NFWUPD_cmd_set+0x94>
        return at_ota_exec_cmd((AT_OTA_CMD)cmd);
    d3ce:	0020      	movs	r0, r4
    d3d0:	f004 fc2a 	bl	11c28 <at_ota_exec_cmd>
    d3d4:	e7d9      	b.n	d38a <at_handle_NFWUPD_cmd_set+0x96>
	...

0000d3d8 <at_handle_CEER_cmd_exec>:
{
    d3d8:	b530      	push	{r4, r5, lr}
    d3da:	b093      	sub	sp, #76	; 0x4c
    uint8               reject_flag     = 0;
    d3dc:	466b      	mov	r3, sp
    d3de:	2100      	movs	r1, #0
    d3e0:	1c9d      	adds	r5, r3, #2
    EMM_CAUSE_INFO      reject_cause    = EMM_CAUSE_INFO_UNKNOWN;
    d3e2:	1cdc      	adds	r4, r3, #3
    d3e4:	23ff      	movs	r3, #255	; 0xff
    char    rsp_string[AT_CEER_RESPONSE_MAX_LEN] = {0};
    d3e6:	2244      	movs	r2, #68	; 0x44
    d3e8:	a801      	add	r0, sp, #4
    uint8               reject_flag     = 0;
    d3ea:	7029      	strb	r1, [r5, #0]
    EMM_CAUSE_INFO      reject_cause    = EMM_CAUSE_INFO_UNKNOWN;
    d3ec:	7023      	strb	r3, [r4, #0]
    char    rsp_string[AT_CEER_RESPONSE_MAX_LEN] = {0};
    d3ee:	f7f2 ff77 	bl	2e0 <memset>
    if (get_extended_error_cause(&reject_flag, &reject_cause) != NEUL_RET_OK)
    d3f2:	0021      	movs	r1, r4
    d3f4:	0028      	movs	r0, r5
    d3f6:	f00f f9b9 	bl	1c76c <get_extended_error_cause>
    d3fa:	2800      	cmp	r0, #0
    d3fc:	d002      	beq.n	d404 <at_handle_CEER_cmd_exec+0x2c>
        return AT_RET_PROGRESS_ERROR;
    d3fe:	2006      	movs	r0, #6
}
    d400:	b013      	add	sp, #76	; 0x4c
    d402:	bd30      	pop	{r4, r5, pc}
    if (reject_flag == 1)
    d404:	782b      	ldrb	r3, [r5, #0]
    d406:	2b01      	cmp	r3, #1
    d408:	d1fa      	bne.n	d400 <at_handle_CEER_cmd_exec+0x28>
        cause_str = get_ceer_register_reject_cause((uint8)reject_cause);
    d40a:	7820      	ldrb	r0, [r4, #0]
    d40c:	f7fc f88a 	bl	9524 <get_ceer_register_reject_cause>
    d410:	1e03      	subs	r3, r0, #0
        if (cause_str == NULL)
    d412:	d0f4      	beq.n	d3fe <at_handle_CEER_cmd_exec+0x26>
        if (reject_cause == EMM_CAUSE_INFO_UNKNOWN)
    d414:	7822      	ldrb	r2, [r4, #0]
    d416:	2aff      	cmp	r2, #255	; 0xff
    d418:	d109      	bne.n	d42e <at_handle_CEER_cmd_exec+0x56>
            (void)snprintf(rsp_string, AT_CEER_RESPONSE_MAX_LEN, "+CEER:%s", cause_str);
    d41a:	4a06      	ldr	r2, [pc, #24]	; (d434 <at_handle_CEER_cmd_exec+0x5c>)
            (void)snprintf(rsp_string, AT_CEER_RESPONSE_MAX_LEN, "+CEER:EMM_CAUSE_%s", cause_str);
    d41c:	2144      	movs	r1, #68	; 0x44
    d41e:	a801      	add	r0, sp, #4
    d420:	f00d fa24 	bl	1a86c <snprintf>
        app_at_send_at_rsp_string_lines_with_claim_and_log(rsp_string);
    d424:	a801      	add	r0, sp, #4
    d426:	f7fc f8dd 	bl	95e4 <app_at_send_at_rsp_string_lines_with_claim_and_log>
    return AT_RET_OK;
    d42a:	2000      	movs	r0, #0
    d42c:	e7e8      	b.n	d400 <at_handle_CEER_cmd_exec+0x28>
            (void)snprintf(rsp_string, AT_CEER_RESPONSE_MAX_LEN, "+CEER:EMM_CAUSE_%s", cause_str);
    d42e:	4a02      	ldr	r2, [pc, #8]	; (d438 <at_handle_CEER_cmd_exec+0x60>)
    d430:	e7f4      	b.n	d41c <at_handle_CEER_cmd_exec+0x44>
    d432:	46c0      	nop			; (mov r8, r8)
    d434:	00023622 	.word	0x00023622
    d438:	0002362b 	.word	0x0002362b

0000d43c <at_get_pending_data_list_common_handle>:
{
    d43c:	b5f0      	push	{r4, r5, r6, r7, lr}
    d43e:	b08d      	sub	sp, #52	; 0x34
    d440:	9105      	str	r1, [sp, #20]
    char          rsp_string[AT_MAX_NQSOS_READ_RSP_LEN] = {0};
    d442:	2214      	movs	r2, #20
    d444:	2100      	movs	r1, #0
{
    d446:	0006      	movs	r6, r0
    char          rsp_string[AT_MAX_NQSOS_READ_RSP_LEN] = {0};
    d448:	a807      	add	r0, sp, #28
    d44a:	f7f2 ff49 	bl	2e0 <memset>
    data_seqs = (uint8*)irzalloc(NEUL_NQSOS_SEQ_NUM * sizeof(uint8));
    d44e:	2020      	movs	r0, #32
    d450:	f005 fae0 	bl	12a14 <irzalloc>
    d454:	0004      	movs	r4, r0
        return AT_RET_MEMORY_ERROR;
    d456:	2004      	movs	r0, #4
    if (data_seqs == NULL)
    d458:	2c00      	cmp	r4, #0
    d45a:	d02c      	beq.n	d4b6 <at_get_pending_data_list_common_handle+0x7a>
    result = get_pending_data_seqs(pending_data_sent_list_index, NEUL_NQSOS_SEQ_NUM, &data_seqs_num, data_seqs);
    d45c:	220a      	movs	r2, #10
    d45e:	a904      	add	r1, sp, #16
    d460:	1852      	adds	r2, r2, r1
    d462:	0023      	movs	r3, r4
    d464:	2120      	movs	r1, #32
    d466:	0030      	movs	r0, r6
    d468:	f00e ff16 	bl	1c298 <get_pending_data_seqs>
    if (result != NEUL_RET_OK)
    d46c:	2800      	cmp	r0, #0
    d46e:	d11e      	bne.n	d4ae <at_get_pending_data_list_common_handle+0x72>
    bool          is_nonip_first_pending                = true; /* need print the prefix if it is the fist pending data */
    d470:	2501      	movs	r5, #1
    d472:	9403      	str	r4, [sp, #12]
    for(uint16 i = 0 ; i < 32; i++)
    d474:	9002      	str	r0, [sp, #8]
{
    d476:	2700      	movs	r7, #0
    d478:	9b02      	ldr	r3, [sp, #8]
    d47a:	00db      	lsls	r3, r3, #3
    d47c:	b2db      	uxtb	r3, r3
    d47e:	9304      	str	r3, [sp, #16]
            if ((data_seqs[i] != 0) && (((data_seqs[i] & 0xFF) & ((0x80 >> j) & 0xFF)) != 0))
    d480:	9b03      	ldr	r3, [sp, #12]
    d482:	781b      	ldrb	r3, [r3, #0]
    d484:	2b00      	cmp	r3, #0
    d486:	d03c      	beq.n	d502 <at_get_pending_data_list_common_handle+0xc6>
    d488:	2280      	movs	r2, #128	; 0x80
    d48a:	413a      	asrs	r2, r7
    d48c:	4213      	tst	r3, r2
    d48e:	d038      	beq.n	d502 <at_get_pending_data_list_common_handle+0xc6>
    d490:	9b04      	ldr	r3, [sp, #16]
    d492:	19db      	adds	r3, r3, r7
    d494:	b2db      	uxtb	r3, r3
                if (pending_data_sent_list_index == AT_CP_ONLY_NON_IP_PENDING_DATA_LIST_INDEX || pending_data_sent_list_index == AT_CP_NON_IP_PENDING_DATA_LIST_INDEX)
    d496:	2eff      	cmp	r6, #255	; 0xff
    d498:	d022      	beq.n	d4e0 <at_get_pending_data_list_common_handle+0xa4>
    d49a:	2eef      	cmp	r6, #239	; 0xef
    d49c:	d110      	bne.n	d4c0 <at_get_pending_data_list_common_handle+0x84>
                    if (is_nonip_first_pending)
    d49e:	2d00      	cmp	r5, #0
    d4a0:	d10b      	bne.n	d4ba <at_get_pending_data_list_common_handle+0x7e>
                        (void)snprintf(rsp_string, AT_MAX_NQSOS_READ_RSP_LEN, ",%d", seq_num);
    d4a2:	4a21      	ldr	r2, [pc, #132]	; (d528 <at_get_pending_data_list_common_handle+0xec>)
    d4a4:	2114      	movs	r1, #20
    d4a6:	a807      	add	r0, sp, #28
    d4a8:	f00d f9e0 	bl	1a86c <snprintf>
    d4ac:	e021      	b.n	d4f2 <at_get_pending_data_list_common_handle+0xb6>
        irfree(data_seqs);
    d4ae:	0020      	movs	r0, r4
    d4b0:	f005 fac2 	bl	12a38 <irfree>
        return AT_RET_PROGRESS_ERROR;
    d4b4:	2006      	movs	r0, #6
}
    d4b6:	b00d      	add	sp, #52	; 0x34
    d4b8:	bdf0      	pop	{r4, r5, r6, r7, pc}
                            (void)snprintf(rsp_string, AT_MAX_NQSOS_READ_RSP_LEN, "%s%d", AT_CMD_NQPNPD_STR, seq_num);
    d4ba:	9300      	str	r3, [sp, #0]
    d4bc:	4b1b      	ldr	r3, [pc, #108]	; (d52c <at_get_pending_data_list_common_handle+0xf0>)
    d4be:	e013      	b.n	d4e8 <at_get_pending_data_list_common_handle+0xac>
                    (void)snprintf(rsp_string, AT_MAX_NQSOS_READ_RSP_LEN, "%s%d,%d", AT_CMD_NQSOS_STR, pending_data_sent_list_index, seq_num);
    d4c0:	9301      	str	r3, [sp, #4]
    d4c2:	4a1b      	ldr	r2, [pc, #108]	; (d530 <at_get_pending_data_list_common_handle+0xf4>)
    d4c4:	4b1b      	ldr	r3, [pc, #108]	; (d534 <at_get_pending_data_list_common_handle+0xf8>)
    d4c6:	2114      	movs	r1, #20
    d4c8:	9600      	str	r6, [sp, #0]
    d4ca:	a807      	add	r0, sp, #28
    d4cc:	f00d f9ce 	bl	1a86c <snprintf>
                     at_uart_write((unsigned char*)APP_AT_STR_RN, strlen(APP_AT_STR_RN));
    d4d0:	4819      	ldr	r0, [pc, #100]	; (d538 <at_get_pending_data_list_common_handle+0xfc>)
    d4d2:	f00d ff64 	bl	1b39e <strlen>
    d4d6:	0001      	movs	r1, r0
    d4d8:	4817      	ldr	r0, [pc, #92]	; (d538 <at_get_pending_data_list_common_handle+0xfc>)
    d4da:	f7fc fa87 	bl	99ec <at_uart_write>
    d4de:	e009      	b.n	d4f4 <at_get_pending_data_list_common_handle+0xb8>
                    if (is_nonip_first_pending)
    d4e0:	2d00      	cmp	r5, #0
    d4e2:	d0de      	beq.n	d4a2 <at_get_pending_data_list_common_handle+0x66>
                            (void)snprintf(rsp_string, AT_MAX_NQSOS_READ_RSP_LEN, "%s%d", AT_CMD_NQPODCP_STR, seq_num);
    d4e4:	9300      	str	r3, [sp, #0]
    d4e6:	4b15      	ldr	r3, [pc, #84]	; (d53c <at_get_pending_data_list_common_handle+0x100>)
                            (void)snprintf(rsp_string, AT_MAX_NQSOS_READ_RSP_LEN, "%s%d", AT_CMD_NQPNPD_STR, seq_num);
    d4e8:	4a15      	ldr	r2, [pc, #84]	; (d540 <at_get_pending_data_list_common_handle+0x104>)
    d4ea:	2114      	movs	r1, #20
    d4ec:	a807      	add	r0, sp, #28
    d4ee:	f00d f9bd 	bl	1a86c <snprintf>
                        (void)snprintf(rsp_string, AT_MAX_NQSOS_READ_RSP_LEN, ",%d", seq_num);
    d4f2:	2500      	movs	r5, #0
                *is_no_need_cr = false;
    d4f4:	2100      	movs	r1, #0
    d4f6:	9b05      	ldr	r3, [sp, #20]
                app_at_send_at_rsp_string(rsp_string, false, AT_FLAG_LOGABLE);
    d4f8:	2208      	movs	r2, #8
                *is_no_need_cr = false;
    d4fa:	7019      	strb	r1, [r3, #0]
                app_at_send_at_rsp_string(rsp_string, false, AT_FLAG_LOGABLE);
    d4fc:	a807      	add	r0, sp, #28
    d4fe:	f7fc f863 	bl	95c8 <app_at_send_at_rsp_string>
    d502:	3701      	adds	r7, #1
        for(uint8 j = 0; j < 8; j++)
    d504:	2f08      	cmp	r7, #8
    d506:	d1bb      	bne.n	d480 <at_get_pending_data_list_common_handle+0x44>
    for(uint16 i = 0 ; i < 32; i++)
    d508:	9802      	ldr	r0, [sp, #8]
    d50a:	3001      	adds	r0, #1
    d50c:	b283      	uxth	r3, r0
    d50e:	9302      	str	r3, [sp, #8]
    d510:	9b03      	ldr	r3, [sp, #12]
    d512:	3301      	adds	r3, #1
    d514:	9303      	str	r3, [sp, #12]
    d516:	9b02      	ldr	r3, [sp, #8]
    d518:	2b20      	cmp	r3, #32
    d51a:	d1ac      	bne.n	d476 <at_get_pending_data_list_common_handle+0x3a>
    irfree(data_seqs);
    d51c:	0020      	movs	r0, r4
    d51e:	f005 fa8b 	bl	12a38 <irfree>
    return AT_RET_OK;
    d522:	2000      	movs	r0, #0
    d524:	e7c7      	b.n	d4b6 <at_get_pending_data_list_common_handle+0x7a>
    d526:	46c0      	nop			; (mov r8, r8)
    d528:	0002394e 	.word	0x0002394e
    d52c:	0002358d 	.word	0x0002358d
    d530:	00023e83 	.word	0x00023e83
    d534:	00023596 	.word	0x00023596
    d538:	00022d8f 	.word	0x00022d8f
    d53c:	00023583 	.word	0x00023583
    d540:	000248db 	.word	0x000248db

0000d544 <at_common_get_pending_non_ip_send_data_list>:
{
    d544:	b537      	push	{r0, r1, r2, r4, r5, lr}
    bool          is_no_need_cr = true;
    d546:	466b      	mov	r3, sp
    d548:	1ddc      	adds	r4, r3, #7
    d54a:	2301      	movs	r3, #1
        pending_data_sent_list_index = AT_CP_ONLY_NON_IP_PENDING_DATA_LIST_INDEX;
    d54c:	25ff      	movs	r5, #255	; 0xff
    bool          is_no_need_cr = true;
    d54e:	7023      	strb	r3, [r4, #0]
    if (is_cplane_data_only)
    d550:	2800      	cmp	r0, #0
    d552:	d100      	bne.n	d556 <at_common_get_pending_non_ip_send_data_list+0x12>
        pending_data_sent_list_index = AT_CP_NON_IP_PENDING_DATA_LIST_INDEX;
    d554:	3d10      	subs	r5, #16
    at_uart_claim();
    d556:	f7fc fa27 	bl	99a8 <at_uart_claim>
    cause = at_get_pending_data_list_common_handle(pending_data_sent_list_index, &is_no_need_cr);
    d55a:	0028      	movs	r0, r5
    d55c:	0021      	movs	r1, r4
    d55e:	f7ff ff6d 	bl	d43c <at_get_pending_data_list_common_handle>
    d562:	1e05      	subs	r5, r0, #0
    if (cause != AT_RET_OK)
    d564:	d003      	beq.n	d56e <at_common_get_pending_non_ip_send_data_list+0x2a>
    at_uart_release();
    d566:	f7fc fa31 	bl	99cc <at_uart_release>
}
    d56a:	0028      	movs	r0, r5
    d56c:	bd3e      	pop	{r1, r2, r3, r4, r5, pc}
    if (!is_no_need_cr)
    d56e:	7823      	ldrb	r3, [r4, #0]
    d570:	2b00      	cmp	r3, #0
    d572:	d1f8      	bne.n	d566 <at_common_get_pending_non_ip_send_data_list+0x22>
        at_uart_write((unsigned char*)APP_AT_STR_RN, strlen(APP_AT_STR_RN));
    d574:	4c04      	ldr	r4, [pc, #16]	; (d588 <at_common_get_pending_non_ip_send_data_list+0x44>)
    d576:	0020      	movs	r0, r4
    d578:	f00d ff11 	bl	1b39e <strlen>
    d57c:	0001      	movs	r1, r0
    d57e:	0020      	movs	r0, r4
    d580:	f7fc fa34 	bl	99ec <at_uart_write>
    d584:	e7ef      	b.n	d566 <at_common_get_pending_non_ip_send_data_list+0x22>
    d586:	46c0      	nop			; (mov r8, r8)
    d588:	00022d8f 	.word	0x00022d8f

0000d58c <at_handle_NQPNPD_cmd_exec>:
{
    d58c:	b510      	push	{r4, lr}
    return at_common_get_pending_non_ip_send_data_list(false);
    d58e:	2000      	movs	r0, #0
    d590:	f7ff ffd8 	bl	d544 <at_common_get_pending_non_ip_send_data_list>
}
    d594:	bd10      	pop	{r4, pc}

0000d596 <at_handle_NQPODCP_cmd_exec>:
{
    d596:	b510      	push	{r4, lr}
    return at_common_get_pending_non_ip_send_data_list(true);
    d598:	2001      	movs	r0, #1
    d59a:	f7ff ffd3 	bl	d544 <at_common_get_pending_non_ip_send_data_list>
}
    d59e:	bd10      	pop	{r4, pc}

0000d5a0 <at_common_handle_non_ip_report_data_mode_test>:
{
    d5a0:	b5f0      	push	{r4, r5, r6, r7, lr}
    uint16 ip_mtu = 0, non_ip_mtu = 0, min_mtu = 0;
    d5a2:	2400      	movs	r4, #0
{
    d5a4:	b0b9      	sub	sp, #228	; 0xe4
    d5a6:	9003      	str	r0, [sp, #12]
    char  auc_rsp_data[AT_MAX_RSP_LEN] = {0};
    d5a8:	22c8      	movs	r2, #200	; 0xc8
    d5aa:	2100      	movs	r1, #0
    d5ac:	a806      	add	r0, sp, #24
    d5ae:	f7f2 fe97 	bl	2e0 <memset>
    uint16 ip_mtu = 0, non_ip_mtu = 0, min_mtu = 0;
    d5b2:	230e      	movs	r3, #14
    for (i = 0; i <= AT_MAX_CID; i++)
    d5b4:	0025      	movs	r5, r4
    uint16 ip_mtu = 0, non_ip_mtu = 0, min_mtu = 0;
    d5b6:	aa02      	add	r2, sp, #8
    d5b8:	ae05      	add	r6, sp, #20
    d5ba:	189b      	adds	r3, r3, r2
    d5bc:	8034      	strh	r4, [r6, #0]
    d5be:	801c      	strh	r4, [r3, #0]
        if (get_mtu_size(i, &ip_mtu, &non_ip_mtu) != NEUL_RET_OK)
    d5c0:	270e      	movs	r7, #14
    d5c2:	ab02      	add	r3, sp, #8
    d5c4:	18ff      	adds	r7, r7, r3
    d5c6:	003a      	movs	r2, r7
    d5c8:	0031      	movs	r1, r6
    d5ca:	0028      	movs	r0, r5
    d5cc:	f00f f8ff 	bl	1c7ce <get_mtu_size>
    d5d0:	2800      	cmp	r0, #0
    d5d2:	d107      	bne.n	d5e4 <at_common_handle_non_ip_report_data_mode_test+0x44>
    d5d4:	883b      	ldrh	r3, [r7, #0]
        if ((min_mtu == 0) || ((min_mtu > non_ip_mtu) && (non_ip_mtu != 0)))
    d5d6:	2c00      	cmp	r4, #0
    d5d8:	d003      	beq.n	d5e2 <at_common_handle_non_ip_report_data_mode_test+0x42>
    d5da:	42a3      	cmp	r3, r4
    d5dc:	d202      	bcs.n	d5e4 <at_common_handle_non_ip_report_data_mode_test+0x44>
    d5de:	2b00      	cmp	r3, #0
    d5e0:	d000      	beq.n	d5e4 <at_common_handle_non_ip_report_data_mode_test+0x44>
    d5e2:	001c      	movs	r4, r3
    for (i = 0; i <= AT_MAX_CID; i++)
    d5e4:	3501      	adds	r5, #1
    d5e6:	b2ed      	uxtb	r5, r5
    d5e8:	2d0b      	cmp	r5, #11
    d5ea:	d1e9      	bne.n	d5c0 <at_common_handle_non_ip_report_data_mode_test+0x20>
    (void)snprintf(auc_rsp_data, AT_MAX_RSP_LEN, "%s:(0-1),(0-%d),(%d)", prefix, AT_MAX_CID, min_mtu);
    d5ec:	230a      	movs	r3, #10
    d5ee:	4a07      	ldr	r2, [pc, #28]	; (d60c <at_common_handle_non_ip_report_data_mode_test+0x6c>)
    d5f0:	9300      	str	r3, [sp, #0]
    d5f2:	21c8      	movs	r1, #200	; 0xc8
    d5f4:	9b03      	ldr	r3, [sp, #12]
    d5f6:	9401      	str	r4, [sp, #4]
    d5f8:	a806      	add	r0, sp, #24
    d5fa:	f00d f937 	bl	1a86c <snprintf>
    app_at_send_at_rsp_string_lines_with_claim_and_log(auc_rsp_data);
    d5fe:	a806      	add	r0, sp, #24
    d600:	f7fb fff0 	bl	95e4 <app_at_send_at_rsp_string_lines_with_claim_and_log>
}
    d604:	2000      	movs	r0, #0
    d606:	b039      	add	sp, #228	; 0xe4
    d608:	bdf0      	pop	{r4, r5, r6, r7, pc}
    d60a:	46c0      	nop			; (mov r8, r8)
    d60c:	00023530 	.word	0x00023530

0000d610 <at_handle_NRNPDM_cmd_test>:
{
    d610:	b510      	push	{r4, lr}
    return at_common_handle_non_ip_report_data_mode_test(AT_CMD_NRNPDM_PREFIX);
    d612:	4802      	ldr	r0, [pc, #8]	; (d61c <at_handle_NRNPDM_cmd_test+0xc>)
    d614:	f7ff ffc4 	bl	d5a0 <at_common_handle_non_ip_report_data_mode_test>
}
    d618:	bd10      	pop	{r4, pc}
    d61a:	46c0      	nop			; (mov r8, r8)
    d61c:	00022e64 	.word	0x00022e64

0000d620 <at_handle_CRTDCP_cmd_test>:
{
    d620:	b510      	push	{r4, lr}
    return at_common_handle_non_ip_report_data_mode_test(AT_CMD_CRTDCP);
    d622:	4802      	ldr	r0, [pc, #8]	; (d62c <at_handle_CRTDCP_cmd_test+0xc>)
    d624:	f7ff ffbc 	bl	d5a0 <at_common_handle_non_ip_report_data_mode_test>
}
    d628:	bd10      	pop	{r4, pc}
    d62a:	46c0      	nop			; (mov r8, r8)
    d62c:	00022e5c 	.word	0x00022e5c

0000d630 <at_common_non_ip_send_data_test>:
{
    d630:	b5f0      	push	{r4, r5, r6, r7, lr}
    uint16 ip_mtu = 0, non_ip_mtu = 0, min_mtu = 0;
    d632:	2400      	movs	r4, #0
{
    d634:	b0bf      	sub	sp, #252	; 0xfc
    d636:	9009      	str	r0, [sp, #36]	; 0x24
    char  auc_rsp_data[AT_MAX_RSP_LEN] = {0};
    d638:	22c8      	movs	r2, #200	; 0xc8
    d63a:	2100      	movs	r1, #0
    d63c:	a80c      	add	r0, sp, #48	; 0x30
    d63e:	f7f2 fe4f 	bl	2e0 <memset>
    uint16 ip_mtu = 0, non_ip_mtu = 0, min_mtu = 0;
    d642:	2326      	movs	r3, #38	; 0x26
    for (i = 0; i <= AT_MAX_CID; i++)
    d644:	0025      	movs	r5, r4
    uint16 ip_mtu = 0, non_ip_mtu = 0, min_mtu = 0;
    d646:	aa02      	add	r2, sp, #8
    d648:	ae0b      	add	r6, sp, #44	; 0x2c
    d64a:	189b      	adds	r3, r3, r2
    d64c:	8034      	strh	r4, [r6, #0]
    d64e:	801c      	strh	r4, [r3, #0]
        if (get_mtu_size(i, &ip_mtu, &non_ip_mtu) != NEUL_RET_OK)
    d650:	2726      	movs	r7, #38	; 0x26
    d652:	ab02      	add	r3, sp, #8
    d654:	18ff      	adds	r7, r7, r3
    d656:	003a      	movs	r2, r7
    d658:	0031      	movs	r1, r6
    d65a:	0028      	movs	r0, r5
    d65c:	f00f f8b7 	bl	1c7ce <get_mtu_size>
    d660:	2800      	cmp	r0, #0
    d662:	d107      	bne.n	d674 <at_common_non_ip_send_data_test+0x44>
    d664:	883b      	ldrh	r3, [r7, #0]
        if ((min_mtu == 0) || ((min_mtu > non_ip_mtu) && (non_ip_mtu != 0)))
    d666:	2c00      	cmp	r4, #0
    d668:	d003      	beq.n	d672 <at_common_non_ip_send_data_test+0x42>
    d66a:	42a3      	cmp	r3, r4
    d66c:	d202      	bcs.n	d674 <at_common_non_ip_send_data_test+0x44>
    d66e:	2b00      	cmp	r3, #0
    d670:	d000      	beq.n	d674 <at_common_non_ip_send_data_test+0x44>
    d672:	001c      	movs	r4, r3
    for (i = 0; i <= AT_MAX_CID; i++)
    d674:	3501      	adds	r5, #1
    d676:	b2ed      	uxtb	r5, r5
    d678:	2d0b      	cmp	r5, #11
    d67a:	d1e9      	bne.n	d650 <at_common_non_ip_send_data_test+0x20>
    (void)snprintf(auc_rsp_data, AT_MAX_RSP_LEN, "%s:(0-%d),(%d),(%d,%d,%d),(%d,%d),(1-255)", string_prefix,AT_MAX_CID,min_mtu,AT_CSODCP_RAI_DEFAULT_VALUE,
    d67c:	2301      	movs	r3, #1
    d67e:	2500      	movs	r5, #0
    d680:	2202      	movs	r2, #2
    d682:	9306      	str	r3, [sp, #24]
    d684:	9303      	str	r3, [sp, #12]
    d686:	3309      	adds	r3, #9
    d688:	9204      	str	r2, [sp, #16]
    d68a:	9300      	str	r3, [sp, #0]
    d68c:	4a07      	ldr	r2, [pc, #28]	; (d6ac <at_common_non_ip_send_data_test+0x7c>)
    d68e:	9b09      	ldr	r3, [sp, #36]	; 0x24
    d690:	21c8      	movs	r1, #200	; 0xc8
    d692:	9505      	str	r5, [sp, #20]
    d694:	9502      	str	r5, [sp, #8]
    d696:	9401      	str	r4, [sp, #4]
    d698:	a80c      	add	r0, sp, #48	; 0x30
    d69a:	f00d f8e7 	bl	1a86c <snprintf>
    app_at_send_at_rsp_string_lines_with_claim_and_log(auc_rsp_data);
    d69e:	a80c      	add	r0, sp, #48	; 0x30
    d6a0:	f7fb ffa0 	bl	95e4 <app_at_send_at_rsp_string_lines_with_claim_and_log>
}
    d6a4:	0028      	movs	r0, r5
    d6a6:	b03f      	add	sp, #252	; 0xfc
    d6a8:	bdf0      	pop	{r4, r5, r6, r7, pc}
    d6aa:	46c0      	nop			; (mov r8, r8)
    d6ac:	00023545 	.word	0x00023545

0000d6b0 <at_handle_NSNPD_cmd_test>:
{
    d6b0:	b510      	push	{r4, lr}
    return at_common_non_ip_send_data_test(AT_CMD_NSNPD_PREFIX);
    d6b2:	4802      	ldr	r0, [pc, #8]	; (d6bc <at_handle_NSNPD_cmd_test+0xc>)
    d6b4:	f7ff ffbc 	bl	d630 <at_common_non_ip_send_data_test>
}
    d6b8:	bd10      	pop	{r4, pc}
    d6ba:	46c0      	nop			; (mov r8, r8)
    d6bc:	00023d4c 	.word	0x00023d4c

0000d6c0 <at_handle_CSODCP_cmd_test>:
{
    d6c0:	b510      	push	{r4, lr}
    return at_common_non_ip_send_data_test(AT_CMD_CSODCP);
    d6c2:	4802      	ldr	r0, [pc, #8]	; (d6cc <at_handle_CSODCP_cmd_test+0xc>)
    d6c4:	f7ff ffb4 	bl	d630 <at_common_non_ip_send_data_test>
}
    d6c8:	bd10      	pop	{r4, pc}
    d6ca:	46c0      	nop			; (mov r8, r8)
    d6cc:	0002398b 	.word	0x0002398b

0000d6d0 <at_handle_NRNPDM_cmd_read>:
{
    d6d0:	b510      	push	{r4, lr}
    char  auc_rsp_data[AT_MAX_RSP_LEN] = {0};
    d6d2:	24c8      	movs	r4, #200	; 0xc8
{
    d6d4:	b0b4      	sub	sp, #208	; 0xd0
    char  auc_rsp_data[AT_MAX_RSP_LEN] = {0};
    d6d6:	0022      	movs	r2, r4
    d6d8:	2100      	movs	r1, #0
    d6da:	a802      	add	r0, sp, #8
    d6dc:	f7f2 fe00 	bl	2e0 <memset>
    mode = (uint8)at_get_non_ip_data_report_mode();
    d6e0:	f7fb fc98 	bl	9014 <at_get_non_ip_data_report_mode>
    (void)snprintf(auc_rsp_data, AT_MAX_RSP_LEN, "%s:%d", AT_CMD_NRNPDM_PREFIX, mode);
    d6e4:	4b06      	ldr	r3, [pc, #24]	; (d700 <at_handle_NRNPDM_cmd_read+0x30>)
    d6e6:	9000      	str	r0, [sp, #0]
    d6e8:	4a06      	ldr	r2, [pc, #24]	; (d704 <at_handle_NRNPDM_cmd_read+0x34>)
    d6ea:	0021      	movs	r1, r4
    d6ec:	a802      	add	r0, sp, #8
    d6ee:	f00d f8bd 	bl	1a86c <snprintf>
    app_at_send_at_rsp_string_lines_with_claim_and_log(auc_rsp_data);
    d6f2:	a802      	add	r0, sp, #8
    d6f4:	f7fb ff76 	bl	95e4 <app_at_send_at_rsp_string_lines_with_claim_and_log>
}
    d6f8:	2000      	movs	r0, #0
    d6fa:	b034      	add	sp, #208	; 0xd0
    d6fc:	bd10      	pop	{r4, pc}
    d6fe:	46c0      	nop			; (mov r8, r8)
    d700:	00022e64 	.word	0x00022e64
    d704:	00023bdc 	.word	0x00023bdc

0000d708 <at_handle_CRTDCP_cmd_read>:
{
    d708:	b530      	push	{r4, r5, lr}
    char                        auc_rsp_data[AT_MAX_RSP_LEN] = {0};
    d70a:	24c8      	movs	r4, #200	; 0xc8
    at_query_crtdcp_mode(&mode);
    d70c:	250f      	movs	r5, #15
{
    d70e:	b0b7      	sub	sp, #220	; 0xdc
    char                        auc_rsp_data[AT_MAX_RSP_LEN] = {0};
    d710:	0022      	movs	r2, r4
    d712:	2100      	movs	r1, #0
    at_query_crtdcp_mode(&mode);
    d714:	446d      	add	r5, sp
    char                        auc_rsp_data[AT_MAX_RSP_LEN] = {0};
    d716:	a804      	add	r0, sp, #16
    d718:	f7f2 fde2 	bl	2e0 <memset>
    at_query_crtdcp_mode(&mode);
    d71c:	0028      	movs	r0, r5
    d71e:	f7fb fc63 	bl	8fe8 <at_query_crtdcp_mode>
    (void)snprintf(auc_rsp_data, AT_MAX_RSP_LEN, "%s:%d", AT_CMD_CRTDCP, mode);
    d722:	782b      	ldrb	r3, [r5, #0]
    d724:	4a06      	ldr	r2, [pc, #24]	; (d740 <at_handle_CRTDCP_cmd_read+0x38>)
    d726:	9300      	str	r3, [sp, #0]
    d728:	0021      	movs	r1, r4
    d72a:	4b06      	ldr	r3, [pc, #24]	; (d744 <at_handle_CRTDCP_cmd_read+0x3c>)
    d72c:	a804      	add	r0, sp, #16
    d72e:	f00d f89d 	bl	1a86c <snprintf>
    app_at_send_at_rsp_string_lines_with_claim_and_log(auc_rsp_data);
    d732:	a804      	add	r0, sp, #16
    d734:	f7fb ff56 	bl	95e4 <app_at_send_at_rsp_string_lines_with_claim_and_log>
}
    d738:	2000      	movs	r0, #0
    d73a:	b037      	add	sp, #220	; 0xdc
    d73c:	bd30      	pop	{r4, r5, pc}
    d73e:	46c0      	nop			; (mov r8, r8)
    d740:	00023bdc 	.word	0x00023bdc
    d744:	00022e5c 	.word	0x00022e5c

0000d748 <at_handle_CGACT_cmd_read>:
{
    d748:	b530      	push	{r4, r5, lr}
    d74a:	b08b      	sub	sp, #44	; 0x2c
    char           rsp_string[AT_MAX_CGACT_RSP_LEN] = {0};
    d74c:	2219      	movs	r2, #25
    d74e:	2100      	movs	r1, #0
    d750:	a803      	add	r0, sp, #12
    d752:	f7f2 fdc5 	bl	2e0 <memset>
    d756:	2400      	movs	r4, #0
        if(get_pdp_state(cid, &state) == NEUL_RET_OK)
    d758:	250b      	movs	r5, #11
    d75a:	446d      	add	r5, sp
    d75c:	b2e0      	uxtb	r0, r4
    d75e:	0029      	movs	r1, r5
    d760:	f00e ffa4 	bl	1c6ac <get_pdp_state>
    d764:	2800      	cmp	r0, #0
    d766:	d10a      	bne.n	d77e <at_handle_CGACT_cmd_read+0x36>
            (void)snprintf(rsp_string, AT_MAX_CGACT_RSP_LEN, "+CGACT:%d,%d", cid, state);
    d768:	782b      	ldrb	r3, [r5, #0]
    d76a:	4a08      	ldr	r2, [pc, #32]	; (d78c <at_handle_CGACT_cmd_read+0x44>)
    d76c:	9300      	str	r3, [sp, #0]
    d76e:	2119      	movs	r1, #25
    d770:	0023      	movs	r3, r4
    d772:	a803      	add	r0, sp, #12
    d774:	f00d f87a 	bl	1a86c <snprintf>
            app_at_send_at_rsp_string_lines_with_claim_and_log(rsp_string);
    d778:	a803      	add	r0, sp, #12
    d77a:	f7fb ff33 	bl	95e4 <app_at_send_at_rsp_string_lines_with_claim_and_log>
    d77e:	3401      	adds	r4, #1
    for(cid = 0; cid <= AT_MAX_CID; cid++)
    d780:	2c0b      	cmp	r4, #11
    d782:	d1e9      	bne.n	d758 <at_handle_CGACT_cmd_read+0x10>
}
    d784:	2000      	movs	r0, #0
    d786:	b00b      	add	sp, #44	; 0x2c
    d788:	bd30      	pop	{r4, r5, pc}
    d78a:	46c0      	nop			; (mov r8, r8)
    d78c:	0002366e 	.word	0x0002366e

0000d790 <at_handle_CGACT_cmd_set>:
{
    d790:	b537      	push	{r0, r1, r2, r4, r5, lr}
    uint16         cid = 0;
    d792:	466b      	mov	r3, sp
    d794:	1d9c      	adds	r4, r3, #6
    d796:	2300      	movs	r3, #0
    cause = at_create_param_array(p_atparams_string, &num_recvparams, AT_MAX_CGACT_PARAM, AT_MAX_CGACT_PARAM);
    d798:	4669      	mov	r1, sp
    uint16         cid = 0;
    d79a:	8023      	strh	r3, [r4, #0]
    cause = at_create_param_array(p_atparams_string, &num_recvparams, AT_MAX_CGACT_PARAM, AT_MAX_CGACT_PARAM);
    d79c:	3302      	adds	r3, #2
    d79e:	001a      	movs	r2, r3
    d7a0:	3103      	adds	r1, #3
    d7a2:	f7fc fd9f 	bl	a2e4 <at_create_param_array>
    if(cause != AT_RET_OK)
    d7a6:	2800      	cmp	r0, #0
    d7a8:	d107      	bne.n	d7ba <at_handle_CGACT_cmd_set+0x2a>
    cause = at_get_uint16_param(AT_PARSE_FIRST_PARAM_POS, &state, true);
    d7aa:	ad01      	add	r5, sp, #4
    d7ac:	2201      	movs	r2, #1
    d7ae:	0029      	movs	r1, r5
    d7b0:	f7fc feac 	bl	a50c <at_get_uint16_param>
    if(cause != AT_RET_OK)
    d7b4:	2800      	cmp	r0, #0
    d7b6:	d001      	beq.n	d7bc <at_handle_CGACT_cmd_set+0x2c>
        return AT_RET_SYNTAX_ERROR;
    d7b8:	2001      	movs	r0, #1
}
    d7ba:	bd3e      	pop	{r1, r2, r3, r4, r5, pc}
    cause = at_get_uint16_param(AT_PARSE_SECOND_PARAM_POS, &cid, true);
    d7bc:	2201      	movs	r2, #1
    d7be:	0021      	movs	r1, r4
    d7c0:	0010      	movs	r0, r2
    d7c2:	f7fc fea3 	bl	a50c <at_get_uint16_param>
    d7c6:	1e01      	subs	r1, r0, #0
    if(cause != AT_RET_OK)
    d7c8:	d1f6      	bne.n	d7b8 <at_handle_CGACT_cmd_set+0x28>
    if(state == 0)
    d7ca:	882b      	ldrh	r3, [r5, #0]
    d7cc:	2b00      	cmp	r3, #0
    d7ce:	d105      	bne.n	d7dc <at_handle_CGACT_cmd_set+0x4c>
        neul_ret = deactivate_pdp_req(cid);
    d7d0:	8820      	ldrh	r0, [r4, #0]
    d7d2:	f00e ff41 	bl	1c658 <deactivate_pdp_req>
    return at_parse_convert_neul_result(neul_ret);
    d7d6:	f7fc fd5b 	bl	a290 <at_parse_convert_neul_result>
    d7da:	e7ee      	b.n	d7ba <at_handle_CGACT_cmd_set+0x2a>
    else if(state == 1)
    d7dc:	2b01      	cmp	r3, #1
    d7de:	d1eb      	bne.n	d7b8 <at_handle_CGACT_cmd_set+0x28>
        neul_ret = activate_pdp_req(cid, NULL);
    d7e0:	8820      	ldrh	r0, [r4, #0]
    d7e2:	f00e ff25 	bl	1c630 <activate_pdp_req>
    d7e6:	e7f6      	b.n	d7d6 <at_handle_CGACT_cmd_set+0x46>

0000d7e8 <at_handle_CMGC_cmd_set>:
{
    d7e8:	b513      	push	{r0, r1, r4, lr}
    uint16         len = 0;
    d7ea:	466b      	mov	r3, sp
    d7ec:	1d9c      	adds	r4, r3, #6
    d7ee:	2300      	movs	r3, #0
    cause = at_create_param_array(p_atparams_string, &num_recvparams, 1, 1);
    d7f0:	4669      	mov	r1, sp
    uint16         len = 0;
    d7f2:	8023      	strh	r3, [r4, #0]
    cause = at_create_param_array(p_atparams_string, &num_recvparams, 1, 1);
    d7f4:	3301      	adds	r3, #1
    d7f6:	001a      	movs	r2, r3
    d7f8:	3105      	adds	r1, #5
    d7fa:	f7fc fd73 	bl	a2e4 <at_create_param_array>
    if(cause != AT_RET_OK)
    d7fe:	2800      	cmp	r0, #0
    d800:	d118      	bne.n	d834 <at_handle_CMGC_cmd_set+0x4c>
    cause = at_get_uint16_param(AT_PARSE_FIRST_PARAM_POS, &len , true);
    d802:	2201      	movs	r2, #1
    d804:	0021      	movs	r1, r4
    d806:	f7fc fe81 	bl	a50c <at_get_uint16_param>
    if (cause != AT_RET_OK)
    d80a:	2800      	cmp	r0, #0
    d80c:	d112      	bne.n	d834 <at_handle_CMGC_cmd_set+0x4c>
    if(len > AT_SMS_CMGC_MAX_DATA_LEN || len < AT_SMS_CMGC_MIN_DATA_LEN)
    d80e:	8823      	ldrh	r3, [r4, #0]
        return AT_RET_SYNTAX_ERROR;
    d810:	3001      	adds	r0, #1
    if(len > AT_SMS_CMGC_MAX_DATA_LEN || len < AT_SMS_CMGC_MIN_DATA_LEN)
    d812:	3b08      	subs	r3, #8
    d814:	2ba6      	cmp	r3, #166	; 0xa6
    d816:	d80d      	bhi.n	d834 <at_handle_CMGC_cmd_set+0x4c>
    set_wait_for_sms_data();
    d818:	f7fb fca2 	bl	9160 <set_wait_for_sms_data>
    set_is_pdu();
    d81c:	f7fb fcb8 	bl	9190 <set_is_pdu>
    set_at_sms_msg_type(AT_SMS_MESSAGE_CMGC);
    d820:	2003      	movs	r0, #3
    d822:	f7fb fc97 	bl	9154 <set_at_sms_msg_type>
    set_sms_len(len);
    d826:	8820      	ldrh	r0, [r4, #0]
    d828:	f7fb fa5c 	bl	8ce4 <set_sms_len>
    app_at_send_at_rsp_string_lines_with_claim_and_log("> ");
    d82c:	4802      	ldr	r0, [pc, #8]	; (d838 <at_handle_CMGC_cmd_set+0x50>)
    d82e:	f7fb fed9 	bl	95e4 <app_at_send_at_rsp_string_lines_with_claim_and_log>
    return cause;
    d832:	2024      	movs	r0, #36	; 0x24
}
    d834:	bd16      	pop	{r1, r2, r4, pc}
    d836:	46c0      	nop			; (mov r8, r8)
    d838:	0002389c 	.word	0x0002389c

0000d83c <at_handle_CMGS_cmd_set>:
{
    d83c:	b513      	push	{r0, r1, r4, lr}
    uint16         len = 0;
    d83e:	466b      	mov	r3, sp
    d840:	1d9c      	adds	r4, r3, #6
    d842:	2300      	movs	r3, #0
    cause = at_create_param_array(p_atparams_string, &num_recvparams, 1, 1);
    d844:	4669      	mov	r1, sp
    uint16         len = 0;
    d846:	8023      	strh	r3, [r4, #0]
    cause = at_create_param_array(p_atparams_string, &num_recvparams, 1, 1);
    d848:	3301      	adds	r3, #1
    d84a:	001a      	movs	r2, r3
    d84c:	3105      	adds	r1, #5
    d84e:	f7fc fd49 	bl	a2e4 <at_create_param_array>
    if(cause != AT_RET_OK)
    d852:	2800      	cmp	r0, #0
    d854:	d118      	bne.n	d888 <at_handle_CMGS_cmd_set+0x4c>
    cause = at_get_uint16_param(AT_PARSE_FIRST_PARAM_POS, &len , true);
    d856:	2201      	movs	r2, #1
    d858:	0021      	movs	r1, r4
    d85a:	f7fc fe57 	bl	a50c <at_get_uint16_param>
    if (cause != AT_RET_OK)
    d85e:	2800      	cmp	r0, #0
    d860:	d112      	bne.n	d888 <at_handle_CMGS_cmd_set+0x4c>
    if(len > AT_SMS_CMGS_MAX_DATA_LEN || len < AT_SMS_CMGS_MIN_DATA_LEN)
    d862:	8823      	ldrh	r3, [r4, #0]
       return AT_RET_SYNTAX_ERROR;
    d864:	3001      	adds	r0, #1
    if(len > AT_SMS_CMGS_MAX_DATA_LEN || len < AT_SMS_CMGS_MIN_DATA_LEN)
    d866:	3b07      	subs	r3, #7
    d868:	2b9d      	cmp	r3, #157	; 0x9d
    d86a:	d80d      	bhi.n	d888 <at_handle_CMGS_cmd_set+0x4c>
    set_wait_for_sms_data();
    d86c:	f7fb fc78 	bl	9160 <set_wait_for_sms_data>
    set_is_pdu();
    d870:	f7fb fc8e 	bl	9190 <set_is_pdu>
    set_at_sms_msg_type(AT_SMS_MESSAGE_CMGS);
    d874:	2002      	movs	r0, #2
    d876:	f7fb fc6d 	bl	9154 <set_at_sms_msg_type>
    set_sms_len(len);
    d87a:	8820      	ldrh	r0, [r4, #0]
    d87c:	f7fb fa32 	bl	8ce4 <set_sms_len>
    app_at_send_at_rsp_string_lines_with_claim_and_log("> ");
    d880:	4802      	ldr	r0, [pc, #8]	; (d88c <at_handle_CMGS_cmd_set+0x50>)
    d882:	f7fb feaf 	bl	95e4 <app_at_send_at_rsp_string_lines_with_claim_and_log>
    return cause;
    d886:	2024      	movs	r0, #36	; 0x24
}
    d888:	bd16      	pop	{r1, r2, r4, pc}
    d88a:	46c0      	nop			; (mov r8, r8)
    d88c:	0002389c 	.word	0x0002389c

0000d890 <at_handle_CNMA_cmd_set>:
{
    d890:	b537      	push	{r0, r1, r2, r4, r5, lr}
    uint16         type = 0;
    d892:	466a      	mov	r2, sp
    uint16         len  = 0;
    d894:	2300      	movs	r3, #0
    cause = at_create_param_array(p_atparams_string, &num_recvparams, 1, 2);
    d896:	4669      	mov	r1, sp
    uint16         type = 0;
    d898:	1d94      	adds	r4, r2, #6
    uint16         len  = 0;
    d89a:	ad01      	add	r5, sp, #4
    d89c:	802b      	strh	r3, [r5, #0]
    uint16         type = 0;
    d89e:	8023      	strh	r3, [r4, #0]
    cause = at_create_param_array(p_atparams_string, &num_recvparams, 1, 2);
    d8a0:	2201      	movs	r2, #1
    d8a2:	3302      	adds	r3, #2
    d8a4:	3103      	adds	r1, #3
    d8a6:	f7fc fd1d 	bl	a2e4 <at_create_param_array>
    if(cause != AT_RET_OK)
    d8aa:	2800      	cmp	r0, #0
    d8ac:	d10a      	bne.n	d8c4 <at_handle_CNMA_cmd_set+0x34>
    cause = at_get_uint16_param(AT_PARSE_FIRST_PARAM_POS, &type , true);
    d8ae:	2201      	movs	r2, #1
    d8b0:	0021      	movs	r1, r4
    d8b2:	f7fc fe2b 	bl	a50c <at_get_uint16_param>
    if (cause == AT_RET_OK)
    d8b6:	2800      	cmp	r0, #0
    d8b8:	d104      	bne.n	d8c4 <at_handle_CNMA_cmd_set+0x34>
        if (type != NEUL_SMS_DR_OK + 1 && type != NEUL_SMS_DR_ERROR + 1)
    d8ba:	8823      	ldrh	r3, [r4, #0]
    d8bc:	3b01      	subs	r3, #1
    d8be:	2b01      	cmp	r3, #1
    d8c0:	d901      	bls.n	d8c6 <at_handle_CNMA_cmd_set+0x36>
            return AT_RET_SYNTAX_ERROR;
    d8c2:	2001      	movs	r0, #1
}
    d8c4:	bd3e      	pop	{r1, r2, r3, r4, r5, pc}
    cause = at_get_uint16_param(AT_PARSE_SECOND_PARAM_POS, &len , true);
    d8c6:	2201      	movs	r2, #1
    d8c8:	0029      	movs	r1, r5
    d8ca:	0010      	movs	r0, r2
    d8cc:	f7fc fe1e 	bl	a50c <at_get_uint16_param>
    if (cause == AT_RET_OK)
    d8d0:	2800      	cmp	r0, #0
    d8d2:	d109      	bne.n	d8e8 <at_handle_CNMA_cmd_set+0x58>
        if (len > NEUL_SMS_MAX_TPDU_LEN)
    d8d4:	882b      	ldrh	r3, [r5, #0]
    d8d6:	2be8      	cmp	r3, #232	; 0xe8
    d8d8:	d8f3      	bhi.n	d8c2 <at_handle_CNMA_cmd_set+0x32>
    result = get_cnma_acknowledgement_expected();
    d8da:	f00f f9b6 	bl	1cc4a <get_cnma_acknowledgement_expected>
    if (result != NEUL_RET_OK)
    d8de:	2800      	cmp	r0, #0
    d8e0:	d005      	beq.n	d8ee <at_handle_CNMA_cmd_set+0x5e>
        return at_parse_convert_neul_result(result);
    d8e2:	f7fc fcd5 	bl	a290 <at_parse_convert_neul_result>
    d8e6:	e7ed      	b.n	d8c4 <at_handle_CNMA_cmd_set+0x34>
    else if (cause != AT_RET_PARAM_MISSING)
    d8e8:	2803      	cmp	r0, #3
    d8ea:	d1eb      	bne.n	d8c4 <at_handle_CNMA_cmd_set+0x34>
    d8ec:	e7f5      	b.n	d8da <at_handle_CNMA_cmd_set+0x4a>
    if (len == 0)
    d8ee:	8829      	ldrh	r1, [r5, #0]
    d8f0:	2900      	cmp	r1, #0
    d8f2:	d106      	bne.n	d902 <at_handle_CNMA_cmd_set+0x72>
        result = set_new_msg_ack((NEUL_SMS_RECEIVE_PDU_RES_TYPE)(type - 1), 0, NULL);
    d8f4:	8820      	ldrh	r0, [r4, #0]
    d8f6:	000a      	movs	r2, r1
    d8f8:	3801      	subs	r0, #1
    d8fa:	b2c0      	uxtb	r0, r0
    d8fc:	f00f f994 	bl	1cc28 <set_new_msg_ack>
    d900:	e7ef      	b.n	d8e2 <at_handle_CNMA_cmd_set+0x52>
    set_wait_for_sms_data();
    d902:	f7fb fc2d 	bl	9160 <set_wait_for_sms_data>
    set_is_pdu();
    d906:	f7fb fc43 	bl	9190 <set_is_pdu>
    set_at_sms_msg_type(AT_SMS_MESSAGE_CNMA);
    d90a:	2001      	movs	r0, #1
    d90c:	f7fb fc22 	bl	9154 <set_at_sms_msg_type>
    set_sms_len(len);
    d910:	8828      	ldrh	r0, [r5, #0]
    d912:	f7fb f9e7 	bl	8ce4 <set_sms_len>
    set_report_type((NEUL_SMS_RECEIVE_PDU_RES_TYPE)(type - 1));
    d916:	8820      	ldrh	r0, [r4, #0]
    d918:	3801      	subs	r0, #1
    d91a:	b2c0      	uxtb	r0, r0
    d91c:	f7fb fc32 	bl	9184 <set_report_type>
    app_at_send_at_rsp_string_lines_with_claim_and_log("> ");
    d920:	4802      	ldr	r0, [pc, #8]	; (d92c <at_handle_CNMA_cmd_set+0x9c>)
    d922:	f7fb fe5f 	bl	95e4 <app_at_send_at_rsp_string_lines_with_claim_and_log>
    return cause;
    d926:	2024      	movs	r0, #36	; 0x24
    d928:	e7cc      	b.n	d8c4 <at_handle_CNMA_cmd_set+0x34>
    d92a:	46c0      	nop			; (mov r8, r8)
    d92c:	0002389c 	.word	0x0002389c

0000d930 <at_handle_CMMS_cmd_read>:
{
    d930:	b530      	push	{r4, r5, lr}
    d932:	b085      	sub	sp, #20
    char        rsp_string[10] = {0};
    d934:	220a      	movs	r2, #10
    d936:	2100      	movs	r1, #0
    d938:	a801      	add	r0, sp, #4
    d93a:	f7f2 fcd1 	bl	2e0 <memset>
    uint8       mode=0;
    d93e:	466b      	mov	r3, sp
    d940:	1cdd      	adds	r5, r3, #3
    d942:	2300      	movs	r3, #0
    result = read_more_message_to_send(&mode);
    d944:	0028      	movs	r0, r5
    uint8       mode=0;
    d946:	702b      	strb	r3, [r5, #0]
    result = read_more_message_to_send(&mode);
    d948:	f00f f925 	bl	1cb96 <read_more_message_to_send>
    cause = at_parse_convert_neul_result(result);
    d94c:	f7fc fca0 	bl	a290 <at_parse_convert_neul_result>
    d950:	1e04      	subs	r4, r0, #0
    if(cause == AT_RET_OK )
    d952:	d10f      	bne.n	d974 <at_handle_CMMS_cmd_read+0x44>
        len = (uint16)snprintf(rsp_string,7,"+CMMS:");
    d954:	4a09      	ldr	r2, [pc, #36]	; (d97c <at_handle_CMMS_cmd_read+0x4c>)
    d956:	2107      	movs	r1, #7
    d958:	a801      	add	r0, sp, #4
    d95a:	f00c ff87 	bl	1a86c <snprintf>
        (void)snprintf(rsp_string+len, 2, "%d", mode);
    d95e:	aa01      	add	r2, sp, #4
    d960:	b280      	uxth	r0, r0
    d962:	1810      	adds	r0, r2, r0
    d964:	782b      	ldrb	r3, [r5, #0]
    d966:	4a06      	ldr	r2, [pc, #24]	; (d980 <at_handle_CMMS_cmd_read+0x50>)
    d968:	2102      	movs	r1, #2
    d96a:	f00c ff7f 	bl	1a86c <snprintf>
        app_at_send_at_rsp_string_lines_with_claim_and_log(rsp_string);
    d96e:	a801      	add	r0, sp, #4
    d970:	f7fb fe38 	bl	95e4 <app_at_send_at_rsp_string_lines_with_claim_and_log>
}
    d974:	0020      	movs	r0, r4
    d976:	b005      	add	sp, #20
    d978:	bd30      	pop	{r4, r5, pc}
    d97a:	46c0      	nop			; (mov r8, r8)
    d97c:	0002389f 	.word	0x0002389f
    d980:	00022e8f 	.word	0x00022e8f

0000d984 <at_handle_CSMS_cmd_read>:
{
    d984:	b5f0      	push	{r4, r5, r6, r7, lr}
    d986:	b08b      	sub	sp, #44	; 0x2c
    char    rsp_string[20] = {0};
    d988:	2214      	movs	r2, #20
    d98a:	2100      	movs	r1, #0
    d98c:	a805      	add	r0, sp, #20
    result = read_short_message_service_type(&service, &mt, &mo, &bm);
    d98e:	2613      	movs	r6, #19
    d990:	2512      	movs	r5, #18
    char    rsp_string[20] = {0};
    d992:	f7f2 fca5 	bl	2e0 <memset>
    result = read_short_message_service_type(&service, &mt, &mo, &bm);
    d996:	2111      	movs	r1, #17
    d998:	446e      	add	r6, sp
    d99a:	446d      	add	r5, sp
    d99c:	af04      	add	r7, sp, #16
    d99e:	0033      	movs	r3, r6
    d9a0:	002a      	movs	r2, r5
    d9a2:	4469      	add	r1, sp
    d9a4:	0038      	movs	r0, r7
    d9a6:	f00f f8d9 	bl	1cb5c <read_short_message_service_type>
    cause = at_parse_convert_neul_result(result);
    d9aa:	f7fc fc71 	bl	a290 <at_parse_convert_neul_result>
    d9ae:	1e04      	subs	r4, r0, #0
    if(cause == AT_RET_OK )
    d9b0:	d116      	bne.n	d9e0 <at_handle_CSMS_cmd_read+0x5c>
        len = (uint16)snprintf(rsp_string,7,"+CSMS:");
    d9b2:	4a0d      	ldr	r2, [pc, #52]	; (d9e8 <at_handle_CSMS_cmd_read+0x64>)
    d9b4:	2107      	movs	r1, #7
    d9b6:	a805      	add	r0, sp, #20
    d9b8:	f00c ff58 	bl	1a86c <snprintf>
        (void)snprintf(rsp_string+len, 8, "%d,%d,%d,%d", service, mt, mo, bm);
    d9bc:	aa05      	add	r2, sp, #20
    d9be:	b280      	uxth	r0, r0
    d9c0:	1810      	adds	r0, r2, r0
    d9c2:	7832      	ldrb	r2, [r6, #0]
    d9c4:	783b      	ldrb	r3, [r7, #0]
    d9c6:	9202      	str	r2, [sp, #8]
    d9c8:	782a      	ldrb	r2, [r5, #0]
    d9ca:	2108      	movs	r1, #8
    d9cc:	9201      	str	r2, [sp, #4]
    d9ce:	466a      	mov	r2, sp
    d9d0:	7c52      	ldrb	r2, [r2, #17]
    d9d2:	9200      	str	r2, [sp, #0]
    d9d4:	4a05      	ldr	r2, [pc, #20]	; (d9ec <at_handle_CSMS_cmd_read+0x68>)
    d9d6:	f00c ff49 	bl	1a86c <snprintf>
        app_at_send_at_rsp_string_lines_with_claim_and_log(rsp_string);
    d9da:	a805      	add	r0, sp, #20
    d9dc:	f7fb fe02 	bl	95e4 <app_at_send_at_rsp_string_lines_with_claim_and_log>
}
    d9e0:	0020      	movs	r0, r4
    d9e2:	b00b      	add	sp, #44	; 0x2c
    d9e4:	bdf0      	pop	{r4, r5, r6, r7, pc}
    d9e6:	46c0      	nop			; (mov r8, r8)
    d9e8:	00023978 	.word	0x00023978
    d9ec:	000239d9 	.word	0x000239d9

0000d9f0 <at_handle_CSMS_cmd_set>:
{
    d9f0:	b5f0      	push	{r4, r5, r6, r7, lr}
    d9f2:	b08b      	sub	sp, #44	; 0x2c
    d9f4:	0004      	movs	r4, r0
    char          rsp_string[AT_SMS_MAX_CSMS_RSP_LEN] = {0};
    d9f6:	2214      	movs	r2, #20
    d9f8:	2100      	movs	r1, #0
    d9fa:	a805      	add	r0, sp, #20
    d9fc:	f7f2 fc70 	bl	2e0 <memset>
    cause = at_create_param_array(p_atparams_string, &num_recvparams, 1, 1);
    da00:	2301      	movs	r3, #1
    da02:	210e      	movs	r1, #14
    da04:	0020      	movs	r0, r4
    da06:	001a      	movs	r2, r3
    da08:	4469      	add	r1, sp
    da0a:	f7fc fc6b 	bl	a2e4 <at_create_param_array>
    da0e:	1e04      	subs	r4, r0, #0
    if(cause != AT_RET_OK)
    da10:	d131      	bne.n	da76 <at_handle_CSMS_cmd_set+0x86>
    cause = at_get_uint16_param(AT_PARSE_FIRST_PARAM_POS, &service, true);
    da12:	2512      	movs	r5, #18
    da14:	446d      	add	r5, sp
    da16:	2201      	movs	r2, #1
    da18:	0029      	movs	r1, r5
    da1a:	f7fc fd77 	bl	a50c <at_get_uint16_param>
        return AT_RET_SYNTAX_ERROR;
    da1e:	3401      	adds	r4, #1
    if (cause != AT_RET_OK)
    da20:	2800      	cmp	r0, #0
    da22:	d128      	bne.n	da76 <at_handle_CSMS_cmd_set+0x86>
    if(service != AT_SMS_CSMS_SERVICE_NOT_SUPPORT && service != AT_SMS_CSMS_SERVICE_SUPPORT)
    da24:	8828      	ldrh	r0, [r5, #0]
    da26:	42a0      	cmp	r0, r4
    da28:	d825      	bhi.n	da76 <at_handle_CSMS_cmd_set+0x86>
    result = set_short_message_service_type(service, &mt, &mo, &bm);
    da2a:	2611      	movs	r6, #17
    da2c:	270f      	movs	r7, #15
    da2e:	446e      	add	r6, sp
    da30:	ad04      	add	r5, sp, #16
    da32:	446f      	add	r7, sp
    da34:	0033      	movs	r3, r6
    da36:	002a      	movs	r2, r5
    da38:	0039      	movs	r1, r7
    da3a:	f00f f87f 	bl	1cb3c <set_short_message_service_type>
    cause = at_parse_convert_neul_result(result);
    da3e:	f7fc fc27 	bl	a290 <at_parse_convert_neul_result>
    da42:	0004      	movs	r4, r0
    (void)set_sms_pdu_callback(sms_receive_message_callback);
    da44:	480d      	ldr	r0, [pc, #52]	; (da7c <at_handle_CSMS_cmd_set+0x8c>)
    da46:	f00f f923 	bl	1cc90 <set_sms_pdu_callback>
    if(cause == AT_RET_OK)
    da4a:	2c00      	cmp	r4, #0
    da4c:	d113      	bne.n	da76 <at_handle_CSMS_cmd_set+0x86>
        len = (uint16)snprintf(rsp_string,7,"+CSMS:");
    da4e:	4a0c      	ldr	r2, [pc, #48]	; (da80 <at_handle_CSMS_cmd_set+0x90>)
    da50:	2107      	movs	r1, #7
    da52:	a805      	add	r0, sp, #20
    da54:	f00c ff0a 	bl	1a86c <snprintf>
        (void)snprintf(rsp_string+len, 6, "%d,%d,%d", mt, mo, bm);
    da58:	aa05      	add	r2, sp, #20
    da5a:	b280      	uxth	r0, r0
    da5c:	1810      	adds	r0, r2, r0
    da5e:	7832      	ldrb	r2, [r6, #0]
    da60:	783b      	ldrb	r3, [r7, #0]
    da62:	9201      	str	r2, [sp, #4]
    da64:	782a      	ldrb	r2, [r5, #0]
    da66:	2106      	movs	r1, #6
    da68:	9200      	str	r2, [sp, #0]
    da6a:	4a06      	ldr	r2, [pc, #24]	; (da84 <at_handle_CSMS_cmd_set+0x94>)
    da6c:	f00c fefe 	bl	1a86c <snprintf>
        app_at_send_at_rsp_string_lines_with_claim_and_log(rsp_string);
    da70:	a805      	add	r0, sp, #20
    da72:	f7fb fdb7 	bl	95e4 <app_at_send_at_rsp_string_lines_with_claim_and_log>
}
    da76:	0020      	movs	r0, r4
    da78:	b00b      	add	sp, #44	; 0x2c
    da7a:	bdf0      	pop	{r4, r5, r6, r7, pc}
    da7c:	0000da89 	.word	0x0000da89
    da80:	00023978 	.word	0x00023978
    da84:	000239dc 	.word	0x000239dc

0000da88 <sms_receive_message_callback>:
{
    da88:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
    da8a:	0006      	movs	r6, r0
    rsp_string = at_alloc(AT_SMS_MAX_PDU_IND_LEN);
    da8c:	20f0      	movs	r0, #240	; 0xf0
    da8e:	0040      	lsls	r0, r0, #1
{
    da90:	000f      	movs	r7, r1
    da92:	0015      	movs	r5, r2
    rsp_string = at_alloc(AT_SMS_MAX_PDU_IND_LEN);
    da94:	f004 ffbe 	bl	12a14 <irzalloc>
    da98:	1e04      	subs	r4, r0, #0
    if(rsp_string == NULL)
    da9a:	d108      	bne.n	daae <sms_receive_message_callback+0x26>
        APP_AT_ERROR("AT malloc cmd failed");
    da9c:	4b1a      	ldr	r3, [pc, #104]	; (db08 <sms_receive_message_callback+0x80>)
    da9e:	2201      	movs	r2, #1
    daa0:	9300      	str	r3, [sp, #0]
    daa2:	2103      	movs	r1, #3
    daa4:	0003      	movs	r3, r0
    daa6:	2008      	movs	r0, #8
    daa8:	f7f8 fe6e 	bl	6788 <log_event_string>
}
    daac:	bdf7      	pop	{r0, r1, r2, r4, r5, r6, r7, pc}
        if(pdu_length > AT_SMS_MAX_TPDU_LEN)
    daae:	2fe8      	cmp	r7, #232	; 0xe8
    dab0:	d90c      	bls.n	dacc <sms_receive_message_callback+0x44>
            at_status_output(AT_RET_SMS_OPERATION_NOT_ALLOWED);
    dab2:	2021      	movs	r0, #33	; 0x21
    dab4:	f7fb fca2 	bl	93fc <at_status_output>
        delayed_async_print(rsp_string, AT_FLAG_LOGABLE | AT_FLAG_LOG_RESTRICTED, 0, 0);
    dab8:	2300      	movs	r3, #0
    daba:	0020      	movs	r0, r4
    dabc:	001a      	movs	r2, r3
    dabe:	2128      	movs	r1, #40	; 0x28
    dac0:	f7fd f8fc 	bl	acbc <delayed_async_print>
        at_free(rsp_string);
    dac4:	0020      	movs	r0, r4
    dac6:	f004 ffb7 	bl	12a38 <irfree>
    daca:	e7ef      	b.n	daac <sms_receive_message_callback+0x24>
            memset(rsp_string,0,AT_SMS_MAX_PDU_IND_LEN);
    dacc:	22f0      	movs	r2, #240	; 0xf0
    dace:	2100      	movs	r1, #0
    dad0:	0052      	lsls	r2, r2, #1
    dad2:	f7f2 fc05 	bl	2e0 <memset>
            rsp_len = (uint16)snprintf(rsp_string, AT_SMS_MAX_PDU_IND_LEN, "+CMT:%d,%d\r\n",alpha,pdu_length);
    dad6:	21f0      	movs	r1, #240	; 0xf0
    dad8:	9700      	str	r7, [sp, #0]
    dada:	0033      	movs	r3, r6
    dadc:	4a0b      	ldr	r2, [pc, #44]	; (db0c <sms_receive_message_callback+0x84>)
    dade:	0049      	lsls	r1, r1, #1
    dae0:	0020      	movs	r0, r4
    dae2:	f00c fec3 	bl	1a86c <snprintf>
    dae6:	19ef      	adds	r7, r5, r7
    dae8:	b286      	uxth	r6, r0
            for(index = 0;index < pdu_length;index++)
    daea:	42bd      	cmp	r5, r7
    daec:	d0e4      	beq.n	dab8 <sms_receive_message_callback+0x30>
                rsp_len += (uint16)snprintf(rsp_string + rsp_len, AT_SMS_MAX_PDU_IND_LEN - rsp_len, "%02x", pdu[index]);
    daee:	22f0      	movs	r2, #240	; 0xf0
    daf0:	0052      	lsls	r2, r2, #1
    daf2:	1b91      	subs	r1, r2, r6
    daf4:	782b      	ldrb	r3, [r5, #0]
    daf6:	19a0      	adds	r0, r4, r6
    daf8:	4a05      	ldr	r2, [pc, #20]	; (db10 <sms_receive_message_callback+0x88>)
    dafa:	f00c feb7 	bl	1a86c <snprintf>
    dafe:	1836      	adds	r6, r6, r0
    db00:	b2b6      	uxth	r6, r6
    db02:	3501      	adds	r5, #1
    db04:	e7f1      	b.n	daea <sms_receive_message_callback+0x62>
    db06:	46c0      	nop			; (mov r8, r8)
    db08:	00024955 	.word	0x00024955
    db0c:	0002496a 	.word	0x0002496a
    db10:	0002393f 	.word	0x0002393f

0000db14 <at_handle_CSCA_cmd_read>:
{
    db14:	b530      	push	{r4, r5, lr}
    db16:	b095      	sub	sp, #84	; 0x54
    uint8       ser_addr[AT_MAX_SMSC_PARAM_LEN] = {0};//AT_MAX_SMSC_PARAM_LEN include '\0',which one larger than the max length in protocol core.
    db18:	2215      	movs	r2, #21
    db1a:	2100      	movs	r1, #0
    db1c:	a804      	add	r0, sp, #16
    db1e:	f7f2 fbdf 	bl	2e0 <memset>
    result = read_short_message_service_address(&type,NEUL_SMS_MAX_SMC_ADDRESS_LENGTH,&length, ser_addr);
    db22:	250d      	movs	r5, #13
    char        rsp_string[AT_MAX_SMSC_RES_LEN] = {0};
    db24:	2228      	movs	r2, #40	; 0x28
    db26:	2100      	movs	r1, #0
    db28:	a80a      	add	r0, sp, #40	; 0x28
    db2a:	f7f2 fbd9 	bl	2e0 <memset>
    result = read_short_message_service_address(&type,NEUL_SMS_MAX_SMC_ADDRESS_LENGTH,&length, ser_addr);
    db2e:	220e      	movs	r2, #14
    db30:	446d      	add	r5, sp
    db32:	ab04      	add	r3, sp, #16
    db34:	446a      	add	r2, sp
    db36:	2114      	movs	r1, #20
    db38:	0028      	movs	r0, r5
    db3a:	f00f f892 	bl	1cc62 <read_short_message_service_address>
    cause = at_parse_convert_neul_result(result);
    db3e:	f7fc fba7 	bl	a290 <at_parse_convert_neul_result>
    db42:	1e04      	subs	r4, r0, #0
    if(cause == AT_RET_OK)
    db44:	d10a      	bne.n	db5c <at_handle_CSCA_cmd_read+0x48>
        (void)snprintf(rsp_string, AT_MAX_SMSC_RES_LEN, "+CSCA:\"%s\",%d",ser_addr,type);
    db46:	782b      	ldrb	r3, [r5, #0]
    db48:	4a06      	ldr	r2, [pc, #24]	; (db64 <at_handle_CSCA_cmd_read+0x50>)
    db4a:	9300      	str	r3, [sp, #0]
    db4c:	2128      	movs	r1, #40	; 0x28
    db4e:	ab04      	add	r3, sp, #16
    db50:	a80a      	add	r0, sp, #40	; 0x28
    db52:	f00c fe8b 	bl	1a86c <snprintf>
        app_at_send_at_rsp_string_lines_with_claim_and_log_restricted(rsp_string);
    db56:	a80a      	add	r0, sp, #40	; 0x28
    db58:	f7fb fd4b 	bl	95f2 <app_at_send_at_rsp_string_lines_with_claim_and_log_restricted>
}
    db5c:	0020      	movs	r0, r4
    db5e:	b015      	add	sp, #84	; 0x54
    db60:	bd30      	pop	{r4, r5, pc}
    db62:	46c0      	nop			; (mov r8, r8)
    db64:	00023944 	.word	0x00023944

0000db68 <at_handle_CSCA_cmd_set>:
{
    db68:	b5f0      	push	{r4, r5, r6, r7, lr}
    db6a:	b089      	sub	sp, #36	; 0x24
    uint8           type = 0;
    db6c:	466b      	mov	r3, sp
    db6e:	2100      	movs	r1, #0
    uint8           ser_addr[AT_MAX_SMSC_PARAM_LEN] = {0};
    db70:	ae02      	add	r6, sp, #8
    uint8           type = 0;
    db72:	1ddf      	adds	r7, r3, #7
{
    db74:	0004      	movs	r4, r0
    uint8           ser_addr[AT_MAX_SMSC_PARAM_LEN] = {0};
    db76:	2215      	movs	r2, #21
    db78:	0030      	movs	r0, r6
    uint8           type = 0;
    db7a:	7039      	strb	r1, [r7, #0]
    uint8           ser_addr[AT_MAX_SMSC_PARAM_LEN] = {0};
    db7c:	f7f2 fbb0 	bl	2e0 <memset>
    cause = at_create_param_array(p_atparams_string, &num_recvparams, 1, 2);
    db80:	4669      	mov	r1, sp
    db82:	2302      	movs	r3, #2
    db84:	2201      	movs	r2, #1
    db86:	3106      	adds	r1, #6
    db88:	0020      	movs	r0, r4
    db8a:	f7fc fbab 	bl	a2e4 <at_create_param_array>
    if(cause != AT_RET_OK)
    db8e:	2800      	cmp	r0, #0
    db90:	d107      	bne.n	dba2 <at_handle_CSCA_cmd_set+0x3a>
    cause = at_get_string_param(AT_PARSE_FIRST_PARAM_POS, ser_addr, AT_MAX_SMSC_PARAM_LEN, true);
    db92:	2301      	movs	r3, #1
    db94:	2215      	movs	r2, #21
    db96:	0031      	movs	r1, r6
    db98:	f7fc fdf6 	bl	a788 <at_get_string_param>
    db9c:	1e04      	subs	r4, r0, #0
    if (cause != AT_RET_OK)
    db9e:	d002      	beq.n	dba6 <at_handle_CSCA_cmd_set+0x3e>
        return AT_RET_SYNTAX_ERROR;
    dba0:	2001      	movs	r0, #1
}
    dba2:	b009      	add	sp, #36	; 0x24
    dba4:	bdf0      	pop	{r4, r5, r6, r7, pc}
    ser_addr_len = (uint8)strlen((char *)ser_addr);
    dba6:	0030      	movs	r0, r6
    dba8:	f00d fbf9 	bl	1b39e <strlen>
    dbac:	b2c5      	uxtb	r5, r0
    if((ser_addr_len < NEUL_SMS_MIN_SMC_ADDRESS_LENGTH) || (ser_addr_len > NEUL_SMS_MAX_SMC_ADDRESS_LENGTH))
    dbae:	1e6b      	subs	r3, r5, #1
    dbb0:	2b13      	cmp	r3, #19
    dbb2:	d8f5      	bhi.n	dba0 <at_handle_CSCA_cmd_set+0x38>
        if((ser_addr[i] < '0') || (ser_addr[i] > '9'))    //address must be numeric format
    dbb4:	5d33      	ldrb	r3, [r6, r4]
    dbb6:	3b30      	subs	r3, #48	; 0x30
    dbb8:	2b09      	cmp	r3, #9
    dbba:	d8f1      	bhi.n	dba0 <at_handle_CSCA_cmd_set+0x38>
    dbbc:	3401      	adds	r4, #1
    for(i = 0; i < ser_addr_len; i++)
    dbbe:	b2e3      	uxtb	r3, r4
    dbc0:	42ab      	cmp	r3, r5
    dbc2:	d3f7      	bcc.n	dbb4 <at_handle_CSCA_cmd_set+0x4c>
    if(num_recvparams == 2)
    dbc4:	466b      	mov	r3, sp
    dbc6:	799b      	ldrb	r3, [r3, #6]
    dbc8:	2b02      	cmp	r3, #2
    dbca:	d10e      	bne.n	dbea <at_handle_CSCA_cmd_set+0x82>
        cause = at_get_uint8_param(AT_PARSE_SECOND_PARAM_POS, &type, false);
    dbcc:	2200      	movs	r2, #0
    dbce:	0039      	movs	r1, r7
    dbd0:	2001      	movs	r0, #1
    dbd2:	f7fc fd1b 	bl	a60c <at_get_uint8_param>
        if (cause != AT_RET_OK)
    dbd6:	2800      	cmp	r0, #0
    dbd8:	d1e2      	bne.n	dba0 <at_handle_CSCA_cmd_set+0x38>
    result = set_short_message_service_address(type, ser_addr_len, ser_addr);
    dbda:	0032      	movs	r2, r6
    dbdc:	0029      	movs	r1, r5
    dbde:	7838      	ldrb	r0, [r7, #0]
    dbe0:	f00e ffe6 	bl	1cbb0 <set_short_message_service_address>
    return at_parse_convert_neul_result(result);
    dbe4:	f7fc fb54 	bl	a290 <at_parse_convert_neul_result>
    dbe8:	e7db      	b.n	dba2 <at_handle_CSCA_cmd_set+0x3a>
        type = AT_SMS_UNKNOWN_SERVICE_TYPE;
    dbea:	2381      	movs	r3, #129	; 0x81
    dbec:	703b      	strb	r3, [r7, #0]
    dbee:	e7f4      	b.n	dbda <at_handle_CSCA_cmd_set+0x72>

0000dbf0 <at_handle_CLAC_cmd_exec>:
{
    dbf0:	b5f0      	push	{r4, r5, r6, r7, lr}
    dbf2:	b087      	sub	sp, #28
    char         rsp_string[CLAC_RSP_MAX_LEN] = {0};
    dbf4:	2214      	movs	r2, #20
    dbf6:	2100      	movs	r1, #0
    dbf8:	a801      	add	r0, sp, #4
    dbfa:	f7f2 fb71 	bl	2e0 <memset>
    struct AT_CMD_CB_node *current_at_cmd_registered_node = at_get_registered_cmd_table_address();
    dbfe:	f003 ff8d 	bl	11b1c <at_get_registered_cmd_table_address>
    for (i = 0; i < list_len; i++)
    dc02:	2684      	movs	r6, #132	; 0x84
    struct AT_CMD_CB_node *current_at_cmd_registered_node = at_get_registered_cmd_table_address();
    dc04:	0004      	movs	r4, r0
    at_uart_claim();
    dc06:	2500      	movs	r5, #0
    dc08:	f7fb fece 	bl	99a8 <at_uart_claim>
        if (AT_IS_VISIABLE(cmd_cb->flag))
    dc0c:	2702      	movs	r7, #2
    for (i = 0; i < list_len; i++)
    dc0e:	0136      	lsls	r6, r6, #4
        if (AT_IS_VISIABLE(cmd_cb->flag))
    dc10:	4b15      	ldr	r3, [pc, #84]	; (dc68 <at_handle_CLAC_cmd_exec+0x78>)
    dc12:	18eb      	adds	r3, r5, r3
    dc14:	881a      	ldrh	r2, [r3, #0]
    dc16:	423a      	tst	r2, r7
    dc18:	d00a      	beq.n	dc30 <at_handle_CLAC_cmd_exec+0x40>
            (void)snprintf(rsp_string, CLAC_RSP_MAX_LEN, "AT%s", p_at_cmd_table[i].cmd_str);
    dc1a:	4a14      	ldr	r2, [pc, #80]	; (dc6c <at_handle_CLAC_cmd_exec+0x7c>)
    dc1c:	2114      	movs	r1, #20
    dc1e:	685b      	ldr	r3, [r3, #4]
    dc20:	a801      	add	r0, sp, #4
    dc22:	f00c fe23 	bl	1a86c <snprintf>
            app_at_send_at_rsp_string_lines(rsp_string, false, AT_FLAG_LOGABLE);
    dc26:	2208      	movs	r2, #8
    dc28:	2100      	movs	r1, #0
    dc2a:	a801      	add	r0, sp, #4
    dc2c:	f7fb fcd3 	bl	95d6 <app_at_send_at_rsp_string_lines>
    dc30:	3518      	adds	r5, #24
    for (i = 0; i < list_len; i++)
    dc32:	42b5      	cmp	r5, r6
    dc34:	d1ec      	bne.n	dc10 <at_handle_CLAC_cmd_exec+0x20>
        if (AT_IS_VISIABLE(cmd_cb->flag))
    dc36:	2502      	movs	r5, #2
    while(current_at_cmd_registered_node != NULL)
    dc38:	2c00      	cmp	r4, #0
    dc3a:	d104      	bne.n	dc46 <at_handle_CLAC_cmd_exec+0x56>
    at_uart_release();
    dc3c:	f7fb fec6 	bl	99cc <at_uart_release>
}
    dc40:	0020      	movs	r0, r4
    dc42:	b007      	add	sp, #28
    dc44:	bdf0      	pop	{r4, r5, r6, r7, pc}
        if (AT_IS_VISIABLE(cmd_cb->flag))
    dc46:	8823      	ldrh	r3, [r4, #0]
    dc48:	422b      	tst	r3, r5
    dc4a:	d00a      	beq.n	dc62 <at_handle_CLAC_cmd_exec+0x72>
            (void)snprintf(rsp_string, CLAC_RSP_MAX_LEN, "AT%s", cmd_cb->cmd_str);
    dc4c:	4a07      	ldr	r2, [pc, #28]	; (dc6c <at_handle_CLAC_cmd_exec+0x7c>)
    dc4e:	2114      	movs	r1, #20
    dc50:	6863      	ldr	r3, [r4, #4]
    dc52:	a801      	add	r0, sp, #4
    dc54:	f00c fe0a 	bl	1a86c <snprintf>
            app_at_send_at_rsp_string_lines(rsp_string, false, AT_FLAG_LOGABLE);
    dc58:	2208      	movs	r2, #8
    dc5a:	2100      	movs	r1, #0
    dc5c:	a801      	add	r0, sp, #4
    dc5e:	f7fb fcba 	bl	95d6 <app_at_send_at_rsp_string_lines>
        current_at_cmd_registered_node = current_at_cmd_registered_node->next;
    dc62:	69a4      	ldr	r4, [r4, #24]
    dc64:	e7e8      	b.n	dc38 <at_handle_CLAC_cmd_exec+0x48>
    dc66:	46c0      	nop			; (mov r8, r8)
    dc68:	00023fa4 	.word	0x00023fa4
    dc6c:	00023882 	.word	0x00023882

0000dc70 <at_handle_CGMR_cmd_exec>:
{
    dc70:	b570      	push	{r4, r5, r6, lr}
    uint16  rev_len = 0;
    dc72:	2600      	movs	r6, #0
    dc74:	250e      	movs	r5, #14
{
    dc76:	b0a6      	sub	sp, #152	; 0x98
    char    ue_version[MAX_VERSION_STRING] = {0};
    dc78:	ac09      	add	r4, sp, #36	; 0x24
    dc7a:	0031      	movs	r1, r6
    uint16  rev_len = 0;
    dc7c:	446d      	add	r5, sp
    char    ue_version[MAX_VERSION_STRING] = {0};
    dc7e:	2230      	movs	r2, #48	; 0x30
    dc80:	0020      	movs	r0, r4
    uint16  rev_len = 0;
    dc82:	802e      	strh	r6, [r5, #0]
    char    ue_version[MAX_VERSION_STRING] = {0};
    dc84:	f7f2 fb2c 	bl	2e0 <memset>
    char    rsp_string[AT_MAX_CGMR_RSP_LEN] = {0};
    dc88:	0031      	movs	r1, r6
    dc8a:	2242      	movs	r2, #66	; 0x42
    dc8c:	a815      	add	r0, sp, #84	; 0x54
    dc8e:	f7f2 fb27 	bl	2e0 <memset>
    const char *versions_print_tables[] =
    dc92:	a904      	add	r1, sp, #16
    dc94:	000a      	movs	r2, r1
    dc96:	4b20      	ldr	r3, [pc, #128]	; (dd18 <at_handle_CGMR_cmd_exec+0xa8>)
    dc98:	3374      	adds	r3, #116	; 0x74
    dc9a:	cb43      	ldmia	r3!, {r0, r1, r6}
    dc9c:	c243      	stmia	r2!, {r0, r1, r6}
    dc9e:	cb03      	ldmia	r3!, {r0, r1}
    dca0:	c203      	stmia	r2!, {r0, r1}
    if (get_ssb_version(&rev_len, ue_version, sizeof(ue_version)) == NEUL_RET_OK)
    dca2:	2230      	movs	r2, #48	; 0x30
    dca4:	0021      	movs	r1, r4
    dca6:	0028      	movs	r0, r5
    dca8:	f00d fe6d 	bl	1b986 <get_ssb_version>
    dcac:	2800      	cmp	r0, #0
    dcae:	d108      	bne.n	dcc2 <at_handle_CGMR_cmd_exec+0x52>
        (void)snprintf(rsp_string, AT_MAX_CGMR_RSP_LEN, "SSB,%s", ue_version);
    dcb0:	0023      	movs	r3, r4
    dcb2:	4a1a      	ldr	r2, [pc, #104]	; (dd1c <at_handle_CGMR_cmd_exec+0xac>)
    dcb4:	2142      	movs	r1, #66	; 0x42
    dcb6:	a815      	add	r0, sp, #84	; 0x54
    dcb8:	f00c fdd8 	bl	1a86c <snprintf>
        app_at_send_at_rsp_string_lines_with_claim_and_log(rsp_string);
    dcbc:	a815      	add	r0, sp, #84	; 0x54
    dcbe:	f7fb fc91 	bl	95e4 <app_at_send_at_rsp_string_lines_with_claim_and_log>
{
    dcc2:	2600      	movs	r6, #0
        if (get_firmware_version((CORE_IMAGES)cimage, &rev_len, ue_version, MAX_VERSION_STRING) == NEUL_RET_OK)
    dcc4:	b2f0      	uxtb	r0, r6
    dcc6:	2330      	movs	r3, #48	; 0x30
    dcc8:	0022      	movs	r2, r4
    dcca:	0029      	movs	r1, r5
    dccc:	f00d fe72 	bl	1b9b4 <get_firmware_version>
    dcd0:	2800      	cmp	r0, #0
    dcd2:	d10b      	bne.n	dcec <at_handle_CGMR_cmd_exec+0x7c>
            (void)snprintf(rsp_string, AT_MAX_CGMR_RSP_LEN, "%s,%s",versions_print_tables[cimage], ue_version);
    dcd4:	9400      	str	r4, [sp, #0]
    dcd6:	aa04      	add	r2, sp, #16
    dcd8:	00b3      	lsls	r3, r6, #2
    dcda:	589b      	ldr	r3, [r3, r2]
    dcdc:	2142      	movs	r1, #66	; 0x42
    dcde:	4a10      	ldr	r2, [pc, #64]	; (dd20 <at_handle_CGMR_cmd_exec+0xb0>)
    dce0:	a815      	add	r0, sp, #84	; 0x54
    dce2:	f00c fdc3 	bl	1a86c <snprintf>
            app_at_send_at_rsp_string_lines_with_claim_and_log(rsp_string);
    dce6:	a815      	add	r0, sp, #84	; 0x54
    dce8:	f7fb fc7c 	bl	95e4 <app_at_send_at_rsp_string_lines_with_claim_and_log>
    for (int cimage = 0; cimage < CORE_IMAGES_MAX_NUMBER; cimage++)
    dcec:	3601      	adds	r6, #1
    dcee:	2e05      	cmp	r6, #5
    dcf0:	d1e8      	bne.n	dcc4 <at_handle_CGMR_cmd_exec+0x54>
    if (get_rfconfig_version(ue_version) == NEUL_RET_OK)
    dcf2:	0020      	movs	r0, r4
    dcf4:	f00d fe76 	bl	1b9e4 <get_rfconfig_version>
    dcf8:	2800      	cmp	r0, #0
    dcfa:	d109      	bne.n	dd10 <at_handle_CGMR_cmd_exec+0xa0>
        (void)snprintf(rsp_string, AT_MAX_CGMR_RSP_LEN, "%s,%s", AT_RADIO_NAME, ue_version);
    dcfc:	9400      	str	r4, [sp, #0]
    dcfe:	4b09      	ldr	r3, [pc, #36]	; (dd24 <at_handle_CGMR_cmd_exec+0xb4>)
    dd00:	4a07      	ldr	r2, [pc, #28]	; (dd20 <at_handle_CGMR_cmd_exec+0xb0>)
    dd02:	2142      	movs	r1, #66	; 0x42
    dd04:	a815      	add	r0, sp, #84	; 0x54
    dd06:	f00c fdb1 	bl	1a86c <snprintf>
        app_at_send_at_rsp_string_lines_with_claim_and_log(rsp_string);
    dd0a:	a815      	add	r0, sp, #84	; 0x54
    dd0c:	f7fb fc6a 	bl	95e4 <app_at_send_at_rsp_string_lines_with_claim_and_log>
}
    dd10:	2000      	movs	r0, #0
    dd12:	b026      	add	sp, #152	; 0x98
    dd14:	bd70      	pop	{r4, r5, r6, pc}
    dd16:	46c0      	nop			; (mov r8, r8)
    dd18:	000229f8 	.word	0x000229f8
    dd1c:	000237af 	.word	0x000237af
    dd20:	00023c28 	.word	0x00023c28
    dd24:	00024916 	.word	0x00024916

0000dd28 <at_handle_CGMM_cmd_exec>:
{
    dd28:	b570      	push	{r4, r5, r6, lr}
    dd2a:	b08c      	sub	sp, #48	; 0x30
    char    model_string[MANUFACTURER_IDENTITY_MAX_LEN + 1] = {0};
    dd2c:	ae01      	add	r6, sp, #4
    dd2e:	2229      	movs	r2, #41	; 0x29
    dd30:	2100      	movs	r1, #0
    dd32:	0030      	movs	r0, r6
    dd34:	f7f2 fad4 	bl	2e0 <memset>
    uint16  model_len = 0;
    dd38:	466b      	mov	r3, sp
    dd3a:	1c9d      	adds	r5, r3, #2
    dd3c:	2300      	movs	r3, #0
    if (get_man_model(model_string,MANUFACTURER_IDENTITY_MAX_LEN, &model_len) != NEUL_RET_OK)
    dd3e:	002a      	movs	r2, r5
    dd40:	2128      	movs	r1, #40	; 0x28
    dd42:	0030      	movs	r0, r6
    uint16  model_len = 0;
    dd44:	802b      	strh	r3, [r5, #0]
    if (get_man_model(model_string,MANUFACTURER_IDENTITY_MAX_LEN, &model_len) != NEUL_RET_OK)
    dd46:	f00d fdd7 	bl	1b8f8 <get_man_model>
        return AT_RET_SYNTAX_ERROR;
    dd4a:	2401      	movs	r4, #1
    if (get_man_model(model_string,MANUFACTURER_IDENTITY_MAX_LEN, &model_len) != NEUL_RET_OK)
    dd4c:	2800      	cmp	r0, #0
    dd4e:	d10a      	bne.n	dd66 <at_handle_CGMM_cmd_exec+0x3e>
    if( model_len > MANUFACTURER_IDENTITY_MAX_LEN )
    dd50:	882b      	ldrh	r3, [r5, #0]
    dd52:	2b28      	cmp	r3, #40	; 0x28
    dd54:	d901      	bls.n	dd5a <at_handle_CGMM_cmd_exec+0x32>
        model_len = MANUFACTURER_IDENTITY_MAX_LEN;
    dd56:	2328      	movs	r3, #40	; 0x28
    dd58:	802b      	strh	r3, [r5, #0]
    model_string[model_len] = '\0';
    dd5a:	2400      	movs	r4, #0
    dd5c:	882b      	ldrh	r3, [r5, #0]
    app_at_send_at_rsp_string_lines_with_claim_and_log(model_string);
    dd5e:	0030      	movs	r0, r6
    model_string[model_len] = '\0';
    dd60:	54f4      	strb	r4, [r6, r3]
    app_at_send_at_rsp_string_lines_with_claim_and_log(model_string);
    dd62:	f7fb fc3f 	bl	95e4 <app_at_send_at_rsp_string_lines_with_claim_and_log>
}
    dd66:	0020      	movs	r0, r4
    dd68:	b00c      	add	sp, #48	; 0x30
    dd6a:	bd70      	pop	{r4, r5, r6, pc}

0000dd6c <at_handle_NATSPEED_cmd_set>:
{
    dd6c:	b5f0      	push	{r4, r5, r6, r7, lr}
    dd6e:	b085      	sub	sp, #20
    uint8               store      = 0;
    dd70:	466a      	mov	r2, sp
    dd72:	2300      	movs	r3, #0
    dd74:	7153      	strb	r3, [r2, #5]
    bool                high_speed = false;
    dd76:	7193      	strb	r3, [r2, #6]
    uint8               timeout    = AT_UART_DEFAULT_TIMEOUT;
    dd78:	2303      	movs	r3, #3
    at_uart_config      uart_config = {AT_UART_DEFAULT_BAUD_RATE, AT_UART_DEFAULT_SYNC_MODE, AT_UART_DEFAULT_STOPBITS, AT_UART_DEFAULT_PARITY, AT_UART_DEFAULT_SW_FLOW_CONTROL};
    dd7a:	ad02      	add	r5, sp, #8
    uint8               timeout    = AT_UART_DEFAULT_TIMEOUT;
    dd7c:	1dd6      	adds	r6, r2, #7
    bool                high_speed = false;
    dd7e:	1d97      	adds	r7, r2, #6
    at_uart_config      uart_config = {AT_UART_DEFAULT_BAUD_RATE, AT_UART_DEFAULT_SYNC_MODE, AT_UART_DEFAULT_STOPBITS, AT_UART_DEFAULT_PARITY, AT_UART_DEFAULT_SW_FLOW_CONTROL};
    dd80:	002a      	movs	r2, r5
    uint8               timeout    = AT_UART_DEFAULT_TIMEOUT;
    dd82:	7033      	strb	r3, [r6, #0]
    at_uart_config      uart_config = {AT_UART_DEFAULT_BAUD_RATE, AT_UART_DEFAULT_SYNC_MODE, AT_UART_DEFAULT_STOPBITS, AT_UART_DEFAULT_PARITY, AT_UART_DEFAULT_SW_FLOW_CONTROL};
    dd84:	4b52      	ldr	r3, [pc, #328]	; (ded0 <at_handle_NATSPEED_cmd_set+0x164>)
    dd86:	3308      	adds	r3, #8
    dd88:	cb12      	ldmia	r3!, {r1, r4}
    dd8a:	c212      	stmia	r2!, {r1, r4}
    cause = at_create_param_array(p_atparams_string, &num_recvparams, 1, 7);
    dd8c:	2307      	movs	r3, #7
    dd8e:	2201      	movs	r2, #1
    dd90:	a901      	add	r1, sp, #4
    dd92:	f7fc faa7 	bl	a2e4 <at_create_param_array>
    dd96:	1e04      	subs	r4, r0, #0
    if(cause != AT_RET_OK)
    dd98:	d10c      	bne.n	ddb4 <at_handle_NATSPEED_cmd_set+0x48>
    cause = at_get_uint32_param(AT_PARSE_FIRST_PARAM_POS, &uart_config.baudrate, true);
    dd9a:	2201      	movs	r2, #1
    dd9c:	0029      	movs	r1, r5
    dd9e:	f7fc fb3d 	bl	a41c <at_get_uint32_param>
    dda2:	1e04      	subs	r4, r0, #0
    if (cause != AT_RET_OK)
    dda4:	d106      	bne.n	ddb4 <at_handle_NATSPEED_cmd_set+0x48>
    if (!at_uart_baud_rate_valid_check(uart_config.baudrate, &high_speed))
    dda6:	0039      	movs	r1, r7
    dda8:	6828      	ldr	r0, [r5, #0]
    ddaa:	f7fc f97b 	bl	a0a4 <at_uart_baud_rate_valid_check>
    ddae:	2800      	cmp	r0, #0
    ddb0:	d103      	bne.n	ddba <at_handle_NATSPEED_cmd_set+0x4e>
        return AT_RET_SYNTAX_ERROR;
    ddb2:	2401      	movs	r4, #1
}
    ddb4:	0020      	movs	r0, r4
    ddb6:	b005      	add	sp, #20
    ddb8:	bdf0      	pop	{r4, r5, r6, r7, pc}
    if (num_recvparams > 1)
    ddba:	466b      	mov	r3, sp
    ddbc:	791b      	ldrb	r3, [r3, #4]
    ddbe:	2b01      	cmp	r3, #1
    ddc0:	d90d      	bls.n	ddde <at_handle_NATSPEED_cmd_set+0x72>
        cause = at_get_uint8_param(AT_PARSE_SECOND_PARAM_POS, &timeout, true);
    ddc2:	2201      	movs	r2, #1
    ddc4:	0031      	movs	r1, r6
    ddc6:	0010      	movs	r0, r2
    ddc8:	f7fc fc20 	bl	a60c <at_get_uint8_param>
        if (cause != AT_RET_OK)
    ddcc:	2800      	cmp	r0, #0
    ddce:	d17c      	bne.n	deca <at_handle_NATSPEED_cmd_set+0x15e>
        if (timeout > AT_UART_MAX_TIMEOUT)
    ddd0:	7833      	ldrb	r3, [r6, #0]
    ddd2:	2b1e      	cmp	r3, #30
    ddd4:	d8ed      	bhi.n	ddb2 <at_handle_NATSPEED_cmd_set+0x46>
        if (timeout == 0)
    ddd6:	2b00      	cmp	r3, #0
    ddd8:	d101      	bne.n	ddde <at_handle_NATSPEED_cmd_set+0x72>
            timeout = AT_UART_DEFAULT_TIMEOUT;
    ddda:	3303      	adds	r3, #3
    dddc:	7033      	strb	r3, [r6, #0]
    if (num_recvparams > 2)
    ddde:	af01      	add	r7, sp, #4
    dde0:	783b      	ldrb	r3, [r7, #0]
    dde2:	2b02      	cmp	r3, #2
    dde4:	d817      	bhi.n	de16 <at_handle_NATSPEED_cmd_set+0xaa>
    if (num_recvparams > 3)
    dde6:	783b      	ldrb	r3, [r7, #0]
    dde8:	2b03      	cmp	r3, #3
    ddea:	d909      	bls.n	de00 <at_handle_NATSPEED_cmd_set+0x94>
        cause = at_get_uint8_param(AT_PARSE_FOURTH_PARAM_POS, &uart_config.syncmode, true);
    ddec:	2201      	movs	r2, #1
    ddee:	a903      	add	r1, sp, #12
    ddf0:	2003      	movs	r0, #3
    ddf2:	f7fc fc0b 	bl	a60c <at_get_uint8_param>
        if (cause != AT_RET_OK)
    ddf6:	2800      	cmp	r0, #0
    ddf8:	d167      	bne.n	deca <at_handle_NATSPEED_cmd_set+0x15e>
        if (uart_config.syncmode > AT_UART_MAX_SYNC_MODE)
    ddfa:	792b      	ldrb	r3, [r5, #4]
    ddfc:	2b03      	cmp	r3, #3
    ddfe:	d8d8      	bhi.n	ddb2 <at_handle_NATSPEED_cmd_set+0x46>
    if ((uart_config.baudrate == AT_UART_BAUD_RATE_2400) && (uart_config.syncmode == AT_UART_MAX_SYNC_MODE))
    de00:	2296      	movs	r2, #150	; 0x96
    de02:	9b02      	ldr	r3, [sp, #8]
    de04:	0112      	lsls	r2, r2, #4
    de06:	4293      	cmp	r3, r2
    de08:	d112      	bne.n	de30 <at_handle_NATSPEED_cmd_set+0xc4>
    de0a:	ab02      	add	r3, sp, #8
    de0c:	791b      	ldrb	r3, [r3, #4]
    de0e:	2b03      	cmp	r3, #3
    de10:	d116      	bne.n	de40 <at_handle_NATSPEED_cmd_set+0xd4>
        return AT_RET_PROGRESS_ERROR;
    de12:	2406      	movs	r4, #6
    de14:	e7ce      	b.n	ddb4 <at_handle_NATSPEED_cmd_set+0x48>
        cause = at_get_uint8_param(AT_PARSE_THIRD_PARAM_POS, &store, true);
    de16:	466b      	mov	r3, sp
    de18:	2201      	movs	r2, #1
    de1a:	1d59      	adds	r1, r3, #5
    de1c:	2002      	movs	r0, #2
    de1e:	f7fc fbf5 	bl	a60c <at_get_uint8_param>
        if (cause != AT_RET_OK)
    de22:	2800      	cmp	r0, #0
    de24:	d151      	bne.n	deca <at_handle_NATSPEED_cmd_set+0x15e>
        if (store > AT_UART_STORE_ENABLE)
    de26:	466b      	mov	r3, sp
    de28:	795b      	ldrb	r3, [r3, #5]
    de2a:	2b01      	cmp	r3, #1
    de2c:	d8c1      	bhi.n	ddb2 <at_handle_NATSPEED_cmd_set+0x46>
    de2e:	e7da      	b.n	dde6 <at_handle_NATSPEED_cmd_set+0x7a>
    if ((uart_config.baudrate == AT_UART_BAUD_RATE_4800) && (uart_config.syncmode == AT_UART_MAX_SYNC_MODE))
    de30:	2296      	movs	r2, #150	; 0x96
    de32:	0152      	lsls	r2, r2, #5
    de34:	4293      	cmp	r3, r2
    de36:	d0e8      	beq.n	de0a <at_handle_NATSPEED_cmd_set+0x9e>
    if ((uart_config.baudrate == AT_UART_BAUD_RATE_57600) && (uart_config.syncmode == AT_UART_MAX_SYNC_MODE))
    de38:	22e1      	movs	r2, #225	; 0xe1
    de3a:	0212      	lsls	r2, r2, #8
    de3c:	4293      	cmp	r3, r2
    de3e:	d0e4      	beq.n	de0a <at_handle_NATSPEED_cmd_set+0x9e>
    if (num_recvparams > 4)
    de40:	783b      	ldrb	r3, [r7, #0]
    de42:	2b04      	cmp	r3, #4
    de44:	d826      	bhi.n	de94 <at_handle_NATSPEED_cmd_set+0x128>
    if (num_recvparams > 5)
    de46:	783b      	ldrb	r3, [r7, #0]
    de48:	2b05      	cmp	r3, #5
    de4a:	d90a      	bls.n	de62 <at_handle_NATSPEED_cmd_set+0xf6>
        cause = at_get_uint8_param(AT_PARSE_SIXTH_PARAM_POS, &uart_config.parity, true);
    de4c:	210e      	movs	r1, #14
    de4e:	2201      	movs	r2, #1
    de50:	4469      	add	r1, sp
    de52:	2005      	movs	r0, #5
    de54:	f7fc fbda 	bl	a60c <at_get_uint8_param>
        if (cause != AT_RET_OK)
    de58:	2800      	cmp	r0, #0
    de5a:	d136      	bne.n	deca <at_handle_NATSPEED_cmd_set+0x15e>
        if (uart_config.parity > UART_PARITY_EVEN)
    de5c:	79ab      	ldrb	r3, [r5, #6]
    de5e:	2b02      	cmp	r3, #2
    de60:	d8a7      	bhi.n	ddb2 <at_handle_NATSPEED_cmd_set+0x46>
    if (num_recvparams > 6)
    de62:	783b      	ldrb	r3, [r7, #0]
    de64:	2b06      	cmp	r3, #6
    de66:	d823      	bhi.n	deb0 <at_handle_NATSPEED_cmd_set+0x144>
    if (!at_uart_mark_need_change_config(uart_config, (bool)store, timeout))
    de68:	466a      	mov	r2, sp
    de6a:	7952      	ldrb	r2, [r2, #5]
    de6c:	7833      	ldrb	r3, [r6, #0]
    de6e:	1e51      	subs	r1, r2, #1
    de70:	418a      	sbcs	r2, r1
    de72:	9802      	ldr	r0, [sp, #8]
    de74:	b2d2      	uxtb	r2, r2
    de76:	6869      	ldr	r1, [r5, #4]
    de78:	f7fb ff18 	bl	9cac <at_uart_mark_need_change_config>
    de7c:	2800      	cmp	r0, #0
    de7e:	d0c8      	beq.n	de12 <at_handle_NATSPEED_cmd_set+0xa6>
    if (high_speed)
    de80:	466b      	mov	r3, sp
    de82:	3306      	adds	r3, #6
    de84:	781b      	ldrb	r3, [r3, #0]
    de86:	2b00      	cmp	r3, #0
    de88:	d100      	bne.n	de8c <at_handle_NATSPEED_cmd_set+0x120>
    de8a:	e793      	b.n	ddb4 <at_handle_NATSPEED_cmd_set+0x48>
        app_at_send_at_rsp_string_lines_with_claim_and_log("+NATSPEED:DISABLE_DEEP_SLEEP");
    de8c:	4811      	ldr	r0, [pc, #68]	; (ded4 <at_handle_NATSPEED_cmd_set+0x168>)
    de8e:	f7fb fba9 	bl	95e4 <app_at_send_at_rsp_string_lines_with_claim_and_log>
    de92:	e78f      	b.n	ddb4 <at_handle_NATSPEED_cmd_set+0x48>
        cause = at_get_uint8_param(AT_PARSE_FIFTH_PARAM_POS, &uart_config.stopbits, true);
    de94:	210d      	movs	r1, #13
    de96:	2201      	movs	r2, #1
    de98:	4469      	add	r1, sp
    de9a:	2004      	movs	r0, #4
    de9c:	f7fc fbb6 	bl	a60c <at_get_uint8_param>
        if (cause != AT_RET_OK)
    dea0:	2800      	cmp	r0, #0
    dea2:	d112      	bne.n	deca <at_handle_NATSPEED_cmd_set+0x15e>
        if ((uart_config.stopbits != AT_UART_STOPBITS_1) && (uart_config.stopbits != AT_UART_STOPBITS_2))
    dea4:	796b      	ldrb	r3, [r5, #5]
    dea6:	3b01      	subs	r3, #1
    dea8:	2b01      	cmp	r3, #1
    deaa:	d900      	bls.n	deae <at_handle_NATSPEED_cmd_set+0x142>
    deac:	e781      	b.n	ddb2 <at_handle_NATSPEED_cmd_set+0x46>
    deae:	e7ca      	b.n	de46 <at_handle_NATSPEED_cmd_set+0xda>
        cause = at_get_uint8_param(AT_PARSE_SEVENTH_PARAM_POS, &uart_config.sw_flow_control, true);
    deb0:	210f      	movs	r1, #15
    deb2:	2201      	movs	r2, #1
    deb4:	4469      	add	r1, sp
    deb6:	2006      	movs	r0, #6
    deb8:	f7fc fba8 	bl	a60c <at_get_uint8_param>
        if (cause != AT_RET_OK)
    debc:	2800      	cmp	r0, #0
    debe:	d104      	bne.n	deca <at_handle_NATSPEED_cmd_set+0x15e>
        if( uart_config.sw_flow_control > AT_UART_FLOW_CONTROL_ENABLED )
    dec0:	79eb      	ldrb	r3, [r5, #7]
    dec2:	2b01      	cmp	r3, #1
    dec4:	d900      	bls.n	dec8 <at_handle_NATSPEED_cmd_set+0x15c>
    dec6:	e774      	b.n	ddb2 <at_handle_NATSPEED_cmd_set+0x46>
    dec8:	e7ce      	b.n	de68 <at_handle_NATSPEED_cmd_set+0xfc>
    deca:	0004      	movs	r4, r0
    decc:	e772      	b.n	ddb4 <at_handle_NATSPEED_cmd_set+0x48>
    dece:	46c0      	nop			; (mov r8, r8)
    ded0:	00022a78 	.word	0x00022a78
    ded4:	000239e5 	.word	0x000239e5

0000ded8 <at_handle_NTSETID_cmd_set>:
{
    ded8:	b5f0      	push	{r4, r5, r6, r7, lr}
    deda:	b091      	sub	sp, #68	; 0x44
    char              str_data[UUID_MAX_LEN + 1] = {0};
    dedc:	ac06      	add	r4, sp, #24
{
    dede:	0005      	movs	r5, r0
    char              str_data[UUID_MAX_LEN + 1] = {0};
    dee0:	2225      	movs	r2, #37	; 0x25
    dee2:	2100      	movs	r1, #0
    dee4:	0020      	movs	r0, r4
    dee6:	f7f2 f9fb 	bl	2e0 <memset>
    cause = at_create_param_array(p_atparams_string, &num_recvparams, 2, 2);
    deea:	2302      	movs	r3, #2
    deec:	4669      	mov	r1, sp
    deee:	0028      	movs	r0, r5
    def0:	001a      	movs	r2, r3
    def2:	3105      	adds	r1, #5
    def4:	f7fc f9f6 	bl	a2e4 <at_create_param_array>
    def8:	1e05      	subs	r5, r0, #0
    if(cause != AT_RET_OK)
    defa:	d149      	bne.n	df90 <at_handle_NTSETID_cmd_set+0xb8>
    cause = at_get_uint16_param(AT_PARSE_FIRST_PARAM_POS, &snt, true);
    defc:	466b      	mov	r3, sp
    defe:	1d9e      	adds	r6, r3, #6
    df00:	2201      	movs	r2, #1
    df02:	0031      	movs	r1, r6
    df04:	f7fc fb02 	bl	a50c <at_get_uint16_param>
    df08:	1e05      	subs	r5, r0, #0
    if(cause != AT_RET_OK)
    df0a:	d141      	bne.n	df90 <at_handle_NTSETID_cmd_set+0xb8>
    cause = at_get_string_param(AT_PARSE_SECOND_PARAM_POS, (uint8 *)str_data, UUID_MAX_LEN + 1, true);
    df0c:	2301      	movs	r3, #1
    df0e:	2225      	movs	r2, #37	; 0x25
    df10:	0021      	movs	r1, r4
    df12:	0018      	movs	r0, r3
    df14:	f7fc fc38 	bl	a788 <at_get_string_param>
    df18:	1e05      	subs	r5, r0, #0
    if (cause != AT_RET_OK)
    df1a:	d139      	bne.n	df90 <at_handle_NTSETID_cmd_set+0xb8>
    switch((NTSETID_SNT)snt)
    df1c:	7833      	ldrb	r3, [r6, #0]
    df1e:	2b01      	cmp	r3, #1
    df20:	d057      	beq.n	dfd2 <at_handle_NTSETID_cmd_set+0xfa>
    df22:	2b00      	cmp	r3, #0
    df24:	d003      	beq.n	df2e <at_handle_NTSETID_cmd_set+0x56>
    df26:	2b02      	cmp	r3, #2
    df28:	d063      	beq.n	dff2 <at_handle_NTSETID_cmd_set+0x11a>
                return AT_RET_SYNTAX_ERROR;
    df2a:	2501      	movs	r5, #1
    df2c:	e030      	b.n	df90 <at_handle_NTSETID_cmd_set+0xb8>
    length = strlen(data);
    df2e:	0020      	movs	r0, r4
    df30:	f00d fa35 	bl	1b39e <strlen>
    if ((length != UUID_LEN) && (length != UUID_LEN + 4))
    df34:	2304      	movs	r3, #4
    df36:	0002      	movs	r2, r0
    df38:	439a      	bics	r2, r3
    df3a:	2a20      	cmp	r2, #32
    df3c:	d1f5      	bne.n	df2a <at_handle_NTSETID_cmd_set+0x52>
        else if ((length == UUID_LEN + 4) && (isxdigit((uint8)data[i]) || (data[i] == '-')))        //lint !e866
    df3e:	4b36      	ldr	r3, [pc, #216]	; (e018 <at_handle_NTSETID_cmd_set+0x140>)
    df40:	6819      	ldr	r1, [r3, #0]
    df42:	002b      	movs	r3, r5
    df44:	e009      	b.n	df5a <at_handle_NTSETID_cmd_set+0x82>
        if ((length == UUID_LEN) && isxdigit((uint8)data[i]))       //lint !e866
    df46:	2820      	cmp	r0, #32
    df48:	d125      	bne.n	df96 <at_handle_NTSETID_cmd_set+0xbe>
    df4a:	2644      	movs	r6, #68	; 0x44
    df4c:	5ce2      	ldrb	r2, [r4, r3]
    df4e:	188a      	adds	r2, r1, r2
    df50:	7852      	ldrb	r2, [r2, #1]
    df52:	4232      	tst	r2, r6
    df54:	d0e9      	beq.n	df2a <at_handle_NTSETID_cmd_set+0x52>
    for (uint8 i = 0; i < length; i++)
    df56:	3301      	adds	r3, #1
    df58:	b2db      	uxtb	r3, r3
    df5a:	4298      	cmp	r0, r3
    df5c:	d8f3      	bhi.n	df46 <at_handle_NTSETID_cmd_set+0x6e>
    df5e:	2600      	movs	r6, #0
    df60:	0037      	movs	r7, r6
                for (i = 0, j = 0; i < strlen(str_data); i++)
    df62:	0020      	movs	r0, r4
    df64:	f00d fa1b 	bl	1b39e <strlen>
    df68:	4287      	cmp	r7, r0
    df6a:	d329      	bcc.n	dfc0 <at_handle_NTSETID_cmd_set+0xe8>
                str_data[j] = '\0';
    df6c:	2300      	movs	r3, #0
                if (at_parse_buf_hex_to_uint8((uint8*)str_data, bin_data, (uint16)at_strlen(str_data)) != true)
    df6e:	0020      	movs	r0, r4
                str_data[j] = '\0';
    df70:	55a3      	strb	r3, [r4, r6]
                if (at_parse_buf_hex_to_uint8((uint8*)str_data, bin_data, (uint16)at_strlen(str_data)) != true)
    df72:	f00d fa14 	bl	1b39e <strlen>
    df76:	a902      	add	r1, sp, #8
    df78:	b282      	uxth	r2, r0
    df7a:	0020      	movs	r0, r4
    df7c:	f7fc f901 	bl	a182 <at_parse_buf_hex_to_uint8>
    df80:	2800      	cmp	r0, #0
    df82:	d0d2      	beq.n	df2a <at_handle_NTSETID_cmd_set+0x52>
                if (set_serial_number(bin_data) != NEUL_RET_OK)
    df84:	a802      	add	r0, sp, #8
    df86:	f00d fc80 	bl	1b88a <set_serial_number>
    df8a:	2800      	cmp	r0, #0
    df8c:	d000      	beq.n	df90 <at_handle_NTSETID_cmd_set+0xb8>
                    return AT_RET_PROGRESS_ERROR;
    df8e:	2506      	movs	r5, #6
}
    df90:	0028      	movs	r0, r5
    df92:	b011      	add	sp, #68	; 0x44
    df94:	bdf0      	pop	{r4, r5, r6, r7, pc}
        else if ((length == UUID_LEN + 4) && (isxdigit((uint8)data[i]) || (data[i] == '-')))        //lint !e866
    df96:	2824      	cmp	r0, #36	; 0x24
    df98:	d1c7      	bne.n	df2a <at_handle_NTSETID_cmd_set+0x52>
    df9a:	2744      	movs	r7, #68	; 0x44
    df9c:	5ce2      	ldrb	r2, [r4, r3]
    df9e:	188e      	adds	r6, r1, r2
    dfa0:	7876      	ldrb	r6, [r6, #1]
    dfa2:	423e      	tst	r6, r7
    dfa4:	d109      	bne.n	dfba <at_handle_NTSETID_cmd_set+0xe2>
    dfa6:	2a2d      	cmp	r2, #45	; 0x2d
    dfa8:	d1bf      	bne.n	df2a <at_handle_NTSETID_cmd_set+0x52>
            if ((data[i] == '-') && ((i != 8) && (i != 13) && (i != 18) && (i != 23)))
    dfaa:	2b17      	cmp	r3, #23
    dfac:	d8bd      	bhi.n	df2a <at_handle_NTSETID_cmd_set+0x52>
    dfae:	4a1b      	ldr	r2, [pc, #108]	; (e01c <at_handle_NTSETID_cmd_set+0x144>)
    dfb0:	2601      	movs	r6, #1
    dfb2:	40da      	lsrs	r2, r3
    dfb4:	4396      	bics	r6, r2
    dfb6:	d0ce      	beq.n	df56 <at_handle_NTSETID_cmd_set+0x7e>
    dfb8:	e7b7      	b.n	df2a <at_handle_NTSETID_cmd_set+0x52>
    dfba:	2a2d      	cmp	r2, #45	; 0x2d
    dfbc:	d1cb      	bne.n	df56 <at_handle_NTSETID_cmd_set+0x7e>
    dfbe:	e7f4      	b.n	dfaa <at_handle_NTSETID_cmd_set+0xd2>
                    if (str_data[i] != '-')
    dfc0:	5de3      	ldrb	r3, [r4, r7]
    dfc2:	2b2d      	cmp	r3, #45	; 0x2d
    dfc4:	d002      	beq.n	dfcc <at_handle_NTSETID_cmd_set+0xf4>
                        str_data[j] = str_data[i];
    dfc6:	55a3      	strb	r3, [r4, r6]
                        j++;
    dfc8:	3601      	adds	r6, #1
    dfca:	b2f6      	uxtb	r6, r6
                for (i = 0, j = 0; i < strlen(str_data); i++)
    dfcc:	3701      	adds	r7, #1
    dfce:	b2ff      	uxtb	r7, r7
    dfd0:	e7c7      	b.n	df62 <at_handle_NTSETID_cmd_set+0x8a>
                if (strlen(str_data) != IMEI_LEN)
    dfd2:	0020      	movs	r0, r4
    dfd4:	f00d f9e3 	bl	1b39e <strlen>
    dfd8:	0002      	movs	r2, r0
    dfda:	280f      	cmp	r0, #15
    dfdc:	d1a5      	bne.n	df2a <at_handle_NTSETID_cmd_set+0x52>
                bin_ret_len = neul_string_convert_str_to_BCD(bin_data, str_data, IMEI_LEN);
    dfde:	0021      	movs	r1, r4
    dfe0:	a802      	add	r0, sp, #8
    dfe2:	f00f fb57 	bl	1d694 <neul_string_convert_str_to_BCD>
                if (bin_ret_len == -1 || bin_ret_len != IMEI_LEN)
    dfe6:	280f      	cmp	r0, #15
    dfe8:	d19f      	bne.n	df2a <at_handle_NTSETID_cmd_set+0x52>
                else if (set_imei(bin_data) != NEUL_RET_OK)
    dfea:	a802      	add	r0, sp, #8
    dfec:	f00d fc37 	bl	1b85e <set_imei>
    dff0:	e7cb      	b.n	df8a <at_handle_NTSETID_cmd_set+0xb2>
                if (strlen(str_data) != SVN_LEN)
    dff2:	0020      	movs	r0, r4
    dff4:	f00d f9d3 	bl	1b39e <strlen>
    dff8:	0002      	movs	r2, r0
    dffa:	2802      	cmp	r0, #2
    dffc:	d000      	beq.n	e000 <at_handle_NTSETID_cmd_set+0x128>
    dffe:	e794      	b.n	df2a <at_handle_NTSETID_cmd_set+0x52>
                bin_ret_len = neul_string_convert_str_to_BCD(bin_data, str_data, SVN_LEN);
    e000:	0021      	movs	r1, r4
    e002:	a802      	add	r0, sp, #8
    e004:	f00f fb46 	bl	1d694 <neul_string_convert_str_to_BCD>
                if (bin_ret_len == -1 || bin_ret_len != SVN_LEN)
    e008:	2802      	cmp	r0, #2
    e00a:	d000      	beq.n	e00e <at_handle_NTSETID_cmd_set+0x136>
    e00c:	e78d      	b.n	df2a <at_handle_NTSETID_cmd_set+0x52>
                else if (set_svn(bin_data) != NEUL_RET_OK)
    e00e:	a802      	add	r0, sp, #8
    e010:	f00e fef4 	bl	1cdfc <set_svn>
    e014:	e7b9      	b.n	df8a <at_handle_NTSETID_cmd_set+0xb2>
    e016:	46c0      	nop			; (mov r8, r8)
    e018:	010005dc 	.word	0x010005dc
    e01c:	00842100 	.word	0x00842100

0000e020 <at_handle_CGMI_cmd_exec>:
{
    e020:	b570      	push	{r4, r5, r6, lr}
    e022:	b08c      	sub	sp, #48	; 0x30
    char    man_string[MANUFACTURER_IDENTITY_MAX_LEN + 1] = {0};
    e024:	ae01      	add	r6, sp, #4
    e026:	2229      	movs	r2, #41	; 0x29
    e028:	2100      	movs	r1, #0
    e02a:	0030      	movs	r0, r6
    e02c:	f7f2 f958 	bl	2e0 <memset>
    uint16  man_len = 0;
    e030:	466b      	mov	r3, sp
    e032:	1c9d      	adds	r5, r3, #2
    e034:	2300      	movs	r3, #0
    if (get_man_identifier(man_string,MANUFACTURER_IDENTITY_MAX_LEN, &man_len) != NEUL_RET_OK)
    e036:	002a      	movs	r2, r5
    e038:	2128      	movs	r1, #40	; 0x28
    e03a:	0030      	movs	r0, r6
    uint16  man_len = 0;
    e03c:	802b      	strh	r3, [r5, #0]
    if (get_man_identifier(man_string,MANUFACTURER_IDENTITY_MAX_LEN, &man_len) != NEUL_RET_OK)
    e03e:	f00d fc39 	bl	1b8b4 <get_man_identifier>
        return AT_RET_SYNTAX_ERROR;
    e042:	2401      	movs	r4, #1
    if (get_man_identifier(man_string,MANUFACTURER_IDENTITY_MAX_LEN, &man_len) != NEUL_RET_OK)
    e044:	2800      	cmp	r0, #0
    e046:	d10a      	bne.n	e05e <at_handle_CGMI_cmd_exec+0x3e>
    if( man_len > MANUFACTURER_IDENTITY_MAX_LEN )
    e048:	882b      	ldrh	r3, [r5, #0]
    e04a:	2b28      	cmp	r3, #40	; 0x28
    e04c:	d901      	bls.n	e052 <at_handle_CGMI_cmd_exec+0x32>
        man_len = MANUFACTURER_IDENTITY_MAX_LEN;
    e04e:	2328      	movs	r3, #40	; 0x28
    e050:	802b      	strh	r3, [r5, #0]
    man_string[man_len] = '\0';
    e052:	2400      	movs	r4, #0
    e054:	882b      	ldrh	r3, [r5, #0]
    app_at_send_at_rsp_string_lines_with_claim_and_log(man_string);
    e056:	0030      	movs	r0, r6
    man_string[man_len] = '\0';
    e058:	54f4      	strb	r4, [r6, r3]
    app_at_send_at_rsp_string_lines_with_claim_and_log(man_string);
    e05a:	f7fb fac3 	bl	95e4 <app_at_send_at_rsp_string_lines_with_claim_and_log>
}
    e05e:	0020      	movs	r0, r4
    e060:	b00c      	add	sp, #48	; 0x30
    e062:	bd70      	pop	{r4, r5, r6, pc}

0000e064 <at_handle_NLOGLEVEL_cmd_read>:
{
    e064:	b570      	push	{r4, r5, r6, lr}
    e066:	b094      	sub	sp, #80	; 0x50
    char            rsp_string[AT_LOG_LEVEL_MAX_LEN] = {0x00};
    e068:	2240      	movs	r2, #64	; 0x40
    e06a:	2100      	movs	r1, #0
    e06c:	a804      	add	r0, sp, #16
    e06e:	f7f2 f937 	bl	2e0 <memset>
    at_uart_claim();
    e072:	2400      	movs	r4, #0
    e074:	f7fb fc98 	bl	99a8 <at_uart_claim>
        if (neul_log_get_log_level((CORES)i, &level[i]) != NEUL_RET_OK)
    e078:	ae03      	add	r6, sp, #12
    e07a:	1931      	adds	r1, r6, r4
    e07c:	b2e0      	uxtb	r0, r4
    e07e:	f00d fd32 	bl	1bae6 <neul_log_get_log_level>
    e082:	1e05      	subs	r5, r0, #0
    e084:	d004      	beq.n	e090 <at_handle_NLOGLEVEL_cmd_read+0x2c>
            at_uart_release();
    e086:	f7fb fca1 	bl	99cc <at_uart_release>
            return AT_RET_SYNTAX_ERROR;
    e08a:	2001      	movs	r0, #1
}
    e08c:	b014      	add	sp, #80	; 0x50
    e08e:	bd70      	pop	{r4, r5, r6, pc}
        if (level[i] >= NEUL_LOG_MAX)
    e090:	5da3      	ldrb	r3, [r4, r6]
    e092:	2b05      	cmp	r3, #5
    e094:	d8f7      	bhi.n	e086 <at_handle_NLOGLEVEL_cmd_read+0x22>
        (void)snprintf(rsp_string, AT_LOG_LEVEL_MAX_LEN, "+NLOGLEVEL:%s,%s", core_name[i], log_level_names[level[i]]);
    e096:	490c      	ldr	r1, [pc, #48]	; (e0c8 <at_handle_NLOGLEVEL_cmd_read+0x64>)
    e098:	009b      	lsls	r3, r3, #2
    e09a:	585b      	ldr	r3, [r3, r1]
    e09c:	00a2      	lsls	r2, r4, #2
    e09e:	9300      	str	r3, [sp, #0]
    e0a0:	4b0a      	ldr	r3, [pc, #40]	; (e0cc <at_handle_NLOGLEVEL_cmd_read+0x68>)
    e0a2:	2140      	movs	r1, #64	; 0x40
    e0a4:	58d3      	ldr	r3, [r2, r3]
    e0a6:	a804      	add	r0, sp, #16
    e0a8:	4a09      	ldr	r2, [pc, #36]	; (e0d0 <at_handle_NLOGLEVEL_cmd_read+0x6c>)
    e0aa:	f00c fbdf 	bl	1a86c <snprintf>
    e0ae:	3401      	adds	r4, #1
        app_at_send_at_rsp_string_lines(rsp_string, false, AT_FLAG_LOGABLE);
    e0b0:	2208      	movs	r2, #8
    e0b2:	0029      	movs	r1, r5
    e0b4:	a804      	add	r0, sp, #16
    e0b6:	f7fb fa8e 	bl	95d6 <app_at_send_at_rsp_string_lines>
    for (i = CORES_SECURITY_CORE; i < CORES_MAX_NUMBER_PHYSICAL; i++)
    e0ba:	2c03      	cmp	r4, #3
    e0bc:	d1dc      	bne.n	e078 <at_handle_NLOGLEVEL_cmd_read+0x14>
    at_uart_release();
    e0be:	f7fb fc85 	bl	99cc <at_uart_release>
    return AT_RET_OK;
    e0c2:	0028      	movs	r0, r5
    e0c4:	e7e2      	b.n	e08c <at_handle_NLOGLEVEL_cmd_read+0x28>
    e0c6:	46c0      	nop			; (mov r8, r8)
    e0c8:	000247e4 	.word	0x000247e4
    e0cc:	00023f68 	.word	0x00023f68
    e0d0:	00023c1d 	.word	0x00023c1d

0000e0d4 <at_handle_NLOGLEVEL_cmd_set>:
{
    e0d4:	b5f0      	push	{r4, r5, r6, r7, lr}
    e0d6:	b089      	sub	sp, #36	; 0x24
    e0d8:	0004      	movs	r4, r0
    uint8               str_core [AT_LOG_LEVEL_MIN_LEN] = {0x00};
    e0da:	220c      	movs	r2, #12
    e0dc:	2100      	movs	r1, #0
    e0de:	a802      	add	r0, sp, #8
    e0e0:	f7f2 f8fe 	bl	2e0 <memset>
    uint8               str_level[AT_LOG_LEVEL_MIN_LEN] = {0x00};
    e0e4:	220c      	movs	r2, #12
    e0e6:	2100      	movs	r1, #0
    e0e8:	a805      	add	r0, sp, #20
    e0ea:	f7f2 f8f9 	bl	2e0 <memset>
    if (at_create_param_array(p_atparams_string, &num_recvparams, 2, 2) != AT_RET_OK)
    e0ee:	2302      	movs	r3, #2
    e0f0:	4669      	mov	r1, sp
    e0f2:	001a      	movs	r2, r3
    e0f4:	3107      	adds	r1, #7
    e0f6:	0020      	movs	r0, r4
    e0f8:	f7fc f8f4 	bl	a2e4 <at_create_param_array>
    e0fc:	2800      	cmp	r0, #0
    e0fe:	d003      	beq.n	e108 <at_handle_NLOGLEVEL_cmd_set+0x34>
        return AT_RET_SYNTAX_ERROR;
    e100:	2501      	movs	r5, #1
}
    e102:	0028      	movs	r0, r5
    e104:	b009      	add	sp, #36	; 0x24
    e106:	bdf0      	pop	{r4, r5, r6, r7, pc}
    if (at_get_string_param(AT_PARSE_FIRST_PARAM_POS, str_core, AT_LOG_LEVEL_MIN_LEN, true) != AT_RET_OK)
    e108:	2301      	movs	r3, #1
    e10a:	220c      	movs	r2, #12
    e10c:	a902      	add	r1, sp, #8
    e10e:	f7fc fb3b 	bl	a788 <at_get_string_param>
    e112:	2800      	cmp	r0, #0
    e114:	d1f4      	bne.n	e100 <at_handle_NLOGLEVEL_cmd_set+0x2c>
        if (at_strcmp(str_core, core_name[i]) == 0)
    e116:	491a      	ldr	r1, [pc, #104]	; (e180 <at_handle_NLOGLEVEL_cmd_set+0xac>)
    e118:	a802      	add	r0, sp, #8
    e11a:	f00d f921 	bl	1b360 <strcmp>
    e11e:	2800      	cmp	r0, #0
    e120:	d00d      	beq.n	e13e <at_handle_NLOGLEVEL_cmd_set+0x6a>
    e122:	4918      	ldr	r1, [pc, #96]	; (e184 <at_handle_NLOGLEVEL_cmd_set+0xb0>)
    e124:	a802      	add	r0, sp, #8
    e126:	f00d f91b 	bl	1b360 <strcmp>
    e12a:	2800      	cmp	r0, #0
    e12c:	d01e      	beq.n	e16c <at_handle_NLOGLEVEL_cmd_set+0x98>
    e12e:	4916      	ldr	r1, [pc, #88]	; (e188 <at_handle_NLOGLEVEL_cmd_set+0xb4>)
    e130:	a802      	add	r0, sp, #8
    e132:	f00d f915 	bl	1b360 <strcmp>
    e136:	2800      	cmp	r0, #0
    e138:	d1e2      	bne.n	e100 <at_handle_NLOGLEVEL_cmd_set+0x2c>
    for (i = CORES_SECURITY_CORE; i < CORES_MAX_NUMBER_PHYSICAL; i++)
    e13a:	2402      	movs	r4, #2
    e13c:	e000      	b.n	e140 <at_handle_NLOGLEVEL_cmd_set+0x6c>
    e13e:	0004      	movs	r4, r0
    if (at_get_string_param(AT_PARSE_SECOND_PARAM_POS, str_level, AT_LOG_LEVEL_MIN_LEN, true) != AT_RET_OK)
    e140:	2301      	movs	r3, #1
    e142:	220c      	movs	r2, #12
    e144:	a905      	add	r1, sp, #20
    e146:	0018      	movs	r0, r3
    e148:	f7fc fb1e 	bl	a788 <at_get_string_param>
    e14c:	0005      	movs	r5, r0
    e14e:	1e06      	subs	r6, r0, #0
    e150:	d1d6      	bne.n	e100 <at_handle_NLOGLEVEL_cmd_set+0x2c>
        if (at_strcmp(str_level, log_level_names[i]) == 0)
    e152:	4b0e      	ldr	r3, [pc, #56]	; (e18c <at_handle_NLOGLEVEL_cmd_set+0xb8>)
    e154:	00b2      	lsls	r2, r6, #2
    e156:	58d1      	ldr	r1, [r2, r3]
    e158:	a805      	add	r0, sp, #20
    e15a:	b2f7      	uxtb	r7, r6
    e15c:	f00d f900 	bl	1b360 <strcmp>
    e160:	2800      	cmp	r0, #0
    e162:	d005      	beq.n	e170 <at_handle_NLOGLEVEL_cmd_set+0x9c>
    e164:	3601      	adds	r6, #1
    for (i = NEUL_LOG_LEVEL_NONE; i < (NEUL_LOG_MAX - 1); i++)
    e166:	2e05      	cmp	r6, #5
    e168:	d1f3      	bne.n	e152 <at_handle_NLOGLEVEL_cmd_set+0x7e>
    e16a:	e7c9      	b.n	e100 <at_handle_NLOGLEVEL_cmd_set+0x2c>
    for (i = CORES_SECURITY_CORE; i < CORES_MAX_NUMBER_PHYSICAL; i++)
    e16c:	2401      	movs	r4, #1
    e16e:	e7e7      	b.n	e140 <at_handle_NLOGLEVEL_cmd_set+0x6c>
    if (neul_log_set_log_level(core, level) != NEUL_RET_OK)          //lint !e644
    e170:	0039      	movs	r1, r7
    e172:	0020      	movs	r0, r4
    e174:	f00d fc9c 	bl	1bab0 <neul_log_set_log_level>
    e178:	2800      	cmp	r0, #0
    e17a:	d0c2      	beq.n	e102 <at_handle_NLOGLEVEL_cmd_set+0x2e>
        return AT_RET_PROGRESS_ERROR;
    e17c:	2506      	movs	r5, #6
    e17e:	e7c0      	b.n	e102 <at_handle_NLOGLEVEL_cmd_set+0x2e>
    e180:	00023c2e 	.word	0x00023c2e
    e184:	00023c37 	.word	0x00023c37
    e188:	00023c40 	.word	0x00023c40
    e18c:	000247e4 	.word	0x000247e4

0000e190 <at_handle_NCCID_cmd_read>:
{
    e190:	b5f0      	push	{r4, r5, r6, r7, lr}
    e192:	b08f      	sub	sp, #60	; 0x3c
    char                rsp_string[AT_MAX_NCCID_RSP_LEN] = {0};
    e194:	221c      	movs	r2, #28
    e196:	2100      	movs	r1, #0
    char                iccid[CCID_PACKED_LENGTH]        = {0};
    e198:	af02      	add	r7, sp, #8
    char                rsp_string[AT_MAX_NCCID_RSP_LEN] = {0};
    e19a:	a807      	add	r0, sp, #28
    e19c:	f7f2 f8a0 	bl	2e0 <memset>
    char                iccid[CCID_PACKED_LENGTH]        = {0};
    e1a0:	2214      	movs	r2, #20
    e1a2:	2100      	movs	r1, #0
    e1a4:	0038      	movs	r0, r7
    e1a6:	f7f2 f89b 	bl	2e0 <memset>
    uint16              iccid_len                        = 0;
    e1aa:	466b      	mov	r3, sp
    e1ac:	1d9e      	adds	r6, r3, #6
    e1ae:	2300      	movs	r3, #0
    result = get_iccid(iccid, &iccid_len);
    e1b0:	0031      	movs	r1, r6
    e1b2:	0038      	movs	r0, r7
    uint16              iccid_len                        = 0;
    e1b4:	8033      	strh	r3, [r6, #0]
    result = get_iccid(iccid, &iccid_len);
    e1b6:	f00d fc3b 	bl	1ba30 <get_iccid>
    e1ba:	0004      	movs	r4, r0
    cause = at_parse_convert_neul_result(result);
    e1bc:	f7fc f868 	bl	a290 <at_parse_convert_neul_result>
    if (result != NEUL_RET_OK)
    e1c0:	2c00      	cmp	r4, #0
    e1c2:	d111      	bne.n	e1e8 <at_handle_NCCID_cmd_read+0x58>
    if (iccid_len == 0)
    e1c4:	8833      	ldrh	r3, [r6, #0]
        return AT_RET_OK;
    e1c6:	0020      	movs	r0, r4
    if (iccid_len == 0)
    e1c8:	2b00      	cmp	r3, #0
    e1ca:	d00d      	beq.n	e1e8 <at_handle_NCCID_cmd_read+0x58>
    rsp_len = (uint16)snprintf(rsp_string, AT_MAX_NCCID_RSP_LEN, "%s", AT_NCCID_RSP_PREFIX);
    e1cc:	4b0e      	ldr	r3, [pc, #56]	; (e208 <at_handle_NCCID_cmd_read+0x78>)
    e1ce:	4a0f      	ldr	r2, [pc, #60]	; (e20c <at_handle_NCCID_cmd_read+0x7c>)
    e1d0:	211c      	movs	r1, #28
    e1d2:	a807      	add	r0, sp, #28
    e1d4:	f00c fb4a 	bl	1a86c <snprintf>
    e1d8:	b285      	uxth	r5, r0
    for (uint8 uc_loop = 0;uc_loop < iccid_len; uc_loop++)
    e1da:	8833      	ldrh	r3, [r6, #0]
    e1dc:	42a3      	cmp	r3, r4
    e1de:	d805      	bhi.n	e1ec <at_handle_NCCID_cmd_read+0x5c>
    app_at_send_at_rsp_string_lines_with_claim_and_log_restricted(rsp_string);
    e1e0:	a807      	add	r0, sp, #28
    e1e2:	f7fb fa06 	bl	95f2 <app_at_send_at_rsp_string_lines_with_claim_and_log_restricted>
    return AT_RET_OK;
    e1e6:	2000      	movs	r0, #0
}
    e1e8:	b00f      	add	sp, #60	; 0x3c
    e1ea:	bdf0      	pop	{r4, r5, r6, r7, pc}
        rsp_len += (uint16)snprintf(rsp_string + rsp_len, AT_MAX_NCCID_RSP_LEN - rsp_len, "%x", iccid[uc_loop]);
    e1ec:	221c      	movs	r2, #28
    e1ee:	1b51      	subs	r1, r2, r5
    e1f0:	aa07      	add	r2, sp, #28
    e1f2:	1950      	adds	r0, r2, r5
    e1f4:	5d3b      	ldrb	r3, [r7, r4]
    e1f6:	4a06      	ldr	r2, [pc, #24]	; (e210 <at_handle_NCCID_cmd_read+0x80>)
    e1f8:	f00c fb38 	bl	1a86c <snprintf>
    for (uint8 uc_loop = 0;uc_loop < iccid_len; uc_loop++)
    e1fc:	3401      	adds	r4, #1
        rsp_len += (uint16)snprintf(rsp_string + rsp_len, AT_MAX_NCCID_RSP_LEN - rsp_len, "%x", iccid[uc_loop]);
    e1fe:	182d      	adds	r5, r5, r0
    e200:	b2ad      	uxth	r5, r5
    for (uint8 uc_loop = 0;uc_loop < iccid_len; uc_loop++)
    e202:	b2e4      	uxtb	r4, r4
    e204:	e7e9      	b.n	e1da <at_handle_NCCID_cmd_read+0x4a>
    e206:	46c0      	nop			; (mov r8, r8)
    e208:	00023a6c 	.word	0x00023a6c
    e20c:	000237d7 	.word	0x000237d7
    e210:	00025f29 	.word	0x00025f29

0000e214 <at_handle_NCCID_cmd_exc>:
{
    e214:	b510      	push	{r4, lr}
    return at_handle_NCCID_cmd_read();
    e216:	f7ff ffbb 	bl	e190 <at_handle_NCCID_cmd_read>
}
    e21a:	bd10      	pop	{r4, pc}

0000e21c <ctzr_callback>:
{
    e21c:	b5f0      	push	{r4, r5, r6, r7, lr}
    char        reporting_str[AT_MAX_CTZR_REPROTING_LEN] = {0};
    e21e:	2521      	movs	r5, #33	; 0x21
{
    e220:	b095      	sub	sp, #84	; 0x54
    char        reporting_str[AT_MAX_CTZR_REPROTING_LEN] = {0};
    e222:	002a      	movs	r2, r5
    e224:	2100      	movs	r1, #0
    e226:	a80b      	add	r0, sp, #44	; 0x2c
    e228:	f7f2 f85a 	bl	2e0 <memset>
    const char *time_str[] =
    e22c:	aa07      	add	r2, sp, #28
    e22e:	0011      	movs	r1, r2
    CTZR_RPORTING_MODE  ctzr_mode = app_at_state_info.ctzr_mode;
    e230:	4b34      	ldr	r3, [pc, #208]	; (e304 <ctzr_callback+0xe8>)
    e232:	789f      	ldrb	r7, [r3, #2]
    const char *time_str[] =
    e234:	4b34      	ldr	r3, [pc, #208]	; (e308 <ctzr_callback+0xec>)
    e236:	3310      	adds	r3, #16
    e238:	cb51      	ldmia	r3!, {r0, r4, r6}
    e23a:	c151      	stmia	r1!, {r0, r4, r6}
    e23c:	681b      	ldr	r3, [r3, #0]
    e23e:	600b      	str	r3, [r1, #0]
    if ((ctzr_mode == CTZR_RPORTING_MODE_DISABLE) || (ctzr_mode > CTZR_RPORTING_MODE_ENABLE_REPORTING_CTZEU))       //lint !e685
    e240:	1e7b      	subs	r3, r7, #1
    e242:	2b02      	cmp	r3, #2
    e244:	d856      	bhi.n	e2f4 <ctzr_callback+0xd8>
    reporting_len = (uint16)snprintf(reporting_str, AT_MAX_CTZR_REPROTING_LEN, "%s", time_str[ctzr_mode]);
    e246:	00bb      	lsls	r3, r7, #2
    e248:	0029      	movs	r1, r5
    e24a:	589b      	ldr	r3, [r3, r2]
    e24c:	a80b      	add	r0, sp, #44	; 0x2c
    e24e:	4a2f      	ldr	r2, [pc, #188]	; (e30c <ctzr_callback+0xf0>)
    e250:	f00c fb0c 	bl	1a86c <snprintf>
    e254:	b283      	uxth	r3, r0
    e256:	9305      	str	r3, [sp, #20]
    e258:	0006      	movs	r6, r0
    tz = rtc_get_time_zone() + 4*rtc_get_daylight_saving_time();
    e25a:	f00a fa89 	bl	18770 <rtc_get_time_zone>
    e25e:	0004      	movs	r4, r0
    e260:	f00a fa80 	bl	18764 <rtc_get_daylight_saving_time>
    e264:	0080      	lsls	r0, r0, #2
    e266:	1904      	adds	r4, r0, r4
    e268:	b2b1      	uxth	r1, r6
    e26a:	ab0b      	add	r3, sp, #44	; 0x2c
    e26c:	b224      	sxth	r4, r4
    e26e:	1858      	adds	r0, r3, r1
    e270:	1a69      	subs	r1, r5, r1
    if (tz >= 0)
    e272:	2c00      	cmp	r4, #0
    e274:	db40      	blt.n	e2f8 <ctzr_callback+0xdc>
        reporting_len += (uint16)snprintf(reporting_str + reporting_len, AT_MAX_CTZR_REPROTING_LEN - reporting_len, "+%02d", tz);
    e276:	0023      	movs	r3, r4
    e278:	4a25      	ldr	r2, [pc, #148]	; (e310 <ctzr_callback+0xf4>)
        reporting_len += (uint16)snprintf(reporting_str + reporting_len, AT_MAX_CTZR_REPROTING_LEN - reporting_len, "-%02d", -tz);
    e27a:	f00c faf7 	bl	1a86c <snprintf>
    e27e:	9b05      	ldr	r3, [sp, #20]
    e280:	1818      	adds	r0, r3, r0
    if ((ctzr_mode == CTZR_RPORTING_MODE_ENABLE_REPORTING_CTZE) || (ctzr_mode == CTZR_RPORTING_MODE_ENABLE_REPORTING_CTZEU))
    e282:	1ebb      	subs	r3, r7, #2
        reporting_len += (uint16)snprintf(reporting_str + reporting_len, AT_MAX_CTZR_REPROTING_LEN - reporting_len, "-%02d", -tz);
    e284:	b285      	uxth	r5, r0
    if ((ctzr_mode == CTZR_RPORTING_MODE_ENABLE_REPORTING_CTZE) || (ctzr_mode == CTZR_RPORTING_MODE_ENABLE_REPORTING_CTZEU))
    e286:	2b01      	cmp	r3, #1
    e288:	d82e      	bhi.n	e2e8 <ctzr_callback+0xcc>
        if (ctzr_mode == CTZR_RPORTING_MODE_ENABLE_REPORTING_CTZE)
    e28a:	2f02      	cmp	r7, #2
    e28c:	d137      	bne.n	e2fe <ctzr_callback+0xe2>
            output_time = get_current_time() + tz*AT_MINUTES_PER_QUARTERS_OF_AN_HOUR*AT_SECONDS_PER_AN_MINUTE;  //lint !e737
    e28e:	f00a fa5f 	bl	18750 <get_current_time>
    e292:	23e1      	movs	r3, #225	; 0xe1
    e294:	009b      	lsls	r3, r3, #2
    e296:	435c      	muls	r4, r3
    e298:	1820      	adds	r0, r4, r0
            output_time = get_current_time();
    e29a:	9006      	str	r0, [sp, #24]
        tmFmtDatetime = gmtime(&output_time);
    e29c:	a806      	add	r0, sp, #24
    e29e:	f00d f913 	bl	1b4c8 <gmtime>
    e2a2:	1e04      	subs	r4, r0, #0
        if (tmFmtDatetime == NULL)
    e2a4:	d026      	beq.n	e2f4 <ctzr_callback+0xd8>
        rtc_get_daylight_saving_time(), tmFmtDatetime->tm_year + 1900);
    e2a6:	f00a fa5d 	bl	18764 <rtc_get_daylight_saving_time>
        reporting_len += (uint16)snprintf(reporting_str + reporting_len, AT_MAX_CTZR_REPROTING_LEN - reporting_len, ",%d,%d/",
    e2aa:	2621      	movs	r6, #33	; 0x21
    e2ac:	aa0b      	add	r2, sp, #44	; 0x2c
        rtc_get_daylight_saving_time(), tmFmtDatetime->tm_year + 1900);
    e2ae:	0003      	movs	r3, r0
        reporting_len += (uint16)snprintf(reporting_str + reporting_len, AT_MAX_CTZR_REPROTING_LEN - reporting_len, ",%d,%d/",
    e2b0:	4f18      	ldr	r7, [pc, #96]	; (e314 <ctzr_callback+0xf8>)
    e2b2:	1950      	adds	r0, r2, r5
    e2b4:	6962      	ldr	r2, [r4, #20]
    e2b6:	1b71      	subs	r1, r6, r5
    e2b8:	19d2      	adds	r2, r2, r7
    e2ba:	9200      	str	r2, [sp, #0]
    e2bc:	4a16      	ldr	r2, [pc, #88]	; (e318 <ctzr_callback+0xfc>)
    e2be:	f00c fad5 	bl	1a86c <snprintf>
    e2c2:	1828      	adds	r0, r5, r0
    e2c4:	b280      	uxth	r0, r0
        (void)add_mon_day_hour_min_sec_to_string(tmFmtDatetime, reporting_str + reporting_len, AT_MAX_CTZR_REPROTING_LEN - reporting_len);
    e2c6:	aa0b      	add	r2, sp, #44	; 0x2c
    e2c8:	1a31      	subs	r1, r6, r0
    e2ca:	1810      	adds	r0, r2, r0
    return (uint8)snprintf(string, max_len, "%02d/%02d,%02d:%02d:%02d",
    e2cc:	6822      	ldr	r2, [r4, #0]
    e2ce:	6923      	ldr	r3, [r4, #16]
    e2d0:	9203      	str	r2, [sp, #12]
    e2d2:	6862      	ldr	r2, [r4, #4]
    e2d4:	3301      	adds	r3, #1
    e2d6:	9202      	str	r2, [sp, #8]
    e2d8:	68a2      	ldr	r2, [r4, #8]
    e2da:	b289      	uxth	r1, r1
    e2dc:	9201      	str	r2, [sp, #4]
    e2de:	68e2      	ldr	r2, [r4, #12]
    e2e0:	9200      	str	r2, [sp, #0]
    e2e2:	4a0e      	ldr	r2, [pc, #56]	; (e31c <ctzr_callback+0x100>)
    e2e4:	f00c fac2 	bl	1a86c <snprintf>
    delayed_async_print(reporting_str, AT_FLAG_LOGABLE, 0, 0);
    e2e8:	2300      	movs	r3, #0
    e2ea:	2108      	movs	r1, #8
    e2ec:	001a      	movs	r2, r3
    e2ee:	a80b      	add	r0, sp, #44	; 0x2c
    e2f0:	f7fc fce4 	bl	acbc <delayed_async_print>
}
    e2f4:	b015      	add	sp, #84	; 0x54
    e2f6:	bdf0      	pop	{r4, r5, r6, r7, pc}
        reporting_len += (uint16)snprintf(reporting_str + reporting_len, AT_MAX_CTZR_REPROTING_LEN - reporting_len, "-%02d", -tz);
    e2f8:	4263      	negs	r3, r4
    e2fa:	4a09      	ldr	r2, [pc, #36]	; (e320 <ctzr_callback+0x104>)
    e2fc:	e7bd      	b.n	e27a <ctzr_callback+0x5e>
            output_time = get_current_time();
    e2fe:	f00a fa27 	bl	18750 <get_current_time>
    e302:	e7ca      	b.n	e29a <ctzr_callback+0x7e>
    e304:	010024c2 	.word	0x010024c2
    e308:	00022a78 	.word	0x00022a78
    e30c:	000237d7 	.word	0x000237d7
    e310:	00023f74 	.word	0x00023f74
    e314:	0000076c 	.word	0x0000076c
    e318:	00023f80 	.word	0x00023f80
    e31c:	00023f88 	.word	0x00023f88
    e320:	00023f7a 	.word	0x00023f7a

0000e324 <at_handle_NITZ_cmd_read>:
{
    e324:	b530      	push	{r4, r5, lr}
    if (get_time_update_mode(&time_update_mode) != NEUL_RET_OK)
    e326:	250f      	movs	r5, #15
{
    e328:	b087      	sub	sp, #28
    char                auc_rsp_data[AT_NITZ_REAS_RSP_MAX_LENGTH] = {0};
    e32a:	2208      	movs	r2, #8
    e32c:	2100      	movs	r1, #0
    e32e:	a804      	add	r0, sp, #16
    if (get_time_update_mode(&time_update_mode) != NEUL_RET_OK)
    e330:	446d      	add	r5, sp
    char                auc_rsp_data[AT_NITZ_REAS_RSP_MAX_LENGTH] = {0};
    e332:	f7f1 ffd5 	bl	2e0 <memset>
    if (get_time_update_mode(&time_update_mode) != NEUL_RET_OK)
    e336:	0028      	movs	r0, r5
    e338:	f00d fc53 	bl	1bbe2 <get_time_update_mode>
    e33c:	0004      	movs	r4, r0
        return AT_RET_PROGRESS_ERROR;
    e33e:	2006      	movs	r0, #6
    if (get_time_update_mode(&time_update_mode) != NEUL_RET_OK)
    e340:	2c00      	cmp	r4, #0
    e342:	d10b      	bne.n	e35c <at_handle_NITZ_cmd_read+0x38>
    (void)snprintf(auc_rsp_data, AT_MAX_RSP_LEN, "%s:%d", AT_NITZ_CMD_PREFIX, (uint8)time_update_mode);
    e344:	782b      	ldrb	r3, [r5, #0]
    e346:	4a06      	ldr	r2, [pc, #24]	; (e360 <at_handle_NITZ_cmd_read+0x3c>)
    e348:	9300      	str	r3, [sp, #0]
    e34a:	21c8      	movs	r1, #200	; 0xc8
    e34c:	4b05      	ldr	r3, [pc, #20]	; (e364 <at_handle_NITZ_cmd_read+0x40>)
    e34e:	a804      	add	r0, sp, #16
    e350:	f00c fa8c 	bl	1a86c <snprintf>
    app_at_send_at_rsp_string_lines_with_claim_and_log(auc_rsp_data);
    e354:	a804      	add	r0, sp, #16
    e356:	f7fb f945 	bl	95e4 <app_at_send_at_rsp_string_lines_with_claim_and_log>
    return AT_RET_OK;
    e35a:	0020      	movs	r0, r4
}
    e35c:	b007      	add	sp, #28
    e35e:	bd30      	pop	{r4, r5, pc}
    e360:	00023bdc 	.word	0x00023bdc
    e364:	00023c0b 	.word	0x00023c0b

0000e368 <at_handle_CGAUTH_cmd_read>:
{
    e368:	b5f0      	push	{r4, r5, r6, r7, lr}
    char                   apnrc_string[AT_CGAUTH_MAX_LEN]    = {0};
    e36a:	2400      	movs	r4, #0
{
    e36c:	b0cb      	sub	sp, #300	; 0x12c
    uint8                  login_str[NEUL_CGAUTH_MAX_USERNAME_LEN + 1] = {0};
    e36e:	ad07      	add	r5, sp, #28
    e370:	223d      	movs	r2, #61	; 0x3d
    e372:	2100      	movs	r1, #0
    e374:	0028      	movs	r0, r5
    e376:	f7f1 ffb3 	bl	2e0 <memset>
    uint8                  password_str[NEUL_CGAUTH_MAX_PASSWORD_LEN + 1] = {0};
    e37a:	223d      	movs	r2, #61	; 0x3d
    e37c:	2100      	movs	r1, #0
    e37e:	a817      	add	r0, sp, #92	; 0x5c
    e380:	f7f1 ffae 	bl	2e0 <memset>
    char                   apnrc_string[AT_CGAUTH_MAX_LEN]    = {0};
    e384:	228c      	movs	r2, #140	; 0x8c
    e386:	2100      	movs	r1, #0
    e388:	a827      	add	r0, sp, #156	; 0x9c
    e38a:	f7f1 ffa9 	bl	2e0 <memset>
    bool                   line_feed_flag                        = false;
    e38e:	9405      	str	r4, [sp, #20]
        result = get_pdp_context_auth_param(cid, &auth_prot, login_str, password_str);
    e390:	2713      	movs	r7, #19
        memset(login_str, 0, NEUL_CGAUTH_MAX_USERNAME_LEN + 1);
    e392:	223d      	movs	r2, #61	; 0x3d
    e394:	2100      	movs	r1, #0
        memset(password_str, 0, NEUL_CGAUTH_MAX_PASSWORD_LEN + 1);
    e396:	ae17      	add	r6, sp, #92	; 0x5c
        memset(login_str, 0, NEUL_CGAUTH_MAX_USERNAME_LEN + 1);
    e398:	0028      	movs	r0, r5
    e39a:	f7f1 ffa1 	bl	2e0 <memset>
        memset(password_str, 0, NEUL_CGAUTH_MAX_PASSWORD_LEN + 1);
    e39e:	223d      	movs	r2, #61	; 0x3d
    e3a0:	2100      	movs	r1, #0
    e3a2:	0030      	movs	r0, r6
    e3a4:	f7f1 ff9c 	bl	2e0 <memset>
        result = get_pdp_context_auth_param(cid, &auth_prot, login_str, password_str);
    e3a8:	ab02      	add	r3, sp, #8
    e3aa:	18ff      	adds	r7, r7, r3
    e3ac:	b2e0      	uxtb	r0, r4
    e3ae:	0033      	movs	r3, r6
    e3b0:	002a      	movs	r2, r5
    e3b2:	0039      	movs	r1, r7
    e3b4:	f00e f811 	bl	1c3da <get_pdp_context_auth_param>
        if( NEUL_RET_OK == result)
    e3b8:	2800      	cmp	r0, #0
    e3ba:	d123      	bne.n	e404 <at_handle_CGAUTH_cmd_read+0x9c>
            (void)snprintf(apnrc_string, AT_CGAUTH_MAX_LEN, "%s%d,%d,\"%s\",\"%s\"", AT_CGAUTH_PREFIX_STR, cid, auth_prot, login_str, password_str);
    e3bc:	9603      	str	r6, [sp, #12]
    e3be:	9502      	str	r5, [sp, #8]
    e3c0:	783b      	ldrb	r3, [r7, #0]
    e3c2:	4a13      	ldr	r2, [pc, #76]	; (e410 <at_handle_CGAUTH_cmd_read+0xa8>)
    e3c4:	9301      	str	r3, [sp, #4]
    e3c6:	9400      	str	r4, [sp, #0]
    e3c8:	4b12      	ldr	r3, [pc, #72]	; (e414 <at_handle_CGAUTH_cmd_read+0xac>)
    e3ca:	218c      	movs	r1, #140	; 0x8c
    e3cc:	a827      	add	r0, sp, #156	; 0x9c
    e3ce:	f00c fa4d 	bl	1a86c <snprintf>
            if (!line_feed_flag)
    e3d2:	9b05      	ldr	r3, [sp, #20]
    e3d4:	4e10      	ldr	r6, [pc, #64]	; (e418 <at_handle_CGAUTH_cmd_read+0xb0>)
    e3d6:	2b00      	cmp	r3, #0
    e3d8:	d106      	bne.n	e3e8 <at_handle_CGAUTH_cmd_read+0x80>
                at_uart_write((unsigned char*)APP_AT_STR_RN, strlen(APP_AT_STR_RN));
    e3da:	0030      	movs	r0, r6
    e3dc:	f00c ffdf 	bl	1b39e <strlen>
    e3e0:	0001      	movs	r1, r0
    e3e2:	0030      	movs	r0, r6
    e3e4:	f7fb fb02 	bl	99ec <at_uart_write>
            app_at_send_at_rsp_string(apnrc_string, true, AT_FLAG_LOGABLE);
    e3e8:	2208      	movs	r2, #8
    e3ea:	2101      	movs	r1, #1
    e3ec:	a827      	add	r0, sp, #156	; 0x9c
    e3ee:	f7fb f8eb 	bl	95c8 <app_at_send_at_rsp_string>
            at_uart_write((unsigned char*)APP_AT_STR_RN, strlen(APP_AT_STR_RN));
    e3f2:	0030      	movs	r0, r6
    e3f4:	f00c ffd3 	bl	1b39e <strlen>
    e3f8:	0001      	movs	r1, r0
    e3fa:	0030      	movs	r0, r6
    e3fc:	f7fb faf6 	bl	99ec <at_uart_write>
    e400:	2301      	movs	r3, #1
    e402:	9305      	str	r3, [sp, #20]
    e404:	3401      	adds	r4, #1
    for(uint8 cid = 0 ; cid <= AT_MAX_CID; cid++)
    e406:	2c0b      	cmp	r4, #11
    e408:	d1c2      	bne.n	e390 <at_handle_CGAUTH_cmd_read+0x28>
}
    e40a:	2000      	movs	r0, #0
    e40c:	b04b      	add	sp, #300	; 0x12c
    e40e:	bdf0      	pop	{r4, r5, r6, r7, pc}
    e410:	000236a8 	.word	0x000236a8
    e414:	0002369f 	.word	0x0002369f
    e418:	00022d8f 	.word	0x00022d8f

0000e41c <at_handle_CGAUTH_cmd_set>:
{
    e41c:	b5f0      	push	{r4, r5, r6, r7, lr}
    e41e:	b0a3      	sub	sp, #140	; 0x8c
    NEUL_PDP_AUTH_PROTO    auth_prot = NEUL_PDP_AUTH_PROTO_NONE;
    e420:	466b      	mov	r3, sp
    e422:	2600      	movs	r6, #0
    uint8                  login_str[NEUL_CGAUTH_MAX_USERNAME_LEN + 1] = {0};
    e424:	ad02      	add	r5, sp, #8
    NEUL_PDP_AUTH_PROTO    auth_prot = NEUL_PDP_AUTH_PROTO_NONE;
    e426:	1ddc      	adds	r4, r3, #7
{
    e428:	0007      	movs	r7, r0
    uint8                  login_str[NEUL_CGAUTH_MAX_USERNAME_LEN + 1] = {0};
    e42a:	223d      	movs	r2, #61	; 0x3d
    e42c:	0031      	movs	r1, r6
    e42e:	0028      	movs	r0, r5
    NEUL_PDP_AUTH_PROTO    auth_prot = NEUL_PDP_AUTH_PROTO_NONE;
    e430:	7026      	strb	r6, [r4, #0]
    uint8                  login_str[NEUL_CGAUTH_MAX_USERNAME_LEN + 1] = {0};
    e432:	f7f1 ff55 	bl	2e0 <memset>
    uint8                  password_str[NEUL_CGAUTH_MAX_PASSWORD_LEN + 1] = {0};
    e436:	223d      	movs	r2, #61	; 0x3d
    e438:	0031      	movs	r1, r6
    e43a:	a812      	add	r0, sp, #72	; 0x48
    e43c:	f7f1 ff50 	bl	2e0 <memset>
    cause = at_create_param_array(p_atparams_string, &num_recvparams, 1, 4);
    e440:	4669      	mov	r1, sp
    e442:	2304      	movs	r3, #4
    e444:	2201      	movs	r2, #1
    e446:	3105      	adds	r1, #5
    e448:	0038      	movs	r0, r7
    e44a:	f7fb ff4b 	bl	a2e4 <at_create_param_array>
    if(cause != AT_RET_OK)
    e44e:	42b0      	cmp	r0, r6
    e450:	d114      	bne.n	e47c <at_handle_CGAUTH_cmd_set+0x60>
    cause = at_get_uint8_param(AT_PARSE_FIRST_PARAM_POS, &cid, true);
    e452:	466b      	mov	r3, sp
    e454:	1d9e      	adds	r6, r3, #6
    e456:	2201      	movs	r2, #1
    e458:	0031      	movs	r1, r6
    e45a:	f7fc f8d7 	bl	a60c <at_get_uint8_param>
    if(cause != AT_RET_OK)
    e45e:	2800      	cmp	r0, #0
    e460:	d10c      	bne.n	e47c <at_handle_CGAUTH_cmd_set+0x60>
    cause = at_get_uint8_param(AT_PARSE_SECOND_PARAM_POS, (uint8 *)&auth_prot, true);
    e462:	2201      	movs	r2, #1
    e464:	0021      	movs	r1, r4
    e466:	0010      	movs	r0, r2
    e468:	f7fc f8d0 	bl	a60c <at_get_uint8_param>
    if((cause != AT_RET_OK) && (cause != AT_RET_PARAM_MISSING))
    e46c:	2800      	cmp	r0, #0
    e46e:	d001      	beq.n	e474 <at_handle_CGAUTH_cmd_set+0x58>
    e470:	2803      	cmp	r0, #3
    e472:	d103      	bne.n	e47c <at_handle_CGAUTH_cmd_set+0x60>
    if (auth_prot > NEUL_PDP_AUTH_PROTO_CHAP)
    e474:	7823      	ldrb	r3, [r4, #0]
    e476:	2b02      	cmp	r3, #2
    e478:	d902      	bls.n	e480 <at_handle_CGAUTH_cmd_set+0x64>
        return AT_RET_SYNTAX_ERROR;
    e47a:	2001      	movs	r0, #1
}
    e47c:	b023      	add	sp, #140	; 0x8c
    e47e:	bdf0      	pop	{r4, r5, r6, r7, pc}
    cause = at_get_string_param(AT_PARSE_THIRD_PARAM_POS, login_str, NEUL_CGAUTH_MAX_USERNAME_LEN + 1, true);
    e480:	2301      	movs	r3, #1
    e482:	223d      	movs	r2, #61	; 0x3d
    e484:	0029      	movs	r1, r5
    e486:	2002      	movs	r0, #2
    e488:	f7fc f97e 	bl	a788 <at_get_string_param>
    if((cause != AT_RET_OK) && (cause != AT_RET_PARAM_MISSING))
    e48c:	2800      	cmp	r0, #0
    e48e:	d004      	beq.n	e49a <at_handle_CGAUTH_cmd_set+0x7e>
    e490:	2803      	cmp	r0, #3
    e492:	d1f2      	bne.n	e47a <at_handle_CGAUTH_cmd_set+0x5e>
    else if ((cause == AT_RET_PARAM_MISSING) && (auth_prot != NEUL_PDP_AUTH_PROTO_NONE))
    e494:	7823      	ldrb	r3, [r4, #0]
    e496:	2b00      	cmp	r3, #0
    e498:	d1ef      	bne.n	e47a <at_handle_CGAUTH_cmd_set+0x5e>
    if ((*login_str == '\0') && (auth_prot != NEUL_PDP_AUTH_PROTO_NONE))
    e49a:	782b      	ldrb	r3, [r5, #0]
    e49c:	2b00      	cmp	r3, #0
    e49e:	d102      	bne.n	e4a6 <at_handle_CGAUTH_cmd_set+0x8a>
    e4a0:	7823      	ldrb	r3, [r4, #0]
    e4a2:	2b00      	cmp	r3, #0
    e4a4:	d1e9      	bne.n	e47a <at_handle_CGAUTH_cmd_set+0x5e>
    cause = at_get_string_param(AT_PARSE_FOURTH_PARAM_POS, password_str, NEUL_CGAUTH_MAX_PASSWORD_LEN + 1, true);
    e4a6:	2301      	movs	r3, #1
    e4a8:	223d      	movs	r2, #61	; 0x3d
    e4aa:	a912      	add	r1, sp, #72	; 0x48
    e4ac:	2003      	movs	r0, #3
    e4ae:	f7fc f96b 	bl	a788 <at_get_string_param>
    if ((cause != AT_RET_OK) && (cause != AT_RET_PARAM_MISSING))
    e4b2:	2800      	cmp	r0, #0
    e4b4:	d001      	beq.n	e4ba <at_handle_CGAUTH_cmd_set+0x9e>
    e4b6:	2803      	cmp	r0, #3
    e4b8:	d1e0      	bne.n	e47c <at_handle_CGAUTH_cmd_set+0x60>
    result = set_pdp_context_auth_param(cid, auth_prot, login_str, password_str);
    e4ba:	7821      	ldrb	r1, [r4, #0]
    e4bc:	ab12      	add	r3, sp, #72	; 0x48
    e4be:	002a      	movs	r2, r5
    e4c0:	7830      	ldrb	r0, [r6, #0]
    e4c2:	f00d ff62 	bl	1c38a <set_pdp_context_auth_param>
    return at_parse_convert_neul_result(result);
    e4c6:	f7fb fee3 	bl	a290 <at_parse_convert_neul_result>
    e4ca:	e7d7      	b.n	e47c <at_handle_CGAUTH_cmd_set+0x60>

0000e4cc <at_handle_CGDCONT_cmd_read>:
{
    e4cc:	b5f0      	push	{r4, r5, r6, r7, lr}
    e4ce:	b0c9      	sub	sp, #292	; 0x124
    pdp_context context = {0};
    e4d0:	2278      	movs	r2, #120	; 0x78
    e4d2:	2100      	movs	r1, #0
    e4d4:	a82a      	add	r0, sp, #168	; 0xa8
    e4d6:	f7f1 ff03 	bl	2e0 <memset>
    context.apn = apn_str;
    e4da:	ab10      	add	r3, sp, #64	; 0x40
    char  *auc_rsp_data = (char *)irzalloc(AT_MAX_RSP_LEN);
    e4dc:	20c8      	movs	r0, #200	; 0xc8
    context.apn = apn_str;
    e4de:	932d      	str	r3, [sp, #180]	; 0xb4
    char  *auc_rsp_data = (char *)irzalloc(AT_MAX_RSP_LEN);
    e4e0:	f004 fa98 	bl	12a14 <irzalloc>
    e4e4:	0005      	movs	r5, r0
        return AT_RET_MEMORY_ERROR;
    e4e6:	2004      	movs	r0, #4
    if(auc_rsp_data == NULL)
    e4e8:	2d00      	cmp	r5, #0
    e4ea:	d100      	bne.n	e4ee <at_handle_CGDCONT_cmd_read+0x22>
    e4ec:	e0c7      	b.n	e67e <at_handle_CGDCONT_cmd_read+0x1b2>
    for(cid = 0; cid <= AT_MAX_CID; cid++)
    e4ee:	2300      	movs	r3, #0
    bool        first_flag = true;
    e4f0:	2401      	movs	r4, #1
    for(cid = 0; cid <= AT_MAX_CID; cid++)
    e4f2:	9305      	str	r3, [sp, #20]
        memset(context.apn, 0, NEUL_MAX_APN_SIZE);
    e4f4:	2100      	movs	r1, #0
    e4f6:	2265      	movs	r2, #101	; 0x65
    e4f8:	982d      	ldr	r0, [sp, #180]	; 0xb4
    e4fa:	f7f1 fef1 	bl	2e0 <memset>
        if(get_pdp_context(cid, &context) == NEUL_RET_OK)
    e4fe:	a92a      	add	r1, sp, #168	; 0xa8
    e500:	9805      	ldr	r0, [sp, #20]
    e502:	f00d ff21 	bl	1c348 <get_pdp_context>
    e506:	2800      	cmp	r0, #0
    e508:	d000      	beq.n	e50c <at_handle_CGDCONT_cmd_read+0x40>
    e50a:	e0a9      	b.n	e660 <at_handle_CGDCONT_cmd_read+0x194>
            if(first_flag)  //first reply need add "\r\n"
    e50c:	2c00      	cmp	r4, #0
    e50e:	d009      	beq.n	e524 <at_handle_CGDCONT_cmd_read+0x58>
                at_uart_claim();
    e510:	f7fb fa4a 	bl	99a8 <at_uart_claim>
                at_uart_write((uint8*)APP_AT_STR_RN, strlen(APP_AT_STR_RN));
    e514:	4c5b      	ldr	r4, [pc, #364]	; (e684 <at_handle_CGDCONT_cmd_read+0x1b8>)
    e516:	0020      	movs	r0, r4
    e518:	f00c ff41 	bl	1b39e <strlen>
    e51c:	0001      	movs	r1, r0
    e51e:	0020      	movs	r0, r4
    e520:	f7fb fa64 	bl	99ec <at_uart_write>
            uc_len = (uint16)snprintf(auc_rsp_data, AT_MAX_RSP_LEN, "+CGDCONT:");
    e524:	4a58      	ldr	r2, [pc, #352]	; (e688 <at_handle_CGDCONT_cmd_read+0x1bc>)
    e526:	21c8      	movs	r1, #200	; 0xc8
    e528:	0028      	movs	r0, r5
    e52a:	f00c f99f 	bl	1a86c <snprintf>
            uc_len += (uint16)snprintf(auc_rsp_data + uc_len, AT_MAX_RSP_LEN - uc_len, "%d", context.cid);
    e52e:	27c8      	movs	r7, #200	; 0xc8
            uc_len = (uint16)snprintf(auc_rsp_data, AT_MAX_RSP_LEN, "+CGDCONT:");
    e530:	b284      	uxth	r4, r0
            uc_len += (uint16)snprintf(auc_rsp_data + uc_len, AT_MAX_RSP_LEN - uc_len, "%d", context.cid);
    e532:	ae2a      	add	r6, sp, #168	; 0xa8
    e534:	1b39      	subs	r1, r7, r4
    e536:	7873      	ldrb	r3, [r6, #1]
    e538:	1928      	adds	r0, r5, r4
    e53a:	4a54      	ldr	r2, [pc, #336]	; (e68c <at_handle_CGDCONT_cmd_read+0x1c0>)
    e53c:	f00c f996 	bl	1a86c <snprintf>
            if(context.pdp_type == PDN_TYPE_IPV6)
    e540:	7933      	ldrb	r3, [r6, #4]
            uc_len += (uint16)snprintf(auc_rsp_data + uc_len, AT_MAX_RSP_LEN - uc_len, "%d", context.cid);
    e542:	1824      	adds	r4, r4, r0
    e544:	b2a4      	uxth	r4, r4
    e546:	1928      	adds	r0, r5, r4
    e548:	1b39      	subs	r1, r7, r4
                uc_len += (uint16)snprintf(auc_rsp_data + uc_len, AT_MAX_RSP_LEN - uc_len, ",\"IPV6\",");
    e54a:	4a51      	ldr	r2, [pc, #324]	; (e690 <at_handle_CGDCONT_cmd_read+0x1c4>)
            if(context.pdp_type == PDN_TYPE_IPV6)
    e54c:	2b02      	cmp	r3, #2
    e54e:	d006      	beq.n	e55e <at_handle_CGDCONT_cmd_read+0x92>
                uc_len += (uint16)snprintf(auc_rsp_data + uc_len, AT_MAX_RSP_LEN - uc_len, ",\"IPV4V6\",");
    e550:	4a50      	ldr	r2, [pc, #320]	; (e694 <at_handle_CGDCONT_cmd_read+0x1c8>)
            else if(context.pdp_type == PDN_TYPE_IPV4V6)
    e552:	2b03      	cmp	r3, #3
    e554:	d003      	beq.n	e55e <at_handle_CGDCONT_cmd_read+0x92>
                uc_len += (uint16)snprintf(auc_rsp_data + uc_len, AT_MAX_RSP_LEN - uc_len, ",\"NONIP\",");
    e556:	4a50      	ldr	r2, [pc, #320]	; (e698 <at_handle_CGDCONT_cmd_read+0x1cc>)
            else if(context.pdp_type == PDN_TYPE_NON_IP)
    e558:	2b05      	cmp	r3, #5
    e55a:	d000      	beq.n	e55e <at_handle_CGDCONT_cmd_read+0x92>
                uc_len += (uint16)snprintf(auc_rsp_data + uc_len, AT_MAX_RSP_LEN - uc_len, ",\"IP\",");
    e55c:	4a4f      	ldr	r2, [pc, #316]	; (e69c <at_handle_CGDCONT_cmd_read+0x1d0>)
    e55e:	f00c f985 	bl	1a86c <snprintf>
    e562:	1824      	adds	r4, r4, r0
            if(at_strlen(context.apn) != 0)
    e564:	68f0      	ldr	r0, [r6, #12]
                uc_len += (uint16)snprintf(auc_rsp_data + uc_len, AT_MAX_RSP_LEN - uc_len, ",\"IP\",");
    e566:	b2a4      	uxth	r4, r4
            if(at_strlen(context.apn) != 0)
    e568:	f00c ff19 	bl	1b39e <strlen>
    e56c:	2800      	cmp	r0, #0
    e56e:	d007      	beq.n	e580 <at_handle_CGDCONT_cmd_read+0xb4>
                uc_len += (uint16)snprintf(auc_rsp_data + uc_len, AT_MAX_RSP_LEN - uc_len, "\"");   //left quotes around APN
    e570:	21c8      	movs	r1, #200	; 0xc8
    e572:	1928      	adds	r0, r5, r4
    e574:	1b09      	subs	r1, r1, r4
    e576:	4a4a      	ldr	r2, [pc, #296]	; (e6a0 <at_handle_CGDCONT_cmd_read+0x1d4>)
    e578:	f00c f978 	bl	1a86c <snprintf>
    e57c:	1824      	adds	r4, r4, r0
    e57e:	b2a4      	uxth	r4, r4
        *(operator_indentifier_upper + loop) = (uint8)toupper( *(apn_context + loop));//lint !e1058
    e580:	2600      	movs	r6, #0
            while(*(context.apn + uc_count) != 0)
    e582:	9b2d      	ldr	r3, [sp, #180]	; 0xb4
    e584:	199b      	adds	r3, r3, r6
    e586:	781f      	ldrb	r7, [r3, #0]
    e588:	9306      	str	r3, [sp, #24]
    e58a:	2f00      	cmp	r7, #0
    e58c:	d049      	beq.n	e622 <at_handle_CGDCONT_cmd_read+0x156>
                uc_piece_data_len = *(context.apn + uc_count);
    e58e:	b2bb      	uxth	r3, r7
    e590:	9309      	str	r3, [sp, #36]	; 0x24
    uint8  operator_indentifier_upper[(AT_APN_OPERATOR_IDENTIFIER_MNC_MCC_LEN + 1)*2 + AT_APN_OPERATOR_IDENTIFIER_GPRS_STR_LEN + 1] = {0};
    e592:	2100      	movs	r1, #0
                is_operator_identifier_flag = is_operator_identifier(context.apn + uc_count + 1);
    e594:	1c73      	adds	r3, r6, #1
    uint8  operator_indentifier_upper[(AT_APN_OPERATOR_IDENTIFIER_MNC_MCC_LEN + 1)*2 + AT_APN_OPERATOR_IDENTIFIER_GPRS_STR_LEN + 1] = {0};
    e596:	2213      	movs	r2, #19
    e598:	a80b      	add	r0, sp, #44	; 0x2c
                is_operator_identifier_flag = is_operator_identifier(context.apn + uc_count + 1);
    e59a:	9308      	str	r3, [sp, #32]
    uint8  operator_indentifier_upper[(AT_APN_OPERATOR_IDENTIFIER_MNC_MCC_LEN + 1)*2 + AT_APN_OPERATOR_IDENTIFIER_GPRS_STR_LEN + 1] = {0};
    e59c:	f7f1 fea0 	bl	2e0 <memset>
        *(operator_indentifier_upper + loop) = (uint8)toupper( *(apn_context + loop));//lint !e1058
    e5a0:	4b40      	ldr	r3, [pc, #256]	; (e6a4 <at_handle_CGDCONT_cmd_read+0x1d8>)
    e5a2:	a90b      	add	r1, sp, #44	; 0x2c
    e5a4:	681b      	ldr	r3, [r3, #0]
    e5a6:	9107      	str	r1, [sp, #28]
    e5a8:	469c      	mov	ip, r3
    e5aa:	2300      	movs	r3, #0
    e5ac:	4660      	mov	r0, ip
    e5ae:	2103      	movs	r1, #3
    e5b0:	9a06      	ldr	r2, [sp, #24]
    e5b2:	18d2      	adds	r2, r2, r3
    e5b4:	7852      	ldrb	r2, [r2, #1]
    e5b6:	1880      	adds	r0, r0, r2
    e5b8:	7840      	ldrb	r0, [r0, #1]
    e5ba:	4008      	ands	r0, r1
    e5bc:	2802      	cmp	r0, #2
    e5be:	d100      	bne.n	e5c2 <at_handle_CGDCONT_cmd_read+0xf6>
    e5c0:	3a20      	subs	r2, #32
    e5c2:	9907      	ldr	r1, [sp, #28]
    e5c4:	545a      	strb	r2, [r3, r1]
    e5c6:	3301      	adds	r3, #1
    for(uint8 loop = 0; loop < AT_APN_OPERATOR_IDENTIFIER_MNC_MCC_LEN *2 + 1 + AT_APN_OPERATOR_IDENTIFIER_GPRS_STR_LEN + 1; loop++)
    e5c8:	2b12      	cmp	r3, #18
    e5ca:	d1ef      	bne.n	e5ac <at_handle_CGDCONT_cmd_read+0xe0>
    if ((strncmp(AT_APN_OPERATOR_IDENTIFIER_MNC_STR, operator_indentifier_upper_ptr, AT_APN_OPERATOR_IDENTIFIER_MNC_MCC_STR_LEN) == 0)
    e5cc:	2203      	movs	r2, #3
    e5ce:	4836      	ldr	r0, [pc, #216]	; (e6a8 <at_handle_CGDCONT_cmd_read+0x1dc>)
    e5d0:	f00c fef1 	bl	1b3b6 <strncmp>
    e5d4:	2800      	cmp	r0, #0
    e5d6:	d012      	beq.n	e5fe <at_handle_CGDCONT_cmd_read+0x132>
                uc_len += (uint16)snprintf(auc_rsp_data + uc_len,  AT_MAX_RSP_LEN - uc_len, "%.*s.", uc_piece_data_len, context.apn + uc_count + 1);
    e5d8:	9a2d      	ldr	r2, [sp, #180]	; 0xb4
    e5da:	23c8      	movs	r3, #200	; 0xc8
    e5dc:	4694      	mov	ip, r2
    e5de:	1b19      	subs	r1, r3, r4
    e5e0:	9b08      	ldr	r3, [sp, #32]
    e5e2:	1928      	adds	r0, r5, r4
    e5e4:	4463      	add	r3, ip
    e5e6:	9300      	str	r3, [sp, #0]
    e5e8:	4a30      	ldr	r2, [pc, #192]	; (e6ac <at_handle_CGDCONT_cmd_read+0x1e0>)
    e5ea:	003b      	movs	r3, r7
    e5ec:	f00c f93e 	bl	1a86c <snprintf>
                uc_count += (uc_piece_data_len + 1);
    e5f0:	9b09      	ldr	r3, [sp, #36]	; 0x24
                uc_len += (uint16)snprintf(auc_rsp_data + uc_len,  AT_MAX_RSP_LEN - uc_len, "%.*s.", uc_piece_data_len, context.apn + uc_count + 1);
    e5f2:	1824      	adds	r4, r4, r0
                uc_count += (uc_piece_data_len + 1);
    e5f4:	3301      	adds	r3, #1
    e5f6:	18f6      	adds	r6, r6, r3
                uc_len += (uint16)snprintf(auc_rsp_data + uc_len,  AT_MAX_RSP_LEN - uc_len, "%.*s.", uc_piece_data_len, context.apn + uc_count + 1);
    e5f8:	b2a4      	uxth	r4, r4
                uc_count += (uc_piece_data_len + 1);
    e5fa:	b2b6      	uxth	r6, r6
    e5fc:	e7c1      	b.n	e582 <at_handle_CGDCONT_cmd_read+0xb6>
    && (strncmp(AT_APN_OPERATOR_IDENTIFIER_MCC_STR, operator_indentifier_upper_ptr + AT_APN_OPERATOR_IDENTIFIER_MNC_MCC_LEN + 1, AT_APN_OPERATOR_IDENTIFIER_MNC_MCC_STR_LEN) == 0)
    e5fe:	211b      	movs	r1, #27
    e600:	ab06      	add	r3, sp, #24
    e602:	2203      	movs	r2, #3
    e604:	18c9      	adds	r1, r1, r3
    e606:	482a      	ldr	r0, [pc, #168]	; (e6b0 <at_handle_CGDCONT_cmd_read+0x1e4>)
    e608:	f00c fed5 	bl	1b3b6 <strncmp>
    e60c:	2800      	cmp	r0, #0
    e60e:	d1e3      	bne.n	e5d8 <at_handle_CGDCONT_cmd_read+0x10c>
    && (strncmp(AT_APN_OPERATOR_IDENTIFIER_GPRS_STR, operator_indentifier_upper_ptr + (AT_APN_OPERATOR_IDENTIFIER_MNC_MCC_LEN + 1)*2, AT_APN_OPERATOR_IDENTIFIER_GPRS_STR_LEN) == 0))
    e610:	2122      	movs	r1, #34	; 0x22
    e612:	ab06      	add	r3, sp, #24
    e614:	2204      	movs	r2, #4
    e616:	18c9      	adds	r1, r1, r3
    e618:	4826      	ldr	r0, [pc, #152]	; (e6b4 <at_handle_CGDCONT_cmd_read+0x1e8>)
    e61a:	f00c fecc 	bl	1b3b6 <strncmp>
    e61e:	2800      	cmp	r0, #0
    e620:	d1da      	bne.n	e5d8 <at_handle_CGDCONT_cmd_read+0x10c>
            if (uc_count > 0)
    e622:	2e00      	cmp	r6, #0
    e624:	d009      	beq.n	e63a <at_handle_CGDCONT_cmd_read+0x16e>
                uc_len += (uint16)snprintf(auc_rsp_data + uc_len, AT_MAX_RSP_LEN - uc_len, "\"");   //right quotes around APN
    e626:	21c8      	movs	r1, #200	; 0xc8
                uc_len = uc_len - 1;          //Remove the '.'
    e628:	3c01      	subs	r4, #1
    e62a:	b2a4      	uxth	r4, r4
                uc_len += (uint16)snprintf(auc_rsp_data + uc_len, AT_MAX_RSP_LEN - uc_len, "\"");   //right quotes around APN
    e62c:	1b09      	subs	r1, r1, r4
    e62e:	1928      	adds	r0, r5, r4
    e630:	4a1b      	ldr	r2, [pc, #108]	; (e6a0 <at_handle_CGDCONT_cmd_read+0x1d4>)
    e632:	f00c f91b 	bl	1a86c <snprintf>
    e636:	1824      	adds	r4, r4, r0
    e638:	b2a4      	uxth	r4, r4
            uc_len += (uint16)snprintf(auc_rsp_data + uc_len,  AT_MAX_RSP_LEN - uc_len, ",,%d,%d,,,,,%d,%d", context.d_comp, context.h_comp, context.nslpi, context.secure_pco);
    e63a:	21c8      	movs	r1, #200	; 0xc8
    e63c:	aa2a      	add	r2, sp, #168	; 0xa8
    e63e:	1b09      	subs	r1, r1, r4
    e640:	1928      	adds	r0, r5, r4
    e642:	7a14      	ldrb	r4, [r2, #8]
    e644:	7893      	ldrb	r3, [r2, #2]
    e646:	9402      	str	r4, [sp, #8]
    e648:	79d4      	ldrb	r4, [r2, #7]
    e64a:	9401      	str	r4, [sp, #4]
    e64c:	78d2      	ldrb	r2, [r2, #3]
            app_at_send_at_rsp_string_rn_no_claim(auc_rsp_data, AT_FLAG_LOGABLE | AT_FLAG_LOG_RESTRICTED);
    e64e:	2400      	movs	r4, #0
            uc_len += (uint16)snprintf(auc_rsp_data + uc_len,  AT_MAX_RSP_LEN - uc_len, ",,%d,%d,,,,,%d,%d", context.d_comp, context.h_comp, context.nslpi, context.secure_pco);
    e650:	9200      	str	r2, [sp, #0]
    e652:	4a19      	ldr	r2, [pc, #100]	; (e6b8 <at_handle_CGDCONT_cmd_read+0x1ec>)
    e654:	f00c f90a 	bl	1a86c <snprintf>
            app_at_send_at_rsp_string_rn_no_claim(auc_rsp_data, AT_FLAG_LOGABLE | AT_FLAG_LOG_RESTRICTED);
    e658:	2128      	movs	r1, #40	; 0x28
    e65a:	0028      	movs	r0, r5
    e65c:	f7fa ffd0 	bl	9600 <app_at_send_at_rsp_string_rn_no_claim>
    for(cid = 0; cid <= AT_MAX_CID; cid++)
    e660:	9b05      	ldr	r3, [sp, #20]
    e662:	3301      	adds	r3, #1
    e664:	b2db      	uxtb	r3, r3
    e666:	9305      	str	r3, [sp, #20]
    e668:	2b0b      	cmp	r3, #11
    e66a:	d000      	beq.n	e66e <at_handle_CGDCONT_cmd_read+0x1a2>
    e66c:	e742      	b.n	e4f4 <at_handle_CGDCONT_cmd_read+0x28>
    if (!first_flag)
    e66e:	2c00      	cmp	r4, #0
    e670:	d101      	bne.n	e676 <at_handle_CGDCONT_cmd_read+0x1aa>
        at_uart_release();
    e672:	f7fb f9ab 	bl	99cc <at_uart_release>
    irfree(auc_rsp_data);
    e676:	0028      	movs	r0, r5
    e678:	f004 f9de 	bl	12a38 <irfree>
    return AT_RET_OK;
    e67c:	2000      	movs	r0, #0
}
    e67e:	b049      	add	sp, #292	; 0x124
    e680:	bdf0      	pop	{r4, r5, r6, r7, pc}
    e682:	46c0      	nop			; (mov r8, r8)
    e684:	00022d8f 	.word	0x00022d8f
    e688:	00023712 	.word	0x00023712
    e68c:	00022e8f 	.word	0x00022e8f
    e690:	00024885 	.word	0x00024885
    e694:	0002488e 	.word	0x0002488e
    e698:	00024899 	.word	0x00024899
    e69c:	0002487e 	.word	0x0002487e
    e6a0:	00024bc5 	.word	0x00024bc5
    e6a4:	010005dc 	.word	0x010005dc
    e6a8:	0002371c 	.word	0x0002371c
    e6ac:	000234f5 	.word	0x000234f5
    e6b0:	00023720 	.word	0x00023720
    e6b4:	00023724 	.word	0x00023724
    e6b8:	00023729 	.word	0x00023729

0000e6bc <at_handle_CGDCONT_cmd_set>:
{
    e6bc:	b5f0      	push	{r4, r5, r6, r7, lr}
    e6be:	b0b7      	sub	sp, #220	; 0xdc
    uint16            cid,d_comp = 0,h_comp = 0,emergency,secure_pco = 0;
    e6c0:	2600      	movs	r6, #0
    e6c2:	466b      	mov	r3, sp
    uint16            nslpi = NEUL_NSLPI_UNDEFINED;
    e6c4:	466a      	mov	r2, sp
    uint16            cid,d_comp = 0,h_comp = 0,emergency,secure_pco = 0;
    e6c6:	819e      	strh	r6, [r3, #12]
    e6c8:	270a      	movs	r7, #10
    uint16            nslpi = NEUL_NSLPI_UNDEFINED;
    e6ca:	23ff      	movs	r3, #255	; 0xff
{
    e6cc:	0004      	movs	r4, r0
    uint16            nslpi = NEUL_NSLPI_UNDEFINED;
    e6ce:	81d3      	strh	r3, [r2, #14]
    uint8             pdp_type_str[AT_MAX_PDP_TYPE_SIZE] = {0};
    e6d0:	0031      	movs	r1, r6
    e6d2:	2210      	movs	r2, #16
    uint16            cid,d_comp = 0,h_comp = 0,emergency,secure_pco = 0;
    e6d4:	ad02      	add	r5, sp, #8
    e6d6:	446f      	add	r7, sp
    uint8             pdp_type_str[AT_MAX_PDP_TYPE_SIZE] = {0};
    e6d8:	a804      	add	r0, sp, #16
    uint16            cid,d_comp = 0,h_comp = 0,emergency,secure_pco = 0;
    e6da:	802e      	strh	r6, [r5, #0]
    e6dc:	803e      	strh	r6, [r7, #0]
    uint8             pdp_type_str[AT_MAX_PDP_TYPE_SIZE] = {0};
    e6de:	f7f1 fdff 	bl	2e0 <memset>
    uint8             apn_str[MAX_APN_SET_SIZE] = {0};
    e6e2:	0031      	movs	r1, r6
    e6e4:	2240      	movs	r2, #64	; 0x40
    e6e6:	a808      	add	r0, sp, #32
    e6e8:	f7f1 fdfa 	bl	2e0 <memset>
    cause = at_create_param_array(p_atparams_string, &num_recvparams, 1, AT_CMD_MXA_CGDCONT_PARAMETES);
    e6ec:	466b      	mov	r3, sp
    e6ee:	1d5e      	adds	r6, r3, #5
    e6f0:	0020      	movs	r0, r4
    e6f2:	230c      	movs	r3, #12
    e6f4:	2201      	movs	r2, #1
    e6f6:	0031      	movs	r1, r6
    e6f8:	f7fb fdf4 	bl	a2e4 <at_create_param_array>
    e6fc:	1e04      	subs	r4, r0, #0
    if(cause != AT_RET_OK)
    e6fe:	d107      	bne.n	e710 <at_handle_CGDCONT_cmd_set+0x54>
    cause = at_get_uint16_param(AT_PARSE_FIRST_PARAM_POS, &cid, true);
    e700:	466b      	mov	r3, sp
    e702:	2201      	movs	r2, #1
    e704:	1d99      	adds	r1, r3, #6
    e706:	f7fb ff01 	bl	a50c <at_get_uint16_param>
    e70a:	1e04      	subs	r4, r0, #0
    if(cause != AT_RET_OK)
    e70c:	d003      	beq.n	e716 <at_handle_CGDCONT_cmd_set+0x5a>
        return AT_RET_SYNTAX_ERROR;
    e70e:	2401      	movs	r4, #1
}
    e710:	0020      	movs	r0, r4
    e712:	b037      	add	sp, #220	; 0xdc
    e714:	bdf0      	pop	{r4, r5, r6, r7, pc}
    else if (cid > AT_MAX_CID)
    e716:	466b      	mov	r3, sp
    e718:	88d8      	ldrh	r0, [r3, #6]
    e71a:	280a      	cmp	r0, #10
    e71c:	d900      	bls.n	e720 <at_handle_CGDCONT_cmd_set+0x64>
    e71e:	e0ba      	b.n	e896 <at_handle_CGDCONT_cmd_set+0x1da>
    else if(num_recvparams == 1)
    e720:	7833      	ldrb	r3, [r6, #0]
    e722:	2b01      	cmp	r3, #1
    e724:	d105      	bne.n	e732 <at_handle_CGDCONT_cmd_set+0x76>
        neul_result = delete_pdp_context(cid);
    e726:	f00d fdd6 	bl	1c2d6 <delete_pdp_context>
        if (neul_result == NEUL_RET_ERROR)
    e72a:	2801      	cmp	r0, #1
    e72c:	d1f0      	bne.n	e710 <at_handle_CGDCONT_cmd_set+0x54>
            return AT_RET_PROGRESS_ERROR;
    e72e:	2406      	movs	r4, #6
    e730:	e7ee      	b.n	e710 <at_handle_CGDCONT_cmd_set+0x54>
    if (num_recvparams > 1)
    e732:	2b01      	cmp	r3, #1
    e734:	d84c      	bhi.n	e7d0 <at_handle_CGDCONT_cmd_set+0x114>
    NEUL_PDN_TYPE     pdp_type = PDN_TYPE_IPV4V6;
    e736:	2603      	movs	r6, #3
    if (num_recvparams > 2)
    e738:	466b      	mov	r3, sp
    e73a:	3305      	adds	r3, #5
    e73c:	781b      	ldrb	r3, [r3, #0]
    e73e:	2b02      	cmp	r3, #2
    e740:	d871      	bhi.n	e826 <at_handle_CGDCONT_cmd_set+0x16a>
    if (num_recvparams > 4)
    e742:	466b      	mov	r3, sp
    e744:	3305      	adds	r3, #5
    e746:	781b      	ldrb	r3, [r3, #0]
    e748:	2b04      	cmp	r3, #4
    e74a:	d90d      	bls.n	e768 <at_handle_CGDCONT_cmd_set+0xac>
        cause = at_get_uint16_param(AT_PARSE_FIFTH_PARAM_POS, &d_comp, false);
    e74c:	2200      	movs	r2, #0
    e74e:	0029      	movs	r1, r5
    e750:	2004      	movs	r0, #4
    e752:	f7fb fedb 	bl	a50c <at_get_uint16_param>
        if((cause == AT_RET_OK) && ((d_comp == AT_UINT16_NO_VALUE) || (d_comp == AT_DATA_COMPRESSION_OFF)))
    e756:	2800      	cmp	r0, #0
    e758:	d1d9      	bne.n	e70e <at_handle_CGDCONT_cmd_set+0x52>
    e75a:	882b      	ldrh	r3, [r5, #0]
    e75c:	4a4f      	ldr	r2, [pc, #316]	; (e89c <at_handle_CGDCONT_cmd_set+0x1e0>)
    e75e:	3b01      	subs	r3, #1
    e760:	b29b      	uxth	r3, r3
    e762:	4293      	cmp	r3, r2
    e764:	d9d3      	bls.n	e70e <at_handle_CGDCONT_cmd_set+0x52>
            d_comp = AT_DATA_COMPRESSION_OFF;
    e766:	8028      	strh	r0, [r5, #0]
    if (num_recvparams > 5)
    e768:	466b      	mov	r3, sp
    e76a:	3305      	adds	r3, #5
    e76c:	781b      	ldrb	r3, [r3, #0]
    e76e:	2b05      	cmp	r3, #5
    e770:	d86c      	bhi.n	e84c <at_handle_CGDCONT_cmd_set+0x190>
    if (num_recvparams > 10)
    e772:	466b      	mov	r3, sp
    e774:	3305      	adds	r3, #5
    e776:	781b      	ldrb	r3, [r3, #0]
    e778:	2b0a      	cmp	r3, #10
    e77a:	d90a      	bls.n	e792 <at_handle_CGDCONT_cmd_set+0xd6>
        cause = at_get_uint16_param(AT_PARSE_ELEVENTH_PARAM_POS, &nslpi, true);
    e77c:	230e      	movs	r3, #14
    e77e:	446b      	add	r3, sp
    e780:	2201      	movs	r2, #1
    e782:	0019      	movs	r1, r3
    e784:	200a      	movs	r0, #10
    e786:	f7fb fec1 	bl	a50c <at_get_uint16_param>
        if ((cause != AT_RET_OK) && (cause != AT_RET_PARAM_MISSING))
    e78a:	2800      	cmp	r0, #0
    e78c:	d06d      	beq.n	e86a <at_handle_CGDCONT_cmd_set+0x1ae>
    e78e:	2803      	cmp	r0, #3
    e790:	d1bd      	bne.n	e70e <at_handle_CGDCONT_cmd_set+0x52>
    if (num_recvparams > 11)
    e792:	466b      	mov	r3, sp
    e794:	3305      	adds	r3, #5
    e796:	781b      	ldrb	r3, [r3, #0]
    e798:	2b0b      	cmp	r3, #11
    e79a:	d86c      	bhi.n	e876 <at_handle_CGDCONT_cmd_set+0x1ba>
    context.cid = (uint8)cid;
    e79c:	466b      	mov	r3, sp
    e79e:	88db      	ldrh	r3, [r3, #6]
    e7a0:	a818      	add	r0, sp, #96	; 0x60
    e7a2:	7043      	strb	r3, [r0, #1]
    context.d_comp = (uint8)d_comp;
    e7a4:	882b      	ldrh	r3, [r5, #0]
    context.pdp_type = pdp_type;
    e7a6:	7106      	strb	r6, [r0, #4]
    context.d_comp = (uint8)d_comp;
    e7a8:	7083      	strb	r3, [r0, #2]
    context.h_comp = (uint8)h_comp;
    e7aa:	883b      	ldrh	r3, [r7, #0]
    e7ac:	70c3      	strb	r3, [r0, #3]
    context.emergency = (emergency == 1);
    e7ae:	2300      	movs	r3, #0
    e7b0:	7143      	strb	r3, [r0, #5]
    context.addr_alloc = 0;     //IPv4AddrAlloc should have been passed to us via the AT command
    e7b2:	7183      	strb	r3, [r0, #6]
    context.nslpi = (uint8)nslpi;          //NSLIP should have been passed to us via the AT command (the 1 here was copied from at_cmd_cb.c)
    e7b4:	466b      	mov	r3, sp
    e7b6:	89db      	ldrh	r3, [r3, #14]
    e7b8:	71c3      	strb	r3, [r0, #7]
    context.secure_pco = (uint8)secure_pco;     //secure_pco should have been passed to us via the AT command
    e7ba:	466b      	mov	r3, sp
    e7bc:	899b      	ldrh	r3, [r3, #12]
    e7be:	7203      	strb	r3, [r0, #8]
    context.apn = apn_str;
    e7c0:	ab08      	add	r3, sp, #32
    e7c2:	60c3      	str	r3, [r0, #12]
    neul_result = activate_pdp_context(&context);
    e7c4:	f00d fd98 	bl	1c2f8 <activate_pdp_context>
    return  at_parse_convert_neul_result(neul_result);
    e7c8:	f7fb fd62 	bl	a290 <at_parse_convert_neul_result>
    e7cc:	0004      	movs	r4, r0
    e7ce:	e79f      	b.n	e710 <at_handle_CGDCONT_cmd_set+0x54>
        cause = at_get_string_param(AT_PARSE_SECOND_PARAM_POS, pdp_type_str, AT_MAX_PDP_TYPE_SIZE, false);
    e7d0:	0023      	movs	r3, r4
    e7d2:	2210      	movs	r2, #16
    e7d4:	a904      	add	r1, sp, #16
    e7d6:	2001      	movs	r0, #1
    e7d8:	f7fb ffd6 	bl	a788 <at_get_string_param>
    e7dc:	1e04      	subs	r4, r0, #0
        if(cause != AT_RET_OK)
    e7de:	d000      	beq.n	e7e2 <at_handle_CGDCONT_cmd_set+0x126>
    e7e0:	e796      	b.n	e710 <at_handle_CGDCONT_cmd_set+0x54>
        if (!at_is_param_in_double_quotes(AT_PARSE_SECOND_PARAM_POS))
    e7e2:	2001      	movs	r0, #1
    e7e4:	f7fc f87e 	bl	a8e4 <at_is_param_in_double_quotes>
    e7e8:	2800      	cmp	r0, #0
    e7ea:	d100      	bne.n	e7ee <at_handle_CGDCONT_cmd_set+0x132>
    e7ec:	e78f      	b.n	e70e <at_handle_CGDCONT_cmd_set+0x52>
        if (!strcmp((char*)pdp_type_str, "NONIP"))
    e7ee:	492c      	ldr	r1, [pc, #176]	; (e8a0 <at_handle_CGDCONT_cmd_set+0x1e4>)
    e7f0:	a804      	add	r0, sp, #16
    e7f2:	f00c fdb5 	bl	1b360 <strcmp>
            pdp_type = PDN_TYPE_NON_IP;
    e7f6:	2605      	movs	r6, #5
        if (!strcmp((char*)pdp_type_str, "NONIP"))
    e7f8:	2800      	cmp	r0, #0
    e7fa:	d09d      	beq.n	e738 <at_handle_CGDCONT_cmd_set+0x7c>
        else if (!strcmp((char*)pdp_type_str, "IP"))
    e7fc:	4929      	ldr	r1, [pc, #164]	; (e8a4 <at_handle_CGDCONT_cmd_set+0x1e8>)
    e7fe:	a804      	add	r0, sp, #16
    e800:	f00c fdae 	bl	1b360 <strcmp>
            pdp_type = PDN_TYPE_IPV4;
    e804:	3e04      	subs	r6, #4
        else if (!strcmp((char*)pdp_type_str, "IP"))
    e806:	2800      	cmp	r0, #0
    e808:	d096      	beq.n	e738 <at_handle_CGDCONT_cmd_set+0x7c>
        else if (!strcmp((char*)pdp_type_str, "IPV6"))
    e80a:	4927      	ldr	r1, [pc, #156]	; (e8a8 <at_handle_CGDCONT_cmd_set+0x1ec>)
    e80c:	a804      	add	r0, sp, #16
    e80e:	f00c fda7 	bl	1b360 <strcmp>
            pdp_type = PDN_TYPE_IPV6;
    e812:	3601      	adds	r6, #1
        else if (!strcmp((char*)pdp_type_str, "IPV6"))
    e814:	2800      	cmp	r0, #0
    e816:	d08f      	beq.n	e738 <at_handle_CGDCONT_cmd_set+0x7c>
        else if (!strcmp((char*)pdp_type_str, "IPV4V6"))
    e818:	4924      	ldr	r1, [pc, #144]	; (e8ac <at_handle_CGDCONT_cmd_set+0x1f0>)
    e81a:	a804      	add	r0, sp, #16
    e81c:	f00c fda0 	bl	1b360 <strcmp>
    e820:	2800      	cmp	r0, #0
    e822:	d088      	beq.n	e736 <at_handle_CGDCONT_cmd_set+0x7a>
    e824:	e773      	b.n	e70e <at_handle_CGDCONT_cmd_set+0x52>
        cause = at_get_string_param(AT_PARSE_THIRD_PARAM_POS, apn_str, MAX_APN_SET_SIZE, true);
    e826:	2301      	movs	r3, #1
    e828:	2240      	movs	r2, #64	; 0x40
    e82a:	a908      	add	r1, sp, #32
    e82c:	2002      	movs	r0, #2
    e82e:	f7fb ffab 	bl	a788 <at_get_string_param>
    e832:	1e04      	subs	r4, r0, #0
        if (cause == AT_RET_OK)
    e834:	d106      	bne.n	e844 <at_handle_CGDCONT_cmd_set+0x188>
           if (!at_is_param_in_double_quotes(AT_PARSE_THIRD_PARAM_POS))
    e836:	2002      	movs	r0, #2
    e838:	f7fc f854 	bl	a8e4 <at_is_param_in_double_quotes>
    e83c:	2800      	cmp	r0, #0
    e83e:	d000      	beq.n	e842 <at_handle_CGDCONT_cmd_set+0x186>
    e840:	e77f      	b.n	e742 <at_handle_CGDCONT_cmd_set+0x86>
    e842:	e764      	b.n	e70e <at_handle_CGDCONT_cmd_set+0x52>
        else if(cause != AT_RET_PARAM_MISSING)
    e844:	2803      	cmp	r0, #3
    e846:	d000      	beq.n	e84a <at_handle_CGDCONT_cmd_set+0x18e>
    e848:	e762      	b.n	e710 <at_handle_CGDCONT_cmd_set+0x54>
    e84a:	e77a      	b.n	e742 <at_handle_CGDCONT_cmd_set+0x86>
        cause = at_get_uint16_param(AT_PARSE_SIXTH_PARAM_POS, &h_comp, true);
    e84c:	2201      	movs	r2, #1
    e84e:	0039      	movs	r1, r7
    e850:	2005      	movs	r0, #5
    e852:	f7fb fe5b 	bl	a50c <at_get_uint16_param>
        if(cause != AT_RET_OK && cause != AT_RET_PARAM_MISSING)
    e856:	2800      	cmp	r0, #0
    e858:	d002      	beq.n	e860 <at_handle_CGDCONT_cmd_set+0x1a4>
    e85a:	2803      	cmp	r0, #3
    e85c:	d000      	beq.n	e860 <at_handle_CGDCONT_cmd_set+0x1a4>
    e85e:	e756      	b.n	e70e <at_handle_CGDCONT_cmd_set+0x52>
        if (h_comp > AT_HEADER_COMPRESSION_RFC3095)
    e860:	883b      	ldrh	r3, [r7, #0]
    e862:	2b03      	cmp	r3, #3
    e864:	d800      	bhi.n	e868 <at_handle_CGDCONT_cmd_set+0x1ac>
    e866:	e784      	b.n	e772 <at_handle_CGDCONT_cmd_set+0xb6>
    e868:	e751      	b.n	e70e <at_handle_CGDCONT_cmd_set+0x52>
        if ((cause == AT_RET_OK) && (nslpi > 1))
    e86a:	466b      	mov	r3, sp
    e86c:	89db      	ldrh	r3, [r3, #14]
    e86e:	2b01      	cmp	r3, #1
    e870:	d900      	bls.n	e874 <at_handle_CGDCONT_cmd_set+0x1b8>
    e872:	e74c      	b.n	e70e <at_handle_CGDCONT_cmd_set+0x52>
    e874:	e78d      	b.n	e792 <at_handle_CGDCONT_cmd_set+0xd6>
        cause = at_get_uint16_param(AT_PARSE_TWELFTH_PARAM_POS, &secure_pco, true);
    e876:	2201      	movs	r2, #1
    e878:	a903      	add	r1, sp, #12
    e87a:	200b      	movs	r0, #11
    e87c:	f7fb fe46 	bl	a50c <at_get_uint16_param>
        if ((cause != AT_RET_OK) && (cause != AT_RET_PARAM_MISSING))
    e880:	2800      	cmp	r0, #0
    e882:	d002      	beq.n	e88a <at_handle_CGDCONT_cmd_set+0x1ce>
    e884:	2803      	cmp	r0, #3
    e886:	d000      	beq.n	e88a <at_handle_CGDCONT_cmd_set+0x1ce>
    e888:	e741      	b.n	e70e <at_handle_CGDCONT_cmd_set+0x52>
        if (secure_pco > 1)
    e88a:	466b      	mov	r3, sp
    e88c:	899b      	ldrh	r3, [r3, #12]
    e88e:	2b01      	cmp	r3, #1
    e890:	d900      	bls.n	e894 <at_handle_CGDCONT_cmd_set+0x1d8>
    e892:	e73c      	b.n	e70e <at_handle_CGDCONT_cmd_set+0x52>
    e894:	e782      	b.n	e79c <at_handle_CGDCONT_cmd_set+0xe0>
        return AT_RET_CID_INVALID;
    e896:	2411      	movs	r4, #17
    e898:	e73a      	b.n	e710 <at_handle_CGDCONT_cmd_set+0x54>
    e89a:	46c0      	nop			; (mov r8, r8)
    e89c:	0000fffd 	.word	0x0000fffd
    e8a0:	0002373b 	.word	0x0002373b
    e8a4:	00024efc 	.word	0x00024efc
    e8a8:	00023741 	.word	0x00023741
    e8ac:	00023746 	.word	0x00023746

0000e8b0 <at_handle_NSOCR_cmd_set>:
{
    e8b0:	b5f0      	push	{r4, r5, r6, r7, lr}
    uint16            protocol, port = 0;
    e8b2:	2500      	movs	r5, #0
    uint16            receive_control = RECEIVE_ENABLE;
    e8b4:	2712      	movs	r7, #18
    e8b6:	2401      	movs	r4, #1
{
    e8b8:	b0a5      	sub	sp, #148	; 0x94
    char              rsp_string[MAX_UINT32_CHARACTERS + 1] = {0};
    e8ba:	0029      	movs	r1, r5
{
    e8bc:	9003      	str	r0, [sp, #12]
    char              rsp_string[MAX_UINT32_CHARACTERS + 1] = {0};
    e8be:	220b      	movs	r2, #11
    uint16            protocol, port = 0;
    e8c0:	ae06      	add	r6, sp, #24
    char              rsp_string[MAX_UINT32_CHARACTERS + 1] = {0};
    e8c2:	a80c      	add	r0, sp, #48	; 0x30
    uint16            protocol, port = 0;
    e8c4:	8035      	strh	r5, [r6, #0]
    char              rsp_string[MAX_UINT32_CHARACTERS + 1] = {0};
    e8c6:	f7f1 fd0b 	bl	2e0 <memset>
    uint8             protocol_family[MAX_SOCKET_TYPE_LEN + 1] = {0};
    e8ca:	0029      	movs	r1, r5
    e8cc:	2207      	movs	r2, #7
    e8ce:	a807      	add	r0, sp, #28
    e8d0:	f7f1 fd06 	bl	2e0 <memset>
    uint8             ai_family_str[MAX_AI_FAMILY_STR_LEN + 1] = {0};
    e8d4:	0029      	movs	r1, r5
    e8d6:	2209      	movs	r2, #9
    e8d8:	a809      	add	r0, sp, #36	; 0x24
    e8da:	f7f1 fd01 	bl	2e0 <memset>
    uint16            receive_control = RECEIVE_ENABLE;
    e8de:	ab02      	add	r3, sp, #8
    e8e0:	18ff      	adds	r7, r7, r3
    char              ip_str[MAX_IP_LEN] = {0};
    e8e2:	0029      	movs	r1, r5
    e8e4:	223c      	movs	r2, #60	; 0x3c
    e8e6:	a815      	add	r0, sp, #84	; 0x54
    uint16            receive_control = RECEIVE_ENABLE;
    e8e8:	803c      	strh	r4, [r7, #0]
    char              ip_str[MAX_IP_LEN] = {0};
    e8ea:	f7f1 fcf9 	bl	2e0 <memset>
    cause = at_create_param_array(p_atparams_string, &num_recvparams, 2, 6);
    e8ee:	210d      	movs	r1, #13
    e8f0:	a802      	add	r0, sp, #8
    e8f2:	1809      	adds	r1, r1, r0
    e8f4:	2306      	movs	r3, #6
    e8f6:	2202      	movs	r2, #2
    e8f8:	9803      	ldr	r0, [sp, #12]
    e8fa:	f7fb fcf3 	bl	a2e4 <at_create_param_array>
    e8fe:	1e05      	subs	r5, r0, #0
    if(cause != AT_RET_OK)
    e900:	d107      	bne.n	e912 <at_handle_NSOCR_cmd_set+0x62>
    cause = at_get_string_param(AT_PARSE_FIRST_PARAM_POS, protocol_family, sizeof(protocol_family),true);
    e902:	0023      	movs	r3, r4
    e904:	2207      	movs	r2, #7
    e906:	a907      	add	r1, sp, #28
    e908:	f7fb ff3e 	bl	a788 <at_get_string_param>
    if((cause != AT_RET_OK) || (at_is_param_in_double_quotes(AT_PARSE_FIRST_PARAM_POS)))
    e90c:	2800      	cmp	r0, #0
    e90e:	d003      	beq.n	e918 <at_handle_NSOCR_cmd_set+0x68>
        return AT_RET_SYNTAX_ERROR;
    e910:	2501      	movs	r5, #1
}
    e912:	0028      	movs	r0, r5
    e914:	b025      	add	sp, #148	; 0x94
    e916:	bdf0      	pop	{r4, r5, r6, r7, pc}
    if((cause != AT_RET_OK) || (at_is_param_in_double_quotes(AT_PARSE_FIRST_PARAM_POS)))
    e918:	f7fb ffe4 	bl	a8e4 <at_is_param_in_double_quotes>
    e91c:	2800      	cmp	r0, #0
    e91e:	d1f7      	bne.n	e910 <at_handle_NSOCR_cmd_set+0x60>
    if (strncmp((char *)protocol_family, DATAGRAM_SOCKET, strlen(DATAGRAM_SOCKET)) == 0)
    e920:	4d60      	ldr	r5, [pc, #384]	; (eaa4 <at_handle_NSOCR_cmd_set+0x1f4>)
    e922:	0028      	movs	r0, r5
    e924:	f00c fd3b 	bl	1b39e <strlen>
    e928:	0029      	movs	r1, r5
    e92a:	0002      	movs	r2, r0
    e92c:	a807      	add	r0, sp, #28
    e92e:	f00c fd42 	bl	1b3b6 <strncmp>
    e932:	2800      	cmp	r0, #0
    e934:	d053      	beq.n	e9de <at_handle_NSOCR_cmd_set+0x12e>
    else if (strncmp((char *)protocol_family, STREAM_SOCKET, strlen(STREAM_SOCKET)) == 0)
    e936:	4d5c      	ldr	r5, [pc, #368]	; (eaa8 <at_handle_NSOCR_cmd_set+0x1f8>)
    e938:	0028      	movs	r0, r5
    e93a:	f00c fd30 	bl	1b39e <strlen>
    e93e:	0029      	movs	r1, r5
    e940:	0002      	movs	r2, r0
    e942:	a807      	add	r0, sp, #28
    e944:	f00c fd37 	bl	1b3b6 <strncmp>
    e948:	2800      	cmp	r0, #0
    e94a:	d00b      	beq.n	e964 <at_handle_NSOCR_cmd_set+0xb4>
    else if (strncmp((char *)protocol_family, RAW_SOCKET, strlen(RAW_SOCKET)) == 0)
    e94c:	4c57      	ldr	r4, [pc, #348]	; (eaac <at_handle_NSOCR_cmd_set+0x1fc>)
    e94e:	0020      	movs	r0, r4
    e950:	f00c fd25 	bl	1b39e <strlen>
    e954:	0021      	movs	r1, r4
    e956:	0002      	movs	r2, r0
    e958:	a807      	add	r0, sp, #28
    e95a:	f00c fd2c 	bl	1b3b6 <strncmp>
        socket_type = SOCK_RAW;
    e95e:	2403      	movs	r4, #3
    else if (strncmp((char *)protocol_family, RAW_SOCKET, strlen(RAW_SOCKET)) == 0)
    e960:	2800      	cmp	r0, #0
    e962:	d1d5      	bne.n	e910 <at_handle_NSOCR_cmd_set+0x60>
    cause = at_get_uint16_param(AT_PARSE_SECOND_PARAM_POS, &protocol, true);
    e964:	2201      	movs	r2, #1
    e966:	210e      	movs	r1, #14
    e968:	ab02      	add	r3, sp, #8
    e96a:	18c9      	adds	r1, r1, r3
    e96c:	0010      	movs	r0, r2
    e96e:	f7fb fdcd 	bl	a50c <at_get_uint16_param>
    e972:	1e05      	subs	r5, r0, #0
    if(cause != AT_RET_OK)
    e974:	d1cc      	bne.n	e910 <at_handle_NSOCR_cmd_set+0x60>
    if (num_recvparams >= 3)
    e976:	230d      	movs	r3, #13
    e978:	aa02      	add	r2, sp, #8
    e97a:	189b      	adds	r3, r3, r2
    e97c:	781b      	ldrb	r3, [r3, #0]
    e97e:	2b02      	cmp	r3, #2
    e980:	d82f      	bhi.n	e9e2 <at_handle_NSOCR_cmd_set+0x132>
    sock_address.sin_port = port;
    e982:	8832      	ldrh	r2, [r6, #0]
    if (num_recvparams >= 4)
    e984:	260d      	movs	r6, #13
    sock_address.sin_port = port;
    e986:	ab0f      	add	r3, sp, #60	; 0x3c
    e988:	805a      	strh	r2, [r3, #2]
    if (num_recvparams >= 4)
    e98a:	ab02      	add	r3, sp, #8
    e98c:	18f6      	adds	r6, r6, r3
    e98e:	7833      	ldrb	r3, [r6, #0]
    e990:	2b03      	cmp	r3, #3
    e992:	d90b      	bls.n	e9ac <at_handle_NSOCR_cmd_set+0xfc>
        cause = at_get_uint16_param(AT_PARSE_FOURTH_PARAM_POS, &receive_control, true);
    e994:	2201      	movs	r2, #1
    e996:	0039      	movs	r1, r7
    e998:	2003      	movs	r0, #3
    e99a:	f7fb fdb7 	bl	a50c <at_get_uint16_param>
        if((cause != AT_RET_OK) && cause != (AT_RET_PARAM_MISSING))
    e99e:	2800      	cmp	r0, #0
    e9a0:	d001      	beq.n	e9a6 <at_handle_NSOCR_cmd_set+0xf6>
    e9a2:	2803      	cmp	r0, #3
    e9a4:	d1b4      	bne.n	e910 <at_handle_NSOCR_cmd_set+0x60>
        if ((receive_control != RECEIVE_ENABLE) && (receive_control != RECEIVE_DISABLE))
    e9a6:	883b      	ldrh	r3, [r7, #0]
    e9a8:	2b01      	cmp	r3, #1
    e9aa:	d8b1      	bhi.n	e910 <at_handle_NSOCR_cmd_set+0x60>
    if (num_recvparams >= 5)
    e9ac:	7833      	ldrb	r3, [r6, #0]
    e9ae:	2b04      	cmp	r3, #4
    e9b0:	d91f      	bls.n	e9f2 <at_handle_NSOCR_cmd_set+0x142>
        cause = at_get_string_param(AT_PARSE_FIFTH_PARAM_POS, ai_family_str, sizeof(ai_family_str),true);
    e9b2:	2301      	movs	r3, #1
    e9b4:	2209      	movs	r2, #9
    e9b6:	a909      	add	r1, sp, #36	; 0x24
    e9b8:	2004      	movs	r0, #4
    e9ba:	f7fb fee5 	bl	a788 <at_get_string_param>
        if(cause != AT_RET_OK)
    e9be:	2800      	cmp	r0, #0
    e9c0:	d1a6      	bne.n	e910 <at_handle_NSOCR_cmd_set+0x60>
        if (strcmp((char *)ai_family_str, AF_INET_STR) == 0)
    e9c2:	493b      	ldr	r1, [pc, #236]	; (eab0 <at_handle_NSOCR_cmd_set+0x200>)
    e9c4:	a809      	add	r0, sp, #36	; 0x24
    e9c6:	f00c fccb 	bl	1b360 <strcmp>
    e9ca:	2800      	cmp	r0, #0
    e9cc:	d011      	beq.n	e9f2 <at_handle_NSOCR_cmd_set+0x142>
        else if (strcmp((char *)ai_family_str, AF_INET6_STR) == 0)
    e9ce:	4939      	ldr	r1, [pc, #228]	; (eab4 <at_handle_NSOCR_cmd_set+0x204>)
    e9d0:	a809      	add	r0, sp, #36	; 0x24
    e9d2:	f00c fcc5 	bl	1b360 <strcmp>
    e9d6:	2800      	cmp	r0, #0
    e9d8:	d19a      	bne.n	e910 <at_handle_NSOCR_cmd_set+0x60>
            ai_family = AF_INET6;
    e9da:	270a      	movs	r7, #10
    e9dc:	e00a      	b.n	e9f4 <at_handle_NSOCR_cmd_set+0x144>
        socket_type = SOCK_DGRAM;
    e9de:	2402      	movs	r4, #2
    e9e0:	e7c0      	b.n	e964 <at_handle_NSOCR_cmd_set+0xb4>
        cause = at_get_uint16_param(AT_PARSE_THIRD_PARAM_POS, &port, true);
    e9e2:	2201      	movs	r2, #1
    e9e4:	0031      	movs	r1, r6
    e9e6:	2002      	movs	r0, #2
    e9e8:	f7fb fd90 	bl	a50c <at_get_uint16_param>
        if(cause != AT_RET_OK)
    e9ec:	2800      	cmp	r0, #0
    e9ee:	d0c8      	beq.n	e982 <at_handle_NSOCR_cmd_set+0xd2>
    e9f0:	e78e      	b.n	e910 <at_handle_NSOCR_cmd_set+0x60>
    uint8             ai_family = AF_INET;
    e9f2:	2702      	movs	r7, #2
    if (num_recvparams == 6)
    e9f4:	230d      	movs	r3, #13
    e9f6:	aa02      	add	r2, sp, #8
    e9f8:	189b      	adds	r3, r3, r2
    e9fa:	781b      	ldrb	r3, [r3, #0]
    sock_address.sin_family = (PROTOCOL_FAMILY)ai_family;
    e9fc:	ae0f      	add	r6, sp, #60	; 0x3c
    e9fe:	7037      	strb	r7, [r6, #0]
    if (num_recvparams == 6)
    ea00:	2b06      	cmp	r3, #6
    ea02:	d129      	bne.n	ea58 <at_handle_NSOCR_cmd_set+0x1a8>
        cause = at_get_ip_param(AT_PARSE_SIXTH_PARAM_POS, (uint8*)ip_str, MAX_IP_LEN, true, &sock_address.sin_addr);
    ea04:	ab10      	add	r3, sp, #64	; 0x40
    ea06:	9300      	str	r3, [sp, #0]
    ea08:	223c      	movs	r2, #60	; 0x3c
    ea0a:	2301      	movs	r3, #1
    ea0c:	a915      	add	r1, sp, #84	; 0x54
    ea0e:	2005      	movs	r0, #5
    ea10:	f7fb ff52 	bl	a8b8 <at_get_ip_param>
        if (cause != AT_RET_OK)
    ea14:	2800      	cmp	r0, #0
    ea16:	d000      	beq.n	ea1a <at_handle_NSOCR_cmd_set+0x16a>
    ea18:	e77a      	b.n	e910 <at_handle_NSOCR_cmd_set+0x60>
    sock = socket(ai_family, socket_type, (PROTOCOL_TYPE)protocol); //lint !e64
    ea1a:	230e      	movs	r3, #14
    ea1c:	aa02      	add	r2, sp, #8
    ea1e:	189b      	adds	r3, r3, r2
    ea20:	0021      	movs	r1, r4
    ea22:	781a      	ldrb	r2, [r3, #0]
    ea24:	0038      	movs	r0, r7
    ea26:	f7f9 f94d 	bl	7cc4 <socket>
    ea2a:	0004      	movs	r4, r0
    if (sock == NEUL_SOCKET_RET_ERROR)
    ea2c:	1c43      	adds	r3, r0, #1
    ea2e:	d011      	beq.n	ea54 <at_handle_NSOCR_cmd_set+0x1a4>
    if (receive_control == RECEIVE_ENABLE)
    ea30:	2312      	movs	r3, #18
    ea32:	aa02      	add	r2, sp, #8
    ea34:	189b      	adds	r3, r3, r2
    ea36:	881a      	ldrh	r2, [r3, #0]
    socket_recv_notify_fn   callback = NULL;
    ea38:	2300      	movs	r3, #0
    if (receive_control == RECEIVE_ENABLE)
    ea3a:	2a01      	cmp	r2, #1
    ea3c:	d100      	bne.n	ea40 <at_handle_NSOCR_cmd_set+0x190>
        callback = (socket_recv_notify_fn)socket_callback;
    ea3e:	4b1e      	ldr	r3, [pc, #120]	; (eab8 <at_handle_NSOCR_cmd_set+0x208>)
    if (neul_bind(sock, (struct sockaddr *) &sock_address, sizeof(sock_address), callback) != NEUL_SOCKET_RET_OK)    //lint !e740 !e826
    ea40:	2218      	movs	r2, #24
    ea42:	0031      	movs	r1, r6
    ea44:	0020      	movs	r0, r4
    ea46:	f7f9 f97b 	bl	7d40 <neul_bind>
    ea4a:	2800      	cmp	r0, #0
    ea4c:	d00e      	beq.n	ea6c <at_handle_NSOCR_cmd_set+0x1bc>
        (void)close_socket(sock);
    ea4e:	0020      	movs	r0, r4
    ea50:	f7f9 face 	bl	7ff0 <close_socket>
        return AT_RET_PROGRESS_ERROR;
    ea54:	2506      	movs	r5, #6
    ea56:	e75c      	b.n	e912 <at_handle_NSOCR_cmd_set+0x62>
    ea58:	2300      	movs	r3, #0
        ip_addr_set_any((sock_address.sin_family == AF_INET6), &sock_address.sin_addr); //lint !e774
    ea5a:	6073      	str	r3, [r6, #4]
    ea5c:	2f0a      	cmp	r7, #10
    ea5e:	d103      	bne.n	ea68 <at_handle_NSOCR_cmd_set+0x1b8>
    ea60:	60b3      	str	r3, [r6, #8]
    ea62:	60f3      	str	r3, [r6, #12]
    ea64:	6133      	str	r3, [r6, #16]
    ea66:	3306      	adds	r3, #6
    ea68:	7533      	strb	r3, [r6, #20]
    ea6a:	e7d6      	b.n	ea1a <at_handle_NSOCR_cmd_set+0x16a>
    if (sock_callback_set(sock, at_socket_sent_callback, at_socket_status_callback) != NEUL_RET_OK)
    ea6c:	4a13      	ldr	r2, [pc, #76]	; (eabc <at_handle_NSOCR_cmd_set+0x20c>)
    ea6e:	4914      	ldr	r1, [pc, #80]	; (eac0 <at_handle_NSOCR_cmd_set+0x210>)
    ea70:	0020      	movs	r0, r4
    ea72:	f7f9 fae9 	bl	8048 <sock_callback_set>
    ea76:	2800      	cmp	r0, #0
    ea78:	d1e9      	bne.n	ea4e <at_handle_NSOCR_cmd_set+0x19e>
    if (sock_num < BITS_IN_WORD)
    ea7a:	b2a3      	uxth	r3, r4
    ea7c:	2b1f      	cmp	r3, #31
    ea7e:	d806      	bhi.n	ea8e <at_handle_NSOCR_cmd_set+0x1de>
        sock_at_allocated |= (uint32) 1 << sock_num;
    ea80:	0019      	movs	r1, r3
    ea82:	2301      	movs	r3, #1
    ea84:	408b      	lsls	r3, r1
    ea86:	4a0f      	ldr	r2, [pc, #60]	; (eac4 <at_handle_NSOCR_cmd_set+0x214>)
    ea88:	6811      	ldr	r1, [r2, #0]
    ea8a:	430b      	orrs	r3, r1
    ea8c:	6013      	str	r3, [r2, #0]
    (void)snprintf(rsp_string, MAX_UINT32_CHARACTERS + 1, "%ld", sock);
    ea8e:	0023      	movs	r3, r4
    ea90:	4a0d      	ldr	r2, [pc, #52]	; (eac8 <at_handle_NSOCR_cmd_set+0x218>)
    ea92:	210b      	movs	r1, #11
    ea94:	a80c      	add	r0, sp, #48	; 0x30
    ea96:	f00b fee9 	bl	1a86c <snprintf>
    app_at_send_at_rsp_string_lines_with_claim_and_log(rsp_string);
    ea9a:	a80c      	add	r0, sp, #48	; 0x30
    ea9c:	f7fa fda2 	bl	95e4 <app_at_send_at_rsp_string_lines_with_claim_and_log>
    return AT_RET_OK;
    eaa0:	e737      	b.n	e912 <at_handle_NSOCR_cmd_set+0x62>
    eaa2:	46c0      	nop			; (mov r8, r8)
    eaa4:	00023d53 	.word	0x00023d53
    eaa8:	00023d59 	.word	0x00023d59
    eaac:	00023d60 	.word	0x00023d60
    eab0:	00023d64 	.word	0x00023d64
    eab4:	00023d6c 	.word	0x00023d6c
    eab8:	0000aef1 	.word	0x0000aef1
    eabc:	00011915 	.word	0x00011915
    eac0:	0000ae95 	.word	0x0000ae95
    eac4:	010024c8 	.word	0x010024c8
    eac8:	000234f1 	.word	0x000234f1

0000eacc <at_handle_NCONFIG_cmd_read>:
{
    eacc:	b5f0      	push	{r4, r5, r6, r7, lr}
    uint16          nconfig_value                       = 0;
    eace:	250e      	movs	r5, #14
    ead0:	2400      	movs	r4, #0
    bool        first_flag                              = true;
    ead2:	2701      	movs	r7, #1
{
    ead4:	b091      	sub	sp, #68	; 0x44
    char           rsp_string[AT_MAX_NCONFIG_GET_RSP_LEN]  = {0};
    ead6:	222d      	movs	r2, #45	; 0x2d
    ead8:	2100      	movs	r1, #0
    eada:	a804      	add	r0, sp, #16
    uint16          nconfig_value                       = 0;
    eadc:	446d      	add	r5, sp
    char           rsp_string[AT_MAX_NCONFIG_GET_RSP_LEN]  = {0};
    eade:	f7f1 fbff 	bl	2e0 <memset>
    uint16          nconfig_value                       = 0;
    eae2:	802c      	strh	r4, [r5, #0]
    eae4:	b2e6      	uxtb	r6, r4
        result = get_nconfig(function_loop, &nconfig_value);
    eae6:	0029      	movs	r1, r5
    eae8:	0030      	movs	r0, r6
    eaea:	f00d fca2 	bl	1c432 <get_nconfig>
        if (result == NEUL_RET_OK)
    eaee:	2800      	cmp	r0, #0
    eaf0:	d129      	bne.n	eb46 <at_handle_NCONFIG_cmd_read+0x7a>
            if (first_flag)
    eaf2:	2f00      	cmp	r7, #0
    eaf4:	d009      	beq.n	eb0a <at_handle_NCONFIG_cmd_read+0x3e>
                at_uart_claim();
    eaf6:	f7fa ff57 	bl	99a8 <at_uart_claim>
                at_uart_write((uint8*)APP_AT_STR_RN, strlen(APP_AT_STR_RN));
    eafa:	4f21      	ldr	r7, [pc, #132]	; (eb80 <at_handle_NCONFIG_cmd_read+0xb4>)
    eafc:	0038      	movs	r0, r7
    eafe:	f00c fc4e 	bl	1b39e <strlen>
    eb02:	0001      	movs	r1, r0
    eb04:	0038      	movs	r0, r7
    eb06:	f7fa ff71 	bl	99ec <at_uart_write>
            memset(rsp_string, 0, AT_MAX_NCONFIG_GET_RSP_LEN);
    eb0a:	222d      	movs	r2, #45	; 0x2d
    eb0c:	2100      	movs	r1, #0
    eb0e:	a804      	add	r0, sp, #16
    eb10:	f7f1 fbe6 	bl	2e0 <memset>
            if (function_loop == NEUL_BARRING_RELEASE_DELAY
    eb14:	0032      	movs	r2, r6
    eb16:	3a08      	subs	r2, #8
    eb18:	4b1a      	ldr	r3, [pc, #104]	; (eb84 <at_handle_NCONFIG_cmd_read+0xb8>)
    eb1a:	2a01      	cmp	r2, #1
    eb1c:	d903      	bls.n	eb26 <at_handle_NCONFIG_cmd_read+0x5a>
                || function_loop == NEUL_SYNC_TIME_PERIOD
    eb1e:	3a03      	subs	r2, #3
    eb20:	8829      	ldrh	r1, [r5, #0]
    eb22:	2a02      	cmp	r2, #2
    eb24:	d819      	bhi.n	eb5a <at_handle_NCONFIG_cmd_read+0x8e>
                (void)snprintf(rsp_string, AT_MAX_NCONFIG_GET_RSP_LEN, "%s%s,%d",
    eb26:	882a      	ldrh	r2, [r5, #0]
    eb28:	00a1      	lsls	r1, r4, #2
    eb2a:	9201      	str	r2, [sp, #4]
    eb2c:	4a16      	ldr	r2, [pc, #88]	; (eb88 <at_handle_NCONFIG_cmd_read+0xbc>)
    eb2e:	588a      	ldr	r2, [r1, r2]
    eb30:	9200      	str	r2, [sp, #0]
    eb32:	4a16      	ldr	r2, [pc, #88]	; (eb8c <at_handle_NCONFIG_cmd_read+0xc0>)
                (void)snprintf(rsp_string, AT_MAX_NCONFIG_GET_RSP_LEN, "%s%s,%s",
    eb34:	212d      	movs	r1, #45	; 0x2d
    eb36:	a804      	add	r0, sp, #16
    eb38:	f00b fe98 	bl	1a86c <snprintf>
            app_at_send_at_rsp_string_rn_no_claim(rsp_string, AT_FLAG_LOGABLE | AT_FLAG_LOG_RESTRICTED);
    eb3c:	2128      	movs	r1, #40	; 0x28
    eb3e:	a804      	add	r0, sp, #16
    eb40:	f7fa fd5e 	bl	9600 <app_at_send_at_rsp_string_rn_no_claim>
    eb44:	2700      	movs	r7, #0
    eb46:	3401      	adds	r4, #1
    for (function_loop = 0;function_loop < NEUL_NCONFIG_FUNCTION_NUM; function_loop++)
    eb48:	2c17      	cmp	r4, #23
    eb4a:	d1cb      	bne.n	eae4 <at_handle_NCONFIG_cmd_read+0x18>
    if (!first_flag)
    eb4c:	2f00      	cmp	r7, #0
    eb4e:	d101      	bne.n	eb54 <at_handle_NCONFIG_cmd_read+0x88>
        at_uart_release();
    eb50:	f7fa ff3c 	bl	99cc <at_uart_release>
}
    eb54:	2000      	movs	r0, #0
    eb56:	b011      	add	sp, #68	; 0x44
    eb58:	bdf0      	pop	{r4, r5, r6, r7, pc}
    eb5a:	4a0d      	ldr	r2, [pc, #52]	; (eb90 <at_handle_NCONFIG_cmd_read+0xc4>)
            else if (function_loop == NEUL_PCO_TYPE)
    eb5c:	2e13      	cmp	r6, #19
    eb5e:	d107      	bne.n	eb70 <at_handle_NCONFIG_cmd_read+0xa4>
                    p_pco_str = AT_EPCO_STR;
    eb60:	480c      	ldr	r0, [pc, #48]	; (eb94 <at_handle_NCONFIG_cmd_read+0xc8>)
                if (nconfig_value == AT_PCO_IE)
    eb62:	2901      	cmp	r1, #1
    eb64:	d100      	bne.n	eb68 <at_handle_NCONFIG_cmd_read+0x9c>
                    p_pco_str = AT_PCO_STR;
    eb66:	480c      	ldr	r0, [pc, #48]	; (eb98 <at_handle_NCONFIG_cmd_read+0xcc>)
                (void)snprintf(rsp_string, AT_MAX_NCONFIG_GET_RSP_LEN, "%s%s,%s",
    eb68:	490c      	ldr	r1, [pc, #48]	; (eb9c <at_handle_NCONFIG_cmd_read+0xd0>)
    eb6a:	9001      	str	r0, [sp, #4]
                (void)snprintf(rsp_string, AT_MAX_NCONFIG_GET_RSP_LEN, "%s%s,%s",
    eb6c:	9100      	str	r1, [sp, #0]
    eb6e:	e7e1      	b.n	eb34 <at_handle_NCONFIG_cmd_read+0x68>
    eb70:	480b      	ldr	r0, [pc, #44]	; (eba0 <at_handle_NCONFIG_cmd_read+0xd4>)
    eb72:	0089      	lsls	r1, r1, #2
    eb74:	5809      	ldr	r1, [r1, r0]
    eb76:	00a0      	lsls	r0, r4, #2
    eb78:	9101      	str	r1, [sp, #4]
    eb7a:	4903      	ldr	r1, [pc, #12]	; (eb88 <at_handle_NCONFIG_cmd_read+0xbc>)
    eb7c:	5841      	ldr	r1, [r0, r1]
    eb7e:	e7f5      	b.n	eb6c <at_handle_NCONFIG_cmd_read+0xa0>
    eb80:	00022d8f 	.word	0x00022d8f
    eb84:	00023af4 	.word	0x00023af4
    eb88:	00024818 	.word	0x00024818
    eb8c:	00023ae4 	.word	0x00023ae4
    eb90:	00023aec 	.word	0x00023aec
    eb94:	00023b8f 	.word	0x00023b8f
    eb98:	00023b90 	.word	0x00023b90
    eb9c:	00023b94 	.word	0x00023b94
    eba0:	00024810 	.word	0x00024810

0000eba4 <at_handle_NCONFIG_cmd_set>:
{
    eba4:	b570      	push	{r4, r5, r6, lr}
    eba6:	b08c      	sub	sp, #48	; 0x30
    eba8:	0005      	movs	r5, r0
    uint8               str_function[AT_MAX_NCONFIG_FUNCTION_LEN]   = {0};
    ebaa:	221e      	movs	r2, #30
    ebac:	2100      	movs	r1, #0
    ebae:	a804      	add	r0, sp, #16
    ebb0:	f7f1 fb96 	bl	2e0 <memset>
    uint8               str_value[AT_MAX_NCONFIG_VALUE_LEN]         = {0};
    ebb4:	2206      	movs	r2, #6
    ebb6:	2100      	movs	r1, #0
    ebb8:	a802      	add	r0, sp, #8
    ebba:	f7f1 fb91 	bl	2e0 <memset>
    uint16              nconfig_value                               = 0;
    ebbe:	466b      	mov	r3, sp
    ebc0:	1d9c      	adds	r4, r3, #6
    ebc2:	2300      	movs	r3, #0
    if (at_create_param_array(p_atparams_string, &num_recvparams, 2, 2) != AT_RET_OK)
    ebc4:	4669      	mov	r1, sp
    uint16              nconfig_value                               = 0;
    ebc6:	8023      	strh	r3, [r4, #0]
    if (at_create_param_array(p_atparams_string, &num_recvparams, 2, 2) != AT_RET_OK)
    ebc8:	3302      	adds	r3, #2
    ebca:	001a      	movs	r2, r3
    ebcc:	3105      	adds	r1, #5
    ebce:	0028      	movs	r0, r5
    ebd0:	f7fb fb88 	bl	a2e4 <at_create_param_array>
    ebd4:	2800      	cmp	r0, #0
    ebd6:	d002      	beq.n	ebde <at_handle_NCONFIG_cmd_set+0x3a>
       return AT_RET_SYNTAX_ERROR;
    ebd8:	2001      	movs	r0, #1
}
    ebda:	b00c      	add	sp, #48	; 0x30
    ebdc:	bd70      	pop	{r4, r5, r6, pc}
    if (at_get_string_param(AT_PARSE_FIRST_PARAM_POS, str_function, AT_MAX_NCONFIG_FUNCTION_LEN, true) != AT_RET_OK)
    ebde:	2301      	movs	r3, #1
    ebe0:	221e      	movs	r2, #30
    ebe2:	a904      	add	r1, sp, #16
    ebe4:	f7fb fdd0 	bl	a788 <at_get_string_param>
    ebe8:	2800      	cmp	r0, #0
    ebea:	d1f5      	bne.n	ebd8 <at_handle_NCONFIG_cmd_set+0x34>
    ebec:	0005      	movs	r5, r0
        if (at_strcmp(str_function, nconfig_function_names[loop]) == 0)
    ebee:	4b35      	ldr	r3, [pc, #212]	; (ecc4 <at_handle_NCONFIG_cmd_set+0x120>)
    ebf0:	00aa      	lsls	r2, r5, #2
    ebf2:	58d1      	ldr	r1, [r2, r3]
    ebf4:	a804      	add	r0, sp, #16
    ebf6:	b2ee      	uxtb	r6, r5
    ebf8:	f00c fbb2 	bl	1b360 <strcmp>
    ebfc:	2800      	cmp	r0, #0
    ebfe:	d04c      	beq.n	ec9a <at_handle_NCONFIG_cmd_set+0xf6>
    ec00:	3501      	adds	r5, #1
    for (loop = 0; loop < NEUL_NCONFIG_FUNCTION_NUM; loop++)
    ec02:	2d17      	cmp	r5, #23
    ec04:	d1f3      	bne.n	ebee <at_handle_NCONFIG_cmd_set+0x4a>
    ec06:	e7e7      	b.n	ebd8 <at_handle_NCONFIG_cmd_set+0x34>
    else if (nconfig_function == NEUL_RELEASE_VERSION)
    ec08:	2e09      	cmp	r6, #9
    ec0a:	d10b      	bne.n	ec24 <at_handle_NCONFIG_cmd_set+0x80>
        if (at_get_uint16_param(AT_PARSE_SECOND_PARAM_POS, &nconfig_value, true) != AT_RET_OK)
    ec0c:	2201      	movs	r2, #1
    ec0e:	0021      	movs	r1, r4
    ec10:	0010      	movs	r0, r2
    ec12:	f7fb fc7b 	bl	a50c <at_get_uint16_param>
    ec16:	2800      	cmp	r0, #0
    ec18:	d1de      	bne.n	ebd8 <at_handle_NCONFIG_cmd_set+0x34>
        if (nconfig_value != NB_IOT_UE_REL_13 && nconfig_value != NB_IOT_UE_REL_14)
    ec1a:	8823      	ldrh	r3, [r4, #0]
    ec1c:	3b0d      	subs	r3, #13
        if (nconfig_value != NB_IOT_CAT_NB1 && nconfig_value != NB_IOT_CAT_NB2)
    ec1e:	2b01      	cmp	r3, #1
    ec20:	d8da      	bhi.n	ebd8 <at_handle_NCONFIG_cmd_set+0x34>
    ec22:	e047      	b.n	ecb4 <at_handle_NCONFIG_cmd_set+0x110>
    else if (nconfig_function == NEUL_NB_CATEGORY)
    ec24:	2e0d      	cmp	r6, #13
    ec26:	d109      	bne.n	ec3c <at_handle_NCONFIG_cmd_set+0x98>
        if (at_get_uint16_param(AT_PARSE_SECOND_PARAM_POS, &nconfig_value, true) != AT_RET_OK)
    ec28:	2201      	movs	r2, #1
    ec2a:	0021      	movs	r1, r4
    ec2c:	0010      	movs	r0, r2
    ec2e:	f7fb fc6d 	bl	a50c <at_get_uint16_param>
    ec32:	2800      	cmp	r0, #0
    ec34:	d1d0      	bne.n	ebd8 <at_handle_NCONFIG_cmd_set+0x34>
        if (nconfig_value != NB_IOT_CAT_NB1 && nconfig_value != NB_IOT_CAT_NB2)
    ec36:	8823      	ldrh	r3, [r4, #0]
    ec38:	3b01      	subs	r3, #1
    ec3a:	e7f0      	b.n	ec1e <at_handle_NCONFIG_cmd_set+0x7a>
    else if(nconfig_function == NEUL_SYNC_TIME_PERIOD)
    ec3c:	2e0b      	cmp	r6, #11
    ec3e:	d031      	beq.n	eca4 <at_handle_NCONFIG_cmd_set+0x100>
        if (at_get_string_param(AT_PARSE_SECOND_PARAM_POS, str_value, AT_MAX_NCONFIG_VALUE_LEN, true) != AT_RET_OK)
    ec40:	2301      	movs	r3, #1
    ec42:	2206      	movs	r2, #6
    ec44:	a902      	add	r1, sp, #8
    ec46:	0018      	movs	r0, r3
    else if (nconfig_function == NEUL_PCO_TYPE)
    ec48:	2e13      	cmp	r6, #19
    ec4a:	d114      	bne.n	ec76 <at_handle_NCONFIG_cmd_set+0xd2>
        if (at_get_string_param(AT_PARSE_SECOND_PARAM_POS, str_value, AT_MAX_NCONFIG_VALUE_LEN, true) != AT_RET_OK)
    ec4c:	f7fb fd9c 	bl	a788 <at_get_string_param>
    ec50:	2800      	cmp	r0, #0
    ec52:	d1c1      	bne.n	ebd8 <at_handle_NCONFIG_cmd_set+0x34>
        if (at_strcmp(str_value, AT_PCO_STR) == 0)
    ec54:	491c      	ldr	r1, [pc, #112]	; (ecc8 <at_handle_NCONFIG_cmd_set+0x124>)
    ec56:	a802      	add	r0, sp, #8
    ec58:	f00c fb82 	bl	1b360 <strcmp>
    ec5c:	2800      	cmp	r0, #0
    ec5e:	d102      	bne.n	ec66 <at_handle_NCONFIG_cmd_set+0xc2>
            nconfig_value = AT_PCO_IE;
    ec60:	2301      	movs	r3, #1
            nconfig_value = AT_EPCO_IE;
    ec62:	8023      	strh	r3, [r4, #0]
    ec64:	e026      	b.n	ecb4 <at_handle_NCONFIG_cmd_set+0x110>
        else if (at_strcmp(str_value, AT_EPCO_STR) == 0)
    ec66:	4919      	ldr	r1, [pc, #100]	; (eccc <at_handle_NCONFIG_cmd_set+0x128>)
    ec68:	a802      	add	r0, sp, #8
    ec6a:	f00c fb79 	bl	1b360 <strcmp>
    ec6e:	2800      	cmp	r0, #0
    ec70:	d1b2      	bne.n	ebd8 <at_handle_NCONFIG_cmd_set+0x34>
            nconfig_value = AT_EPCO_IE;
    ec72:	2302      	movs	r3, #2
    ec74:	e7f5      	b.n	ec62 <at_handle_NCONFIG_cmd_set+0xbe>
        if (at_get_string_param(AT_PARSE_SECOND_PARAM_POS, str_value, AT_MAX_NCONFIG_VALUE_LEN, true) != AT_RET_OK)
    ec76:	f7fb fd87 	bl	a788 <at_get_string_param>
    ec7a:	2800      	cmp	r0, #0
    ec7c:	d1ac      	bne.n	ebd8 <at_handle_NCONFIG_cmd_set+0x34>
        if (at_strcmp(str_value, APP_AT_STR_TRUE) == 0)
    ec7e:	4914      	ldr	r1, [pc, #80]	; (ecd0 <at_handle_NCONFIG_cmd_set+0x12c>)
    ec80:	a802      	add	r0, sp, #8
    ec82:	f00c fb6d 	bl	1b360 <strcmp>
    ec86:	2800      	cmp	r0, #0
    ec88:	d0ea      	beq.n	ec60 <at_handle_NCONFIG_cmd_set+0xbc>
        else if(at_strcmp(str_value, APP_AT_STR_FALSE) == 0)
    ec8a:	4912      	ldr	r1, [pc, #72]	; (ecd4 <at_handle_NCONFIG_cmd_set+0x130>)
    ec8c:	a802      	add	r0, sp, #8
    ec8e:	f00c fb67 	bl	1b360 <strcmp>
    ec92:	2800      	cmp	r0, #0
    ec94:	d1a0      	bne.n	ebd8 <at_handle_NCONFIG_cmd_set+0x34>
            nconfig_value = 0;
    ec96:	8020      	strh	r0, [r4, #0]
    ec98:	e00c      	b.n	ecb4 <at_handle_NCONFIG_cmd_set+0x110>
    if ((nconfig_function == NEUL_BARRING_RELEASE_DELAY) || (nconfig_function == NEUL_IPV6_GET_PREFIX_TIME))
    ec9a:	2304      	movs	r3, #4
    ec9c:	0032      	movs	r2, r6
    ec9e:	439a      	bics	r2, r3
    eca0:	2a08      	cmp	r2, #8
    eca2:	d1b1      	bne.n	ec08 <at_handle_NCONFIG_cmd_set+0x64>
        if (at_get_uint16_param(AT_PARSE_SECOND_PARAM_POS, &nconfig_value, true) != AT_RET_OK)
    eca4:	2201      	movs	r2, #1
    eca6:	0021      	movs	r1, r4
    eca8:	0010      	movs	r0, r2
    ecaa:	f7fb fc2f 	bl	a50c <at_get_uint16_param>
    ecae:	2800      	cmp	r0, #0
    ecb0:	d000      	beq.n	ecb4 <at_handle_NCONFIG_cmd_set+0x110>
    ecb2:	e791      	b.n	ebd8 <at_handle_NCONFIG_cmd_set+0x34>
    result = set_nconfig(nconfig_function, nconfig_value);
    ecb4:	8821      	ldrh	r1, [r4, #0]
    ecb6:	0030      	movs	r0, r6
    ecb8:	f00d fbb1 	bl	1c41e <set_nconfig>
    return at_parse_convert_neul_result(result);
    ecbc:	f7fb fae8 	bl	a290 <at_parse_convert_neul_result>
    ecc0:	e78b      	b.n	ebda <at_handle_NCONFIG_cmd_set+0x36>
    ecc2:	46c0      	nop			; (mov r8, r8)
    ecc4:	00024818 	.word	0x00024818
    ecc8:	00023b90 	.word	0x00023b90
    eccc:	00023b8f 	.word	0x00023b8f
    ecd0:	00023ba0 	.word	0x00023ba0
    ecd4:	00023ba5 	.word	0x00023ba5

0000ecd8 <at_handle_NPING_cmd_set>:
{
    ecd8:	b530      	push	{r4, r5, lr}
    ecda:	b093      	sub	sp, #76	; 0x4c
    ecdc:	0005      	movs	r5, r0
    char              ip_addr_str[AT_MAX_PDP_ADDR_SIZE] = {0};
    ecde:	2221      	movs	r2, #33	; 0x21
    ece0:	2100      	movs	r1, #0
    ece2:	a809      	add	r0, sp, #36	; 0x24
    uint16            p_size                            = AT_NPING_MIN_P_SIZE_VALUE;
    ece4:	240a      	movs	r4, #10
    char              ip_addr_str[AT_MAX_PDP_ADDR_SIZE] = {0};
    ece6:	f7f1 fafb 	bl	2e0 <memset>
    uint16            p_size                            = AT_NPING_MIN_P_SIZE_VALUE;
    ecea:	230c      	movs	r3, #12
    cause = at_create_param_array(p_atparams_string, &num_recvparams, 1, 3);
    ecec:	2109      	movs	r1, #9
    uint16            p_size                            = AT_NPING_MIN_P_SIZE_VALUE;
    ecee:	446c      	add	r4, sp
    ecf0:	8023      	strh	r3, [r4, #0]
    uint32            timeout                           = AT_NPING_DEFAULT_TIMEOUT_VALUE;
    ecf2:	4b1d      	ldr	r3, [pc, #116]	; (ed68 <at_handle_NPING_cmd_set+0x90>)
    cause = at_create_param_array(p_atparams_string, &num_recvparams, 1, 3);
    ecf4:	2201      	movs	r2, #1
    uint32            timeout                           = AT_NPING_DEFAULT_TIMEOUT_VALUE;
    ecf6:	9303      	str	r3, [sp, #12]
    cause = at_create_param_array(p_atparams_string, &num_recvparams, 1, 3);
    ecf8:	4469      	add	r1, sp
    ecfa:	2303      	movs	r3, #3
    ecfc:	0028      	movs	r0, r5
    ecfe:	f7fb faf1 	bl	a2e4 <at_create_param_array>
    if(cause != AT_RET_OK)
    ed02:	2800      	cmp	r0, #0
    ed04:	d109      	bne.n	ed1a <at_handle_NPING_cmd_set+0x42>
    cause = at_get_ip_param(AT_PARSE_FIRST_PARAM_POS, (uint8*)ip_addr_str, AT_MAX_PDP_ADDR_SIZE, true, &remote_addr);
    ed06:	ad04      	add	r5, sp, #16
    ed08:	9500      	str	r5, [sp, #0]
    ed0a:	2301      	movs	r3, #1
    ed0c:	2221      	movs	r2, #33	; 0x21
    ed0e:	a909      	add	r1, sp, #36	; 0x24
    ed10:	f7fb fdd2 	bl	a8b8 <at_get_ip_param>
    if(cause != AT_RET_OK)
    ed14:	2800      	cmp	r0, #0
    ed16:	d002      	beq.n	ed1e <at_handle_NPING_cmd_set+0x46>
        return AT_RET_SYNTAX_ERROR;
    ed18:	2001      	movs	r0, #1
}
    ed1a:	b013      	add	sp, #76	; 0x4c
    ed1c:	bd30      	pop	{r4, r5, pc}
    cause = at_get_uint16_param(AT_PARSE_SECOND_PARAM_POS, &p_size, true);
    ed1e:	2201      	movs	r2, #1
    ed20:	0021      	movs	r1, r4
    ed22:	0010      	movs	r0, r2
    ed24:	f7fb fbf2 	bl	a50c <at_get_uint16_param>
    if ((cause != AT_RET_OK) && (cause != AT_RET_PARAM_MISSING))
    ed28:	2800      	cmp	r0, #0
    ed2a:	d001      	beq.n	ed30 <at_handle_NPING_cmd_set+0x58>
    ed2c:	2803      	cmp	r0, #3
    ed2e:	d1f3      	bne.n	ed18 <at_handle_NPING_cmd_set+0x40>
    if (p_size > AT_NPING_MAX_P_SIZE_VALUE)
    ed30:	4b0e      	ldr	r3, [pc, #56]	; (ed6c <at_handle_NPING_cmd_set+0x94>)
    ed32:	8822      	ldrh	r2, [r4, #0]
    ed34:	429a      	cmp	r2, r3
    ed36:	d8ef      	bhi.n	ed18 <at_handle_NPING_cmd_set+0x40>
    cause = at_get_uint32_param(AT_PARSE_THIRD_PARAM_POS, &timeout, true);
    ed38:	2201      	movs	r2, #1
    ed3a:	a903      	add	r1, sp, #12
    ed3c:	2002      	movs	r0, #2
    ed3e:	f7fb fb6d 	bl	a41c <at_get_uint32_param>
    if ((cause != AT_RET_OK) && (cause != AT_RET_PARAM_MISSING))
    ed42:	2800      	cmp	r0, #0
    ed44:	d001      	beq.n	ed4a <at_handle_NPING_cmd_set+0x72>
    ed46:	2803      	cmp	r0, #3
    ed48:	d1e6      	bne.n	ed18 <at_handle_NPING_cmd_set+0x40>
    if((timeout < AT_NPING_MIN_TIMEOUT_VALUE) || (timeout > AT_NPING_MAX_TIMEOUT_VALUE))
    ed4a:	9a03      	ldr	r2, [sp, #12]
    ed4c:	4b08      	ldr	r3, [pc, #32]	; (ed70 <at_handle_NPING_cmd_set+0x98>)
    ed4e:	0011      	movs	r1, r2
    ed50:	390a      	subs	r1, #10
    ed52:	4299      	cmp	r1, r3
    ed54:	d8e0      	bhi.n	ed18 <at_handle_NPING_cmd_set+0x40>
    icmp_ping_send_result = icmp_ping_send(&remote_addr, p_size, timeout, at_handle_nping_callback);
    ed56:	8821      	ldrh	r1, [r4, #0]
    ed58:	4b06      	ldr	r3, [pc, #24]	; (ed74 <at_handle_NPING_cmd_set+0x9c>)
    ed5a:	0028      	movs	r0, r5
    ed5c:	f00e f9f8 	bl	1d150 <icmp_ping_send>
    return at_parse_convert_neul_result(icmp_ping_send_result);
    ed60:	f7fb fa96 	bl	a290 <at_parse_convert_neul_result>
    ed64:	e7d9      	b.n	ed1a <at_handle_NPING_cmd_set+0x42>
    ed66:	46c0      	nop			; (mov r8, r8)
    ed68:	00002710 	.word	0x00002710
    ed6c:	000005dc 	.word	0x000005dc
    ed70:	000927b6 	.word	0x000927b6
    ed74:	0000c27d 	.word	0x0000c27d

0000ed78 <at_handle_CMEE_cmd_read>:
{
    ed78:	b513      	push	{r0, r1, r4, lr}
    char            rsp_string[AT_CMEE_READ_RSP_LEN] = {0};
    ed7a:	2408      	movs	r4, #8
    ed7c:	2100      	movs	r1, #0
    ed7e:	0022      	movs	r2, r4
    ed80:	4668      	mov	r0, sp
    ed82:	f7f1 faad 	bl	2e0 <memset>
    (void)snprintf(rsp_string, AT_CMEE_READ_RSP_LEN, "+CMEE:%d", get_cmee_error_type());
    ed86:	f7fa fae9 	bl	935c <get_cmee_error_type>
    ed8a:	4a05      	ldr	r2, [pc, #20]	; (eda0 <at_handle_CMEE_cmd_read+0x28>)
    ed8c:	0003      	movs	r3, r0
    ed8e:	0021      	movs	r1, r4
    ed90:	4668      	mov	r0, sp
    ed92:	f00b fd6b 	bl	1a86c <snprintf>
    app_at_send_at_rsp_string_lines_with_claim_and_log(rsp_string);
    ed96:	4668      	mov	r0, sp
    ed98:	f7fa fc24 	bl	95e4 <app_at_send_at_rsp_string_lines_with_claim_and_log>
}
    ed9c:	2000      	movs	r0, #0
    ed9e:	bd16      	pop	{r1, r2, r4, pc}
    eda0:	00023887 	.word	0x00023887

0000eda4 <at_handle_CSCON_cmd_read>:
{
    eda4:	b5f0      	push	{r4, r5, r6, r7, lr}
    char      auc_rsp_data[AT_MAX_RSP_LEN] = {0};
    eda6:	24c8      	movs	r4, #200	; 0xc8
{
    eda8:	b0b7      	sub	sp, #220	; 0xdc
    char      auc_rsp_data[AT_MAX_RSP_LEN] = {0};
    edaa:	ad04      	add	r5, sp, #16
    edac:	0022      	movs	r2, r4
    edae:	2100      	movs	r1, #0
    edb0:	0028      	movs	r0, r5
    uint8     connection_status = 0;
    edb2:	270f      	movs	r7, #15
    char      auc_rsp_data[AT_MAX_RSP_LEN] = {0};
    edb4:	f7f1 fa94 	bl	2e0 <memset>
    uint8     connection_status = 0;
    edb8:	2300      	movs	r3, #0
    edba:	446f      	add	r7, sp
    edbc:	703b      	strb	r3, [r7, #0]
    uc_len = (uint16)snprintf(auc_rsp_data, AT_MAX_RSP_LEN, "+CSCON:%d,", app_at_state_info.read_connection_state_mode);
    edbe:	4b18      	ldr	r3, [pc, #96]	; (ee20 <at_handle_CSCON_cmd_read+0x7c>)
    edc0:	4a18      	ldr	r2, [pc, #96]	; (ee24 <at_handle_CSCON_cmd_read+0x80>)
    edc2:	785b      	ldrb	r3, [r3, #1]
    edc4:	0021      	movs	r1, r4
    edc6:	0028      	movs	r0, r5
    edc8:	f00b fd50 	bl	1a86c <snprintf>
    edcc:	0006      	movs	r6, r0
    if (get_connection_status(&connection_status) != NEUL_RET_OK)
    edce:	0038      	movs	r0, r7
    edd0:	f00d fa1b 	bl	1c20a <get_connection_status>
        return AT_RET_PROGRESS_ERROR;
    edd4:	2306      	movs	r3, #6
    if (get_connection_status(&connection_status) != NEUL_RET_OK)
    edd6:	2800      	cmp	r0, #0
    edd8:	d113      	bne.n	ee02 <at_handle_CSCON_cmd_read+0x5e>
    auc_rsp_data[uc_len++] = (char)('0' + connection_status);
    edda:	783b      	ldrb	r3, [r7, #0]
    eddc:	1c70      	adds	r0, r6, #1
    edde:	3330      	adds	r3, #48	; 0x30
    ede0:	b2b6      	uxth	r6, r6
    ede2:	55ab      	strb	r3, [r5, r6]
    if(app_at_state_info.read_connection_state_mode == 2)
    ede4:	4b0e      	ldr	r3, [pc, #56]	; (ee20 <at_handle_CSCON_cmd_read+0x7c>)
    auc_rsp_data[uc_len++] = (char)('0' + connection_status);
    ede6:	b280      	uxth	r0, r0
    if(app_at_state_info.read_connection_state_mode == 2)
    ede8:	785b      	ldrb	r3, [r3, #1]
    edea:	2b02      	cmp	r3, #2
    edec:	d10c      	bne.n	ee08 <at_handle_CSCON_cmd_read+0x64>
        uc_len += (uint16)snprintf(auc_rsp_data + uc_len, AT_MAX_RSP_LEN - uc_len, ",%d", ACT_VALUE_E_UTRAN_NB_S1_MODE);
    edee:	1a21      	subs	r1, r4, r0
    edf0:	3307      	adds	r3, #7
    edf2:	1828      	adds	r0, r5, r0
    edf4:	4a0c      	ldr	r2, [pc, #48]	; (ee28 <at_handle_CSCON_cmd_read+0x84>)
    edf6:	f00b fd39 	bl	1a86c <snprintf>
    app_at_send_at_rsp_string_lines_with_claim_and_log(auc_rsp_data);
    edfa:	0028      	movs	r0, r5
    edfc:	f7fa fbf2 	bl	95e4 <app_at_send_at_rsp_string_lines_with_claim_and_log>
    return AT_RET_OK;
    ee00:	2300      	movs	r3, #0
}
    ee02:	0018      	movs	r0, r3
    ee04:	b037      	add	sp, #220	; 0xdc
    ee06:	bdf0      	pop	{r4, r5, r6, r7, pc}
    else if(app_at_state_info.read_connection_state_mode == 3)
    ee08:	2b03      	cmp	r3, #3
    ee0a:	d1f6      	bne.n	edfa <at_handle_CSCON_cmd_read+0x56>
        uc_len += (uint16)snprintf(auc_rsp_data + uc_len, AT_MAX_RSP_LEN - uc_len, ",%d,%d", ACT_VALUE_E_UTRAN_NB_S1_MODE, ACCESS_E_UTRAN_FDD);
    ee0c:	3301      	adds	r3, #1
    ee0e:	1a21      	subs	r1, r4, r0
    ee10:	9300      	str	r3, [sp, #0]
    ee12:	1828      	adds	r0, r5, r0
    ee14:	3305      	adds	r3, #5
    ee16:	4a05      	ldr	r2, [pc, #20]	; (ee2c <at_handle_CSCON_cmd_read+0x88>)
    ee18:	f00b fd28 	bl	1a86c <snprintf>
    ee1c:	e7ed      	b.n	edfa <at_handle_CSCON_cmd_read+0x56>
    ee1e:	46c0      	nop			; (mov r8, r8)
    ee20:	010024c2 	.word	0x010024c2
    ee24:	00023952 	.word	0x00023952
    ee28:	0002394e 	.word	0x0002394e
    ee2c:	00023734 	.word	0x00023734

0000ee30 <at_handle_CGPADDR_cmd_exec>:
{
    ee30:	b5f0      	push	{r4, r5, r6, r7, lr}
    if (NEUL_RET_OK != get_defined_cids(AT_MAX_CID + 1, &returned_cids, cids))
    ee32:	270e      	movs	r7, #14
{
    ee34:	b0a3      	sub	sp, #140	; 0x8c
    uint8   cids[AT_MAX_CID + 1]    = {0};
    ee36:	ae06      	add	r6, sp, #24
    ee38:	220b      	movs	r2, #11
    ee3a:	2100      	movs	r1, #0
    ee3c:	0030      	movs	r0, r6
    if (NEUL_RET_OK != get_defined_cids(AT_MAX_CID + 1, &returned_cids, cids))
    ee3e:	446f      	add	r7, sp
    uint8   cids[AT_MAX_CID + 1]    = {0};
    ee40:	f7f1 fa4e 	bl	2e0 <memset>
    if (NEUL_RET_OK != get_defined_cids(AT_MAX_CID + 1, &returned_cids, cids))
    ee44:	0032      	movs	r2, r6
    ee46:	0039      	movs	r1, r7
    ee48:	200b      	movs	r0, #11
    ee4a:	f00d fa18 	bl	1c27e <get_defined_cids>
    ee4e:	2800      	cmp	r0, #0
    ee50:	d001      	beq.n	ee56 <at_handle_CGPADDR_cmd_exec+0x26>
    return AT_RET_OK;
    ee52:	2000      	movs	r0, #0
    ee54:	e020      	b.n	ee98 <at_handle_CGPADDR_cmd_exec+0x68>
    if ((getifaddrs(&ifa) != NEUL_RET_OK))  // get IP addresses
    ee56:	a804      	add	r0, sp, #16
    ee58:	f00e f836 	bl	1cec8 <getifaddrs>
    for( int16 i = 0 ; i < returned_cids; i++)
    ee5c:	1e04      	subs	r4, r0, #0
    if ((getifaddrs(&ifa) != NEUL_RET_OK))  // get IP addresses
    ee5e:	d1f8      	bne.n	ee52 <at_handle_CGPADDR_cmd_exec+0x22>
    for( int16 i = 0 ; i < returned_cids; i++)
    ee60:	883b      	ldrh	r3, [r7, #0]
    ee62:	9d04      	ldr	r5, [sp, #16]
    ee64:	429c      	cmp	r4, r3
    ee66:	db05      	blt.n	ee74 <at_handle_CGPADDR_cmd_exec+0x44>
    if (ifa != NULL)
    ee68:	2d00      	cmp	r5, #0
    ee6a:	d0f2      	beq.n	ee52 <at_handle_CGPADDR_cmd_exec+0x22>
        freeifaddrs(ifa);
    ee6c:	0028      	movs	r0, r5
    ee6e:	f00e f81b 	bl	1cea8 <freeifaddrs>
    ee72:	e7ee      	b.n	ee52 <at_handle_CGPADDR_cmd_exec+0x22>
        char    ac_rsp_data[100]        = {0};
    ee74:	2264      	movs	r2, #100	; 0x64
    ee76:	2100      	movs	r1, #0
    ee78:	a809      	add	r0, sp, #36	; 0x24
    ee7a:	f7f1 fa31 	bl	2e0 <memset>
        uint32  uc_cgpaddr_len          = 0;
    ee7e:	2300      	movs	r3, #0
    ee80:	9305      	str	r3, [sp, #20]
        if (get_cgpaddr_cid(cids[i], ifa, &uc_cgpaddr_len, ac_rsp_data, 100) != AT_RET_OK)
    ee82:	3364      	adds	r3, #100	; 0x64
    ee84:	5d30      	ldrb	r0, [r6, r4]
    ee86:	aa05      	add	r2, sp, #20
    ee88:	9300      	str	r3, [sp, #0]
    ee8a:	0029      	movs	r1, r5
    ee8c:	ab09      	add	r3, sp, #36	; 0x24
    ee8e:	f7f9 ff8f 	bl	8db0 <get_cgpaddr_cid>
    ee92:	2800      	cmp	r0, #0
    ee94:	d002      	beq.n	ee9c <at_handle_CGPADDR_cmd_exec+0x6c>
            return AT_RET_PROGRESS_ERROR;
    ee96:	2006      	movs	r0, #6
}
    ee98:	b023      	add	sp, #140	; 0x8c
    ee9a:	bdf0      	pop	{r4, r5, r6, r7, pc}
        at_uart_claim();
    ee9c:	f7fa fd84 	bl	99a8 <at_uart_claim>
        if (uc_cgpaddr_len != 0) // need add "\r\n" if has value to return.
    eea0:	9b05      	ldr	r3, [sp, #20]
    eea2:	2b00      	cmp	r3, #0
    eea4:	d007      	beq.n	eeb6 <at_handle_CGPADDR_cmd_exec+0x86>
            at_uart_write((uint8*)APP_AT_STR_RN, strlen(APP_AT_STR_RN));
    eea6:	4d09      	ldr	r5, [pc, #36]	; (eecc <at_handle_CGPADDR_cmd_exec+0x9c>)
    eea8:	0028      	movs	r0, r5
    eeaa:	f00c fa78 	bl	1b39e <strlen>
    eeae:	0001      	movs	r1, r0
    eeb0:	0028      	movs	r0, r5
    eeb2:	f7fa fd9b 	bl	99ec <at_uart_write>
        app_at_send_at_rsp_string(ac_rsp_data, false, AT_FLAG_LOGABLE | AT_FLAG_LOG_RESTRICTED);
    eeb6:	2228      	movs	r2, #40	; 0x28
    eeb8:	2100      	movs	r1, #0
    eeba:	a809      	add	r0, sp, #36	; 0x24
    eebc:	3401      	adds	r4, #1
    eebe:	f7fa fb83 	bl	95c8 <app_at_send_at_rsp_string>
    eec2:	b224      	sxth	r4, r4
        at_uart_release();
    eec4:	f7fa fd82 	bl	99cc <at_uart_release>
    eec8:	e7ca      	b.n	ee60 <at_handle_CGPADDR_cmd_exec+0x30>
    eeca:	46c0      	nop			; (mov r8, r8)
    eecc:	00022d8f 	.word	0x00022d8f

0000eed0 <at_handle_CGPADDR_cmd_set>:
{
    eed0:	b5f0      	push	{r4, r5, r6, r7, lr}
    eed2:	b0a5      	sub	sp, #148	; 0x94
    uint16              cid[AT_MAX_CID + 1]             = {0};
    eed4:	ae05      	add	r6, sp, #20
{
    eed6:	0004      	movs	r4, r0
    uint16              cid[AT_MAX_CID + 1]             = {0};
    eed8:	2216      	movs	r2, #22
    eeda:	2100      	movs	r1, #0
    eedc:	0030      	movs	r0, r6
    eede:	f7f1 f9ff 	bl	2e0 <memset>
    cause = at_create_param_array(p_atparams_string, &num_recvparams, 1, AT_MAX_CID+1);
    eee2:	230b      	movs	r3, #11
    eee4:	0019      	movs	r1, r3
    eee6:	0020      	movs	r0, r4
    eee8:	2201      	movs	r2, #1
    eeea:	4469      	add	r1, sp
    eeec:	f7fb f9fa 	bl	a2e4 <at_create_param_array>
    eef0:	0005      	movs	r5, r0
    for(i = 0; i < num_recvparams; i++)
    eef2:	1e04      	subs	r4, r0, #0
    if(cause != AT_RET_OK)
    eef4:	d00f      	beq.n	ef16 <at_handle_CGPADDR_cmd_set+0x46>
}
    eef6:	0028      	movs	r0, r5
    eef8:	b025      	add	sp, #148	; 0x94
    eefa:	bdf0      	pop	{r4, r5, r6, r7, pc}
        cause = at_get_uint16_param(i, &cid[i], false);
    eefc:	0067      	lsls	r7, r4, #1
    eefe:	19f1      	adds	r1, r6, r7
    ef00:	2200      	movs	r2, #0
    ef02:	0020      	movs	r0, r4
    ef04:	f7fb fb02 	bl	a50c <at_get_uint16_param>
        if(cause != AT_RET_OK)
    ef08:	2800      	cmp	r0, #0
    ef0a:	d145      	bne.n	ef98 <at_handle_CGPADDR_cmd_set+0xc8>
        if (cid[i] > AT_MAX_CID)
    ef0c:	5bf3      	ldrh	r3, [r6, r7]
    ef0e:	2b0a      	cmp	r3, #10
    ef10:	d844      	bhi.n	ef9c <at_handle_CGPADDR_cmd_set+0xcc>
    for(i = 0; i < num_recvparams; i++)
    ef12:	3401      	adds	r4, #1
    ef14:	b2e4      	uxtb	r4, r4
    ef16:	466b      	mov	r3, sp
    ef18:	7adb      	ldrb	r3, [r3, #11]
    ef1a:	42a3      	cmp	r3, r4
    ef1c:	d8ee      	bhi.n	eefc <at_handle_CGPADDR_cmd_set+0x2c>
    if ((getifaddrs(&ifa) != NEUL_RET_OK))  // get IP addresses
    ef1e:	a803      	add	r0, sp, #12
    ef20:	f00d ffd2 	bl	1cec8 <getifaddrs>
    for(i = 0; i < num_recvparams; i++)
    ef24:	2400      	movs	r4, #0
    if ((getifaddrs(&ifa) != NEUL_RET_OK))  // get IP addresses
    ef26:	42a0      	cmp	r0, r4
    ef28:	d1e5      	bne.n	eef6 <at_handle_CGPADDR_cmd_set+0x26>
    for(i = 0; i < num_recvparams; i++)
    ef2a:	230b      	movs	r3, #11
    ef2c:	446b      	add	r3, sp
    ef2e:	781b      	ldrb	r3, [r3, #0]
    ef30:	9f03      	ldr	r7, [sp, #12]
    ef32:	42a3      	cmp	r3, r4
    ef34:	d805      	bhi.n	ef42 <at_handle_CGPADDR_cmd_set+0x72>
    if (ifa != NULL)
    ef36:	2f00      	cmp	r7, #0
    ef38:	d0dd      	beq.n	eef6 <at_handle_CGPADDR_cmd_set+0x26>
        freeifaddrs(ifa);
    ef3a:	0038      	movs	r0, r7
    ef3c:	f00d ffb4 	bl	1cea8 <freeifaddrs>
    ef40:	e7d9      	b.n	eef6 <at_handle_CGPADDR_cmd_set+0x26>
        char               ac_rsp_data[100]                 = {0};
    ef42:	2264      	movs	r2, #100	; 0x64
    ef44:	2100      	movs	r1, #0
    ef46:	a80b      	add	r0, sp, #44	; 0x2c
    ef48:	f7f1 f9ca 	bl	2e0 <memset>
        uint32             uc_cgpaddr_len                   = 0;
    ef4c:	2300      	movs	r3, #0
    ef4e:	9304      	str	r3, [sp, #16]
        if (get_cgpaddr_cid((int16)cid[i], ifa, &uc_cgpaddr_len, ac_rsp_data, 100) != AT_RET_OK)
    ef50:	0063      	lsls	r3, r4, #1
    ef52:	5ef0      	ldrsh	r0, [r6, r3]
    ef54:	2364      	movs	r3, #100	; 0x64
    ef56:	aa04      	add	r2, sp, #16
    ef58:	9300      	str	r3, [sp, #0]
    ef5a:	0039      	movs	r1, r7
    ef5c:	ab0b      	add	r3, sp, #44	; 0x2c
    ef5e:	f7f9 ff27 	bl	8db0 <get_cgpaddr_cid>
    ef62:	2800      	cmp	r0, #0
    ef64:	d001      	beq.n	ef6a <at_handle_CGPADDR_cmd_set+0x9a>
            return AT_RET_PROGRESS_ERROR;
    ef66:	2506      	movs	r5, #6
    ef68:	e7c5      	b.n	eef6 <at_handle_CGPADDR_cmd_set+0x26>
        at_uart_claim();
    ef6a:	f7fa fd1d 	bl	99a8 <at_uart_claim>
        if (uc_cgpaddr_len != 0) //first reply need add "\r\n"
    ef6e:	9b04      	ldr	r3, [sp, #16]
    ef70:	2b00      	cmp	r3, #0
    ef72:	d007      	beq.n	ef84 <at_handle_CGPADDR_cmd_set+0xb4>
            at_uart_write((uint8*)APP_AT_STR_RN, strlen(APP_AT_STR_RN));
    ef74:	4f0a      	ldr	r7, [pc, #40]	; (efa0 <at_handle_CGPADDR_cmd_set+0xd0>)
    ef76:	0038      	movs	r0, r7
    ef78:	f00c fa11 	bl	1b39e <strlen>
    ef7c:	0001      	movs	r1, r0
    ef7e:	0038      	movs	r0, r7
    ef80:	f7fa fd34 	bl	99ec <at_uart_write>
        app_at_send_at_rsp_string(ac_rsp_data, false, AT_FLAG_LOGABLE | AT_FLAG_LOG_RESTRICTED);
    ef84:	2228      	movs	r2, #40	; 0x28
    ef86:	2100      	movs	r1, #0
    ef88:	a80b      	add	r0, sp, #44	; 0x2c
    for(i = 0; i < num_recvparams; i++)
    ef8a:	3401      	adds	r4, #1
        app_at_send_at_rsp_string(ac_rsp_data, false, AT_FLAG_LOGABLE | AT_FLAG_LOG_RESTRICTED);
    ef8c:	f7fa fb1c 	bl	95c8 <app_at_send_at_rsp_string>
    for(i = 0; i < num_recvparams; i++)
    ef90:	b2e4      	uxtb	r4, r4
        at_uart_release();
    ef92:	f7fa fd1b 	bl	99cc <at_uart_release>
    ef96:	e7c8      	b.n	ef2a <at_handle_CGPADDR_cmd_set+0x5a>
            return AT_RET_SYNTAX_ERROR;
    ef98:	2501      	movs	r5, #1
    ef9a:	e7ac      	b.n	eef6 <at_handle_CGPADDR_cmd_set+0x26>
            return AT_RET_CID_INVALID;
    ef9c:	2511      	movs	r5, #17
    ef9e:	e7aa      	b.n	eef6 <at_handle_CGPADDR_cmd_set+0x26>
    efa0:	00022d8f 	.word	0x00022d8f

0000efa4 <at_handle_CGPADDR_cmd_test>:
{
    efa4:	b530      	push	{r4, r5, lr}
    uint32        uc_cgpaddr_len = 0;
    efa6:	2400      	movs	r4, #0
    char          auc_rsp_data[AT_MAX_RSP_LEN]  = {0};
    efa8:	25c8      	movs	r5, #200	; 0xc8
{
    efaa:	b0b5      	sub	sp, #212	; 0xd4
    char          auc_rsp_data[AT_MAX_RSP_LEN]  = {0};
    efac:	002a      	movs	r2, r5
    efae:	0021      	movs	r1, r4
    efb0:	a802      	add	r0, sp, #8
    uint32        uc_cgpaddr_len = 0;
    efb2:	9401      	str	r4, [sp, #4]
    char          auc_rsp_data[AT_MAX_RSP_LEN]  = {0};
    efb4:	f7f1 f994 	bl	2e0 <memset>
    get_cgpaddr_cid_range(&uc_cgpaddr_len, auc_rsp_data, AT_MAX_RSP_LEN);
    efb8:	002a      	movs	r2, r5
    efba:	a902      	add	r1, sp, #8
    efbc:	a801      	add	r0, sp, #4
    efbe:	f7f9 ff71 	bl	8ea4 <get_cgpaddr_cid_range>
    app_at_send_at_rsp_string_lines_with_claim_and_log(auc_rsp_data);
    efc2:	a802      	add	r0, sp, #8
    efc4:	f7fa fb0e 	bl	95e4 <app_at_send_at_rsp_string_lines_with_claim_and_log>
}
    efc8:	0020      	movs	r0, r4
    efca:	b035      	add	sp, #212	; 0xd4
    efcc:	bd30      	pop	{r4, r5, pc}
	...

0000efd0 <at_handle_CSQ_cmd_exec>:
{
    efd0:	b530      	push	{r4, r5, lr}
    uint8   csq                               = 0;
    efd2:	240b      	movs	r4, #11
    efd4:	2100      	movs	r1, #0
{
    efd6:	b087      	sub	sp, #28
    uint8   csq                               = 0;
    efd8:	446c      	add	r4, sp
    char    auc_rsp_data[AT_CSQ_EXEC_MAX_LEN] = {0};
    efda:	220b      	movs	r2, #11
    efdc:	a803      	add	r0, sp, #12
    uint8   csq                               = 0;
    efde:	7021      	strb	r1, [r4, #0]
    char    auc_rsp_data[AT_CSQ_EXEC_MAX_LEN] = {0};
    efe0:	f7f1 f97e 	bl	2e0 <memset>
    if (get_csq(&csq) != NEUL_RET_OK)
    efe4:	0020      	movs	r0, r4
    efe6:	f00d f889 	bl	1c0fc <get_csq>
    efea:	0005      	movs	r5, r0
        return AT_RET_PROGRESS_ERROR;
    efec:	2006      	movs	r0, #6
    if (get_csq(&csq) != NEUL_RET_OK)
    efee:	2d00      	cmp	r5, #0
    eff0:	d10b      	bne.n	f00a <at_handle_CSQ_cmd_exec+0x3a>
    (void)snprintf(auc_rsp_data, AT_CSQ_EXEC_MAX_LEN, "%s%d,99", AT_CMD_CSQ_PREFIX, csq);
    eff2:	7823      	ldrb	r3, [r4, #0]
    eff4:	4a06      	ldr	r2, [pc, #24]	; (f010 <at_handle_CSQ_cmd_exec+0x40>)
    eff6:	9300      	str	r3, [sp, #0]
    eff8:	210b      	movs	r1, #11
    effa:	4b06      	ldr	r3, [pc, #24]	; (f014 <at_handle_CSQ_cmd_exec+0x44>)
    effc:	a803      	add	r0, sp, #12
    effe:	f00b fc35 	bl	1a86c <snprintf>
    app_at_send_at_rsp_string_lines_with_claim_and_log(auc_rsp_data);
    f002:	a803      	add	r0, sp, #12
    f004:	f7fa faee 	bl	95e4 <app_at_send_at_rsp_string_lines_with_claim_and_log>
    return AT_RET_OK;
    f008:	0028      	movs	r0, r5
}
    f00a:	b007      	add	sp, #28
    f00c:	bd30      	pop	{r4, r5, pc}
    f00e:	46c0      	nop			; (mov r8, r8)
    f010:	00023999 	.word	0x00023999
    f014:	00023993 	.word	0x00023993

0000f018 <at_handle_CIMI_cmd_exec>:
{
    f018:	b5f0      	push	{r4, r5, r6, r7, lr}
    f01a:	b0b9      	sub	sp, #228	; 0xe4
    char     puc_imsi[AT_MAX_IMSI_LEN]     = {0};
    f01c:	af02      	add	r7, sp, #8
    f01e:	2210      	movs	r2, #16
    f020:	2100      	movs	r1, #0
    f022:	0038      	movs	r0, r7
    f024:	f7f1 f95c 	bl	2e0 <memset>
    char     auc_rsp_data[AT_MAX_RSP_LEN]   = {0};
    f028:	22c8      	movs	r2, #200	; 0xc8
    f02a:	2100      	movs	r1, #0
    f02c:	a806      	add	r0, sp, #24
    f02e:	f7f1 f957 	bl	2e0 <memset>
    uint16   uc_imsi_len   = 0;
    f032:	466b      	mov	r3, sp
    f034:	1d9d      	adds	r5, r3, #6
    f036:	2300      	movs	r3, #0
    result = get_imsi(puc_imsi, &uc_imsi_len);
    f038:	0029      	movs	r1, r5
    f03a:	0038      	movs	r0, r7
    uint16   uc_imsi_len   = 0;
    f03c:	802b      	strh	r3, [r5, #0]
    result = get_imsi(puc_imsi, &uc_imsi_len);
    f03e:	f00c fce3 	bl	1ba08 <get_imsi>
    f042:	0004      	movs	r4, r0
    cause = at_parse_convert_neul_result(result);
    f044:	f7fb f924 	bl	a290 <at_parse_convert_neul_result>
    if (result != NEUL_RET_OK)
    f048:	2c00      	cmp	r4, #0
    f04a:	d103      	bne.n	f054 <at_handle_CIMI_cmd_exec+0x3c>
    if (uc_imsi_len != 0)
    f04c:	8828      	ldrh	r0, [r5, #0]
    uint16   uc_len        = 0;
    f04e:	0026      	movs	r6, r4
    if (uc_imsi_len != 0)
    f050:	2800      	cmp	r0, #0
    f052:	d10d      	bne.n	f070 <at_handle_CIMI_cmd_exec+0x58>
}
    f054:	b039      	add	sp, #228	; 0xe4
    f056:	bdf0      	pop	{r4, r5, r6, r7, pc}
            uc_len += (uint16)snprintf(auc_rsp_data + uc_len, AT_MAX_RSP_LEN - uc_len, "%u", (uint8)puc_imsi[uc_loop]);
    f058:	22c8      	movs	r2, #200	; 0xc8
    f05a:	1b91      	subs	r1, r2, r6
    f05c:	aa06      	add	r2, sp, #24
    f05e:	1990      	adds	r0, r2, r6
    f060:	5d3b      	ldrb	r3, [r7, r4]
    f062:	4a07      	ldr	r2, [pc, #28]	; (f080 <at_handle_CIMI_cmd_exec+0x68>)
    f064:	f00b fc02 	bl	1a86c <snprintf>
        for (uc_loop = 0;uc_loop < uc_imsi_len; uc_loop++)
    f068:	3401      	adds	r4, #1
            uc_len += (uint16)snprintf(auc_rsp_data + uc_len, AT_MAX_RSP_LEN - uc_len, "%u", (uint8)puc_imsi[uc_loop]);
    f06a:	1836      	adds	r6, r6, r0
    f06c:	b2b6      	uxth	r6, r6
        for (uc_loop = 0;uc_loop < uc_imsi_len; uc_loop++)
    f06e:	b2a4      	uxth	r4, r4
    f070:	882b      	ldrh	r3, [r5, #0]
    f072:	42a3      	cmp	r3, r4
    f074:	d8f0      	bhi.n	f058 <at_handle_CIMI_cmd_exec+0x40>
        app_at_send_at_rsp_string_lines_with_claim_and_log_restricted(auc_rsp_data);
    f076:	a806      	add	r0, sp, #24
    f078:	f7fa fabb 	bl	95f2 <app_at_send_at_rsp_string_lines_with_claim_and_log_restricted>
    return AT_RET_OK;
    f07c:	2000      	movs	r0, #0
    f07e:	e7e9      	b.n	f054 <at_handle_CIMI_cmd_exec+0x3c>
    f080:	00024fe2 	.word	0x00024fe2

0000f084 <at_handle_NRB_cmd_exec>:
{
    f084:	b510      	push	{r4, lr}
    app_at_send_at_rsp_string_lines_with_claim_and_log(AT_NRB_EXEC_RSP);
    f086:	4807      	ldr	r0, [pc, #28]	; (f0a4 <at_handle_NRB_cmd_exec+0x20>)
    f088:	f7fa faac 	bl	95e4 <app_at_send_at_rsp_string_lines_with_claim_and_log>
    prepare_for_powerdown();
    f08c:	f00d fe57 	bl	1cd3e <prepare_for_powerdown>
    non_os_enter_critical();
    f090:	f009 f890 	bl	181b4 <non_os_enter_critical>
    request_reboot(REBOOT_CAUSE_APPLICATION_AT);
    f094:	4804      	ldr	r0, [pc, #16]	; (f0a8 <at_handle_NRB_cmd_exec+0x24>)
    f096:	f00d fd3f 	bl	1cb18 <request_reboot>
    non_os_exit_critical();
    f09a:	f009 f89f 	bl	181dc <non_os_exit_critical>
}
    f09e:	2000      	movs	r0, #0
    f0a0:	bd10      	pop	{r4, pc}
    f0a2:	46c0      	nop			; (mov r8, r8)
    f0a4:	00023d42 	.word	0x00023d42
    f0a8:	00002101 	.word	0x00002101

0000f0ac <at_handle_CFUN_cmd_read>:
{
    f0ac:	b530      	push	{r4, r5, lr}
    f0ae:	b085      	sub	sp, #20
    char    rsp_string[AT_MAX_CFUN_READ_RSP_LEN] = {0};
    f0b0:	220a      	movs	r2, #10
    f0b2:	2100      	movs	r1, #0
    f0b4:	a801      	add	r0, sp, #4
    f0b6:	f7f1 f913 	bl	2e0 <memset>
    if (get_cfun(&current_cfun_setting) != NEUL_RET_OK)
    f0ba:	466b      	mov	r3, sp
    f0bc:	1c9d      	adds	r5, r3, #2
    f0be:	0028      	movs	r0, r5
    f0c0:	f00d f8ce 	bl	1c260 <get_cfun>
    f0c4:	0004      	movs	r4, r0
        return AT_RET_PROGRESS_ERROR;
    f0c6:	2006      	movs	r0, #6
    if (get_cfun(&current_cfun_setting) != NEUL_RET_OK)
    f0c8:	2c00      	cmp	r4, #0
    f0ca:	d109      	bne.n	f0e0 <at_handle_CFUN_cmd_read+0x34>
    (void)snprintf(rsp_string, AT_MAX_CFUN_READ_RSP_LEN, "+CFUN:%d", current_cfun_setting);
    f0cc:	882b      	ldrh	r3, [r5, #0]
    f0ce:	4a05      	ldr	r2, [pc, #20]	; (f0e4 <at_handle_CFUN_cmd_read+0x38>)
    f0d0:	210a      	movs	r1, #10
    f0d2:	a801      	add	r0, sp, #4
    f0d4:	f00b fbca 	bl	1a86c <snprintf>
    app_at_send_at_rsp_string_lines_with_claim_and_log(rsp_string);
    f0d8:	a801      	add	r0, sp, #4
    f0da:	f7fa fa83 	bl	95e4 <app_at_send_at_rsp_string_lines_with_claim_and_log>
    return AT_RET_OK;
    f0de:	0020      	movs	r0, r4
}
    f0e0:	b005      	add	sp, #20
    f0e2:	bd30      	pop	{r4, r5, pc}
    f0e4:	00023653 	.word	0x00023653

0000f0e8 <at_handle_NCHIPINFO_cmd_set>:
{
    f0e8:	b5f0      	push	{r4, r5, r6, r7, lr}
    char                nchipinfo_rsp[AT_MAX_NCHIPINFO_RSP_LEN]       = {0};
    f0ea:	242f      	movs	r4, #47	; 0x2f
{
    f0ec:	b097      	sub	sp, #92	; 0x5c
    f0ee:	0005      	movs	r5, r0
    uint8               str_function[AT_CMD_NCHIPINFO_PREFIX_LEN]   = {0};
    f0f0:	2205      	movs	r2, #5
    f0f2:	2100      	movs	r1, #0
    f0f4:	a806      	add	r0, sp, #24
    f0f6:	f7f1 f8f3 	bl	2e0 <memset>
    char                nchipinfo_rsp[AT_MAX_NCHIPINFO_RSP_LEN]       = {0};
    f0fa:	0022      	movs	r2, r4
    f0fc:	2100      	movs	r1, #0
    f0fe:	a80a      	add	r0, sp, #40	; 0x28
    f100:	f7f1 f8ee 	bl	2e0 <memset>
    if (at_create_param_array(p_atparams_string, &num_recvparams, 1, 1) != AT_RET_OK)
    f104:	2301      	movs	r3, #1
    f106:	2117      	movs	r1, #23
    f108:	001a      	movs	r2, r3
    f10a:	4469      	add	r1, sp
    f10c:	0028      	movs	r0, r5
    f10e:	f7fb f8e9 	bl	a2e4 <at_create_param_array>
    f112:	2800      	cmp	r0, #0
    f114:	d003      	beq.n	f11e <at_handle_NCHIPINFO_cmd_set+0x36>
       return AT_RET_SYNTAX_ERROR;
    f116:	2601      	movs	r6, #1
}
    f118:	0030      	movs	r0, r6
    f11a:	b017      	add	sp, #92	; 0x5c
    f11c:	bdf0      	pop	{r4, r5, r6, r7, pc}
    if (at_get_string_param(AT_PARSE_FIRST_PARAM_POS, str_function, AT_CMD_NCHIPINFO_PREFIX_LEN, true) != AT_RET_OK)
    f11e:	2301      	movs	r3, #1
    f120:	2205      	movs	r2, #5
    f122:	a906      	add	r1, sp, #24
    f124:	f7fb fb30 	bl	a788 <at_get_string_param>
    f128:	1e06      	subs	r6, r0, #0
    f12a:	d1f4      	bne.n	f116 <at_handle_NCHIPINFO_cmd_set+0x2e>
    if (get_chipinfo(&chipinfo) != NEUL_RET_OK)
    f12c:	ad08      	add	r5, sp, #32
    f12e:	0028      	movs	r0, r5
    f130:	f00d fddc 	bl	1ccec <get_chipinfo>
    f134:	2800      	cmp	r0, #0
    f136:	d15b      	bne.n	f1f0 <at_handle_NCHIPINFO_cmd_set+0x108>
    if (at_strcmp(str_function, AT_CMD_ALL_STR) == 0)
    f138:	492e      	ldr	r1, [pc, #184]	; (f1f4 <at_handle_NCHIPINFO_cmd_set+0x10c>)
    f13a:	a806      	add	r0, sp, #24
    f13c:	f00c f910 	bl	1b360 <strcmp>
    f140:	2800      	cmp	r0, #0
    f142:	d124      	bne.n	f18e <at_handle_NCHIPINFO_cmd_set+0xa6>
        rsp_len  = (uint16)snprintf(nchipinfo_rsp, AT_MAX_NCHIPINFO_RSP_LEN, "%s%s,%2d.%1d\r\n", AT_CMD_NCHIPINFO_PREFIX_STR, AT_CMD_NCHIPINFO_TEMP_STR, chipinfo.temp / 10 , abs(chipinfo.temp) % 10);
    f144:	2304      	movs	r3, #4
    f146:	5eef      	ldrsh	r7, [r5, r3]
    f148:	0038      	movs	r0, r7
    f14a:	f00c f811 	bl	1b170 <abs>
    f14e:	210a      	movs	r1, #10
    f150:	f7f1 faa2 	bl	698 <__aeabi_idivmod>
    f154:	0038      	movs	r0, r7
    f156:	9102      	str	r1, [sp, #8]
    f158:	210a      	movs	r1, #10
    f15a:	f7f1 f9b7 	bl	4cc <__divsi3>
    f15e:	4b26      	ldr	r3, [pc, #152]	; (f1f8 <at_handle_NCHIPINFO_cmd_set+0x110>)
    f160:	b200      	sxth	r0, r0
    f162:	4a26      	ldr	r2, [pc, #152]	; (f1fc <at_handle_NCHIPINFO_cmd_set+0x114>)
    f164:	9001      	str	r0, [sp, #4]
    f166:	9300      	str	r3, [sp, #0]
    f168:	0021      	movs	r1, r4
    f16a:	4b25      	ldr	r3, [pc, #148]	; (f200 <at_handle_NCHIPINFO_cmd_set+0x118>)
    f16c:	a80a      	add	r0, sp, #40	; 0x28
    f16e:	f00b fb7d 	bl	1a86c <snprintf>
        rsp_len += (uint16)snprintf(nchipinfo_rsp + rsp_len, AT_MAX_NCHIPINFO_RSP_LEN - rsp_len, "%s%s,%d", AT_CMD_NCHIPINFO_PREFIX_STR, AT_CMD_NCHIPINFO_VBAT_STR, chipinfo.vbat);
    f172:	ab0a      	add	r3, sp, #40	; 0x28
    f174:	b280      	uxth	r0, r0
    f176:	1a21      	subs	r1, r4, r0
    f178:	1818      	adds	r0, r3, r0
    f17a:	2202      	movs	r2, #2
    f17c:	5eab      	ldrsh	r3, [r5, r2]
    f17e:	4a21      	ldr	r2, [pc, #132]	; (f204 <at_handle_NCHIPINFO_cmd_set+0x11c>)
    f180:	9301      	str	r3, [sp, #4]
    f182:	4b21      	ldr	r3, [pc, #132]	; (f208 <at_handle_NCHIPINFO_cmd_set+0x120>)
    f184:	9300      	str	r3, [sp, #0]
    f186:	4b1e      	ldr	r3, [pc, #120]	; (f200 <at_handle_NCHIPINFO_cmd_set+0x118>)
        (void)snprintf(nchipinfo_rsp, AT_MAX_NCHIPINFO_RSP_LEN, "%s%s,%d", AT_CMD_NCHIPINFO_PREFIX_STR, AT_CMD_NCHIPINFO_VBAT_STR, chipinfo.vbat);
    f188:	f00b fb70 	bl	1a86c <snprintf>
    f18c:	e01c      	b.n	f1c8 <at_handle_NCHIPINFO_cmd_set+0xe0>
    else if (at_strcmp(str_function, AT_CMD_NCHIPINFO_TEMP_STR) == 0)
    f18e:	4f1a      	ldr	r7, [pc, #104]	; (f1f8 <at_handle_NCHIPINFO_cmd_set+0x110>)
    f190:	a806      	add	r0, sp, #24
    f192:	0039      	movs	r1, r7
    f194:	f00c f8e4 	bl	1b360 <strcmp>
    f198:	2800      	cmp	r0, #0
    f19a:	d119      	bne.n	f1d0 <at_handle_NCHIPINFO_cmd_set+0xe8>
        (void)snprintf(nchipinfo_rsp, AT_MAX_NCHIPINFO_RSP_LEN, "%s%s,%2d.%1d", AT_CMD_NCHIPINFO_PREFIX_STR, AT_CMD_NCHIPINFO_TEMP_STR, chipinfo.temp / 10, abs(chipinfo.temp) % 10);
    f19c:	2304      	movs	r3, #4
    f19e:	5eed      	ldrsh	r5, [r5, r3]
    f1a0:	0028      	movs	r0, r5
    f1a2:	f00b ffe5 	bl	1b170 <abs>
    f1a6:	210a      	movs	r1, #10
    f1a8:	f7f1 fa76 	bl	698 <__aeabi_idivmod>
    f1ac:	0028      	movs	r0, r5
    f1ae:	9102      	str	r1, [sp, #8]
    f1b0:	210a      	movs	r1, #10
    f1b2:	f7f1 f98b 	bl	4cc <__divsi3>
    f1b6:	b200      	sxth	r0, r0
    f1b8:	9001      	str	r0, [sp, #4]
    f1ba:	9700      	str	r7, [sp, #0]
    f1bc:	4b10      	ldr	r3, [pc, #64]	; (f200 <at_handle_NCHIPINFO_cmd_set+0x118>)
    f1be:	4a13      	ldr	r2, [pc, #76]	; (f20c <at_handle_NCHIPINFO_cmd_set+0x124>)
    f1c0:	0021      	movs	r1, r4
    f1c2:	a80a      	add	r0, sp, #40	; 0x28
    f1c4:	f00b fb52 	bl	1a86c <snprintf>
    app_at_send_at_rsp_string_lines_with_claim_and_log(nchipinfo_rsp);
    f1c8:	a80a      	add	r0, sp, #40	; 0x28
    f1ca:	f7fa fa0b 	bl	95e4 <app_at_send_at_rsp_string_lines_with_claim_and_log>
    return AT_RET_OK;
    f1ce:	e7a3      	b.n	f118 <at_handle_NCHIPINFO_cmd_set+0x30>
    else if (at_strcmp(str_function, AT_CMD_NCHIPINFO_VBAT_STR) == 0)
    f1d0:	4f0d      	ldr	r7, [pc, #52]	; (f208 <at_handle_NCHIPINFO_cmd_set+0x120>)
    f1d2:	a806      	add	r0, sp, #24
    f1d4:	0039      	movs	r1, r7
    f1d6:	f00c f8c3 	bl	1b360 <strcmp>
    f1da:	2800      	cmp	r0, #0
    f1dc:	d19b      	bne.n	f116 <at_handle_NCHIPINFO_cmd_set+0x2e>
        (void)snprintf(nchipinfo_rsp, AT_MAX_NCHIPINFO_RSP_LEN, "%s%s,%d", AT_CMD_NCHIPINFO_PREFIX_STR, AT_CMD_NCHIPINFO_VBAT_STR, chipinfo.vbat);
    f1de:	2202      	movs	r2, #2
    f1e0:	5eab      	ldrsh	r3, [r5, r2]
    f1e2:	0021      	movs	r1, r4
    f1e4:	9301      	str	r3, [sp, #4]
    f1e6:	9700      	str	r7, [sp, #0]
    f1e8:	4b05      	ldr	r3, [pc, #20]	; (f200 <at_handle_NCHIPINFO_cmd_set+0x118>)
    f1ea:	4a06      	ldr	r2, [pc, #24]	; (f204 <at_handle_NCHIPINFO_cmd_set+0x11c>)
    f1ec:	a80a      	add	r0, sp, #40	; 0x28
    f1ee:	e7cb      	b.n	f188 <at_handle_NCHIPINFO_cmd_set+0xa0>
        return AT_RET_PROGRESS_ERROR;
    f1f0:	2606      	movs	r6, #6
    f1f2:	e791      	b.n	f118 <at_handle_NCHIPINFO_cmd_set+0x30>
    f1f4:	00023a74 	.word	0x00023a74
    f1f8:	00023a93 	.word	0x00023a93
    f1fc:	00023a84 	.word	0x00023a84
    f200:	00023a78 	.word	0x00023a78
    f204:	00023ae4 	.word	0x00023ae4
    f208:	00023a98 	.word	0x00023a98
    f20c:	00023a9d 	.word	0x00023a9d

0000f210 <at_handle_NRDTEST_set>:
{
    f210:	b530      	push	{r4, r5, lr}
    uint8            *data_string = NULL;
    f212:	2300      	movs	r3, #0
{
    f214:	b085      	sub	sp, #20
    cause = at_create_param_array(p_atparams_string, &num_recvparams, 2, 2);
    f216:	4669      	mov	r1, sp
    uint8            *data_string = NULL;
    f218:	9303      	str	r3, [sp, #12]
    cause = at_create_param_array(p_atparams_string, &num_recvparams, 2, 2);
    f21a:	3302      	adds	r3, #2
    f21c:	001a      	movs	r2, r3
    f21e:	3107      	adds	r1, #7
    f220:	f7fb f860 	bl	a2e4 <at_create_param_array>
    if(cause != AT_RET_OK)
    f224:	2800      	cmp	r0, #0
    f226:	d107      	bne.n	f238 <at_handle_NRDTEST_set+0x28>
    cause = at_get_uint16_param(AT_PARSE_FIRST_PARAM_POS, &data_len, true);
    f228:	ac02      	add	r4, sp, #8
    f22a:	2201      	movs	r2, #1
    f22c:	0021      	movs	r1, r4
    f22e:	f7fb f96d 	bl	a50c <at_get_uint16_param>
    if (cause != AT_RET_OK)
    f232:	2800      	cmp	r0, #0
    f234:	d002      	beq.n	f23c <at_handle_NRDTEST_set+0x2c>
        return AT_RET_SYNTAX_ERROR;
    f236:	2001      	movs	r0, #1
}
    f238:	b005      	add	sp, #20
    f23a:	bd30      	pop	{r4, r5, pc}
    if (data_len == 0)
    f23c:	8823      	ldrh	r3, [r4, #0]
    f23e:	2b00      	cmp	r3, #0
    f240:	d0f9      	beq.n	f236 <at_handle_NRDTEST_set+0x26>
    cause = at_get_hexstring_param(AT_PARSE_SECOND_PARAM_POS, &data_string, &data_string_len, true);
    f242:	250a      	movs	r5, #10
    f244:	2301      	movs	r3, #1
    f246:	446d      	add	r5, sp
    f248:	002a      	movs	r2, r5
    f24a:	a903      	add	r1, sp, #12
    f24c:	0018      	movs	r0, r3
    f24e:	f7fb faed 	bl	a82c <at_get_hexstring_param>
    if(cause != AT_RET_OK)
    f252:	2800      	cmp	r0, #0
    f254:	d1ef      	bne.n	f236 <at_handle_NRDTEST_set+0x26>
    if (data_len * 2 != data_string_len)
    f256:	8822      	ldrh	r2, [r4, #0]
    f258:	882b      	ldrh	r3, [r5, #0]
    f25a:	0052      	lsls	r2, r2, #1
    f25c:	429a      	cmp	r2, r3
    f25e:	d1ea      	bne.n	f236 <at_handle_NRDTEST_set+0x26>
    if (at_parse_buf_hex_to_uint8(data_string, data_string, (uint16)(data_len * 2)) == false)
    f260:	9903      	ldr	r1, [sp, #12]
    f262:	b292      	uxth	r2, r2
    f264:	0008      	movs	r0, r1
    f266:	f7fa ff8c 	bl	a182 <at_parse_buf_hex_to_uint8>
    f26a:	2800      	cmp	r0, #0
    f26c:	d0e3      	beq.n	f236 <at_handle_NRDTEST_set+0x26>
    neul_ret = production_execute_radiotest(data_len, data_string, nrdtest_callback);
    f26e:	8820      	ldrh	r0, [r4, #0]
    f270:	4a04      	ldr	r2, [pc, #16]	; (f284 <at_handle_NRDTEST_set+0x74>)
    f272:	9903      	ldr	r1, [sp, #12]
    f274:	f00c fd16 	bl	1bca4 <production_execute_radiotest>
    if (neul_ret == NEUL_RET_IN_PROGRESS)
    f278:	2809      	cmp	r0, #9
    f27a:	d0dd      	beq.n	f238 <at_handle_NRDTEST_set+0x28>
    return at_parse_convert_neul_result(neul_ret);
    f27c:	f7fb f808 	bl	a290 <at_parse_convert_neul_result>
    f280:	e7da      	b.n	f238 <at_handle_NRDTEST_set+0x28>
    f282:	46c0      	nop			; (mov r8, r8)
    f284:	00010b2d 	.word	0x00010b2d

0000f288 <at_handle_NBAND_test>:
{
    f288:	b5f0      	push	{r4, r5, r6, r7, lr}
    f28a:	b099      	sub	sp, #100	; 0x64
    uint8   support_band_value[AT_MAX_BAND_NUMBER] = {0};
    f28c:	af01      	add	r7, sp, #4
    f28e:	2214      	movs	r2, #20
    f290:	2100      	movs	r1, #0
    f292:	0038      	movs	r0, r7
    f294:	f7f1 f824 	bl	2e0 <memset>
    uint16  support_band_num                       = 0;
    f298:	2400      	movs	r4, #0
    f29a:	466b      	mov	r3, sp
    char    rsp_string[AT_MAX_NBAND_TEST_RSP_LEN]  = {0};
    f29c:	2245      	movs	r2, #69	; 0x45
    uint16  support_band_num                       = 0;
    f29e:	1c9e      	adds	r6, r3, #2
    char    rsp_string[AT_MAX_NBAND_TEST_RSP_LEN]  = {0};
    f2a0:	0021      	movs	r1, r4
    f2a2:	a806      	add	r0, sp, #24
    uint16  support_band_num                       = 0;
    f2a4:	8034      	strh	r4, [r6, #0]
    char    rsp_string[AT_MAX_NBAND_TEST_RSP_LEN]  = {0};
    f2a6:	f7f1 f81b 	bl	2e0 <memset>
    len += (uint16)snprintf(rsp_string, AT_MAX_NBAND_TEST_RSP_LEN, "%s(", AT_CMD_NBAND_PREFIX);
    f2aa:	4b1a      	ldr	r3, [pc, #104]	; (f314 <at_handle_NBAND_test+0x8c>)
    f2ac:	4a1a      	ldr	r2, [pc, #104]	; (f318 <at_handle_NBAND_test+0x90>)
    f2ae:	2145      	movs	r1, #69	; 0x45
    f2b0:	a806      	add	r0, sp, #24
    f2b2:	f00b fadb 	bl	1a86c <snprintf>
    if (get_support_bands(AT_MAX_BAND_NUMBER, &support_band_num, support_band_value)  == NEUL_RET_ERROR)
    f2b6:	003a      	movs	r2, r7
    len += (uint16)snprintf(rsp_string, AT_MAX_NBAND_TEST_RSP_LEN, "%s(", AT_CMD_NBAND_PREFIX);
    f2b8:	b285      	uxth	r5, r0
    if (get_support_bands(AT_MAX_BAND_NUMBER, &support_band_num, support_band_value)  == NEUL_RET_ERROR)
    f2ba:	0031      	movs	r1, r6
    f2bc:	2014      	movs	r0, #20
    f2be:	f00c ff8a 	bl	1c1d6 <get_support_bands>
        return AT_RET_PROGRESS_ERROR;
    f2c2:	2306      	movs	r3, #6
    if (get_support_bands(AT_MAX_BAND_NUMBER, &support_band_num, support_band_value)  == NEUL_RET_ERROR)
    f2c4:	2801      	cmp	r0, #1
    f2c6:	d00d      	beq.n	f2e4 <at_handle_NBAND_test+0x5c>
    f2c8:	ab06      	add	r3, sp, #24
    f2ca:	1958      	adds	r0, r3, r5
    f2cc:	2345      	movs	r3, #69	; 0x45
    f2ce:	1b59      	subs	r1, r3, r5
    for (loop = 0; loop < support_band_num; loop++)
    f2d0:	8833      	ldrh	r3, [r6, #0]
    f2d2:	42a3      	cmp	r3, r4
    f2d4:	d809      	bhi.n	f2ea <at_handle_NBAND_test+0x62>
    len += (uint16)snprintf(rsp_string + len, AT_MAX_NBAND_TEST_RSP_LEN - len, ")");
    f2d6:	4a11      	ldr	r2, [pc, #68]	; (f31c <at_handle_NBAND_test+0x94>)
    f2d8:	f00b fac8 	bl	1a86c <snprintf>
    app_at_send_at_rsp_string_lines_with_claim_and_log(rsp_string);
    f2dc:	a806      	add	r0, sp, #24
    f2de:	f7fa f981 	bl	95e4 <app_at_send_at_rsp_string_lines_with_claim_and_log>
    return AT_RET_OK;
    f2e2:	2300      	movs	r3, #0
}
    f2e4:	0018      	movs	r0, r3
    f2e6:	b019      	add	sp, #100	; 0x64
    f2e8:	bdf0      	pop	{r4, r5, r6, r7, pc}
        if (loop != 0)
    f2ea:	2c00      	cmp	r4, #0
    f2ec:	d004      	beq.n	f2f8 <at_handle_NBAND_test+0x70>
            len += (uint16)snprintf(rsp_string + len, AT_MAX_NBAND_TEST_RSP_LEN - len, ",");
    f2ee:	4a0c      	ldr	r2, [pc, #48]	; (f320 <at_handle_NBAND_test+0x98>)
    f2f0:	f00b fabc 	bl	1a86c <snprintf>
    f2f4:	182d      	adds	r5, r5, r0
    f2f6:	b2ad      	uxth	r5, r5
        len += (uint16)snprintf(rsp_string + len, AT_MAX_NBAND_TEST_RSP_LEN - len, "%d", support_band_value[loop]);
    f2f8:	2245      	movs	r2, #69	; 0x45
    f2fa:	1b51      	subs	r1, r2, r5
    f2fc:	aa06      	add	r2, sp, #24
    f2fe:	1950      	adds	r0, r2, r5
    f300:	5d3b      	ldrb	r3, [r7, r4]
    f302:	4a08      	ldr	r2, [pc, #32]	; (f324 <at_handle_NBAND_test+0x9c>)
    f304:	f00b fab2 	bl	1a86c <snprintf>
    for (loop = 0; loop < support_band_num; loop++)
    f308:	3401      	adds	r4, #1
        len += (uint16)snprintf(rsp_string + len, AT_MAX_NBAND_TEST_RSP_LEN - len, "%d", support_band_value[loop]);
    f30a:	182d      	adds	r5, r5, r0
    f30c:	b2ad      	uxth	r5, r5
    for (loop = 0; loop < support_band_num; loop++)
    f30e:	b2e4      	uxtb	r4, r4
    f310:	e7da      	b.n	f2c8 <at_handle_NBAND_test+0x40>
    f312:	46c0      	nop			; (mov r8, r8)
    f314:	00023a64 	.word	0x00023a64
    f318:	0002379f 	.word	0x0002379f
    f31c:	00023d40 	.word	0x00023d40
    f320:	00024ab6 	.word	0x00024ab6
    f324:	00022e8f 	.word	0x00022e8f

0000f328 <at_handle_NBAND_set>:
{
    f328:	b5f0      	push	{r4, r5, r6, r7, lr}
    uint8             num_recvparams                    = 0;
    f32a:	2400      	movs	r4, #0
{
    f32c:	b087      	sub	sp, #28
    uint8             num_recvparams                    = 0;
    f32e:	466b      	mov	r3, sp
    uint8             band_value[AT_MAX_BAND_NUMBER]    = {0};
    f330:	ad01      	add	r5, sp, #4
{
    f332:	0006      	movs	r6, r0
    uint8             band_value[AT_MAX_BAND_NUMBER]    = {0};
    f334:	2214      	movs	r2, #20
    f336:	0021      	movs	r1, r4
    f338:	0028      	movs	r0, r5
    uint8             num_recvparams                    = 0;
    f33a:	705c      	strb	r4, [r3, #1]
    uint8             band_value[AT_MAX_BAND_NUMBER]    = {0};
    f33c:	f7f0 ffd0 	bl	2e0 <memset>
    uint16            band                              = 0;
    f340:	466b      	mov	r3, sp
    cause = at_create_param_array(p_atparams_string, &num_recvparams, 1, AT_MAX_BAND_NUMBER);
    f342:	2201      	movs	r2, #1
    f344:	4669      	mov	r1, sp
    uint16            band                              = 0;
    f346:	1c9f      	adds	r7, r3, #2
    cause = at_create_param_array(p_atparams_string, &num_recvparams, 1, AT_MAX_BAND_NUMBER);
    f348:	1889      	adds	r1, r1, r2
    f34a:	2314      	movs	r3, #20
    f34c:	0030      	movs	r0, r6
    uint16            band                              = 0;
    f34e:	803c      	strh	r4, [r7, #0]
    cause = at_create_param_array(p_atparams_string, &num_recvparams, 1, AT_MAX_BAND_NUMBER);
    f350:	f7fa ffc8 	bl	a2e4 <at_create_param_array>
    if(cause != AT_RET_OK)
    f354:	42a0      	cmp	r0, r4
    f356:	d123      	bne.n	f3a0 <at_handle_NBAND_set+0x78>
    for(band_value_index = 0; band_value_index < num_recvparams; band_value_index++)
    f358:	0006      	movs	r6, r0
    uint8             loop,num_bands                    = 0;
    f35a:	0004      	movs	r4, r0
    for(band_value_index = 0; band_value_index < num_recvparams; band_value_index++)
    f35c:	466b      	mov	r3, sp
    f35e:	785b      	ldrb	r3, [r3, #1]
    f360:	42b3      	cmp	r3, r6
    f362:	d806      	bhi.n	f372 <at_handle_NBAND_set+0x4a>
    result = set_bands(num_bands, band_value);
    f364:	0029      	movs	r1, r5
    f366:	0020      	movs	r0, r4
    f368:	f00c ff17 	bl	1c19a <set_bands>
    return at_parse_convert_neul_result(result);
    f36c:	f7fa ff90 	bl	a290 <at_parse_convert_neul_result>
    f370:	e016      	b.n	f3a0 <at_handle_NBAND_set+0x78>
        if (at_get_uint16_param(band_value_index, &band, true) != AT_RET_OK)
    f372:	2201      	movs	r2, #1
    f374:	0039      	movs	r1, r7
    f376:	0030      	movs	r0, r6
    f378:	f7fb f8c8 	bl	a50c <at_get_uint16_param>
    f37c:	2800      	cmp	r0, #0
    f37e:	d10e      	bne.n	f39e <at_handle_NBAND_set+0x76>
            if (band_value[loop] == band)
    f380:	883b      	ldrh	r3, [r7, #0]
        for (loop = 0; loop < num_bands; loop++)
    f382:	b2c2      	uxtb	r2, r0
    f384:	4294      	cmp	r4, r2
    f386:	d803      	bhi.n	f390 <at_handle_NBAND_set+0x68>
            band_value[num_bands] = (uint8)band;
    f388:	552b      	strb	r3, [r5, r4]
            num_bands++;
    f38a:	3401      	adds	r4, #1
    f38c:	b2e4      	uxtb	r4, r4
    f38e:	e003      	b.n	f398 <at_handle_NBAND_set+0x70>
            if (band_value[loop] == band)
    f390:	5c2a      	ldrb	r2, [r5, r0]
    f392:	3001      	adds	r0, #1
    f394:	429a      	cmp	r2, r3
    f396:	d1f4      	bne.n	f382 <at_handle_NBAND_set+0x5a>
    for(band_value_index = 0; band_value_index < num_recvparams; band_value_index++)
    f398:	3601      	adds	r6, #1
    f39a:	b2f6      	uxtb	r6, r6
    f39c:	e7de      	b.n	f35c <at_handle_NBAND_set+0x34>
        return AT_RET_PROGRESS_ERROR;
    f39e:	2006      	movs	r0, #6
}
    f3a0:	b007      	add	sp, #28
    f3a2:	bdf0      	pop	{r4, r5, r6, r7, pc}

0000f3a4 <at_handle_UE_STATS_cmd_exec>:
{
    f3a4:	b510      	push	{r4, lr}
    f3a6:	b098      	sub	sp, #96	; 0x60
    ue_stats  ue_stats_bin = {0};
    f3a8:	2260      	movs	r2, #96	; 0x60
    f3aa:	2100      	movs	r1, #0
    f3ac:	4668      	mov	r0, sp
    f3ae:	f7f0 ff97 	bl	2e0 <memset>
    if (get_ue_stats(&ue_stats_bin) != 0)
    f3b2:	4668      	mov	r0, sp
    f3b4:	f00d fcc7 	bl	1cd46 <get_ue_stats>
    f3b8:	0004      	movs	r4, r0
        return AT_RET_PROGRESS_ERROR;
    f3ba:	2006      	movs	r0, #6
    if (get_ue_stats(&ue_stats_bin) != 0)
    f3bc:	2c00      	cmp	r4, #0
    f3be:	d104      	bne.n	f3ca <at_handle_UE_STATS_cmd_exec+0x26>
    output_ue_stats_radio(&ue_stats_bin, false);
    f3c0:	4668      	mov	r0, sp
    f3c2:	0021      	movs	r1, r4
    f3c4:	f7fd fc32 	bl	cc2c <output_ue_stats_radio>
    return AT_RET_OK;
    f3c8:	0020      	movs	r0, r4
}
    f3ca:	b018      	add	sp, #96	; 0x60
    f3cc:	bd10      	pop	{r4, pc}
	...

0000f3d0 <output_ue_stats_cell>:
{
    f3d0:	b5f0      	push	{r4, r5, r6, r7, lr}
    uint8           cell_info_num                               = 0;
    f3d2:	2400      	movs	r4, #0
    f3d4:	261b      	movs	r6, #27
{
    f3d6:	b0bd      	sub	sp, #244	; 0xf4
    uint8           cell_info_num                               = 0;
    f3d8:	446e      	add	r6, sp
    char            ue_stats_rsp[AT_MAX_UESTATS_CELL_RSP_LEN]   = {0};
    f3da:	2232      	movs	r2, #50	; 0x32
    f3dc:	0021      	movs	r1, r4
    f3de:	a807      	add	r0, sp, #28
    uint8           cell_info_num                               = 0;
    f3e0:	7034      	strb	r4, [r6, #0]
    char            ue_stats_rsp[AT_MAX_UESTATS_CELL_RSP_LEN]   = {0};
    f3e2:	f7f0 ff7d 	bl	2e0 <memset>
    memset((char *)cell_info, 0, sizeof(ue_cell_info)*UE_MAX_CELL_INFO_NUM);
    f3e6:	22a0      	movs	r2, #160	; 0xa0
    f3e8:	0021      	movs	r1, r4
    f3ea:	a814      	add	r0, sp, #80	; 0x50
    f3ec:	f7f0 ff78 	bl	2e0 <memset>
    result = get_cell_info(UE_MAX_CELL_INFO_NUM, &cell_info_num, cell_info);
    f3f0:	aa14      	add	r2, sp, #80	; 0x50
    f3f2:	0031      	movs	r1, r6
    f3f4:	200a      	movs	r0, #10
    f3f6:	f00d fcc0 	bl	1cd7a <get_cell_info>
    if(result != NEUL_RET_OK)
    f3fa:	42a0      	cmp	r0, r4
    f3fc:	d105      	bne.n	f40a <output_ue_stats_cell+0x3a>
    for (int index = 0; index < cell_info_num; index++)
    f3fe:	0005      	movs	r5, r0
    f400:	3452      	adds	r4, #82	; 0x52
    f402:	446c      	add	r4, sp
    f404:	7833      	ldrb	r3, [r6, #0]
    f406:	42ab      	cmp	r3, r5
    f408:	dc01      	bgt.n	f40e <output_ue_stats_cell+0x3e>
}
    f40a:	b03d      	add	sp, #244	; 0xf4
    f40c:	bdf0      	pop	{r4, r5, r6, r7, pc}
        buffer_length = (uint16)snprintf(ue_stats_rsp, AT_MAX_UESTATS_CELL_RSP_LEN, "%s%s,%d,%d,%u,%d,%d", AT_CMD_NEUSTATS_RSP_PREFIX, AT_CMD_NUESTATS_CELL,
    f40e:	2208      	movs	r2, #8
    f410:	5ea3      	ldrsh	r3, [r4, r2]
        cell_info[index].earfcn, cell_info[index].pci, cell_info[index].primary_cell ? 1:0,
    f412:	012f      	lsls	r7, r5, #4
        buffer_length = (uint16)snprintf(ue_stats_rsp, AT_MAX_UESTATS_CELL_RSP_LEN, "%s%s,%d,%d,%u,%d,%d", AT_CMD_NEUSTATS_RSP_PREFIX, AT_CMD_NUESTATS_CELL,
    f414:	9305      	str	r3, [sp, #20]
    f416:	2206      	movs	r2, #6
    f418:	5ea3      	ldrsh	r3, [r4, r2]
    f41a:	2132      	movs	r1, #50	; 0x32
    f41c:	9304      	str	r3, [sp, #16]
        cell_info[index].earfcn, cell_info[index].pci, cell_info[index].primary_cell ? 1:0,
    f41e:	ab14      	add	r3, sp, #80	; 0x50
    f420:	19df      	adds	r7, r3, r7
    f422:	787b      	ldrb	r3, [r7, #1]
        buffer_length = (uint16)snprintf(ue_stats_rsp, AT_MAX_UESTATS_CELL_RSP_LEN, "%s%s,%d,%d,%u,%d,%d", AT_CMD_NEUSTATS_RSP_PREFIX, AT_CMD_NUESTATS_CELL,
    f424:	4a11      	ldr	r2, [pc, #68]	; (f46c <output_ue_stats_cell+0x9c>)
        cell_info[index].earfcn, cell_info[index].pci, cell_info[index].primary_cell ? 1:0,
    f426:	07db      	lsls	r3, r3, #31
        buffer_length = (uint16)snprintf(ue_stats_rsp, AT_MAX_UESTATS_CELL_RSP_LEN, "%s%s,%d,%d,%u,%d,%d", AT_CMD_NEUSTATS_RSP_PREFIX, AT_CMD_NUESTATS_CELL,
    f428:	0fdb      	lsrs	r3, r3, #31
    f42a:	9303      	str	r3, [sp, #12]
    f42c:	8823      	ldrh	r3, [r4, #0]
    f42e:	a807      	add	r0, sp, #28
    f430:	9302      	str	r3, [sp, #8]
    f432:	1ca3      	adds	r3, r4, #2
    f434:	681b      	ldr	r3, [r3, #0]
    f436:	9301      	str	r3, [sp, #4]
    f438:	4b0d      	ldr	r3, [pc, #52]	; (f470 <output_ue_stats_cell+0xa0>)
    f43a:	9300      	str	r3, [sp, #0]
    f43c:	4b0d      	ldr	r3, [pc, #52]	; (f474 <output_ue_stats_cell+0xa4>)
    f43e:	f00b fa15 	bl	1a86c <snprintf>
        if (cell_info[index].primary_cell)
    f442:	787b      	ldrb	r3, [r7, #1]
    f444:	07db      	lsls	r3, r3, #31
    f446:	d50b      	bpl.n	f460 <output_ue_stats_cell+0x90>
            (void)snprintf(ue_stats_rsp + buffer_length, AT_MAX_UESTATS_CELL_RSP_LEN, ",%d,%d", cell_info[index].rssi, cell_info[index].snr);
    f448:	220a      	movs	r2, #10
    f44a:	5ea3      	ldrsh	r3, [r4, r2]
    f44c:	b280      	uxth	r0, r0
    f44e:	aa07      	add	r2, sp, #28
    f450:	1810      	adds	r0, r2, r0
    f452:	210c      	movs	r1, #12
    f454:	5e62      	ldrsh	r2, [r4, r1]
    f456:	2132      	movs	r1, #50	; 0x32
    f458:	9200      	str	r2, [sp, #0]
    f45a:	4a07      	ldr	r2, [pc, #28]	; (f478 <output_ue_stats_cell+0xa8>)
    f45c:	f00b fa06 	bl	1a86c <snprintf>
        app_at_send_at_rsp_string_lines_with_claim_and_log_restricted(ue_stats_rsp);
    f460:	a807      	add	r0, sp, #28
    f462:	f7fa f8c6 	bl	95f2 <app_at_send_at_rsp_string_lines_with_claim_and_log_restricted>
    for (int index = 0; index < cell_info_num; index++)
    f466:	3501      	adds	r5, #1
    f468:	3410      	adds	r4, #16
    f46a:	e7cb      	b.n	f404 <output_ue_stats_cell+0x34>
    f46c:	000248fd 	.word	0x000248fd
    f470:	00024911 	.word	0x00024911
    f474:	000248e8 	.word	0x000248e8
    f478:	00023734 	.word	0x00023734

0000f47c <output_ue_stats_appsmem>:
{
    f47c:	b570      	push	{r4, r5, r6, lr}
    f47e:	b096      	sub	sp, #88	; 0x58
    char   mem_stats_rsp[AT_MAX_MEM_STATS_RSP_LEN] = {0};
    f480:	2232      	movs	r2, #50	; 0x32
    f482:	2100      	movs	r1, #0
    uint32 mem_stats[AT_MAX_MEM_STATS_ITEM] = {0};
    f484:	ad04      	add	r5, sp, #16
    char   mem_stats_rsp[AT_MAX_MEM_STATS_RSP_LEN] = {0};
    f486:	a809      	add	r0, sp, #36	; 0x24
    f488:	f7f0 ff2a 	bl	2e0 <memset>
    uint32 mem_stats[AT_MAX_MEM_STATS_ITEM] = {0};
    f48c:	2214      	movs	r2, #20
    f48e:	2100      	movs	r1, #0
    f490:	0028      	movs	r0, r5
    f492:	f7f0 ff25 	bl	2e0 <memset>
    irmalloc_get_machine_readable_stats(&mem_stats[0], &mem_stats[1], &mem_stats[2], &mem_stats[3], &mem_stats[4]);
    f496:	ab08      	add	r3, sp, #32
    f498:	9300      	str	r3, [sp, #0]
    f49a:	aa06      	add	r2, sp, #24
    f49c:	ab07      	add	r3, sp, #28
    f49e:	a905      	add	r1, sp, #20
    f4a0:	0028      	movs	r0, r5
    f4a2:	f003 fad3 	bl	12a4c <irmalloc_get_machine_readable_stats>
    at_uart_claim();
    f4a6:	2400      	movs	r4, #0
    f4a8:	f7fa fa7e 	bl	99a8 <at_uart_claim>
        memset(mem_stats_rsp, 0, sizeof(mem_stats_rsp));
    f4ac:	2632      	movs	r6, #50	; 0x32
    f4ae:	0032      	movs	r2, r6
    f4b0:	2100      	movs	r1, #0
    f4b2:	a809      	add	r0, sp, #36	; 0x24
    f4b4:	f7f0 ff14 	bl	2e0 <memset>
        (void)snprintf(mem_stats_rsp, AT_MAX_MEM_STATS_RSP_LEN, "%s%s,%s%d", AT_CMD_NEUSTATS_RSP_PREFIX, AT_CMD_NUESTATS_APPSMEM, mem_stats_labels[i], mem_stats[i]);
    f4b8:	592b      	ldr	r3, [r5, r4]
    f4ba:	4a0c      	ldr	r2, [pc, #48]	; (f4ec <output_ue_stats_appsmem+0x70>)
    f4bc:	9302      	str	r3, [sp, #8]
    f4be:	4b0c      	ldr	r3, [pc, #48]	; (f4f0 <output_ue_stats_appsmem+0x74>)
    f4c0:	0031      	movs	r1, r6
    f4c2:	58e3      	ldr	r3, [r4, r3]
    f4c4:	a809      	add	r0, sp, #36	; 0x24
    f4c6:	9301      	str	r3, [sp, #4]
    f4c8:	4b0a      	ldr	r3, [pc, #40]	; (f4f4 <output_ue_stats_appsmem+0x78>)
    f4ca:	3404      	adds	r4, #4
    f4cc:	9300      	str	r3, [sp, #0]
    f4ce:	4b0a      	ldr	r3, [pc, #40]	; (f4f8 <output_ue_stats_appsmem+0x7c>)
    f4d0:	f00b f9cc 	bl	1a86c <snprintf>
        app_at_send_at_rsp_string_lines(mem_stats_rsp, false, AT_FLAG_LOGABLE);
    f4d4:	2208      	movs	r2, #8
    f4d6:	2100      	movs	r1, #0
    f4d8:	a809      	add	r0, sp, #36	; 0x24
    f4da:	f7fa f87c 	bl	95d6 <app_at_send_at_rsp_string_lines>
    for (int i = 0; i < AT_MAX_MEM_STATS_ITEM; i++)
    f4de:	2c14      	cmp	r4, #20
    f4e0:	d1e5      	bne.n	f4ae <output_ue_stats_appsmem+0x32>
    at_uart_release();
    f4e2:	f7fa fa73 	bl	99cc <at_uart_release>
}
    f4e6:	b016      	add	sp, #88	; 0x58
    f4e8:	bd70      	pop	{r4, r5, r6, pc}
    f4ea:	46c0      	nop			; (mov r8, r8)
    f4ec:	000248d6 	.word	0x000248d6
    f4f0:	000247fc 	.word	0x000247fc
    f4f4:	000248e0 	.word	0x000248e0
    f4f8:	000248e8 	.word	0x000248e8

0000f4fc <at_handle_UE_STATS_cmd_set>:
{
    f4fc:	b510      	push	{r4, lr}
    f4fe:	b09c      	sub	sp, #112	; 0x70
    f500:	0004      	movs	r4, r0
    uint8               str_function[AT_CMD_NUESTATS_PREFIX_LEN]   = {0};
    f502:	2208      	movs	r2, #8
    f504:	2100      	movs	r1, #0
    f506:	a802      	add	r0, sp, #8
    f508:	f7f0 feea 	bl	2e0 <memset>
    ue_stats            ue_stats_bin = {0};
    f50c:	2260      	movs	r2, #96	; 0x60
    f50e:	2100      	movs	r1, #0
    f510:	a804      	add	r0, sp, #16
    f512:	f7f0 fee5 	bl	2e0 <memset>
    if (at_create_param_array(p_atparams_string, &num_recvparams, 1, 1) != AT_RET_OK)
    f516:	2301      	movs	r3, #1
    f518:	4669      	mov	r1, sp
    f51a:	001a      	movs	r2, r3
    f51c:	3107      	adds	r1, #7
    f51e:	0020      	movs	r0, r4
    f520:	f7fa fee0 	bl	a2e4 <at_create_param_array>
    f524:	2800      	cmp	r0, #0
    f526:	d003      	beq.n	f530 <at_handle_UE_STATS_cmd_set+0x34>
       return AT_RET_SYNTAX_ERROR;
    f528:	2401      	movs	r4, #1
}
    f52a:	0020      	movs	r0, r4
    f52c:	b01c      	add	sp, #112	; 0x70
    f52e:	bd10      	pop	{r4, pc}
    if (at_get_string_param(AT_PARSE_FIRST_PARAM_POS, str_function, AT_CMD_NUESTATS_PREFIX_LEN, true) != AT_RET_OK)
    f530:	2301      	movs	r3, #1
    f532:	2208      	movs	r2, #8
    f534:	a902      	add	r1, sp, #8
    f536:	f7fb f927 	bl	a788 <at_get_string_param>
    f53a:	1e04      	subs	r4, r0, #0
    f53c:	d1f4      	bne.n	f528 <at_handle_UE_STATS_cmd_set+0x2c>
    if (get_ue_stats(&ue_stats_bin) != 0)
    f53e:	a804      	add	r0, sp, #16
    f540:	f00d fc01 	bl	1cd46 <get_ue_stats>
    f544:	2800      	cmp	r0, #0
    f546:	d142      	bne.n	f5ce <at_handle_UE_STATS_cmd_set+0xd2>
    if (at_strcmp(str_function, AT_CMD_ALL_STR) == 0)
    f548:	4922      	ldr	r1, [pc, #136]	; (f5d4 <at_handle_UE_STATS_cmd_set+0xd8>)
    f54a:	a802      	add	r0, sp, #8
    f54c:	f00b ff08 	bl	1b360 <strcmp>
    f550:	2800      	cmp	r0, #0
    f552:	d10e      	bne.n	f572 <at_handle_UE_STATS_cmd_set+0x76>
        output_ue_stats_radio(&ue_stats_bin, true);
    f554:	2101      	movs	r1, #1
    f556:	a804      	add	r0, sp, #16
    f558:	f7fd fb68 	bl	cc2c <output_ue_stats_radio>
        output_ue_stats_bler(&ue_stats_bin);
    f55c:	a804      	add	r0, sp, #16
    f55e:	f7fc f817 	bl	b590 <output_ue_stats_bler>
        output_ue_statshp(&ue_stats_bin);
    f562:	a804      	add	r0, sp, #16
    f564:	f7fc f860 	bl	b628 <output_ue_statshp>
        output_ue_stats_appsmem();
    f568:	f7ff ff88 	bl	f47c <output_ue_stats_appsmem>
        output_ue_stats_cell();
    f56c:	f7ff ff30 	bl	f3d0 <output_ue_stats_cell>
    f570:	e7db      	b.n	f52a <at_handle_UE_STATS_cmd_set+0x2e>
    else if (at_strcmp(str_function, AT_CMD_NUESTATS_RADIO) == 0)
    f572:	4919      	ldr	r1, [pc, #100]	; (f5d8 <at_handle_UE_STATS_cmd_set+0xdc>)
    f574:	a802      	add	r0, sp, #8
    f576:	f00b fef3 	bl	1b360 <strcmp>
    f57a:	2800      	cmp	r0, #0
    f57c:	d104      	bne.n	f588 <at_handle_UE_STATS_cmd_set+0x8c>
        output_ue_stats_radio(&ue_stats_bin, true);
    f57e:	2101      	movs	r1, #1
    f580:	a804      	add	r0, sp, #16
    f582:	f7fd fb53 	bl	cc2c <output_ue_stats_radio>
    f586:	e7d0      	b.n	f52a <at_handle_UE_STATS_cmd_set+0x2e>
    else if (at_strcmp(str_function, AT_CMD_NUESTATS_BLER) == 0)
    f588:	4914      	ldr	r1, [pc, #80]	; (f5dc <at_handle_UE_STATS_cmd_set+0xe0>)
    f58a:	a802      	add	r0, sp, #8
    f58c:	f00b fee8 	bl	1b360 <strcmp>
    f590:	2800      	cmp	r0, #0
    f592:	d103      	bne.n	f59c <at_handle_UE_STATS_cmd_set+0xa0>
        output_ue_stats_bler(&ue_stats_bin);
    f594:	a804      	add	r0, sp, #16
    f596:	f7fb fffb 	bl	b590 <output_ue_stats_bler>
    f59a:	e7c6      	b.n	f52a <at_handle_UE_STATS_cmd_set+0x2e>
    else if (at_strcmp(str_function, AT_CMD_NUESTATS_CELL) == 0)
    f59c:	4910      	ldr	r1, [pc, #64]	; (f5e0 <at_handle_UE_STATS_cmd_set+0xe4>)
    f59e:	a802      	add	r0, sp, #8
    f5a0:	f00b fede 	bl	1b360 <strcmp>
    f5a4:	2800      	cmp	r0, #0
    f5a6:	d0e1      	beq.n	f56c <at_handle_UE_STATS_cmd_set+0x70>
    else if (at_strcmp(str_function, AT_CMD_NUESTATS_THP) == 0)
    f5a8:	490e      	ldr	r1, [pc, #56]	; (f5e4 <at_handle_UE_STATS_cmd_set+0xe8>)
    f5aa:	a802      	add	r0, sp, #8
    f5ac:	f00b fed8 	bl	1b360 <strcmp>
    f5b0:	2800      	cmp	r0, #0
    f5b2:	d103      	bne.n	f5bc <at_handle_UE_STATS_cmd_set+0xc0>
        output_ue_statshp(&ue_stats_bin);
    f5b4:	a804      	add	r0, sp, #16
    f5b6:	f7fc f837 	bl	b628 <output_ue_statshp>
    f5ba:	e7b6      	b.n	f52a <at_handle_UE_STATS_cmd_set+0x2e>
    else if (at_strcmp(str_function,  AT_CMD_NUESTATS_APPSMEM) == 0)
    f5bc:	490a      	ldr	r1, [pc, #40]	; (f5e8 <at_handle_UE_STATS_cmd_set+0xec>)
    f5be:	a802      	add	r0, sp, #8
    f5c0:	f00b fece 	bl	1b360 <strcmp>
    f5c4:	2800      	cmp	r0, #0
    f5c6:	d1af      	bne.n	f528 <at_handle_UE_STATS_cmd_set+0x2c>
        output_ue_stats_appsmem();
    f5c8:	f7ff ff58 	bl	f47c <output_ue_stats_appsmem>
    f5cc:	e7ad      	b.n	f52a <at_handle_UE_STATS_cmd_set+0x2e>
        return AT_RET_PROGRESS_ERROR;
    f5ce:	2406      	movs	r4, #6
    f5d0:	e7ab      	b.n	f52a <at_handle_UE_STATS_cmd_set+0x2e>
    f5d2:	46c0      	nop			; (mov r8, r8)
    f5d4:	00023a74 	.word	0x00023a74
    f5d8:	00024916 	.word	0x00024916
    f5dc:	000248f8 	.word	0x000248f8
    f5e0:	00024911 	.word	0x00024911
    f5e4:	00024927 	.word	0x00024927
    f5e8:	000248e0 	.word	0x000248e0

0000f5ec <at_handle_NCSEARFCN_cmd_exec>:
{
    f5ec:	b510      	push	{r4, lr}
    if(clear_stored_earfcn() != NEUL_RET_OK)
    f5ee:	f00c fcfd 	bl	1bfec <clear_stored_earfcn>
        return AT_RET_PROGRESS_ERROR;
    f5f2:	2306      	movs	r3, #6
    if(clear_stored_earfcn() != NEUL_RET_OK)
    f5f4:	2800      	cmp	r0, #0
    f5f6:	d100      	bne.n	f5fa <at_handle_NCSEARFCN_cmd_exec+0xe>
    return AT_RET_OK;
    f5f8:	0003      	movs	r3, r0
}
    f5fa:	0018      	movs	r0, r3
    f5fc:	bd10      	pop	{r4, pc}
	...

0000f600 <at_handle_NEARFCN_cmd_set>:
    uint16            ci_string_len   = AT_NEARFCN_CI_STRING_LEN;
    f600:	2304      	movs	r3, #4
{
    f602:	b5f0      	push	{r4, r5, r6, r7, lr}
    f604:	b085      	sub	sp, #20
    uint16            ci_string_len   = AT_NEARFCN_CI_STRING_LEN;
    f606:	ae01      	add	r6, sp, #4
    f608:	8033      	strh	r3, [r6, #0]
    uint16            pci = AT_NEAFRCN_PCI_INVALID;
    f60a:	466b      	mov	r3, sp
    f60c:	1d9d      	adds	r5, r3, #6
    f60e:	2301      	movs	r3, #1
    uint16             earfcn            = 0;
    f610:	240a      	movs	r4, #10
    uint16            pci = AT_NEAFRCN_PCI_INVALID;
    f612:	425b      	negs	r3, r3
    f614:	802b      	strh	r3, [r5, #0]
    uint16            search_mode       = 0;
    f616:	2300      	movs	r3, #0
    cause = at_create_param_array(p_atparams_string, &num_recvparams, AT_MIN_NEARFCN_PARAM, AT_MAX_NEARFCN_PARAM);
    f618:	4669      	mov	r1, sp
    uint16            search_mode       = 0;
    f61a:	af02      	add	r7, sp, #8
    uint16             earfcn            = 0;
    f61c:	446c      	add	r4, sp
    uint16            search_mode       = 0;
    f61e:	803b      	strh	r3, [r7, #0]
    uint16             earfcn            = 0;
    f620:	8023      	strh	r3, [r4, #0]
    cause = at_create_param_array(p_atparams_string, &num_recvparams, AT_MIN_NEARFCN_PARAM, AT_MAX_NEARFCN_PARAM);
    f622:	3303      	adds	r3, #3
    f624:	2202      	movs	r2, #2
    f626:	18c9      	adds	r1, r1, r3
    f628:	f7fa fe5c 	bl	a2e4 <at_create_param_array>
    if(cause != AT_RET_OK)
    f62c:	2800      	cmp	r0, #0
    f62e:	d106      	bne.n	f63e <at_handle_NEARFCN_cmd_set+0x3e>
    cause = at_get_uint16_param(AT_PARSE_FIRST_PARAM_POS, &search_mode, true);
    f630:	2201      	movs	r2, #1
    f632:	0039      	movs	r1, r7
    f634:	f7fa ff6a 	bl	a50c <at_get_uint16_param>
    if(cause != AT_RET_OK)
    f638:	2800      	cmp	r0, #0
    f63a:	d002      	beq.n	f642 <at_handle_NEARFCN_cmd_set+0x42>
        return AT_RET_SYNTAX_ERROR;
    f63c:	2001      	movs	r0, #1
}
    f63e:	b005      	add	sp, #20
    f640:	bdf0      	pop	{r4, r5, r6, r7, pc}
    cause = at_get_uint16_param(AT_PARSE_SECOND_PARAM_POS, &earfcn, true);
    f642:	2201      	movs	r2, #1
    f644:	0021      	movs	r1, r4
    f646:	0010      	movs	r0, r2
    f648:	f7fa ff60 	bl	a50c <at_get_uint16_param>
    if(cause != AT_RET_OK)
    f64c:	2800      	cmp	r0, #0
    f64e:	d1f5      	bne.n	f63c <at_handle_NEARFCN_cmd_set+0x3c>
    if (num_recvparams == AT_MAX_NEARFCN_PARAM)
    f650:	466b      	mov	r3, sp
    f652:	78db      	ldrb	r3, [r3, #3]
    f654:	2b03      	cmp	r3, #3
    f656:	d011      	beq.n	f67c <at_handle_NEARFCN_cmd_set+0x7c>
    if(search_mode > 1)
    f658:	8838      	ldrh	r0, [r7, #0]
    f65a:	2801      	cmp	r0, #1
    f65c:	d8ee      	bhi.n	f63c <at_handle_NEARFCN_cmd_set+0x3c>
    if((pci > AT_NEARFCN_MAX_PCI) && (pci != AT_NEAFRCN_PCI_INVALID))
    f65e:	882b      	ldrh	r3, [r5, #0]
    f660:	490e      	ldr	r1, [pc, #56]	; (f69c <at_handle_NEARFCN_cmd_set+0x9c>)
    f662:	001a      	movs	r2, r3
    f664:	3af9      	subs	r2, #249	; 0xf9
    f666:	3aff      	subs	r2, #255	; 0xff
    f668:	b292      	uxth	r2, r2
    f66a:	428a      	cmp	r2, r1
    f66c:	d9e6      	bls.n	f63c <at_handle_NEARFCN_cmd_set+0x3c>
    neul_result = set_plmn_search_range(search_mode, earfcn, earfcn, pci);   //now,only support set single point (earfcn_start == earfcn_end)
    f66e:	8821      	ldrh	r1, [r4, #0]
    f670:	000a      	movs	r2, r1
    f672:	f00c fcae 	bl	1bfd2 <set_plmn_search_range>
    return at_parse_convert_neul_result(neul_result);
    f676:	f7fa fe0b 	bl	a290 <at_parse_convert_neul_result>
    f67a:	e7e0      	b.n	f63e <at_handle_NEARFCN_cmd_set+0x3e>
        cause = at_get_hexstring_param(AT_PARSE_THIRD_PARAM_POS, &ci_string, &ci_string_len, true);
    f67c:	2301      	movs	r3, #1
    f67e:	0032      	movs	r2, r6
    f680:	a903      	add	r1, sp, #12
    f682:	2002      	movs	r0, #2
    f684:	f7fb f8d2 	bl	a82c <at_get_hexstring_param>
        if (cause != AT_RET_OK)
    f688:	2800      	cmp	r0, #0
    f68a:	d1d7      	bne.n	f63c <at_handle_NEARFCN_cmd_set+0x3c>
        if (at_parse_buf_hex_to_uint16(ci_string, &pci,  ci_string_len) == false)
    f68c:	8832      	ldrh	r2, [r6, #0]
    f68e:	0029      	movs	r1, r5
    f690:	9803      	ldr	r0, [sp, #12]
    f692:	f7fa fdaa 	bl	a1ea <at_parse_buf_hex_to_uint16>
    f696:	2800      	cmp	r0, #0
    f698:	d1de      	bne.n	f658 <at_handle_NEARFCN_cmd_set+0x58>
    f69a:	e7cf      	b.n	f63c <at_handle_NEARFCN_cmd_set+0x3c>
    f69c:	0000fe06 	.word	0x0000fe06

0000f6a0 <at_handle_CGATT_cmd_read>:
{
    f6a0:	b530      	push	{r4, r5, lr}
    f6a2:	b085      	sub	sp, #20
    char    rsp_string[AT_MAX_CGATT_READ_RSP_LEN] = {0};
    f6a4:	220a      	movs	r2, #10
    f6a6:	2100      	movs	r1, #0
    f6a8:	a801      	add	r0, sp, #4
    f6aa:	f7f0 fe19 	bl	2e0 <memset>
    if (get_service_state(&current_cfun_setting) != NEUL_RET_OK)
    f6ae:	466b      	mov	r3, sp
    f6b0:	1cdd      	adds	r5, r3, #3
    f6b2:	0028      	movs	r0, r5
    f6b4:	f00c fd1a 	bl	1c0ec <get_service_state>
    f6b8:	0004      	movs	r4, r0
        return AT_RET_PROGRESS_ERROR;
    f6ba:	2006      	movs	r0, #6
    if (get_service_state(&current_cfun_setting) != NEUL_RET_OK)
    f6bc:	2c00      	cmp	r4, #0
    f6be:	d109      	bne.n	f6d4 <at_handle_CGATT_cmd_read+0x34>
    (void)snprintf(rsp_string, AT_MAX_CGATT_READ_RSP_LEN, "+CGATT:%d", current_cfun_setting);
    f6c0:	782b      	ldrb	r3, [r5, #0]
    f6c2:	4a05      	ldr	r2, [pc, #20]	; (f6d8 <at_handle_CGATT_cmd_read+0x38>)
    f6c4:	210a      	movs	r1, #10
    f6c6:	a801      	add	r0, sp, #4
    f6c8:	f00b f8d0 	bl	1a86c <snprintf>
    app_at_send_at_rsp_string_lines_with_claim_and_log(rsp_string);
    f6cc:	a801      	add	r0, sp, #4
    f6ce:	f7f9 ff89 	bl	95e4 <app_at_send_at_rsp_string_lines_with_claim_and_log>
    return AT_RET_OK;
    f6d2:	0020      	movs	r0, r4
}
    f6d4:	b005      	add	sp, #20
    f6d6:	bd30      	pop	{r4, r5, pc}
    f6d8:	00023688 	.word	0x00023688

0000f6dc <at_handle_COPS_cmd_test>:
{
    f6dc:	b510      	push	{r4, lr}
    result  = get_available_plmn(at_get_available_plmn_callback);
    f6de:	4803      	ldr	r0, [pc, #12]	; (f6ec <at_handle_COPS_cmd_test+0x10>)
    f6e0:	f00c fcb2 	bl	1c048 <get_available_plmn>
    return at_parse_convert_neul_result(result);
    f6e4:	f7fa fdd4 	bl	a290 <at_parse_convert_neul_result>
}
    f6e8:	bd10      	pop	{r4, pc}
    f6ea:	46c0      	nop			; (mov r8, r8)
    f6ec:	0000c1a5 	.word	0x0000c1a5

0000f6f0 <at_handle_COPS_cmd_read>:
{
    f6f0:	b5f0      	push	{r4, r5, r6, r7, lr}
    uint8       current_mode                     = 0;
    f6f2:	2613      	movs	r6, #19
    f6f4:	2700      	movs	r7, #0
{
    f6f6:	b08f      	sub	sp, #60	; 0x3c
    char        rsp_string[AT_COPS_READ_RSP_LEN] = {0};
    f6f8:	2214      	movs	r2, #20
    f6fa:	2100      	movs	r1, #0
    uint8       current_plmn[3]                  = {0};
    f6fc:	ad05      	add	r5, sp, #20
    char        rsp_string[AT_COPS_READ_RSP_LEN] = {0};
    f6fe:	a809      	add	r0, sp, #36	; 0x24
    f700:	f7f0 fdee 	bl	2e0 <memset>
    uint8       current_plmn[3]                  = {0};
    f704:	2203      	movs	r2, #3
    f706:	2100      	movs	r1, #0
    f708:	0028      	movs	r0, r5
    f70a:	f7f0 fde9 	bl	2e0 <memset>
    uint8       plmn_for_compare[3]              = {0xff,0xff,0xff};
    f70e:	4927      	ldr	r1, [pc, #156]	; (f7ac <at_handle_COPS_cmd_read+0xbc>)
    uint8       current_mode                     = 0;
    f710:	446e      	add	r6, sp
    uint8       plmn_for_compare[3]              = {0xff,0xff,0xff};
    f712:	2203      	movs	r2, #3
    f714:	3120      	adds	r1, #32
    f716:	a806      	add	r0, sp, #24
    uint8       plmn_data[APP_AT_MAX_PLMN_LEN]   = {0};
    f718:	ac07      	add	r4, sp, #28
    uint8       current_mode                     = 0;
    f71a:	7037      	strb	r7, [r6, #0]
    uint8       plmn_for_compare[3]              = {0xff,0xff,0xff};
    f71c:	f7f0 fd68 	bl	1f0 <memcpy>
    uint8       plmn_data[APP_AT_MAX_PLMN_LEN]   = {0};
    f720:	2207      	movs	r2, #7
    f722:	0039      	movs	r1, r7
    f724:	0020      	movs	r0, r4
    f726:	f7f0 fddb 	bl	2e0 <memset>
    if (get_plmn_state(&current_mode, current_plmn) != NEUL_RET_OK)
    f72a:	0029      	movs	r1, r5
    f72c:	0030      	movs	r0, r6
    f72e:	f00c fc7d 	bl	1c02c <get_plmn_state>
        return AT_RET_PROGRESS_ERROR;
    f732:	2306      	movs	r3, #6
    if (get_plmn_state(&current_mode, current_plmn) != NEUL_RET_OK)
    f734:	42b8      	cmp	r0, r7
    f736:	d12f      	bne.n	f798 <at_handle_COPS_cmd_read+0xa8>
    if (memcmp(current_plmn, plmn_for_compare, sizeof(plmn_for_compare)) != 0) //compare with{0xff,0xff,0xff}
    f738:	2203      	movs	r2, #3
    f73a:	a906      	add	r1, sp, #24
    f73c:	0028      	movs	r0, r5
    f73e:	f00b fdc5 	bl	1b2cc <memcmp>
    f742:	7836      	ldrb	r6, [r6, #0]
    f744:	4b1a      	ldr	r3, [pc, #104]	; (f7b0 <at_handle_COPS_cmd_read+0xc0>)
    f746:	42b8      	cmp	r0, r7
    f748:	d029      	beq.n	f79e <at_handle_COPS_cmd_read+0xae>
        plmn_digit = current_plmn[0] & 0x0F;
    f74a:	782a      	ldrb	r2, [r5, #0]
    f74c:	210f      	movs	r1, #15
    f74e:	0010      	movs	r0, r2
        plmn_digit = (current_plmn[0] >> 4) & 0x0F;
    f750:	0912      	lsrs	r2, r2, #4
        plmn_digit = current_plmn[0] & 0x0F;
    f752:	4008      	ands	r0, r1
        *a_char = '0' + plmn_digit;
    f754:	3030      	adds	r0, #48	; 0x30
        *a_char = '0' + plmn_digit;
    f756:	3230      	adds	r2, #48	; 0x30
        *a_char = '0' + plmn_digit;
    f758:	7020      	strb	r0, [r4, #0]
        *a_char = '0' + plmn_digit;
    f75a:	7062      	strb	r2, [r4, #1]
        plmn_digit = current_plmn[1] & 0x0F;
    f75c:	786a      	ldrb	r2, [r5, #1]
    f75e:	0010      	movs	r0, r2
    f760:	4008      	ands	r0, r1
        *a_char = '0' + plmn_digit;
    f762:	3030      	adds	r0, #48	; 0x30
    f764:	70a0      	strb	r0, [r4, #2]
        plmn_digit = current_plmn[2] & 0x0F;
    f766:	78a8      	ldrb	r0, [r5, #2]
        plmn_digit = (current_plmn[1] >> 4) & 0x0F;
    f768:	0912      	lsrs	r2, r2, #4
        plmn_digit = current_plmn[2] & 0x0F;
    f76a:	4001      	ands	r1, r0
        plmn_digit = (current_plmn[2] >> 4) & 0x0F;
    f76c:	0900      	lsrs	r0, r0, #4
        *a_char = '0' + plmn_digit;
    f76e:	3130      	adds	r1, #48	; 0x30
        *a_char = '0' + plmn_digit;
    f770:	3030      	adds	r0, #48	; 0x30
        *a_char = '0' + plmn_digit;
    f772:	70e1      	strb	r1, [r4, #3]
        *a_char = '0' + plmn_digit;
    f774:	7120      	strb	r0, [r4, #4]
        if(plmn_digit != 0x0F)
    f776:	2a0f      	cmp	r2, #15
    f778:	d001      	beq.n	f77e <at_handle_COPS_cmd_read+0x8e>
           *a_char = '0' + plmn_digit;
    f77a:	3230      	adds	r2, #48	; 0x30
    f77c:	7162      	strb	r2, [r4, #5]
        (void)snprintf(rsp_string, AT_COPS_READ_RSP_LEN, "%s%d,%d,\"%s\"", AT_CMD_COPS_PREFIX, current_mode, PLMN_NUMERIC_FORMAT, plmn_data);
    f77e:	2202      	movs	r2, #2
    f780:	9402      	str	r4, [sp, #8]
    f782:	9201      	str	r2, [sp, #4]
    f784:	9600      	str	r6, [sp, #0]
    f786:	4a0b      	ldr	r2, [pc, #44]	; (f7b4 <at_handle_COPS_cmd_read+0xc4>)
    f788:	2114      	movs	r1, #20
    f78a:	a809      	add	r0, sp, #36	; 0x24
    f78c:	f00b f86e 	bl	1a86c <snprintf>
    app_at_send_at_rsp_string_lines_with_claim_and_log(rsp_string);
    f790:	a809      	add	r0, sp, #36	; 0x24
    f792:	f7f9 ff27 	bl	95e4 <app_at_send_at_rsp_string_lines_with_claim_and_log>
    return AT_RET_OK;
    f796:	2300      	movs	r3, #0
}
    f798:	0018      	movs	r0, r3
    f79a:	b00f      	add	sp, #60	; 0x3c
    f79c:	bdf0      	pop	{r4, r5, r6, r7, pc}
        (void)snprintf(rsp_string, AT_COPS_READ_RSP_LEN, "%s%d", AT_CMD_COPS_PREFIX, current_mode);
    f79e:	9600      	str	r6, [sp, #0]
    f7a0:	4a05      	ldr	r2, [pc, #20]	; (f7b8 <at_handle_COPS_cmd_read+0xc8>)
    f7a2:	2114      	movs	r1, #20
    f7a4:	a809      	add	r0, sp, #36	; 0x24
    f7a6:	f00b f861 	bl	1a86c <snprintf>
    f7aa:	e7f1      	b.n	f790 <at_handle_COPS_cmd_read+0xa0>
    f7ac:	00022a78 	.word	0x00022a78
    f7b0:	0002356f 	.word	0x0002356f
    f7b4:	000238c0 	.word	0x000238c0
    f7b8:	000248db 	.word	0x000248db

0000f7bc <at_handle_COPS_cmd_set>:
    uint16            format = AT_UINT16_NO_VALUE;
    f7bc:	2301      	movs	r3, #1
{
    f7be:	b5f0      	push	{r4, r5, r6, r7, lr}
    f7c0:	b087      	sub	sp, #28
    uint16            format = AT_UINT16_NO_VALUE;
    f7c2:	425b      	negs	r3, r3
{
    f7c4:	0007      	movs	r7, r0
    uint8             plmn_str[AT_MAX_OPERATOR_SIZE] = {0};
    f7c6:	2210      	movs	r2, #16
    f7c8:	2100      	movs	r1, #0
    uint16            format = AT_UINT16_NO_VALUE;
    f7ca:	ad01      	add	r5, sp, #4
    uint8             plmn_str[AT_MAX_OPERATOR_SIZE] = {0};
    f7cc:	a802      	add	r0, sp, #8
    uint16            format = AT_UINT16_NO_VALUE;
    f7ce:	802b      	strh	r3, [r5, #0]
    uint8             plmn_str[AT_MAX_OPERATOR_SIZE] = {0};
    f7d0:	f7f0 fd86 	bl	2e0 <memset>
    uint16            acc_tech    = ACT_VALUE_E_UTRAN_NB_S1_MODE;
    f7d4:	466b      	mov	r3, sp
    f7d6:	1d9e      	adds	r6, r3, #6
    f7d8:	2309      	movs	r3, #9
    f7da:	8033      	strh	r3, [r6, #0]
    cause = at_create_param_array(p_atparams_string, &num_recvparams, 1, AT_MAX_COPS_PARAM);
    f7dc:	466b      	mov	r3, sp
    f7de:	1c5c      	adds	r4, r3, #1
    f7e0:	2201      	movs	r2, #1
    f7e2:	2304      	movs	r3, #4
    f7e4:	0021      	movs	r1, r4
    f7e6:	0038      	movs	r0, r7
    f7e8:	f7fa fd7c 	bl	a2e4 <at_create_param_array>
    if(cause != AT_RET_OK)
    f7ec:	2800      	cmp	r0, #0
    f7ee:	d123      	bne.n	f838 <at_handle_COPS_cmd_set+0x7c>
    cause = at_get_uint16_param(AT_PARSE_FIRST_PARAM_POS, &mode, true);
    f7f0:	466b      	mov	r3, sp
    f7f2:	1c9f      	adds	r7, r3, #2
    f7f4:	2201      	movs	r2, #1
    f7f6:	0039      	movs	r1, r7
    f7f8:	f7fa fe88 	bl	a50c <at_get_uint16_param>
    if(cause != AT_RET_OK)
    f7fc:	2800      	cmp	r0, #0
    f7fe:	d11b      	bne.n	f838 <at_handle_COPS_cmd_set+0x7c>
    if (num_recvparams > 1)
    f800:	7823      	ldrb	r3, [r4, #0]
    f802:	2b01      	cmp	r3, #1
    f804:	d811      	bhi.n	f82a <at_handle_COPS_cmd_set+0x6e>
    if (num_recvparams > 2)
    f806:	7823      	ldrb	r3, [r4, #0]
    f808:	2b02      	cmp	r3, #2
    f80a:	d917      	bls.n	f83c <at_handle_COPS_cmd_set+0x80>
        cause = at_get_string_param(AT_PARSE_THIRD_PARAM_POS, plmn_str, AT_MAX_OPERATOR_SIZE, true);
    f80c:	2301      	movs	r3, #1
    f80e:	2210      	movs	r2, #16
    f810:	a902      	add	r1, sp, #8
    f812:	2002      	movs	r0, #2
    f814:	f7fa ffb8 	bl	a788 <at_get_string_param>
        if (cause != AT_RET_OK)
    f818:	2800      	cmp	r0, #0
    f81a:	d10d      	bne.n	f838 <at_handle_COPS_cmd_set+0x7c>
        if (!at_is_param_in_double_quotes(AT_PARSE_THIRD_PARAM_POS))
    f81c:	3002      	adds	r0, #2
    f81e:	f7fb f861 	bl	a8e4 <at_is_param_in_double_quotes>
    f822:	2800      	cmp	r0, #0
    f824:	d10a      	bne.n	f83c <at_handle_COPS_cmd_set+0x80>
            return AT_RET_SYNTAX_ERROR;
    f826:	2001      	movs	r0, #1
    f828:	e006      	b.n	f838 <at_handle_COPS_cmd_set+0x7c>
        cause = at_get_uint16_param(AT_PARSE_SECOND_PARAM_POS, &format, true);
    f82a:	2201      	movs	r2, #1
    f82c:	0029      	movs	r1, r5
    f82e:	0010      	movs	r0, r2
    f830:	f7fa fe6c 	bl	a50c <at_get_uint16_param>
        if(cause != AT_RET_OK)
    f834:	2800      	cmp	r0, #0
    f836:	d0e6      	beq.n	f806 <at_handle_COPS_cmd_set+0x4a>
}
    f838:	b007      	add	sp, #28
    f83a:	bdf0      	pop	{r4, r5, r6, r7, pc}
    if (num_recvparams > 3)
    f83c:	7823      	ldrb	r3, [r4, #0]
    f83e:	2b03      	cmp	r3, #3
    f840:	d906      	bls.n	f850 <at_handle_COPS_cmd_set+0x94>
        cause = at_get_uint16_param(AT_PARSE_FOURTH_PARAM_POS, &acc_tech, true);
    f842:	2201      	movs	r2, #1
    f844:	0031      	movs	r1, r6
    f846:	2003      	movs	r0, #3
    f848:	f7fa fe60 	bl	a50c <at_get_uint16_param>
        if (cause != AT_RET_OK)
    f84c:	2800      	cmp	r0, #0
    f84e:	d1f3      	bne.n	f838 <at_handle_COPS_cmd_set+0x7c>
    if (((format != PLMN_NUMERIC_FORMAT) && (format!= AT_UINT16_NO_VALUE))
    f850:	882d      	ldrh	r5, [r5, #0]
    f852:	4a15      	ldr	r2, [pc, #84]	; (f8a8 <at_handle_COPS_cmd_set+0xec>)
    f854:	2d02      	cmp	r5, #2
    f856:	d10f      	bne.n	f878 <at_handle_COPS_cmd_set+0xbc>
       || ((AT_UINT16_NO_VALUE != acc_tech && ACT_VALUE_E_UTRAN_NB_S1_MODE != acc_tech)))
    f858:	8833      	ldrh	r3, [r6, #0]
    f85a:	4293      	cmp	r3, r2
    f85c:	d001      	beq.n	f862 <at_handle_COPS_cmd_set+0xa6>
    f85e:	2b09      	cmp	r3, #9
    f860:	d1e1      	bne.n	f826 <at_handle_COPS_cmd_set+0x6a>
    switch (mode)
    f862:	883e      	ldrh	r6, [r7, #0]
            return AT_RET_SYNTAX_ERROR;
    f864:	2001      	movs	r0, #1
    switch (mode)
    f866:	2e04      	cmp	r6, #4
    f868:	d8e6      	bhi.n	f838 <at_handle_COPS_cmd_set+0x7c>
    f86a:	0030      	movs	r0, r6
            if (num_recvparams < 2)
    f86c:	7823      	ldrb	r3, [r4, #0]
    switch (mode)
    f86e:	f7f0 fd99 	bl	3a4 <__gnu_thumb1_case_uqi>
    f872:	1706      	.short	0x1706
    f874:	1406      	.short	0x1406
    f876:	17          	.byte	0x17
    f877:	00          	.byte	0x00
    if (((format != PLMN_NUMERIC_FORMAT) && (format!= AT_UINT16_NO_VALUE))
    f878:	4295      	cmp	r5, r2
    f87a:	d1d4      	bne.n	f826 <at_handle_COPS_cmd_set+0x6a>
    f87c:	e7ec      	b.n	f858 <at_handle_COPS_cmd_set+0x9c>
            if (num_recvparams != 1)
    f87e:	2b01      	cmp	r3, #1
    f880:	d1d1      	bne.n	f826 <at_handle_COPS_cmd_set+0x6a>
    neul_result = plmn_select(mode, format, (uint16)strlen((char*)plmn_str), plmn_str);
    f882:	a802      	add	r0, sp, #8
    f884:	f00b fd8b 	bl	1b39e <strlen>
    f888:	ab02      	add	r3, sp, #8
    f88a:	b282      	uxth	r2, r0
    f88c:	0029      	movs	r1, r5
    f88e:	0030      	movs	r0, r6
    f890:	f7f9 fa3a 	bl	8d08 <plmn_select>
    return at_parse_convert_neul_result(neul_result);
    f894:	f7fa fcfc 	bl	a290 <at_parse_convert_neul_result>
    f898:	e7ce      	b.n	f838 <at_handle_COPS_cmd_set+0x7c>
            if (num_recvparams < 2)
    f89a:	2b01      	cmp	r3, #1
    f89c:	d8f1      	bhi.n	f882 <at_handle_COPS_cmd_set+0xc6>
    f89e:	e7c2      	b.n	f826 <at_handle_COPS_cmd_set+0x6a>
            if (num_recvparams < 3)
    f8a0:	2b02      	cmp	r3, #2
    f8a2:	d8ee      	bhi.n	f882 <at_handle_COPS_cmd_set+0xc6>
    f8a4:	e7bf      	b.n	f826 <at_handle_COPS_cmd_set+0x6a>
    f8a6:	46c0      	nop			; (mov r8, r8)
    f8a8:	0000ffff 	.word	0x0000ffff

0000f8ac <at_parse_convert_hexstring_to_uuid.part.0>:
static bool at_parse_convert_hexstring_to_uuid(const char *src_buf, char *des_buf)
    f8ac:	b5f0      	push	{r4, r5, r6, r7, lr}
        if ((i == 8) || (i == 12) || (i == 16) || (i == 20))
    f8ae:	2304      	movs	r3, #4
static bool at_parse_convert_hexstring_to_uuid(const char *src_buf, char *des_buf)
    f8b0:	2400      	movs	r4, #0
        if ((i == 8) || (i == 12) || (i == 16) || (i == 20))
    f8b2:	469c      	mov	ip, r3
    for (i = 0, j = 0; i < UUID_LEN; i++)
    f8b4:	0022      	movs	r2, r4
        if ((i == 8) || (i == 12) || (i == 16) || (i == 20))
    f8b6:	2608      	movs	r6, #8
            des_buf[j++] = '-';
    f8b8:	272d      	movs	r7, #45	; 0x2d
        if ((i == 8) || (i == 12) || (i == 16) || (i == 20))
    f8ba:	4665      	mov	r5, ip
    f8bc:	0023      	movs	r3, r4
    f8be:	43ab      	bics	r3, r5
    f8c0:	3b08      	subs	r3, #8
    f8c2:	43b3      	bics	r3, r6
    f8c4:	b2db      	uxtb	r3, r3
    f8c6:	0015      	movs	r5, r2
    f8c8:	2b00      	cmp	r3, #0
    f8ca:	d102      	bne.n	f8d2 <at_parse_convert_hexstring_to_uuid.part.0+0x26>
            des_buf[j++] = '-';
    f8cc:	3501      	adds	r5, #1
    f8ce:	b2ed      	uxtb	r5, r5
    f8d0:	548f      	strb	r7, [r1, r2]
        des_buf[j++] = src_buf[i];
    f8d2:	5d03      	ldrb	r3, [r0, r4]
    f8d4:	1c6a      	adds	r2, r5, #1
    f8d6:	3401      	adds	r4, #1
    f8d8:	b2d2      	uxtb	r2, r2
    f8da:	554b      	strb	r3, [r1, r5]
    for (i = 0, j = 0; i < UUID_LEN; i++)
    f8dc:	2c20      	cmp	r4, #32
    f8de:	d1ec      	bne.n	f8ba <at_parse_convert_hexstring_to_uuid.part.0+0xe>
    des_buf[j] = '\0';
    f8e0:	2300      	movs	r3, #0
}
    f8e2:	2001      	movs	r0, #1
    des_buf[j] = '\0';
    f8e4:	548b      	strb	r3, [r1, r2]
}
    f8e6:	bdf0      	pop	{r4, r5, r6, r7, pc}

0000f8e8 <at_handle_CGSN_cmd_exec>:
{
    f8e8:	b510      	push	{r4, lr}
    f8ea:	b098      	sub	sp, #96	; 0x60
    char              at_terminal_id_string[AT_CGSN_RSP_MAX_LEN] = {0};
    f8ec:	2227      	movs	r2, #39	; 0x27
    f8ee:	2100      	movs	r1, #0
    f8f0:	a804      	add	r0, sp, #16
    f8f2:	f7f0 fcf5 	bl	2e0 <memset>
    char              rsp_string[AT_CGSN_RSP_MAX_LEN] = {0};
    f8f6:	2227      	movs	r2, #39	; 0x27
    f8f8:	2100      	movs	r1, #0
    f8fa:	a80e      	add	r0, sp, #56	; 0x38
    f8fc:	f7f0 fcf0 	bl	2e0 <memset>
    uint8             data[SERIALNUMBER_LENGTH] = {0};
    f900:	2210      	movs	r2, #16
    f902:	2100      	movs	r1, #0
    f904:	4668      	mov	r0, sp
    f906:	f7f0 fceb 	bl	2e0 <memset>
    if (get_serial_number(data) != NEUL_RET_OK)
    f90a:	4668      	mov	r0, sp
    f90c:	f00d faae 	bl	1ce6c <get_serial_number>
    f910:	0004      	movs	r4, r0
        return AT_RET_PROGRESS_ERROR;
    f912:	2006      	movs	r0, #6
    if (get_serial_number(data) != NEUL_RET_OK)
    f914:	2c00      	cmp	r4, #0
    f916:	d107      	bne.n	f928 <at_handle_CGSN_cmd_exec+0x40>
    if (at_parse_buf_to_hex_forward_order(data, (uint8*)at_terminal_id_string, SERIALNUMBER_LENGTH) != true)
    f918:	2210      	movs	r2, #16
    f91a:	a904      	add	r1, sp, #16
    f91c:	4668      	mov	r0, sp
    f91e:	f7fa fc0c 	bl	a13a <at_parse_buf_to_hex_forward_order>
    f922:	2800      	cmp	r0, #0
    f924:	d102      	bne.n	f92c <at_handle_CGSN_cmd_exec+0x44>
        return AT_RET_SYNTAX_ERROR;
    f926:	2001      	movs	r0, #1
}
    f928:	b018      	add	sp, #96	; 0x60
    f92a:	bd10      	pop	{r4, pc}
    f92c:	a90e      	add	r1, sp, #56	; 0x38
    f92e:	a804      	add	r0, sp, #16
    f930:	f7ff ffbc 	bl	f8ac <at_parse_convert_hexstring_to_uuid.part.0>
    if (at_parse_convert_hexstring_to_uuid(at_terminal_id_string, rsp_string) != true)
    f934:	2800      	cmp	r0, #0
    f936:	d0f6      	beq.n	f926 <at_handle_CGSN_cmd_exec+0x3e>
    app_at_send_at_rsp_string_lines(rsp_string, true, AT_FLAG_UNLOGABLE);
    f938:	a80e      	add	r0, sp, #56	; 0x38
    f93a:	2204      	movs	r2, #4
    f93c:	2101      	movs	r1, #1
    f93e:	f7f9 fe4a 	bl	95d6 <app_at_send_at_rsp_string_lines>
    return AT_RET_OK;
    f942:	0020      	movs	r0, r4
    f944:	e7f0      	b.n	f928 <at_handle_CGSN_cmd_exec+0x40>
	...

0000f948 <at_handle_CGSN_cmd_set>:
{
    f948:	b530      	push	{r4, r5, lr}
    f94a:	b09b      	sub	sp, #108	; 0x6c
    f94c:	0004      	movs	r4, r0
    char              at_terminal_id_string[AT_CGSN_RSP_MAX_LEN] = {0};
    f94e:	2227      	movs	r2, #39	; 0x27
    f950:	2100      	movs	r1, #0
    f952:	a806      	add	r0, sp, #24
    f954:	f7f0 fcc4 	bl	2e0 <memset>
    char              rsp_string[AT_CGSN_RSP_MAX_LEN] = {0};
    f958:	2227      	movs	r2, #39	; 0x27
    f95a:	2100      	movs	r1, #0
    f95c:	a810      	add	r0, sp, #64	; 0x40
    f95e:	f7f0 fcbf 	bl	2e0 <memset>
    uint8             data[SERIALNUMBER_LENGTH] = {0}; // max length for binary data
    f962:	2210      	movs	r2, #16
    f964:	2100      	movs	r1, #0
    f966:	a802      	add	r0, sp, #8
    f968:	f7f0 fcba 	bl	2e0 <memset>
    cause = at_create_param_array(p_atparams_string, &num_recvparams, 1, 1);
    f96c:	2301      	movs	r3, #1
    f96e:	4669      	mov	r1, sp
    f970:	0020      	movs	r0, r4
    f972:	001a      	movs	r2, r3
    f974:	3105      	adds	r1, #5
    f976:	f7fa fcb5 	bl	a2e4 <at_create_param_array>
    f97a:	1e04      	subs	r4, r0, #0
    if(cause != AT_RET_OK)
    f97c:	d108      	bne.n	f990 <at_handle_CGSN_cmd_set+0x48>
    cause = at_get_uint16_param(AT_PARSE_FIRST_PARAM_POS, &snt, true);
    f97e:	466b      	mov	r3, sp
    f980:	1d9d      	adds	r5, r3, #6
    f982:	2201      	movs	r2, #1
    f984:	0029      	movs	r1, r5
    f986:	f7fa fdc1 	bl	a50c <at_get_uint16_param>
    f98a:	1e04      	subs	r4, r0, #0
    if(cause != AT_RET_OK)
    f98c:	d003      	beq.n	f996 <at_handle_CGSN_cmd_set+0x4e>
        return AT_RET_SYNTAX_ERROR;
    f98e:	2401      	movs	r4, #1
}
    f990:	0020      	movs	r0, r4
    f992:	b01b      	add	sp, #108	; 0x6c
    f994:	bd30      	pop	{r4, r5, pc}
    switch((CGSN_SNT)snt)
    f996:	7828      	ldrb	r0, [r5, #0]
    f998:	2803      	cmp	r0, #3
    f99a:	d808      	bhi.n	f9ae <at_handle_CGSN_cmd_set+0x66>
    f99c:	f7f0 fd02 	bl	3a4 <__gnu_thumb1_case_uqi>
    f9a0:	4b3d2f02 	.word	0x4b3d2f02
            if(get_serial_number(data) != NEUL_RET_OK)
    f9a4:	a802      	add	r0, sp, #8
    f9a6:	f00d fa61 	bl	1ce6c <get_serial_number>
    f9aa:	2800      	cmp	r0, #0
    f9ac:	d001      	beq.n	f9b2 <at_handle_CGSN_cmd_set+0x6a>
            return AT_RET_PROGRESS_ERROR;
    f9ae:	2406      	movs	r4, #6
    f9b0:	e7ee      	b.n	f990 <at_handle_CGSN_cmd_set+0x48>
            if (at_parse_buf_to_hex_forward_order(data, (uint8*)rsp_string, SERIALNUMBER_LENGTH) != true)
    f9b2:	2210      	movs	r2, #16
    f9b4:	a910      	add	r1, sp, #64	; 0x40
    f9b6:	a802      	add	r0, sp, #8
    f9b8:	f7fa fbbf 	bl	a13a <at_parse_buf_to_hex_forward_order>
    f9bc:	2800      	cmp	r0, #0
    f9be:	d0e6      	beq.n	f98e <at_handle_CGSN_cmd_set+0x46>
    f9c0:	a906      	add	r1, sp, #24
    f9c2:	a810      	add	r0, sp, #64	; 0x40
    f9c4:	f7ff ff72 	bl	f8ac <at_parse_convert_hexstring_to_uuid.part.0>
            if (at_parse_convert_hexstring_to_uuid(rsp_string, at_terminal_id_string) != true)
    f9c8:	2800      	cmp	r0, #0
    f9ca:	d0e0      	beq.n	f98e <at_handle_CGSN_cmd_set+0x46>
    if ((snt >= 1) && (snt <= 3))
    f9cc:	882b      	ldrh	r3, [r5, #0]
    uint16            rsp_len = 0;
    f9ce:	2000      	movs	r0, #0
    if ((snt >= 1) && (snt <= 3))
    f9d0:	3b01      	subs	r3, #1
    f9d2:	2b02      	cmp	r3, #2
    f9d4:	d805      	bhi.n	f9e2 <at_handle_CGSN_cmd_set+0x9a>
        rsp_len = (uint16)snprintf(rsp_string, AT_CGSN_RSP_MAX_LEN, CGSN_PREFIX);
    f9d6:	4a1f      	ldr	r2, [pc, #124]	; (fa54 <at_handle_CGSN_cmd_set+0x10c>)
    f9d8:	2127      	movs	r1, #39	; 0x27
    f9da:	a810      	add	r0, sp, #64	; 0x40
    f9dc:	f00a ff46 	bl	1a86c <snprintf>
    f9e0:	b280      	uxth	r0, r0
    (void)snprintf((rsp_string + rsp_len), (AT_CGSN_RSP_MAX_LEN - rsp_len), "%s", at_terminal_id_string);
    f9e2:	2127      	movs	r1, #39	; 0x27
    f9e4:	ab10      	add	r3, sp, #64	; 0x40
    f9e6:	1a09      	subs	r1, r1, r0
    f9e8:	4a1b      	ldr	r2, [pc, #108]	; (fa58 <at_handle_CGSN_cmd_set+0x110>)
    f9ea:	1818      	adds	r0, r3, r0
    f9ec:	ab06      	add	r3, sp, #24
    f9ee:	f00a ff3d 	bl	1a86c <snprintf>
    app_at_send_at_rsp_string_lines(rsp_string, true, AT_FLAG_UNLOGABLE);
    f9f2:	2204      	movs	r2, #4
    f9f4:	2101      	movs	r1, #1
    f9f6:	a810      	add	r0, sp, #64	; 0x40
    f9f8:	f7f9 fded 	bl	95d6 <app_at_send_at_rsp_string_lines>
    return AT_RET_OK;
    f9fc:	e7c8      	b.n	f990 <at_handle_CGSN_cmd_set+0x48>
            if(get_imei(data) != NEUL_RET_OK)
    f9fe:	a802      	add	r0, sp, #8
    fa00:	f00d f9dc 	bl	1cdbc <get_imei>
    fa04:	2800      	cmp	r0, #0
    fa06:	d1d2      	bne.n	f9ae <at_handle_CGSN_cmd_set+0x66>
            str_ret_len = (uint16)neul_string_convert_BCD_to_str(at_terminal_id_string, data, IMEI_LEN);
    fa08:	220f      	movs	r2, #15
    fa0a:	a902      	add	r1, sp, #8
    fa0c:	a806      	add	r0, sp, #24
    fa0e:	f00d fe0b 	bl	1d628 <neul_string_convert_BCD_to_str>
            if (str_ret_len != IMEI_LEN)
    fa12:	b280      	uxth	r0, r0
    fa14:	280f      	cmp	r0, #15
    fa16:	d1ba      	bne.n	f98e <at_handle_CGSN_cmd_set+0x46>
    fa18:	e7d8      	b.n	f9cc <at_handle_CGSN_cmd_set+0x84>
            if(get_imeisv(data) != NEUL_RET_OK)
    fa1a:	a802      	add	r0, sp, #8
    fa1c:	f00d fa06 	bl	1ce2c <get_imeisv>
    fa20:	2800      	cmp	r0, #0
    fa22:	d1c4      	bne.n	f9ae <at_handle_CGSN_cmd_set+0x66>
            str_ret_len = (uint16)neul_string_convert_BCD_to_str(at_terminal_id_string, data, IMEISV_LEN);
    fa24:	2210      	movs	r2, #16
    fa26:	a902      	add	r1, sp, #8
    fa28:	a806      	add	r0, sp, #24
    fa2a:	f00d fdfd 	bl	1d628 <neul_string_convert_BCD_to_str>
            if (str_ret_len != IMEISV_LEN)
    fa2e:	b280      	uxth	r0, r0
    fa30:	2810      	cmp	r0, #16
    fa32:	d1ac      	bne.n	f98e <at_handle_CGSN_cmd_set+0x46>
    fa34:	e7ca      	b.n	f9cc <at_handle_CGSN_cmd_set+0x84>
            if(get_svn(data) != NEUL_RET_OK)
    fa36:	a802      	add	r0, sp, #8
    fa38:	f00d f9ec 	bl	1ce14 <get_svn>
    fa3c:	2800      	cmp	r0, #0
    fa3e:	d1b6      	bne.n	f9ae <at_handle_CGSN_cmd_set+0x66>
            str_ret_len = (uint16)neul_string_convert_BCD_to_str(at_terminal_id_string, data, SVN_LEN);
    fa40:	2202      	movs	r2, #2
    fa42:	a902      	add	r1, sp, #8
    fa44:	a806      	add	r0, sp, #24
    fa46:	f00d fdef 	bl	1d628 <neul_string_convert_BCD_to_str>
            if (str_ret_len != SVN_LEN)
    fa4a:	b280      	uxth	r0, r0
    fa4c:	2802      	cmp	r0, #2
    fa4e:	d19e      	bne.n	f98e <at_handle_CGSN_cmd_set+0x46>
    fa50:	e7bc      	b.n	f9cc <at_handle_CGSN_cmd_set+0x84>
    fa52:	46c0      	nop			; (mov r8, r8)
    fa54:	000237b6 	.word	0x000237b6
    fa58:	000237d7 	.word	0x000237d7

0000fa5c <at_uint8_to_binary_string.part.1>:
static bool at_uint8_to_binary_string(char *str_binary, uint8 bit_num, uint8 value)
    fa5c:	b530      	push	{r4, r5, lr}
        bit   = value & 0x1 ? 1 : 0;
    fa5e:	2501      	movs	r5, #1
        str_binary[i - 1] = (char)(bit + '0');
    fa60:	0013      	movs	r3, r2
    fa62:	1844      	adds	r4, r0, r1
    fa64:	402b      	ands	r3, r5
    for (i = bit_num; i > 0; i--)
    fa66:	3901      	subs	r1, #1
        str_binary[i - 1] = (char)(bit + '0');
    fa68:	3c01      	subs	r4, #1
    fa6a:	3330      	adds	r3, #48	; 0x30
    for (i = bit_num; i > 0; i--)
    fa6c:	b2c9      	uxtb	r1, r1
        str_binary[i - 1] = (char)(bit + '0');
    fa6e:	0852      	lsrs	r2, r2, #1
    fa70:	7023      	strb	r3, [r4, #0]
    for (i = bit_num; i > 0; i--)
    fa72:	2900      	cmp	r1, #0
    fa74:	d1f4      	bne.n	fa60 <at_uint8_to_binary_string.part.1+0x4>
}
    fa76:	2001      	movs	r0, #1
    fa78:	bd30      	pop	{r4, r5, pc}
	...

0000fa7c <at_set_edrx_ptwedrx_changed_callback>:
{
    fa7c:	b5f0      	push	{r4, r5, r6, r7, lr}
    fa7e:	b09f      	sub	sp, #124	; 0x7c
    fa80:	9307      	str	r3, [sp, #28]
    fa82:	ab24      	add	r3, sp, #144	; 0x90
    fa84:	781b      	ldrb	r3, [r3, #0]
    fa86:	9004      	str	r0, [sp, #16]
    fa88:	9308      	str	r3, [sp, #32]
    fa8a:	ab25      	add	r3, sp, #148	; 0x94
    fa8c:	781b      	ldrb	r3, [r3, #0]
    fa8e:	9105      	str	r1, [sp, #20]
    fa90:	9206      	str	r2, [sp, #24]
    char  rsp_string[AT_CEDRXS_RESPONSE_MAX_LEN] = {0};
    fa92:	2100      	movs	r1, #0
    fa94:	2229      	movs	r2, #41	; 0x29
    char  requested_edrx_string[AT_CEDRXS_BINARY_STRING_LEN] = {0};
    fa96:	ac0b      	add	r4, sp, #44	; 0x2c
    char  rsp_string[AT_CEDRXS_RESPONSE_MAX_LEN] = {0};
    fa98:	a813      	add	r0, sp, #76	; 0x4c
{
    fa9a:	9309      	str	r3, [sp, #36]	; 0x24
    char  nw_provided_edrx_string[AT_CEDRXS_BINARY_STRING_LEN] = {0};
    fa9c:	ad0d      	add	r5, sp, #52	; 0x34
    char  rsp_string[AT_CEDRXS_RESPONSE_MAX_LEN] = {0};
    fa9e:	f7f0 fc1f 	bl	2e0 <memset>
    char  requested_edrx_string[AT_CEDRXS_BINARY_STRING_LEN] = {0};
    faa2:	2206      	movs	r2, #6
    faa4:	2100      	movs	r1, #0
    faa6:	0020      	movs	r0, r4
    faa8:	f7f0 fc1a 	bl	2e0 <memset>
    char  paging_time_window_string[AT_CEDRXS_BINARY_STRING_LEN] = {0};
    faac:	ae0f      	add	r6, sp, #60	; 0x3c
    char  nw_provided_edrx_string[AT_CEDRXS_BINARY_STRING_LEN] = {0};
    faae:	2206      	movs	r2, #6
    fab0:	2100      	movs	r1, #0
    fab2:	0028      	movs	r0, r5
    fab4:	f7f0 fc14 	bl	2e0 <memset>
    char  requested_paging_time_window_string[AT_CEDRXS_BINARY_STRING_LEN] = {0};
    fab8:	af11      	add	r7, sp, #68	; 0x44
    char  paging_time_window_string[AT_CEDRXS_BINARY_STRING_LEN] = {0};
    faba:	2206      	movs	r2, #6
    fabc:	2100      	movs	r1, #0
    fabe:	0030      	movs	r0, r6
    fac0:	f7f0 fc0e 	bl	2e0 <memset>
    char  requested_paging_time_window_string[AT_CEDRXS_BINARY_STRING_LEN] = {0};
    fac4:	2206      	movs	r2, #6
    fac6:	2100      	movs	r1, #0
    fac8:	0038      	movs	r0, r7
    faca:	f7f0 fc09 	bl	2e0 <memset>
    face:	9a05      	ldr	r2, [sp, #20]
    fad0:	2104      	movs	r1, #4
    fad2:	0020      	movs	r0, r4
    fad4:	f7ff ffc2 	bl	fa5c <at_uint8_to_binary_string.part.1>
    if (at_uint8_to_binary_string(requested_edrx_string, 4, requested_edrx_value)
    fad8:	2800      	cmp	r0, #0
    fada:	d027      	beq.n	fb2c <at_set_edrx_ptwedrx_changed_callback+0xb0>
    fadc:	9a06      	ldr	r2, [sp, #24]
    fade:	2104      	movs	r1, #4
    fae0:	0028      	movs	r0, r5
    fae2:	f7ff ffbb 	bl	fa5c <at_uint8_to_binary_string.part.1>
        && at_uint8_to_binary_string(nw_provided_edrx_string, 4, nw_provided_edrx_value)
    fae6:	2800      	cmp	r0, #0
    fae8:	d020      	beq.n	fb2c <at_set_edrx_ptwedrx_changed_callback+0xb0>
    faea:	9a07      	ldr	r2, [sp, #28]
    faec:	2104      	movs	r1, #4
    faee:	0030      	movs	r0, r6
    faf0:	f7ff ffb4 	bl	fa5c <at_uint8_to_binary_string.part.1>
        && at_uint8_to_binary_string(paging_time_window_string, 4, paging_time_window)
    faf4:	2800      	cmp	r0, #0
    faf6:	d019      	beq.n	fb2c <at_set_edrx_ptwedrx_changed_callback+0xb0>
    faf8:	9a08      	ldr	r2, [sp, #32]
    fafa:	2104      	movs	r1, #4
    fafc:	0038      	movs	r0, r7
    fafe:	f7ff ffad 	bl	fa5c <at_uint8_to_binary_string.part.1>
        && at_uint8_to_binary_string(requested_paging_time_window_string, 4, requested_paging_time_window))
    fb02:	2800      	cmp	r0, #0
    fb04:	d012      	beq.n	fb2c <at_set_edrx_ptwedrx_changed_callback+0xb0>
        if (is_nptwedrx)
    fb06:	9b09      	ldr	r3, [sp, #36]	; 0x24
    fb08:	2b00      	cmp	r3, #0
    fb0a:	d011      	beq.n	fb30 <at_set_edrx_ptwedrx_changed_callback+0xb4>
            (void)snprintf(rsp_string, AT_CEDRXS_RESPONSE_MAX_LEN, "+NPTWEDRXP:%d,\"%s\",\"%s\",\"%s\",\"%s\"", act_type, requested_paging_time_window_string, requested_edrx_string, nw_provided_edrx_string, paging_time_window_string);
    fb0c:	9603      	str	r6, [sp, #12]
    fb0e:	9502      	str	r5, [sp, #8]
    fb10:	9401      	str	r4, [sp, #4]
    fb12:	9700      	str	r7, [sp, #0]
    fb14:	9b04      	ldr	r3, [sp, #16]
    fb16:	4a0b      	ldr	r2, [pc, #44]	; (fb44 <at_set_edrx_ptwedrx_changed_callback+0xc8>)
    fb18:	2129      	movs	r1, #41	; 0x29
    fb1a:	a813      	add	r0, sp, #76	; 0x4c
    fb1c:	f00a fea6 	bl	1a86c <snprintf>
        delayed_async_print(rsp_string, AT_FLAG_LOGABLE, 0, 0);
    fb20:	2300      	movs	r3, #0
    fb22:	2108      	movs	r1, #8
    fb24:	001a      	movs	r2, r3
    fb26:	a813      	add	r0, sp, #76	; 0x4c
    fb28:	f7fb f8c8 	bl	acbc <delayed_async_print>
}
    fb2c:	b01f      	add	sp, #124	; 0x7c
    fb2e:	bdf0      	pop	{r4, r5, r6, r7, pc}
            (void)snprintf(rsp_string, AT_CEDRXS_RESPONSE_MAX_LEN, "+CEDRXP:%d,\"%s\",\"%s\",\"%s\"", act_type, requested_edrx_string, nw_provided_edrx_string, paging_time_window_string);
    fb30:	9602      	str	r6, [sp, #8]
    fb32:	9501      	str	r5, [sp, #4]
    fb34:	9400      	str	r4, [sp, #0]
    fb36:	9b04      	ldr	r3, [sp, #16]
    fb38:	4a03      	ldr	r2, [pc, #12]	; (fb48 <at_set_edrx_ptwedrx_changed_callback+0xcc>)
    fb3a:	2129      	movs	r1, #41	; 0x29
    fb3c:	a813      	add	r0, sp, #76	; 0x4c
    fb3e:	f00a fe95 	bl	1a86c <snprintf>
    fb42:	e7ed      	b.n	fb20 <at_set_edrx_ptwedrx_changed_callback+0xa4>
    fb44:	00023e2a 	.word	0x00023e2a
    fb48:	00023e4c 	.word	0x00023e4c

0000fb4c <at_set_edrx_changed_callback>:
{
    fb4c:	b513      	push	{r0, r1, r4, lr}
   at_set_edrx_ptwedrx_changed_callback(act_type, requested_edrx_value, nw_provided_edrx_value, paging_time_window, requested_paging_time_window, false);
    fb4e:	2400      	movs	r4, #0
    fb50:	9401      	str	r4, [sp, #4]
    fb52:	9400      	str	r4, [sp, #0]
    fb54:	f7ff ff92 	bl	fa7c <at_set_edrx_ptwedrx_changed_callback>
}
    fb58:	bd13      	pop	{r0, r1, r4, pc}

0000fb5a <at_set_ptwedrx_changed_callback>:
{
    fb5a:	b537      	push	{r0, r1, r2, r4, r5, lr}
   at_set_edrx_ptwedrx_changed_callback(act_type, requested_edrx_value, nw_provided_edrx_value, paging_time_window, requested_paging_time_window, true);
    fb5c:	2501      	movs	r5, #1
{
    fb5e:	ac06      	add	r4, sp, #24
    fb60:	7824      	ldrb	r4, [r4, #0]
   at_set_edrx_ptwedrx_changed_callback(act_type, requested_edrx_value, nw_provided_edrx_value, paging_time_window, requested_paging_time_window, true);
    fb62:	9501      	str	r5, [sp, #4]
    fb64:	9400      	str	r4, [sp, #0]
    fb66:	f7ff ff89 	bl	fa7c <at_set_edrx_ptwedrx_changed_callback>
}
    fb6a:	bd37      	pop	{r0, r1, r2, r4, r5, pc}

0000fb6c <at_handle_CEDRXRDP_cmd_exec>:
{
    fb6c:	b5f0      	push	{r4, r5, r6, r7, lr}
    uint8   registered_state    = 0;
    fb6e:	2400      	movs	r4, #0
{
    fb70:	b09d      	sub	sp, #116	; 0x74
    uint8   act_type            = 0;
    fb72:	2717      	movs	r7, #23
    uint8   request_edrx        = 0;
    fb74:	2519      	movs	r5, #25
    uint8   registered_state    = 0;
    fb76:	466b      	mov	r3, sp
    uint8   act_type            = 0;
    fb78:	446f      	add	r7, sp
    uint8   edrx_valid          = 0;
    fb7a:	ae06      	add	r6, sp, #24
    uint8   request_edrx        = 0;
    fb7c:	446d      	add	r5, sp
    char    rsp_string[AT_CEDRXRDP_RESPONSE_MAX_LEN] = {0};
    fb7e:	223a      	movs	r2, #58	; 0x3a
    fb80:	0021      	movs	r1, r4
    fb82:	a80d      	add	r0, sp, #52	; 0x34
    uint8   registered_state    = 0;
    fb84:	759c      	strb	r4, [r3, #22]
    uint8   nw_provided_edrx    = 0;
    fb86:	769c      	strb	r4, [r3, #26]
    uint8   paging_time         = 0;
    fb88:	76dc      	strb	r4, [r3, #27]
    uint8   act_type            = 0;
    fb8a:	703c      	strb	r4, [r7, #0]
    uint8   edrx_valid          = 0;
    fb8c:	7034      	strb	r4, [r6, #0]
    uint8   request_edrx        = 0;
    fb8e:	702c      	strb	r4, [r5, #0]
    char    rsp_string[AT_CEDRXRDP_RESPONSE_MAX_LEN] = {0};
    fb90:	f7f0 fba6 	bl	2e0 <memset>
    char    request_edrx_string[AT_CEDRXS_BINARY_STRING_LEN] = {0};
    fb94:	2206      	movs	r2, #6
    fb96:	0021      	movs	r1, r4
    fb98:	a807      	add	r0, sp, #28
    fb9a:	f7f0 fba1 	bl	2e0 <memset>
    char    provided_edrx_string[AT_CEDRXS_BINARY_STRING_LEN] = {0};
    fb9e:	2206      	movs	r2, #6
    fba0:	0021      	movs	r1, r4
    fba2:	a809      	add	r0, sp, #36	; 0x24
    fba4:	f7f0 fb9c 	bl	2e0 <memset>
    char    paging_time_string[AT_CEDRXS_BINARY_STRING_LEN] = {0};
    fba8:	2206      	movs	r2, #6
    fbaa:	0021      	movs	r1, r4
    fbac:	a80b      	add	r0, sp, #44	; 0x2c
    fbae:	f7f0 fb97 	bl	2e0 <memset>
    if (get_edrxedp(&registered_state, &act_type, &edrx_valid, &request_edrx, &nw_provided_edrx, &paging_time) != NEUL_RET_OK)
    fbb2:	231b      	movs	r3, #27
    fbb4:	446b      	add	r3, sp
    fbb6:	9301      	str	r3, [sp, #4]
    fbb8:	231a      	movs	r3, #26
    fbba:	2016      	movs	r0, #22
    fbbc:	446b      	add	r3, sp
    fbbe:	9300      	str	r3, [sp, #0]
    fbc0:	0032      	movs	r2, r6
    fbc2:	002b      	movs	r3, r5
    fbc4:	0039      	movs	r1, r7
    fbc6:	4468      	add	r0, sp
    fbc8:	f00c fddc 	bl	1c784 <get_edrxedp>
    fbcc:	42a0      	cmp	r0, r4
    fbce:	d002      	beq.n	fbd6 <at_handle_CEDRXRDP_cmd_exec+0x6a>
        return AT_RET_PROGRESS_ERROR;
    fbd0:	2006      	movs	r0, #6
}
    fbd2:	b01d      	add	sp, #116	; 0x74
    fbd4:	bdf0      	pop	{r4, r5, r6, r7, pc}
    if (edrx_valid)
    fbd6:	7833      	ldrb	r3, [r6, #0]
    fbd8:	2b00      	cmp	r3, #0
    fbda:	d027      	beq.n	fc2c <at_handle_CEDRXRDP_cmd_exec+0xc0>
    fbdc:	782a      	ldrb	r2, [r5, #0]
    fbde:	2104      	movs	r1, #4
    fbe0:	a807      	add	r0, sp, #28
    fbe2:	f7ff ff3b 	bl	fa5c <at_uint8_to_binary_string.part.1>
        if ((at_uint8_to_binary_string(request_edrx_string, 4, request_edrx) == false) ||
    fbe6:	2800      	cmp	r0, #0
    fbe8:	d0f2      	beq.n	fbd0 <at_handle_CEDRXRDP_cmd_exec+0x64>
    fbea:	466b      	mov	r3, sp
    fbec:	2104      	movs	r1, #4
    fbee:	7e9a      	ldrb	r2, [r3, #26]
    fbf0:	a809      	add	r0, sp, #36	; 0x24
    fbf2:	f7ff ff33 	bl	fa5c <at_uint8_to_binary_string.part.1>
    fbf6:	2800      	cmp	r0, #0
    fbf8:	d0ea      	beq.n	fbd0 <at_handle_CEDRXRDP_cmd_exec+0x64>
    fbfa:	466b      	mov	r3, sp
    fbfc:	2104      	movs	r1, #4
    fbfe:	7eda      	ldrb	r2, [r3, #27]
    fc00:	a80b      	add	r0, sp, #44	; 0x2c
    fc02:	f7ff ff2b 	bl	fa5c <at_uint8_to_binary_string.part.1>
            (at_uint8_to_binary_string(provided_edrx_string, 4, nw_provided_edrx) == false) ||
    fc06:	2800      	cmp	r0, #0
    fc08:	d0e2      	beq.n	fbd0 <at_handle_CEDRXRDP_cmd_exec+0x64>
        (void)snprintf(rsp_string, AT_CEDRXRDP_RESPONSE_MAX_LEN, "+CEDRXRDP:%d,\"%s\",\"%s\",\"%s\"",act_type, request_edrx_string, provided_edrx_string, paging_time_string);
    fc0a:	aa0b      	add	r2, sp, #44	; 0x2c
    fc0c:	783b      	ldrb	r3, [r7, #0]
    fc0e:	9202      	str	r2, [sp, #8]
    fc10:	aa09      	add	r2, sp, #36	; 0x24
    fc12:	9201      	str	r2, [sp, #4]
    fc14:	aa07      	add	r2, sp, #28
    fc16:	9200      	str	r2, [sp, #0]
    fc18:	213a      	movs	r1, #58	; 0x3a
    fc1a:	4a08      	ldr	r2, [pc, #32]	; (fc3c <at_handle_CEDRXRDP_cmd_exec+0xd0>)
    fc1c:	a80d      	add	r0, sp, #52	; 0x34
    fc1e:	f00a fe25 	bl	1a86c <snprintf>
    app_at_send_at_rsp_string_lines_with_claim_and_log(rsp_string);
    fc22:	a80d      	add	r0, sp, #52	; 0x34
    fc24:	f7f9 fcde 	bl	95e4 <app_at_send_at_rsp_string_lines_with_claim_and_log>
    return AT_RET_OK;
    fc28:	2000      	movs	r0, #0
    fc2a:	e7d2      	b.n	fbd2 <at_handle_CEDRXRDP_cmd_exec+0x66>
        (void)snprintf(rsp_string, AT_CEDRXRDP_RESPONSE_MAX_LEN, "+CEDRXRDP:%d", act_type);
    fc2c:	783b      	ldrb	r3, [r7, #0]
    fc2e:	4a04      	ldr	r2, [pc, #16]	; (fc40 <at_handle_CEDRXRDP_cmd_exec+0xd4>)
    fc30:	213a      	movs	r1, #58	; 0x3a
    fc32:	a80d      	add	r0, sp, #52	; 0x34
    fc34:	f00a fe1a 	bl	1a86c <snprintf>
    fc38:	e7f3      	b.n	fc22 <at_handle_CEDRXRDP_cmd_exec+0xb6>
    fc3a:	46c0      	nop			; (mov r8, r8)
    fc3c:	000235d3 	.word	0x000235d3
    fc40:	000235ef 	.word	0x000235ef

0000fc44 <at_cedrxs_nptwedrxs_common_handle_read>:
{
    fc44:	b5f0      	push	{r4, r5, r6, r7, lr}
    uint8 type = 0;
    fc46:	2700      	movs	r7, #0
    fc48:	2411      	movs	r4, #17
    uint8 edrx_value =0;
    fc4a:	2612      	movs	r6, #18
{
    fc4c:	b097      	sub	sp, #92	; 0x5c
    uint8 type = 0;
    fc4e:	ab02      	add	r3, sp, #8
    fc50:	18e4      	adds	r4, r4, r3
    uint8 edrx_value =0;
    fc52:	18f6      	adds	r6, r6, r3
    char  rsp_string[AT_CEDRXS_RESPONSE_MAX_LEN] = {0};
    fc54:	0039      	movs	r1, r7
{
    fc56:	9005      	str	r0, [sp, #20]
    char  rsp_string[AT_CEDRXS_RESPONSE_MAX_LEN] = {0};
    fc58:	2229      	movs	r2, #41	; 0x29
    fc5a:	a80b      	add	r0, sp, #44	; 0x2c
    char  requesteded_edrx_string[AT_CEDRXS_BINARY_STRING_LEN] = {0};
    fc5c:	ad07      	add	r5, sp, #28
    uint8 paging_time_window =0;
    fc5e:	74df      	strb	r7, [r3, #19]
    uint8 type = 0;
    fc60:	7027      	strb	r7, [r4, #0]
    uint8 edrx_value =0;
    fc62:	7037      	strb	r7, [r6, #0]
    char  rsp_string[AT_CEDRXS_RESPONSE_MAX_LEN] = {0};
    fc64:	f7f0 fb3c 	bl	2e0 <memset>
    char  requesteded_edrx_string[AT_CEDRXS_BINARY_STRING_LEN] = {0};
    fc68:	0039      	movs	r1, r7
    fc6a:	2206      	movs	r2, #6
    fc6c:	0028      	movs	r0, r5
    fc6e:	f7f0 fb37 	bl	2e0 <memset>
    char  paging_time_window_string[AT_CEDRXS_BINARY_STRING_LEN] = {0};
    fc72:	0039      	movs	r1, r7
    fc74:	2206      	movs	r2, #6
    fc76:	a809      	add	r0, sp, #36	; 0x24
    fc78:	f7f0 fb32 	bl	2e0 <memset>
    result = get_edrxs_and_ptw(&type, &edrx_value,&paging_time_window);
    fc7c:	2313      	movs	r3, #19
    fc7e:	aa02      	add	r2, sp, #8
    fc80:	189b      	adds	r3, r3, r2
    fc82:	001a      	movs	r2, r3
    fc84:	0031      	movs	r1, r6
    fc86:	0020      	movs	r0, r4
    fc88:	f00c fcb0 	bl	1c5ec <get_edrxs_and_ptw>
    fc8c:	0007      	movs	r7, r0
    cause = at_parse_convert_neul_result(result);
    fc8e:	f7fa faff 	bl	a290 <at_parse_convert_neul_result>
    if (result != NEUL_RET_OK)
    fc92:	2f00      	cmp	r7, #0
    fc94:	d107      	bne.n	fca6 <at_cedrxs_nptwedrxs_common_handle_read+0x62>
    fc96:	7832      	ldrb	r2, [r6, #0]
    fc98:	2104      	movs	r1, #4
    fc9a:	0028      	movs	r0, r5
    fc9c:	f7ff fede 	bl	fa5c <at_uint8_to_binary_string.part.1>
    if (at_uint8_to_binary_string(requesteded_edrx_string, 4, edrx_value) == false)
    fca0:	2800      	cmp	r0, #0
    fca2:	d102      	bne.n	fcaa <at_cedrxs_nptwedrxs_common_handle_read+0x66>
        return AT_RET_PROGRESS_ERROR;
    fca4:	2006      	movs	r0, #6
}
    fca6:	b017      	add	sp, #92	; 0x5c
    fca8:	bdf0      	pop	{r4, r5, r6, r7, pc}
    if (is_nptwedrxs)
    fcaa:	9b05      	ldr	r3, [sp, #20]
    fcac:	2b00      	cmp	r3, #0
    fcae:	d017      	beq.n	fce0 <at_cedrxs_nptwedrxs_common_handle_read+0x9c>
    fcb0:	ab02      	add	r3, sp, #8
    fcb2:	7cda      	ldrb	r2, [r3, #19]
    fcb4:	2104      	movs	r1, #4
    fcb6:	a809      	add	r0, sp, #36	; 0x24
    fcb8:	f7ff fed0 	bl	fa5c <at_uint8_to_binary_string.part.1>
        if (at_uint8_to_binary_string(paging_time_window_string, 4, paging_time_window) == false)
    fcbc:	2800      	cmp	r0, #0
    fcbe:	d0f1      	beq.n	fca4 <at_cedrxs_nptwedrxs_common_handle_read+0x60>
        (void)snprintf(rsp_string, AT_CEDRXS_RESPONSE_MAX_LEN, "%s%d,\"%s\",\"%s\"", AT_CMD_NPTWEDRXS_PREFIX, type, paging_time_window_string, requesteded_edrx_string);
    fcc0:	ab09      	add	r3, sp, #36	; 0x24
    fcc2:	9502      	str	r5, [sp, #8]
    fcc4:	9301      	str	r3, [sp, #4]
    fcc6:	7823      	ldrb	r3, [r4, #0]
    fcc8:	4a0a      	ldr	r2, [pc, #40]	; (fcf4 <at_cedrxs_nptwedrxs_common_handle_read+0xb0>)
    fcca:	9300      	str	r3, [sp, #0]
    fccc:	2129      	movs	r1, #41	; 0x29
    fcce:	4b0a      	ldr	r3, [pc, #40]	; (fcf8 <at_cedrxs_nptwedrxs_common_handle_read+0xb4>)
    fcd0:	a80b      	add	r0, sp, #44	; 0x2c
    fcd2:	f00a fdcb 	bl	1a86c <snprintf>
    app_at_send_at_rsp_string_lines_with_claim_and_log(rsp_string);
    fcd6:	a80b      	add	r0, sp, #44	; 0x2c
    fcd8:	f7f9 fc84 	bl	95e4 <app_at_send_at_rsp_string_lines_with_claim_and_log>
    return AT_RET_OK;
    fcdc:	2000      	movs	r0, #0
    fcde:	e7e2      	b.n	fca6 <at_cedrxs_nptwedrxs_common_handle_read+0x62>
        (void)snprintf(rsp_string, AT_CEDRXS_RESPONSE_MAX_LEN, "%s%d,\"%s\"", AT_CMD_CEDRXS_PREFIX, type, requesteded_edrx_string);
    fce0:	9501      	str	r5, [sp, #4]
    fce2:	7823      	ldrb	r3, [r4, #0]
    fce4:	4a05      	ldr	r2, [pc, #20]	; (fcfc <at_cedrxs_nptwedrxs_common_handle_read+0xb8>)
    fce6:	9300      	str	r3, [sp, #0]
    fce8:	2129      	movs	r1, #41	; 0x29
    fcea:	4b05      	ldr	r3, [pc, #20]	; (fd00 <at_cedrxs_nptwedrxs_common_handle_read+0xbc>)
    fcec:	a80b      	add	r0, sp, #44	; 0x2c
    fcee:	f00a fdbd 	bl	1a86c <snprintf>
    fcf2:	e7f0      	b.n	fcd6 <at_cedrxs_nptwedrxs_common_handle_read+0x92>
    fcf4:	00023507 	.word	0x00023507
    fcf8:	000234fb 	.word	0x000234fb
    fcfc:	0002351f 	.word	0x0002351f
    fd00:	00023516 	.word	0x00023516

0000fd04 <at_handle_NPTWEDRXS_cmd_read>:
{
    fd04:	b510      	push	{r4, lr}
    return at_cedrxs_nptwedrxs_common_handle_read (true);
    fd06:	2001      	movs	r0, #1
    fd08:	f7ff ff9c 	bl	fc44 <at_cedrxs_nptwedrxs_common_handle_read>
}
    fd0c:	bd10      	pop	{r4, pc}

0000fd0e <at_handle_CEDRXS_cmd_read>:
{
    fd0e:	b510      	push	{r4, lr}
    return at_cedrxs_nptwedrxs_common_handle_read (false);
    fd10:	2000      	movs	r0, #0
    fd12:	f7ff ff97 	bl	fc44 <at_cedrxs_nptwedrxs_common_handle_read>
}
    fd16:	bd10      	pop	{r4, pc}

0000fd18 <check_at_allocated_socket>:
{
    fd18:	0003      	movs	r3, r0
        return false;
    fd1a:	2000      	movs	r0, #0
    if (sock_num >= BITS_IN_WORD)
    fd1c:	2b1f      	cmp	r3, #31
    fd1e:	d804      	bhi.n	fd2a <check_at_allocated_socket+0x12>
    if ((sock_at_allocated & ((uint32) 1 << sock_num)) != 0)
    fd20:	4a02      	ldr	r2, [pc, #8]	; (fd2c <check_at_allocated_socket+0x14>)
    fd22:	6810      	ldr	r0, [r2, #0]
    fd24:	40d8      	lsrs	r0, r3
    fd26:	2301      	movs	r3, #1
    fd28:	4018      	ands	r0, r3
}
    fd2a:	4770      	bx	lr
    fd2c:	010024c8 	.word	0x010024c8

0000fd30 <at_handle_NSOSTATUS_cmd_set>:
{
    fd30:	b5f0      	push	{r4, r5, r6, r7, lr}
    uint16                  backoff = 0;
    fd32:	250e      	movs	r5, #14
    fd34:	2300      	movs	r3, #0
    cause = at_create_param_array(p_atparams_string, &num_recvparams, 1, 1);
    fd36:	210b      	movs	r1, #11
{
    fd38:	b085      	sub	sp, #20
    uint16                  backoff = 0;
    fd3a:	446d      	add	r5, sp
    fd3c:	802b      	strh	r3, [r5, #0]
    cause = at_create_param_array(p_atparams_string, &num_recvparams, 1, 1);
    fd3e:	3301      	adds	r3, #1
    fd40:	001a      	movs	r2, r3
    fd42:	4469      	add	r1, sp
    fd44:	f7fa face 	bl	a2e4 <at_create_param_array>
    fd48:	1e04      	subs	r4, r0, #0
    if(cause != AT_RET_OK)
    fd4a:	d115      	bne.n	fd78 <at_handle_NSOSTATUS_cmd_set+0x48>
    cause = at_get_uint8_param(AT_PARSE_FIRST_PARAM_POS, &socketid, true);
    fd4c:	af03      	add	r7, sp, #12
    fd4e:	2201      	movs	r2, #1
    fd50:	0039      	movs	r1, r7
    fd52:	f7fa fc5b 	bl	a60c <at_get_uint8_param>
    fd56:	1e04      	subs	r4, r0, #0
    if(cause != AT_RET_OK)
    fd58:	d127      	bne.n	fdaa <at_handle_NSOSTATUS_cmd_set+0x7a>
    if(!check_at_allocated_socket(socketid) && socketid != 0)
    fd5a:	783e      	ldrb	r6, [r7, #0]
    fd5c:	b2b0      	uxth	r0, r6
    fd5e:	f7ff ffdb 	bl	fd18 <check_at_allocated_socket>
    fd62:	2800      	cmp	r0, #0
    fd64:	d10b      	bne.n	fd7e <at_handle_NSOSTATUS_cmd_set+0x4e>
    fd66:	2e00      	cmp	r6, #0
    fd68:	d009      	beq.n	fd7e <at_handle_NSOSTATUS_cmd_set+0x4e>
        app_at_send_socket_or_cid_status_string(AT_CMD_NSOSTATUS_RSP_PREFIX, socketid, SOCKET_OR_CID_STATUS_NOT_EXIST, backoff, true);
    fd6a:	2201      	movs	r2, #1
    fd6c:	882b      	ldrh	r3, [r5, #0]
    fd6e:	0031      	movs	r1, r6
    fd70:	9200      	str	r2, [sp, #0]
    fd72:	480f      	ldr	r0, [pc, #60]	; (fdb0 <at_handle_NSOSTATUS_cmd_set+0x80>)
    fd74:	f7fb fb1c 	bl	b3b0 <app_at_send_socket_or_cid_status_string>
}
    fd78:	0020      	movs	r0, r4
    fd7a:	b005      	add	sp, #20
    fd7c:	bdf0      	pop	{r4, r5, r6, r7, pc}
    result = get_socket_status(socketid, &status, &backoff);
    fd7e:	240d      	movs	r4, #13
    fd80:	446c      	add	r4, sp
    fd82:	0030      	movs	r0, r6
    fd84:	002a      	movs	r2, r5
    fd86:	0021      	movs	r1, r4
    fd88:	f7f8 f980 	bl	808c <get_socket_status>
    fd8c:	1e06      	subs	r6, r0, #0
    if (result == NEUL_RET_OK)
    fd8e:	d107      	bne.n	fda0 <at_handle_NSOSTATUS_cmd_set+0x70>
        app_at_send_socket_or_cid_status_string(AT_CMD_NSOSTATUS_RSP_PREFIX, socketid, status, backoff, true);
    fd90:	2001      	movs	r0, #1
    fd92:	882b      	ldrh	r3, [r5, #0]
    fd94:	7822      	ldrb	r2, [r4, #0]
    fd96:	7839      	ldrb	r1, [r7, #0]
    fd98:	9000      	str	r0, [sp, #0]
    fd9a:	4805      	ldr	r0, [pc, #20]	; (fdb0 <at_handle_NSOSTATUS_cmd_set+0x80>)
    fd9c:	f7fb fb08 	bl	b3b0 <app_at_send_socket_or_cid_status_string>
    return at_parse_convert_neul_result(result);
    fda0:	0030      	movs	r0, r6
    fda2:	f7fa fa75 	bl	a290 <at_parse_convert_neul_result>
    fda6:	0004      	movs	r4, r0
    fda8:	e7e6      	b.n	fd78 <at_handle_NSOSTATUS_cmd_set+0x48>
        return AT_RET_SYNTAX_ERROR;
    fdaa:	2401      	movs	r4, #1
    fdac:	e7e4      	b.n	fd78 <at_handle_NSOSTATUS_cmd_set+0x48>
    fdae:	46c0      	nop			; (mov r8, r8)
    fdb0:	00023d82 	.word	0x00023d82

0000fdb4 <at_handle_NQSOS_cmd_read>:
{
    fdb4:	b573      	push	{r0, r1, r4, r5, r6, lr}
    bool          is_no_need_cr = true;
    fdb6:	466b      	mov	r3, sp
    fdb8:	1dde      	adds	r6, r3, #7
    fdba:	2301      	movs	r3, #1
    at_uart_claim();
    fdbc:	2400      	movs	r4, #0
    bool          is_no_need_cr = true;
    fdbe:	7033      	strb	r3, [r6, #0]
    at_uart_claim();
    fdc0:	f7f9 fdf2 	bl	99a8 <at_uart_claim>
       if(!check_at_allocated_socket(socket_num))
    fdc4:	b2a0      	uxth	r0, r4
    fdc6:	b2e5      	uxtb	r5, r4
    fdc8:	f7ff ffa6 	bl	fd18 <check_at_allocated_socket>
    fdcc:	2800      	cmp	r0, #0
    fdce:	d009      	beq.n	fde4 <at_handle_NQSOS_cmd_read+0x30>
       cause = at_get_pending_data_list_common_handle(socket_num, &is_no_need_cr);
    fdd0:	0028      	movs	r0, r5
    fdd2:	0031      	movs	r1, r6
    fdd4:	f7fd fb32 	bl	d43c <at_get_pending_data_list_common_handle>
    fdd8:	1e05      	subs	r5, r0, #0
       if (cause != AT_RET_OK)
    fdda:	d003      	beq.n	fde4 <at_handle_NQSOS_cmd_read+0x30>
           at_uart_release();
    fddc:	f7f9 fdf6 	bl	99cc <at_uart_release>
}
    fde0:	0028      	movs	r0, r5
    fde2:	bd76      	pop	{r1, r2, r4, r5, r6, pc}
    fde4:	3401      	adds	r4, #1
    for (uint8 socket_num = NEUL_MIN_SOCKET_SEQ; socket_num < NEUL_MAX_SOCKET_NUM; socket_num++)
    fde6:	2c07      	cmp	r4, #7
    fde8:	d1ec      	bne.n	fdc4 <at_handle_NQSOS_cmd_read+0x10>
    if (!is_no_need_cr)
    fdea:	7833      	ldrb	r3, [r6, #0]
    fdec:	2b00      	cmp	r3, #0
    fdee:	d107      	bne.n	fe00 <at_handle_NQSOS_cmd_read+0x4c>
        at_uart_write((unsigned char*)APP_AT_STR_RN, strlen(APP_AT_STR_RN));
    fdf0:	4c05      	ldr	r4, [pc, #20]	; (fe08 <at_handle_NQSOS_cmd_read+0x54>)
    fdf2:	0020      	movs	r0, r4
    fdf4:	f00b fad3 	bl	1b39e <strlen>
    fdf8:	0001      	movs	r1, r0
    fdfa:	0020      	movs	r0, r4
    fdfc:	f7f9 fdf6 	bl	99ec <at_uart_write>
    at_uart_release();
    fe00:	f7f9 fde4 	bl	99cc <at_uart_release>
    return AT_RET_OK;
    fe04:	2500      	movs	r5, #0
    fe06:	e7eb      	b.n	fde0 <at_handle_NQSOS_cmd_read+0x2c>
    fe08:	00022d8f 	.word	0x00022d8f

0000fe0c <at_handle_NQSOS_cmd_set>:
    bool          is_no_need_cr = true;
    fe0c:	2201      	movs	r2, #1
{
    fe0e:	b5f0      	push	{r4, r5, r6, r7, lr}
    fe10:	b085      	sub	sp, #20
    bool          is_no_need_cr = true;
    fe12:	ab02      	add	r3, sp, #8
    cause = at_create_param_array(p_atparams_string, &num_recvparams, 1, NEUL_MAX_SOCKET_NUM);
    fe14:	a902      	add	r1, sp, #8
    bool          is_no_need_cr = true;
    fe16:	1ddd      	adds	r5, r3, #7
    cause = at_create_param_array(p_atparams_string, &num_recvparams, 1, NEUL_MAX_SOCKET_NUM);
    fe18:	3105      	adds	r1, #5
    fe1a:	2307      	movs	r3, #7
    bool          is_no_need_cr = true;
    fe1c:	702a      	strb	r2, [r5, #0]
    cause = at_create_param_array(p_atparams_string, &num_recvparams, 1, NEUL_MAX_SOCKET_NUM);
    fe1e:	f7fa fa61 	bl	a2e4 <at_create_param_array>
    fe22:	1e04      	subs	r4, r0, #0
    if(cause != AT_RET_OK)
    fe24:	d121      	bne.n	fe6a <at_handle_NQSOS_cmd_set+0x5e>
    at_uart_claim();
    fe26:	f7f9 fdbf 	bl	99a8 <at_uart_claim>
    for (uint8 params_num = 0; params_num < num_recvparams; params_num++)
    fe2a:	0027      	movs	r7, r4
    fe2c:	ab02      	add	r3, sp, #8
    fe2e:	795b      	ldrb	r3, [r3, #5]
    fe30:	42bb      	cmp	r3, r7
    fe32:	d80d      	bhi.n	fe50 <at_handle_NQSOS_cmd_set+0x44>
    if (!is_no_need_cr)
    fe34:	782b      	ldrb	r3, [r5, #0]
    fe36:	2b00      	cmp	r3, #0
    fe38:	d107      	bne.n	fe4a <at_handle_NQSOS_cmd_set+0x3e>
        at_uart_write((unsigned char*)APP_AT_STR_RN, strlen(APP_AT_STR_RN));
    fe3a:	4d17      	ldr	r5, [pc, #92]	; (fe98 <at_handle_NQSOS_cmd_set+0x8c>)
    fe3c:	0028      	movs	r0, r5
    fe3e:	f00b faae 	bl	1b39e <strlen>
    fe42:	0001      	movs	r1, r0
    fe44:	0028      	movs	r0, r5
    fe46:	f7f9 fdd1 	bl	99ec <at_uart_write>
    at_uart_release();
    fe4a:	f7f9 fdbf 	bl	99cc <at_uart_release>
    return AT_RET_OK;
    fe4e:	e00c      	b.n	fe6a <at_handle_NQSOS_cmd_set+0x5e>
       cause = at_get_uint8_param(AT_PARSE_FIRST_PARAM_POS + params_num, &socket_num, true);
    fe50:	ab02      	add	r3, sp, #8
    fe52:	1d9e      	adds	r6, r3, #6
    fe54:	2201      	movs	r2, #1
    fe56:	0031      	movs	r1, r6
    fe58:	0038      	movs	r0, r7
    fe5a:	f7fa fbd7 	bl	a60c <at_get_uint8_param>
    fe5e:	9001      	str	r0, [sp, #4]
       if(cause != AT_RET_OK)
    fe60:	2800      	cmp	r0, #0
    fe62:	d005      	beq.n	fe70 <at_handle_NQSOS_cmd_set+0x64>
           at_uart_release();
    fe64:	f7f9 fdb2 	bl	99cc <at_uart_release>
       cause = at_get_uint8_param(AT_PARSE_FIRST_PARAM_POS + params_num, &socket_num, true);
    fe68:	9c01      	ldr	r4, [sp, #4]
}
    fe6a:	0020      	movs	r0, r4
    fe6c:	b005      	add	sp, #20
    fe6e:	bdf0      	pop	{r4, r5, r6, r7, pc}
       if(!check_at_allocated_socket(socket_num))
    fe70:	7836      	ldrb	r6, [r6, #0]
    fe72:	b2b0      	uxth	r0, r6
    fe74:	f7ff ff50 	bl	fd18 <check_at_allocated_socket>
    fe78:	2800      	cmp	r0, #0
    fe7a:	d009      	beq.n	fe90 <at_handle_NQSOS_cmd_set+0x84>
       cause = at_get_pending_data_list_common_handle(socket_num, &is_no_need_cr);
    fe7c:	0030      	movs	r0, r6
    fe7e:	0029      	movs	r1, r5
    fe80:	f7fd fadc 	bl	d43c <at_get_pending_data_list_common_handle>
    fe84:	1e06      	subs	r6, r0, #0
       if (cause != AT_RET_OK)
    fe86:	d003      	beq.n	fe90 <at_handle_NQSOS_cmd_set+0x84>
           at_uart_release();
    fe88:	f7f9 fda0 	bl	99cc <at_uart_release>
       cause = at_get_pending_data_list_common_handle(socket_num, &is_no_need_cr);
    fe8c:	0034      	movs	r4, r6
           return cause;
    fe8e:	e7ec      	b.n	fe6a <at_handle_NQSOS_cmd_set+0x5e>
    for (uint8 params_num = 0; params_num < num_recvparams; params_num++)
    fe90:	3701      	adds	r7, #1
    fe92:	b2ff      	uxtb	r7, r7
    fe94:	e7ca      	b.n	fe2c <at_handle_NQSOS_cmd_set+0x20>
    fe96:	46c0      	nop			; (mov r8, r8)
    fe98:	00022d8f 	.word	0x00022d8f

0000fe9c <at_handle_NSORF_cmd_set>:
{
    fe9c:	b5f0      	push	{r4, r5, r6, r7, lr}
    fe9e:	b09f      	sub	sp, #124	; 0x7c
    fea0:	0004      	movs	r4, r0
    char              rsp_string[AT_MAX_NSORF_SET_RSP_LEN] = {0};
    fea2:	223c      	movs	r2, #60	; 0x3c
    fea4:	2100      	movs	r1, #0
    fea6:	a80f      	add	r0, sp, #60	; 0x3c
    fea8:	f7f0 fa1a 	bl	2e0 <memset>
    cause = at_create_param_array(p_atparams_string, &num_recvparams, 2, 2);
    feac:	2302      	movs	r3, #2
    feae:	2113      	movs	r1, #19
    feb0:	a802      	add	r0, sp, #8
    feb2:	1809      	adds	r1, r1, r0
    feb4:	001a      	movs	r2, r3
    feb6:	0020      	movs	r0, r4
    feb8:	f7fa fa14 	bl	a2e4 <at_create_param_array>
    febc:	1e04      	subs	r4, r0, #0
    if (cause != AT_RET_OK)
    febe:	d109      	bne.n	fed4 <at_handle_NSORF_cmd_set+0x38>
    cause = at_get_uint16_param(AT_PARSE_FIRST_PARAM_POS, &socket, true);
    fec0:	2616      	movs	r6, #22
    fec2:	ab02      	add	r3, sp, #8
    fec4:	18f6      	adds	r6, r6, r3
    fec6:	2201      	movs	r2, #1
    fec8:	0031      	movs	r1, r6
    feca:	f7fa fb1f 	bl	a50c <at_get_uint16_param>
    if (cause != AT_RET_OK)
    fece:	2800      	cmp	r0, #0
    fed0:	d003      	beq.n	feda <at_handle_NSORF_cmd_set+0x3e>
        return AT_RET_SYNTAX_ERROR;
    fed2:	2401      	movs	r4, #1
}
    fed4:	0020      	movs	r0, r4
    fed6:	b01f      	add	sp, #124	; 0x7c
    fed8:	bdf0      	pop	{r4, r5, r6, r7, pc}
    cause = at_get_uint16_param(AT_PARSE_SECOND_PARAM_POS, &length, true);
    feda:	2201      	movs	r2, #1
    fedc:	af08      	add	r7, sp, #32
    fede:	0039      	movs	r1, r7
    fee0:	0010      	movs	r0, r2
    fee2:	f7fa fb13 	bl	a50c <at_get_uint16_param>
    if (cause != AT_RET_OK)
    fee6:	2800      	cmp	r0, #0
    fee8:	d1f3      	bne.n	fed2 <at_handle_NSORF_cmd_set+0x36>
    if(!check_at_allocated_socket(socket))
    feea:	8830      	ldrh	r0, [r6, #0]
    feec:	f7ff ff14 	bl	fd18 <check_at_allocated_socket>
        return AT_RET_INVALID_SOCKET;
    fef0:	2425      	movs	r4, #37	; 0x25
    if(!check_at_allocated_socket(socket))
    fef2:	2800      	cmp	r0, #0
    fef4:	d0ee      	beq.n	fed4 <at_handle_NSORF_cmd_set+0x38>
    if (app_at_min_ip_mtu_from_active_cids(&ip_mtu_size) != AT_RET_OK)
    fef6:	251a      	movs	r5, #26
    fef8:	ab02      	add	r3, sp, #8
    fefa:	18ed      	adds	r5, r5, r3
    fefc:	0028      	movs	r0, r5
    fefe:	f7f9 f98f 	bl	9220 <app_at_min_ip_mtu_from_active_cids>
    ff02:	1e04      	subs	r4, r0, #0
    ff04:	d001      	beq.n	ff0a <__RAM_SIZE__+0x2a>
        return AT_RET_PROGRESS_ERROR;
    ff06:	2406      	movs	r4, #6
    ff08:	e7e4      	b.n	fed4 <at_handle_NSORF_cmd_set+0x38>
    if (length > ip_mtu_size)
    ff0a:	8838      	ldrh	r0, [r7, #0]
    ff0c:	882b      	ldrh	r3, [r5, #0]
    ff0e:	4283      	cmp	r3, r0
    ff10:	d3f9      	bcc.n	ff06 <__RAM_SIZE__+0x26>
    buffer = irmalloc(length);
    ff12:	f002 fd75 	bl	12a00 <irmalloc>
    ff16:	1e05      	subs	r5, r0, #0
    if (buffer == NULL)
    ff18:	d0f5      	beq.n	ff06 <__RAM_SIZE__+0x26>
    ret = recvfrom(socket, (void *)buffer, length, MSG_NORMAL,  (struct sockaddr *) &sock_address, sizeof(sock_address));   //lint !e740 !e826
    ff1a:	2318      	movs	r3, #24
    ff1c:	883a      	ldrh	r2, [r7, #0]
    ff1e:	8830      	ldrh	r0, [r6, #0]
    ff20:	9301      	str	r3, [sp, #4]
    ff22:	ab09      	add	r3, sp, #36	; 0x24
    ff24:	9300      	str	r3, [sp, #0]
    ff26:	0029      	movs	r1, r5
    ff28:	0023      	movs	r3, r4
    ff2a:	f7f7 fff9 	bl	7f20 <recvfrom>
    ff2e:	0007      	movs	r7, r0
    remaining_length = socklen(socket);
    ff30:	8830      	ldrh	r0, [r6, #0]
    ff32:	f7f8 f873 	bl	801c <socklen>
    ff36:	9005      	str	r0, [sp, #20]
    if ((ret < 0) || (remaining_length < 0))
    ff38:	2f00      	cmp	r7, #0
    ff3a:	db01      	blt.n	ff40 <__RAM_SIZE__+0x60>
    ff3c:	2800      	cmp	r0, #0
    ff3e:	da03      	bge.n	ff48 <__RAM_SIZE__+0x68>
        irfree(buffer);
    ff40:	0028      	movs	r0, r5
    ff42:	f002 fd79 	bl	12a38 <irfree>
    ff46:	e7de      	b.n	ff06 <__RAM_SIZE__+0x26>
    else if (ret == 0)
    ff48:	2f00      	cmp	r7, #0
    ff4a:	d103      	bne.n	ff54 <__RAM_SIZE__+0x74>
    irfree(buffer);
    ff4c:	0028      	movs	r0, r5
    ff4e:	f002 fd73 	bl	12a38 <irfree>
    return AT_RET_OK;
    ff52:	e7bf      	b.n	fed4 <at_handle_NSORF_cmd_set+0x38>
    at_uart_claim();
    ff54:	f7f9 fd28 	bl	99a8 <at_uart_claim>
    at_uart_write((uint8*)APP_AT_STR_RN, strlen(APP_AT_STR_RN));
    ff58:	4825      	ldr	r0, [pc, #148]	; (fff0 <__RAM_SIZE__+0x110>)
    ff5a:	f00b fa20 	bl	1b39e <strlen>
    ff5e:	0001      	movs	r1, r0
    ff60:	4823      	ldr	r0, [pc, #140]	; (fff0 <__RAM_SIZE__+0x110>)
    ff62:	f7f9 fd43 	bl	99ec <at_uart_write>
    len = (uint16)snprintf(rsp_string, AT_MAX_NSORF_SET_RSP_LEN, "%d,%s,%d,%d,", socket, ipaddr_ntoa(&(sock_address.sin_addr)),sock_address.sin_port, ret); //lint !e506
    ff66:	2230      	movs	r2, #48	; 0x30
    ff68:	ab02      	add	r3, sp, #8
    ff6a:	189b      	adds	r3, r3, r2
    ff6c:	781b      	ldrb	r3, [r3, #0]
    ff6e:	8836      	ldrh	r6, [r6, #0]
    ff70:	a80a      	add	r0, sp, #40	; 0x28
    ff72:	2b06      	cmp	r3, #6
    ff74:	d11b      	bne.n	ffae <__RAM_SIZE__+0xce>
    ff76:	f00d fac7 	bl	1d508 <ip6addr_ntoa>
    ff7a:	9702      	str	r7, [sp, #8]
    ff7c:	ab02      	add	r3, sp, #8
    ff7e:	8bdb      	ldrh	r3, [r3, #30]
    ff80:	4a1c      	ldr	r2, [pc, #112]	; (fff4 <__RAM_SIZE__+0x114>)
    ff82:	9301      	str	r3, [sp, #4]
    ff84:	9000      	str	r0, [sp, #0]
    ff86:	0033      	movs	r3, r6
    ff88:	213c      	movs	r1, #60	; 0x3c
    ff8a:	a80f      	add	r0, sp, #60	; 0x3c
    ff8c:	f00a fc6e 	bl	1a86c <snprintf>
    at_uart_write((uint8*)rsp_string, (uint32)len);
    ff90:	b281      	uxth	r1, r0
    ff92:	a80f      	add	r0, sp, #60	; 0x3c
    ff94:	f7f9 fd2a 	bl	99ec <at_uart_write>
    ff98:	002e      	movs	r6, r5
        if (at_parse_buf_to_hex_forward_order(buffer + i, (uint8*)op, 1) == false)
    ff9a:	2201      	movs	r2, #1
    ff9c:	a907      	add	r1, sp, #28
    ff9e:	0030      	movs	r0, r6
    ffa0:	f7fa f8cb 	bl	a13a <at_parse_buf_to_hex_forward_order>
    ffa4:	2800      	cmp	r0, #0
    ffa6:	d105      	bne.n	ffb4 <__RAM_SIZE__+0xd4>
            at_uart_release();
    ffa8:	f7f9 fd10 	bl	99cc <at_uart_release>
    ffac:	e7c8      	b.n	ff40 <__RAM_SIZE__+0x60>
    len = (uint16)snprintf(rsp_string, AT_MAX_NSORF_SET_RSP_LEN, "%d,%s,%d,%d,", socket, ipaddr_ntoa(&(sock_address.sin_addr)),sock_address.sin_port, ret); //lint !e506
    ffae:	f00d f971 	bl	1d294 <ip4addr_ntoa>
    ffb2:	e7e2      	b.n	ff7a <__RAM_SIZE__+0x9a>
        at_uart_write(op, 2);
    ffb4:	2102      	movs	r1, #2
    ffb6:	a807      	add	r0, sp, #28
    ffb8:	3601      	adds	r6, #1
    ffba:	f7f9 fd17 	bl	99ec <at_uart_write>
    for (int i=0; i< ret; i++)
    ffbe:	1b73      	subs	r3, r6, r5
    ffc0:	429f      	cmp	r7, r3
    ffc2:	dcea      	bgt.n	ff9a <__RAM_SIZE__+0xba>
    len = (uint16)snprintf(rsp_string, AT_MAX_NSORF_SET_RSP_LEN, ",%d", remaining_length);
    ffc4:	9b05      	ldr	r3, [sp, #20]
    ffc6:	4a0c      	ldr	r2, [pc, #48]	; (fff8 <__RAM_SIZE__+0x118>)
    ffc8:	213c      	movs	r1, #60	; 0x3c
    ffca:	a80f      	add	r0, sp, #60	; 0x3c
    ffcc:	f00a fc4e 	bl	1a86c <snprintf>
    at_uart_write((uint8*)rsp_string, (uint32)len);
    ffd0:	b281      	uxth	r1, r0
    ffd2:	a80f      	add	r0, sp, #60	; 0x3c
    ffd4:	f7f9 fd0a 	bl	99ec <at_uart_write>
    at_uart_write((uint8*)APP_AT_STR_RN, strlen(APP_AT_STR_RN));
    ffd8:	4e05      	ldr	r6, [pc, #20]	; (fff0 <__RAM_SIZE__+0x110>)
    ffda:	0030      	movs	r0, r6
    ffdc:	f00b f9df 	bl	1b39e <strlen>
    ffe0:	0001      	movs	r1, r0
    ffe2:	0030      	movs	r0, r6
    ffe4:	f7f9 fd02 	bl	99ec <at_uart_write>
    at_uart_release();
    ffe8:	f7f9 fcf0 	bl	99cc <at_uart_release>
    ffec:	e7ae      	b.n	ff4c <__RAM_SIZE__+0x6c>
    ffee:	46c0      	nop			; (mov r8, r8)
    fff0:	00022d8f 	.word	0x00022d8f
    fff4:	00023d75 	.word	0x00023d75
    fff8:	0002394e 	.word	0x0002394e

0000fffc <at_nsost_nsostf_common_handle>:
{
    fffc:	b5f0      	push	{r4, r5, r6, r7, lr}
    uint8             num_recvparams = 0;
    fffe:	2400      	movs	r4, #0
   10000:	2713      	movs	r7, #19
{
   10002:	b0a5      	sub	sp, #148	; 0x94
    uint8             num_recvparams = 0;
   10004:	ab02      	add	r3, sp, #8
    uint16            socket = 0;
   10006:	82dc      	strh	r4, [r3, #22]
    uint8             num_recvparams = 0;
   10008:	18ff      	adds	r7, r7, r3
    uint16            length = 0;
   1000a:	ab08      	add	r3, sp, #32
   1000c:	801c      	strh	r4, [r3, #0]
    uint16            remote_port = 0;
   1000e:	ab02      	add	r3, sp, #8
   10010:	835c      	strh	r4, [r3, #26]
{
   10012:	9005      	str	r0, [sp, #20]
    uint16            data_string_len = 0;
   10014:	ab09      	add	r3, sp, #36	; 0x24
    char              ip_str[MAX_IP_LEN] = {0};
   10016:	223c      	movs	r2, #60	; 0x3c
{
   10018:	000d      	movs	r5, r1
    char              ip_str[MAX_IP_LEN] = {0};
   1001a:	a815      	add	r0, sp, #84	; 0x54
   1001c:	0021      	movs	r1, r4
    uint16            data_string_len = 0;
   1001e:	801c      	strh	r4, [r3, #0]
    uint8             num_recvparams = 0;
   10020:	703c      	strb	r4, [r7, #0]
    uint8            *data_string = NULL;
   10022:	940b      	str	r4, [sp, #44]	; 0x2c
    char              ip_str[MAX_IP_LEN] = {0};
   10024:	f7f0 f95c 	bl	2e0 <memset>
    char              rsp_string[AT_MAX_NSOST_SET_RSP_LEN] = {0};
   10028:	0021      	movs	r1, r4
   1002a:	220a      	movs	r2, #10
   1002c:	a80c      	add	r0, sp, #48	; 0x30
   1002e:	f7f0 f957 	bl	2e0 <memset>
    uint16            ip_mtu_size = 0;
   10032:	231e      	movs	r3, #30
   10034:	aa02      	add	r2, sp, #8
   10036:	189b      	adds	r3, r3, r2
    SOCK_MSG_FLAG     msg_flags = MSG_NORMAL;
   10038:	ae0a      	add	r6, sp, #40	; 0x28
    uint16            ip_mtu_size = 0;
   1003a:	801c      	strh	r4, [r3, #0]
    SOCK_MSG_FLAG     msg_flags = MSG_NORMAL;
   1003c:	8034      	strh	r4, [r6, #0]
    if (at_trigger_filter_send())
   1003e:	f001 fd73 	bl	11b28 <at_trigger_filter_send>
        return AT_RET_FOTA_UPDATING;
   10042:	3413      	adds	r4, #19
    if (at_trigger_filter_send())
   10044:	2800      	cmp	r0, #0
   10046:	d115      	bne.n	10074 <at_nsost_nsostf_common_handle+0x78>
    cause = at_create_param_array(p_atparams_string, &num_recvparams, 5 + num_of_flags, 6 + num_of_flags);
   10048:	1d6b      	adds	r3, r5, #5
   1004a:	b2db      	uxtb	r3, r3
   1004c:	9304      	str	r3, [sp, #16]
   1004e:	1dab      	adds	r3, r5, #6
   10050:	b2db      	uxtb	r3, r3
   10052:	9a04      	ldr	r2, [sp, #16]
   10054:	0039      	movs	r1, r7
   10056:	9805      	ldr	r0, [sp, #20]
   10058:	f7fa f944 	bl	a2e4 <at_create_param_array>
   1005c:	1e04      	subs	r4, r0, #0
    if (cause != AT_RET_OK)
   1005e:	d109      	bne.n	10074 <at_nsost_nsostf_common_handle+0x78>
    cause = at_get_uint16_param(AT_PARSE_FIRST_PARAM_POS, &socket, true);
   10060:	2316      	movs	r3, #22
   10062:	a902      	add	r1, sp, #8
   10064:	185b      	adds	r3, r3, r1
   10066:	2201      	movs	r2, #1
   10068:	0019      	movs	r1, r3
   1006a:	f7fa fa4f 	bl	a50c <at_get_uint16_param>
    if (cause != AT_RET_OK)
   1006e:	2800      	cmp	r0, #0
   10070:	d003      	beq.n	1007a <at_nsost_nsostf_common_handle+0x7e>
        return AT_RET_SYNTAX_ERROR;
   10072:	2401      	movs	r4, #1
}
   10074:	0020      	movs	r0, r4
   10076:	b025      	add	sp, #148	; 0x94
   10078:	bdf0      	pop	{r4, r5, r6, r7, pc}
    cause = at_get_ip_param(AT_PARSE_SECOND_PARAM_POS, (uint8*)ip_str, MAX_IP_LEN, true, &sock_address.sin_addr);
   1007a:	ab10      	add	r3, sp, #64	; 0x40
   1007c:	9300      	str	r3, [sp, #0]
   1007e:	2301      	movs	r3, #1
   10080:	223c      	movs	r2, #60	; 0x3c
   10082:	a915      	add	r1, sp, #84	; 0x54
   10084:	0018      	movs	r0, r3
   10086:	f7fa fc17 	bl	a8b8 <at_get_ip_param>
    if (cause != AT_RET_OK)
   1008a:	2800      	cmp	r0, #0
   1008c:	d1f1      	bne.n	10072 <at_nsost_nsostf_common_handle+0x76>
    cause = at_get_uint16_param(AT_PARSE_THIRD_PARAM_POS, &remote_port, true);
   1008e:	231a      	movs	r3, #26
   10090:	a902      	add	r1, sp, #8
   10092:	185b      	adds	r3, r3, r1
   10094:	2201      	movs	r2, #1
   10096:	0019      	movs	r1, r3
   10098:	3002      	adds	r0, #2
   1009a:	f7fa fa37 	bl	a50c <at_get_uint16_param>
    if (cause != AT_RET_OK)
   1009e:	2800      	cmp	r0, #0
   100a0:	d1e7      	bne.n	10072 <at_nsost_nsostf_common_handle+0x76>
    if (is_nsostf)
   100a2:	2d00      	cmp	r5, #0
   100a4:	d12f      	bne.n	10106 <at_nsost_nsostf_common_handle+0x10a>
    cause = at_get_uint16_param(AT_PARSE_FOURTH_PARAM_POS + num_of_flags, &length, true);
   100a6:	ae08      	add	r6, sp, #32
   100a8:	1ce8      	adds	r0, r5, #3
   100aa:	b2c0      	uxtb	r0, r0
   100ac:	2201      	movs	r2, #1
   100ae:	0031      	movs	r1, r6
   100b0:	f7fa fa2c 	bl	a50c <at_get_uint16_param>
    if (cause != AT_RET_OK)
   100b4:	2800      	cmp	r0, #0
   100b6:	d1dc      	bne.n	10072 <at_nsost_nsostf_common_handle+0x76>
    cause = at_get_hexstring_param(AT_PARSE_FIFTH_PARAM_POS + num_of_flags, &data_string, &data_string_len, true);
   100b8:	1d28      	adds	r0, r5, #4
   100ba:	af09      	add	r7, sp, #36	; 0x24
   100bc:	b2c0      	uxtb	r0, r0
   100be:	2301      	movs	r3, #1
   100c0:	003a      	movs	r2, r7
   100c2:	a90b      	add	r1, sp, #44	; 0x2c
   100c4:	f7fa fbb2 	bl	a82c <at_get_hexstring_param>
   100c8:	0005      	movs	r5, r0
   100ca:	1e04      	subs	r4, r0, #0
    if (cause != AT_RET_OK)
   100cc:	d1d2      	bne.n	10074 <at_nsost_nsostf_common_handle+0x78>
    cause = at_get_uint8_param(AT_PARSE_SIXTH_PARAM_POS + num_of_flags, &seq_num, true);
   100ce:	ac07      	add	r4, sp, #28
   100d0:	2201      	movs	r2, #1
   100d2:	0021      	movs	r1, r4
   100d4:	9804      	ldr	r0, [sp, #16]
   100d6:	f7fa fa99 	bl	a60c <at_get_uint8_param>
    if (cause == AT_RET_PARAM_MISSING)
   100da:	2803      	cmp	r0, #3
   100dc:	d124      	bne.n	10128 <at_nsost_nsostf_common_handle+0x12c>
        seq_num = NEUL_DATA_SENT_DATA_SEQ_INVALID;
   100de:	7025      	strb	r5, [r4, #0]
    if(!check_at_allocated_socket(socket))
   100e0:	2316      	movs	r3, #22
   100e2:	aa02      	add	r2, sp, #8
   100e4:	189b      	adds	r3, r3, r2
   100e6:	8818      	ldrh	r0, [r3, #0]
   100e8:	f7ff fe16 	bl	fd18 <check_at_allocated_socket>
        return AT_RET_INVALID_SOCKET;
   100ec:	2425      	movs	r4, #37	; 0x25
    if(!check_at_allocated_socket(socket))
   100ee:	2800      	cmp	r0, #0
   100f0:	d0c0      	beq.n	10074 <at_nsost_nsostf_common_handle+0x78>
    if (app_at_min_ip_mtu_from_active_cids(&ip_mtu_size) != AT_RET_OK)
   100f2:	251e      	movs	r5, #30
   100f4:	ab02      	add	r3, sp, #8
   100f6:	18ed      	adds	r5, r5, r3
   100f8:	0028      	movs	r0, r5
   100fa:	f7f9 f891 	bl	9220 <app_at_min_ip_mtu_from_active_cids>
   100fe:	1e04      	subs	r4, r0, #0
   10100:	d018      	beq.n	10134 <at_nsost_nsostf_common_handle+0x138>
        return AT_RET_PROGRESS_ERROR;
   10102:	2406      	movs	r4, #6
   10104:	e7b6      	b.n	10074 <at_nsost_nsostf_common_handle+0x78>
        cause = at_get_uint16_param(AT_PARSE_FOURTH_PARAM_POS, (uint16 *)(&msg_flags), true);   //lint !e740
   10106:	2201      	movs	r2, #1
   10108:	0031      	movs	r1, r6
   1010a:	2003      	movs	r0, #3
   1010c:	f7fa f9fe 	bl	a50c <at_get_uint16_param>
        if (cause != AT_RET_OK)
   10110:	2800      	cmp	r0, #0
   10112:	d1ae      	bne.n	10072 <at_nsost_nsostf_common_handle+0x76>
        else if (msg_flags != MSG_NORMAL && msg_flags != MSG_NEXCEPTION && msg_flags != MSG_NRELEASE && msg_flags != MSG_NRELEASE_AFTER_REPLY)
   10114:	8833      	ldrh	r3, [r6, #0]
   10116:	4a3b      	ldr	r2, [pc, #236]	; (10204 <at_nsost_nsostf_common_handle+0x208>)
   10118:	4213      	tst	r3, r2
   1011a:	d0c4      	beq.n	100a6 <at_nsost_nsostf_common_handle+0xaa>
   1011c:	4a3a      	ldr	r2, [pc, #232]	; (10208 <at_nsost_nsostf_common_handle+0x20c>)
   1011e:	189b      	adds	r3, r3, r2
   10120:	4a3a      	ldr	r2, [pc, #232]	; (1020c <at_nsost_nsostf_common_handle+0x210>)
   10122:	4213      	tst	r3, r2
   10124:	d1a5      	bne.n	10072 <at_nsost_nsostf_common_handle+0x76>
   10126:	e7be      	b.n	100a6 <at_nsost_nsostf_common_handle+0xaa>
    else if ((cause != AT_RET_OK) || (seq_num == NEUL_DATA_SENT_DATA_SEQ_INVALID))
   10128:	2800      	cmp	r0, #0
   1012a:	d1a2      	bne.n	10072 <at_nsost_nsostf_common_handle+0x76>
   1012c:	7823      	ldrb	r3, [r4, #0]
   1012e:	2b00      	cmp	r3, #0
   10130:	d1d6      	bne.n	100e0 <at_nsost_nsostf_common_handle+0xe4>
   10132:	e79e      	b.n	10072 <at_nsost_nsostf_common_handle+0x76>
    if (length > ip_mtu_size)
   10134:	8832      	ldrh	r2, [r6, #0]
   10136:	882b      	ldrh	r3, [r5, #0]
   10138:	4293      	cmp	r3, r2
   1013a:	d200      	bcs.n	1013e <at_nsost_nsostf_common_handle+0x142>
   1013c:	e799      	b.n	10072 <at_nsost_nsostf_common_handle+0x76>
    if (length * 2 != data_string_len)
   1013e:	883b      	ldrh	r3, [r7, #0]
   10140:	0052      	lsls	r2, r2, #1
   10142:	429a      	cmp	r2, r3
   10144:	d000      	beq.n	10148 <at_nsost_nsostf_common_handle+0x14c>
   10146:	e794      	b.n	10072 <at_nsost_nsostf_common_handle+0x76>
    if (at_parse_buf_hex_to_uint8(data_string, data_string, (uint16)(length * 2)) == false)
   10148:	990b      	ldr	r1, [sp, #44]	; 0x2c
   1014a:	b292      	uxth	r2, r2
   1014c:	0008      	movs	r0, r1
   1014e:	f7fa f818 	bl	a182 <at_parse_buf_hex_to_uint8>
   10152:	2800      	cmp	r0, #0
   10154:	d100      	bne.n	10158 <at_nsost_nsostf_common_handle+0x15c>
   10156:	e78c      	b.n	10072 <at_nsost_nsostf_common_handle+0x76>
    if (sock_address.sin_addr.type == IPADDR_TYPE_V4)
   10158:	ad0f      	add	r5, sp, #60	; 0x3c
   1015a:	7d2b      	ldrb	r3, [r5, #20]
   1015c:	2b00      	cmp	r3, #0
   1015e:	d13f      	bne.n	101e0 <at_nsost_nsostf_common_handle+0x1e4>
        sock_address.sin_family = AF_INET;
   10160:	3302      	adds	r3, #2
        sock_address.sin_family = AF_INET6;
   10162:	702b      	strb	r3, [r5, #0]
    sock_address.sin_port = remote_port ;
   10164:	231a      	movs	r3, #26
    if (get_socket_status((uint8)socket, &status, &backoff) == NEUL_RET_OK)
   10166:	2716      	movs	r7, #22
    sock_address.sin_port = remote_port ;
   10168:	aa02      	add	r2, sp, #8
   1016a:	189b      	adds	r3, r3, r2
   1016c:	881b      	ldrh	r3, [r3, #0]
    if (get_socket_status((uint8)socket, &status, &backoff) == NEUL_RET_OK)
   1016e:	18bf      	adds	r7, r7, r2
    sock_address.sin_port = remote_port ;
   10170:	806b      	strh	r3, [r5, #2]
    if (get_socket_status((uint8)socket, &status, &backoff) == NEUL_RET_OK)
   10172:	0013      	movs	r3, r2
   10174:	2222      	movs	r2, #34	; 0x22
   10176:	18d2      	adds	r2, r2, r3
   10178:	2315      	movs	r3, #21
   1017a:	a902      	add	r1, sp, #8
   1017c:	185b      	adds	r3, r3, r1
   1017e:	7838      	ldrb	r0, [r7, #0]
   10180:	0019      	movs	r1, r3
   10182:	f7f7 ff83 	bl	808c <get_socket_status>
   10186:	2800      	cmp	r0, #0
   10188:	d134      	bne.n	101f4 <at_nsost_nsostf_common_handle+0x1f8>
        if (status == SOCKET_OR_CID_STATUS_BACK_OFF)
   1018a:	ab02      	add	r3, sp, #8
   1018c:	7d5b      	ldrb	r3, [r3, #21]
   1018e:	2b03      	cmp	r3, #3
   10190:	d030      	beq.n	101f4 <at_nsost_nsostf_common_handle+0x1f8>
    if (seq_num == NEUL_DATA_SENT_DATA_SEQ_INVALID)
   10192:	ab07      	add	r3, sp, #28
   10194:	7819      	ldrb	r1, [r3, #0]
   10196:	ab0a      	add	r3, sp, #40	; 0x28
   10198:	8838      	ldrh	r0, [r7, #0]
   1019a:	8832      	ldrh	r2, [r6, #0]
   1019c:	9f0b      	ldr	r7, [sp, #44]	; 0x2c
   1019e:	881b      	ldrh	r3, [r3, #0]
   101a0:	2618      	movs	r6, #24
   101a2:	2900      	cmp	r1, #0
   101a4:	d11e      	bne.n	101e4 <at_nsost_nsostf_common_handle+0x1e8>
        ret = sendto(socket, data_string, length, msg_flags, (struct sockaddr *) &sock_address, sizeof(sock_address));  //lint !e740 !e826
   101a6:	9601      	str	r6, [sp, #4]
   101a8:	9500      	str	r5, [sp, #0]
   101aa:	0039      	movs	r1, r7
   101ac:	f7f7 fe3e 	bl	7e2c <sendto>
    if (ret == NEUL_SOCKET_RET_FLOWCONTROL)
   101b0:	1c83      	adds	r3, r0, #2
   101b2:	d021      	beq.n	101f8 <at_nsost_nsostf_common_handle+0x1fc>
    else if (ret == NEUL_SOCKET_RET_DATA_SEQUENCE_REPEAT_ERROR)
   101b4:	1cc3      	adds	r3, r0, #3
   101b6:	d021      	beq.n	101fc <at_nsost_nsostf_common_handle+0x200>
    else if (ret == NEUL_SOCKET_RET_NO_NETWORK_SERVICE)
   101b8:	1d03      	adds	r3, r0, #4
   101ba:	d021      	beq.n	10200 <at_nsost_nsostf_common_handle+0x204>
    else if ((ret == NEUL_SOCKET_RET_ERROR) || (ret != length))
   101bc:	1c43      	adds	r3, r0, #1
   101be:	d0a0      	beq.n	10102 <at_nsost_nsostf_common_handle+0x106>
   101c0:	ab08      	add	r3, sp, #32
   101c2:	881b      	ldrh	r3, [r3, #0]
   101c4:	4283      	cmp	r3, r0
   101c6:	d19c      	bne.n	10102 <at_nsost_nsostf_common_handle+0x106>
    (void)snprintf(rsp_string, AT_MAX_NSOST_SET_RSP_LEN, "%d,%d", socket, ret);
   101c8:	ab02      	add	r3, sp, #8
   101ca:	8adb      	ldrh	r3, [r3, #22]
   101cc:	4a10      	ldr	r2, [pc, #64]	; (10210 <at_nsost_nsostf_common_handle+0x214>)
   101ce:	9000      	str	r0, [sp, #0]
   101d0:	210a      	movs	r1, #10
   101d2:	a80c      	add	r0, sp, #48	; 0x30
   101d4:	f00a fb4a 	bl	1a86c <snprintf>
    app_at_send_at_rsp_string_lines_with_claim_and_log(rsp_string);
   101d8:	a80c      	add	r0, sp, #48	; 0x30
   101da:	f7f9 fa03 	bl	95e4 <app_at_send_at_rsp_string_lines_with_claim_and_log>
    return AT_RET_OK;
   101de:	e749      	b.n	10074 <at_nsost_nsostf_common_handle+0x78>
        sock_address.sin_family = AF_INET6;
   101e0:	230a      	movs	r3, #10
   101e2:	e7be      	b.n	10162 <at_nsost_nsostf_common_handle+0x166>
        ret = sendto_with_indication(socket, seq_num, data_string, length, msg_flags, (struct sockaddr *) &sock_address, sizeof(sock_address));  //lint !e740 !e826
   101e4:	9300      	str	r3, [sp, #0]
   101e6:	9602      	str	r6, [sp, #8]
   101e8:	0013      	movs	r3, r2
   101ea:	9501      	str	r5, [sp, #4]
   101ec:	003a      	movs	r2, r7
   101ee:	f7f7 fde3 	bl	7db8 <sendto_with_indication>
   101f2:	e7dd      	b.n	101b0 <at_nsost_nsostf_common_handle+0x1b4>
        return AT_RET_BACK_OFF;
   101f4:	2432      	movs	r4, #50	; 0x32
   101f6:	e73d      	b.n	10074 <at_nsost_nsostf_common_handle+0x78>
        return AT_RET_FLOW_CONTROL;
   101f8:	2407      	movs	r4, #7
   101fa:	e73b      	b.n	10074 <at_nsost_nsostf_common_handle+0x78>
        return AT_RET_DATA_SEQUENCE_REPEAT_ERROR;
   101fc:	241d      	movs	r4, #29
   101fe:	e739      	b.n	10074 <at_nsost_nsostf_common_handle+0x78>
        return AT_RET_NO_NETWORK_SERVICE;
   10200:	240b      	movs	r4, #11
   10202:	e737      	b.n	10074 <at_nsost_nsostf_common_handle+0x78>
   10204:	fffffeff 	.word	0xfffffeff
   10208:	fffffe00 	.word	0xfffffe00
   1020c:	0000fdff 	.word	0x0000fdff
   10210:	00023735 	.word	0x00023735

00010214 <at_handle_NSOSTF_cmd_set>:
{
   10214:	b510      	push	{r4, lr}
    return at_nsost_nsostf_common_handle(p_atparams_string, true);
   10216:	2101      	movs	r1, #1
   10218:	f7ff fef0 	bl	fffc <at_nsost_nsostf_common_handle>
}
   1021c:	bd10      	pop	{r4, pc}

0001021e <at_handle_NSOST_cmd_set>:
{
   1021e:	b510      	push	{r4, lr}
    return at_nsost_nsostf_common_handle(p_atparams_string, false);
   10220:	2100      	movs	r1, #0
   10222:	f7ff feeb 	bl	fffc <at_nsost_nsostf_common_handle>
}
   10226:	bd10      	pop	{r4, pc}

00010228 <at_handle_NSOSD_cmd_set>:
{
   10228:	b5f0      	push	{r4, r5, r6, r7, lr}
    uint8   seq_num = NEUL_DATA_SENT_DATA_SEQ_INVALID;
   1022a:	250d      	movs	r5, #13
{
   1022c:	b08b      	sub	sp, #44	; 0x2c
    uint16  ip_mtu_size = 0;
   1022e:	2100      	movs	r1, #0
   10230:	466b      	mov	r3, sp
{
   10232:	0004      	movs	r4, r0
    char    rsp_string[AT_MAX_NSOST_SET_RSP_LEN] = {0};
   10234:	220a      	movs	r2, #10
    uint8   seq_num = NEUL_DATA_SENT_DATA_SEQ_INVALID;
   10236:	446d      	add	r5, sp
    char    rsp_string[AT_MAX_NSOST_SET_RSP_LEN] = {0};
   10238:	a807      	add	r0, sp, #28
    cause = at_create_param_array(p_atparams_string, &num_recvparams, 3, 5);
   1023a:	ae03      	add	r6, sp, #12
    uint16  ip_mtu_size = 0;
   1023c:	8299      	strh	r1, [r3, #20]
    uint16  msg_flags = MSG_NORMAL;
   1023e:	82d9      	strh	r1, [r3, #22]
    uint8   seq_num = NEUL_DATA_SENT_DATA_SEQ_INVALID;
   10240:	7029      	strb	r1, [r5, #0]
    char    rsp_string[AT_MAX_NSOST_SET_RSP_LEN] = {0};
   10242:	f7f0 f84d 	bl	2e0 <memset>
    cause = at_create_param_array(p_atparams_string, &num_recvparams, 3, 5);
   10246:	0020      	movs	r0, r4
   10248:	2305      	movs	r3, #5
   1024a:	2203      	movs	r2, #3
   1024c:	0031      	movs	r1, r6
   1024e:	f7fa f849 	bl	a2e4 <at_create_param_array>
   10252:	1e04      	subs	r4, r0, #0
    if(cause != AT_RET_OK)
   10254:	d13a      	bne.n	102cc <at_handle_NSOSD_cmd_set+0xa4>
    cause = at_get_uint16_param(AT_PARSE_FIRST_PARAM_POS, &socket, true);
   10256:	210e      	movs	r1, #14
   10258:	2201      	movs	r2, #1
   1025a:	4469      	add	r1, sp
   1025c:	f7fa f956 	bl	a50c <at_get_uint16_param>
   10260:	1e04      	subs	r4, r0, #0
    if(cause != AT_RET_OK)
   10262:	d133      	bne.n	102cc <at_handle_NSOSD_cmd_set+0xa4>
    cause = at_get_uint16_param(AT_PARSE_SECOND_PARAM_POS, &length, true);
   10264:	2201      	movs	r2, #1
   10266:	a904      	add	r1, sp, #16
   10268:	0010      	movs	r0, r2
   1026a:	f7fa f94f 	bl	a50c <at_get_uint16_param>
   1026e:	1e04      	subs	r4, r0, #0
    if(cause != AT_RET_OK)
   10270:	d12c      	bne.n	102cc <at_handle_NSOSD_cmd_set+0xa4>
    cause = at_get_hexstring_param(AT_PARSE_THIRD_PARAM_POS, &data_string, &data_string_len, true);
   10272:	2212      	movs	r2, #18
   10274:	2301      	movs	r3, #1
   10276:	446a      	add	r2, sp
   10278:	a906      	add	r1, sp, #24
   1027a:	2002      	movs	r0, #2
   1027c:	f7fa fad6 	bl	a82c <at_get_hexstring_param>
   10280:	1e04      	subs	r4, r0, #0
    if(cause != AT_RET_OK)
   10282:	d123      	bne.n	102cc <at_handle_NSOSD_cmd_set+0xa4>
    if (num_recvparams > 3)
   10284:	7833      	ldrb	r3, [r6, #0]
   10286:	2b03      	cmp	r3, #3
   10288:	d817      	bhi.n	102ba <at_handle_NSOSD_cmd_set+0x92>
    cause = at_get_uint8_param(AT_PARSE_FIFTH_PARAM_POS, &seq_num, true);
   1028a:	2201      	movs	r2, #1
   1028c:	0029      	movs	r1, r5
   1028e:	2004      	movs	r0, #4
   10290:	f7fa f9bc 	bl	a60c <at_get_uint8_param>
    if(cause == AT_RET_PARAM_MISSING)
   10294:	2803      	cmp	r0, #3
   10296:	d11c      	bne.n	102d2 <at_handle_NSOSD_cmd_set+0xaa>
        seq_num = NEUL_DATA_SENT_DATA_SEQ_INVALID ;
   10298:	2300      	movs	r3, #0
   1029a:	702b      	strb	r3, [r5, #0]
    if(!check_at_allocated_socket(socket))
   1029c:	260e      	movs	r6, #14
   1029e:	446e      	add	r6, sp
   102a0:	8830      	ldrh	r0, [r6, #0]
   102a2:	f7ff fd39 	bl	fd18 <check_at_allocated_socket>
        return AT_RET_INVALID_SOCKET;
   102a6:	2425      	movs	r4, #37	; 0x25
    if(!check_at_allocated_socket(socket))
   102a8:	2800      	cmp	r0, #0
   102aa:	d00f      	beq.n	102cc <at_handle_NSOSD_cmd_set+0xa4>
    if (app_at_min_ip_mtu_from_active_cids(&ip_mtu_size) != AT_RET_OK)
   102ac:	a805      	add	r0, sp, #20
   102ae:	f7f8 ffb7 	bl	9220 <app_at_min_ip_mtu_from_active_cids>
   102b2:	1e04      	subs	r4, r0, #0
   102b4:	d015      	beq.n	102e2 <at_handle_NSOSD_cmd_set+0xba>
        return AT_RET_PROGRESS_ERROR;
   102b6:	2406      	movs	r4, #6
   102b8:	e008      	b.n	102cc <at_handle_NSOSD_cmd_set+0xa4>
        cause = at_get_uint16_param(AT_PARSE_FOURTH_PARAM_POS, &msg_flags, true);
   102ba:	2316      	movs	r3, #22
   102bc:	446b      	add	r3, sp
   102be:	2201      	movs	r2, #1
   102c0:	0019      	movs	r1, r3
   102c2:	2003      	movs	r0, #3
   102c4:	f7fa f922 	bl	a50c <at_get_uint16_param>
   102c8:	1e04      	subs	r4, r0, #0
        if(cause != AT_RET_OK)
   102ca:	d0de      	beq.n	1028a <at_handle_NSOSD_cmd_set+0x62>
}
   102cc:	0020      	movs	r0, r4
   102ce:	b00b      	add	sp, #44	; 0x2c
   102d0:	bdf0      	pop	{r4, r5, r6, r7, pc}
    else if ((cause != AT_RET_OK) || (seq_num == NEUL_DATA_SENT_DATA_SEQ_INVALID))
   102d2:	2800      	cmp	r0, #0
   102d4:	d001      	beq.n	102da <at_handle_NSOSD_cmd_set+0xb2>
        return AT_RET_SYNTAX_ERROR;
   102d6:	2401      	movs	r4, #1
   102d8:	e7f8      	b.n	102cc <at_handle_NSOSD_cmd_set+0xa4>
    else if ((cause != AT_RET_OK) || (seq_num == NEUL_DATA_SENT_DATA_SEQ_INVALID))
   102da:	782b      	ldrb	r3, [r5, #0]
   102dc:	2b00      	cmp	r3, #0
   102de:	d1dd      	bne.n	1029c <at_handle_NSOSD_cmd_set+0x74>
   102e0:	e7f9      	b.n	102d6 <at_handle_NSOSD_cmd_set+0xae>
    if (length > ip_mtu_size)
   102e2:	466b      	mov	r3, sp
   102e4:	af04      	add	r7, sp, #16
   102e6:	883a      	ldrh	r2, [r7, #0]
   102e8:	8a9b      	ldrh	r3, [r3, #20]
   102ea:	4293      	cmp	r3, r2
   102ec:	d3f3      	bcc.n	102d6 <at_handle_NSOSD_cmd_set+0xae>
    if (length * 2 != data_string_len)
   102ee:	466b      	mov	r3, sp
   102f0:	8a5b      	ldrh	r3, [r3, #18]
   102f2:	0052      	lsls	r2, r2, #1
   102f4:	429a      	cmp	r2, r3
   102f6:	d1ee      	bne.n	102d6 <at_handle_NSOSD_cmd_set+0xae>
    if (at_parse_buf_hex_to_uint8(data_string, data_string, (uint16)(length * 2)) == false)
   102f8:	9906      	ldr	r1, [sp, #24]
   102fa:	b292      	uxth	r2, r2
   102fc:	0008      	movs	r0, r1
   102fe:	f7f9 ff40 	bl	a182 <at_parse_buf_hex_to_uint8>
   10302:	2800      	cmp	r0, #0
   10304:	d0e7      	beq.n	102d6 <at_handle_NSOSD_cmd_set+0xae>
    ret = send_with_indication(socket, seq_num, data_string, length, (SOCK_MSG_FLAG)msg_flags);
   10306:	466a      	mov	r2, sp
   10308:	8ad2      	ldrh	r2, [r2, #22]
   1030a:	883b      	ldrh	r3, [r7, #0]
   1030c:	7829      	ldrb	r1, [r5, #0]
   1030e:	8830      	ldrh	r0, [r6, #0]
   10310:	9200      	str	r2, [sp, #0]
   10312:	9a06      	ldr	r2, [sp, #24]
   10314:	f7f7 fdb8 	bl	7e88 <send_with_indication>
    if (ret == NEUL_SOCKET_RET_FLOWCONTROL)
   10318:	1c83      	adds	r3, r0, #2
   1031a:	d011      	beq.n	10340 <at_handle_NSOSD_cmd_set+0x118>
    else if (ret == NEUL_SOCKET_RET_DATA_SEQUENCE_REPEAT_ERROR)
   1031c:	1cc3      	adds	r3, r0, #3
   1031e:	d011      	beq.n	10344 <at_handle_NSOSD_cmd_set+0x11c>
    else if ((ret == NEUL_SOCKET_RET_ERROR) || (ret != length))
   10320:	1c43      	adds	r3, r0, #1
   10322:	d0c8      	beq.n	102b6 <at_handle_NSOSD_cmd_set+0x8e>
   10324:	883a      	ldrh	r2, [r7, #0]
   10326:	4282      	cmp	r2, r0
   10328:	d1c5      	bne.n	102b6 <at_handle_NSOSD_cmd_set+0x8e>
    (void)snprintf(rsp_string, AT_MAX_NSOST_SET_RSP_LEN, "%d,%d", socket, ret);
   1032a:	8833      	ldrh	r3, [r6, #0]
   1032c:	210a      	movs	r1, #10
   1032e:	9200      	str	r2, [sp, #0]
   10330:	a807      	add	r0, sp, #28
   10332:	4a05      	ldr	r2, [pc, #20]	; (10348 <at_handle_NSOSD_cmd_set+0x120>)
   10334:	f00a fa9a 	bl	1a86c <snprintf>
    app_at_send_at_rsp_string_lines_with_claim_and_log(rsp_string);
   10338:	a807      	add	r0, sp, #28
   1033a:	f7f9 f953 	bl	95e4 <app_at_send_at_rsp_string_lines_with_claim_and_log>
    return AT_RET_OK;
   1033e:	e7c5      	b.n	102cc <at_handle_NSOSD_cmd_set+0xa4>
        return AT_RET_FLOW_CONTROL;
   10340:	2407      	movs	r4, #7
   10342:	e7c3      	b.n	102cc <at_handle_NSOSD_cmd_set+0xa4>
        return AT_RET_DATA_SEQUENCE_REPEAT_ERROR;
   10344:	241d      	movs	r4, #29
   10346:	e7c1      	b.n	102cc <at_handle_NSOSD_cmd_set+0xa4>
   10348:	00023735 	.word	0x00023735

0001034c <at_handle_NSOCO_cmd_set>:
{
   1034c:	b5f0      	push	{r4, r5, r6, r7, lr}
   1034e:	b09b      	sub	sp, #108	; 0x6c
   10350:	0004      	movs	r4, r0
    char        ip_str[MAX_IP_LEN] = {0};
   10352:	223c      	movs	r2, #60	; 0x3c
   10354:	2100      	movs	r1, #0
   10356:	a80b      	add	r0, sp, #44	; 0x2c
   10358:	f7ef ffc2 	bl	2e0 <memset>
    cause = at_create_param_array(p_atparams_string, &num_recvparams, 3, 3);
   1035c:	2303      	movs	r3, #3
   1035e:	210f      	movs	r1, #15
   10360:	0020      	movs	r0, r4
   10362:	001a      	movs	r2, r3
   10364:	4469      	add	r1, sp
   10366:	f7f9 ffbd 	bl	a2e4 <at_create_param_array>
   1036a:	1e04      	subs	r4, r0, #0
    if(cause != AT_RET_OK)
   1036c:	d107      	bne.n	1037e <at_handle_NSOCO_cmd_set+0x32>
    cause = at_get_uint16_param(AT_PARSE_FIRST_PARAM_POS, &sock, true);
   1036e:	ad04      	add	r5, sp, #16
   10370:	2201      	movs	r2, #1
   10372:	0029      	movs	r1, r5
   10374:	f7fa f8ca 	bl	a50c <at_get_uint16_param>
    if(cause != AT_RET_OK)
   10378:	2800      	cmp	r0, #0
   1037a:	d003      	beq.n	10384 <at_handle_NSOCO_cmd_set+0x38>
        return AT_RET_SYNTAX_ERROR;
   1037c:	2401      	movs	r4, #1
}
   1037e:	0020      	movs	r0, r4
   10380:	b01b      	add	sp, #108	; 0x6c
   10382:	bdf0      	pop	{r4, r5, r6, r7, pc}
    cause = at_get_ip_param(AT_PARSE_SECOND_PARAM_POS, (uint8*)ip_str, MAX_IP_LEN, true, &sock_address.sin_addr);
   10384:	ab06      	add	r3, sp, #24
   10386:	9300      	str	r3, [sp, #0]
   10388:	2301      	movs	r3, #1
   1038a:	223c      	movs	r2, #60	; 0x3c
   1038c:	a90b      	add	r1, sp, #44	; 0x2c
   1038e:	0018      	movs	r0, r3
   10390:	ae05      	add	r6, sp, #20
   10392:	f7fa fa91 	bl	a8b8 <at_get_ip_param>
    if (cause != AT_RET_OK)
   10396:	2800      	cmp	r0, #0
   10398:	d1f0      	bne.n	1037c <at_handle_NSOCO_cmd_set+0x30>
    cause = at_get_uint16_param(AT_PARSE_THIRD_PARAM_POS, &port, true);
   1039a:	2712      	movs	r7, #18
   1039c:	446f      	add	r7, sp
   1039e:	2201      	movs	r2, #1
   103a0:	0039      	movs	r1, r7
   103a2:	3002      	adds	r0, #2
   103a4:	f7fa f8b2 	bl	a50c <at_get_uint16_param>
   103a8:	1e04      	subs	r4, r0, #0
    if(cause != AT_RET_OK)
   103aa:	d1e7      	bne.n	1037c <at_handle_NSOCO_cmd_set+0x30>
    if(!check_at_allocated_socket(sock))
   103ac:	882d      	ldrh	r5, [r5, #0]
   103ae:	0028      	movs	r0, r5
   103b0:	f7ff fcb2 	bl	fd18 <check_at_allocated_socket>
   103b4:	2800      	cmp	r0, #0
   103b6:	d00c      	beq.n	103d2 <at_handle_NSOCO_cmd_set+0x86>
    sock_address.sin_port = port;
   103b8:	883b      	ldrh	r3, [r7, #0]
    ret = connect(sock, (struct sockaddr *)&sock_address, sizeof(sock_address)); //lint !e740
   103ba:	2218      	movs	r2, #24
   103bc:	0031      	movs	r1, r6
   103be:	0028      	movs	r0, r5
    sock_address.sin_port = port;
   103c0:	8073      	strh	r3, [r6, #2]
    ret = connect(sock, (struct sockaddr *)&sock_address, sizeof(sock_address)); //lint !e740
   103c2:	f7f7 fcdf 	bl	7d84 <connect>
    if (ret == NEUL_SOCKET_RET_NO_NETWORK_SERVICE)
   103c6:	1d03      	adds	r3, r0, #4
   103c8:	d005      	beq.n	103d6 <at_handle_NSOCO_cmd_set+0x8a>
    else if (ret != NEUL_SOCKET_RET_OK)
   103ca:	2800      	cmp	r0, #0
   103cc:	d0d7      	beq.n	1037e <at_handle_NSOCO_cmd_set+0x32>
        return AT_RET_PROGRESS_ERROR;
   103ce:	2406      	movs	r4, #6
   103d0:	e7d5      	b.n	1037e <at_handle_NSOCO_cmd_set+0x32>
        return AT_RET_INVALID_SOCKET;
   103d2:	2425      	movs	r4, #37	; 0x25
   103d4:	e7d3      	b.n	1037e <at_handle_NSOCO_cmd_set+0x32>
        return AT_RET_NO_NETWORK_SERVICE;
   103d6:	240b      	movs	r4, #11
   103d8:	e7d1      	b.n	1037e <at_handle_NSOCO_cmd_set+0x32>

000103da <at_cgtft_decimal_string_to_uint16_range.part.4>:
static AT_RET at_cgtft_decimal_string_to_uint16_range(const uint8 *src_str, uint16 *dst_data)
   103da:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
   103dc:	0006      	movs	r6, r0
   103de:	000d      	movs	r5, r1
    for (j = 0; j < 2; j++)
   103e0:	2702      	movs	r7, #2
        *dst_data = 0;
   103e2:	2400      	movs	r4, #0
        len = (uint8 )strlen(str_p);
   103e4:	0030      	movs	r0, r6
        *dst_data = 0;
   103e6:	802c      	strh	r4, [r5, #0]
        len = (uint8 )strlen(str_p);
   103e8:	f00a ffd9 	bl	1b39e <strlen>
   103ec:	b2c0      	uxtb	r0, r0
   103ee:	b2e3      	uxtb	r3, r4
   103f0:	1931      	adds	r1, r6, r4
        for (i = 0; (i < len) && (*str_p != '.'); i++)
   103f2:	4298      	cmp	r0, r3
   103f4:	d916      	bls.n	10424 <at_cgtft_decimal_string_to_uint16_range.part.4+0x4a>
   103f6:	5d32      	ldrb	r2, [r6, r4]
   103f8:	2a2e      	cmp	r2, #46	; 0x2e
   103fa:	d105      	bne.n	10408 <at_cgtft_decimal_string_to_uint16_range.part.4+0x2e>
        if (i == 0)
   103fc:	2b00      	cmp	r3, #0
   103fe:	d117      	bne.n	10430 <at_cgtft_decimal_string_to_uint16_range.part.4+0x56>
                return AT_RET_SYNTAX_ERROR;
   10400:	2001      	movs	r0, #1
   10402:	e01a      	b.n	1043a <at_cgtft_decimal_string_to_uint16_range.part.4+0x60>
    for (j = 0; j < 2; j++)
   10404:	2701      	movs	r7, #1
   10406:	e7ec      	b.n	103e2 <at_cgtft_decimal_string_to_uint16_range.part.4+0x8>
            if ((*str_p < '0') || (*str_p > '9') || (i >= 5))
   10408:	0013      	movs	r3, r2
   1040a:	3b30      	subs	r3, #48	; 0x30
   1040c:	2b09      	cmp	r3, #9
   1040e:	d8f7      	bhi.n	10400 <at_cgtft_decimal_string_to_uint16_range.part.4+0x26>
   10410:	3401      	adds	r4, #1
   10412:	2c06      	cmp	r4, #6
   10414:	d0f4      	beq.n	10400 <at_cgtft_decimal_string_to_uint16_range.part.4+0x26>
            *dst_data = (uint16)(*dst_data * 10 + (*str_p - '0'));
   10416:	210a      	movs	r1, #10
   10418:	882b      	ldrh	r3, [r5, #0]
   1041a:	434b      	muls	r3, r1
   1041c:	3b30      	subs	r3, #48	; 0x30
   1041e:	189b      	adds	r3, r3, r2
   10420:	802b      	strh	r3, [r5, #0]
   10422:	e7e4      	b.n	103ee <at_cgtft_decimal_string_to_uint16_range.part.4+0x14>
        if (i == 0)
   10424:	2b00      	cmp	r3, #0
   10426:	d0eb      	beq.n	10400 <at_cgtft_decimal_string_to_uint16_range.part.4+0x26>
        if (*str_p == '.')
   10428:	780b      	ldrb	r3, [r1, #0]
   1042a:	000e      	movs	r6, r1
   1042c:	2b2e      	cmp	r3, #46	; 0x2e
   1042e:	d101      	bne.n	10434 <at_cgtft_decimal_string_to_uint16_range.part.4+0x5a>
            str_p++;
   10430:	1c4e      	adds	r6, r1, #1
            dst_data++;
   10432:	3502      	adds	r5, #2
    for (j = 0; j < 2; j++)
   10434:	2f01      	cmp	r7, #1
   10436:	d1e5      	bne.n	10404 <at_cgtft_decimal_string_to_uint16_range.part.4+0x2a>
    return AT_RET_OK;
   10438:	2000      	movs	r0, #0
}
   1043a:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}

0001043c <at_handle_CGTFT_cmd_set>:
{
   1043c:	b5f0      	push	{r4, r5, r6, r7, lr}
   1043e:	b0b3      	sub	sp, #204	; 0xcc
   10440:	0006      	movs	r6, r0
    uint8          range_str[AT_CMD_CGTFT_RANGE_STR_MAX_LEN] = {0};
   10442:	220c      	movs	r2, #12
   10444:	2100      	movs	r1, #0
   10446:	a804      	add	r0, sp, #16
   10448:	f7ef ff4a 	bl	2e0 <memset>
    uint16         service_type[2] = {0};
   1044c:	2100      	movs	r1, #0
    memset(&tft_params, 0, sizeof(tft_context));
   1044e:	ac20      	add	r4, sp, #128	; 0x80
   10450:	2248      	movs	r2, #72	; 0x48
   10452:	0020      	movs	r0, r4
    uint16         service_type[2] = {0};
   10454:	9103      	str	r1, [sp, #12]
    memset(&tft_params, 0, sizeof(tft_context));
   10456:	f7ef ff43 	bl	2e0 <memset>
    cause = at_create_param_array(p_atparams_string, &num_recvparams, 1, AT_MAX_CGTFT_PARAM - 1);       //<local address and subnet mask>is not supported by UE
   1045a:	ab02      	add	r3, sp, #8
   1045c:	1cdd      	adds	r5, r3, #3
   1045e:	2201      	movs	r2, #1
   10460:	230b      	movs	r3, #11
   10462:	0029      	movs	r1, r5
   10464:	0030      	movs	r0, r6
   10466:	f7f9 ff3d 	bl	a2e4 <at_create_param_array>
    if(cause != AT_RET_OK)
   1046a:	2800      	cmp	r0, #0
   1046c:	d106      	bne.n	1047c <at_handle_CGTFT_cmd_set+0x40>
    cause = at_get_uint16_param(AT_PARSE_FIRST_PARAM_POS, &tft_params.cid, true);
   1046e:	2201      	movs	r2, #1
   10470:	a922      	add	r1, sp, #136	; 0x88
   10472:	f7fa f84b 	bl	a50c <at_get_uint16_param>
    if((cause != AT_RET_OK) || (tft_params.cid > AT_MAX_CID))
   10476:	2800      	cmp	r0, #0
   10478:	d002      	beq.n	10480 <at_handle_CGTFT_cmd_set+0x44>
        return AT_RET_SYNTAX_ERROR;
   1047a:	2001      	movs	r0, #1
}
   1047c:	b033      	add	sp, #204	; 0xcc
   1047e:	bdf0      	pop	{r4, r5, r6, r7, pc}
    if((cause != AT_RET_OK) || (tft_params.cid > AT_MAX_CID))
   10480:	8920      	ldrh	r0, [r4, #8]
   10482:	280a      	cmp	r0, #10
   10484:	d8f9      	bhi.n	1047a <at_handle_CGTFT_cmd_set+0x3e>
    if (num_recvparams == 1)
   10486:	782b      	ldrb	r3, [r5, #0]
   10488:	2b01      	cmp	r3, #1
   1048a:	d104      	bne.n	10496 <at_handle_CGTFT_cmd_set+0x5a>
        neul_ret = delete_tft_req(tft_params.cid);
   1048c:	f00c fafe 	bl	1ca8c <delete_tft_req>
    return at_parse_convert_neul_result(neul_ret);
   10490:	f7f9 fefe 	bl	a290 <at_parse_convert_neul_result>
   10494:	e7f2      	b.n	1047c <at_handle_CGTFT_cmd_set+0x40>
        cause = at_get_uint8_param(AT_PARSE_SECOND_PARAM_POS, &tft_params.pfi, true);
   10496:	2201      	movs	r2, #1
   10498:	2182      	movs	r1, #130	; 0x82
   1049a:	ab02      	add	r3, sp, #8
   1049c:	18c9      	adds	r1, r1, r3
   1049e:	0010      	movs	r0, r2
   104a0:	f7fa f8b4 	bl	a60c <at_get_uint8_param>
        if((cause != AT_RET_OK) || (tft_params.pfi < AT_CMD_CGTFT_MIN_PFI) || (tft_params.pfi > AT_CMD_CGTFT_MAX_PFI))
   104a4:	2800      	cmp	r0, #0
   104a6:	d1e8      	bne.n	1047a <at_handle_CGTFT_cmd_set+0x3e>
   104a8:	7aa3      	ldrb	r3, [r4, #10]
   104aa:	3b01      	subs	r3, #1
   104ac:	2b0f      	cmp	r3, #15
   104ae:	d8e4      	bhi.n	1047a <at_handle_CGTFT_cmd_set+0x3e>
        cause = at_get_uint8_param(AT_PARSE_THIRD_PARAM_POS, &tft_params.evaluation_precedence, true);
   104b0:	2183      	movs	r1, #131	; 0x83
   104b2:	ab02      	add	r3, sp, #8
   104b4:	2201      	movs	r2, #1
   104b6:	18c9      	adds	r1, r1, r3
   104b8:	3002      	adds	r0, #2
   104ba:	f7fa f8a7 	bl	a60c <at_get_uint8_param>
        if(cause != AT_RET_OK)
   104be:	2800      	cmp	r0, #0
   104c0:	d1db      	bne.n	1047a <at_handle_CGTFT_cmd_set+0x3e>
        p_remote_addr_subnet_mask_str = (char *)irmalloc(AT_CMD_CGTFT_ADDR_MASK_STR_MAX_LEN);
   104c2:	3082      	adds	r0, #130	; 0x82
   104c4:	f002 fa9c 	bl	12a00 <irmalloc>
   104c8:	9000      	str	r0, [sp, #0]
        if (p_remote_addr_subnet_mask_str == NULL)
   104ca:	9b00      	ldr	r3, [sp, #0]
             return AT_RET_MEMORY_ERROR;
   104cc:	2004      	movs	r0, #4
        if (p_remote_addr_subnet_mask_str == NULL)
   104ce:	2b00      	cmp	r3, #0
   104d0:	d0d4      	beq.n	1047c <at_handle_CGTFT_cmd_set+0x40>
        cause = at_get_string_param(AT_PARSE_FOURTH_PARAM_POS, (uint8 *)p_remote_addr_subnet_mask_str, AT_CMD_CGTFT_ADDR_MASK_STR_MAX_LEN, true);
   104d2:	2301      	movs	r3, #1
   104d4:	2282      	movs	r2, #130	; 0x82
   104d6:	9900      	ldr	r1, [sp, #0]
   104d8:	3801      	subs	r0, #1
   104da:	f7fa f955 	bl	a788 <at_get_string_param>
   104de:	0006      	movs	r6, r0
   104e0:	1e05      	subs	r5, r0, #0
        if (cause == AT_RET_OK)
   104e2:	d000      	beq.n	104e6 <at_handle_CGTFT_cmd_set+0xaa>
   104e4:	e15c      	b.n	107a0 <at_handle_CGTFT_cmd_set+0x364>
    char  ip_temp[MAX_IP_LEN] = {0};
   104e6:	0001      	movs	r1, r0
   104e8:	223c      	movs	r2, #60	; 0x3c
   104ea:	a811      	add	r0, sp, #68	; 0x44
   104ec:	f7ef fef8 	bl	2e0 <memset>
    memset(remote_addr, 0, sizeof(ip_addr_t));
   104f0:	2214      	movs	r2, #20
   104f2:	0031      	movs	r1, r6
   104f4:	a807      	add	r0, sp, #28
   104f6:	f7ef fef3 	bl	2e0 <memset>
    memset(subnet_mask, 0, sizeof(ip_addr_t));
   104fa:	2214      	movs	r2, #20
   104fc:	0031      	movs	r1, r6
   104fe:	a80c      	add	r0, sp, #48	; 0x30
   10500:	f7ef feee 	bl	2e0 <memset>
    str_len = (uint8)strlen(addr_mask_str);
   10504:	9800      	ldr	r0, [sp, #0]
   10506:	f00a ff4a 	bl	1b39e <strlen>
   1050a:	b2c3      	uxtb	r3, r0
   1050c:	469c      	mov	ip, r3
   1050e:	0032      	movs	r2, r6
    uint8 dot_count = 0;
   10510:	0033      	movs	r3, r6
   10512:	b2d1      	uxtb	r1, r2
    for (i = 0; i < str_len; i++)
   10514:	458c      	cmp	ip, r1
   10516:	d900      	bls.n	1051a <at_handle_CGTFT_cmd_set+0xde>
   10518:	e0c6      	b.n	106a8 <at_handle_CGTFT_cmd_set+0x26c>
    if (str_len <= remote_addr_str_len + 1)
   1051a:	b2c7      	uxtb	r7, r0
   1051c:	1c6a      	adds	r2, r5, #1
   1051e:	4297      	cmp	r7, r2
   10520:	dd00      	ble.n	10524 <at_handle_CGTFT_cmd_set+0xe8>
   10522:	e0d2      	b.n	106ca <at_handle_CGTFT_cmd_set+0x28e>
        return AT_RET_SYNTAX_ERROR;
   10524:	2601      	movs	r6, #1
            irfree(p_remote_addr_subnet_mask_str);
   10526:	9800      	ldr	r0, [sp, #0]
   10528:	f002 fa86 	bl	12a38 <irfree>
            if (cause != AT_RET_OK)
   1052c:	2e00      	cmp	r6, #0
   1052e:	d1a4      	bne.n	1047a <at_handle_CGTFT_cmd_set+0x3e>
            tft_params.addr_subnet_type = IP_GET_TYPE(&remote_addr);
   10530:	a907      	add	r1, sp, #28
   10532:	7c0b      	ldrb	r3, [r1, #16]
   10534:	ad20      	add	r5, sp, #128	; 0x80
   10536:	732b      	strb	r3, [r5, #12]
            if (tft_params.addr_subnet_type == IPADDR_TYPE_V4)
   10538:	2b00      	cmp	r3, #0
   1053a:	d000      	beq.n	1053e <at_handle_CGTFT_cmd_set+0x102>
   1053c:	e125      	b.n	1078a <at_handle_CGTFT_cmd_set+0x34e>
                memcpy(tft_params.remote_addr, (uint8*)ip_2_ip4(&remote_addr), AT_IPV4_FULL_ADDR_LEN);
   1053e:	2085      	movs	r0, #133	; 0x85
   10540:	ab02      	add	r3, sp, #8
   10542:	2204      	movs	r2, #4
   10544:	18c0      	adds	r0, r0, r3
   10546:	f7ef fe53 	bl	1f0 <memcpy>
                memcpy(tft_params.subnet_mask_addr, (uint8*)ip_2_ip4(&subnet_mask_addr), AT_IPV4_FULL_ADDR_LEN);
   1054a:	2204      	movs	r2, #4
                memcpy(tft_params.subnet_mask_addr, (uint8*)ip_2_ip6(&subnet_mask_addr), AT_IPV6_FULL_ADDR_LEN);
   1054c:	2095      	movs	r0, #149	; 0x95
   1054e:	ab02      	add	r3, sp, #8
   10550:	18c0      	adds	r0, r0, r3
   10552:	a90c      	add	r1, sp, #48	; 0x30
   10554:	f7ef fe4c 	bl	1f0 <memcpy>
            tft_params.remote_addr_subnet_mask_present = true;
   10558:	2301      	movs	r3, #1
   1055a:	702b      	strb	r3, [r5, #0]
        cause = at_get_uint8_param(AT_PARSE_FIFTH_PARAM_POS, &tft_params.protnum_nexthead, true);
   1055c:	21a5      	movs	r1, #165	; 0xa5
   1055e:	ab02      	add	r3, sp, #8
   10560:	2201      	movs	r2, #1
   10562:	18c9      	adds	r1, r1, r3
   10564:	2004      	movs	r0, #4
   10566:	f7fa f851 	bl	a60c <at_get_uint8_param>
        if (cause == AT_RET_OK)
   1056a:	2800      	cmp	r0, #0
   1056c:	d000      	beq.n	10570 <at_handle_CGTFT_cmd_set+0x134>
   1056e:	e11e      	b.n	107ae <at_handle_CGTFT_cmd_set+0x372>
            tft_params.protnum_nexthead_present = true;
   10570:	2301      	movs	r3, #1
   10572:	7063      	strb	r3, [r4, #1]
        cause = at_get_string_param(AT_PARSE_SIXTH_PARAM_POS, range_str, AT_CMD_CGTFT_RANGE_STR_MAX_LEN, true);
   10574:	2301      	movs	r3, #1
   10576:	220c      	movs	r2, #12
   10578:	a904      	add	r1, sp, #16
   1057a:	2005      	movs	r0, #5
   1057c:	f7fa f904 	bl	a788 <at_get_string_param>
        if(cause == AT_RET_OK)
   10580:	2800      	cmp	r0, #0
   10582:	d000      	beq.n	10586 <at_handle_CGTFT_cmd_set+0x14a>
   10584:	e117      	b.n	107b6 <at_handle_CGTFT_cmd_set+0x37a>
   10586:	21a6      	movs	r1, #166	; 0xa6
   10588:	ab02      	add	r3, sp, #8
   1058a:	18c9      	adds	r1, r1, r3
   1058c:	a804      	add	r0, sp, #16
   1058e:	f7ff ff24 	bl	103da <at_cgtft_decimal_string_to_uint16_range.part.4>
            if ((cause != AT_RET_OK) || (tft_params.local_port_range[0] > tft_params.local_port_range[1]))
   10592:	2800      	cmp	r0, #0
   10594:	d000      	beq.n	10598 <at_handle_CGTFT_cmd_set+0x15c>
   10596:	e770      	b.n	1047a <at_handle_CGTFT_cmd_set+0x3e>
   10598:	8de2      	ldrh	r2, [r4, #46]	; 0x2e
   1059a:	8e23      	ldrh	r3, [r4, #48]	; 0x30
   1059c:	429a      	cmp	r2, r3
   1059e:	d900      	bls.n	105a2 <at_handle_CGTFT_cmd_set+0x166>
   105a0:	e76b      	b.n	1047a <at_handle_CGTFT_cmd_set+0x3e>
            tft_params.local_port_range_present = true;
   105a2:	2301      	movs	r3, #1
   105a4:	70a3      	strb	r3, [r4, #2]
        memset(range_str, 0, AT_CMD_CGTFT_RANGE_STR_MAX_LEN);
   105a6:	220c      	movs	r2, #12
   105a8:	2100      	movs	r1, #0
   105aa:	a804      	add	r0, sp, #16
   105ac:	f7ef fe98 	bl	2e0 <memset>
        cause = at_get_string_param(AT_PARSE_SEVENTH_PARAM_POS, range_str, AT_CMD_CGTFT_RANGE_STR_MAX_LEN, true);
   105b0:	2301      	movs	r3, #1
   105b2:	220c      	movs	r2, #12
   105b4:	a904      	add	r1, sp, #16
   105b6:	2006      	movs	r0, #6
   105b8:	f7fa f8e6 	bl	a788 <at_get_string_param>
        if(cause == AT_RET_OK)
   105bc:	2800      	cmp	r0, #0
   105be:	d000      	beq.n	105c2 <at_handle_CGTFT_cmd_set+0x186>
   105c0:	e0fd      	b.n	107be <at_handle_CGTFT_cmd_set+0x382>
   105c2:	21aa      	movs	r1, #170	; 0xaa
   105c4:	ab02      	add	r3, sp, #8
   105c6:	18c9      	adds	r1, r1, r3
   105c8:	a804      	add	r0, sp, #16
   105ca:	f7ff ff06 	bl	103da <at_cgtft_decimal_string_to_uint16_range.part.4>
            if((cause != AT_RET_OK) || (tft_params.remote_port_range[0] > tft_params.remote_port_range[1]))
   105ce:	2800      	cmp	r0, #0
   105d0:	d000      	beq.n	105d4 <at_handle_CGTFT_cmd_set+0x198>
   105d2:	e752      	b.n	1047a <at_handle_CGTFT_cmd_set+0x3e>
   105d4:	8e62      	ldrh	r2, [r4, #50]	; 0x32
   105d6:	8ea3      	ldrh	r3, [r4, #52]	; 0x34
   105d8:	429a      	cmp	r2, r3
   105da:	d900      	bls.n	105de <at_handle_CGTFT_cmd_set+0x1a2>
   105dc:	e74d      	b.n	1047a <at_handle_CGTFT_cmd_set+0x3e>
            tft_params.remote_port_range_present = true;
   105de:	2301      	movs	r3, #1
   105e0:	70e3      	strb	r3, [r4, #3]
        cause = at_get_uint32_param(AT_PARSE_EIGHTH_PARAM_POS, &tft_params.spi, true);
   105e2:	2201      	movs	r2, #1
   105e4:	a92e      	add	r1, sp, #184	; 0xb8
   105e6:	2007      	movs	r0, #7
   105e8:	f7f9 ff18 	bl	a41c <at_get_uint32_param>
        if(cause == AT_RET_OK)
   105ec:	2800      	cmp	r0, #0
   105ee:	d000      	beq.n	105f2 <at_handle_CGTFT_cmd_set+0x1b6>
   105f0:	e0e9      	b.n	107c6 <at_handle_CGTFT_cmd_set+0x38a>
            tft_params.spi_present = true;
   105f2:	2301      	movs	r3, #1
   105f4:	7123      	strb	r3, [r4, #4]
        memset(range_str, 0, AT_CMD_CGTFT_RANGE_STR_MAX_LEN);
   105f6:	220c      	movs	r2, #12
   105f8:	2100      	movs	r1, #0
   105fa:	a804      	add	r0, sp, #16
   105fc:	f7ef fe70 	bl	2e0 <memset>
        cause = at_get_string_param(AT_PARSE_NINTH_PARAM_POS, range_str, AT_CMD_CGTFT_RANGE_STR_MAX_LEN, true);
   10600:	2301      	movs	r3, #1
   10602:	220c      	movs	r2, #12
   10604:	a904      	add	r1, sp, #16
   10606:	2008      	movs	r0, #8
   10608:	f7fa f8be 	bl	a788 <at_get_string_param>
        if(cause == AT_RET_OK)
   1060c:	2800      	cmp	r0, #0
   1060e:	d000      	beq.n	10612 <at_handle_CGTFT_cmd_set+0x1d6>
   10610:	e0dd      	b.n	107ce <at_handle_CGTFT_cmd_set+0x392>
   10612:	ad03      	add	r5, sp, #12
   10614:	0029      	movs	r1, r5
   10616:	a804      	add	r0, sp, #16
   10618:	f7ff fedf 	bl	103da <at_cgtft_decimal_string_to_uint16_range.part.4>
            if((cause != AT_RET_OK) || (service_type[0] > 255) || (service_type[1] > 255) || (service_type[0] > service_type[1]))
   1061c:	2800      	cmp	r0, #0
   1061e:	d000      	beq.n	10622 <at_handle_CGTFT_cmd_set+0x1e6>
   10620:	e72b      	b.n	1047a <at_handle_CGTFT_cmd_set+0x3e>
   10622:	882a      	ldrh	r2, [r5, #0]
   10624:	2aff      	cmp	r2, #255	; 0xff
   10626:	d900      	bls.n	1062a <at_handle_CGTFT_cmd_set+0x1ee>
   10628:	e727      	b.n	1047a <at_handle_CGTFT_cmd_set+0x3e>
   1062a:	886b      	ldrh	r3, [r5, #2]
   1062c:	2bff      	cmp	r3, #255	; 0xff
   1062e:	d900      	bls.n	10632 <at_handle_CGTFT_cmd_set+0x1f6>
   10630:	e723      	b.n	1047a <at_handle_CGTFT_cmd_set+0x3e>
   10632:	429a      	cmp	r2, r3
   10634:	d900      	bls.n	10638 <at_handle_CGTFT_cmd_set+0x1fc>
   10636:	e720      	b.n	1047a <at_handle_CGTFT_cmd_set+0x3e>
            tft_params.service_type[0] = (uint8)service_type[0];
   10638:	a92f      	add	r1, sp, #188	; 0xbc
   1063a:	700a      	strb	r2, [r1, #0]
            tft_params.service_type[1] = (uint8)service_type[1];
   1063c:	22b5      	movs	r2, #181	; 0xb5
   1063e:	a902      	add	r1, sp, #8
   10640:	1852      	adds	r2, r2, r1
   10642:	7013      	strb	r3, [r2, #0]
            tft_params.service_type_present = true;
   10644:	2301      	movs	r3, #1
   10646:	7163      	strb	r3, [r4, #5]
        cause = at_get_uint32_param(AT_PARSE_TENTH_PARAM_POS, &tft_params.flow_label, true);
   10648:	2201      	movs	r2, #1
   1064a:	a930      	add	r1, sp, #192	; 0xc0
   1064c:	2009      	movs	r0, #9
   1064e:	f7f9 fee5 	bl	a41c <at_get_uint32_param>
        if(cause == AT_RET_OK)
   10652:	2800      	cmp	r0, #0
   10654:	d000      	beq.n	10658 <at_handle_CGTFT_cmd_set+0x21c>
   10656:	e0be      	b.n	107d6 <at_handle_CGTFT_cmd_set+0x39a>
            if (tft_params.flow_label > 0xFFFFF)
   10658:	4b63      	ldr	r3, [pc, #396]	; (107e8 <at_handle_CGTFT_cmd_set+0x3ac>)
   1065a:	6c22      	ldr	r2, [r4, #64]	; 0x40
   1065c:	429a      	cmp	r2, r3
   1065e:	d900      	bls.n	10662 <at_handle_CGTFT_cmd_set+0x226>
   10660:	e70b      	b.n	1047a <at_handle_CGTFT_cmd_set+0x3e>
            tft_params.flow_label_present = true;
   10662:	2301      	movs	r3, #1
   10664:	71a3      	strb	r3, [r4, #6]
        cause = at_get_uint8_param(AT_PARSE_ELEVENTH_PARAM_POS, &tft_params.direction, true);
   10666:	2201      	movs	r2, #1
   10668:	a931      	add	r1, sp, #196	; 0xc4
   1066a:	200a      	movs	r0, #10
   1066c:	f7f9 ffce 	bl	a60c <at_get_uint8_param>
        if (cause == AT_RET_OK)
   10670:	2800      	cmp	r0, #0
   10672:	d000      	beq.n	10676 <at_handle_CGTFT_cmd_set+0x23a>
   10674:	e0b3      	b.n	107de <at_handle_CGTFT_cmd_set+0x3a2>
            tft_params.direction_present = true;
   10676:	2301      	movs	r3, #1
   10678:	71e3      	strb	r3, [r4, #7]
        if (tft_params.remote_addr_subnet_mask_present && tft_params.flow_label_present)
   1067a:	ab20      	add	r3, sp, #128	; 0x80
   1067c:	781a      	ldrb	r2, [r3, #0]
   1067e:	2a00      	cmp	r2, #0
   10680:	d006      	beq.n	10690 <at_handle_CGTFT_cmd_set+0x254>
   10682:	799a      	ldrb	r2, [r3, #6]
   10684:	2a00      	cmp	r2, #0
   10686:	d003      	beq.n	10690 <at_handle_CGTFT_cmd_set+0x254>
            if (tft_params.addr_subnet_type != IPADDR_TYPE_V6)
   10688:	7b1a      	ldrb	r2, [r3, #12]
   1068a:	2a06      	cmp	r2, #6
   1068c:	d000      	beq.n	10690 <at_handle_CGTFT_cmd_set+0x254>
   1068e:	e6f4      	b.n	1047a <at_handle_CGTFT_cmd_set+0x3e>
        if (tft_params.remote_addr_subnet_mask_present || tft_params.protnum_nexthead_present || tft_params.local_port_range_present || tft_params.remote_port_range_present
   10690:	9a20      	ldr	r2, [sp, #128]	; 0x80
   10692:	2a00      	cmp	r2, #0
   10694:	d104      	bne.n	106a0 <at_handle_CGTFT_cmd_set+0x264>
         || tft_params.spi_present || tft_params.service_type_present || tft_params.flow_label_present)
   10696:	685a      	ldr	r2, [r3, #4]
            return AT_RET_PARAM_MISSING;
   10698:	2003      	movs	r0, #3
         || tft_params.spi_present || tft_params.service_type_present || tft_params.flow_label_present)
   1069a:	0212      	lsls	r2, r2, #8
   1069c:	d100      	bne.n	106a0 <at_handle_CGTFT_cmd_set+0x264>
   1069e:	e6ed      	b.n	1047c <at_handle_CGTFT_cmd_set+0x40>
            neul_ret = set_tft_req(&tft_params);
   106a0:	0018      	movs	r0, r3
   106a2:	f00c f9ff 	bl	1caa4 <set_tft_req>
   106a6:	e6f3      	b.n	10490 <at_handle_CGTFT_cmd_set+0x54>
        if (addr_mask_str[i] == '.')
   106a8:	9f00      	ldr	r7, [sp, #0]
   106aa:	5cbf      	ldrb	r7, [r7, r2]
   106ac:	2f2e      	cmp	r7, #46	; 0x2e
   106ae:	d10a      	bne.n	106c6 <at_handle_CGTFT_cmd_set+0x28a>
            dot_count++;
   106b0:	3301      	adds	r3, #1
   106b2:	b2db      	uxtb	r3, r3
            if (dot_count == 1 || dot_count == 4 || dot_count == 16)
   106b4:	2b01      	cmp	r3, #1
   106b6:	d003      	beq.n	106c0 <at_handle_CGTFT_cmd_set+0x284>
   106b8:	2b04      	cmp	r3, #4
   106ba:	d001      	beq.n	106c0 <at_handle_CGTFT_cmd_set+0x284>
   106bc:	2b10      	cmp	r3, #16
   106be:	d102      	bne.n	106c6 <at_handle_CGTFT_cmd_set+0x28a>
   106c0:	3201      	adds	r2, #1
    uint8 remote_addr_str_len = 0;
   106c2:	000d      	movs	r5, r1
   106c4:	e725      	b.n	10512 <at_handle_CGTFT_cmd_set+0xd6>
            if (dot_count == 1 || dot_count == 4 || dot_count == 16)
   106c6:	0029      	movs	r1, r5
   106c8:	e7fa      	b.n	106c0 <at_handle_CGTFT_cmd_set+0x284>
    if (dot_count == 1 || dot_count == 7)
   106ca:	2b01      	cmp	r3, #1
   106cc:	d001      	beq.n	106d2 <at_handle_CGTFT_cmd_set+0x296>
   106ce:	2b07      	cmp	r3, #7
   106d0:	d121      	bne.n	10716 <at_handle_CGTFT_cmd_set+0x2da>
        memcpy(ip_temp, addr_mask_str, remote_addr_str_len);
   106d2:	9900      	ldr	r1, [sp, #0]
   106d4:	002a      	movs	r2, r5
   106d6:	a811      	add	r0, sp, #68	; 0x44
   106d8:	f7ef fd8a 	bl	1f0 <memcpy>
        if (ipaddr_aton(ip_temp, remote_addr) != 1)
   106dc:	a907      	add	r1, sp, #28
   106de:	a811      	add	r0, sp, #68	; 0x44
   106e0:	f00c fd76 	bl	1d1d0 <ipaddr_aton>
   106e4:	2801      	cmp	r0, #1
   106e6:	d000      	beq.n	106ea <at_handle_CGTFT_cmd_set+0x2ae>
   106e8:	e71c      	b.n	10524 <at_handle_CGTFT_cmd_set+0xe8>
        memset(ip_temp, 0, MAX_IP_LEN);
   106ea:	223c      	movs	r2, #60	; 0x3c
   106ec:	2100      	movs	r1, #0
   106ee:	a811      	add	r0, sp, #68	; 0x44
   106f0:	f7ef fdf6 	bl	2e0 <memset>
        memcpy(ip_temp, (addr_mask_str + remote_addr_str_len + 1), ((str_len - remote_addr_str_len) - 1));
   106f4:	9b00      	ldr	r3, [sp, #0]
   106f6:	1b7a      	subs	r2, r7, r5
   106f8:	1c69      	adds	r1, r5, #1
   106fa:	1859      	adds	r1, r3, r1
   106fc:	3a01      	subs	r2, #1
   106fe:	a811      	add	r0, sp, #68	; 0x44
   10700:	f7ef fd76 	bl	1f0 <memcpy>
        if (ipaddr_aton(ip_temp, subnet_mask) != 1)
   10704:	a90c      	add	r1, sp, #48	; 0x30
   10706:	a811      	add	r0, sp, #68	; 0x44
   10708:	f00c fd62 	bl	1d1d0 <ipaddr_aton>
   1070c:	3801      	subs	r0, #1
   1070e:	1e43      	subs	r3, r0, #1
   10710:	4198      	sbcs	r0, r3
                    return AT_RET_SYNTAX_ERROR;
   10712:	b2c6      	uxtb	r6, r0
   10714:	e707      	b.n	10526 <at_handle_CGTFT_cmd_set+0xea>
    else if (dot_count == 31)
   10716:	2b1f      	cmp	r3, #31
   10718:	d000      	beq.n	1071c <at_handle_CGTFT_cmd_set+0x2e0>
   1071a:	e703      	b.n	10524 <at_handle_CGTFT_cmd_set+0xe8>
   1071c:	2100      	movs	r1, #0
                if (ip_temp[index] * 10 + addr_mask_str[i] - '0' > 0xFF)
   1071e:	ad11      	add	r5, sp, #68	; 0x44
    uint8 index = 0;
   10720:	000b      	movs	r3, r1
   10722:	e017      	b.n	10754 <at_handle_CGTFT_cmd_set+0x318>
            if (addr_mask_str[i] != '.')
   10724:	9a00      	ldr	r2, [sp, #0]
   10726:	5c50      	ldrb	r0, [r2, r1]
   10728:	282e      	cmp	r0, #46	; 0x2e
   1072a:	d029      	beq.n	10780 <at_handle_CGTFT_cmd_set+0x344>
                if ((addr_mask_str[i] < '0') || (addr_mask_str[i] > '9'))
   1072c:	0002      	movs	r2, r0
   1072e:	3a30      	subs	r2, #48	; 0x30
   10730:	b2d2      	uxtb	r2, r2
   10732:	9201      	str	r2, [sp, #4]
   10734:	2a09      	cmp	r2, #9
   10736:	d900      	bls.n	1073a <at_handle_CGTFT_cmd_set+0x2fe>
   10738:	e6f4      	b.n	10524 <at_handle_CGTFT_cmd_set+0xe8>
                if (ip_temp[index] * 10 + addr_mask_str[i] - '0' > 0xFF)
   1073a:	220a      	movs	r2, #10
   1073c:	5cef      	ldrb	r7, [r5, r3]
   1073e:	4357      	muls	r7, r2
   10740:	2230      	movs	r2, #48	; 0x30
   10742:	1838      	adds	r0, r7, r0
   10744:	32ff      	adds	r2, #255	; 0xff
   10746:	4290      	cmp	r0, r2
   10748:	dd00      	ble.n	1074c <at_handle_CGTFT_cmd_set+0x310>
   1074a:	e6eb      	b.n	10524 <at_handle_CGTFT_cmd_set+0xe8>
                ip_temp[index] = (char)(ip_temp[index] * 10 + addr_mask_str[i] - '0');
   1074c:	9a01      	ldr	r2, [sp, #4]
   1074e:	19d2      	adds	r2, r2, r7
   10750:	54ea      	strb	r2, [r5, r3]
   10752:	3101      	adds	r1, #1
        for (i = 0; i < str_len; i++)
   10754:	b2ca      	uxtb	r2, r1
   10756:	4594      	cmp	ip, r2
   10758:	d8e4      	bhi.n	10724 <at_handle_CGTFT_cmd_set+0x2e8>
        IP_SET_TYPE_VAL(*remote_addr, IPADDR_TYPE_V6);
   1075a:	2224      	movs	r2, #36	; 0x24
   1075c:	2106      	movs	r1, #6
   1075e:	ab02      	add	r3, sp, #8
   10760:	189b      	adds	r3, r3, r2
   10762:	7019      	strb	r1, [r3, #0]
        memcpy((uint8*)ip_2_ip6(remote_addr), ip_temp, AT_IPV6_FULL_ADDR_LEN);
   10764:	aa07      	add	r2, sp, #28
   10766:	ab11      	add	r3, sp, #68	; 0x44
   10768:	cba1      	ldmia	r3!, {r0, r5, r7}
   1076a:	c2a1      	stmia	r2!, {r0, r5, r7}
   1076c:	681b      	ldr	r3, [r3, #0]
   1076e:	6013      	str	r3, [r2, #0]
        IP_SET_TYPE_VAL(*subnet_mask, IPADDR_TYPE_V6);
   10770:	aa0c      	add	r2, sp, #48	; 0x30
   10772:	7411      	strb	r1, [r2, #16]
        memcpy((uint8*)ip_2_ip6(subnet_mask), ip_temp + AT_IPV6_FULL_ADDR_LEN, AT_IPV6_FULL_ADDR_LEN);
   10774:	ab15      	add	r3, sp, #84	; 0x54
   10776:	cb23      	ldmia	r3!, {r0, r1, r5}
   10778:	c223      	stmia	r2!, {r0, r1, r5}
   1077a:	681b      	ldr	r3, [r3, #0]
   1077c:	6013      	str	r3, [r2, #0]
   1077e:	e6d2      	b.n	10526 <at_handle_CGTFT_cmd_set+0xea>
                index++;
   10780:	3301      	adds	r3, #1
   10782:	b2db      	uxtb	r3, r3
                if (index >= (AT_IPV6_FULL_ADDR_LEN * 2))
   10784:	2b1f      	cmp	r3, #31
   10786:	d9e4      	bls.n	10752 <at_handle_CGTFT_cmd_set+0x316>
   10788:	e6cc      	b.n	10524 <at_handle_CGTFT_cmd_set+0xe8>
            else if (tft_params.addr_subnet_type == IPADDR_TYPE_V6)
   1078a:	2b06      	cmp	r3, #6
   1078c:	d000      	beq.n	10790 <at_handle_CGTFT_cmd_set+0x354>
   1078e:	e674      	b.n	1047a <at_handle_CGTFT_cmd_set+0x3e>
                memcpy(tft_params.remote_addr, (uint8*)ip_2_ip6(&remote_addr), AT_IPV6_FULL_ADDR_LEN);
   10790:	2085      	movs	r0, #133	; 0x85
   10792:	ab02      	add	r3, sp, #8
   10794:	2210      	movs	r2, #16
   10796:	18c0      	adds	r0, r0, r3
   10798:	f7ef fd2a 	bl	1f0 <memcpy>
                memcpy(tft_params.subnet_mask_addr, (uint8*)ip_2_ip6(&subnet_mask_addr), AT_IPV6_FULL_ADDR_LEN);
   1079c:	2210      	movs	r2, #16
   1079e:	e6d5      	b.n	1054c <at_handle_CGTFT_cmd_set+0x110>
            irfree(p_remote_addr_subnet_mask_str);
   107a0:	9800      	ldr	r0, [sp, #0]
   107a2:	f002 f949 	bl	12a38 <irfree>
            if (cause != AT_RET_PARAM_MISSING)
   107a6:	2e03      	cmp	r6, #3
   107a8:	d000      	beq.n	107ac <at_handle_CGTFT_cmd_set+0x370>
   107aa:	e666      	b.n	1047a <at_handle_CGTFT_cmd_set+0x3e>
   107ac:	e6d6      	b.n	1055c <at_handle_CGTFT_cmd_set+0x120>
        else if (cause != AT_RET_PARAM_MISSING)
   107ae:	2803      	cmp	r0, #3
   107b0:	d000      	beq.n	107b4 <at_handle_CGTFT_cmd_set+0x378>
   107b2:	e662      	b.n	1047a <at_handle_CGTFT_cmd_set+0x3e>
   107b4:	e6de      	b.n	10574 <at_handle_CGTFT_cmd_set+0x138>
        else if (cause != AT_RET_PARAM_MISSING)
   107b6:	2803      	cmp	r0, #3
   107b8:	d000      	beq.n	107bc <at_handle_CGTFT_cmd_set+0x380>
   107ba:	e65e      	b.n	1047a <at_handle_CGTFT_cmd_set+0x3e>
   107bc:	e6f3      	b.n	105a6 <at_handle_CGTFT_cmd_set+0x16a>
        else if (cause != AT_RET_PARAM_MISSING)
   107be:	2803      	cmp	r0, #3
   107c0:	d000      	beq.n	107c4 <at_handle_CGTFT_cmd_set+0x388>
   107c2:	e65a      	b.n	1047a <at_handle_CGTFT_cmd_set+0x3e>
   107c4:	e70d      	b.n	105e2 <at_handle_CGTFT_cmd_set+0x1a6>
        else if (cause != AT_RET_PARAM_MISSING)
   107c6:	2803      	cmp	r0, #3
   107c8:	d000      	beq.n	107cc <at_handle_CGTFT_cmd_set+0x390>
   107ca:	e656      	b.n	1047a <at_handle_CGTFT_cmd_set+0x3e>
   107cc:	e713      	b.n	105f6 <at_handle_CGTFT_cmd_set+0x1ba>
        else if (cause != AT_RET_PARAM_MISSING)
   107ce:	2803      	cmp	r0, #3
   107d0:	d000      	beq.n	107d4 <at_handle_CGTFT_cmd_set+0x398>
   107d2:	e652      	b.n	1047a <at_handle_CGTFT_cmd_set+0x3e>
   107d4:	e738      	b.n	10648 <at_handle_CGTFT_cmd_set+0x20c>
        else if (cause != AT_RET_PARAM_MISSING)
   107d6:	2803      	cmp	r0, #3
   107d8:	d000      	beq.n	107dc <at_handle_CGTFT_cmd_set+0x3a0>
   107da:	e64e      	b.n	1047a <at_handle_CGTFT_cmd_set+0x3e>
   107dc:	e743      	b.n	10666 <at_handle_CGTFT_cmd_set+0x22a>
        else if (cause != AT_RET_PARAM_MISSING)
   107de:	2803      	cmp	r0, #3
   107e0:	d000      	beq.n	107e4 <at_handle_CGTFT_cmd_set+0x3a8>
   107e2:	e64a      	b.n	1047a <at_handle_CGTFT_cmd_set+0x3e>
   107e4:	e749      	b.n	1067a <at_handle_CGTFT_cmd_set+0x23e>
   107e6:	46c0      	nop			; (mov r8, r8)
   107e8:	000fffff 	.word	0x000fffff

000107ec <at_parse_binary_string_to_uint8>:
{
   107ec:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
   107ee:	0006      	movs	r6, r0
   107f0:	000f      	movs	r7, r1
    if ( strlen((char*)src_str) > 8)
   107f2:	f00a fdd4 	bl	1b39e <strlen>
   107f6:	2808      	cmp	r0, #8
   107f8:	d914      	bls.n	10824 <at_parse_binary_string_to_uint8+0x38>
        return AT_RET_SYNTAX_ERROR;
   107fa:	2001      	movs	r0, #1
}
   107fc:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
        if((src_str[index] != '0') && (src_str[index] != '1'))
   107fe:	5d33      	ldrb	r3, [r6, r4]
   10800:	001a      	movs	r2, r3
   10802:	3a30      	subs	r2, #48	; 0x30
   10804:	2a01      	cmp	r2, #1
   10806:	d8f8      	bhi.n	107fa <at_parse_binary_string_to_uint8+0xe>
        *dst_data = (uint8)(temp << 1) + (src_str[index] - '0');
   10808:	006d      	lsls	r5, r5, #1
   1080a:	3d30      	subs	r5, #48	; 0x30
   1080c:	195d      	adds	r5, r3, r5
   1080e:	b2ed      	uxtb	r5, r5
    for (uint8 index = 0; index < strlen((char*)src_str); index ++)
   10810:	3401      	adds	r4, #1
        *dst_data = (uint8)(temp << 1) + (src_str[index] - '0');
   10812:	703d      	strb	r5, [r7, #0]
    for (uint8 index = 0; index < strlen((char*)src_str); index ++)
   10814:	b2e4      	uxtb	r4, r4
   10816:	0030      	movs	r0, r6
   10818:	f00a fdc1 	bl	1b39e <strlen>
   1081c:	4284      	cmp	r4, r0
   1081e:	d3ee      	bcc.n	107fe <at_parse_binary_string_to_uint8+0x12>
    return AT_RET_OK;
   10820:	2000      	movs	r0, #0
   10822:	e7eb      	b.n	107fc <at_parse_binary_string_to_uint8+0x10>
    for (uint8 index = 0; index < strlen((char*)src_str); index ++)
   10824:	2400      	movs	r4, #0
    uint8 temp = 0;
   10826:	0025      	movs	r5, r4
   10828:	e7f5      	b.n	10816 <at_parse_binary_string_to_uint8+0x2a>
	...

0001082c <at_cedrxs_nptwedrxs_common_handle_set>:
{
   1082c:	b5f0      	push	{r4, r5, r6, r7, lr}
    uint16              mode                                                       = 0;
   1082e:	2400      	movs	r4, #0
    uint16              type                                                       = 0;
   10830:	270e      	movs	r7, #14
{
   10832:	b08b      	sub	sp, #44	; 0x2c
    uint16              mode                                                       = 0;
   10834:	ab02      	add	r3, sp, #8
   10836:	819c      	strh	r4, [r3, #12]
    uint16              type                                                       = 0;
   10838:	18ff      	adds	r7, r7, r3
    uint8               paging_time_window                                         = NEUL_EDRX_AND_PTW_INVALID_FALG;
   1083a:	250b      	movs	r5, #11
    uint8               edrx_value                                                 = NEUL_EDRX_AND_PTW_INVALID_FALG;
   1083c:	23ff      	movs	r3, #255	; 0xff
   1083e:	aa02      	add	r2, sp, #8
   10840:	7293      	strb	r3, [r2, #10]
{
   10842:	9003      	str	r0, [sp, #12]
   10844:	000e      	movs	r6, r1
    uint8               paging_time_window                                         = NEUL_EDRX_AND_PTW_INVALID_FALG;
   10846:	18ad      	adds	r5, r5, r2
    uint8               str_edrx[AT_CEDRXS_BINARY_STRING_LEN + 1]                  = {0};
   10848:	0021      	movs	r1, r4
   1084a:	2207      	movs	r2, #7
   1084c:	a806      	add	r0, sp, #24
    uint8               paging_time_window                                         = NEUL_EDRX_AND_PTW_INVALID_FALG;
   1084e:	702b      	strb	r3, [r5, #0]
    uint16              type                                                       = 0;
   10850:	803c      	strh	r4, [r7, #0]
    uint8               str_edrx[AT_CEDRXS_BINARY_STRING_LEN + 1]                  = {0};
   10852:	f7ef fd45 	bl	2e0 <memset>
    uint8               paging_time_window_string[AT_CEDRXS_BINARY_STRING_LEN + 1] = {0};
   10856:	2207      	movs	r2, #7
   10858:	0021      	movs	r1, r4
   1085a:	a808      	add	r0, sp, #32
   1085c:	f7ef fd40 	bl	2e0 <memset>
    if (at_create_param_array(p_atparams_string, &num_recvparams, 1, 3 + num_of_flags) != AT_RET_OK)
   10860:	2109      	movs	r1, #9
   10862:	a802      	add	r0, sp, #8
   10864:	1cf3      	adds	r3, r6, #3
   10866:	1809      	adds	r1, r1, r0
   10868:	b2db      	uxtb	r3, r3
   1086a:	2201      	movs	r2, #1
   1086c:	9803      	ldr	r0, [sp, #12]
   1086e:	f7f9 fd39 	bl	a2e4 <at_create_param_array>
   10872:	42a0      	cmp	r0, r4
   10874:	d001      	beq.n	1087a <at_cedrxs_nptwedrxs_common_handle_set+0x4e>
    switch (mode)
   10876:	2501      	movs	r5, #1
   10878:	e044      	b.n	10904 <at_cedrxs_nptwedrxs_common_handle_set+0xd8>
    if (at_get_uint16_param(AT_PARSE_FIRST_PARAM_POS, &mode, true) != AT_RET_OK)
   1087a:	2201      	movs	r2, #1
   1087c:	a905      	add	r1, sp, #20
   1087e:	f7f9 fe45 	bl	a50c <at_get_uint16_param>
   10882:	2800      	cmp	r0, #0
   10884:	d1f7      	bne.n	10876 <at_cedrxs_nptwedrxs_common_handle_set+0x4a>
    cause = at_get_uint16_param(AT_PARSE_SECOND_PARAM_POS, &type, true);
   10886:	2201      	movs	r2, #1
   10888:	0039      	movs	r1, r7
   1088a:	0010      	movs	r0, r2
   1088c:	f7f9 fe3e 	bl	a50c <at_get_uint16_param>
    if ((cause == AT_RET_OK) && (type == AT_CEDRXS_ACT_TYPE_NB_S1))
   10890:	2800      	cmp	r0, #0
   10892:	d104      	bne.n	1089e <at_cedrxs_nptwedrxs_common_handle_set+0x72>
   10894:	883b      	ldrh	r3, [r7, #0]
   10896:	2b05      	cmp	r3, #5
   10898:	d1ed      	bne.n	10876 <at_cedrxs_nptwedrxs_common_handle_set+0x4a>
        type_missing = false;
   1089a:	0004      	movs	r4, r0
   1089c:	e002      	b.n	108a4 <at_cedrxs_nptwedrxs_common_handle_set+0x78>
        type_missing = true;
   1089e:	2401      	movs	r4, #1
    else if (cause == AT_RET_PARAM_MISSING)
   108a0:	2803      	cmp	r0, #3
   108a2:	d1e8      	bne.n	10876 <at_cedrxs_nptwedrxs_common_handle_set+0x4a>
    if(is_nptwedrxs)
   108a4:	2e00      	cmp	r6, #0
   108a6:	d130      	bne.n	1090a <at_cedrxs_nptwedrxs_common_handle_set+0xde>
    cause = at_get_string_param(AT_PARSE_THIRD_PARAM_POS + num_of_flags, str_edrx, AT_CEDRXS_BINARY_STRING_LEN + 1, true );
   108a8:	1cb0      	adds	r0, r6, #2
   108aa:	b2c0      	uxtb	r0, r0
   108ac:	2301      	movs	r3, #1
   108ae:	2207      	movs	r2, #7
   108b0:	a906      	add	r1, sp, #24
   108b2:	f7f9 ff69 	bl	a788 <at_get_string_param>
    if ((cause != AT_RET_OK)&& (cause != AT_RET_PARAM_MISSING))
   108b6:	2800      	cmp	r0, #0
   108b8:	d13d      	bne.n	10936 <at_cedrxs_nptwedrxs_common_handle_set+0x10a>
    if ((strlen((char*)str_edrx) > 4) || (at_parse_binary_string_to_uint8(str_edrx, &edrx_value) != AT_RET_OK))
   108ba:	a806      	add	r0, sp, #24
   108bc:	f00a fd6f 	bl	1b39e <strlen>
   108c0:	2804      	cmp	r0, #4
   108c2:	d8d8      	bhi.n	10876 <at_cedrxs_nptwedrxs_common_handle_set+0x4a>
   108c4:	230a      	movs	r3, #10
   108c6:	aa02      	add	r2, sp, #8
   108c8:	189b      	adds	r3, r3, r2
   108ca:	0019      	movs	r1, r3
   108cc:	a806      	add	r0, sp, #24
   108ce:	f7ff ff8d 	bl	107ec <at_parse_binary_string_to_uint8>
   108d2:	1e05      	subs	r5, r0, #0
   108d4:	d1cf      	bne.n	10876 <at_cedrxs_nptwedrxs_common_handle_set+0x4a>
    switch (mode)
   108d6:	ab02      	add	r3, sp, #8
   108d8:	8998      	ldrh	r0, [r3, #12]
   108da:	2802      	cmp	r0, #2
   108dc:	d92e      	bls.n	1093c <at_cedrxs_nptwedrxs_common_handle_set+0x110>
   108de:	2803      	cmp	r0, #3
   108e0:	d1c9      	bne.n	10876 <at_cedrxs_nptwedrxs_common_handle_set+0x4a>
   108e2:	ab02      	add	r3, sp, #8
   108e4:	b2c0      	uxtb	r0, r0
   108e6:	7839      	ldrb	r1, [r7, #0]
   108e8:	7a9a      	ldrb	r2, [r3, #10]
    if (is_nptwedrxs)
   108ea:	2e00      	cmp	r6, #0
   108ec:	d029      	beq.n	10942 <at_cedrxs_nptwedrxs_common_handle_set+0x116>
        if (set_ptwedrxs((uint8)mode, (uint8)type, edrx_value, paging_time_window, at_set_ptwedrx_changed_callback) != NEUL_RET_OK)
   108ee:	230b      	movs	r3, #11
   108f0:	ac02      	add	r4, sp, #8
   108f2:	191b      	adds	r3, r3, r4
   108f4:	4c15      	ldr	r4, [pc, #84]	; (1094c <at_cedrxs_nptwedrxs_common_handle_set+0x120>)
   108f6:	781b      	ldrb	r3, [r3, #0]
   108f8:	9400      	str	r4, [sp, #0]
   108fa:	f00b fe1d 	bl	1c538 <set_ptwedrxs>
   108fe:	2800      	cmp	r0, #0
   10900:	d000      	beq.n	10904 <at_cedrxs_nptwedrxs_common_handle_set+0xd8>
            return AT_RET_PROGRESS_ERROR;
   10902:	2506      	movs	r5, #6
}
   10904:	0028      	movs	r0, r5
   10906:	b00b      	add	sp, #44	; 0x2c
   10908:	bdf0      	pop	{r4, r5, r6, r7, pc}
        cause = at_get_string_param(AT_PARSE_THIRD_PARAM_POS, paging_time_window_string, AT_CEDRXS_BINARY_STRING_LEN + 1, true );
   1090a:	2301      	movs	r3, #1
   1090c:	2207      	movs	r2, #7
   1090e:	a908      	add	r1, sp, #32
   10910:	2002      	movs	r0, #2
   10912:	f7f9 ff39 	bl	a788 <at_get_string_param>
        if ((cause != AT_RET_OK)&& (cause != AT_RET_PARAM_MISSING))
   10916:	2800      	cmp	r0, #0
   10918:	d001      	beq.n	1091e <at_cedrxs_nptwedrxs_common_handle_set+0xf2>
   1091a:	2803      	cmp	r0, #3
   1091c:	d1ab      	bne.n	10876 <at_cedrxs_nptwedrxs_common_handle_set+0x4a>
        if ((strlen((char*)paging_time_window_string) > 4) || (at_parse_binary_string_to_uint8(paging_time_window_string, &paging_time_window) != AT_RET_OK))
   1091e:	a808      	add	r0, sp, #32
   10920:	f00a fd3d 	bl	1b39e <strlen>
   10924:	2804      	cmp	r0, #4
   10926:	d8a6      	bhi.n	10876 <at_cedrxs_nptwedrxs_common_handle_set+0x4a>
   10928:	0029      	movs	r1, r5
   1092a:	a808      	add	r0, sp, #32
   1092c:	f7ff ff5e 	bl	107ec <at_parse_binary_string_to_uint8>
   10930:	2800      	cmp	r0, #0
   10932:	d0b9      	beq.n	108a8 <at_cedrxs_nptwedrxs_common_handle_set+0x7c>
   10934:	e79f      	b.n	10876 <at_cedrxs_nptwedrxs_common_handle_set+0x4a>
    if ((cause != AT_RET_OK)&& (cause != AT_RET_PARAM_MISSING))
   10936:	2803      	cmp	r0, #3
   10938:	d19d      	bne.n	10876 <at_cedrxs_nptwedrxs_common_handle_set+0x4a>
   1093a:	e7be      	b.n	108ba <at_cedrxs_nptwedrxs_common_handle_set+0x8e>
            if (type_missing)
   1093c:	2c00      	cmp	r4, #0
   1093e:	d0d0      	beq.n	108e2 <at_cedrxs_nptwedrxs_common_handle_set+0xb6>
   10940:	e799      	b.n	10876 <at_cedrxs_nptwedrxs_common_handle_set+0x4a>
        if (set_edrxs((uint8)mode, (uint8)type, edrx_value, at_set_edrx_changed_callback) != NEUL_RET_OK)
   10942:	4b03      	ldr	r3, [pc, #12]	; (10950 <at_cedrxs_nptwedrxs_common_handle_set+0x124>)
   10944:	f00b fddc 	bl	1c500 <set_edrxs>
   10948:	e7d9      	b.n	108fe <at_cedrxs_nptwedrxs_common_handle_set+0xd2>
   1094a:	46c0      	nop			; (mov r8, r8)
   1094c:	0000fb5b 	.word	0x0000fb5b
   10950:	0000fb4d 	.word	0x0000fb4d

00010954 <at_handle_NPTWEDRXS_cmd_set>:
{
   10954:	b510      	push	{r4, lr}
    return at_cedrxs_nptwedrxs_common_handle_set(p_atparams_string, true);
   10956:	2101      	movs	r1, #1
   10958:	f7ff ff68 	bl	1082c <at_cedrxs_nptwedrxs_common_handle_set>
}
   1095c:	bd10      	pop	{r4, pc}

0001095e <at_handle_CEDRXS_cmd_set>:
{
   1095e:	b510      	push	{r4, lr}
    return at_cedrxs_nptwedrxs_common_handle_set(p_atparams_string, false);
   10960:	2100      	movs	r1, #0
   10962:	f7ff ff63 	bl	1082c <at_cedrxs_nptwedrxs_common_handle_set>
}
   10966:	bd10      	pop	{r4, pc}

00010968 <at_handle_CPSMS_cmd_set>:
{
   10968:	b5f0      	push	{r4, r5, r6, r7, lr}
   1096a:	b08b      	sub	sp, #44	; 0x2c
   1096c:	0004      	movs	r4, r0
    uint8               requested_str[2][AT_8BIT_TIME_STR_LEN + 1] = {{0},{0}};
   1096e:	2212      	movs	r2, #18
   10970:	2100      	movs	r1, #0
   10972:	a805      	add	r0, sp, #20
   10974:	f7ef fcb4 	bl	2e0 <memset>
    uint16              requested[2] = {NEUL_CPSMS_UNUSED_TIME_VALUE, NEUL_CPSMS_UNUSED_TIME_VALUE};
   10978:	4928      	ldr	r1, [pc, #160]	; (10a1c <at_handle_CPSMS_cmd_set+0xb4>)
   1097a:	ad04      	add	r5, sp, #16
   1097c:	2204      	movs	r2, #4
   1097e:	3124      	adds	r1, #36	; 0x24
   10980:	0028      	movs	r0, r5
   10982:	f7ef fc35 	bl	1f0 <memcpy>
    if (at_create_param_array(p_atparams_string, &num_recvparams, 1, 5) != AT_RET_OK)
   10986:	2305      	movs	r3, #5
   10988:	a902      	add	r1, sp, #8
   1098a:	2201      	movs	r2, #1
   1098c:	18c9      	adds	r1, r1, r3
   1098e:	0020      	movs	r0, r4
   10990:	f7f9 fca8 	bl	a2e4 <at_create_param_array>
   10994:	2800      	cmp	r0, #0
   10996:	d003      	beq.n	109a0 <at_handle_CPSMS_cmd_set+0x38>
       return AT_RET_SYNTAX_ERROR;
   10998:	2701      	movs	r7, #1
}
   1099a:	0038      	movs	r0, r7
   1099c:	b00b      	add	sp, #44	; 0x2c
   1099e:	bdf0      	pop	{r4, r5, r6, r7, pc}
    cause = at_get_uint16_param(AT_PARSE_FIRST_PARAM_POS, &mode, true);
   109a0:	ab02      	add	r3, sp, #8
   109a2:	2201      	movs	r2, #1
   109a4:	1d99      	adds	r1, r3, #6
   109a6:	f7f9 fdb1 	bl	a50c <at_get_uint16_param>
    for (uint8 i = AT_PARSE_FOURTH_PARAM_POS; i < num_recvparams; i++)
   109aa:	2403      	movs	r4, #3
    cause = at_get_uint16_param(AT_PARSE_FIRST_PARAM_POS, &mode, true);
   109ac:	1e07      	subs	r7, r0, #0
    if (cause != AT_RET_OK)
   109ae:	d1f3      	bne.n	10998 <at_handle_CPSMS_cmd_set+0x30>
   109b0:	1ee1      	subs	r1, r4, #3
   109b2:	b2cb      	uxtb	r3, r1
   109b4:	9301      	str	r3, [sp, #4]
    for (uint8 i = AT_PARSE_FOURTH_PARAM_POS; i < num_recvparams; i++)
   109b6:	ab02      	add	r3, sp, #8
   109b8:	3305      	adds	r3, #5
   109ba:	781b      	ldrb	r3, [r3, #0]
   109bc:	42a3      	cmp	r3, r4
   109be:	d80c      	bhi.n	109da <at_handle_CPSMS_cmd_set+0x72>
    if ((mode != NEUL_CPSMS_MODE_ENABLE) && (mode != NEUL_CPSMS_MODE_DISABLE) && (mode != NEUL_CPSMS_MODE_DISABLE_AND_RESET))
   109c0:	ab02      	add	r3, sp, #8
   109c2:	88d8      	ldrh	r0, [r3, #6]
   109c4:	2802      	cmp	r0, #2
   109c6:	d8e7      	bhi.n	10998 <at_handle_CPSMS_cmd_set+0x30>
    if (set_power_saving_mode((uint8)mode, requested[0], requested[1]) != NEUL_RET_OK)
   109c8:	886a      	ldrh	r2, [r5, #2]
   109ca:	8829      	ldrh	r1, [r5, #0]
   109cc:	b2c0      	uxtb	r0, r0
   109ce:	f00b fd5b 	bl	1c488 <set_power_saving_mode>
   109d2:	2800      	cmp	r0, #0
   109d4:	d0e1      	beq.n	1099a <at_handle_CPSMS_cmd_set+0x32>
        return AT_RET_PROGRESS_ERROR;
   109d6:	2706      	movs	r7, #6
   109d8:	e7df      	b.n	1099a <at_handle_CPSMS_cmd_set+0x32>
        cause = at_get_string_param(i, requested_str[index], AT_8BIT_TIME_STR_LEN + 1, true);
   109da:	2609      	movs	r6, #9
   109dc:	9b01      	ldr	r3, [sp, #4]
   109de:	2209      	movs	r2, #9
   109e0:	435e      	muls	r6, r3
   109e2:	ab05      	add	r3, sp, #20
   109e4:	199e      	adds	r6, r3, r6
   109e6:	0031      	movs	r1, r6
   109e8:	2301      	movs	r3, #1
   109ea:	0020      	movs	r0, r4
   109ec:	f7f9 fecc 	bl	a788 <at_get_string_param>
        if(cause == AT_RET_OK)
   109f0:	2800      	cmp	r0, #0
   109f2:	d110      	bne.n	10a16 <at_handle_CPSMS_cmd_set+0xae>
            requested[index] = 0;
   109f4:	9b01      	ldr	r3, [sp, #4]
   109f6:	0059      	lsls	r1, r3, #1
   109f8:	5268      	strh	r0, [r5, r1]
            cause = at_parse_binary_string_to_uint8(requested_str[index], (uint8*)&requested[index]);
   109fa:	1869      	adds	r1, r5, r1
   109fc:	0030      	movs	r0, r6
   109fe:	f7ff fef5 	bl	107ec <at_parse_binary_string_to_uint8>
            if(cause != AT_RET_OK)
   10a02:	2800      	cmp	r0, #0
   10a04:	d1c8      	bne.n	10998 <at_handle_CPSMS_cmd_set+0x30>
            if(strlen((char*)(requested_str[index])) != AT_8BIT_TIME_STR_LEN)
   10a06:	0030      	movs	r0, r6
   10a08:	f00a fcc9 	bl	1b39e <strlen>
   10a0c:	2808      	cmp	r0, #8
   10a0e:	d1c3      	bne.n	10998 <at_handle_CPSMS_cmd_set+0x30>
    for (uint8 i = AT_PARSE_FOURTH_PARAM_POS; i < num_recvparams; i++)
   10a10:	3401      	adds	r4, #1
   10a12:	b2e4      	uxtb	r4, r4
   10a14:	e7cc      	b.n	109b0 <at_handle_CPSMS_cmd_set+0x48>
        else if(cause == AT_RET_PARAM_MISSING)
   10a16:	2803      	cmp	r0, #3
   10a18:	d0fa      	beq.n	10a10 <at_handle_CPSMS_cmd_set+0xa8>
   10a1a:	e7bd      	b.n	10998 <at_handle_CPSMS_cmd_set+0x30>
   10a1c:	00022a78 	.word	0x00022a78

00010a20 <at_handle_NCIDSTATUS_cmd_set>:
    cause = at_create_param_array(p_atparams_string, &num_recvparams, 1, 1);
   10a20:	2301      	movs	r3, #1
   10a22:	210b      	movs	r1, #11
{
   10a24:	b5f0      	push	{r4, r5, r6, r7, lr}
   10a26:	b085      	sub	sp, #20
    cause = at_create_param_array(p_atparams_string, &num_recvparams, 1, 1);
   10a28:	001a      	movs	r2, r3
   10a2a:	4469      	add	r1, sp
   10a2c:	f7f9 fc5a 	bl	a2e4 <at_create_param_array>
   10a30:	1e04      	subs	r4, r0, #0
    if(cause != AT_RET_OK)
   10a32:	d120      	bne.n	10a76 <at_handle_NCIDSTATUS_cmd_set+0x56>
    cause = at_get_uint8_param(AT_PARSE_FIRST_PARAM_POS, &cid, true);
   10a34:	ad03      	add	r5, sp, #12
   10a36:	2201      	movs	r2, #1
   10a38:	0029      	movs	r1, r5
   10a3a:	f7f9 fde7 	bl	a60c <at_get_uint8_param>
        return AT_RET_SYNTAX_ERROR;
   10a3e:	3401      	adds	r4, #1
    if(cause != AT_RET_OK)
   10a40:	2800      	cmp	r0, #0
   10a42:	d118      	bne.n	10a76 <at_handle_NCIDSTATUS_cmd_set+0x56>
    if (cid > AT_MAX_CID)
   10a44:	7828      	ldrb	r0, [r5, #0]
   10a46:	280a      	cmp	r0, #10
   10a48:	d815      	bhi.n	10a76 <at_handle_NCIDSTATUS_cmd_set+0x56>
    result = get_cid_status(cid, &status, &backoff);
   10a4a:	270e      	movs	r7, #14
   10a4c:	230d      	movs	r3, #13
   10a4e:	446f      	add	r7, sp
   10a50:	446b      	add	r3, sp
   10a52:	003a      	movs	r2, r7
   10a54:	0019      	movs	r1, r3
   10a56:	f00c f851 	bl	1cafc <get_cid_status>
   10a5a:	1e06      	subs	r6, r0, #0
    if (result == NEUL_RET_OK)
   10a5c:	d107      	bne.n	10a6e <at_handle_NCIDSTATUS_cmd_set+0x4e>
        app_at_send_socket_or_cid_status_string(AT_CMD_NCIDSTATUS_RSP_PREFIX, cid, status, backoff, true);
   10a5e:	466a      	mov	r2, sp
   10a60:	883b      	ldrh	r3, [r7, #0]
   10a62:	7b52      	ldrb	r2, [r2, #13]
   10a64:	7829      	ldrb	r1, [r5, #0]
   10a66:	4805      	ldr	r0, [pc, #20]	; (10a7c <at_handle_NCIDSTATUS_cmd_set+0x5c>)
   10a68:	9400      	str	r4, [sp, #0]
   10a6a:	f7fa fca1 	bl	b3b0 <app_at_send_socket_or_cid_status_string>
    return at_parse_convert_neul_result(result);
   10a6e:	0030      	movs	r0, r6
   10a70:	f7f9 fc0e 	bl	a290 <at_parse_convert_neul_result>
   10a74:	0004      	movs	r4, r0
}
   10a76:	0020      	movs	r0, r4
   10a78:	b005      	add	sp, #20
   10a7a:	bdf0      	pop	{r4, r5, r6, r7, pc}
   10a7c:	00023ac5 	.word	0x00023ac5

00010a80 <at_handle_NPSMR_cmd_set>:
{
   10a80:	b513      	push	{r0, r1, r4, lr}
    cause = at_create_param_array(p_atparams_string, &num_recvparams, 1, 1);
   10a82:	2301      	movs	r3, #1
   10a84:	4669      	mov	r1, sp
   10a86:	001a      	movs	r2, r3
   10a88:	3105      	adds	r1, #5
   10a8a:	f7f9 fc2b 	bl	a2e4 <at_create_param_array>
    if(cause != AT_RET_OK)
   10a8e:	2800      	cmp	r0, #0
   10a90:	d10c      	bne.n	10aac <at_handle_NPSMR_cmd_set+0x2c>
    cause = at_get_uint16_param(AT_PARSE_FIRST_PARAM_POS, &npsmr_mode, true);
   10a92:	466b      	mov	r3, sp
   10a94:	1d9c      	adds	r4, r3, #6
   10a96:	2201      	movs	r2, #1
   10a98:	0021      	movs	r1, r4
   10a9a:	f7f9 fd37 	bl	a50c <at_get_uint16_param>
    if(cause != AT_RET_OK)
   10a9e:	2800      	cmp	r0, #0
   10aa0:	d105      	bne.n	10aae <at_handle_NPSMR_cmd_set+0x2e>
    if((npsmr_mode != NPSMR_MODE_ENUM_DISABLE_REPORT)  &&  (npsmr_mode != NPSMR_MODE_ENUM_ENABLE_REPORT))
   10aa2:	8823      	ldrh	r3, [r4, #0]
   10aa4:	2b01      	cmp	r3, #1
   10aa6:	d802      	bhi.n	10aae <at_handle_NPSMR_cmd_set+0x2e>
    app_at_state_info.npsmr_mode = (NPSMR_MODE_ENUM)npsmr_mode;
   10aa8:	4a02      	ldr	r2, [pc, #8]	; (10ab4 <at_handle_NPSMR_cmd_set+0x34>)
   10aaa:	7113      	strb	r3, [r2, #4]
}
   10aac:	bd16      	pop	{r1, r2, r4, pc}
        return AT_RET_SYNTAX_ERROR;
   10aae:	2001      	movs	r0, #1
   10ab0:	e7fc      	b.n	10aac <at_handle_NPSMR_cmd_set+0x2c>
   10ab2:	46c0      	nop			; (mov r8, r8)
   10ab4:	010024c2 	.word	0x010024c2

00010ab8 <at_handle_NUICC_cmd_set>:
{
   10ab8:	b513      	push	{r0, r1, r4, lr}
    cause = at_create_param_array(p_atparams_string, &num_recvparams, 1, 1);
   10aba:	2301      	movs	r3, #1
   10abc:	4669      	mov	r1, sp
   10abe:	001a      	movs	r2, r3
   10ac0:	3105      	adds	r1, #5
   10ac2:	f7f9 fc0f 	bl	a2e4 <at_create_param_array>
    if(cause != AT_RET_OK)
   10ac6:	2800      	cmp	r0, #0
   10ac8:	d111      	bne.n	10aee <at_handle_NUICC_cmd_set+0x36>
    cause = at_get_uint16_param(AT_PARSE_FIRST_PARAM_POS, &status, true);
   10aca:	466b      	mov	r3, sp
   10acc:	1d9c      	adds	r4, r3, #6
   10ace:	2201      	movs	r2, #1
   10ad0:	0021      	movs	r1, r4
   10ad2:	f7f9 fd1b 	bl	a50c <at_get_uint16_param>
   10ad6:	0003      	movs	r3, r0
        return AT_RET_SYNTAX_ERROR;
   10ad8:	2001      	movs	r0, #1
    if(cause != AT_RET_OK)
   10ada:	2b00      	cmp	r3, #0
   10adc:	d107      	bne.n	10aee <at_handle_NUICC_cmd_set+0x36>
    if(status == NEUL_UICC_FREE || status == NEUL_UICC_RESTART)
   10ade:	8823      	ldrh	r3, [r4, #0]
   10ae0:	4283      	cmp	r3, r0
   10ae2:	d804      	bhi.n	10aee <at_handle_NUICC_cmd_set+0x36>
        result = uicc_status_control((NEUL_UICC_STATUS)status);
   10ae4:	b2d8      	uxtb	r0, r3
   10ae6:	f001 ff11 	bl	1290c <uicc_status_control>
    return at_parse_convert_neul_result(result);
   10aea:	f7f9 fbd1 	bl	a290 <at_parse_convert_neul_result>
}
   10aee:	bd16      	pop	{r1, r2, r4, pc}

00010af0 <at_handle_CCHC_cmd_set>:
{
   10af0:	b513      	push	{r0, r1, r4, lr}
    if (at_create_param_array(p_atparams_string, &num_recvparams, 1, 1) != AT_RET_OK)
   10af2:	2301      	movs	r3, #1
   10af4:	4669      	mov	r1, sp
   10af6:	001a      	movs	r2, r3
   10af8:	3106      	adds	r1, #6
   10afa:	f7f9 fbf3 	bl	a2e4 <at_create_param_array>
       return AT_RET_SYNTAX_ERROR;
   10afe:	2201      	movs	r2, #1
    if (at_create_param_array(p_atparams_string, &num_recvparams, 1, 1) != AT_RET_OK)
   10b00:	2800      	cmp	r0, #0
   10b02:	d110      	bne.n	10b26 <at_handle_CCHC_cmd_set+0x36>
    cause = at_get_uint8_param(AT_PARSE_FIRST_PARAM_POS, &sessionid, true);
   10b04:	466b      	mov	r3, sp
   10b06:	1ddc      	adds	r4, r3, #7
   10b08:	0021      	movs	r1, r4
   10b0a:	f7f9 fd7f 	bl	a60c <at_get_uint8_param>
   10b0e:	1e02      	subs	r2, r0, #0
    if (cause != AT_RET_OK)
   10b10:	d109      	bne.n	10b26 <at_handle_CCHC_cmd_set+0x36>
    if ((sessionid == FIRST_CHANNEL_NB) || (sessionid > LAST_CHANNEL_NB))
   10b12:	7820      	ldrb	r0, [r4, #0]
        return AT_RET_SYNTAX_ERROR;
   10b14:	3201      	adds	r2, #1
    if ((sessionid == FIRST_CHANNEL_NB) || (sessionid > LAST_CHANNEL_NB))
   10b16:	1e43      	subs	r3, r0, #1
   10b18:	2b02      	cmp	r3, #2
   10b1a:	d804      	bhi.n	10b26 <at_handle_CCHC_cmd_set+0x36>
    result = close_logical_channel(sessionid);
   10b1c:	f001 febe 	bl	1289c <close_logical_channel>
    return at_parse_convert_neul_result(result);
   10b20:	f7f9 fbb6 	bl	a290 <at_parse_convert_neul_result>
   10b24:	0002      	movs	r2, r0
}
   10b26:	0010      	movs	r0, r2
   10b28:	bd16      	pop	{r1, r2, r4, pc}
	...

00010b2c <nrdtest_callback>:
{
   10b2c:	b5f0      	push	{r4, r5, r6, r7, lr}
   10b2e:	000e      	movs	r6, r1
   10b30:	b08f      	sub	sp, #60	; 0x3c
   10b32:	0015      	movs	r5, r2
    if ((RADIO_TEST_RET)retcode ==  RADIO_TEST_RET_NOT_COMPLETE)
   10b34:	2804      	cmp	r0, #4
   10b36:	d124      	bne.n	10b82 <nrdtest_callback+0x56>
        if (length != 0)
   10b38:	2900      	cmp	r1, #0
   10b3a:	d00f      	beq.n	10b5c <nrdtest_callback+0x30>
            rsp_len = (uint16)snprintf(rsp_string, AT_MAX_NRDTEST_RSP_LEN, "%d,", length);
   10b3c:	000b      	movs	r3, r1
   10b3e:	4a15      	ldr	r2, [pc, #84]	; (10b94 <nrdtest_callback+0x68>)
   10b40:	2134      	movs	r1, #52	; 0x34
   10b42:	a801      	add	r0, sp, #4
   10b44:	f009 fe92 	bl	1a86c <snprintf>
   10b48:	2734      	movs	r7, #52	; 0x34
   10b4a:	b284      	uxth	r4, r0
   10b4c:	19ae      	adds	r6, r5, r6
            for (loop = 0; (loop < length) &&(rsp_len<AT_MAX_NRDTEST_RSP_LEN) ; loop++)
   10b4e:	42ae      	cmp	r6, r5
   10b50:	d001      	beq.n	10b56 <nrdtest_callback+0x2a>
   10b52:	2c33      	cmp	r4, #51	; 0x33
   10b54:	d904      	bls.n	10b60 <nrdtest_callback+0x34>
            app_at_send_at_rsp_string_lines_with_claim_and_log(rsp_string);
   10b56:	a801      	add	r0, sp, #4
   10b58:	f7f8 fd44 	bl	95e4 <app_at_send_at_rsp_string_lines_with_claim_and_log>
}
   10b5c:	b00f      	add	sp, #60	; 0x3c
   10b5e:	bdf0      	pop	{r4, r5, r6, r7, pc}
                if (data[loop] == 0)
   10b60:	782b      	ldrb	r3, [r5, #0]
   10b62:	aa01      	add	r2, sp, #4
   10b64:	1910      	adds	r0, r2, r4
   10b66:	1b39      	subs	r1, r7, r4
   10b68:	2b00      	cmp	r3, #0
   10b6a:	d106      	bne.n	10b7a <nrdtest_callback+0x4e>
                    rsp_len += (uint16)snprintf(rsp_string + rsp_len, AT_MAX_NRDTEST_RSP_LEN - rsp_len, "00");
   10b6c:	4a0a      	ldr	r2, [pc, #40]	; (10b98 <nrdtest_callback+0x6c>)
   10b6e:	f009 fe7d 	bl	1a86c <snprintf>
                    rsp_len += (uint16)snprintf(rsp_string + rsp_len, AT_MAX_NRDTEST_RSP_LEN - rsp_len, "%02x", data[loop]);
   10b72:	1824      	adds	r4, r4, r0
   10b74:	b2a4      	uxth	r4, r4
   10b76:	3501      	adds	r5, #1
   10b78:	e7e9      	b.n	10b4e <nrdtest_callback+0x22>
   10b7a:	4a08      	ldr	r2, [pc, #32]	; (10b9c <nrdtest_callback+0x70>)
   10b7c:	f009 fe76 	bl	1a86c <snprintf>
   10b80:	e7f7      	b.n	10b72 <nrdtest_callback+0x46>
    else if (((RADIO_TEST_RET)retcode == RADIO_TEST_RET_OK) || ((RADIO_TEST_RET)retcode == RADIO_TEST_RET_MODE_ALREADY_ENABLED))
   10b82:	2302      	movs	r3, #2
   10b84:	4398      	bics	r0, r3
   10b86:	d102      	bne.n	10b8e <nrdtest_callback+0x62>
        app_at_send_callback_response(AT_RET_PROGRESS_ERROR);
   10b88:	f7f7 fc9e 	bl	84c8 <app_at_send_callback_response>
}
   10b8c:	e7e6      	b.n	10b5c <nrdtest_callback+0x30>
        app_at_send_callback_response(AT_RET_PROGRESS_ERROR);
   10b8e:	2006      	movs	r0, #6
   10b90:	e7fa      	b.n	10b88 <nrdtest_callback+0x5c>
   10b92:	46c0      	nop			; (mov r8, r8)
   10b94:	000234e4 	.word	0x000234e4
   10b98:	000254d4 	.word	0x000254d4
   10b9c:	0002393f 	.word	0x0002393f

00010ba0 <at_handle_NCPCDPR_cmd_set>:
{
   10ba0:	b537      	push	{r0, r1, r2, r4, r5, lr}
    cause = at_create_param_array(p_atparams_string, &num_recvparams, 2, 2);
   10ba2:	2302      	movs	r3, #2
   10ba4:	4669      	mov	r1, sp
   10ba6:	001a      	movs	r2, r3
   10ba8:	3103      	adds	r1, #3
   10baa:	f7f9 fb9b 	bl	a2e4 <at_create_param_array>
    if(cause != AT_RET_OK)
   10bae:	2800      	cmp	r0, #0
   10bb0:	d10a      	bne.n	10bc8 <at_handle_NCPCDPR_cmd_set+0x28>
    cause = at_get_uint16_param(AT_PARSE_FIRST_PARAM_POS, &param_item, true);
   10bb2:	ac01      	add	r4, sp, #4
   10bb4:	2201      	movs	r2, #1
   10bb6:	0021      	movs	r1, r4
   10bb8:	f7f9 fca8 	bl	a50c <at_get_uint16_param>
    if(cause != AT_RET_OK)
   10bbc:	2800      	cmp	r0, #0
   10bbe:	d103      	bne.n	10bc8 <at_handle_NCPCDPR_cmd_set+0x28>
    if (param_item >= NUM_PDP_CONTEXT_DYNAMIC_PARAM)
   10bc0:	8823      	ldrh	r3, [r4, #0]
   10bc2:	2b01      	cmp	r3, #1
   10bc4:	d901      	bls.n	10bca <at_handle_NCPCDPR_cmd_set+0x2a>
        return AT_RET_SYNTAX_ERROR;
   10bc6:	2001      	movs	r0, #1
}
   10bc8:	bd3e      	pop	{r1, r2, r3, r4, r5, pc}
    cause = at_get_uint16_param(AT_PARSE_SECOND_PARAM_POS, &state, true);
   10bca:	466b      	mov	r3, sp
   10bcc:	2201      	movs	r2, #1
   10bce:	1d9d      	adds	r5, r3, #6
   10bd0:	0029      	movs	r1, r5
   10bd2:	0010      	movs	r0, r2
   10bd4:	f7f9 fc9a 	bl	a50c <at_get_uint16_param>
    if(cause != AT_RET_OK)
   10bd8:	2800      	cmp	r0, #0
   10bda:	d1f5      	bne.n	10bc8 <at_handle_NCPCDPR_cmd_set+0x28>
    if (state != 0 && state != 1)
   10bdc:	8829      	ldrh	r1, [r5, #0]
   10bde:	2901      	cmp	r1, #1
   10be0:	d8f1      	bhi.n	10bc6 <at_handle_NCPCDPR_cmd_set+0x26>
    result = set_pdp_context_dynamic_param_request_state((PDP_CONTEXT_DYNAMIC_PARAM)param_item, (bool)state);
   10be2:	2301      	movs	r3, #1
   10be4:	7820      	ldrb	r0, [r4, #0]
   10be6:	4019      	ands	r1, r3
   10be8:	f00b feb5 	bl	1c956 <set_pdp_context_dynamic_param_request_state>
    return at_parse_convert_neul_result(result);
   10bec:	f7f9 fb50 	bl	a290 <at_parse_convert_neul_result>
   10bf0:	e7ea      	b.n	10bc8 <at_handle_NCPCDPR_cmd_set+0x28>
	...

00010bf4 <at_handle_NIPINFO_cmd_set>:
{
   10bf4:	b537      	push	{r0, r1, r2, r4, r5, lr}
    cause = at_create_param_array(p_atparams_string, &num_recvparams, 1, 1);
   10bf6:	2301      	movs	r3, #1
   10bf8:	4669      	mov	r1, sp
   10bfa:	001a      	movs	r2, r3
   10bfc:	3105      	adds	r1, #5
   10bfe:	f7f9 fb71 	bl	a2e4 <at_create_param_array>
   10c02:	1e04      	subs	r4, r0, #0
    if(cause != AT_RET_OK)
   10c04:	d112      	bne.n	10c2c <at_handle_NIPINFO_cmd_set+0x38>
    cause = at_get_uint16_param(AT_PARSE_FIRST_PARAM_POS, &mode, true);
   10c06:	466b      	mov	r3, sp
   10c08:	1d9d      	adds	r5, r3, #6
   10c0a:	2201      	movs	r2, #1
   10c0c:	0029      	movs	r1, r5
   10c0e:	f7f9 fc7d 	bl	a50c <at_get_uint16_param>
   10c12:	1e04      	subs	r4, r0, #0
    if(cause != AT_RET_OK)
   10c14:	d10a      	bne.n	10c2c <at_handle_NIPINFO_cmd_set+0x38>
    if (mode > NIPINFO_MODE_ENABLE_UNSOLICITED_RESULT)
   10c16:	882b      	ldrh	r3, [r5, #0]
   10c18:	2b01      	cmp	r3, #1
   10c1a:	d809      	bhi.n	10c30 <at_handle_NIPINFO_cmd_set+0x3c>
    else if (mode == NIPINFO_MODE_DISABLE_UNSOLICITED_RESULT)
   10c1c:	2b00      	cmp	r3, #0
   10c1e:	d000      	beq.n	10c22 <at_handle_NIPINFO_cmd_set+0x2e>
        (void)set_ip_info_callback(nipinfo_callback);
   10c20:	4804      	ldr	r0, [pc, #16]	; (10c34 <at_handle_NIPINFO_cmd_set+0x40>)
   10c22:	f00b fe7d 	bl	1c920 <set_ip_info_callback>
    app_at_ip_info = (NIPINFO_MODE_ENUM)mode;
   10c26:	882a      	ldrh	r2, [r5, #0]
   10c28:	4b03      	ldr	r3, [pc, #12]	; (10c38 <at_handle_NIPINFO_cmd_set+0x44>)
   10c2a:	701a      	strb	r2, [r3, #0]
}
   10c2c:	0020      	movs	r0, r4
   10c2e:	bd3e      	pop	{r1, r2, r3, r4, r5, pc}
        return AT_RET_SYNTAX_ERROR;
   10c30:	2401      	movs	r4, #1
   10c32:	e7fb      	b.n	10c2c <at_handle_NIPINFO_cmd_set+0x38>
   10c34:	0000cb1d 	.word	0x0000cb1d
   10c38:	010024c1 	.word	0x010024c1

00010c3c <at_handle_NPOWERCLASS_cmd_set>:
{
   10c3c:	b537      	push	{r0, r1, r2, r4, r5, lr}
    cause = at_create_param_array(p_atparams_string, &num_recvparams, 2, 2);
   10c3e:	2302      	movs	r3, #2
   10c40:	4669      	mov	r1, sp
   10c42:	001a      	movs	r2, r3
   10c44:	3103      	adds	r1, #3
   10c46:	f7f9 fb4d 	bl	a2e4 <at_create_param_array>
    if (cause != AT_RET_OK)
   10c4a:	2800      	cmp	r0, #0
   10c4c:	d11c      	bne.n	10c88 <at_handle_NPOWERCLASS_cmd_set+0x4c>
    cause = at_get_uint16_param(AT_PARSE_FIRST_PARAM_POS, &band, true);
   10c4e:	ac01      	add	r4, sp, #4
   10c50:	2201      	movs	r2, #1
   10c52:	0021      	movs	r1, r4
   10c54:	f7f9 fc5a 	bl	a50c <at_get_uint16_param>
    if (cause != AT_RET_OK)
   10c58:	2800      	cmp	r0, #0
   10c5a:	d115      	bne.n	10c88 <at_handle_NPOWERCLASS_cmd_set+0x4c>
    cause = at_get_uint16_param(AT_PARSE_SECOND_PARAM_POS, &power_class, true);
   10c5c:	466b      	mov	r3, sp
   10c5e:	2201      	movs	r2, #1
   10c60:	1d9d      	adds	r5, r3, #6
   10c62:	0029      	movs	r1, r5
   10c64:	0010      	movs	r0, r2
   10c66:	f7f9 fc51 	bl	a50c <at_get_uint16_param>
    if (cause != AT_RET_OK)
   10c6a:	2800      	cmp	r0, #0
   10c6c:	d10c      	bne.n	10c88 <at_handle_NPOWERCLASS_cmd_set+0x4c>
    if (power_class != AT_CMD_UE_POWER_CLASS_3 && power_class != AT_CMD_UE_POWER_CLASS_5 && power_class != AT_CMD_UE_POWER_CLASS_6)
   10c6e:	8829      	ldrh	r1, [r5, #0]
   10c70:	2903      	cmp	r1, #3
   10c72:	d003      	beq.n	10c7c <at_handle_NPOWERCLASS_cmd_set+0x40>
   10c74:	1f4b      	subs	r3, r1, #5
        return AT_RET_SYNTAX_ERROR;
   10c76:	3001      	adds	r0, #1
    if (power_class != AT_CMD_UE_POWER_CLASS_3 && power_class != AT_CMD_UE_POWER_CLASS_5 && power_class != AT_CMD_UE_POWER_CLASS_6)
   10c78:	4283      	cmp	r3, r0
   10c7a:	d805      	bhi.n	10c88 <at_handle_NPOWERCLASS_cmd_set+0x4c>
    result = set_power_band_class((uint8)band, (uint8)power_class);
   10c7c:	b2c9      	uxtb	r1, r1
   10c7e:	7820      	ldrb	r0, [r4, #0]
   10c80:	f00b fdec 	bl	1c85c <set_power_band_class>
    return at_parse_convert_neul_result(result);
   10c84:	f7f9 fb04 	bl	a290 <at_parse_convert_neul_result>
}
   10c88:	bd3e      	pop	{r1, r2, r3, r4, r5, pc}
	...

00010c8c <at_common_handle_non_ip_send_data_parse.part.15>:
static AT_RET at_common_handle_non_ip_send_data_parse(uint8 *p_atparams_string, bool is_cp_only)
   10c8c:	b5f0      	push	{r4, r5, r6, r7, lr}
   10c8e:	b089      	sub	sp, #36	; 0x24
    cause = at_get_uint16_param(AT_PARSE_FIRST_PARAM_POS, &cid, true);
   10c90:	ab02      	add	r3, sp, #8
   10c92:	1d9d      	adds	r5, r3, #6
static AT_RET at_common_handle_non_ip_send_data_parse(uint8 *p_atparams_string, bool is_cp_only)
   10c94:	9001      	str	r0, [sp, #4]
    cause = at_get_uint16_param(AT_PARSE_FIRST_PARAM_POS, &cid, true);
   10c96:	2201      	movs	r2, #1
   10c98:	0029      	movs	r1, r5
   10c9a:	2000      	movs	r0, #0
   10c9c:	f7f9 fc36 	bl	a50c <at_get_uint16_param>
    if (cause != AT_RET_OK)
   10ca0:	2800      	cmp	r0, #0
   10ca2:	d003      	beq.n	10cac <at_common_handle_non_ip_send_data_parse.part.15+0x20>
        return AT_RET_SYNTAX_ERROR;
   10ca4:	2401      	movs	r4, #1
}
   10ca6:	0020      	movs	r0, r4
   10ca8:	b009      	add	sp, #36	; 0x24
   10caa:	bdf0      	pop	{r4, r5, r6, r7, pc}
    if(cid > AT_MAX_CID)
   10cac:	882b      	ldrh	r3, [r5, #0]
       return AT_RET_CID_INVALID;
   10cae:	2411      	movs	r4, #17
    if(cid > AT_MAX_CID)
   10cb0:	2b0a      	cmp	r3, #10
   10cb2:	d8f8      	bhi.n	10ca6 <at_common_handle_non_ip_send_data_parse.part.15+0x1a>
    cause = at_get_uint16_param(AT_PARSE_SECOND_PARAM_POS, &length, true);
   10cb4:	2201      	movs	r2, #1
   10cb6:	a904      	add	r1, sp, #16
   10cb8:	0010      	movs	r0, r2
   10cba:	f7f9 fc27 	bl	a50c <at_get_uint16_param>
    if (cause != AT_RET_OK)
   10cbe:	2800      	cmp	r0, #0
   10cc0:	d1f0      	bne.n	10ca4 <at_common_handle_non_ip_send_data_parse.part.15+0x18>
    cause = at_get_hexstring_param(AT_PARSE_THIRD_PARAM_POS, &data_string, &data_string_len, true);
   10cc2:	260a      	movs	r6, #10
   10cc4:	ab02      	add	r3, sp, #8
   10cc6:	18f6      	adds	r6, r6, r3
   10cc8:	0032      	movs	r2, r6
   10cca:	2301      	movs	r3, #1
   10ccc:	a907      	add	r1, sp, #28
   10cce:	3002      	adds	r0, #2
   10cd0:	f7f9 fdac 	bl	a82c <at_get_hexstring_param>
   10cd4:	1e04      	subs	r4, r0, #0
    if (cause != AT_RET_OK)
   10cd6:	d1e6      	bne.n	10ca6 <at_common_handle_non_ip_send_data_parse.part.15+0x1a>
    if (app_at_get_non_ip_mtu_size(&non_ip_mtu_size) != AT_RET_OK)
   10cd8:	af06      	add	r7, sp, #24
   10cda:	0038      	movs	r0, r7
   10cdc:	f7f8 fa6a 	bl	91b4 <app_at_get_non_ip_mtu_size>
   10ce0:	1e04      	subs	r4, r0, #0
   10ce2:	d001      	beq.n	10ce8 <at_common_handle_non_ip_send_data_parse.part.15+0x5c>
        return AT_RET_PROGRESS_ERROR;
   10ce4:	2406      	movs	r4, #6
   10ce6:	e7de      	b.n	10ca6 <at_common_handle_non_ip_send_data_parse.part.15+0x1a>
    if ((length > non_ip_mtu_size)||(length * 2 != data_string_len))
   10ce8:	ab02      	add	r3, sp, #8
   10cea:	891a      	ldrh	r2, [r3, #8]
   10cec:	883b      	ldrh	r3, [r7, #0]
   10cee:	4293      	cmp	r3, r2
   10cf0:	d3d8      	bcc.n	10ca4 <at_common_handle_non_ip_send_data_parse.part.15+0x18>
   10cf2:	8833      	ldrh	r3, [r6, #0]
   10cf4:	0052      	lsls	r2, r2, #1
   10cf6:	429a      	cmp	r2, r3
   10cf8:	d1d4      	bne.n	10ca4 <at_common_handle_non_ip_send_data_parse.part.15+0x18>
    if (at_parse_buf_hex_to_uint8(data_string, data_string, (uint16)(length * 2)) == false)
   10cfa:	9907      	ldr	r1, [sp, #28]
   10cfc:	b292      	uxth	r2, r2
   10cfe:	0008      	movs	r0, r1
   10d00:	f7f9 fa3f 	bl	a182 <at_parse_buf_hex_to_uint8>
   10d04:	2800      	cmp	r0, #0
   10d06:	d0cd      	beq.n	10ca4 <at_common_handle_non_ip_send_data_parse.part.15+0x18>
    cause = at_get_uint16_param(AT_PARSE_FOURTH_PARAM_POS, &rai, true);
   10d08:	ae05      	add	r6, sp, #20
   10d0a:	2201      	movs	r2, #1
   10d0c:	0031      	movs	r1, r6
   10d0e:	2003      	movs	r0, #3
   10d10:	f7f9 fbfc 	bl	a50c <at_get_uint16_param>
    if (cause != AT_RET_OK)
   10d14:	2800      	cmp	r0, #0
   10d16:	d047      	beq.n	10da8 <at_common_handle_non_ip_send_data_parse.part.15+0x11c>
        rai = AT_CSODCP_RAI_DEFAULT_VALUE;
   10d18:	8034      	strh	r4, [r6, #0]
    cause = at_get_uint16_param(AT_PARSE_FIFTH_PARAM_POS, &data_type, true);
   10d1a:	270e      	movs	r7, #14
   10d1c:	ab02      	add	r3, sp, #8
   10d1e:	18ff      	adds	r7, r7, r3
   10d20:	2201      	movs	r2, #1
   10d22:	0039      	movs	r1, r7
   10d24:	2004      	movs	r0, #4
   10d26:	f7f9 fbf1 	bl	a50c <at_get_uint16_param>
    if(cause != AT_RET_OK)
   10d2a:	2800      	cmp	r0, #0
   10d2c:	d040      	beq.n	10db0 <at_common_handle_non_ip_send_data_parse.part.15+0x124>
       data_type = AT_CSODCP_DATA_TYPE_DEFAULT_VALUE;
   10d2e:	2300      	movs	r3, #0
   10d30:	803b      	strh	r3, [r7, #0]
    cause = at_get_uint8_param(AT_PARSE_SIXTH_PARAM_POS, &seq_num, true);
   10d32:	af03      	add	r7, sp, #12
   10d34:	2201      	movs	r2, #1
   10d36:	0039      	movs	r1, r7
   10d38:	2005      	movs	r0, #5
   10d3a:	f7f9 fc67 	bl	a60c <at_get_uint8_param>
    if (cause == AT_RET_PARAM_MISSING)
   10d3e:	2803      	cmp	r0, #3
   10d40:	d13b      	bne.n	10dba <at_common_handle_non_ip_send_data_parse.part.15+0x12e>
        seq_num = NEUL_DATA_SENT_DATA_SEQ_INVALID;
   10d42:	2300      	movs	r3, #0
   10d44:	703b      	strb	r3, [r7, #0]
    if(get_cid_status((uint8)cid, &status, &backoff) == NEUL_RET_OK)
   10d46:	2212      	movs	r2, #18
   10d48:	ab02      	add	r3, sp, #8
   10d4a:	1d5f      	adds	r7, r3, #5
   10d4c:	7828      	ldrb	r0, [r5, #0]
   10d4e:	18d2      	adds	r2, r2, r3
   10d50:	0039      	movs	r1, r7
   10d52:	f00b fed3 	bl	1cafc <get_cid_status>
   10d56:	2800      	cmp	r0, #0
   10d58:	d1c4      	bne.n	10ce4 <at_common_handle_non_ip_send_data_parse.part.15+0x58>
        if (status == SOCKET_OR_CID_STATUS_BACK_OFF)
   10d5a:	783b      	ldrb	r3, [r7, #0]
   10d5c:	2b03      	cmp	r3, #3
   10d5e:	d036      	beq.n	10dce <at_common_handle_non_ip_send_data_parse.part.15+0x142>
    msg_flag = (uint32)(((seq_num << 16) & 0x00FF0000) | (((data_type << 8) + (rai << 9)) & 0x0000FFFF));
   10d60:	230e      	movs	r3, #14
   10d62:	aa02      	add	r2, sp, #8
   10d64:	189b      	adds	r3, r3, r2
   10d66:	881b      	ldrh	r3, [r3, #0]
   10d68:	8832      	ldrh	r2, [r6, #0]
   10d6a:	021b      	lsls	r3, r3, #8
   10d6c:	0252      	lsls	r2, r2, #9
   10d6e:	189b      	adds	r3, r3, r2
   10d70:	aa03      	add	r2, sp, #12
   10d72:	7812      	ldrb	r2, [r2, #0]
   10d74:	041b      	lsls	r3, r3, #16
   10d76:	0412      	lsls	r2, r2, #16
   10d78:	0c1b      	lsrs	r3, r3, #16
   10d7a:	4313      	orrs	r3, r2
    if (is_cp_only)
   10d7c:	9a01      	ldr	r2, [sp, #4]
   10d7e:	2a00      	cmp	r2, #0
   10d80:	d022      	beq.n	10dc8 <at_common_handle_non_ip_send_data_parse.part.15+0x13c>
        msg_flag |= ((uint32)AT_CP_ONLY_NON_IP_PENDING_DATA_LIST_INDEX << 24);
   10d82:	4a14      	ldr	r2, [pc, #80]	; (10dd4 <at_common_handle_non_ip_send_data_parse.part.15+0x148>)
        msg_flag |= ((uint32)AT_CP_NON_IP_PENDING_DATA_LIST_INDEX << 24);
   10d84:	4313      	orrs	r3, r2
    ret = nonip_sendto((uint8)cid, data_string, length, msg_flag);
   10d86:	aa02      	add	r2, sp, #8
   10d88:	8912      	ldrh	r2, [r2, #8]
   10d8a:	7828      	ldrb	r0, [r5, #0]
   10d8c:	9907      	ldr	r1, [sp, #28]
   10d8e:	f00a ff63 	bl	1bc58 <nonip_sendto>
    if (ret != NEUL_RET_OK)
   10d92:	2800      	cmp	r0, #0
   10d94:	d100      	bne.n	10d98 <at_common_handle_non_ip_send_data_parse.part.15+0x10c>
   10d96:	e786      	b.n	10ca6 <at_common_handle_non_ip_send_data_parse.part.15+0x1a>
            return AT_RET_DATA_SEQUENCE_REPEAT_ERROR;
   10d98:	241d      	movs	r4, #29
        if (ret == NEUL_RET_DATA_SEQUENCE_REPEAT_ERROR)
   10d9a:	281e      	cmp	r0, #30
   10d9c:	d100      	bne.n	10da0 <at_common_handle_non_ip_send_data_parse.part.15+0x114>
   10d9e:	e782      	b.n	10ca6 <at_common_handle_non_ip_send_data_parse.part.15+0x1a>
        cause = at_parse_convert_neul_result(ret);
   10da0:	f7f9 fa76 	bl	a290 <at_parse_convert_neul_result>
   10da4:	0004      	movs	r4, r0
   10da6:	e77e      	b.n	10ca6 <at_common_handle_non_ip_send_data_parse.part.15+0x1a>
    else if(rai > AT_CSODCP_RAI_RELEASE_AFTER_REPLY)
   10da8:	8833      	ldrh	r3, [r6, #0]
   10daa:	2b02      	cmp	r3, #2
   10dac:	d9b5      	bls.n	10d1a <at_common_handle_non_ip_send_data_parse.part.15+0x8e>
   10dae:	e779      	b.n	10ca4 <at_common_handle_non_ip_send_data_parse.part.15+0x18>
    else if(data_type > AT_CSODCP_DATA_TYPE_EXCEPTION_DATA)
   10db0:	883b      	ldrh	r3, [r7, #0]
   10db2:	2b01      	cmp	r3, #1
   10db4:	d900      	bls.n	10db8 <at_common_handle_non_ip_send_data_parse.part.15+0x12c>
   10db6:	e775      	b.n	10ca4 <at_common_handle_non_ip_send_data_parse.part.15+0x18>
   10db8:	e7bb      	b.n	10d32 <at_common_handle_non_ip_send_data_parse.part.15+0xa6>
    else if ((cause != AT_RET_OK) || (seq_num == NEUL_DATA_SENT_DATA_SEQ_INVALID))
   10dba:	2800      	cmp	r0, #0
   10dbc:	d000      	beq.n	10dc0 <at_common_handle_non_ip_send_data_parse.part.15+0x134>
   10dbe:	e771      	b.n	10ca4 <at_common_handle_non_ip_send_data_parse.part.15+0x18>
   10dc0:	783b      	ldrb	r3, [r7, #0]
   10dc2:	2b00      	cmp	r3, #0
   10dc4:	d1bf      	bne.n	10d46 <at_common_handle_non_ip_send_data_parse.part.15+0xba>
   10dc6:	e76d      	b.n	10ca4 <at_common_handle_non_ip_send_data_parse.part.15+0x18>
        msg_flag |= ((uint32)AT_CP_NON_IP_PENDING_DATA_LIST_INDEX << 24);
   10dc8:	22ef      	movs	r2, #239	; 0xef
   10dca:	0612      	lsls	r2, r2, #24
   10dcc:	e7da      	b.n	10d84 <at_common_handle_non_ip_send_data_parse.part.15+0xf8>
            return AT_RET_BACK_OFF;
   10dce:	2432      	movs	r4, #50	; 0x32
   10dd0:	e769      	b.n	10ca6 <at_common_handle_non_ip_send_data_parse.part.15+0x1a>
   10dd2:	46c0      	nop			; (mov r8, r8)
   10dd4:	ff001000 	.word	0xff001000

00010dd8 <at_handle_NSNPD_cmd_set>:
{
   10dd8:	b507      	push	{r0, r1, r2, lr}
    cause = at_create_param_array(p_atparams_string, &num_recvparams, 3, 6);
   10dda:	4669      	mov	r1, sp
   10ddc:	2306      	movs	r3, #6
   10dde:	2203      	movs	r2, #3
   10de0:	3107      	adds	r1, #7
   10de2:	f7f9 fa7f 	bl	a2e4 <at_create_param_array>
    if (cause != AT_RET_OK)
   10de6:	2800      	cmp	r0, #0
   10de8:	d101      	bne.n	10dee <at_handle_NSNPD_cmd_set+0x16>
   10dea:	f7ff ff4f 	bl	10c8c <at_common_handle_non_ip_send_data_parse.part.15>
}
   10dee:	bd0e      	pop	{r1, r2, r3, pc}

00010df0 <at_handle_NGACTR_cmd_set>:
{
   10df0:	b537      	push	{r0, r1, r2, r4, r5, lr}
    cause = at_create_param_array(p_atparams_string, &num_recvparams, 1, 1);
   10df2:	2301      	movs	r3, #1
   10df4:	4669      	mov	r1, sp
   10df6:	001a      	movs	r2, r3
   10df8:	3105      	adds	r1, #5
   10dfa:	f7f9 fa73 	bl	a2e4 <at_create_param_array>
   10dfe:	1e04      	subs	r4, r0, #0
    if(cause != AT_RET_OK)
   10e00:	d112      	bne.n	10e28 <at_handle_NGACTR_cmd_set+0x38>
    cause = at_get_uint16_param(AT_PARSE_FIRST_PARAM_POS, &pdp_context_act_or_deact_result_report_mode, true);
   10e02:	466b      	mov	r3, sp
   10e04:	1d9d      	adds	r5, r3, #6
   10e06:	2201      	movs	r2, #1
   10e08:	0029      	movs	r1, r5
   10e0a:	f7f9 fb7f 	bl	a50c <at_get_uint16_param>
   10e0e:	1e04      	subs	r4, r0, #0
    if(cause != AT_RET_OK)
   10e10:	d10c      	bne.n	10e2c <at_handle_NGACTR_cmd_set+0x3c>
    if(pdp_context_act_or_deact_result_report_mode == PDP_CONTEXT_REPORT_MODE_DISABLE)
   10e12:	882b      	ldrh	r3, [r5, #0]
   10e14:	2b00      	cmp	r3, #0
   10e16:	d002      	beq.n	10e1e <at_handle_NGACTR_cmd_set+0x2e>
    else if(pdp_context_act_or_deact_result_report_mode == PDP_CONTEXT_REPORT_MODE_ENABLE)
   10e18:	2b01      	cmp	r3, #1
   10e1a:	d107      	bne.n	10e2c <at_handle_NGACTR_cmd_set+0x3c>
        set_pdp_context_report_callback(pdp_context_activate_or_deactivate_callback);
   10e1c:	4804      	ldr	r0, [pc, #16]	; (10e30 <at_handle_NGACTR_cmd_set+0x40>)
   10e1e:	f00b fc3f 	bl	1c6a0 <set_pdp_context_report_callback>
    app_at_state_info.ngactr_mode = (PDP_CONTEXT_REPORT_MODE_ENUM)pdp_context_act_or_deact_result_report_mode;
   10e22:	882a      	ldrh	r2, [r5, #0]
   10e24:	4b03      	ldr	r3, [pc, #12]	; (10e34 <at_handle_NGACTR_cmd_set+0x44>)
   10e26:	715a      	strb	r2, [r3, #5]
}
   10e28:	0020      	movs	r0, r4
   10e2a:	bd3e      	pop	{r1, r2, r3, r4, r5, pc}
        return AT_RET_SYNTAX_ERROR;
   10e2c:	2401      	movs	r4, #1
   10e2e:	e7fb      	b.n	10e28 <at_handle_NGACTR_cmd_set+0x38>
   10e30:	0000ae55 	.word	0x0000ae55
   10e34:	010024c2 	.word	0x010024c2

00010e38 <at_handle_CNMA_cmd_exec>:
{
   10e38:	b510      	push	{r4, lr}
    result = get_cnma_acknowledgement_expected();
   10e3a:	f00b ff06 	bl	1cc4a <get_cnma_acknowledgement_expected>
    if (result != NEUL_RET_OK)
   10e3e:	2800      	cmp	r0, #0
   10e40:	d002      	beq.n	10e48 <at_handle_CNMA_cmd_exec+0x10>
    return at_parse_convert_neul_result(result);
   10e42:	f7f9 fa25 	bl	a290 <at_parse_convert_neul_result>
}
   10e46:	bd10      	pop	{r4, pc}
    result = set_new_msg_ack(NEUL_SMS_DR_OK, 0, NULL);
   10e48:	0002      	movs	r2, r0
   10e4a:	0001      	movs	r1, r0
   10e4c:	f00b feec 	bl	1cc28 <set_new_msg_ack>
   10e50:	e7f7      	b.n	10e42 <at_handle_CNMA_cmd_exec+0xa>

00010e52 <at_handle_CMMS_cmd_set>:
{
   10e52:	b513      	push	{r0, r1, r4, lr}
    cause = at_create_param_array(p_atparams_string, &num_recvparams, 1, 1);
   10e54:	2301      	movs	r3, #1
   10e56:	4669      	mov	r1, sp
   10e58:	001a      	movs	r2, r3
   10e5a:	3106      	adds	r1, #6
   10e5c:	f7f9 fa42 	bl	a2e4 <at_create_param_array>
    if(cause != AT_RET_OK)
   10e60:	2800      	cmp	r0, #0
   10e62:	d111      	bne.n	10e88 <at_handle_CMMS_cmd_set+0x36>
    cause = at_get_uint8_param(AT_PARSE_FIRST_PARAM_POS, &mode, true);
   10e64:	466b      	mov	r3, sp
   10e66:	1ddc      	adds	r4, r3, #7
   10e68:	2201      	movs	r2, #1
   10e6a:	0021      	movs	r1, r4
   10e6c:	f7f9 fbce 	bl	a60c <at_get_uint8_param>
   10e70:	0003      	movs	r3, r0
        return AT_RET_SYNTAX_ERROR;
   10e72:	2001      	movs	r0, #1
    if ((cause != AT_RET_OK) || (mode > NEUL_SMS_MORE_MESSAGE_ENABLE))
   10e74:	2b00      	cmp	r3, #0
   10e76:	d107      	bne.n	10e88 <at_handle_CMMS_cmd_set+0x36>
   10e78:	7823      	ldrb	r3, [r4, #0]
   10e7a:	2b02      	cmp	r3, #2
   10e7c:	d804      	bhi.n	10e88 <at_handle_CMMS_cmd_set+0x36>
    result = set_more_message_to_send(mode);
   10e7e:	0018      	movs	r0, r3
   10e80:	f00b fe7d 	bl	1cb7e <set_more_message_to_send>
    cause = at_parse_convert_neul_result(result);
   10e84:	f7f9 fa04 	bl	a290 <at_parse_convert_neul_result>
}
   10e88:	bd16      	pop	{r1, r2, r4, pc}

00010e8a <at_handle_NTPERMID_cmd_set>:
{
   10e8a:	b573      	push	{r0, r1, r4, r5, r6, lr}
    cause = at_create_param_array(p_atparams_string, &num_recvparams, 2, 2);
   10e8c:	2302      	movs	r3, #2
   10e8e:	4669      	mov	r1, sp
   10e90:	001a      	movs	r2, r3
   10e92:	3103      	adds	r1, #3
   10e94:	f7f9 fa26 	bl	a2e4 <at_create_param_array>
   10e98:	1e04      	subs	r4, r0, #0
    if(cause != AT_RET_OK)
   10e9a:	d123      	bne.n	10ee4 <at_handle_NTPERMID_cmd_set+0x5a>
    cause = at_get_uint16_param(AT_PARSE_FIRST_PARAM_POS, &id, true);
   10e9c:	ad01      	add	r5, sp, #4
   10e9e:	2201      	movs	r2, #1
   10ea0:	0029      	movs	r1, r5
   10ea2:	f7f9 fb33 	bl	a50c <at_get_uint16_param>
    if(cause != AT_RET_OK)
   10ea6:	2800      	cmp	r0, #0
   10ea8:	d001      	beq.n	10eae <at_handle_NTPERMID_cmd_set+0x24>
            return AT_RET_SYNTAX_ERROR;
   10eaa:	2401      	movs	r4, #1
   10eac:	e01a      	b.n	10ee4 <at_handle_NTPERMID_cmd_set+0x5a>
    cause = at_get_uint16_param(AT_PARSE_SECOND_PARAM_POS, &permanence_type, true);
   10eae:	466b      	mov	r3, sp
   10eb0:	2201      	movs	r2, #1
   10eb2:	1d9e      	adds	r6, r3, #6
   10eb4:	0031      	movs	r1, r6
   10eb6:	0010      	movs	r0, r2
   10eb8:	f7f9 fb28 	bl	a50c <at_get_uint16_param>
   10ebc:	1e04      	subs	r4, r0, #0
    if (cause != AT_RET_OK)
   10ebe:	d1f4      	bne.n	10eaa <at_handle_NTPERMID_cmd_set+0x20>
    if ((permanence_type == ID_CONFIG_FLASH) || (permanence_type == ID_CONFIG_OTP))
   10ec0:	8830      	ldrh	r0, [r6, #0]
   10ec2:	1e43      	subs	r3, r0, #1
   10ec4:	2b01      	cmp	r3, #1
   10ec6:	d8f0      	bhi.n	10eaa <at_handle_NTPERMID_cmd_set+0x20>
    switch((NTPERMID_SNT)id)
   10ec8:	782b      	ldrb	r3, [r5, #0]
        dest = (NTPERMID_TYPE)permanence_type;
   10eca:	b2c0      	uxtb	r0, r0
    switch((NTPERMID_SNT)id)
   10ecc:	2b00      	cmp	r3, #0
   10ece:	d004      	beq.n	10eda <at_handle_NTPERMID_cmd_set+0x50>
   10ed0:	2b01      	cmp	r3, #1
   10ed2:	d1ea      	bne.n	10eaa <at_handle_NTPERMID_cmd_set+0x20>
            if (set_imei_permanence(dest) != NEUL_RET_OK)
   10ed4:	f00a fd32 	bl	1b93c <set_imei_permanence>
   10ed8:	e001      	b.n	10ede <at_handle_NTPERMID_cmd_set+0x54>
            if (set_serialnumber_permanence(dest) != NEUL_RET_OK)
   10eda:	f00a fd42 	bl	1b962 <set_serialnumber_permanence>
   10ede:	2800      	cmp	r0, #0
   10ee0:	d000      	beq.n	10ee4 <at_handle_NTPERMID_cmd_set+0x5a>
                return AT_RET_PROGRESS_ERROR;
   10ee2:	2406      	movs	r4, #6
}
   10ee4:	0020      	movs	r0, r4
   10ee6:	bd76      	pop	{r1, r2, r4, r5, r6, pc}

00010ee8 <at_handle_CTZR_cmd_set>:
{
   10ee8:	b537      	push	{r0, r1, r2, r4, r5, lr}
    cause = at_create_param_array(p_atparams_string, &num_recvparams, 1, 1);
   10eea:	2301      	movs	r3, #1
   10eec:	4669      	mov	r1, sp
   10eee:	001a      	movs	r2, r3
   10ef0:	3105      	adds	r1, #5
   10ef2:	f7f9 f9f7 	bl	a2e4 <at_create_param_array>
   10ef6:	1e04      	subs	r4, r0, #0
    if(cause != AT_RET_OK)
   10ef8:	d114      	bne.n	10f24 <at_handle_CTZR_cmd_set+0x3c>
    cause = at_get_uint16_param(AT_PARSE_FIRST_PARAM_POS, &reporting, true);
   10efa:	466b      	mov	r3, sp
   10efc:	1d9d      	adds	r5, r3, #6
   10efe:	2201      	movs	r2, #1
   10f00:	0029      	movs	r1, r5
   10f02:	f7f9 fb03 	bl	a50c <at_get_uint16_param>
   10f06:	1e04      	subs	r4, r0, #0
    if(cause != AT_RET_OK)
   10f08:	d10c      	bne.n	10f24 <at_handle_CTZR_cmd_set+0x3c>
    if ((CTZR_RPORTING_MODE)reporting == CTZR_RPORTING_MODE_DISABLE)
   10f0a:	882b      	ldrh	r3, [r5, #0]
   10f0c:	b2da      	uxtb	r2, r3
   10f0e:	2a00      	cmp	r2, #0
   10f10:	d003      	beq.n	10f1a <at_handle_CTZR_cmd_set+0x32>
    else if(reporting >= CTZR_RPORTING_MODE_ENABLE_REPORTING_TZ
   10f12:	3b01      	subs	r3, #1
   10f14:	2b02      	cmp	r3, #2
   10f16:	d807      	bhi.n	10f28 <at_handle_CTZR_cmd_set+0x40>
        set_time_zone_reporting(ctzr_callback);
   10f18:	4804      	ldr	r0, [pc, #16]	; (10f2c <at_handle_CTZR_cmd_set+0x44>)
   10f1a:	f00a fdfd 	bl	1bb18 <set_time_zone_reporting>
    app_at_state_info.ctzr_mode = (CTZR_RPORTING_MODE)reporting;
   10f1e:	882a      	ldrh	r2, [r5, #0]
   10f20:	4b03      	ldr	r3, [pc, #12]	; (10f30 <at_handle_CTZR_cmd_set+0x48>)
   10f22:	709a      	strb	r2, [r3, #2]
}
   10f24:	0020      	movs	r0, r4
   10f26:	bd3e      	pop	{r1, r2, r3, r4, r5, pc}
        return AT_RET_SYNTAX_ERROR;
   10f28:	2401      	movs	r4, #1
   10f2a:	e7fb      	b.n	10f24 <at_handle_CTZR_cmd_set+0x3c>
   10f2c:	0000e21d 	.word	0x0000e21d
   10f30:	010024c2 	.word	0x010024c2

00010f34 <at_handle_NITZ_set>:
{
   10f34:	b537      	push	{r0, r1, r2, r4, r5, lr}
    cause = at_create_param_array(p_atparams_string, &num_recvparams, AT_NITZ_SET_PARAMTER_NUMBER, AT_NITZ_SET_PARAMTER_NUMBER);
   10f36:	2301      	movs	r3, #1
   10f38:	4669      	mov	r1, sp
   10f3a:	001a      	movs	r2, r3
   10f3c:	3105      	adds	r1, #5
   10f3e:	f7f9 f9d1 	bl	a2e4 <at_create_param_array>
   10f42:	1e04      	subs	r4, r0, #0
    if(cause != AT_RET_OK)
   10f44:	d112      	bne.n	10f6c <at_handle_NITZ_set+0x38>
    cause = at_get_uint16_param(AT_PARSE_FIRST_PARAM_POS, &time_update_mode, true);
   10f46:	466b      	mov	r3, sp
   10f48:	1d9d      	adds	r5, r3, #6
   10f4a:	2201      	movs	r2, #1
   10f4c:	0029      	movs	r1, r5
   10f4e:	f7f9 fadd 	bl	a50c <at_get_uint16_param>
   10f52:	1e04      	subs	r4, r0, #0
    if(cause != AT_RET_OK)
   10f54:	d109      	bne.n	10f6a <at_handle_NITZ_set+0x36>
    if((time_update_mode == TIME_UPDATE_MODE_LOCAL) || (time_update_mode == TIME_UPDATE_MODE_NETWORK))
   10f56:	8828      	ldrh	r0, [r5, #0]
   10f58:	2801      	cmp	r0, #1
   10f5a:	d806      	bhi.n	10f6a <at_handle_NITZ_set+0x36>
        if (set_time_update_mode((TIME_UPDATE_MODE)time_update_mode) != NEUL_RET_OK)
   10f5c:	b2c0      	uxtb	r0, r0
   10f5e:	f00a fe39 	bl	1bbd4 <set_time_update_mode>
   10f62:	2800      	cmp	r0, #0
   10f64:	d002      	beq.n	10f6c <at_handle_NITZ_set+0x38>
            return AT_RET_PROGRESS_ERROR;
   10f66:	2406      	movs	r4, #6
   10f68:	e000      	b.n	10f6c <at_handle_NITZ_set+0x38>
        return AT_RET_SYNTAX_ERROR;
   10f6a:	2401      	movs	r4, #1
}
   10f6c:	0020      	movs	r0, r4
   10f6e:	bd3e      	pop	{r1, r2, r3, r4, r5, pc}

00010f70 <at_handle_CCLK_set>:
    cause = at_create_param_array(p_atparams_string, &num_recvparams, AT_CCLK_SET_PARAMTER_NUMBER, AT_CCLK_SET_PARAMTER_NUMBER); //time string will use 2 parameters
   10f70:	2301      	movs	r3, #1
   10f72:	210a      	movs	r1, #10
{
   10f74:	b530      	push	{r4, r5, lr}
   10f76:	b08d      	sub	sp, #52	; 0x34
    cause = at_create_param_array(p_atparams_string, &num_recvparams, AT_CCLK_SET_PARAMTER_NUMBER, AT_CCLK_SET_PARAMTER_NUMBER); //time string will use 2 parameters
   10f78:	001a      	movs	r2, r3
   10f7a:	4469      	add	r1, sp
   10f7c:	f7f9 f9b2 	bl	a2e4 <at_create_param_array>
   10f80:	1e04      	subs	r4, r0, #0
    if(cause != AT_RET_OK)
   10f82:	d11c      	bne.n	10fbe <at_handle_CCLK_set+0x4e>
    cause = at_get_tm_param(AT_PARSE_FIRST_PARAM_POS, &time_struct, &time_zone, true);
   10f84:	250b      	movs	r5, #11
   10f86:	446d      	add	r5, sp
   10f88:	2301      	movs	r3, #1
   10f8a:	002a      	movs	r2, r5
   10f8c:	a903      	add	r1, sp, #12
   10f8e:	f7f9 fd63 	bl	aa58 <at_get_tm_param>
   10f92:	1e04      	subs	r4, r0, #0
    if (cause != AT_RET_OK)
   10f94:	d113      	bne.n	10fbe <at_handle_CCLK_set+0x4e>
    current_time        = mktime(&time_struct);
   10f96:	a803      	add	r0, sp, #12
   10f98:	f00a fb78 	bl	1b68c <mktime>
    neul_result = set_system_time_from_apps((uint64)current_time * RTC_MS_IN_SECOND, time_zone, 0, updated_time_fields);
   10f9c:	22fa      	movs	r2, #250	; 0xfa
   10f9e:	2300      	movs	r3, #0
   10fa0:	0092      	lsls	r2, r2, #2
   10fa2:	0021      	movs	r1, r4
   10fa4:	f7ef fb9e 	bl	6e4 <__aeabi_lmul>
   10fa8:	2303      	movs	r3, #3
   10faa:	782d      	ldrb	r5, [r5, #0]
   10fac:	9300      	str	r3, [sp, #0]
   10fae:	b26d      	sxtb	r5, r5
   10fb0:	0023      	movs	r3, r4
   10fb2:	002a      	movs	r2, r5
   10fb4:	f00a fdef 	bl	1bb96 <set_system_time_from_apps>
    return at_parse_convert_neul_result(neul_result);
   10fb8:	f7f9 f96a 	bl	a290 <at_parse_convert_neul_result>
   10fbc:	0004      	movs	r4, r0
}
   10fbe:	0020      	movs	r0, r4
   10fc0:	b00d      	add	sp, #52	; 0x34
   10fc2:	bd30      	pop	{r4, r5, pc}

00010fc4 <at_handle_NSOCL_cmd_set>:
{
   10fc4:	b537      	push	{r0, r1, r2, r4, r5, lr}
    cause = at_create_param_array(p_atparams_string, &num_recvparams, 1, 1);
   10fc6:	2301      	movs	r3, #1
   10fc8:	4669      	mov	r1, sp
   10fca:	001a      	movs	r2, r3
   10fcc:	3105      	adds	r1, #5
   10fce:	f7f9 f989 	bl	a2e4 <at_create_param_array>
   10fd2:	1e04      	subs	r4, r0, #0
    if (cause != AT_RET_OK)
   10fd4:	d115      	bne.n	11002 <at_handle_NSOCL_cmd_set+0x3e>
    cause = at_get_uint16_param(AT_PARSE_FIRST_PARAM_POS, &socket, true);
   10fd6:	466b      	mov	r3, sp
   10fd8:	1d9d      	adds	r5, r3, #6
   10fda:	2201      	movs	r2, #1
   10fdc:	0029      	movs	r1, r5
   10fde:	f7f9 fa95 	bl	a50c <at_get_uint16_param>
   10fe2:	1e04      	subs	r4, r0, #0
    if (cause != AT_RET_OK)
   10fe4:	d10c      	bne.n	11000 <at_handle_NSOCL_cmd_set+0x3c>
    if (!check_at_allocated_socket(socket))
   10fe6:	882d      	ldrh	r5, [r5, #0]
   10fe8:	0028      	movs	r0, r5
   10fea:	f7fe fe95 	bl	fd18 <check_at_allocated_socket>
   10fee:	2800      	cmp	r0, #0
   10ff0:	d009      	beq.n	11006 <at_handle_NSOCL_cmd_set+0x42>
    if (close_socket(socket) != NEUL_SOCKET_RET_OK)
   10ff2:	0028      	movs	r0, r5
   10ff4:	f7f6 fffc 	bl	7ff0 <close_socket>
   10ff8:	2800      	cmp	r0, #0
   10ffa:	d002      	beq.n	11002 <at_handle_NSOCL_cmd_set+0x3e>
        return AT_RET_PROGRESS_ERROR;
   10ffc:	2406      	movs	r4, #6
   10ffe:	e000      	b.n	11002 <at_handle_NSOCL_cmd_set+0x3e>
        return AT_RET_SYNTAX_ERROR;
   11000:	2401      	movs	r4, #1
}
   11002:	0020      	movs	r0, r4
   11004:	bd3e      	pop	{r1, r2, r3, r4, r5, pc}
        return AT_RET_INVALID_SOCKET;
   11006:	2425      	movs	r4, #37	; 0x25
   11008:	e7fb      	b.n	11002 <at_handle_NSOCL_cmd_set+0x3e>

0001100a <at_handle_CMEE_cmd_set>:
{
   1100a:	b537      	push	{r0, r1, r2, r4, r5, lr}
    cause = at_create_param_array(p_atparams_string, &num_recvparams, 1, 1);
   1100c:	2301      	movs	r3, #1
   1100e:	4669      	mov	r1, sp
   11010:	001a      	movs	r2, r3
   11012:	3105      	adds	r1, #5
   11014:	f7f9 f966 	bl	a2e4 <at_create_param_array>
   11018:	1e04      	subs	r4, r0, #0
    if(cause != AT_RET_OK)
   1101a:	d10d      	bne.n	11038 <at_handle_CMEE_cmd_set+0x2e>
    cause = at_get_uint16_param(AT_PARSE_FIRST_PARAM_POS, &error_control, true);
   1101c:	466b      	mov	r3, sp
   1101e:	1d9d      	adds	r5, r3, #6
   11020:	2201      	movs	r2, #1
   11022:	0029      	movs	r1, r5
   11024:	f7f9 fa72 	bl	a50c <at_get_uint16_param>
   11028:	1e04      	subs	r4, r0, #0
    if (cause != AT_RET_OK)
   1102a:	d107      	bne.n	1103c <at_handle_CMEE_cmd_set+0x32>
    if (error_control > 1)
   1102c:	8828      	ldrh	r0, [r5, #0]
   1102e:	2801      	cmp	r0, #1
   11030:	d804      	bhi.n	1103c <at_handle_CMEE_cmd_set+0x32>
        set_cmee_error_type((CMEE_ERROR_TYPE)error_control);
   11032:	b2c0      	uxtb	r0, r0
   11034:	f7f8 f998 	bl	9368 <set_cmee_error_type>
}
   11038:	0020      	movs	r0, r4
   1103a:	bd3e      	pop	{r1, r2, r3, r4, r5, pc}
        return AT_RET_SYNTAX_ERROR;
   1103c:	2401      	movs	r4, #1
   1103e:	e7fb      	b.n	11038 <at_handle_CMEE_cmd_set+0x2e>

00011040 <at_handle_CSCON_cmd_set>:
{
   11040:	b537      	push	{r0, r1, r2, r4, r5, lr}
    cause = at_create_param_array(p_atparams_string, &num_recvparams, 1, 1);
   11042:	2301      	movs	r3, #1
   11044:	4669      	mov	r1, sp
   11046:	001a      	movs	r2, r3
   11048:	3105      	adds	r1, #5
   1104a:	f7f9 f94b 	bl	a2e4 <at_create_param_array>
   1104e:	1e04      	subs	r4, r0, #0
    if(cause != AT_RET_OK)
   11050:	d112      	bne.n	11078 <at_handle_CSCON_cmd_set+0x38>
    cause = at_get_uint16_param(AT_PARSE_FIRST_PARAM_POS, &read_connection_state_mode, true);
   11052:	466b      	mov	r3, sp
   11054:	1d9d      	adds	r5, r3, #6
   11056:	2201      	movs	r2, #1
   11058:	0029      	movs	r1, r5
   1105a:	f7f9 fa57 	bl	a50c <at_get_uint16_param>
   1105e:	1e04      	subs	r4, r0, #0
    if(cause != AT_RET_OK)
   11060:	d10c      	bne.n	1107c <at_handle_CSCON_cmd_set+0x3c>
    if(read_connection_state_mode == 0)
   11062:	882b      	ldrh	r3, [r5, #0]
   11064:	2b00      	cmp	r3, #0
   11066:	d002      	beq.n	1106e <at_handle_CSCON_cmd_set+0x2e>
    else if(read_connection_state_mode == 1)
   11068:	2b01      	cmp	r3, #1
   1106a:	d107      	bne.n	1107c <at_handle_CSCON_cmd_set+0x3c>
        (void)set_connection_status_callback(connection_status_callback);
   1106c:	4804      	ldr	r0, [pc, #16]	; (11080 <at_handle_CSCON_cmd_set+0x40>)
   1106e:	f00b f9f3 	bl	1c458 <set_connection_status_callback>
    app_at_state_info.read_connection_state_mode = (uint8)read_connection_state_mode;
   11072:	882a      	ldrh	r2, [r5, #0]
   11074:	4b03      	ldr	r3, [pc, #12]	; (11084 <at_handle_CSCON_cmd_set+0x44>)
   11076:	705a      	strb	r2, [r3, #1]
}
   11078:	0020      	movs	r0, r4
   1107a:	bd3e      	pop	{r1, r2, r3, r4, r5, pc}
        return AT_RET_SYNTAX_ERROR;
   1107c:	2401      	movs	r4, #1
   1107e:	e7fb      	b.n	11078 <at_handle_CSCON_cmd_set+0x38>
   11080:	0000af2d 	.word	0x0000af2d
   11084:	010024c2 	.word	0x010024c2

00011088 <at_handle_CEREG_cmd_set>:
{
   11088:	b537      	push	{r0, r1, r2, r4, r5, lr}
    cause = at_create_param_array(p_atparams_string, &num_recvparams, 1, 1);
   1108a:	2301      	movs	r3, #1
   1108c:	4669      	mov	r1, sp
   1108e:	001a      	movs	r2, r3
   11090:	3105      	adds	r1, #5
   11092:	f7f9 f927 	bl	a2e4 <at_create_param_array>
   11096:	1e04      	subs	r4, r0, #0
    if(cause != AT_RET_OK)
   11098:	d119      	bne.n	110ce <at_handle_CEREG_cmd_set+0x46>
    cause = at_get_uint16_param(AT_PARSE_FIRST_PARAM_POS, &mode, true);
   1109a:	466b      	mov	r3, sp
   1109c:	1d9d      	adds	r5, r3, #6
   1109e:	2201      	movs	r2, #1
   110a0:	0029      	movs	r1, r5
   110a2:	f7f9 fa33 	bl	a50c <at_get_uint16_param>
   110a6:	1e04      	subs	r4, r0, #0
    if(cause != AT_RET_OK)
   110a8:	d111      	bne.n	110ce <at_handle_CEREG_cmd_set+0x46>
    if (mode > CEREG_MODE_PSM_ENABLE_NETWORK_REGISTRATION_LOCATION_INFORMATION_EMM_CAUSE)
   110aa:	882b      	ldrh	r3, [r5, #0]
   110ac:	2b05      	cmp	r3, #5
   110ae:	d810      	bhi.n	110d2 <at_handle_CEREG_cmd_set+0x4a>
    else if (mode == CEREG_MODE_DISABLE_NETWORK_REGISTRATION_UNSOLICITED_RESULT)
   110b0:	2b00      	cmp	r3, #0
   110b2:	d000      	beq.n	110b6 <at_handle_CEREG_cmd_set+0x2e>
        (void)set_registration_status_callback(service_status_callback);
   110b4:	4808      	ldr	r0, [pc, #32]	; (110d8 <at_handle_CEREG_cmd_set+0x50>)
   110b6:	f00b f9db 	bl	1c470 <set_registration_status_callback>
    if(mode == CEREG_MODE_PSM_ENABLE_NETWORK_REGISTRATION_LOCATION_INFORMATION_EMM_CAUSE)
   110ba:	882b      	ldrh	r3, [r5, #0]
        (void)set_t3324_t3412_ext_value_changed_callback(t3324_t3412_ext_value_callback);
   110bc:	4807      	ldr	r0, [pc, #28]	; (110dc <at_handle_CEREG_cmd_set+0x54>)
    if(mode == CEREG_MODE_PSM_ENABLE_NETWORK_REGISTRATION_LOCATION_INFORMATION_EMM_CAUSE)
   110be:	2b05      	cmp	r3, #5
   110c0:	d000      	beq.n	110c4 <at_handle_CEREG_cmd_set+0x3c>
        (void)set_t3324_t3412_ext_value_changed_callback(NULL);
   110c2:	2000      	movs	r0, #0
   110c4:	f00b f9da 	bl	1c47c <set_t3324_t3412_ext_value_changed_callback>
    app_at_state_info.cereg_mode = (CEREG_MODE_ENUM)mode;
   110c8:	882a      	ldrh	r2, [r5, #0]
   110ca:	4b05      	ldr	r3, [pc, #20]	; (110e0 <at_handle_CEREG_cmd_set+0x58>)
   110cc:	701a      	strb	r2, [r3, #0]
}
   110ce:	0020      	movs	r0, r4
   110d0:	bd3e      	pop	{r1, r2, r3, r4, r5, pc}
        return AT_RET_SYNTAX_ERROR;
   110d2:	2401      	movs	r4, #1
   110d4:	e7fb      	b.n	110ce <at_handle_CEREG_cmd_set+0x46>
   110d6:	46c0      	nop			; (mov r8, r8)
   110d8:	000117bd 	.word	0x000117bd
   110dc:	00011801 	.word	0x00011801
   110e0:	010024c2 	.word	0x010024c2

000110e4 <at_handle_CFUN_cmd_set>:
{
   110e4:	b513      	push	{r0, r1, r4, lr}
    cause = at_create_param_array(p_atparams_string, &num_recvparams, 1, 2);
   110e6:	4669      	mov	r1, sp
   110e8:	2302      	movs	r3, #2
   110ea:	2201      	movs	r2, #1
   110ec:	3105      	adds	r1, #5
   110ee:	f7f9 f8f9 	bl	a2e4 <at_create_param_array>
    if(cause != AT_RET_OK)
   110f2:	2800      	cmp	r0, #0
   110f4:	d117      	bne.n	11126 <at_handle_CFUN_cmd_set+0x42>
    cause = at_get_uint16_param(AT_PARSE_FIRST_PARAM_POS, &fun, true);
   110f6:	466b      	mov	r3, sp
   110f8:	1d9c      	adds	r4, r3, #6
   110fa:	2201      	movs	r2, #1
   110fc:	0021      	movs	r1, r4
   110fe:	f7f9 fa05 	bl	a50c <at_get_uint16_param>
    if(cause != AT_RET_OK || fun == AT_UINT16_NO_VALUE)
   11102:	2800      	cmp	r0, #0
   11104:	d10f      	bne.n	11126 <at_handle_CFUN_cmd_set+0x42>
   11106:	8823      	ldrh	r3, [r4, #0]
   11108:	4a07      	ldr	r2, [pc, #28]	; (11128 <at_handle_CFUN_cmd_set+0x44>)
   1110a:	4293      	cmp	r3, r2
   1110c:	d00b      	beq.n	11126 <at_handle_CFUN_cmd_set+0x42>
        return AT_RET_SYNTAX_ERROR;
   1110e:	3001      	adds	r0, #1
    if (fun != AT_CFUN_MIN && fun != AT_CFUN_FULL)
   11110:	4283      	cmp	r3, r0
   11112:	d808      	bhi.n	11126 <at_handle_CFUN_cmd_set+0x42>
    result = set_cfun(fun, cfun_result_callback); //lint !e64 need remove after merge IOT-3592
   11114:	0018      	movs	r0, r3
   11116:	4905      	ldr	r1, [pc, #20]	; (1112c <at_handle_CFUN_cmd_set+0x48>)
   11118:	f00b f884 	bl	1c224 <set_cfun>
   1111c:	0003      	movs	r3, r0
        cause = AT_RET_CMD_IN_PROGRESS_BLOCK;
   1111e:	2009      	movs	r0, #9
    if (result == NEUL_RET_OK)
   11120:	2b00      	cmp	r3, #0
   11122:	d000      	beq.n	11126 <at_handle_CFUN_cmd_set+0x42>
        cause = AT_RET_PROGRESS_ERROR;
   11124:	3803      	subs	r0, #3
}
   11126:	bd16      	pop	{r1, r2, r4, pc}
   11128:	0000ffff 	.word	0x0000ffff
   1112c:	0000c0f5 	.word	0x0000c0f5

00011130 <at_handle_CGATT_cmd_set>:
{
   11130:	b513      	push	{r0, r1, r4, lr}
    cause = at_create_param_array(p_atparams_string, &num_recvparams, 1, 1);
   11132:	2301      	movs	r3, #1
   11134:	4669      	mov	r1, sp
   11136:	001a      	movs	r2, r3
   11138:	3105      	adds	r1, #5
   1113a:	f7f9 f8d3 	bl	a2e4 <at_create_param_array>
    if(cause != AT_RET_OK)
   1113e:	2800      	cmp	r0, #0
   11140:	d111      	bne.n	11166 <at_handle_CGATT_cmd_set+0x36>
    cause = at_get_uint16_param(AT_PARSE_FIRST_PARAM_POS, &state, true);
   11142:	466b      	mov	r3, sp
   11144:	1d9c      	adds	r4, r3, #6
   11146:	0021      	movs	r1, r4
   11148:	2201      	movs	r2, #1
   1114a:	f7f9 f9df 	bl	a50c <at_get_uint16_param>
   1114e:	0001      	movs	r1, r0
        return AT_RET_SYNTAX_ERROR;
   11150:	2001      	movs	r0, #1
    if(cause != AT_RET_OK)
   11152:	2900      	cmp	r1, #0
   11154:	d107      	bne.n	11166 <at_handle_CGATT_cmd_set+0x36>
    if (state > 1)
   11156:	8823      	ldrh	r3, [r4, #0]
   11158:	4283      	cmp	r3, r0
   1115a:	d804      	bhi.n	11166 <at_handle_CGATT_cmd_set+0x36>
    result = set_service_state(state, NULL);
   1115c:	0018      	movs	r0, r3
   1115e:	f00a ff87 	bl	1c070 <set_service_state>
    return at_parse_convert_neul_result(result);
   11162:	f7f9 f895 	bl	a290 <at_parse_convert_neul_result>
}
   11166:	bd16      	pop	{r1, r2, r4, pc}

00011168 <at_handle_CGTFT_cmd_read>:
{
   11168:	b5f0      	push	{r4, r5, r6, r7, lr}
   1116a:	b0e5      	sub	sp, #404	; 0x194
    char           rsp_string[AT_MAX_CGTFT_READ_RSP_LEN] = {0};
   1116c:	22aa      	movs	r2, #170	; 0xaa
   1116e:	2100      	movs	r1, #0
   11170:	a839      	add	r0, sp, #228	; 0xe4
   11172:	f7ef f8b5 	bl	2e0 <memset>
    uint8          cids[AT_MAX_CID + 1] = {0};
   11176:	220b      	movs	r2, #11
   11178:	2100      	movs	r1, #0
   1117a:	a808      	add	r0, sp, #32
   1117c:	f7ef f8b0 	bl	2e0 <memset>
    uint16         num_cids = 0;
   11180:	2116      	movs	r1, #22
   11182:	ab02      	add	r3, sp, #8
   11184:	18c9      	adds	r1, r1, r3
   11186:	2300      	movs	r3, #0
    if (NEUL_RET_OK != get_defined_cids(AT_MAX_CID + 1, &num_cids, cids))
   11188:	aa08      	add	r2, sp, #32
   1118a:	200b      	movs	r0, #11
    uint16         num_cids = 0;
   1118c:	800b      	strh	r3, [r1, #0]
    if (NEUL_RET_OK != get_defined_cids(AT_MAX_CID + 1, &num_cids, cids))
   1118e:	f00b f876 	bl	1c27e <get_defined_cids>
        return AT_RET_PROGRESS_ERROR;
   11192:	2306      	movs	r3, #6
    for (i = 0; i < num_cids; i++)
   11194:	1e07      	subs	r7, r0, #0
    if (NEUL_RET_OK != get_defined_cids(AT_MAX_CID + 1, &num_cids, cids))
   11196:	d100      	bne.n	1119a <at_handle_CGTFT_cmd_read+0x32>
   11198:	e0f3      	b.n	11382 <at_handle_CGTFT_cmd_read+0x21a>
}
   1119a:	0018      	movs	r0, r3
   1119c:	b065      	add	sp, #404	; 0x194
   1119e:	bdf0      	pop	{r4, r5, r6, r7, pc}
        memset(&tft, 0, sizeof(tft_context));
   111a0:	2100      	movs	r1, #0
   111a2:	2248      	movs	r2, #72	; 0x48
   111a4:	a815      	add	r0, sp, #84	; 0x54
   111a6:	f7ef f89b 	bl	2e0 <memset>
        packet_filters = 0;
   111aa:	2100      	movs	r1, #0
            neul_ret = get_tft_context(cids[i], packet_filters++, &tft, &num_packet_filters);
   111ac:	1c4b      	adds	r3, r1, #1
   111ae:	b2db      	uxtb	r3, r3
   111b0:	9305      	str	r3, [sp, #20]
   111b2:	ab08      	add	r3, sp, #32
   111b4:	5dd8      	ldrb	r0, [r3, r7]
   111b6:	2315      	movs	r3, #21
   111b8:	aa02      	add	r2, sp, #8
   111ba:	189b      	adds	r3, r3, r2
   111bc:	aa15      	add	r2, sp, #84	; 0x54
   111be:	f00b fc81 	bl	1cac4 <get_tft_context>
            if (neul_ret == NEUL_RET_OK)
   111c2:	2800      	cmp	r0, #0
   111c4:	d000      	beq.n	111c8 <at_handle_CGTFT_cmd_read+0x60>
   111c6:	e0d4      	b.n	11372 <at_handle_CGTFT_cmd_read+0x20a>
                if (tft.remote_addr_subnet_mask_present || tft.protnum_nexthead_present || tft.local_port_range_present || tft.remote_port_range_present
   111c8:	9b15      	ldr	r3, [sp, #84]	; 0x54
   111ca:	2b00      	cmp	r3, #0
   111cc:	d103      	bne.n	111d6 <at_handle_CGTFT_cmd_read+0x6e>
                 || tft.spi_present || tft.service_type_present || tft.flow_label_present)
   111ce:	9b16      	ldr	r3, [sp, #88]	; 0x58
   111d0:	021b      	lsls	r3, r3, #8
   111d2:	d100      	bne.n	111d6 <at_handle_CGTFT_cmd_read+0x6e>
   111d4:	e0cd      	b.n	11372 <at_handle_CGTFT_cmd_read+0x20a>
   111d6:	ae27      	add	r6, sp, #156	; 0x9c
                    memset(rsp_string, 0, AT_MAX_CGTFT_READ_RSP_LEN);
   111d8:	22aa      	movs	r2, #170	; 0xaa
   111da:	2100      	movs	r1, #0
   111dc:	a839      	add	r0, sp, #228	; 0xe4
   111de:	f7ef f87f 	bl	2e0 <memset>
   111e2:	2248      	movs	r2, #72	; 0x48
   111e4:	a915      	add	r1, sp, #84	; 0x54
   111e6:	0030      	movs	r0, r6
   111e8:	f7ef f802 	bl	1f0 <memcpy>
    rsp_len = (uint16)snprintf(rsp_string_buff, buff_size, "%s%d,%d,%d", AT_CMD_CGTFT_RSP_PREFIX, tft.cid, tft.pfi, tft.evaluation_precedence);
   111ec:	7af3      	ldrb	r3, [r6, #11]
   111ee:	4a8a      	ldr	r2, [pc, #552]	; (11418 <at_handle_CGTFT_cmd_read+0x2b0>)
   111f0:	9302      	str	r3, [sp, #8]
   111f2:	7ab3      	ldrb	r3, [r6, #10]
   111f4:	21aa      	movs	r1, #170	; 0xaa
   111f6:	9301      	str	r3, [sp, #4]
   111f8:	8933      	ldrh	r3, [r6, #8]
   111fa:	a839      	add	r0, sp, #228	; 0xe4
   111fc:	9300      	str	r3, [sp, #0]
   111fe:	4b87      	ldr	r3, [pc, #540]	; (1141c <at_handle_CGTFT_cmd_read+0x2b4>)
   11200:	f009 fb34 	bl	1a86c <snprintf>
   11204:	b283      	uxth	r3, r0
   11206:	9304      	str	r3, [sp, #16]
    if (tft.remote_addr_subnet_mask_present)
   11208:	7833      	ldrb	r3, [r6, #0]
   1120a:	0405      	lsls	r5, r0, #16
   1120c:	2b00      	cmp	r3, #0
   1120e:	d100      	bne.n	11212 <at_handle_CGTFT_cmd_read+0xaa>
   11210:	e0da      	b.n	113c8 <at_handle_CGTFT_cmd_read+0x260>
        if (tft.addr_subnet_type == IPADDR_TYPE_V4)
   11212:	7b34      	ldrb	r4, [r6, #12]
   11214:	ae0b      	add	r6, sp, #44	; 0x2c
   11216:	2c00      	cmp	r4, #0
   11218:	d000      	beq.n	1121c <at_handle_CGTFT_cmd_read+0xb4>
   1121a:	e0bb      	b.n	11394 <at_handle_CGTFT_cmd_read+0x22c>
            memcpy((uint8*)ip_2_ip4(&remote_addr), tft.remote_addr, AT_IPV4_FULL_ADDR_LEN);
   1121c:	23a1      	movs	r3, #161	; 0xa1
   1121e:	a902      	add	r1, sp, #8
   11220:	185b      	adds	r3, r3, r1
   11222:	0019      	movs	r1, r3
   11224:	2204      	movs	r2, #4
   11226:	0030      	movs	r0, r6
   11228:	f7ee ffe2 	bl	1f0 <memcpy>
            memcpy((uint8*)ip_2_ip4(&subnet_mask_addr), tft.subnet_mask_addr, AT_IPV4_FULL_ADDR_LEN);
   1122c:	21b1      	movs	r1, #177	; 0xb1
            IP_SET_TYPE_VAL(remote_addr, IPADDR_TYPE_V4);
   1122e:	7434      	strb	r4, [r6, #16]
            memcpy((uint8*)ip_2_ip4(&subnet_mask_addr), tft.subnet_mask_addr, AT_IPV4_FULL_ADDR_LEN);
   11230:	ab02      	add	r3, sp, #8
   11232:	ae10      	add	r6, sp, #64	; 0x40
   11234:	2204      	movs	r2, #4
   11236:	18c9      	adds	r1, r1, r3
   11238:	0030      	movs	r0, r6
   1123a:	f7ee ffd9 	bl	1f0 <memcpy>
            IP_SET_TYPE_VAL(subnet_mask_addr, IPADDR_TYPE_V4);
   1123e:	7434      	strb	r4, [r6, #16]
        rsp_len += (uint16)snprintf(rsp_string_buff + rsp_len, buff_size - rsp_len, ",\"%s", ipaddr_ntoa(&remote_addr));        //lint !e506 Constant value Boolean
   11240:	20aa      	movs	r0, #170	; 0xaa
   11242:	0c2d      	lsrs	r5, r5, #16
   11244:	ab39      	add	r3, sp, #228	; 0xe4
   11246:	195e      	adds	r6, r3, r5
   11248:	1b45      	subs	r5, r0, r5
   1124a:	a80b      	add	r0, sp, #44	; 0x2c
   1124c:	7c03      	ldrb	r3, [r0, #16]
   1124e:	2b06      	cmp	r3, #6
   11250:	d000      	beq.n	11254 <at_handle_CGTFT_cmd_read+0xec>
   11252:	e0b3      	b.n	113bc <at_handle_CGTFT_cmd_read+0x254>
   11254:	f00c f958 	bl	1d508 <ip6addr_ntoa>
   11258:	0003      	movs	r3, r0
   1125a:	0029      	movs	r1, r5
   1125c:	0030      	movs	r0, r6
   1125e:	4a70      	ldr	r2, [pc, #448]	; (11420 <at_handle_CGTFT_cmd_read+0x2b8>)
   11260:	f009 fb04 	bl	1a86c <snprintf>
        rsp_len += (uint16)snprintf(rsp_string_buff + rsp_len, buff_size - rsp_len, ".%s\"", ipaddr_ntoa(&subnet_mask_addr));   //lint !e506 Constant value Boolean
   11264:	25aa      	movs	r5, #170	; 0xaa
        rsp_len += (uint16)snprintf(rsp_string_buff + rsp_len, buff_size - rsp_len, ",\"%s", ipaddr_ntoa(&remote_addr));        //lint !e506 Constant value Boolean
   11266:	9b04      	ldr	r3, [sp, #16]
   11268:	181c      	adds	r4, r3, r0
   1126a:	b2a4      	uxth	r4, r4
        rsp_len += (uint16)snprintf(rsp_string_buff + rsp_len, buff_size - rsp_len, ".%s\"", ipaddr_ntoa(&subnet_mask_addr));   //lint !e506 Constant value Boolean
   1126c:	ab39      	add	r3, sp, #228	; 0xe4
   1126e:	a810      	add	r0, sp, #64	; 0x40
   11270:	191e      	adds	r6, r3, r4
   11272:	7c03      	ldrb	r3, [r0, #16]
   11274:	1b2d      	subs	r5, r5, r4
   11276:	2b06      	cmp	r3, #6
   11278:	d000      	beq.n	1127c <at_handle_CGTFT_cmd_read+0x114>
   1127a:	e0a2      	b.n	113c2 <at_handle_CGTFT_cmd_read+0x25a>
   1127c:	f00c f944 	bl	1d508 <ip6addr_ntoa>
   11280:	0003      	movs	r3, r0
   11282:	4a68      	ldr	r2, [pc, #416]	; (11424 <at_handle_CGTFT_cmd_read+0x2bc>)
   11284:	0029      	movs	r1, r5
   11286:	0030      	movs	r0, r6
   11288:	f009 faf0 	bl	1a86c <snprintf>
   1128c:	1824      	adds	r4, r4, r0
   1128e:	21aa      	movs	r1, #170	; 0xaa
        rsp_len += (uint16)snprintf(rsp_string_buff + rsp_len, buff_size - rsp_len, ",");
   11290:	b2a4      	uxth	r4, r4
   11292:	ab39      	add	r3, sp, #228	; 0xe4
    if (tft.protnum_nexthead_present)
   11294:	ad27      	add	r5, sp, #156	; 0x9c
   11296:	1918      	adds	r0, r3, r4
   11298:	786b      	ldrb	r3, [r5, #1]
   1129a:	1b09      	subs	r1, r1, r4
   1129c:	2b00      	cmp	r3, #0
   1129e:	d100      	bne.n	112a2 <at_handle_CGTFT_cmd_read+0x13a>
   112a0:	e09d      	b.n	113de <at_handle_CGTFT_cmd_read+0x276>
        rsp_len += (uint16)snprintf(rsp_string_buff + rsp_len, buff_size - rsp_len, ",%d", tft.protnum_nexthead);
   112a2:	23c1      	movs	r3, #193	; 0xc1
   112a4:	aa02      	add	r2, sp, #8
   112a6:	189b      	adds	r3, r3, r2
   112a8:	781b      	ldrb	r3, [r3, #0]
   112aa:	4a5f      	ldr	r2, [pc, #380]	; (11428 <at_handle_CGTFT_cmd_read+0x2c0>)
   112ac:	f009 fade 	bl	1a86c <snprintf>
   112b0:	21aa      	movs	r1, #170	; 0xaa
        rsp_len += (uint16)snprintf(rsp_string_buff + rsp_len, buff_size - rsp_len, ",");
   112b2:	1824      	adds	r4, r4, r0
   112b4:	b2a4      	uxth	r4, r4
   112b6:	ab39      	add	r3, sp, #228	; 0xe4
   112b8:	1918      	adds	r0, r3, r4
    if (tft.local_port_range_present)
   112ba:	78ab      	ldrb	r3, [r5, #2]
   112bc:	1b09      	subs	r1, r1, r4
   112be:	2b00      	cmp	r3, #0
   112c0:	d100      	bne.n	112c4 <at_handle_CGTFT_cmd_read+0x15c>
   112c2:	e090      	b.n	113e6 <at_handle_CGTFT_cmd_read+0x27e>
        rsp_len += (uint16)snprintf(rsp_string_buff + rsp_len, buff_size - rsp_len, ",\"%d.%d\"", tft.local_port_range[0], tft.local_port_range[1]);
   112c4:	8e2a      	ldrh	r2, [r5, #48]	; 0x30
   112c6:	8deb      	ldrh	r3, [r5, #46]	; 0x2e
   112c8:	9200      	str	r2, [sp, #0]
   112ca:	4a58      	ldr	r2, [pc, #352]	; (1142c <at_handle_CGTFT_cmd_read+0x2c4>)
   112cc:	f009 face 	bl	1a86c <snprintf>
   112d0:	21aa      	movs	r1, #170	; 0xaa
        rsp_len += (uint16)snprintf(rsp_string_buff + rsp_len, buff_size - rsp_len, ",");
   112d2:	1824      	adds	r4, r4, r0
   112d4:	b2a4      	uxth	r4, r4
   112d6:	ab39      	add	r3, sp, #228	; 0xe4
    if (tft.remote_port_range_present)
   112d8:	aa27      	add	r2, sp, #156	; 0x9c
   112da:	1918      	adds	r0, r3, r4
   112dc:	78d3      	ldrb	r3, [r2, #3]
   112de:	1b09      	subs	r1, r1, r4
   112e0:	2b00      	cmp	r3, #0
   112e2:	d100      	bne.n	112e6 <at_handle_CGTFT_cmd_read+0x17e>
   112e4:	e083      	b.n	113ee <at_handle_CGTFT_cmd_read+0x286>
        rsp_len += (uint16)snprintf(rsp_string_buff + rsp_len, buff_size - rsp_len, ",\"%d.%d\"", tft.remote_port_range[0], tft.remote_port_range[1]);
   112e6:	8e53      	ldrh	r3, [r2, #50]	; 0x32
   112e8:	8e92      	ldrh	r2, [r2, #52]	; 0x34
   112ea:	9200      	str	r2, [sp, #0]
   112ec:	4a4f      	ldr	r2, [pc, #316]	; (1142c <at_handle_CGTFT_cmd_read+0x2c4>)
   112ee:	f009 fabd 	bl	1a86c <snprintf>
   112f2:	21aa      	movs	r1, #170	; 0xaa
        rsp_len += (uint16)snprintf(rsp_string_buff + rsp_len, buff_size - rsp_len, ",");
   112f4:	1824      	adds	r4, r4, r0
   112f6:	b2a4      	uxth	r4, r4
   112f8:	ab39      	add	r3, sp, #228	; 0xe4
    if (tft.spi_present)
   112fa:	ad27      	add	r5, sp, #156	; 0x9c
   112fc:	1918      	adds	r0, r3, r4
   112fe:	792b      	ldrb	r3, [r5, #4]
   11300:	1b09      	subs	r1, r1, r4
   11302:	2b00      	cmp	r3, #0
   11304:	d077      	beq.n	113f6 <at_handle_CGTFT_cmd_read+0x28e>
        rsp_len += (uint16)snprintf(rsp_string_buff + rsp_len, buff_size - rsp_len, ",0x%X", tft.spi);
   11306:	6bab      	ldr	r3, [r5, #56]	; 0x38
   11308:	4a49      	ldr	r2, [pc, #292]	; (11430 <at_handle_CGTFT_cmd_read+0x2c8>)
   1130a:	f009 faaf 	bl	1a86c <snprintf>
   1130e:	21aa      	movs	r1, #170	; 0xaa
        rsp_len += (uint16)snprintf(rsp_string_buff + rsp_len, buff_size - rsp_len, ",");
   11310:	1824      	adds	r4, r4, r0
   11312:	b2a4      	uxth	r4, r4
   11314:	ab39      	add	r3, sp, #228	; 0xe4
   11316:	1918      	adds	r0, r3, r4
    if (tft.service_type_present)
   11318:	796b      	ldrb	r3, [r5, #5]
   1131a:	1b09      	subs	r1, r1, r4
   1131c:	2b00      	cmp	r3, #0
   1131e:	d06e      	beq.n	113fe <at_handle_CGTFT_cmd_read+0x296>
        rsp_len += (uint16)snprintf(rsp_string_buff + rsp_len, buff_size - rsp_len, ",\"%d.%d\"", tft.service_type[0], tft.service_type[1]);
   11320:	22d1      	movs	r2, #209	; 0xd1
   11322:	ad02      	add	r5, sp, #8
   11324:	1952      	adds	r2, r2, r5
   11326:	7812      	ldrb	r2, [r2, #0]
   11328:	ab36      	add	r3, sp, #216	; 0xd8
   1132a:	781b      	ldrb	r3, [r3, #0]
   1132c:	9200      	str	r2, [sp, #0]
   1132e:	4a3f      	ldr	r2, [pc, #252]	; (1142c <at_handle_CGTFT_cmd_read+0x2c4>)
   11330:	f009 fa9c 	bl	1a86c <snprintf>
   11334:	21aa      	movs	r1, #170	; 0xaa
        rsp_len += (uint16)snprintf(rsp_string_buff + rsp_len, buff_size - rsp_len, ",");
   11336:	1824      	adds	r4, r4, r0
   11338:	b2a4      	uxth	r4, r4
   1133a:	ab39      	add	r3, sp, #228	; 0xe4
    if (tft.flow_label_present)
   1133c:	ad27      	add	r5, sp, #156	; 0x9c
   1133e:	1918      	adds	r0, r3, r4
   11340:	79ab      	ldrb	r3, [r5, #6]
   11342:	1b09      	subs	r1, r1, r4
   11344:	2b00      	cmp	r3, #0
   11346:	d05e      	beq.n	11406 <at_handle_CGTFT_cmd_read+0x29e>
        rsp_len += (uint16)snprintf(rsp_string_buff + rsp_len, buff_size - rsp_len, ",0x%X", tft.flow_label);
   11348:	6c2b      	ldr	r3, [r5, #64]	; 0x40
   1134a:	4a39      	ldr	r2, [pc, #228]	; (11430 <at_handle_CGTFT_cmd_read+0x2c8>)
   1134c:	f009 fa8e 	bl	1a86c <snprintf>
   11350:	21aa      	movs	r1, #170	; 0xaa
        rsp_len += (uint16)snprintf(rsp_string_buff + rsp_len, buff_size - rsp_len, ",");
   11352:	1824      	adds	r4, r4, r0
   11354:	b2a4      	uxth	r4, r4
   11356:	ab39      	add	r3, sp, #228	; 0xe4
   11358:	1918      	adds	r0, r3, r4
    if (tft.direction_present)
   1135a:	79eb      	ldrb	r3, [r5, #7]
   1135c:	1b09      	subs	r1, r1, r4
   1135e:	2b00      	cmp	r3, #0
   11360:	d055      	beq.n	1140e <at_handle_CGTFT_cmd_read+0x2a6>
        rsp_len += (uint16)snprintf(rsp_string_buff + rsp_len, buff_size - rsp_len, ",%d", tft.direction);
   11362:	ab38      	add	r3, sp, #224	; 0xe0
   11364:	781b      	ldrb	r3, [r3, #0]
   11366:	4a30      	ldr	r2, [pc, #192]	; (11428 <at_handle_CGTFT_cmd_read+0x2c0>)
   11368:	f009 fa80 	bl	1a86c <snprintf>
                    app_at_send_at_rsp_string_lines_with_claim_and_log(rsp_string);
   1136c:	a839      	add	r0, sp, #228	; 0xe4
   1136e:	f7f8 f939 	bl	95e4 <app_at_send_at_rsp_string_lines_with_claim_and_log>
        }while (packet_filters < num_packet_filters);
   11372:	ab02      	add	r3, sp, #8
   11374:	9905      	ldr	r1, [sp, #20]
   11376:	7d5b      	ldrb	r3, [r3, #21]
   11378:	428b      	cmp	r3, r1
   1137a:	d900      	bls.n	1137e <at_handle_CGTFT_cmd_read+0x216>
   1137c:	e716      	b.n	111ac <at_handle_CGTFT_cmd_read+0x44>
    for (i = 0; i < num_cids; i++)
   1137e:	3701      	adds	r7, #1
   11380:	b2ff      	uxtb	r7, r7
   11382:	2316      	movs	r3, #22
   11384:	aa02      	add	r2, sp, #8
   11386:	189b      	adds	r3, r3, r2
   11388:	881b      	ldrh	r3, [r3, #0]
   1138a:	42bb      	cmp	r3, r7
   1138c:	d900      	bls.n	11390 <at_handle_CGTFT_cmd_read+0x228>
   1138e:	e707      	b.n	111a0 <at_handle_CGTFT_cmd_read+0x38>
    return AT_RET_OK;
   11390:	2300      	movs	r3, #0
   11392:	e702      	b.n	1119a <at_handle_CGTFT_cmd_read+0x32>
            memcpy((uint8*)ip_2_ip6(&remote_addr), tft.remote_addr, AT_IPV6_FULL_ADDR_LEN);
   11394:	23a1      	movs	r3, #161	; 0xa1
   11396:	a902      	add	r1, sp, #8
   11398:	185b      	adds	r3, r3, r1
   1139a:	0019      	movs	r1, r3
   1139c:	2210      	movs	r2, #16
   1139e:	0030      	movs	r0, r6
            IP_SET_TYPE_VAL(remote_addr, IPADDR_TYPE_V6);
   113a0:	2406      	movs	r4, #6
            memcpy((uint8*)ip_2_ip6(&remote_addr), tft.remote_addr, AT_IPV6_FULL_ADDR_LEN);
   113a2:	f7ee ff25 	bl	1f0 <memcpy>
            memcpy((uint8*)ip_2_ip6(&subnet_mask_addr), tft.subnet_mask_addr, AT_IPV6_FULL_ADDR_LEN);
   113a6:	21b1      	movs	r1, #177	; 0xb1
            IP_SET_TYPE_VAL(remote_addr, IPADDR_TYPE_V6);
   113a8:	7434      	strb	r4, [r6, #16]
            memcpy((uint8*)ip_2_ip6(&subnet_mask_addr), tft.subnet_mask_addr, AT_IPV6_FULL_ADDR_LEN);
   113aa:	ab02      	add	r3, sp, #8
   113ac:	ae10      	add	r6, sp, #64	; 0x40
   113ae:	2210      	movs	r2, #16
   113b0:	18c9      	adds	r1, r1, r3
   113b2:	0030      	movs	r0, r6
   113b4:	f7ee ff1c 	bl	1f0 <memcpy>
            IP_SET_TYPE_VAL(subnet_mask_addr, IPADDR_TYPE_V6);
   113b8:	7434      	strb	r4, [r6, #16]
   113ba:	e741      	b.n	11240 <at_handle_CGTFT_cmd_read+0xd8>
        rsp_len += (uint16)snprintf(rsp_string_buff + rsp_len, buff_size - rsp_len, ",\"%s", ipaddr_ntoa(&remote_addr));        //lint !e506 Constant value Boolean
   113bc:	f00b ff6a 	bl	1d294 <ip4addr_ntoa>
   113c0:	e74a      	b.n	11258 <at_handle_CGTFT_cmd_read+0xf0>
        rsp_len += (uint16)snprintf(rsp_string_buff + rsp_len, buff_size - rsp_len, ".%s\"", ipaddr_ntoa(&subnet_mask_addr));   //lint !e506 Constant value Boolean
   113c2:	f00b ff67 	bl	1d294 <ip4addr_ntoa>
   113c6:	e75b      	b.n	11280 <at_handle_CGTFT_cmd_read+0x118>
        rsp_len += (uint16)snprintf(rsp_string_buff + rsp_len, buff_size - rsp_len, ",");
   113c8:	21aa      	movs	r1, #170	; 0xaa
   113ca:	ab39      	add	r3, sp, #228	; 0xe4
   113cc:	0c2d      	lsrs	r5, r5, #16
   113ce:	1958      	adds	r0, r3, r5
   113d0:	1b49      	subs	r1, r1, r5
   113d2:	4a18      	ldr	r2, [pc, #96]	; (11434 <at_handle_CGTFT_cmd_read+0x2cc>)
   113d4:	f009 fa4a 	bl	1a86c <snprintf>
   113d8:	9b04      	ldr	r3, [sp, #16]
   113da:	181c      	adds	r4, r3, r0
   113dc:	e757      	b.n	1128e <at_handle_CGTFT_cmd_read+0x126>
        rsp_len += (uint16)snprintf(rsp_string_buff + rsp_len, buff_size - rsp_len, ",");
   113de:	4a15      	ldr	r2, [pc, #84]	; (11434 <at_handle_CGTFT_cmd_read+0x2cc>)
   113e0:	f009 fa44 	bl	1a86c <snprintf>
   113e4:	e764      	b.n	112b0 <at_handle_CGTFT_cmd_read+0x148>
        rsp_len += (uint16)snprintf(rsp_string_buff + rsp_len, buff_size - rsp_len, ",");
   113e6:	4a13      	ldr	r2, [pc, #76]	; (11434 <at_handle_CGTFT_cmd_read+0x2cc>)
   113e8:	f009 fa40 	bl	1a86c <snprintf>
   113ec:	e770      	b.n	112d0 <at_handle_CGTFT_cmd_read+0x168>
        rsp_len += (uint16)snprintf(rsp_string_buff + rsp_len, buff_size - rsp_len, ",");
   113ee:	4a11      	ldr	r2, [pc, #68]	; (11434 <at_handle_CGTFT_cmd_read+0x2cc>)
   113f0:	f009 fa3c 	bl	1a86c <snprintf>
   113f4:	e77d      	b.n	112f2 <at_handle_CGTFT_cmd_read+0x18a>
        rsp_len += (uint16)snprintf(rsp_string_buff + rsp_len, buff_size - rsp_len, ",");
   113f6:	4a0f      	ldr	r2, [pc, #60]	; (11434 <at_handle_CGTFT_cmd_read+0x2cc>)
   113f8:	f009 fa38 	bl	1a86c <snprintf>
   113fc:	e787      	b.n	1130e <at_handle_CGTFT_cmd_read+0x1a6>
        rsp_len += (uint16)snprintf(rsp_string_buff + rsp_len, buff_size - rsp_len, ",");
   113fe:	4a0d      	ldr	r2, [pc, #52]	; (11434 <at_handle_CGTFT_cmd_read+0x2cc>)
   11400:	f009 fa34 	bl	1a86c <snprintf>
   11404:	e796      	b.n	11334 <at_handle_CGTFT_cmd_read+0x1cc>
        rsp_len += (uint16)snprintf(rsp_string_buff + rsp_len, buff_size - rsp_len, ",");
   11406:	4a0b      	ldr	r2, [pc, #44]	; (11434 <at_handle_CGTFT_cmd_read+0x2cc>)
   11408:	f009 fa30 	bl	1a86c <snprintf>
   1140c:	e7a0      	b.n	11350 <at_handle_CGTFT_cmd_read+0x1e8>
        rsp_len += (uint16)snprintf(rsp_string_buff + rsp_len, buff_size - rsp_len, ",");
   1140e:	4a09      	ldr	r2, [pc, #36]	; (11434 <at_handle_CGTFT_cmd_read+0x2cc>)
   11410:	f009 fa2c 	bl	1a86c <snprintf>
   11414:	e7aa      	b.n	1136c <at_handle_CGTFT_cmd_read+0x204>
   11416:	46c0      	nop			; (mov r8, r8)
   11418:	00023e6f 	.word	0x00023e6f
   1141c:	000237cd 	.word	0x000237cd
   11420:	000237d5 	.word	0x000237d5
   11424:	000237da 	.word	0x000237da
   11428:	0002394e 	.word	0x0002394e
   1142c:	000237df 	.word	0x000237df
   11430:	000237e8 	.word	0x000237e8
   11434:	00024ab6 	.word	0x00024ab6

00011438 <at_handle_CRSM_cmd_test>:
   11438:	2000      	movs	r0, #0
   1143a:	4770      	bx	lr

0001143c <at_handle_NEARFCN_cmd_test>:
   1143c:	2000      	movs	r0, #0
   1143e:	4770      	bx	lr

00011440 <at_handle_CGMM_cmd_test>:
   11440:	2000      	movs	r0, #0
   11442:	4770      	bx	lr

00011444 <at_handle_CGMI_cmd_test>:
   11444:	2000      	movs	r0, #0
   11446:	4770      	bx	lr

00011448 <at_handle_CGMR_cmd_test>:
   11448:	2000      	movs	r0, #0
   1144a:	4770      	bx	lr

0001144c <at_handle_CIMI_cmd_test>:
   1144c:	2000      	movs	r0, #0
   1144e:	4770      	bx	lr

00011450 <at_handle_NRDTEST_test>:
   11450:	2000      	movs	r0, #0
   11452:	4770      	bx	lr

00011454 <at_handle_CLAC_cmd_test>:
   11454:	2000      	movs	r0, #0
   11456:	4770      	bx	lr

00011458 <at_handle_CCLK_cmd_test>:
   11458:	2000      	movs	r0, #0
   1145a:	4770      	bx	lr

0001145c <at_handle_NCCID_cmd_test>:
   1145c:	2000      	movs	r0, #0
   1145e:	4770      	bx	lr

00011460 <at_handle_NQPODCP_cmd_test>:
   11460:	2000      	movs	r0, #0
   11462:	4770      	bx	lr

00011464 <at_handle_NQPNPD_cmd_test>:
   11464:	2000      	movs	r0, #0
   11466:	4770      	bx	lr

00011468 <at_handle_CSCA_cmd_test>:
   11468:	2000      	movs	r0, #0
   1146a:	4770      	bx	lr

0001146c <at_handle_CMGS_cmd_test>:
   1146c:	2000      	movs	r0, #0
   1146e:	4770      	bx	lr

00011470 <at_handle_CMGC_cmd_test>:
   11470:	2000      	movs	r0, #0
   11472:	4770      	bx	lr

00011474 <at_handle_CEER_cmd_test>:
   11474:	2000      	movs	r0, #0
   11476:	4770      	bx	lr

00011478 <at_handle_CEDRXRDP_cmd_test>:
   11478:	2000      	movs	r0, #0
   1147a:	4770      	bx	lr

0001147c <at_handle_CNMPSD_cmd_test>:
   1147c:	2000      	movs	r0, #0
   1147e:	4770      	bx	lr

00011480 <at_handle_CPIN_cmd_test>:
   11480:	2000      	movs	r0, #0
   11482:	4770      	bx	lr

00011484 <at_handle_CPINR_cmd_test>:
   11484:	2000      	movs	r0, #0
   11486:	4770      	bx	lr

00011488 <at_handle_CCHO_cmd_test>:
   11488:	2000      	movs	r0, #0
   1148a:	4770      	bx	lr

0001148c <at_handle_CCHC_cmd_test>:
   1148c:	2000      	movs	r0, #0
   1148e:	4770      	bx	lr

00011490 <at_handle_CGLA_cmd_test>:
   11490:	2000      	movs	r0, #0
   11492:	4770      	bx	lr

00011494 <at_handle_CSIM_cmd_test>:
   11494:	2000      	movs	r0, #0
   11496:	4770      	bx	lr

00011498 <at_handle_NUICC_cmd_test>:
   11498:	2000      	movs	r0, #0
   1149a:	4770      	bx	lr

0001149c <at_handle_CSODCP_cmd_set>:
{
   1149c:	b507      	push	{r0, r1, r2, lr}
    cause = at_create_param_array(p_atparams_string, &num_recvparams, 3, 6);
   1149e:	4669      	mov	r1, sp
   114a0:	2306      	movs	r3, #6
   114a2:	2203      	movs	r2, #3
   114a4:	3107      	adds	r1, #7
   114a6:	f7f8 ff1d 	bl	a2e4 <at_create_param_array>
    if (cause != AT_RET_OK)
   114aa:	2800      	cmp	r0, #0
   114ac:	d102      	bne.n	114b4 <at_handle_CSODCP_cmd_set+0x18>
   114ae:	3001      	adds	r0, #1
   114b0:	f7ff fbec 	bl	10c8c <at_common_handle_non_ip_send_data_parse.part.15>
}
   114b4:	bd0e      	pop	{r1, r2, r3, pc}

000114b6 <at_handle_CRTDCP_cmd_set>:
{
   114b6:	b537      	push	{r0, r1, r2, r4, r5, lr}
    cause = at_create_param_array(p_atparams_string, &num_recvparams, 1, 1);
   114b8:	2301      	movs	r3, #1
   114ba:	4669      	mov	r1, sp
   114bc:	001a      	movs	r2, r3
   114be:	3105      	adds	r1, #5
   114c0:	f7f8 ff10 	bl	a2e4 <at_create_param_array>
   114c4:	1e04      	subs	r4, r0, #0
    if (cause != AT_RET_OK)
   114c6:	d10d      	bne.n	114e4 <at_handle_CRTDCP_cmd_set+0x2e>
    cause = at_get_uint16_param(AT_PARSE_FIRST_PARAM_POS, &mode, true);
   114c8:	466b      	mov	r3, sp
   114ca:	1d9d      	adds	r5, r3, #6
   114cc:	2201      	movs	r2, #1
   114ce:	0029      	movs	r1, r5
   114d0:	f7f9 f81c 	bl	a50c <at_get_uint16_param>
   114d4:	1e04      	subs	r4, r0, #0
    if (cause != AT_RET_OK || mode > AT_NON_IP_DATA_REPORT_MODE_ENABLE)
   114d6:	d107      	bne.n	114e8 <at_handle_CRTDCP_cmd_set+0x32>
   114d8:	8828      	ldrh	r0, [r5, #0]
   114da:	2801      	cmp	r0, #1
   114dc:	d804      	bhi.n	114e8 <at_handle_CRTDCP_cmd_set+0x32>
        at_set_crtdcp_mode((AT_REPORT_NON_IP_DATA_MODE)mode);
   114de:	b2c0      	uxtb	r0, r0
   114e0:	f7f7 fd72 	bl	8fc8 <at_set_crtdcp_mode>
}
   114e4:	0020      	movs	r0, r4
   114e6:	bd3e      	pop	{r1, r2, r3, r4, r5, pc}
        return AT_RET_SYNTAX_ERROR;
   114e8:	2401      	movs	r4, #1
   114ea:	e7fb      	b.n	114e4 <at_handle_CRTDCP_cmd_set+0x2e>

000114ec <at_handle_NRNPDM_cmd_set>:
{
   114ec:	b537      	push	{r0, r1, r2, r4, r5, lr}
    cause = at_create_param_array(p_atparams_string, &num_recvparams, 1, 1);
   114ee:	2301      	movs	r3, #1
   114f0:	4669      	mov	r1, sp
   114f2:	001a      	movs	r2, r3
   114f4:	3105      	adds	r1, #5
   114f6:	f7f8 fef5 	bl	a2e4 <at_create_param_array>
   114fa:	1e04      	subs	r4, r0, #0
    if (cause != AT_RET_OK)
   114fc:	d10d      	bne.n	1151a <at_handle_NRNPDM_cmd_set+0x2e>
    cause = at_get_uint16_param(AT_PARSE_FIRST_PARAM_POS, &mode, true);
   114fe:	466b      	mov	r3, sp
   11500:	1d9d      	adds	r5, r3, #6
   11502:	2201      	movs	r2, #1
   11504:	0029      	movs	r1, r5
   11506:	f7f9 f801 	bl	a50c <at_get_uint16_param>
   1150a:	1e04      	subs	r4, r0, #0
    if (cause != AT_RET_OK || mode > AT_NON_IP_DATA_REPORT_MODE_ENABLE)
   1150c:	d107      	bne.n	1151e <at_handle_NRNPDM_cmd_set+0x32>
   1150e:	8828      	ldrh	r0, [r5, #0]
   11510:	2801      	cmp	r0, #1
   11512:	d804      	bhi.n	1151e <at_handle_NRNPDM_cmd_set+0x32>
        at_set_non_ip_data_report_mode((AT_REPORT_NON_IP_DATA_MODE)mode);
   11514:	b2c0      	uxtb	r0, r0
   11516:	f7f7 fd6d 	bl	8ff4 <at_set_non_ip_data_report_mode>
}
   1151a:	0020      	movs	r0, r4
   1151c:	bd3e      	pop	{r1, r2, r3, r4, r5, pc}
        return AT_RET_SYNTAX_ERROR;
   1151e:	2401      	movs	r4, #1
   11520:	e7fb      	b.n	1151a <at_handle_NRNPDM_cmd_set+0x2e>
	...

00011524 <at_handle_CPSMS_cmd_read>:
{
   11524:	b5f0      	push	{r4, r5, r6, r7, lr}
    char               rsp_string[AT_MAX_CPSMS_READ_RSP_LEN] = {0};
   11526:	2523      	movs	r5, #35	; 0x23
{
   11528:	b08d      	sub	sp, #52	; 0x34
    char               rsp_string[AT_MAX_CPSMS_READ_RSP_LEN] = {0};
   1152a:	002a      	movs	r2, r5
   1152c:	2100      	movs	r1, #0
   1152e:	a803      	add	r0, sp, #12
   11530:	f7ee fed6 	bl	2e0 <memset>
    result = get_power_saving_mode(&mode, &requested_periodic_tau, &requested_active_time);
   11534:	270a      	movs	r7, #10
   11536:	2409      	movs	r4, #9
   11538:	230b      	movs	r3, #11
   1153a:	446f      	add	r7, sp
   1153c:	446b      	add	r3, sp
   1153e:	446c      	add	r4, sp
   11540:	001a      	movs	r2, r3
   11542:	0039      	movs	r1, r7
   11544:	0020      	movs	r0, r4
   11546:	f00a ffab 	bl	1c4a0 <get_power_saving_mode>
   1154a:	0006      	movs	r6, r0
    cause = at_parse_convert_neul_result(result);
   1154c:	f7f8 fea0 	bl	a290 <at_parse_convert_neul_result>
    if (result != NEUL_RET_OK)
   11550:	2e00      	cmp	r6, #0
   11552:	d10e      	bne.n	11572 <at_handle_CPSMS_cmd_read+0x4e>
    rsp_len = (uint16)snprintf(rsp_string, AT_MAX_CPSMS_READ_RSP_LEN, "%s%d,,,", AT_CPSMS_RSP_PREFIX, mode);
   11554:	7823      	ldrb	r3, [r4, #0]
   11556:	4a18      	ldr	r2, [pc, #96]	; (115b8 <at_handle_CPSMS_cmd_read+0x94>)
   11558:	9300      	str	r3, [sp, #0]
   1155a:	0029      	movs	r1, r5
   1155c:	4b17      	ldr	r3, [pc, #92]	; (115bc <at_handle_CPSMS_cmd_read+0x98>)
   1155e:	a803      	add	r0, sp, #12
   11560:	f009 f984 	bl	1a86c <snprintf>
    if(!at_uint8_to_binary_string(rsp_string + rsp_len, AT_8BIT_TIME_STR_LEN, requested_periodic_tau))
   11564:	ab03      	add	r3, sp, #12
    rsp_len = (uint16)snprintf(rsp_string, AT_MAX_CPSMS_READ_RSP_LEN, "%s%d,,,", AT_CPSMS_RSP_PREFIX, mode);
   11566:	0004      	movs	r4, r0
    if(!at_uint8_to_binary_string(rsp_string + rsp_len, AT_8BIT_TIME_STR_LEN, requested_periodic_tau))
   11568:	b280      	uxth	r0, r0
   1156a:	1818      	adds	r0, r3, r0
    if (str_binary == NULL)
   1156c:	2800      	cmp	r0, #0
   1156e:	d102      	bne.n	11576 <at_handle_CPSMS_cmd_read+0x52>
        return AT_RET_PROGRESS_ERROR;
   11570:	2006      	movs	r0, #6
}
   11572:	b00d      	add	sp, #52	; 0x34
   11574:	bdf0      	pop	{r4, r5, r6, r7, pc}
   11576:	783a      	ldrb	r2, [r7, #0]
   11578:	2108      	movs	r1, #8
   1157a:	f7fe fa6f 	bl	fa5c <at_uint8_to_binary_string.part.1>
    if(!at_uint8_to_binary_string(rsp_string + rsp_len, AT_8BIT_TIME_STR_LEN, requested_periodic_tau))
   1157e:	2800      	cmp	r0, #0
   11580:	d0f6      	beq.n	11570 <at_handle_CPSMS_cmd_read+0x4c>
    rsp_len += AT_8BIT_TIME_STR_LEN;
   11582:	3408      	adds	r4, #8
   11584:	b2a4      	uxth	r4, r4
    rsp_len += (uint16)snprintf(rsp_string + rsp_len, AT_MAX_CPSMS_READ_RSP_LEN - rsp_len, ",");
   11586:	ab03      	add	r3, sp, #12
   11588:	1918      	adds	r0, r3, r4
   1158a:	1b29      	subs	r1, r5, r4
   1158c:	4a0c      	ldr	r2, [pc, #48]	; (115c0 <at_handle_CPSMS_cmd_read+0x9c>)
   1158e:	f009 f96d 	bl	1a86c <snprintf>
   11592:	1820      	adds	r0, r4, r0
    if(!at_uint8_to_binary_string(rsp_string + rsp_len, AT_8BIT_TIME_STR_LEN, requested_active_time))
   11594:	b280      	uxth	r0, r0
   11596:	ab03      	add	r3, sp, #12
   11598:	1818      	adds	r0, r3, r0
    if (str_binary == NULL)
   1159a:	2800      	cmp	r0, #0
   1159c:	d0e8      	beq.n	11570 <at_handle_CPSMS_cmd_read+0x4c>
   1159e:	466b      	mov	r3, sp
   115a0:	2108      	movs	r1, #8
   115a2:	7ada      	ldrb	r2, [r3, #11]
   115a4:	f7fe fa5a 	bl	fa5c <at_uint8_to_binary_string.part.1>
    if(!at_uint8_to_binary_string(rsp_string + rsp_len, AT_8BIT_TIME_STR_LEN, requested_active_time))
   115a8:	2800      	cmp	r0, #0
   115aa:	d0e1      	beq.n	11570 <at_handle_CPSMS_cmd_read+0x4c>
    app_at_send_at_rsp_string_lines_with_claim_and_log(rsp_string);
   115ac:	a803      	add	r0, sp, #12
   115ae:	f7f8 f819 	bl	95e4 <app_at_send_at_rsp_string_lines_with_claim_and_log>
    return AT_RET_OK;
   115b2:	0030      	movs	r0, r6
   115b4:	e7dd      	b.n	11572 <at_handle_CPSMS_cmd_read+0x4e>
   115b6:	46c0      	nop			; (mov r8, r8)
   115b8:	000238f6 	.word	0x000238f6
   115bc:	000238ee 	.word	0x000238ee
   115c0:	00024ab6 	.word	0x00024ab6

000115c4 <output_cereg_print>:
{
   115c4:	b5f0      	push	{r4, r5, r6, r7, lr}
    char                rsp_string[AT_MAX_CEREG_RSP_LEN] = {0};
   115c6:	2633      	movs	r6, #51	; 0x33
{
   115c8:	b097      	sub	sp, #92	; 0x5c
   115ca:	9306      	str	r3, [sp, #24]
   115cc:	ab1c      	add	r3, sp, #112	; 0x70
   115ce:	781b      	ldrb	r3, [r3, #0]
   115d0:	9104      	str	r1, [sp, #16]
   115d2:	9307      	str	r3, [sp, #28]
   115d4:	ab1d      	add	r3, sp, #116	; 0x74
   115d6:	781d      	ldrb	r5, [r3, #0]
   115d8:	ab1e      	add	r3, sp, #120	; 0x78
   115da:	881b      	ldrh	r3, [r3, #0]
   115dc:	9205      	str	r2, [sp, #20]
   115de:	9302      	str	r3, [sp, #8]
   115e0:	ab1f      	add	r3, sp, #124	; 0x7c
   115e2:	881b      	ldrh	r3, [r3, #0]
    char                rsp_string[AT_MAX_CEREG_RSP_LEN] = {0};
   115e4:	0032      	movs	r2, r6
   115e6:	2100      	movs	r1, #0
{
   115e8:	0007      	movs	r7, r0
    char                rsp_string[AT_MAX_CEREG_RSP_LEN] = {0};
   115ea:	a809      	add	r0, sp, #36	; 0x24
{
   115ec:	9303      	str	r3, [sp, #12]
    char                rsp_string[AT_MAX_CEREG_RSP_LEN] = {0};
   115ee:	f7ee fe77 	bl	2e0 <memset>
    rsp_len = (uint16)snprintf(rsp_string, AT_MAX_CEREG_RSP_LEN, "+CEREG:");
   115f2:	4a4a      	ldr	r2, [pc, #296]	; (1171c <output_cereg_print+0x158>)
   115f4:	0031      	movs	r1, r6
   115f6:	a809      	add	r0, sp, #36	; 0x24
   115f8:	f009 f938 	bl	1a86c <snprintf>
   115fc:	b284      	uxth	r4, r0
    if (output_cereg_mode_flag)
   115fe:	2d00      	cmp	r5, #0
   11600:	d009      	beq.n	11616 <output_cereg_print+0x52>
        rsp_len += (uint16)snprintf(rsp_string + rsp_len, AT_MAX_CEREG_RSP_LEN - rsp_len, "%d,", app_at_state_info.cereg_mode);
   11602:	4b47      	ldr	r3, [pc, #284]	; (11720 <output_cereg_print+0x15c>)
   11604:	aa09      	add	r2, sp, #36	; 0x24
   11606:	1910      	adds	r0, r2, r4
   11608:	1b31      	subs	r1, r6, r4
   1160a:	781b      	ldrb	r3, [r3, #0]
   1160c:	4a45      	ldr	r2, [pc, #276]	; (11724 <output_cereg_print+0x160>)
   1160e:	f009 f92d 	bl	1a86c <snprintf>
   11612:	1824      	adds	r4, r4, r0
   11614:	b2a4      	uxth	r4, r4
    rsp_len += (uint16)snprintf(rsp_string + rsp_len, AT_MAX_CEREG_RSP_LEN - rsp_len, "%d", state);
   11616:	2633      	movs	r6, #51	; 0x33
   11618:	ab09      	add	r3, sp, #36	; 0x24
   1161a:	1918      	adds	r0, r3, r4
   1161c:	1b31      	subs	r1, r6, r4
   1161e:	003b      	movs	r3, r7
   11620:	4a41      	ldr	r2, [pc, #260]	; (11728 <output_cereg_print+0x164>)
   11622:	f009 f923 	bl	1a86c <snprintf>
    if (app_at_state_info.cereg_mode >= CEREG_MODE_ENABLE_NETWORK_REGISTRATION_LOCATION_INFORMATION)
   11626:	4b3e      	ldr	r3, [pc, #248]	; (11720 <output_cereg_print+0x15c>)
    rsp_len += (uint16)snprintf(rsp_string + rsp_len, AT_MAX_CEREG_RSP_LEN - rsp_len, "%d", state);
   11628:	1824      	adds	r4, r4, r0
    if (app_at_state_info.cereg_mode >= CEREG_MODE_ENABLE_NETWORK_REGISTRATION_LOCATION_INFORMATION)
   1162a:	781b      	ldrb	r3, [r3, #0]
    rsp_len += (uint16)snprintf(rsp_string + rsp_len, AT_MAX_CEREG_RSP_LEN - rsp_len, "%d", state);
   1162c:	b2a7      	uxth	r7, r4
    if (app_at_state_info.cereg_mode >= CEREG_MODE_ENABLE_NETWORK_REGISTRATION_LOCATION_INFORMATION)
   1162e:	2b01      	cmp	r3, #1
   11630:	d90c      	bls.n	1164c <output_cereg_print+0x88>
        rsp_len += (uint16)snprintf(rsp_string + rsp_len, AT_MAX_CEREG_RSP_LEN - rsp_len, ",%04X,%08X,%d", tac, ci, ACT_VALUE_E_UTRAN_NB_S1_MODE);
   11632:	ab09      	add	r3, sp, #36	; 0x24
   11634:	19d8      	adds	r0, r3, r7
   11636:	2309      	movs	r3, #9
   11638:	9301      	str	r3, [sp, #4]
   1163a:	9b05      	ldr	r3, [sp, #20]
   1163c:	1bf1      	subs	r1, r6, r7
   1163e:	9300      	str	r3, [sp, #0]
   11640:	4a3a      	ldr	r2, [pc, #232]	; (1172c <output_cereg_print+0x168>)
   11642:	9b04      	ldr	r3, [sp, #16]
   11644:	f009 f912 	bl	1a86c <snprintf>
   11648:	183f      	adds	r7, r7, r0
   1164a:	b2bf      	uxth	r7, r7
    if ( app_at_state_info.cereg_mode == CEREG_MODE_ENABLE_NETWORK_REGISTRATION_LOCATION_INFORMATION_EMM_CAUSE
   1164c:	21fd      	movs	r1, #253	; 0xfd
   1164e:	4b34      	ldr	r3, [pc, #208]	; (11720 <output_cereg_print+0x15c>)
   11650:	781a      	ldrb	r2, [r3, #0]
   11652:	1ed3      	subs	r3, r2, #3
   11654:	400b      	ands	r3, r1
   11656:	d119      	bne.n	1168c <output_cereg_print+0xc8>
   11658:	aa09      	add	r2, sp, #36	; 0x24
   1165a:	19d0      	adds	r0, r2, r7
        if (reject_flag)
   1165c:	9a06      	ldr	r2, [sp, #24]
   1165e:	39ca      	subs	r1, #202	; 0xca
   11660:	1bc9      	subs	r1, r1, r7
   11662:	2a00      	cmp	r2, #0
   11664:	d018      	beq.n	11698 <output_cereg_print+0xd4>
            rsp_len += (uint16)snprintf(rsp_string + rsp_len, AT_MAX_CEREG_RSP_LEN - rsp_len, ",%d,%d", AT_CEREG_CAUSE_TYPE_OFFICIAL, reject_cause);
   11666:	9a07      	ldr	r2, [sp, #28]
   11668:	9200      	str	r2, [sp, #0]
   1166a:	4a31      	ldr	r2, [pc, #196]	; (11730 <output_cereg_print+0x16c>)
   1166c:	f009 f8fe 	bl	1a86c <snprintf>
        rsp_len += (uint16)snprintf(rsp_string + rsp_len, AT_MAX_CEREG_RSP_LEN - rsp_len, ",,");
   11670:	183f      	adds	r7, r7, r0
   11672:	b2bf      	uxth	r7, r7
    if ( app_at_state_info.cereg_mode == CEREG_MODE_PSM_ENABLE_NETWORK_REGISTRATION_LOCATION_INFORMATION
   11674:	4b2a      	ldr	r3, [pc, #168]	; (11720 <output_cereg_print+0x15c>)
      || app_at_state_info.cereg_mode == CEREG_MODE_PSM_ENABLE_NETWORK_REGISTRATION_LOCATION_INFORMATION_EMM_CAUSE)
   11676:	781b      	ldrb	r3, [r3, #0]
    if ( app_at_state_info.cereg_mode == CEREG_MODE_PSM_ENABLE_NETWORK_REGISTRATION_LOCATION_INFORMATION
   11678:	3b04      	subs	r3, #4
   1167a:	2b01      	cmp	r3, #1
   1167c:	d910      	bls.n	116a0 <output_cereg_print+0xdc>
    if (output_cereg_mode_flag)
   1167e:	2d00      	cmp	r5, #0
   11680:	d044      	beq.n	1170c <output_cereg_print+0x148>
        app_at_send_at_rsp_string_lines_with_claim_and_log_restricted(rsp_string);
   11682:	a809      	add	r0, sp, #36	; 0x24
   11684:	f7f7 ffb5 	bl	95f2 <app_at_send_at_rsp_string_lines_with_claim_and_log_restricted>
    return AT_RET_OK;
   11688:	2000      	movs	r0, #0
   1168a:	e01c      	b.n	116c6 <output_cereg_print+0x102>
    else if (app_at_state_info.cereg_mode == CEREG_MODE_PSM_ENABLE_NETWORK_REGISTRATION_LOCATION_INFORMATION)
   1168c:	2a04      	cmp	r2, #4
   1168e:	d1f1      	bne.n	11674 <output_cereg_print+0xb0>
        rsp_len += (uint16)snprintf(rsp_string + rsp_len, AT_MAX_CEREG_RSP_LEN - rsp_len, ",,");
   11690:	2133      	movs	r1, #51	; 0x33
   11692:	ab09      	add	r3, sp, #36	; 0x24
   11694:	1bc9      	subs	r1, r1, r7
   11696:	19d8      	adds	r0, r3, r7
   11698:	4a26      	ldr	r2, [pc, #152]	; (11734 <output_cereg_print+0x170>)
   1169a:	f009 f8e7 	bl	1a86c <snprintf>
   1169e:	e7e7      	b.n	11670 <output_cereg_print+0xac>
        rsp_len += (uint16)snprintf(rsp_string + rsp_len, AT_MAX_CEREG_RSP_LEN - rsp_len, ",");
   116a0:	2133      	movs	r1, #51	; 0x33
   116a2:	4e25      	ldr	r6, [pc, #148]	; (11738 <output_cereg_print+0x174>)
   116a4:	ab09      	add	r3, sp, #36	; 0x24
   116a6:	19d8      	adds	r0, r3, r7
   116a8:	1bc9      	subs	r1, r1, r7
   116aa:	0032      	movs	r2, r6
   116ac:	f009 f8de 	bl	1a86c <snprintf>
        if (active_time != 0xFFFF)
   116b0:	4c22      	ldr	r4, [pc, #136]	; (1173c <output_cereg_print+0x178>)
   116b2:	9b02      	ldr	r3, [sp, #8]
        rsp_len += (uint16)snprintf(rsp_string + rsp_len, AT_MAX_CEREG_RSP_LEN - rsp_len, ",");
   116b4:	183f      	adds	r7, r7, r0
   116b6:	b2bf      	uxth	r7, r7
        if (active_time != 0xFFFF)
   116b8:	42a3      	cmp	r3, r4
   116ba:	d00f      	beq.n	116dc <output_cereg_print+0x118>
   116bc:	ab09      	add	r3, sp, #36	; 0x24
   116be:	19d8      	adds	r0, r3, r7
    if (str_binary == NULL)
   116c0:	2800      	cmp	r0, #0
   116c2:	d102      	bne.n	116ca <output_cereg_print+0x106>
                return AT_RET_PROGRESS_ERROR;
   116c4:	2006      	movs	r0, #6
}
   116c6:	b017      	add	sp, #92	; 0x5c
   116c8:	bdf0      	pop	{r4, r5, r6, r7, pc}
   116ca:	466b      	mov	r3, sp
   116cc:	2108      	movs	r1, #8
   116ce:	7a1a      	ldrb	r2, [r3, #8]
   116d0:	f7fe f9c4 	bl	fa5c <at_uint8_to_binary_string.part.1>
            if(!at_uint8_to_binary_string(rsp_string + rsp_len, AT_8BIT_TIME_STR_LEN, (uint8)active_time))
   116d4:	2800      	cmp	r0, #0
   116d6:	d0f5      	beq.n	116c4 <output_cereg_print+0x100>
            rsp_len += AT_8BIT_TIME_STR_LEN;
   116d8:	3708      	adds	r7, #8
   116da:	b2bf      	uxth	r7, r7
        rsp_len += (uint16)snprintf(rsp_string + rsp_len, AT_MAX_CEREG_RSP_LEN - rsp_len, ",");
   116dc:	2133      	movs	r1, #51	; 0x33
   116de:	ab09      	add	r3, sp, #36	; 0x24
   116e0:	19d8      	adds	r0, r3, r7
   116e2:	1bc9      	subs	r1, r1, r7
   116e4:	0032      	movs	r2, r6
   116e6:	f009 f8c1 	bl	1a86c <snprintf>
        if (periodic_tau != 0xFFFF)
   116ea:	9b03      	ldr	r3, [sp, #12]
   116ec:	42a3      	cmp	r3, r4
   116ee:	d0c6      	beq.n	1167e <output_cereg_print+0xba>
        rsp_len += (uint16)snprintf(rsp_string + rsp_len, AT_MAX_CEREG_RSP_LEN - rsp_len, ",");
   116f0:	1838      	adds	r0, r7, r0
            if(!at_uint8_to_binary_string(rsp_string + rsp_len, AT_8BIT_TIME_STR_LEN, (uint8)periodic_tau))
   116f2:	b280      	uxth	r0, r0
   116f4:	ab09      	add	r3, sp, #36	; 0x24
   116f6:	1818      	adds	r0, r3, r0
    if (str_binary == NULL)
   116f8:	2800      	cmp	r0, #0
   116fa:	d0e3      	beq.n	116c4 <output_cereg_print+0x100>
   116fc:	466b      	mov	r3, sp
   116fe:	2108      	movs	r1, #8
   11700:	7b1a      	ldrb	r2, [r3, #12]
   11702:	f7fe f9ab 	bl	fa5c <at_uint8_to_binary_string.part.1>
            if(!at_uint8_to_binary_string(rsp_string + rsp_len, AT_8BIT_TIME_STR_LEN, (uint8)periodic_tau))
   11706:	2800      	cmp	r0, #0
   11708:	d1b9      	bne.n	1167e <output_cereg_print+0xba>
   1170a:	e7db      	b.n	116c4 <output_cereg_print+0x100>
        delayed_async_print(rsp_string, AT_FLAG_LOGABLE | AT_FLAG_LOG_RESTRICTED, 0, 0);
   1170c:	a809      	add	r0, sp, #36	; 0x24
   1170e:	002b      	movs	r3, r5
   11710:	002a      	movs	r2, r5
   11712:	2128      	movs	r1, #40	; 0x28
   11714:	f7f9 fad2 	bl	acbc <delayed_async_print>
    return AT_RET_OK;
   11718:	0028      	movs	r0, r5
   1171a:	e7d4      	b.n	116c6 <output_cereg_print+0x102>
   1171c:	000248c0 	.word	0x000248c0
   11720:	010024c2 	.word	0x010024c2
   11724:	000234e4 	.word	0x000234e4
   11728:	00022e8f 	.word	0x00022e8f
   1172c:	000248c8 	.word	0x000248c8
   11730:	00023734 	.word	0x00023734
   11734:	000238fb 	.word	0x000238fb
   11738:	00024ab6 	.word	0x00024ab6
   1173c:	0000ffff 	.word	0x0000ffff

00011740 <output_cereg_info>:
{
   11740:	b5f0      	push	{r4, r5, r6, r7, lr}
    uint8               state = 0;
   11742:	2513      	movs	r5, #19
{
   11744:	b08b      	sub	sp, #44	; 0x2c
    uint8               state = 0;
   11746:	ab02      	add	r3, sp, #8
    uint16              tac = 0;
   11748:	2616      	movs	r6, #22
    uint8               state = 0;
   1174a:	18ed      	adds	r5, r5, r3
   1174c:	2300      	movs	r3, #0
    uint16              tac = 0;
   1174e:	aa02      	add	r2, sp, #8
   11750:	18b6      	adds	r6, r6, r2
    bool                reject_flag = false;
   11752:	af07      	add	r7, sp, #28
    EMM_CAUSE_INFO      reject_cause = EMM_CAUSE_INFO_UNKNOWN;
   11754:	2415      	movs	r4, #21
    uint16             active_time=0;
   11756:	8313      	strh	r3, [r2, #24]
    uint16             periodic_tau=0;
   11758:	8353      	strh	r3, [r2, #26]
    uint8               state = 0;
   1175a:	702b      	strb	r3, [r5, #0]
    uint16              tac = 0;
   1175c:	8033      	strh	r3, [r6, #0]
    bool                reject_flag = false;
   1175e:	703b      	strb	r3, [r7, #0]
    uint32              ci =0;
   11760:	9309      	str	r3, [sp, #36]	; 0x24
    EMM_CAUSE_INFO      reject_cause = EMM_CAUSE_INFO_UNKNOWN;
   11762:	23ff      	movs	r3, #255	; 0xff
   11764:	18a4      	adds	r4, r4, r2
   11766:	7023      	strb	r3, [r4, #0]
    if (get_registration_status(&state, &tac, &ci, &reject_flag, &reject_cause, &active_time, &periodic_tau) != NEUL_RET_OK)
   11768:	3be5      	subs	r3, #229	; 0xe5
   1176a:	189b      	adds	r3, r3, r2
   1176c:	9302      	str	r3, [sp, #8]
   1176e:	ab08      	add	r3, sp, #32
{
   11770:	9005      	str	r0, [sp, #20]
    if (get_registration_status(&state, &tac, &ci, &reject_flag, &reject_cause, &active_time, &periodic_tau) != NEUL_RET_OK)
   11772:	9301      	str	r3, [sp, #4]
   11774:	9400      	str	r4, [sp, #0]
   11776:	003b      	movs	r3, r7
   11778:	aa09      	add	r2, sp, #36	; 0x24
   1177a:	0031      	movs	r1, r6
   1177c:	0028      	movs	r0, r5
   1177e:	f00a fcef 	bl	1c160 <get_registration_status>
   11782:	0003      	movs	r3, r0
        return AT_RET_PROGRESS_ERROR;
   11784:	2006      	movs	r0, #6
    if (get_registration_status(&state, &tac, &ci, &reject_flag, &reject_cause, &active_time, &periodic_tau) != NEUL_RET_OK)
   11786:	2b00      	cmp	r3, #0
   11788:	d10f      	bne.n	117aa <output_cereg_info+0x6a>
    rc = output_cereg_print(state,tac,ci,reject_flag,reject_cause,output_cereg_mode_flag,active_time,periodic_tau);
   1178a:	aa02      	add	r2, sp, #8
   1178c:	8b52      	ldrh	r2, [r2, #26]
   1178e:	783b      	ldrb	r3, [r7, #0]
   11790:	8831      	ldrh	r1, [r6, #0]
   11792:	7828      	ldrb	r0, [r5, #0]
   11794:	9203      	str	r2, [sp, #12]
   11796:	aa02      	add	r2, sp, #8
   11798:	8b12      	ldrh	r2, [r2, #24]
   1179a:	9202      	str	r2, [sp, #8]
   1179c:	9a05      	ldr	r2, [sp, #20]
   1179e:	9201      	str	r2, [sp, #4]
   117a0:	7822      	ldrb	r2, [r4, #0]
   117a2:	9200      	str	r2, [sp, #0]
   117a4:	9a09      	ldr	r2, [sp, #36]	; 0x24
   117a6:	f7ff ff0d 	bl	115c4 <output_cereg_print>
}
   117aa:	b00b      	add	sp, #44	; 0x2c
   117ac:	bdf0      	pop	{r4, r5, r6, r7, pc}

000117ae <at_handle_CEREG_cmd_read>:
{
   117ae:	b510      	push	{r4, lr}
    (void)output_cereg_info(true);
   117b0:	2001      	movs	r0, #1
   117b2:	f7ff ffc5 	bl	11740 <output_cereg_info>
}
   117b6:	2000      	movs	r0, #0
   117b8:	bd10      	pop	{r4, pc}
	...

000117bc <service_status_callback>:
{
   117bc:	b510      	push	{r4, lr}
   117be:	b088      	sub	sp, #32
   117c0:	0004      	movs	r4, r0
    char        rsp_string[AT_MAX_CEREG_IND_LEN] = {0};
   117c2:	221e      	movs	r2, #30
   117c4:	2100      	movs	r1, #0
   117c6:	4668      	mov	r0, sp
   117c8:	f7ee fd8a 	bl	2e0 <memset>
    if (app_at_state_info.cereg_mode == CEREG_MODE_ENABLE_NETWORK_REGISTRATION_UNSOLICITED_RESULT)
   117cc:	4b0a      	ldr	r3, [pc, #40]	; (117f8 <service_status_callback+0x3c>)
   117ce:	781b      	ldrb	r3, [r3, #0]
   117d0:	2b01      	cmp	r3, #1
   117d2:	d10d      	bne.n	117f0 <service_status_callback+0x34>
        (void)snprintf(rsp_string, AT_MAX_CEREG_IND_LEN, "+CEREG:%d", service_status);
   117d4:	0023      	movs	r3, r4
   117d6:	4a09      	ldr	r2, [pc, #36]	; (117fc <service_status_callback+0x40>)
   117d8:	211e      	movs	r1, #30
   117da:	4668      	mov	r0, sp
   117dc:	f009 f846 	bl	1a86c <snprintf>
        delayed_async_print(rsp_string, AT_FLAG_LOGABLE, 0, 0);
   117e0:	2300      	movs	r3, #0
   117e2:	2108      	movs	r1, #8
   117e4:	001a      	movs	r2, r3
   117e6:	4668      	mov	r0, sp
   117e8:	f7f9 fa68 	bl	acbc <delayed_async_print>
}
   117ec:	b008      	add	sp, #32
   117ee:	bd10      	pop	{r4, pc}
        (void)output_cereg_info(false);
   117f0:	2000      	movs	r0, #0
   117f2:	f7ff ffa5 	bl	11740 <output_cereg_info>
}
   117f6:	e7f9      	b.n	117ec <service_status_callback+0x30>
   117f8:	010024c2 	.word	0x010024c2
   117fc:	0002494b 	.word	0x0002494b

00011800 <t3324_t3412_ext_value_callback>:
{
   11800:	b5f0      	push	{r4, r5, r6, r7, lr}
        uint8               state = 0;
   11802:	2513      	movs	r5, #19
{
   11804:	b08b      	sub	sp, #44	; 0x2c
   11806:	9105      	str	r1, [sp, #20]
        uint8               state = 0;
   11808:	ab02      	add	r3, sp, #8
        uint16              tac = 0;
   1180a:	2616      	movs	r6, #22
        uint16             periodic_tau=0;
   1180c:	211a      	movs	r1, #26
        uint8               state = 0;
   1180e:	18ed      	adds	r5, r5, r3
   11810:	2300      	movs	r3, #0
{
   11812:	9004      	str	r0, [sp, #16]
        uint16              tac = 0;
   11814:	aa02      	add	r2, sp, #8
        uint16             periodic_tau=0;
   11816:	a802      	add	r0, sp, #8
   11818:	1809      	adds	r1, r1, r0
        uint16              tac = 0;
   1181a:	18b6      	adds	r6, r6, r2
        bool                reject_flag = false;
   1181c:	af07      	add	r7, sp, #28
        uint16             active_time=0;
   1181e:	aa08      	add	r2, sp, #32
        EMM_CAUSE_INFO      reject_cause = EMM_CAUSE_INFO_UNKNOWN;
   11820:	2415      	movs	r4, #21
        uint16             active_time=0;
   11822:	8013      	strh	r3, [r2, #0]
        uint16             periodic_tau=0;
   11824:	800b      	strh	r3, [r1, #0]
        uint8               state = 0;
   11826:	702b      	strb	r3, [r5, #0]
        uint16              tac = 0;
   11828:	8033      	strh	r3, [r6, #0]
        bool                reject_flag = false;
   1182a:	703b      	strb	r3, [r7, #0]
        uint32              ci =0;
   1182c:	9309      	str	r3, [sp, #36]	; 0x24
        EMM_CAUSE_INFO      reject_cause = EMM_CAUSE_INFO_UNKNOWN;
   1182e:	23ff      	movs	r3, #255	; 0xff
   11830:	1824      	adds	r4, r4, r0
   11832:	7023      	strb	r3, [r4, #0]
        if (get_registration_status(&state, &tac, &ci, &reject_flag, &reject_cause, &active_time, &periodic_tau) != NEUL_RET_OK)
   11834:	0028      	movs	r0, r5
   11836:	9102      	str	r1, [sp, #8]
   11838:	9201      	str	r2, [sp, #4]
   1183a:	9400      	str	r4, [sp, #0]
   1183c:	aa09      	add	r2, sp, #36	; 0x24
   1183e:	003b      	movs	r3, r7
   11840:	0031      	movs	r1, r6
   11842:	f00a fc8d 	bl	1c160 <get_registration_status>
   11846:	1e02      	subs	r2, r0, #0
   11848:	d10c      	bne.n	11864 <t3324_t3412_ext_value_callback+0x64>
       (void)output_cereg_print(state,tac,ci,reject_flag,reject_cause,false,t3324,t3412_ext);
   1184a:	7828      	ldrb	r0, [r5, #0]
   1184c:	9d05      	ldr	r5, [sp, #20]
   1184e:	783b      	ldrb	r3, [r7, #0]
   11850:	8831      	ldrh	r1, [r6, #0]
   11852:	9503      	str	r5, [sp, #12]
   11854:	9d04      	ldr	r5, [sp, #16]
   11856:	9201      	str	r2, [sp, #4]
   11858:	9502      	str	r5, [sp, #8]
   1185a:	7822      	ldrb	r2, [r4, #0]
   1185c:	9200      	str	r2, [sp, #0]
   1185e:	9a09      	ldr	r2, [sp, #36]	; 0x24
   11860:	f7ff feb0 	bl	115c4 <output_cereg_print>
}
   11864:	b00b      	add	sp, #44	; 0x2c
   11866:	bdf0      	pop	{r4, r5, r6, r7, pc}

00011868 <at_handle_CCLK_cmd_read>:
{
   11868:	b570      	push	{r4, r5, r6, lr}
    char     rsp_string[AT_MAX_CCLK_RSP_LEN]           = {0};
   1186a:	251c      	movs	r5, #28
{
   1186c:	b08c      	sub	sp, #48	; 0x30
    char     rsp_string[AT_MAX_CCLK_RSP_LEN]           = {0};
   1186e:	002a      	movs	r2, r5
   11870:	2100      	movs	r1, #0
   11872:	a805      	add	r0, sp, #20
   11874:	f7ee fd34 	bl	2e0 <memset>
    current_time = get_current_time();
   11878:	f006 ff6a 	bl	18750 <get_current_time>
        return AT_RET_OK;
   1187c:	2300      	movs	r3, #0
    current_time = get_current_time();
   1187e:	9004      	str	r0, [sp, #16]
    if(current_time == 0)
   11880:	4298      	cmp	r0, r3
   11882:	d037      	beq.n	118f4 <at_handle_CCLK_cmd_read+0x8c>
    tmFmtDatetime = gmtime(&current_time);
   11884:	a804      	add	r0, sp, #16
   11886:	f009 fe1f 	bl	1b4c8 <gmtime>
        return AT_RET_PROGRESS_ERROR;
   1188a:	2306      	movs	r3, #6
    tmFmtDatetime = gmtime(&current_time);
   1188c:	1e06      	subs	r6, r0, #0
    if (tmFmtDatetime == NULL)
   1188e:	d031      	beq.n	118f4 <at_handle_CCLK_cmd_read+0x8c>
    rsp_len = (uint8)snprintf(rsp_string, AT_MAX_CCLK_RSP_LEN, "+CCLK:%02d/",
   11890:	6940      	ldr	r0, [r0, #20]
   11892:	2164      	movs	r1, #100	; 0x64
   11894:	f7ee ff00 	bl	698 <__aeabi_idivmod>
   11898:	4a1a      	ldr	r2, [pc, #104]	; (11904 <at_handle_CCLK_cmd_read+0x9c>)
   1189a:	000b      	movs	r3, r1
   1189c:	a805      	add	r0, sp, #20
   1189e:	0029      	movs	r1, r5
   118a0:	f008 ffe4 	bl	1a86c <snprintf>
    rsp_len += add_mon_day_hour_min_sec_to_string(tmFmtDatetime, rsp_string + rsp_len, AT_MAX_CCLK_RSP_LEN - rsp_len);
   118a4:	aa05      	add	r2, sp, #20
    rsp_len = (uint8)snprintf(rsp_string, AT_MAX_CCLK_RSP_LEN, "+CCLK:%02d/",
   118a6:	b2c4      	uxtb	r4, r0
    rsp_len += add_mon_day_hour_min_sec_to_string(tmFmtDatetime, rsp_string + rsp_len, AT_MAX_CCLK_RSP_LEN - rsp_len);
   118a8:	b2c0      	uxtb	r0, r0
   118aa:	1810      	adds	r0, r2, r0
    return (uint8)snprintf(string, max_len, "%02d/%02d,%02d:%02d:%02d",
   118ac:	6832      	ldr	r2, [r6, #0]
   118ae:	6933      	ldr	r3, [r6, #16]
   118b0:	9203      	str	r2, [sp, #12]
   118b2:	6872      	ldr	r2, [r6, #4]
    rsp_len += add_mon_day_hour_min_sec_to_string(tmFmtDatetime, rsp_string + rsp_len, AT_MAX_CCLK_RSP_LEN - rsp_len);
   118b4:	1b29      	subs	r1, r5, r4
    return (uint8)snprintf(string, max_len, "%02d/%02d,%02d:%02d:%02d",
   118b6:	9202      	str	r2, [sp, #8]
   118b8:	68b2      	ldr	r2, [r6, #8]
   118ba:	3301      	adds	r3, #1
   118bc:	9201      	str	r2, [sp, #4]
   118be:	68f2      	ldr	r2, [r6, #12]
   118c0:	b289      	uxth	r1, r1
   118c2:	9200      	str	r2, [sp, #0]
   118c4:	4a10      	ldr	r2, [pc, #64]	; (11908 <at_handle_CCLK_cmd_read+0xa0>)
   118c6:	f008 ffd1 	bl	1a86c <snprintf>
    rsp_len += add_mon_day_hour_min_sec_to_string(tmFmtDatetime, rsp_string + rsp_len, AT_MAX_CCLK_RSP_LEN - rsp_len);
   118ca:	1824      	adds	r4, r4, r0
    if (rtc_get_time_zone() >= 0)
   118cc:	f006 ff50 	bl	18770 <rtc_get_time_zone>
    rsp_len += add_mon_day_hour_min_sec_to_string(tmFmtDatetime, rsp_string + rsp_len, AT_MAX_CCLK_RSP_LEN - rsp_len);
   118d0:	b2e4      	uxtb	r4, r4
   118d2:	ab05      	add	r3, sp, #20
   118d4:	191e      	adds	r6, r3, r4
   118d6:	1b2c      	subs	r4, r5, r4
    if (rtc_get_time_zone() >= 0)
   118d8:	2800      	cmp	r0, #0
   118da:	db0e      	blt.n	118fa <at_handle_CCLK_cmd_read+0x92>
        (void)snprintf(rsp_string + rsp_len, AT_MAX_CCLK_RSP_LEN - rsp_len, "+%02d", rtc_get_time_zone());
   118dc:	f006 ff48 	bl	18770 <rtc_get_time_zone>
   118e0:	0003      	movs	r3, r0
   118e2:	4a0a      	ldr	r2, [pc, #40]	; (1190c <at_handle_CCLK_cmd_read+0xa4>)
        (void)snprintf(rsp_string + rsp_len, AT_MAX_CCLK_RSP_LEN - rsp_len, "-%02d", -rtc_get_time_zone());
   118e4:	0021      	movs	r1, r4
   118e6:	0030      	movs	r0, r6
   118e8:	f008 ffc0 	bl	1a86c <snprintf>
    app_at_send_at_rsp_string_lines_with_claim_and_log(rsp_string);
   118ec:	a805      	add	r0, sp, #20
   118ee:	f7f7 fe79 	bl	95e4 <app_at_send_at_rsp_string_lines_with_claim_and_log>
    return AT_RET_OK;
   118f2:	2300      	movs	r3, #0
}
   118f4:	0018      	movs	r0, r3
   118f6:	b00c      	add	sp, #48	; 0x30
   118f8:	bd70      	pop	{r4, r5, r6, pc}
        (void)snprintf(rsp_string + rsp_len, AT_MAX_CCLK_RSP_LEN - rsp_len, "-%02d", -rtc_get_time_zone());
   118fa:	f006 ff39 	bl	18770 <rtc_get_time_zone>
   118fe:	4a04      	ldr	r2, [pc, #16]	; (11910 <at_handle_CCLK_cmd_read+0xa8>)
   11900:	4243      	negs	r3, r0
   11902:	e7ef      	b.n	118e4 <at_handle_CCLK_cmd_read+0x7c>
   11904:	000235c7 	.word	0x000235c7
   11908:	00023f88 	.word	0x00023f88
   1190c:	00023f74 	.word	0x00023f74
   11910:	00023f7a 	.word	0x00023f7a

00011914 <at_socket_status_callback>:
{
   11914:	b570      	push	{r4, r5, r6, lr}
   11916:	b088      	sub	sp, #32
   11918:	000e      	movs	r6, r1
   1191a:	0004      	movs	r4, r0
   1191c:	0015      	movs	r5, r2
    char rsp_string[SOCK_CLOSE_RSP_LEN] = {0};
   1191e:	2100      	movs	r1, #0
   11920:	220c      	movs	r2, #12
   11922:	a805      	add	r0, sp, #20
   11924:	f7ee fcdc 	bl	2e0 <memset>
    switch (status)
   11928:	2e07      	cmp	r6, #7
   1192a:	d80f      	bhi.n	1194c <at_socket_status_callback+0x38>
   1192c:	0030      	movs	r0, r6
   1192e:	f7ee fd39 	bl	3a4 <__gnu_thumb1_case_uqi>
   11932:	0f04      	.short	0x0f04
   11934:	25221e1a 	.word	0x25221e1a
   11938:	3d32      	.short	0x3d32
            APP_AT_NORMAL("Socket %d had connected", sock_num);
   1193a:	4b1e      	ldr	r3, [pc, #120]	; (119b4 <at_socket_status_callback+0xa0>)
   1193c:	9401      	str	r4, [sp, #4]
            APP_AT_NORMAL("Socket %d had closed by server", sock_num);
   1193e:	9300      	str	r3, [sp, #0]
   11940:	2300      	movs	r3, #0
   11942:	2101      	movs	r1, #1
   11944:	001a      	movs	r2, r3
   11946:	2008      	movs	r0, #8
   11948:	f7f4 ff1e 	bl	6788 <log_event_string>
}
   1194c:	b008      	add	sp, #32
   1194e:	bd70      	pop	{r4, r5, r6, pc}
            APP_AT_NORMAL("Socket %d had acked %d bytes", sock_num, arg);
   11950:	4b19      	ldr	r3, [pc, #100]	; (119b8 <at_socket_status_callback+0xa4>)
   11952:	9502      	str	r5, [sp, #8]
   11954:	9401      	str	r4, [sp, #4]
            APP_AT_NORMAL("Socket %d dropped %d bytes data due to cache full", sock_num, arg);
   11956:	9300      	str	r3, [sp, #0]
   11958:	2300      	movs	r3, #0
   1195a:	2101      	movs	r1, #1
   1195c:	001a      	movs	r2, r3
   1195e:	2008      	movs	r0, #8
   11960:	f7f4 ff12 	bl	6788 <log_event_string>
}
   11964:	e7f2      	b.n	1194c <at_socket_status_callback+0x38>
            APP_AT_NORMAL("Socket %d had recved %d bytes", sock_num, arg);
   11966:	9502      	str	r5, [sp, #8]
   11968:	9401      	str	r4, [sp, #4]
   1196a:	4b14      	ldr	r3, [pc, #80]	; (119bc <at_socket_status_callback+0xa8>)
   1196c:	e7f3      	b.n	11956 <at_socket_status_callback+0x42>
            APP_AT_NORMAL("Socket %d had closed by err %d", sock_num, arg);
   1196e:	9502      	str	r5, [sp, #8]
   11970:	9401      	str	r4, [sp, #4]
   11972:	4b13      	ldr	r3, [pc, #76]	; (119c0 <at_socket_status_callback+0xac>)
   11974:	e7ef      	b.n	11956 <at_socket_status_callback+0x42>
            APP_AT_NORMAL("Socket %d had closed by server", sock_num);
   11976:	9401      	str	r4, [sp, #4]
   11978:	4b12      	ldr	r3, [pc, #72]	; (119c4 <at_socket_status_callback+0xb0>)
   1197a:	e7e0      	b.n	1193e <at_socket_status_callback+0x2a>
            (void)snprintf(rsp_string, SOCK_CLOSE_RSP_LEN, "%s %d", SOCK_CLOSE_PREFIX_STR, sock_num);
   1197c:	4b12      	ldr	r3, [pc, #72]	; (119c8 <at_socket_status_callback+0xb4>)
   1197e:	4a13      	ldr	r2, [pc, #76]	; (119cc <at_socket_status_callback+0xb8>)
   11980:	210c      	movs	r1, #12
   11982:	9400      	str	r4, [sp, #0]
   11984:	a805      	add	r0, sp, #20
   11986:	f008 ff71 	bl	1a86c <snprintf>
            delayed_async_print(rsp_string, AT_FLAG_LOGABLE, 0, 0);
   1198a:	2300      	movs	r3, #0
   1198c:	2108      	movs	r1, #8
   1198e:	001a      	movs	r2, r3
   11990:	a805      	add	r0, sp, #20
   11992:	f7f9 f993 	bl	acbc <delayed_async_print>
    if (sock_num < BITS_IN_WORD)
   11996:	b2a3      	uxth	r3, r4
   11998:	2b1f      	cmp	r3, #31
   1199a:	d8d7      	bhi.n	1194c <at_socket_status_callback+0x38>
        sock_at_allocated &= ~((uint32) 1 << sock_num);
   1199c:	001c      	movs	r4, r3
   1199e:	2301      	movs	r3, #1
   119a0:	40a3      	lsls	r3, r4
   119a2:	4a0b      	ldr	r2, [pc, #44]	; (119d0 <at_socket_status_callback+0xbc>)
   119a4:	6811      	ldr	r1, [r2, #0]
   119a6:	4399      	bics	r1, r3
   119a8:	6011      	str	r1, [r2, #0]
   119aa:	e7cf      	b.n	1194c <at_socket_status_callback+0x38>
            APP_AT_NORMAL("Socket %d dropped %d bytes data due to cache full", sock_num, arg);
   119ac:	9502      	str	r5, [sp, #8]
   119ae:	9401      	str	r4, [sp, #4]
   119b0:	4b08      	ldr	r3, [pc, #32]	; (119d4 <at_socket_status_callback+0xc0>)
   119b2:	e7d0      	b.n	11956 <at_socket_status_callback+0x42>
   119b4:	00023e8b 	.word	0x00023e8b
   119b8:	00023ea3 	.word	0x00023ea3
   119bc:	00023ec0 	.word	0x00023ec0
   119c0:	00023ede 	.word	0x00023ede
   119c4:	00023efd 	.word	0x00023efd
   119c8:	00023f1c 	.word	0x00023f1c
   119cc:	00023f25 	.word	0x00023f25
   119d0:	010024c8 	.word	0x010024c8
   119d4:	00023f2b 	.word	0x00023f2b

000119d8 <psm_status_callback>:
{
   119d8:	b510      	push	{r4, lr}
    app_at_state_info.npsmr_state = (NPSMR_STATE_ENUM)psm_status;
   119da:	4b0d      	ldr	r3, [pc, #52]	; (11a10 <psm_status_callback+0x38>)
{
   119dc:	b086      	sub	sp, #24
    app_at_state_info.npsmr_state = (NPSMR_STATE_ENUM)psm_status;
   119de:	70d8      	strb	r0, [r3, #3]
    if (app_at_state_info.npsmr_mode == NPSMR_MODE_ENUM_ENABLE_REPORT)
   119e0:	791b      	ldrb	r3, [r3, #4]
{
   119e2:	0004      	movs	r4, r0
    if (app_at_state_info.npsmr_mode == NPSMR_MODE_ENUM_ENABLE_REPORT)
   119e4:	2b01      	cmp	r3, #1
   119e6:	d111      	bne.n	11a0c <psm_status_callback+0x34>
        char auc_rsp_data[AT_MAX_NPSMR_REPORTING_LEN]  = {0};
   119e8:	2209      	movs	r2, #9
   119ea:	2100      	movs	r1, #0
   119ec:	a803      	add	r0, sp, #12
   119ee:	f7ee fc77 	bl	2e0 <memset>
        (void)snprintf(auc_rsp_data, AT_MAX_NPSMR_REPORTING_LEN, "%s%d",AT_CMD_NPSMR_PREFIX,  psm_status);
   119f2:	4b08      	ldr	r3, [pc, #32]	; (11a14 <psm_status_callback+0x3c>)
   119f4:	4a08      	ldr	r2, [pc, #32]	; (11a18 <psm_status_callback+0x40>)
   119f6:	2109      	movs	r1, #9
   119f8:	9400      	str	r4, [sp, #0]
   119fa:	a803      	add	r0, sp, #12
   119fc:	f008 ff36 	bl	1a86c <snprintf>
        delayed_async_print(auc_rsp_data, AT_FLAG_LOGABLE, 0, 0);
   11a00:	2300      	movs	r3, #0
   11a02:	2108      	movs	r1, #8
   11a04:	001a      	movs	r2, r3
   11a06:	a803      	add	r0, sp, #12
   11a08:	f7f9 f958 	bl	acbc <delayed_async_print>
}
   11a0c:	b006      	add	sp, #24
   11a0e:	bd10      	pop	{r4, pc}
   11a10:	010024c2 	.word	0x010024c2
   11a14:	00023cf4 	.word	0x00023cf4
   11a18:	000248db 	.word	0x000248db

00011a1c <at_non_ip_sent_callback>:
{
   11a1c:	b530      	push	{r4, r5, lr}
   11a1e:	0004      	movs	r4, r0
   11a20:	b089      	sub	sp, #36	; 0x24
   11a22:	000d      	movs	r5, r1
    char rsp_string[AT_MAX_SENT_DATA_RSP_LEN] = {0};
   11a24:	2214      	movs	r2, #20
   11a26:	2100      	movs	r1, #0
   11a28:	a803      	add	r0, sp, #12
   11a2a:	f7ee fc59 	bl	2e0 <memset>
    index = ((data_seq >> 8) & 0xFF);
   11a2e:	0a23      	lsrs	r3, r4, #8
    seq_num = (uint8)(data_seq & 0xFF);
   11a30:	b2e4      	uxtb	r4, r4
    if (index == AT_CP_ONLY_NON_IP_PENDING_DATA_LIST_INDEX)
   11a32:	2bff      	cmp	r3, #255	; 0xff
   11a34:	d10f      	bne.n	11a56 <at_non_ip_sent_callback+0x3a>
        (void)snprintf(rsp_string, AT_MAX_SENT_DATA_RSP_LEN, "%s%d,%d", AT_CMD_CP_ONLY_NONIP_SENT_DATA_STPR, seq_num, (uint8)data_status);
   11a36:	4b0b      	ldr	r3, [pc, #44]	; (11a64 <at_non_ip_sent_callback+0x48>)
   11a38:	9501      	str	r5, [sp, #4]
   11a3a:	9400      	str	r4, [sp, #0]
        (void)snprintf(rsp_string, AT_MAX_SENT_DATA_RSP_LEN, "%s%d,%d", AT_CMD_NONIP_SENT_DATA_STPR, seq_num, (uint8)data_status);
   11a3c:	4a0a      	ldr	r2, [pc, #40]	; (11a68 <at_non_ip_sent_callback+0x4c>)
   11a3e:	2114      	movs	r1, #20
   11a40:	a803      	add	r0, sp, #12
   11a42:	f008 ff13 	bl	1a86c <snprintf>
    delayed_async_print(rsp_string, AT_FLAG_LOGABLE, 0, 0);
   11a46:	2300      	movs	r3, #0
   11a48:	2108      	movs	r1, #8
   11a4a:	001a      	movs	r2, r3
   11a4c:	a803      	add	r0, sp, #12
   11a4e:	f7f9 f935 	bl	acbc <delayed_async_print>
}
   11a52:	b009      	add	sp, #36	; 0x24
   11a54:	bd30      	pop	{r4, r5, pc}
    else if (index == AT_CP_NON_IP_PENDING_DATA_LIST_INDEX)
   11a56:	2bef      	cmp	r3, #239	; 0xef
   11a58:	d1fb      	bne.n	11a52 <at_non_ip_sent_callback+0x36>
        (void)snprintf(rsp_string, AT_MAX_SENT_DATA_RSP_LEN, "%s%d,%d", AT_CMD_NONIP_SENT_DATA_STPR, seq_num, (uint8)data_status);
   11a5a:	9501      	str	r5, [sp, #4]
   11a5c:	9400      	str	r4, [sp, #0]
   11a5e:	4b03      	ldr	r3, [pc, #12]	; (11a6c <at_non_ip_sent_callback+0x50>)
   11a60:	e7ec      	b.n	11a3c <at_non_ip_sent_callback+0x20>
   11a62:	46c0      	nop			; (mov r8, r8)
   11a64:	00023e14 	.word	0x00023e14
   11a68:	00023e83 	.word	0x00023e83
   11a6c:	00023e7a 	.word	0x00023e7a

00011a70 <at_get_internal_cmd_table_size>:
    uint8   table_size;

    table_size = sizeof(g_at_cmd_table)/sizeof(AT_CMD_CB_s);

    return table_size;
}
   11a70:	2058      	movs	r0, #88	; 0x58
   11a72:	4770      	bx	lr

00011a74 <at_get_internal_cmd_table_address>:

const AT_CMD_CB_s * at_get_internal_cmd_table_address(void)
{
    return g_at_cmd_table;
}
   11a74:	4800      	ldr	r0, [pc, #0]	; (11a78 <at_get_internal_cmd_table_address+0x4>)
   11a76:	4770      	bx	lr
   11a78:	00023fa4 	.word	0x00023fa4

00011a7c <at_cmd_register>:
 * @param at_cmd_cb pointer of the at cmd param,at_cmd_cb.cmd_str should always using '+'as first char.should
            not include '=','?',';',or will not parse correctly.
 * @return The result of register, successful: true, fail:false
 */
bool at_cmd_register(const AT_CMD_CB_s* at_cmd_cb)
{
   11a7c:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
   11a7e:	4677      	mov	r7, lr
   11a80:	1e05      	subs	r5, r0, #0
    struct AT_CMD_CB_node* current_at_cmd_registered_node, *new_at_cmd_node;

    if ((at_cmd_cb == NULL) || (at_cmd_cb->cmd_str == NULL) || (at_cmd_cb->cmd_str[0] != '+'))
   11a82:	d005      	beq.n	11a90 <at_cmd_register+0x14>
   11a84:	6843      	ldr	r3, [r0, #4]
   11a86:	2b00      	cmp	r3, #0
   11a88:	d002      	beq.n	11a90 <at_cmd_register+0x14>
   11a8a:	781b      	ldrb	r3, [r3, #0]
   11a8c:	2b2b      	cmp	r3, #43	; 0x2b
   11a8e:	d005      	beq.n	11a9c <at_cmd_register+0x20>
    {
        assert(false);
   11a90:	2016      	movs	r0, #22
   11a92:	0039      	movs	r1, r7
   11a94:	f7f0 f83c 	bl	1b10 <panic>
        return false;//lint !e527
   11a98:	2000      	movs	r0, #0
    }
    current_at_cmd_registered_node->next = new_at_cmd_node;
    non_os_exit_critical();

    return true;
}
   11a9a:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    if ((at_cmd_cb->at_read_handler == NULL) && (at_cmd_cb->at_set_handler == NULL) 
   11a9c:	68c3      	ldr	r3, [r0, #12]
   11a9e:	2b00      	cmp	r3, #0
   11aa0:	d108      	bne.n	11ab4 <at_cmd_register+0x38>
   11aa2:	6883      	ldr	r3, [r0, #8]
   11aa4:	2b00      	cmp	r3, #0
   11aa6:	d105      	bne.n	11ab4 <at_cmd_register+0x38>
        && (at_cmd_cb->at_exec_handler == NULL) && (at_cmd_cb->at_test_handler == NULL))
   11aa8:	6943      	ldr	r3, [r0, #20]
   11aaa:	2b00      	cmp	r3, #0
   11aac:	d102      	bne.n	11ab4 <at_cmd_register+0x38>
   11aae:	6903      	ldr	r3, [r0, #16]
   11ab0:	2b00      	cmp	r3, #0
   11ab2:	d0ed      	beq.n	11a90 <at_cmd_register+0x14>
    new_at_cmd_node = irmalloc(sizeof(struct AT_CMD_CB_node));
   11ab4:	201c      	movs	r0, #28
   11ab6:	f000 ffa3 	bl	12a00 <irmalloc>
   11aba:	1e06      	subs	r6, r0, #0
    if (new_at_cmd_node == NULL)
   11abc:	d0e8      	beq.n	11a90 <at_cmd_register+0x14>
    memcpy((void*)(&new_at_cmd_node->at_cmd_cb), (void*)at_cmd_cb, sizeof(AT_CMD_CB_s));
   11abe:	2218      	movs	r2, #24
   11ac0:	0029      	movs	r1, r5
   11ac2:	f7ee fb95 	bl	1f0 <memcpy>
    new_at_cmd_node->at_cmd_cb.cmd_str = irmalloc(strlen(at_cmd_cb->cmd_str) + 1);//copy the '\0' too.
   11ac6:	6868      	ldr	r0, [r5, #4]
   11ac8:	f009 fc69 	bl	1b39e <strlen>
   11acc:	3001      	adds	r0, #1
   11ace:	f000 ff97 	bl	12a00 <irmalloc>
   11ad2:	1e04      	subs	r4, r0, #0
   11ad4:	6070      	str	r0, [r6, #4]
    if (new_at_cmd_node->at_cmd_cb.cmd_str == NULL)
   11ad6:	d103      	bne.n	11ae0 <at_cmd_register+0x64>
        irfree(new_at_cmd_node);
   11ad8:	0030      	movs	r0, r6
   11ada:	f000 ffad 	bl	12a38 <irfree>
   11ade:	e7d7      	b.n	11a90 <at_cmd_register+0x14>
    memcpy((void*)new_at_cmd_node->at_cmd_cb.cmd_str, (void*)at_cmd_cb->cmd_str, strlen(at_cmd_cb->cmd_str) + 1);//copy the '\0' too.
   11ae0:	686d      	ldr	r5, [r5, #4]
   11ae2:	0028      	movs	r0, r5
   11ae4:	f009 fc5b 	bl	1b39e <strlen>
   11ae8:	0029      	movs	r1, r5
   11aea:	1c42      	adds	r2, r0, #1
   11aec:	0020      	movs	r0, r4
   11aee:	f7ee fb7f 	bl	1f0 <memcpy>
    new_at_cmd_node->next = NULL;
   11af2:	2300      	movs	r3, #0
   11af4:	61b3      	str	r3, [r6, #24]
    non_os_enter_critical();
   11af6:	f006 fb5d 	bl	181b4 <non_os_enter_critical>
    if (at_cmd_registered_table == NULL)
   11afa:	4a07      	ldr	r2, [pc, #28]	; (11b18 <at_cmd_register+0x9c>)
   11afc:	6813      	ldr	r3, [r2, #0]
   11afe:	2b00      	cmp	r3, #0
   11b00:	d105      	bne.n	11b0e <at_cmd_register+0x92>
        at_cmd_registered_table = new_at_cmd_node;
   11b02:	6016      	str	r6, [r2, #0]
    non_os_exit_critical();
   11b04:	f006 fb6a 	bl	181dc <non_os_exit_critical>
    return true;
   11b08:	2001      	movs	r0, #1
   11b0a:	e7c6      	b.n	11a9a <at_cmd_register+0x1e>
   11b0c:	0013      	movs	r3, r2
    while(current_at_cmd_registered_node->next != NULL)
   11b0e:	699a      	ldr	r2, [r3, #24]
   11b10:	2a00      	cmp	r2, #0
   11b12:	d1fb      	bne.n	11b0c <at_cmd_register+0x90>
    current_at_cmd_registered_node->next = new_at_cmd_node;
   11b14:	619e      	str	r6, [r3, #24]
   11b16:	e7f5      	b.n	11b04 <at_cmd_register+0x88>
   11b18:	010024cc 	.word	0x010024cc

00011b1c <at_get_registered_cmd_table_address>:


struct AT_CMD_CB_node * at_get_registered_cmd_table_address(void)
{
    return at_cmd_registered_table;
   11b1c:	4b01      	ldr	r3, [pc, #4]	; (11b24 <at_get_registered_cmd_table_address+0x8>)
   11b1e:	6818      	ldr	r0, [r3, #0]
}
   11b20:	4770      	bx	lr
   11b22:	46c0      	nop			; (mov r8, r8)
   11b24:	010024cc 	.word	0x010024cc

00011b28 <at_trigger_filter_send>:
{
    at_filter_update_state_callback = callback;
}

bool at_trigger_filter_send()
{
   11b28:	b510      	push	{r4, lr}
    if (at_filter_update_state_callback != NULL)
   11b2a:	4b03      	ldr	r3, [pc, #12]	; (11b38 <at_trigger_filter_send+0x10>)
   11b2c:	681b      	ldr	r3, [r3, #0]
    {
        return (at_filter_update_state_callback)();
    }
    else
    {
        return false;
   11b2e:	1e18      	subs	r0, r3, #0
    if (at_filter_update_state_callback != NULL)
   11b30:	d000      	beq.n	11b34 <at_trigger_filter_send+0xc>
        return (at_filter_update_state_callback)();
   11b32:	4798      	blx	r3
    }
}
   11b34:	bd10      	pop	{r4, pc}
   11b36:	46c0      	nop			; (mov r8, r8)
   11b38:	010024d0 	.word	0x010024d0

00011b3c <at_get_package_info_buff>:

/**
 * Get a buffer in RAM to store the OTA package info
 */
static uint8 *at_get_package_info_buff(uint16 buff_len)
{
   11b3c:	b570      	push	{r4, r5, r6, lr}
   11b3e:	0005      	movs	r5, r0
    ota_package_info_buff = irmalloc(buff_len);
   11b40:	f000 ff5e 	bl	12a00 <irmalloc>
   11b44:	4c04      	ldr	r4, [pc, #16]	; (11b58 <at_get_package_info_buff+0x1c>)
   11b46:	6020      	str	r0, [r4, #0]

    if (ota_package_info_buff)
   11b48:	2800      	cmp	r0, #0
   11b4a:	d003      	beq.n	11b54 <at_get_package_info_buff+0x18>
    {
        memset(ota_package_info_buff, 0, buff_len);
   11b4c:	002a      	movs	r2, r5
   11b4e:	2100      	movs	r1, #0
   11b50:	f7ee fbc6 	bl	2e0 <memset>
    }
    return ota_package_info_buff;
   11b54:	6820      	ldr	r0, [r4, #0]
}
   11b56:	bd70      	pop	{r4, r5, r6, pc}
   11b58:	010024d8 	.word	0x010024d8

00011b5c <ota_package_print_result>:
{
   11b5c:	b570      	push	{r4, r5, r6, lr}
   11b5e:	0005      	movs	r5, r0
    pkg_rsp = (char*)irmalloc(AT_OTA_STATUS_RSP_MAX_LEN);
   11b60:	2028      	movs	r0, #40	; 0x28
   11b62:	f000 ff4d 	bl	12a00 <irmalloc>
   11b66:	1e04      	subs	r4, r0, #0
    if (pkg_rsp)
   11b68:	d010      	beq.n	11b8c <ota_package_print_result+0x30>
   11b6a:	4b09      	ldr	r3, [pc, #36]	; (11b90 <ota_package_print_result+0x34>)
   11b6c:	2d09      	cmp	r5, #9
   11b6e:	d802      	bhi.n	11b76 <ota_package_print_result+0x1a>
   11b70:	4b08      	ldr	r3, [pc, #32]	; (11b94 <ota_package_print_result+0x38>)
   11b72:	00ad      	lsls	r5, r5, #2
   11b74:	58eb      	ldr	r3, [r5, r3]
        (void)snprintf(pkg_rsp, AT_OTA_STATUS_RSP_MAX_LEN, "+NFWUPD:%s", pkg_str);
   11b76:	4a08      	ldr	r2, [pc, #32]	; (11b98 <ota_package_print_result+0x3c>)
   11b78:	2128      	movs	r1, #40	; 0x28
   11b7a:	0020      	movs	r0, r4
   11b7c:	f008 fe76 	bl	1a86c <snprintf>
        app_at_send_at_rsp_string_lines_with_claim_and_log(pkg_rsp);
   11b80:	0020      	movs	r0, r4
   11b82:	f7f7 fd2f 	bl	95e4 <app_at_send_at_rsp_string_lines_with_claim_and_log>
        irfree(pkg_rsp);
   11b86:	0020      	movs	r0, r4
   11b88:	f000 ff56 	bl	12a38 <irfree>
}
   11b8c:	bd70      	pop	{r4, r5, r6, pc}
   11b8e:	46c0      	nop			; (mov r8, r8)
   11b90:	0002519b 	.word	0x0002519b
   11b94:	0002515c 	.word	0x0002515c
   11b98:	000251b2 	.word	0x000251b2

00011b9c <at_ota_helper_take_binary>:
{
   11b9c:	b510      	push	{r4, lr}
    if (at_ota_binary)
   11b9e:	4b08      	ldr	r3, [pc, #32]	; (11bc0 <at_ota_helper_take_binary+0x24>)
   11ba0:	4674      	mov	r4, lr
   11ba2:	6818      	ldr	r0, [r3, #0]
   11ba4:	2800      	cmp	r0, #0
   11ba6:	d009      	beq.n	11bbc <at_ota_helper_take_binary+0x20>
        if(osSemaphoreAcquire(at_ota_binary, osWaitForever) != osOK)
   11ba8:	2101      	movs	r1, #1
   11baa:	4249      	negs	r1, r1
   11bac:	f002 ff66 	bl	14a7c <osSemaphoreAcquire>
   11bb0:	2800      	cmp	r0, #0
   11bb2:	d003      	beq.n	11bbc <at_ota_helper_take_binary+0x20>
            assert(false);
   11bb4:	0021      	movs	r1, r4
   11bb6:	2016      	movs	r0, #22
   11bb8:	f7ef ffaa 	bl	1b10 <panic>
}
   11bbc:	bd10      	pop	{r4, pc}
   11bbe:	46c0      	nop			; (mov r8, r8)
   11bc0:	010024d4 	.word	0x010024d4

00011bc4 <at_ota_binary_create.part.2>:
        at_ota_binary = osSemaphoreNew(1, 0, NULL);
   11bc4:	2200      	movs	r2, #0
static void at_ota_binary_create(void)
   11bc6:	b510      	push	{r4, lr}
        at_ota_binary = osSemaphoreNew(1, 0, NULL);
   11bc8:	0011      	movs	r1, r2
   11bca:	2001      	movs	r0, #1
   11bcc:	f002 ff3a 	bl	14a44 <osSemaphoreNew>
   11bd0:	4b01      	ldr	r3, [pc, #4]	; (11bd8 <at_ota_binary_create.part.2+0x14>)
   11bd2:	6018      	str	r0, [r3, #0]
}
   11bd4:	bd10      	pop	{r4, pc}
   11bd6:	46c0      	nop			; (mov r8, r8)
   11bd8:	010024d4 	.word	0x010024d4

00011bdc <at_ota_helper_give_binary.isra.0>:
static void at_ota_helper_give_binary(uint8 state)
   11bdc:	b510      	push	{r4, lr}
    if (at_ota_binary)
   11bde:	4b07      	ldr	r3, [pc, #28]	; (11bfc <at_ota_helper_give_binary.isra.0+0x20>)
   11be0:	4674      	mov	r4, lr
   11be2:	6818      	ldr	r0, [r3, #0]
   11be4:	2800      	cmp	r0, #0
   11be6:	d007      	beq.n	11bf8 <at_ota_helper_give_binary.isra.0+0x1c>
        if(osSemaphoreRelease(at_ota_binary) != osOK)
   11be8:	f002 ff74 	bl	14ad4 <osSemaphoreRelease>
   11bec:	2800      	cmp	r0, #0
   11bee:	d003      	beq.n	11bf8 <at_ota_helper_give_binary.isra.0+0x1c>
            assert(false);
   11bf0:	0021      	movs	r1, r4
   11bf2:	2016      	movs	r0, #22
   11bf4:	f7ef ff8c 	bl	1b10 <panic>
}
   11bf8:	bd10      	pop	{r4, pc}
   11bfa:	46c0      	nop			; (mov r8, r8)
   11bfc:	010024d4 	.word	0x010024d4

00011c00 <at_ota_helper_package_parse_done>:
{
   11c00:	b510      	push	{r4, lr}
    at_ota_package_parse_status = (NEUL_UPDATE_OTA_PACKAGE_STATUS)state;
   11c02:	4b02      	ldr	r3, [pc, #8]	; (11c0c <at_ota_helper_package_parse_done+0xc>)
   11c04:	7018      	strb	r0, [r3, #0]
    at_ota_helper_give_binary(0);
   11c06:	f7ff ffe9 	bl	11bdc <at_ota_helper_give_binary.isra.0>
}
   11c0a:	bd10      	pop	{r4, pc}
   11c0c:	01000594 	.word	0x01000594

00011c10 <at_ota_helper_erase_done>:
{
   11c10:	b510      	push	{r4, lr}
    at_ota_helper_give_binary(0);
   11c12:	f7ff ffe3 	bl	11bdc <at_ota_helper_give_binary.isra.0>
}
   11c16:	bd10      	pop	{r4, pc}

00011c18 <at_ota_helper_download_done>:
{
   11c18:	b510      	push	{r4, lr}
    at_ota_helper_give_binary(0);
   11c1a:	f7ff ffdf 	bl	11bdc <at_ota_helper_give_binary.isra.0>
}
   11c1e:	bd10      	pop	{r4, pc}

00011c20 <at_ota_helper_get_package_info_done>:
   11c20:	b510      	push	{r4, lr}
   11c22:	f7ff ffdb 	bl	11bdc <at_ota_helper_give_binary.isra.0>
   11c26:	bd10      	pop	{r4, pc}

00011c28 <at_ota_exec_cmd>:
            return OTA_PACKAGE_INFO_UNSUPPORTED;
    }
}
#endif
AT_RET at_ota_exec_cmd(AT_OTA_CMD cmd)
{
   11c28:	4673      	mov	r3, lr
   11c2a:	b5f0      	push	{r4, r5, r6, r7, lr}
   11c2c:	b085      	sub	sp, #20
   11c2e:	9301      	str	r3, [sp, #4]
#ifdef LIBOTA
    NEUL_UPDATE_RET ret;
    NEUL_UPDATE_OTA_PACKAGE_STATUS pkg_status = NEUL_UPDATE_OTA_PACKAGE_NOT_DOWNLOADED;
   11c30:	ab02      	add	r3, sp, #8
   11c32:	1cdd      	adds	r5, r3, #3
   11c34:	2309      	movs	r3, #9
   11c36:	702b      	strb	r3, [r5, #0]
    if (at_ota_binary == NULL)
   11c38:	4b55      	ldr	r3, [pc, #340]	; (11d90 <at_ota_exec_cmd+0x168>)
{
   11c3a:	0006      	movs	r6, r0
    if (at_ota_binary == NULL)
   11c3c:	681b      	ldr	r3, [r3, #0]
   11c3e:	2b00      	cmp	r3, #0
   11c40:	d101      	bne.n	11c46 <at_ota_exec_cmd+0x1e>
   11c42:	f7ff ffbf 	bl	11bc4 <at_ota_binary_create.part.2>

    at_ota_binary_create();

    switch(cmd)
   11c46:	2e05      	cmp	r6, #5
   11c48:	d80f      	bhi.n	11c6a <at_ota_exec_cmd+0x42>
   11c4a:	0030      	movs	r0, r6
   11c4c:	f7ee fbaa 	bl	3a4 <__gnu_thumb1_case_uqi>
   11c50:	25180d03 	.word	0x25180d03
   11c54:	7b25      	.short	0x7b25
    {
        case AT_OTA_CMD_ERASE:
            package_offset = 0;
   11c56:	2300      	movs	r3, #0
   11c58:	4a4e      	ldr	r2, [pc, #312]	; (11d94 <at_ota_exec_cmd+0x16c>)
            package_sn     = 0;
            ret = ota_package_init(at_ota_helper_erase_done);
   11c5a:	484f      	ldr	r0, [pc, #316]	; (11d98 <at_ota_exec_cmd+0x170>)
            package_offset = 0;
   11c5c:	6013      	str	r3, [r2, #0]
            package_sn     = 0;
   11c5e:	4a4f      	ldr	r2, [pc, #316]	; (11d9c <at_ota_exec_cmd+0x174>)
   11c60:	6013      	str	r3, [r2, #0]
            ret = ota_package_init(at_ota_helper_erase_done);
   11c62:	f7f5 fa69 	bl	7138 <ota_package_init>
            if (ret != NEUL_UPDATE_RET_OK)
   11c66:	2800      	cmp	r0, #0
   11c68:	d001      	beq.n	11c6e <at_ota_exec_cmd+0x46>
                return AT_RET_SYNTAX_ERROR;
            }
            break;

        default:
            return AT_RET_SYNTAX_ERROR;
   11c6a:	2001      	movs	r0, #1
   11c6c:	e006      	b.n	11c7c <at_ota_exec_cmd+0x54>
            at_ota_helper_take_binary();
   11c6e:	f7ff ff95 	bl	11b9c <at_ota_helper_take_binary>
            if (!ota_check_flash_erased_result())
   11c72:	f7f5 fa77 	bl	7164 <ota_check_flash_erased_result>
   11c76:	2800      	cmp	r0, #0
   11c78:	d10d      	bne.n	11c96 <at_ota_exec_cmd+0x6e>
                return AT_RET_PROGRESS_ERROR;
   11c7a:	2006      	movs	r0, #6
    return AT_RET_OK;
#else
    UNUSED(cmd);
    return AT_RET_SYNTAX_ERROR;
#endif
}
   11c7c:	b005      	add	sp, #20
   11c7e:	bdf0      	pop	{r4, r5, r6, r7, pc}
            package_offset = 0;
   11c80:	2400      	movs	r4, #0
   11c82:	4b44      	ldr	r3, [pc, #272]	; (11d94 <at_ota_exec_cmd+0x16c>)
            (void)neul_update_get_update_status(&pkg_status);
   11c84:	0028      	movs	r0, r5
            package_offset = 0;
   11c86:	601c      	str	r4, [r3, #0]
            package_sn     = 0;
   11c88:	4b44      	ldr	r3, [pc, #272]	; (11d9c <at_ota_exec_cmd+0x174>)
   11c8a:	601c      	str	r4, [r3, #0]
            (void)neul_update_get_update_status(&pkg_status);
   11c8c:	f7f5 fd90 	bl	77b0 <neul_update_get_update_status>
            ota_package_print_result(pkg_status);
   11c90:	7828      	ldrb	r0, [r5, #0]
   11c92:	f7ff ff63 	bl	11b5c <ota_package_print_result>
    return AT_RET_OK;
   11c96:	2000      	movs	r0, #0
   11c98:	e7f0      	b.n	11c7c <at_ota_exec_cmd+0x54>
            ret = ota_package_parse_req(at_ota_helper_package_parse_done);
   11c9a:	4841      	ldr	r0, [pc, #260]	; (11da0 <at_ota_exec_cmd+0x178>)
   11c9c:	f7f5 f9a2 	bl	6fe4 <ota_package_parse_req>
            if (ret != NEUL_UPDATE_RET_OK)
   11ca0:	2800      	cmp	r0, #0
   11ca2:	d1ea      	bne.n	11c7a <at_ota_exec_cmd+0x52>
            at_ota_helper_take_binary();
   11ca4:	f7ff ff7a 	bl	11b9c <at_ota_helper_take_binary>
            if (at_ota_package_parse_status != NEUL_UPDATE_OTA_PACKAGE_OK)
   11ca8:	4b3e      	ldr	r3, [pc, #248]	; (11da4 <at_ota_exec_cmd+0x17c>)
   11caa:	7818      	ldrb	r0, [r3, #0]
   11cac:	2800      	cmp	r0, #0
   11cae:	d002      	beq.n	11cb6 <at_ota_exec_cmd+0x8e>
                ota_package_print_result(at_ota_package_parse_status);
   11cb0:	f7ff ff54 	bl	11b5c <ota_package_print_result>
   11cb4:	e7e1      	b.n	11c7a <at_ota_exec_cmd+0x52>
            return OTA_PACKAGE_INFO_NAME;
   11cb6:	1f32      	subs	r2, r6, #4
   11cb8:	4253      	negs	r3, r2
   11cba:	415a      	adcs	r2, r3
            ret = ota_get_package_info_req(at_ota_helper_get_package_info_done, at_get_package_info_buff, package_info_type(cmd));
   11cbc:	493a      	ldr	r1, [pc, #232]	; (11da8 <at_ota_exec_cmd+0x180>)
   11cbe:	483b      	ldr	r0, [pc, #236]	; (11dac <at_ota_exec_cmd+0x184>)
   11cc0:	f7f5 f99c 	bl	6ffc <ota_get_package_info_req>
   11cc4:	1e07      	subs	r7, r0, #0
            if (ret != NEUL_UPDATE_RET_OK)
   11cc6:	d1d8      	bne.n	11c7a <at_ota_exec_cmd+0x52>
            at_ota_helper_take_binary();
   11cc8:	f7ff ff68 	bl	11b9c <at_ota_helper_take_binary>
            if (ota_package_info_buff == NULL)
   11ccc:	4d38      	ldr	r5, [pc, #224]	; (11db0 <at_ota_exec_cmd+0x188>)
   11cce:	682b      	ldr	r3, [r5, #0]
   11cd0:	2b00      	cmp	r3, #0
   11cd2:	d101      	bne.n	11cd8 <at_ota_exec_cmd+0xb0>
                return AT_RET_MEMORY_ERROR;
   11cd4:	2004      	movs	r0, #4
   11cd6:	e7d1      	b.n	11c7c <at_ota_exec_cmd+0x54>
                char *pkg_info_rsp = irmalloc(AT_OTA_PKG_INFO_RSP_MAX_LEN);
   11cd8:	206d      	movs	r0, #109	; 0x6d
   11cda:	f000 fe91 	bl	12a00 <irmalloc>
   11cde:	1e04      	subs	r4, r0, #0
                if (pkg_info_rsp)
   11ce0:	d0f8      	beq.n	11cd4 <at_ota_exec_cmd+0xac>
                    memset(pkg_info_rsp, 0, AT_OTA_PKG_INFO_RSP_MAX_LEN);
   11ce2:	226d      	movs	r2, #109	; 0x6d
   11ce4:	0039      	movs	r1, r7
   11ce6:	f7ee fafb 	bl	2e0 <memset>
                    if (cmd == AT_OTA_CMD_GET_PACKAGE_NAME)
   11cea:	2e03      	cmp	r6, #3
   11cec:	d10f      	bne.n	11d0e <at_ota_exec_cmd+0xe6>
                        (void)snprintf(pkg_info_rsp, AT_OTA_PKG_INFO_RSP_MAX_LEN, "+NFWUPD:%s", (char *)ota_package_info_buff);
   11cee:	682b      	ldr	r3, [r5, #0]
   11cf0:	4a30      	ldr	r2, [pc, #192]	; (11db4 <at_ota_exec_cmd+0x18c>)
                        (void)snprintf(pkg_info_rsp, AT_OTA_PKG_INFO_RSP_MAX_LEN, "+NFWUPD:%u", pkg_version);
   11cf2:	216d      	movs	r1, #109	; 0x6d
   11cf4:	0020      	movs	r0, r4
   11cf6:	f008 fdb9 	bl	1a86c <snprintf>
                    app_at_send_at_rsp_string_lines_with_claim_and_log(pkg_info_rsp);
   11cfa:	0020      	movs	r0, r4
   11cfc:	f7f7 fc72 	bl	95e4 <app_at_send_at_rsp_string_lines_with_claim_and_log>
                    irfree(ota_package_info_buff);
   11d00:	6828      	ldr	r0, [r5, #0]
   11d02:	f000 fe99 	bl	12a38 <irfree>
                    irfree(pkg_info_rsp);
   11d06:	0020      	movs	r0, r4
   11d08:	f000 fe96 	bl	12a38 <irfree>
   11d0c:	e7c3      	b.n	11c96 <at_ota_exec_cmd+0x6e>
                        pkg_info_len = strlen((char *)ota_package_info_buff);
   11d0e:	6828      	ldr	r0, [r5, #0]
   11d10:	f009 fb45 	bl	1b39e <strlen>
   11d14:	0006      	movs	r6, r0
                        assert(pkg_info_len <= sizeof(uint32));
   11d16:	2804      	cmp	r0, #4
   11d18:	d903      	bls.n	11d22 <at_ota_exec_cmd+0xfa>
   11d1a:	9901      	ldr	r1, [sp, #4]
   11d1c:	2016      	movs	r0, #22
   11d1e:	f7ef fef7 	bl	1b10 <panic>
                        if (neul_string_convert_uint8_array_to_uint32(ota_package_info_buff, pkg_info_len, &pkg_version) == false)
   11d22:	aa03      	add	r2, sp, #12
   11d24:	0031      	movs	r1, r6
   11d26:	6828      	ldr	r0, [r5, #0]
   11d28:	f00b fce1 	bl	1d6ee <neul_string_convert_uint8_array_to_uint32>
   11d2c:	2800      	cmp	r0, #0
   11d2e:	d107      	bne.n	11d40 <at_ota_exec_cmd+0x118>
                            irfree(ota_package_info_buff);
   11d30:	6828      	ldr	r0, [r5, #0]
   11d32:	f000 fe81 	bl	12a38 <irfree>
                            irfree(pkg_info_rsp);
   11d36:	0020      	movs	r0, r4
   11d38:	f000 fe7e 	bl	12a38 <irfree>
                            return AT_RET_VALUE_OVERFLOW;
   11d3c:	2026      	movs	r0, #38	; 0x26
   11d3e:	e79d      	b.n	11c7c <at_ota_exec_cmd+0x54>
                        (void)snprintf(pkg_info_rsp, AT_OTA_PKG_INFO_RSP_MAX_LEN, "+NFWUPD:%u", pkg_version);
   11d40:	9b03      	ldr	r3, [sp, #12]
   11d42:	4a1d      	ldr	r2, [pc, #116]	; (11db8 <at_ota_exec_cmd+0x190>)
   11d44:	e7d5      	b.n	11cf2 <at_ota_exec_cmd+0xca>
            (void)set_update_method(OTA_UPDATE_METHOD_AT);
   11d46:	2001      	movs	r0, #1
   11d48:	f7f5 f970 	bl	702c <set_update_method>
            ret = ota_package_upgrade_req();
   11d4c:	f7f5 f940 	bl	6fd0 <ota_package_upgrade_req>
   11d50:	1e04      	subs	r4, r0, #0
            if (ret != NEUL_UPDATE_RET_OK)
   11d52:	d0a0      	beq.n	11c96 <at_ota_exec_cmd+0x6e>
                (void)set_update_method(OTA_UPDATE_METHOD_LWM2M);
   11d54:	2000      	movs	r0, #0
   11d56:	f7f5 f969 	bl	702c <set_update_method>
                pkg_rsp = (char*)irmalloc(AT_OTA_STATUS_RSP_MAX_LEN);
   11d5a:	2028      	movs	r0, #40	; 0x28
   11d5c:	f000 fe50 	bl	12a00 <irmalloc>
   11d60:	1e05      	subs	r5, r0, #0
                if (pkg_rsp)
   11d62:	d100      	bne.n	11d66 <at_ota_exec_cmd+0x13e>
   11d64:	e781      	b.n	11c6a <at_ota_exec_cmd+0x42>
   11d66:	3c01      	subs	r4, #1
   11d68:	b2e4      	uxtb	r4, r4
   11d6a:	4b14      	ldr	r3, [pc, #80]	; (11dbc <at_ota_exec_cmd+0x194>)
   11d6c:	2c02      	cmp	r4, #2
   11d6e:	d802      	bhi.n	11d76 <at_ota_exec_cmd+0x14e>
   11d70:	4b13      	ldr	r3, [pc, #76]	; (11dc0 <at_ota_exec_cmd+0x198>)
   11d72:	00a4      	lsls	r4, r4, #2
   11d74:	58e3      	ldr	r3, [r4, r3]
                    (void)snprintf(pkg_rsp, AT_OTA_STATUS_RSP_MAX_LEN, "+NFWUPD:%s", pkg_str);
   11d76:	4a0f      	ldr	r2, [pc, #60]	; (11db4 <at_ota_exec_cmd+0x18c>)
   11d78:	2128      	movs	r1, #40	; 0x28
   11d7a:	0028      	movs	r0, r5
   11d7c:	f008 fd76 	bl	1a86c <snprintf>
                    app_at_send_at_rsp_string_lines_with_claim_and_log(pkg_rsp);
   11d80:	0028      	movs	r0, r5
   11d82:	f7f7 fc2f 	bl	95e4 <app_at_send_at_rsp_string_lines_with_claim_and_log>
                    irfree(pkg_rsp);
   11d86:	0028      	movs	r0, r5
   11d88:	f000 fe56 	bl	12a38 <irfree>
   11d8c:	e76d      	b.n	11c6a <at_ota_exec_cmd+0x42>
   11d8e:	46c0      	nop			; (mov r8, r8)
   11d90:	010024d4 	.word	0x010024d4
   11d94:	010024dc 	.word	0x010024dc
   11d98:	00011c11 	.word	0x00011c11
   11d9c:	010024e0 	.word	0x010024e0
   11da0:	00011c01 	.word	0x00011c01
   11da4:	01000594 	.word	0x01000594
   11da8:	00011b3d 	.word	0x00011b3d
   11dac:	00011c21 	.word	0x00011c21
   11db0:	010024d8 	.word	0x010024d8
   11db4:	000251b2 	.word	0x000251b2
   11db8:	00025190 	.word	0x00025190
   11dbc:	0002519b 	.word	0x0002519b
   11dc0:	00025184 	.word	0x00025184

00011dc4 <at_ota_download_package>:
AT_RET at_ota_download_package(uint16 sn, uint16 length, const uint8* data, const uint8* crc)
{
   11dc4:	b5f0      	push	{r4, r5, r6, r7, lr}
   11dc6:	001e      	movs	r6, r3
    if (at_ota_binary == NULL)
   11dc8:	4b20      	ldr	r3, [pc, #128]	; (11e4c <at_ota_download_package+0x88>)
{
   11dca:	b085      	sub	sp, #20
    if (at_ota_binary == NULL)
   11dcc:	681b      	ldr	r3, [r3, #0]
{
   11dce:	0004      	movs	r4, r0
   11dd0:	9101      	str	r1, [sp, #4]
   11dd2:	0017      	movs	r7, r2
    if (at_ota_binary == NULL)
   11dd4:	2b00      	cmp	r3, #0
   11dd6:	d101      	bne.n	11ddc <at_ota_download_package+0x18>
   11dd8:	f7ff fef4 	bl	11bc4 <at_ota_binary_create.part.2>
#ifdef LIBOTA
    uint8 calculate_crc;
    at_ota_binary_create();

    if ((data == NULL) || (crc == NULL))
   11ddc:	2f00      	cmp	r7, #0
   11dde:	d104      	bne.n	11dea <at_ota_download_package+0x26>
    {
        return AT_RET_SYNTAX_ERROR;
   11de0:	2301      	movs	r3, #1
   11de2:	9300      	str	r3, [sp, #0]
    UNUSED(length);
    UNUSED(data);
    UNUSED(crc);
    return AT_RET_SYNTAX_ERROR;
#endif
}
   11de4:	9800      	ldr	r0, [sp, #0]
   11de6:	b005      	add	sp, #20
   11de8:	bdf0      	pop	{r4, r5, r6, r7, pc}
    if ((data == NULL) || (crc == NULL))
   11dea:	2e00      	cmp	r6, #0
   11dec:	d0f8      	beq.n	11de0 <at_ota_download_package+0x1c>
   11dee:	4d18      	ldr	r5, [pc, #96]	; (11e50 <at_ota_download_package+0x8c>)
   11df0:	682b      	ldr	r3, [r5, #0]
    if ((sn == 0) && (package_sn != 0xFFFF))
   11df2:	2c00      	cmp	r4, #0
   11df4:	d125      	bne.n	11e42 <at_ota_download_package+0x7e>
   11df6:	4a17      	ldr	r2, [pc, #92]	; (11e54 <at_ota_download_package+0x90>)
   11df8:	4293      	cmp	r3, r2
   11dfa:	d022      	beq.n	11e42 <at_ota_download_package+0x7e>
        package_offset = 0;
   11dfc:	4b16      	ldr	r3, [pc, #88]	; (11e58 <at_ota_download_package+0x94>)
        package_sn     = 0;
   11dfe:	602c      	str	r4, [r5, #0]
        package_offset = 0;
   11e00:	601c      	str	r4, [r3, #0]
    if ((at_parse_calculate_crc8(data, length, &calculate_crc) != AT_RET_OK) || (calculate_crc != *crc))
   11e02:	ab02      	add	r3, sp, #8
   11e04:	1dda      	adds	r2, r3, #7
   11e06:	9901      	ldr	r1, [sp, #4]
   11e08:	0038      	movs	r0, r7
   11e0a:	f7f8 fde9 	bl	a9e0 <at_parse_calculate_crc8>
   11e0e:	9000      	str	r0, [sp, #0]
   11e10:	2800      	cmp	r0, #0
   11e12:	d1e5      	bne.n	11de0 <at_ota_download_package+0x1c>
   11e14:	ab02      	add	r3, sp, #8
   11e16:	7832      	ldrb	r2, [r6, #0]
   11e18:	79db      	ldrb	r3, [r3, #7]
   11e1a:	429a      	cmp	r2, r3
   11e1c:	d1e0      	bne.n	11de0 <at_ota_download_package+0x1c>
    if (ota_package_download(package_offset, data, length, at_ota_helper_download_done) != NEUL_UPDATE_RET_OK)
   11e1e:	4e0e      	ldr	r6, [pc, #56]	; (11e58 <at_ota_download_package+0x94>)
   11e20:	4b0e      	ldr	r3, [pc, #56]	; (11e5c <at_ota_download_package+0x98>)
   11e22:	9a01      	ldr	r2, [sp, #4]
   11e24:	0039      	movs	r1, r7
   11e26:	6830      	ldr	r0, [r6, #0]
   11e28:	f7f5 f9a2 	bl	7170 <ota_package_download>
   11e2c:	2800      	cmp	r0, #0
   11e2e:	d1d7      	bne.n	11de0 <at_ota_download_package+0x1c>
    at_ota_helper_take_binary();
   11e30:	f7ff feb4 	bl	11b9c <at_ota_helper_take_binary>
    package_offset += length;
   11e34:	6832      	ldr	r2, [r6, #0]
   11e36:	9b01      	ldr	r3, [sp, #4]
   11e38:	4694      	mov	ip, r2
   11e3a:	4463      	add	r3, ip
   11e3c:	6033      	str	r3, [r6, #0]
    package_sn      = sn;
   11e3e:	602c      	str	r4, [r5, #0]
    return AT_RET_OK;
   11e40:	e7d0      	b.n	11de4 <at_ota_download_package+0x20>
    else if (sn != ((package_sn + 1) & 0xFFFF))
   11e42:	3301      	adds	r3, #1
   11e44:	b29b      	uxth	r3, r3
   11e46:	429c      	cmp	r4, r3
   11e48:	d1ca      	bne.n	11de0 <at_ota_download_package+0x1c>
   11e4a:	e7da      	b.n	11e02 <at_ota_download_package+0x3e>
   11e4c:	010024d4 	.word	0x010024d4
   11e50:	010024e0 	.word	0x010024e0
   11e54:	0000ffff 	.word	0x0000ffff
   11e58:	010024dc 	.word	0x010024dc
   11e5c:	00011c19 	.word	0x00011c19

00011e60 <at_handle_NCALTEMPSENSOR_cmd_test>:
}

static AT_RET at_handle_NCALTEMPSENSOR_cmd_test(void)
{
    return AT_RET_OK;
}
   11e60:	2000      	movs	r0, #0
   11e62:	4770      	bx	lr

00011e64 <at_handle_NRDMIPI_cmd_test>:
{
   11e64:	b510      	push	{r4, lr}
    app_at_send_at_rsp_string_lines_with_claim_and_log(AT_NRDMIPI_TEST_RSP);
   11e66:	4802      	ldr	r0, [pc, #8]	; (11e70 <at_handle_NRDMIPI_cmd_test+0xc>)
   11e68:	f7f7 fbbc 	bl	95e4 <app_at_send_at_rsp_string_lines_with_claim_and_log>
}
   11e6c:	2000      	movs	r0, #0
   11e6e:	bd10      	pop	{r4, pc}
   11e70:	0002539f 	.word	0x0002539f

00011e74 <at_handle_NRDEXEC_cmd_test>:
{
   11e74:	b510      	push	{r4, lr}
    app_at_send_at_rsp_string_lines_with_claim_and_log(AT_NRDEXEC_TEST_RSP);
   11e76:	4802      	ldr	r0, [pc, #8]	; (11e80 <at_handle_NRDEXEC_cmd_test+0xc>)
   11e78:	f7f7 fbb4 	bl	95e4 <app_at_send_at_rsp_string_lines_with_claim_and_log>
}
   11e7c:	2000      	movs	r0, #0
   11e7e:	bd10      	pop	{r4, pc}
   11e80:	00025358 	.word	0x00025358

00011e84 <at_handle_NRDSET_cmd_test>:
{
   11e84:	b510      	push	{r4, lr}
    app_at_send_at_rsp_string_lines_with_claim_and_log(AT_NRDSET_TEST_RSP);
   11e86:	4802      	ldr	r0, [pc, #8]	; (11e90 <at_handle_NRDSET_cmd_test+0xc>)
   11e88:	f7f7 fbac 	bl	95e4 <app_at_send_at_rsp_string_lines_with_claim_and_log>
}
   11e8c:	2000      	movs	r0, #0
   11e8e:	bd10      	pop	{r4, pc}
   11e90:	00025402 	.word	0x00025402

00011e94 <at_handle_NRDCTRL_cmd_test>:
{
   11e94:	b510      	push	{r4, lr}
    app_at_send_at_rsp_string_lines_with_claim_and_log(AT_NRDCTRL_TEST_RSP);
   11e96:	4802      	ldr	r0, [pc, #8]	; (11ea0 <at_handle_NRDCTRL_cmd_test+0xc>)
   11e98:	f7f7 fba4 	bl	95e4 <app_at_send_at_rsp_string_lines_with_claim_and_log>
}
   11e9c:	2000      	movs	r0, #0
   11e9e:	bd10      	pop	{r4, pc}
   11ea0:	000252e9 	.word	0x000252e9

00011ea4 <at_handle_NRDMIPI_cmd_set>:
{
   11ea4:	b5f0      	push	{r4, r5, r6, r7, lr}
    uint8             data                                      = 0;
   11ea6:	2500      	movs	r5, #0
   11ea8:	240b      	movs	r4, #11
{
   11eaa:	0006      	movs	r6, r0
   11eac:	b08b      	sub	sp, #44	; 0x2c
    uint8             str_function[AT_CMD_NRDMIPI_PREFIX_LEN]   = {0};
   11eae:	2206      	movs	r2, #6
   11eb0:	0029      	movs	r1, r5
    uint8             data                                      = 0;
   11eb2:	446c      	add	r4, sp
    uint8             str_function[AT_CMD_NRDMIPI_PREFIX_LEN]   = {0};
   11eb4:	a803      	add	r0, sp, #12
    uint8             data                                      = 0;
   11eb6:	7025      	strb	r5, [r4, #0]
    if (at_create_param_array(p_atparams_string, &num_recvparams, 3, 4) != AT_RET_OK)
   11eb8:	af02      	add	r7, sp, #8
    uint8             str_function[AT_CMD_NRDMIPI_PREFIX_LEN]   = {0};
   11eba:	f7ee fa11 	bl	2e0 <memset>
    char              rsp_string[AT_MAX_NRDEXEC_MIPIR_RSP_LEN]  = {0};
   11ebe:	2212      	movs	r2, #18
   11ec0:	0029      	movs	r1, r5
   11ec2:	a805      	add	r0, sp, #20
   11ec4:	f7ee fa0c 	bl	2e0 <memset>
    if (at_create_param_array(p_atparams_string, &num_recvparams, 3, 4) != AT_RET_OK)
   11ec8:	2304      	movs	r3, #4
   11eca:	2203      	movs	r2, #3
   11ecc:	0039      	movs	r1, r7
   11ece:	0030      	movs	r0, r6
   11ed0:	f7f8 fa08 	bl	a2e4 <at_create_param_array>
   11ed4:	42a8      	cmp	r0, r5
   11ed6:	d002      	beq.n	11ede <at_handle_NRDMIPI_cmd_set+0x3a>
       return AT_RET_SYNTAX_ERROR;
   11ed8:	2001      	movs	r0, #1
}
   11eda:	b00b      	add	sp, #44	; 0x2c
   11edc:	bdf0      	pop	{r4, r5, r6, r7, pc}
    if (at_get_string_param(AT_PARSE_FIRST_PARAM_POS, str_function, AT_CMD_NRDMIPI_PREFIX_LEN, true) != AT_RET_OK)
   11ede:	2301      	movs	r3, #1
   11ee0:	2206      	movs	r2, #6
   11ee2:	a903      	add	r1, sp, #12
   11ee4:	f7f8 fc50 	bl	a788 <at_get_string_param>
   11ee8:	2800      	cmp	r0, #0
   11eea:	d1f5      	bne.n	11ed8 <at_handle_NRDMIPI_cmd_set+0x34>
    cause = at_get_uint8_param(AT_PARSE_SECOND_PARAM_POS, &slave_addr, true);
   11eec:	2509      	movs	r5, #9
   11eee:	2201      	movs	r2, #1
   11ef0:	446d      	add	r5, sp
   11ef2:	0029      	movs	r1, r5
   11ef4:	0010      	movs	r0, r2
   11ef6:	f7f8 fb89 	bl	a60c <at_get_uint8_param>
    if(cause != AT_RET_OK)
   11efa:	2800      	cmp	r0, #0
   11efc:	d1ed      	bne.n	11eda <at_handle_NRDMIPI_cmd_set+0x36>
    cause = at_get_uint8_param(AT_PARSE_THIRD_PARAM_POS, &data_addr, true);
   11efe:	260a      	movs	r6, #10
   11f00:	446e      	add	r6, sp
   11f02:	2201      	movs	r2, #1
   11f04:	0031      	movs	r1, r6
   11f06:	3002      	adds	r0, #2
   11f08:	f7f8 fb80 	bl	a60c <at_get_uint8_param>
    if(cause != AT_RET_OK)
   11f0c:	2800      	cmp	r0, #0
   11f0e:	d1e4      	bne.n	11eda <at_handle_NRDMIPI_cmd_set+0x36>
    if (num_recvparams == AT_NRDMIPI_WRITE_PARAM_NUM)
   11f10:	783b      	ldrb	r3, [r7, #0]
   11f12:	2b04      	cmp	r3, #4
   11f14:	d024      	beq.n	11f60 <at_handle_NRDMIPI_cmd_set+0xbc>
    if (at_strcmp(str_function, AT_CMD_NRDMIPI_FUNC_WRITE_STR) == 0)
   11f16:	491d      	ldr	r1, [pc, #116]	; (11f8c <at_handle_NRDMIPI_cmd_set+0xe8>)
   11f18:	a803      	add	r0, sp, #12
   11f1a:	f009 fa21 	bl	1b360 <strcmp>
   11f1e:	2800      	cmp	r0, #0
   11f20:	d026      	beq.n	11f70 <at_handle_NRDMIPI_cmd_set+0xcc>
    else if (at_strcmp(str_function, AT_CMD_NRDMIPI_FUNC_READ_STR) == 0)
   11f22:	4f1b      	ldr	r7, [pc, #108]	; (11f90 <at_handle_NRDMIPI_cmd_set+0xec>)
   11f24:	a803      	add	r0, sp, #12
   11f26:	0039      	movs	r1, r7
   11f28:	f009 fa1a 	bl	1b360 <strcmp>
   11f2c:	2800      	cmp	r0, #0
   11f2e:	d1d3      	bne.n	11ed8 <at_handle_NRDMIPI_cmd_set+0x34>
        if (num_recvparams != AT_NRDMIPI_READ_PARAM_NUM)
   11f30:	ab02      	add	r3, sp, #8
   11f32:	781b      	ldrb	r3, [r3, #0]
   11f34:	2b03      	cmp	r3, #3
   11f36:	d1cf      	bne.n	11ed8 <at_handle_NRDMIPI_cmd_set+0x34>
        result = production_radio_config_read_mipi_word(slave_addr, data_addr, &data);
   11f38:	7828      	ldrb	r0, [r5, #0]
   11f3a:	7831      	ldrb	r1, [r6, #0]
   11f3c:	0022      	movs	r2, r4
   11f3e:	f009 ff04 	bl	1bd4a <production_radio_config_read_mipi_word>
   11f42:	1e05      	subs	r5, r0, #0
        if (result == NEUL_RET_OK)
   11f44:	d11e      	bne.n	11f84 <at_handle_NRDMIPI_cmd_set+0xe0>
            (void)snprintf(rsp_string, AT_MAX_NRDEXEC_MIPIR_RSP_LEN, "%s%s,%d", AT_NRDMIPI_PREFIX, AT_CMD_NRDMIPI_FUNC_READ_STR, data);
   11f46:	7823      	ldrb	r3, [r4, #0]
   11f48:	4a12      	ldr	r2, [pc, #72]	; (11f94 <at_handle_NRDMIPI_cmd_set+0xf0>)
   11f4a:	9301      	str	r3, [sp, #4]
   11f4c:	9700      	str	r7, [sp, #0]
   11f4e:	4b12      	ldr	r3, [pc, #72]	; (11f98 <at_handle_NRDMIPI_cmd_set+0xf4>)
   11f50:	2112      	movs	r1, #18
   11f52:	a805      	add	r0, sp, #20
   11f54:	f008 fc8a 	bl	1a86c <snprintf>
            app_at_send_at_rsp_string_lines_with_claim_and_log(rsp_string);
   11f58:	a805      	add	r0, sp, #20
   11f5a:	f7f7 fb43 	bl	95e4 <app_at_send_at_rsp_string_lines_with_claim_and_log>
   11f5e:	e011      	b.n	11f84 <at_handle_NRDMIPI_cmd_set+0xe0>
        cause = at_get_uint8_param(AT_PARSE_FOURTH_PARAM_POS, &data, true);
   11f60:	2201      	movs	r2, #1
   11f62:	0021      	movs	r1, r4
   11f64:	2003      	movs	r0, #3
   11f66:	f7f8 fb51 	bl	a60c <at_get_uint8_param>
        if(cause != AT_RET_OK)
   11f6a:	2800      	cmp	r0, #0
   11f6c:	d0d3      	beq.n	11f16 <at_handle_NRDMIPI_cmd_set+0x72>
   11f6e:	e7b4      	b.n	11eda <at_handle_NRDMIPI_cmd_set+0x36>
        if (num_recvparams != AT_NRDMIPI_WRITE_PARAM_NUM)
   11f70:	ab02      	add	r3, sp, #8
   11f72:	781b      	ldrb	r3, [r3, #0]
   11f74:	2b04      	cmp	r3, #4
   11f76:	d1af      	bne.n	11ed8 <at_handle_NRDMIPI_cmd_set+0x34>
        result = production_radio_config_write_mipi_word(slave_addr, data_addr, data);
   11f78:	7828      	ldrb	r0, [r5, #0]
   11f7a:	7822      	ldrb	r2, [r4, #0]
   11f7c:	7831      	ldrb	r1, [r6, #0]
   11f7e:	f009 fef6 	bl	1bd6e <production_radio_config_write_mipi_word>
   11f82:	0005      	movs	r5, r0
    return at_parse_convert_neul_result(result);
   11f84:	0028      	movs	r0, r5
   11f86:	f7f8 f983 	bl	a290 <at_parse_convert_neul_result>
   11f8a:	e7a6      	b.n	11eda <at_handle_NRDMIPI_cmd_set+0x36>
   11f8c:	00023cb3 	.word	0x00023cb3
   11f90:	00023cb9 	.word	0x00023cb9
   11f94:	00023ae4 	.word	0x00023ae4
   11f98:	00025395 	.word	0x00025395

00011f9c <at_handle_NRDEXEC_cmd_set>:
{
   11f9c:	b5f0      	push	{r4, r5, r6, r7, lr}
    if (at_create_param_array(p_atparams_string, &num_recvparams, 1, 11) != AT_RET_OK)
   11f9e:	2422      	movs	r4, #34	; 0x22
{
   11fa0:	0005      	movs	r5, r0
   11fa2:	b09d      	sub	sp, #116	; 0x74
    uint8               str_function[AT_CMD_NRDEXEC_PREFIX_LEN]   = {0};
   11fa4:	220b      	movs	r2, #11
   11fa6:	2100      	movs	r1, #0
   11fa8:	a80f      	add	r0, sp, #60	; 0x3c
    if (at_create_param_array(p_atparams_string, &num_recvparams, 1, 11) != AT_RET_OK)
   11faa:	446c      	add	r4, sp
    uint8               str_function[AT_CMD_NRDEXEC_PREFIX_LEN]   = {0};
   11fac:	f7ee f998 	bl	2e0 <memset>
    if (at_create_param_array(p_atparams_string, &num_recvparams, 1, 11) != AT_RET_OK)
   11fb0:	230b      	movs	r3, #11
   11fb2:	2201      	movs	r2, #1
   11fb4:	0021      	movs	r1, r4
   11fb6:	0028      	movs	r0, r5
   11fb8:	f7f8 f994 	bl	a2e4 <at_create_param_array>
   11fbc:	2800      	cmp	r0, #0
   11fbe:	d001      	beq.n	11fc4 <at_handle_NRDEXEC_cmd_set+0x28>
        return AT_RET_SYNTAX_ERROR;
   11fc0:	2401      	movs	r4, #1
   11fc2:	e052      	b.n	1206a <at_handle_NRDEXEC_cmd_set+0xce>
    if (at_get_string_param(AT_PARSE_FIRST_PARAM_POS, str_function, AT_CMD_NRDEXEC_PREFIX_LEN, true) != AT_RET_OK)
   11fc4:	2301      	movs	r3, #1
   11fc6:	220b      	movs	r2, #11
   11fc8:	a90f      	add	r1, sp, #60	; 0x3c
   11fca:	f7f8 fbdd 	bl	a788 <at_get_string_param>
   11fce:	2800      	cmp	r0, #0
   11fd0:	d1f6      	bne.n	11fc0 <at_handle_NRDEXEC_cmd_set+0x24>
    if (at_strcmp(str_function, AT_NRDEXEC_RXRSSI_STRING) == 0)
   11fd2:	49ba      	ldr	r1, [pc, #744]	; (122bc <at_handle_NRDEXEC_cmd_set+0x320>)
   11fd4:	a80f      	add	r0, sp, #60	; 0x3c
   11fd6:	f009 f9c3 	bl	1b360 <strcmp>
   11fda:	1e01      	subs	r1, r0, #0
   11fdc:	d148      	bne.n	12070 <at_handle_NRDEXEC_cmd_set+0xd4>
        if (num_recvparams != AT_NRDEXEC_RXRSSI_PARAM_NUM)
   11fde:	7823      	ldrb	r3, [r4, #0]
   11fe0:	2b04      	cmp	r3, #4
   11fe2:	d1ed      	bne.n	11fc0 <at_handle_NRDEXEC_cmd_set+0x24>
    char              rsp_string[AT_MAX_NRDEXEC_RXRSSI_RSP_LEN] = {0};
   11fe4:	2220      	movs	r2, #32
   11fe6:	a812      	add	r0, sp, #72	; 0x48
   11fe8:	f7ee f97a 	bl	2e0 <memset>
    cause = at_get_uint32_param(AT_PARSE_SECOND_PARAM_POS, &freq, true);
   11fec:	2201      	movs	r2, #1
   11fee:	a90e      	add	r1, sp, #56	; 0x38
   11ff0:	0010      	movs	r0, r2
   11ff2:	f7f8 fa13 	bl	a41c <at_get_uint32_param>
   11ff6:	1e04      	subs	r4, r0, #0
    if(cause != AT_RET_OK)
   11ff8:	d137      	bne.n	1206a <at_handle_NRDEXEC_cmd_set+0xce>
    cause = at_get_uint16_param(AT_PARSE_THIRD_PARAM_POS, &gain_index, true);
   11ffa:	252a      	movs	r5, #42	; 0x2a
   11ffc:	446d      	add	r5, sp
   11ffe:	2201      	movs	r2, #1
   12000:	0029      	movs	r1, r5
   12002:	2002      	movs	r0, #2
   12004:	f7f8 fa82 	bl	a50c <at_get_uint16_param>
   12008:	1e04      	subs	r4, r0, #0
    if(cause != AT_RET_OK)
   1200a:	d12e      	bne.n	1206a <at_handle_NRDEXEC_cmd_set+0xce>
    if (gain_index > AT_MAX_GAIN_INDEX_VALUE && gain_index != AT_SPECIAL_GAIN_INDEX_VALUE)
   1200c:	882b      	ldrh	r3, [r5, #0]
   1200e:	2b0a      	cmp	r3, #10
   12010:	d901      	bls.n	12016 <at_handle_NRDEXEC_cmd_set+0x7a>
   12012:	2bff      	cmp	r3, #255	; 0xff
   12014:	d1d4      	bne.n	11fc0 <at_handle_NRDEXEC_cmd_set+0x24>
    cause = at_get_uint16_param(AT_PARSE_FOURTH_PARAM_POS, &port, true);
   12016:	ae0d      	add	r6, sp, #52	; 0x34
   12018:	2201      	movs	r2, #1
   1201a:	0031      	movs	r1, r6
   1201c:	2003      	movs	r0, #3
   1201e:	f7f8 fa75 	bl	a50c <at_get_uint16_param>
   12022:	1e04      	subs	r4, r0, #0
    if (cause != AT_RET_OK)
   12024:	d121      	bne.n	1206a <at_handle_NRDEXEC_cmd_set+0xce>
    if ((port != 0) && (port != 1))
   12026:	8833      	ldrh	r3, [r6, #0]
   12028:	2b01      	cmp	r3, #1
   1202a:	d8c9      	bhi.n	11fc0 <at_handle_NRDEXEC_cmd_set+0x24>
    result = production_radio_config_meas_rssi(freq, (uint8)gain_index, &rssi, &snr, (uint8)port);
   1202c:	b2db      	uxtb	r3, r3
   1202e:	af0c      	add	r7, sp, #48	; 0x30
   12030:	ae0b      	add	r6, sp, #44	; 0x2c
   12032:	7829      	ldrb	r1, [r5, #0]
   12034:	0032      	movs	r2, r6
   12036:	9300      	str	r3, [sp, #0]
   12038:	980e      	ldr	r0, [sp, #56]	; 0x38
   1203a:	003b      	movs	r3, r7
   1203c:	f009 fe6c 	bl	1bd18 <production_radio_config_meas_rssi>
    cause = at_parse_convert_neul_result(result);
   12040:	f7f8 f926 	bl	a290 <at_parse_convert_neul_result>
   12044:	1e04      	subs	r4, r0, #0
    if (cause != AT_RET_OK)
   12046:	d110      	bne.n	1206a <at_handle_NRDEXEC_cmd_set+0xce>
    (void)snprintf(rsp_string, AT_MAX_NRDEXEC_RXRSSI_RSP_LEN, "%s%s,%d,%d", AT_NRDEXEC_TEST_PREFIX, AT_NRDEXEC_RXRSSI_STRING, rssi, snr);
   12048:	2200      	movs	r2, #0
   1204a:	5ebb      	ldrsh	r3, [r7, r2]
   1204c:	2120      	movs	r1, #32
   1204e:	9302      	str	r3, [sp, #8]
   12050:	2200      	movs	r2, #0
   12052:	5eb3      	ldrsh	r3, [r6, r2]
   12054:	a812      	add	r0, sp, #72	; 0x48
   12056:	9301      	str	r3, [sp, #4]
   12058:	4b98      	ldr	r3, [pc, #608]	; (122bc <at_handle_NRDEXEC_cmd_set+0x320>)
   1205a:	4a99      	ldr	r2, [pc, #612]	; (122c0 <at_handle_NRDEXEC_cmd_set+0x324>)
   1205c:	9300      	str	r3, [sp, #0]
   1205e:	4b99      	ldr	r3, [pc, #612]	; (122c4 <at_handle_NRDEXEC_cmd_set+0x328>)
   12060:	f008 fc04 	bl	1a86c <snprintf>
    app_at_send_at_rsp_string_lines_with_claim_and_log(rsp_string);
   12064:	a812      	add	r0, sp, #72	; 0x48
   12066:	f7f7 fabd 	bl	95e4 <app_at_send_at_rsp_string_lines_with_claim_and_log>
}
   1206a:	0020      	movs	r0, r4
   1206c:	b01d      	add	sp, #116	; 0x74
   1206e:	bdf0      	pop	{r4, r5, r6, r7, pc}
    else if (at_strcmp(str_function, AT_NRDEXEC_TXVERIFY_STRING) == 0)
   12070:	4995      	ldr	r1, [pc, #596]	; (122c8 <at_handle_NRDEXEC_cmd_set+0x32c>)
   12072:	a80f      	add	r0, sp, #60	; 0x3c
   12074:	f009 f974 	bl	1b360 <strcmp>
   12078:	2800      	cmp	r0, #0
   1207a:	d16e      	bne.n	1215a <at_handle_NRDEXEC_cmd_set+0x1be>
        if (num_recvparams != AT_NRDEXEC_TXVERIFY_PARAM_NUM && num_recvparams != AT_NRDEXEC_TXVERIFY_IGNORED_NUM)
   1207c:	7823      	ldrb	r3, [r4, #0]
   1207e:	3b08      	subs	r3, #8
   12080:	2b01      	cmp	r3, #1
   12082:	d89d      	bhi.n	11fc0 <at_handle_NRDEXEC_cmd_set+0x24>
    uint16              subcarrier_index=0;
   12084:	242a      	movs	r4, #42	; 0x2a
    cause = at_get_uint32_param(AT_PARSE_SECOND_PARAM_POS, &frequency, true);
   12086:	2201      	movs	r2, #1
    uint16              subcarrier_index=0;
   12088:	446c      	add	r4, sp
   1208a:	8020      	strh	r0, [r4, #0]
    cause = at_get_uint32_param(AT_PARSE_SECOND_PARAM_POS, &frequency, true);
   1208c:	a90e      	add	r1, sp, #56	; 0x38
   1208e:	0010      	movs	r0, r2
   12090:	f7f8 f9c4 	bl	a41c <at_get_uint32_param>
    if (cause != AT_RET_OK)
   12094:	2800      	cmp	r0, #0
   12096:	d000      	beq.n	1209a <at_handle_NRDEXEC_cmd_set+0xfe>
   12098:	e792      	b.n	11fc0 <at_handle_NRDEXEC_cmd_set+0x24>
    cause = at_get_uint16_param(AT_PARSE_THIRD_PARAM_POS, &band, true);
   1209a:	2626      	movs	r6, #38	; 0x26
   1209c:	446e      	add	r6, sp
   1209e:	2201      	movs	r2, #1
   120a0:	0031      	movs	r1, r6
   120a2:	2002      	movs	r0, #2
   120a4:	f7f8 fa32 	bl	a50c <at_get_uint16_param>
    if ((cause != AT_RET_OK) || (band > AT_NRDEXEC_MAX_BAND_VALUE))
   120a8:	2800      	cmp	r0, #0
   120aa:	d000      	beq.n	120ae <at_handle_NRDEXEC_cmd_set+0x112>
   120ac:	e788      	b.n	11fc0 <at_handle_NRDEXEC_cmd_set+0x24>
   120ae:	8833      	ldrh	r3, [r6, #0]
   120b0:	2bff      	cmp	r3, #255	; 0xff
   120b2:	d900      	bls.n	120b6 <at_handle_NRDEXEC_cmd_set+0x11a>
   120b4:	e784      	b.n	11fc0 <at_handle_NRDEXEC_cmd_set+0x24>
    cause = at_get_int16_param(AT_PARSE_FOURTH_PARAM_POS, &temperature, true);
   120b6:	2201      	movs	r2, #1
   120b8:	a90b      	add	r1, sp, #44	; 0x2c
   120ba:	3003      	adds	r0, #3
   120bc:	f7f8 fad8 	bl	a670 <at_get_int16_param>
    if (cause != AT_RET_OK)
   120c0:	2800      	cmp	r0, #0
   120c2:	d000      	beq.n	120c6 <at_handle_NRDEXEC_cmd_set+0x12a>
   120c4:	e77c      	b.n	11fc0 <at_handle_NRDEXEC_cmd_set+0x24>
    cause = at_get_int16_param(AT_PARSE_FIFTH_PARAM_POS, &voltage, true);
   120c6:	2201      	movs	r2, #1
   120c8:	a90c      	add	r1, sp, #48	; 0x30
   120ca:	3004      	adds	r0, #4
   120cc:	f7f8 fad0 	bl	a670 <at_get_int16_param>
    if (cause != AT_RET_OK)
   120d0:	2800      	cmp	r0, #0
   120d2:	d000      	beq.n	120d6 <at_handle_NRDEXEC_cmd_set+0x13a>
   120d4:	e774      	b.n	11fc0 <at_handle_NRDEXEC_cmd_set+0x24>
    cause = at_get_int16_param(AT_PARSE_SIXTH_PARAM_POS, &tx_power, true);
   120d6:	af0d      	add	r7, sp, #52	; 0x34
   120d8:	2201      	movs	r2, #1
   120da:	0039      	movs	r1, r7
   120dc:	3005      	adds	r0, #5
   120de:	f7f8 fac7 	bl	a670 <at_get_int16_param>
    if (cause != AT_RET_OK)
   120e2:	2800      	cmp	r0, #0
   120e4:	d000      	beq.n	120e8 <at_handle_NRDEXEC_cmd_set+0x14c>
   120e6:	e76b      	b.n	11fc0 <at_handle_NRDEXEC_cmd_set+0x24>
    cause = at_get_uint32_param(AT_PARSE_SEVENTH_PARAM_POS, &tx_duration, true);
   120e8:	2201      	movs	r2, #1
   120ea:	a912      	add	r1, sp, #72	; 0x48
   120ec:	3006      	adds	r0, #6
   120ee:	f7f8 f995 	bl	a41c <at_get_uint32_param>
    if (cause != AT_RET_OK)
   120f2:	2800      	cmp	r0, #0
   120f4:	d000      	beq.n	120f8 <at_handle_NRDEXEC_cmd_set+0x15c>
   120f6:	e763      	b.n	11fc0 <at_handle_NRDEXEC_cmd_set+0x24>
    cause = at_get_uint16_param(AT_PARSE_EIGHTH_PARAM_POS, &num_subcarrier, true);
   120f8:	ad0a      	add	r5, sp, #40	; 0x28
   120fa:	2201      	movs	r2, #1
   120fc:	0029      	movs	r1, r5
   120fe:	3007      	adds	r0, #7
   12100:	f7f8 fa04 	bl	a50c <at_get_uint16_param>
    if (cause != AT_RET_OK)
   12104:	2800      	cmp	r0, #0
   12106:	d000      	beq.n	1210a <at_handle_NRDEXEC_cmd_set+0x16e>
   12108:	e75a      	b.n	11fc0 <at_handle_NRDEXEC_cmd_set+0x24>
    cause = at_get_uint16_param(AT_PARSE_NINTH_PARAM_POS, &subcarrier_index, true);
   1210a:	2201      	movs	r2, #1
   1210c:	0021      	movs	r1, r4
   1210e:	3008      	adds	r0, #8
   12110:	f7f8 f9fc 	bl	a50c <at_get_uint16_param>
    if (cause != AT_RET_OK && cause != AT_RET_PARAM_MISSING)
   12114:	2800      	cmp	r0, #0
   12116:	d002      	beq.n	1211e <at_handle_NRDEXEC_cmd_set+0x182>
   12118:	2803      	cmp	r0, #3
   1211a:	d000      	beq.n	1211e <at_handle_NRDEXEC_cmd_set+0x182>
   1211c:	e750      	b.n	11fc0 <at_handle_NRDEXEC_cmd_set+0x24>
    if (at_check_num_sc_for_sc_index(num_subcarrier, subcarrier_index) != AT_RET_OK)
   1211e:	8821      	ldrh	r1, [r4, #0]
   12120:	8828      	ldrh	r0, [r5, #0]
   12122:	f7f8 fc71 	bl	aa08 <at_check_num_sc_for_sc_index>
   12126:	2800      	cmp	r0, #0
   12128:	d000      	beq.n	1212c <at_handle_NRDEXEC_cmd_set+0x190>
   1212a:	e749      	b.n	11fc0 <at_handle_NRDEXEC_cmd_set+0x24>
    result = production_radio_config_tx_verify((int8)tx_power, frequency, tx_duration, (uint8)band, temperature, voltage, (uint8)num_subcarrier, (uint8)subcarrier_index);
   1212c:	2000      	movs	r0, #0
   1212e:	7822      	ldrb	r2, [r4, #0]
   12130:	7833      	ldrb	r3, [r6, #0]
   12132:	5638      	ldrsb	r0, [r7, r0]
   12134:	9203      	str	r2, [sp, #12]
   12136:	782a      	ldrb	r2, [r5, #0]
   12138:	9202      	str	r2, [sp, #8]
   1213a:	466a      	mov	r2, sp
   1213c:	2130      	movs	r1, #48	; 0x30
   1213e:	5e52      	ldrsh	r2, [r2, r1]
   12140:	9201      	str	r2, [sp, #4]
   12142:	466a      	mov	r2, sp
   12144:	212c      	movs	r1, #44	; 0x2c
   12146:	5e52      	ldrsh	r2, [r2, r1]
   12148:	990e      	ldr	r1, [sp, #56]	; 0x38
   1214a:	9200      	str	r2, [sp, #0]
   1214c:	9a12      	ldr	r2, [sp, #72]	; 0x48
   1214e:	f009 fe73 	bl	1be38 <production_radio_config_tx_verify>
    return at_parse_convert_neul_result(result);
   12152:	f7f8 f89d 	bl	a290 <at_parse_convert_neul_result>
   12156:	0004      	movs	r4, r0
        return at_handle_nrdexec_rxcalist();
   12158:	e787      	b.n	1206a <at_handle_NRDEXEC_cmd_set+0xce>
    else if (at_strcmp(str_function, AT_NRDEXEC_RXVERIFY_STRING) == 0)
   1215a:	495c      	ldr	r1, [pc, #368]	; (122cc <at_handle_NRDEXEC_cmd_set+0x330>)
   1215c:	a80f      	add	r0, sp, #60	; 0x3c
   1215e:	f009 f8ff 	bl	1b360 <strcmp>
   12162:	1e01      	subs	r1, r0, #0
   12164:	d167      	bne.n	12236 <at_handle_NRDEXEC_cmd_set+0x29a>
        if (num_recvparams != AT_NRDEXEC_RXVERIFY_PARAM_NUM)
   12166:	7823      	ldrb	r3, [r4, #0]
   12168:	2b06      	cmp	r3, #6
   1216a:	d000      	beq.n	1216e <at_handle_NRDEXEC_cmd_set+0x1d2>
   1216c:	e728      	b.n	11fc0 <at_handle_NRDEXEC_cmd_set+0x24>
    char                rsp_string[AT_NRDEXEC_RXVERIFY_RSP_LEN] = {0};
   1216e:	2227      	movs	r2, #39	; 0x27
   12170:	a812      	add	r0, sp, #72	; 0x48
   12172:	f7ee f8b5 	bl	2e0 <memset>
    cause = at_get_uint32_param(AT_PARSE_SECOND_PARAM_POS, &frequency, true);
   12176:	2201      	movs	r2, #1
   12178:	a90e      	add	r1, sp, #56	; 0x38
   1217a:	0010      	movs	r0, r2
   1217c:	f7f8 f94e 	bl	a41c <at_get_uint32_param>
    if (cause != AT_RET_OK)
   12180:	2800      	cmp	r0, #0
   12182:	d000      	beq.n	12186 <at_handle_NRDEXEC_cmd_set+0x1ea>
   12184:	e71c      	b.n	11fc0 <at_handle_NRDEXEC_cmd_set+0x24>
    cause = at_get_uint16_param(AT_PARSE_THIRD_PARAM_POS, &band, true);
   12186:	ac09      	add	r4, sp, #36	; 0x24
   12188:	2201      	movs	r2, #1
   1218a:	0021      	movs	r1, r4
   1218c:	2002      	movs	r0, #2
   1218e:	f7f8 f9bd 	bl	a50c <at_get_uint16_param>
    if ((cause != AT_RET_OK) || (band > AT_NRDEXEC_MAX_BAND_VALUE))
   12192:	2800      	cmp	r0, #0
   12194:	d000      	beq.n	12198 <at_handle_NRDEXEC_cmd_set+0x1fc>
   12196:	e713      	b.n	11fc0 <at_handle_NRDEXEC_cmd_set+0x24>
   12198:	8823      	ldrh	r3, [r4, #0]
   1219a:	2bff      	cmp	r3, #255	; 0xff
   1219c:	d900      	bls.n	121a0 <at_handle_NRDEXEC_cmd_set+0x204>
   1219e:	e70f      	b.n	11fc0 <at_handle_NRDEXEC_cmd_set+0x24>
    cause = at_get_int16_param(AT_PARSE_FOURTH_PARAM_POS, &temperature, true);
   121a0:	ad0a      	add	r5, sp, #40	; 0x28
   121a2:	2201      	movs	r2, #1
   121a4:	0029      	movs	r1, r5
   121a6:	3003      	adds	r0, #3
   121a8:	f7f8 fa62 	bl	a670 <at_get_int16_param>
    if (cause != AT_RET_OK)
   121ac:	2800      	cmp	r0, #0
   121ae:	d000      	beq.n	121b2 <at_handle_NRDEXEC_cmd_set+0x216>
   121b0:	e706      	b.n	11fc0 <at_handle_NRDEXEC_cmd_set+0x24>
    cause = at_get_int16_param(AT_PARSE_FIFTH_PARAM_POS, &voltage, true);
   121b2:	212a      	movs	r1, #42	; 0x2a
   121b4:	2201      	movs	r2, #1
   121b6:	4469      	add	r1, sp
   121b8:	3004      	adds	r0, #4
   121ba:	f7f8 fa59 	bl	a670 <at_get_int16_param>
    if (cause != AT_RET_OK)
   121be:	2800      	cmp	r0, #0
   121c0:	d000      	beq.n	121c4 <at_handle_NRDEXEC_cmd_set+0x228>
   121c2:	e6fd      	b.n	11fc0 <at_handle_NRDEXEC_cmd_set+0x24>
    cause = at_get_uint16_param(AT_PARSE_SIXTH_PARAM_POS, &gain_index, true);
   121c4:	2626      	movs	r6, #38	; 0x26
   121c6:	446e      	add	r6, sp
   121c8:	2201      	movs	r2, #1
   121ca:	0031      	movs	r1, r6
   121cc:	3005      	adds	r0, #5
   121ce:	f7f8 f99d 	bl	a50c <at_get_uint16_param>
    if (cause != AT_RET_OK)
   121d2:	2800      	cmp	r0, #0
   121d4:	d000      	beq.n	121d8 <at_handle_NRDEXEC_cmd_set+0x23c>
   121d6:	e6f3      	b.n	11fc0 <at_handle_NRDEXEC_cmd_set+0x24>
    if (gain_index > AT_MAX_GAIN_INDEX_VALUE && gain_index != AT_SPECIAL_GAIN_INDEX_VALUE)
   121d8:	8831      	ldrh	r1, [r6, #0]
   121da:	290a      	cmp	r1, #10
   121dc:	d902      	bls.n	121e4 <at_handle_NRDEXEC_cmd_set+0x248>
   121de:	29ff      	cmp	r1, #255	; 0xff
   121e0:	d000      	beq.n	121e4 <at_handle_NRDEXEC_cmd_set+0x248>
   121e2:	e6ed      	b.n	11fc0 <at_handle_NRDEXEC_cmd_set+0x24>
    result = production_radio_config_rx_verify(frequency, (uint8)gain_index, (uint8)band, temperature, voltage, &rssi, &snr, &cbm);
   121e4:	202a      	movs	r0, #42	; 0x2a
   121e6:	2200      	movs	r2, #0
   121e8:	5eab      	ldrsh	r3, [r5, r2]
   121ea:	af0d      	add	r7, sp, #52	; 0x34
   121ec:	ae0c      	add	r6, sp, #48	; 0x30
   121ee:	ad0b      	add	r5, sp, #44	; 0x2c
   121f0:	7822      	ldrb	r2, [r4, #0]
   121f2:	4468      	add	r0, sp
   121f4:	9703      	str	r7, [sp, #12]
   121f6:	9602      	str	r6, [sp, #8]
   121f8:	9501      	str	r5, [sp, #4]
   121fa:	2400      	movs	r4, #0
   121fc:	5f00      	ldrsh	r0, [r0, r4]
   121fe:	b2c9      	uxtb	r1, r1
   12200:	9000      	str	r0, [sp, #0]
   12202:	980e      	ldr	r0, [sp, #56]	; 0x38
   12204:	f009 fe9c 	bl	1bf40 <production_radio_config_rx_verify>
    cause = at_parse_convert_neul_result(result);
   12208:	f7f8 f842 	bl	a290 <at_parse_convert_neul_result>
   1220c:	1e04      	subs	r4, r0, #0
    if (cause != AT_RET_OK)
   1220e:	d000      	beq.n	12212 <at_handle_NRDEXEC_cmd_set+0x276>
   12210:	e72b      	b.n	1206a <at_handle_NRDEXEC_cmd_set+0xce>
    (void)snprintf(rsp_string, AT_NRDEXEC_RXVERIFY_RSP_LEN, "%s%s,%d,%d,%d", AT_NRDEXEC_TEST_PREFIX, AT_NRDEXEC_RXVERIFY_STRING, rssi, snr, cbm);
   12212:	2200      	movs	r2, #0
   12214:	5ebb      	ldrsh	r3, [r7, r2]
   12216:	2127      	movs	r1, #39	; 0x27
   12218:	9303      	str	r3, [sp, #12]
   1221a:	2200      	movs	r2, #0
   1221c:	5eb3      	ldrsh	r3, [r6, r2]
   1221e:	a812      	add	r0, sp, #72	; 0x48
   12220:	9302      	str	r3, [sp, #8]
   12222:	2200      	movs	r2, #0
   12224:	5eab      	ldrsh	r3, [r5, r2]
   12226:	4a2a      	ldr	r2, [pc, #168]	; (122d0 <at_handle_NRDEXEC_cmd_set+0x334>)
   12228:	9301      	str	r3, [sp, #4]
   1222a:	4b28      	ldr	r3, [pc, #160]	; (122cc <at_handle_NRDEXEC_cmd_set+0x330>)
   1222c:	9300      	str	r3, [sp, #0]
   1222e:	4b25      	ldr	r3, [pc, #148]	; (122c4 <at_handle_NRDEXEC_cmd_set+0x328>)
   12230:	f008 fb1c 	bl	1a86c <snprintf>
   12234:	e716      	b.n	12064 <at_handle_NRDEXEC_cmd_set+0xc8>
    else if (at_strcmp(str_function, AT_NRDEXEC_TXTEST_STRING) == 0)
   12236:	4927      	ldr	r1, [pc, #156]	; (122d4 <at_handle_NRDEXEC_cmd_set+0x338>)
   12238:	a80f      	add	r0, sp, #60	; 0x3c
   1223a:	f009 f891 	bl	1b360 <strcmp>
   1223e:	2800      	cmp	r0, #0
   12240:	d14a      	bne.n	122d8 <at_handle_NRDEXEC_cmd_set+0x33c>
        if (num_recvparams != AT_NRDEXEC_TXTEST_IGNORED_NUM && num_recvparams != AT_NRDEXEC_TXTEST_PARAM_NUM)
   12242:	7823      	ldrb	r3, [r4, #0]
   12244:	3b04      	subs	r3, #4
   12246:	2b01      	cmp	r3, #1
   12248:	d900      	bls.n	1224c <at_handle_NRDEXEC_cmd_set+0x2b0>
   1224a:	e6b9      	b.n	11fc0 <at_handle_NRDEXEC_cmd_set+0x24>
    cause = at_get_uint32_param(AT_PARSE_SECOND_PARAM_POS, &frequency, true);
   1224c:	2201      	movs	r2, #1
    uint16              subcarrier_index=0;  // Default to zero if parameter not given by AT command
   1224e:	ac0e      	add	r4, sp, #56	; 0x38
   12250:	8020      	strh	r0, [r4, #0]
    cause = at_get_uint32_param(AT_PARSE_SECOND_PARAM_POS, &frequency, true);
   12252:	a912      	add	r1, sp, #72	; 0x48
   12254:	0010      	movs	r0, r2
   12256:	f7f8 f8e1 	bl	a41c <at_get_uint32_param>
    if (cause != AT_RET_OK)
   1225a:	2800      	cmp	r0, #0
   1225c:	d000      	beq.n	12260 <at_handle_NRDEXEC_cmd_set+0x2c4>
   1225e:	e6af      	b.n	11fc0 <at_handle_NRDEXEC_cmd_set+0x24>
    cause = at_get_uint16_param(AT_PARSE_THIRD_PARAM_POS, &band, true);
   12260:	ad0c      	add	r5, sp, #48	; 0x30
   12262:	2201      	movs	r2, #1
   12264:	0029      	movs	r1, r5
   12266:	2002      	movs	r0, #2
   12268:	f7f8 f950 	bl	a50c <at_get_uint16_param>
    if ((cause != AT_RET_OK) || (band > AT_NRDEXEC_MAX_BAND_VALUE))
   1226c:	2800      	cmp	r0, #0
   1226e:	d000      	beq.n	12272 <at_handle_NRDEXEC_cmd_set+0x2d6>
   12270:	e6a6      	b.n	11fc0 <at_handle_NRDEXEC_cmd_set+0x24>
   12272:	882b      	ldrh	r3, [r5, #0]
   12274:	2bff      	cmp	r3, #255	; 0xff
   12276:	d900      	bls.n	1227a <at_handle_NRDEXEC_cmd_set+0x2de>
   12278:	e6a2      	b.n	11fc0 <at_handle_NRDEXEC_cmd_set+0x24>
    cause = at_get_uint16_param(AT_PARSE_FOURTH_PARAM_POS, &num_subcarrier, true);
   1227a:	ae0d      	add	r6, sp, #52	; 0x34
   1227c:	2201      	movs	r2, #1
   1227e:	0031      	movs	r1, r6
   12280:	3003      	adds	r0, #3
   12282:	f7f8 f943 	bl	a50c <at_get_uint16_param>
    if (cause != AT_RET_OK)
   12286:	2800      	cmp	r0, #0
   12288:	d000      	beq.n	1228c <at_handle_NRDEXEC_cmd_set+0x2f0>
   1228a:	e699      	b.n	11fc0 <at_handle_NRDEXEC_cmd_set+0x24>
    cause = at_get_uint16_param(AT_PARSE_FIFTH_PARAM_POS, &subcarrier_index, true);
   1228c:	2201      	movs	r2, #1
   1228e:	0021      	movs	r1, r4
   12290:	3004      	adds	r0, #4
   12292:	f7f8 f93b 	bl	a50c <at_get_uint16_param>
    if (cause != AT_RET_OK && cause != AT_RET_PARAM_MISSING)
   12296:	2800      	cmp	r0, #0
   12298:	d002      	beq.n	122a0 <at_handle_NRDEXEC_cmd_set+0x304>
   1229a:	2803      	cmp	r0, #3
   1229c:	d000      	beq.n	122a0 <at_handle_NRDEXEC_cmd_set+0x304>
   1229e:	e68f      	b.n	11fc0 <at_handle_NRDEXEC_cmd_set+0x24>
    if (at_check_num_sc_for_sc_index(num_subcarrier, subcarrier_index) != AT_RET_OK)
   122a0:	8821      	ldrh	r1, [r4, #0]
   122a2:	8830      	ldrh	r0, [r6, #0]
   122a4:	f7f8 fbb0 	bl	aa08 <at_check_num_sc_for_sc_index>
   122a8:	2800      	cmp	r0, #0
   122aa:	d000      	beq.n	122ae <at_handle_NRDEXEC_cmd_set+0x312>
   122ac:	e688      	b.n	11fc0 <at_handle_NRDEXEC_cmd_set+0x24>
    result = production_radio_config_tx_test(frequency, (uint8)band, (uint8)num_subcarrier, (uint8)subcarrier_index);
   122ae:	7823      	ldrb	r3, [r4, #0]
   122b0:	7832      	ldrb	r2, [r6, #0]
   122b2:	7829      	ldrb	r1, [r5, #0]
   122b4:	9812      	ldr	r0, [sp, #72]	; 0x48
   122b6:	f009 fe73 	bl	1bfa0 <production_radio_config_tx_test>
   122ba:	e74a      	b.n	12152 <at_handle_NRDEXEC_cmd_set+0x1b6>
   122bc:	0002530e 	.word	0x0002530e
   122c0:	000238d6 	.word	0x000238d6
   122c4:	00025315 	.word	0x00025315
   122c8:	0002531f 	.word	0x0002531f
   122cc:	00025328 	.word	0x00025328
   122d0:	00025331 	.word	0x00025331
   122d4:	0002533f 	.word	0x0002533f
    else if (at_strcmp(str_function, AT_NRDEXEC_TXCALIST_STRING) == 0)
   122d8:	4970      	ldr	r1, [pc, #448]	; (1249c <at_handle_NRDEXEC_cmd_set+0x500>)
   122da:	a80f      	add	r0, sp, #60	; 0x3c
   122dc:	f009 f840 	bl	1b360 <strcmp>
   122e0:	2800      	cmp	r0, #0
   122e2:	d15f      	bne.n	123a4 <at_handle_NRDEXEC_cmd_set+0x408>
        if (num_recvparams != AT_NRDEXEC_TXCALIST_PARAM_NUM)
   122e4:	7823      	ldrb	r3, [r4, #0]
   122e6:	2b09      	cmp	r3, #9
   122e8:	d000      	beq.n	122ec <at_handle_NRDEXEC_cmd_set+0x350>
   122ea:	e669      	b.n	11fc0 <at_handle_NRDEXEC_cmd_set+0x24>
    cause = at_get_uint32_param(AT_PARSE_SECOND_PARAM_POS, &start_frequency, true);
   122ec:	2201      	movs	r2, #1
    uint16               subcarrier_index = 0;
   122ee:	ac0c      	add	r4, sp, #48	; 0x30
   122f0:	8020      	strh	r0, [r4, #0]
    cause = at_get_uint32_param(AT_PARSE_SECOND_PARAM_POS, &start_frequency, true);
   122f2:	a90d      	add	r1, sp, #52	; 0x34
   122f4:	0010      	movs	r0, r2
   122f6:	f7f8 f891 	bl	a41c <at_get_uint32_param>
    if (cause != AT_RET_OK)
   122fa:	2800      	cmp	r0, #0
   122fc:	d000      	beq.n	12300 <at_handle_NRDEXEC_cmd_set+0x364>
   122fe:	e65f      	b.n	11fc0 <at_handle_NRDEXEC_cmd_set+0x24>
    cause = at_get_uint32_param(AT_PARSE_THIRD_PARAM_POS, &step_frequency, true);
   12300:	2201      	movs	r2, #1
   12302:	a90e      	add	r1, sp, #56	; 0x38
   12304:	2002      	movs	r0, #2
   12306:	f7f8 f889 	bl	a41c <at_get_uint32_param>
    if (cause != AT_RET_OK)
   1230a:	2800      	cmp	r0, #0
   1230c:	d000      	beq.n	12310 <at_handle_NRDEXEC_cmd_set+0x374>
   1230e:	e657      	b.n	11fc0 <at_handle_NRDEXEC_cmd_set+0x24>
    cause = at_get_uint32_param(AT_PARSE_FOURTH_PARAM_POS, &stop_frequency, true);
   12310:	2201      	movs	r2, #1
   12312:	a912      	add	r1, sp, #72	; 0x48
   12314:	3003      	adds	r0, #3
   12316:	f7f8 f881 	bl	a41c <at_get_uint32_param>
    if (cause != AT_RET_OK)
   1231a:	2800      	cmp	r0, #0
   1231c:	d000      	beq.n	12320 <at_handle_NRDEXEC_cmd_set+0x384>
   1231e:	e64f      	b.n	11fc0 <at_handle_NRDEXEC_cmd_set+0x24>
    cause = at_get_int16_param(AT_PARSE_FIFTH_PARAM_POS, &start_power, true);
   12320:	2726      	movs	r7, #38	; 0x26
   12322:	446f      	add	r7, sp
   12324:	2201      	movs	r2, #1
   12326:	0039      	movs	r1, r7
   12328:	3004      	adds	r0, #4
   1232a:	f7f8 f9a1 	bl	a670 <at_get_int16_param>
    if (cause != AT_RET_OK)
   1232e:	2800      	cmp	r0, #0
   12330:	d000      	beq.n	12334 <at_handle_NRDEXEC_cmd_set+0x398>
   12332:	e645      	b.n	11fc0 <at_handle_NRDEXEC_cmd_set+0x24>
    cause = at_get_int16_param(AT_PARSE_SIXTH_PARAM_POS, &step_power, true);
   12334:	2201      	movs	r2, #1
   12336:	a90a      	add	r1, sp, #40	; 0x28
   12338:	3005      	adds	r0, #5
   1233a:	f7f8 f999 	bl	a670 <at_get_int16_param>
    if (cause != AT_RET_OK)
   1233e:	2800      	cmp	r0, #0
   12340:	d000      	beq.n	12344 <at_handle_NRDEXEC_cmd_set+0x3a8>
   12342:	e63d      	b.n	11fc0 <at_handle_NRDEXEC_cmd_set+0x24>
    cause = at_get_int16_param(AT_PARSE_SEVENTH_PARAM_POS, &stop_power, true);
   12344:	252a      	movs	r5, #42	; 0x2a
   12346:	446d      	add	r5, sp
   12348:	2201      	movs	r2, #1
   1234a:	0029      	movs	r1, r5
   1234c:	3006      	adds	r0, #6
   1234e:	f7f8 f98f 	bl	a670 <at_get_int16_param>
    if (cause != AT_RET_OK)
   12352:	2800      	cmp	r0, #0
   12354:	d000      	beq.n	12358 <at_handle_NRDEXEC_cmd_set+0x3bc>
   12356:	e633      	b.n	11fc0 <at_handle_NRDEXEC_cmd_set+0x24>
    cause = at_get_uint16_param(AT_PARSE_EIGHTH_PARAM_POS, &num_subcarrier, true);
   12358:	ae0b      	add	r6, sp, #44	; 0x2c
   1235a:	2201      	movs	r2, #1
   1235c:	0031      	movs	r1, r6
   1235e:	3007      	adds	r0, #7
   12360:	f7f8 f8d4 	bl	a50c <at_get_uint16_param>
    if (cause != AT_RET_OK)
   12364:	2800      	cmp	r0, #0
   12366:	d000      	beq.n	1236a <at_handle_NRDEXEC_cmd_set+0x3ce>
   12368:	e62a      	b.n	11fc0 <at_handle_NRDEXEC_cmd_set+0x24>
    cause = at_get_uint16_param(AT_PARSE_NINTH_PARAM_POS, &subcarrier_index, true);
   1236a:	2201      	movs	r2, #1
   1236c:	0021      	movs	r1, r4
   1236e:	3008      	adds	r0, #8
   12370:	f7f8 f8cc 	bl	a50c <at_get_uint16_param>
    if (cause != AT_RET_OK)
   12374:	2800      	cmp	r0, #0
   12376:	d000      	beq.n	1237a <at_handle_NRDEXEC_cmd_set+0x3de>
   12378:	e622      	b.n	11fc0 <at_handle_NRDEXEC_cmd_set+0x24>
    result = production_radio_config_tx_calist(start_frequency, step_frequency, stop_frequency, (int8)start_power, (int8)step_power, (int8)stop_power, (uint8)num_subcarrier, (uint8)subcarrier_index);
   1237a:	2300      	movs	r3, #0
   1237c:	7822      	ldrb	r2, [r4, #0]
   1237e:	56fb      	ldrsb	r3, [r7, r3]
   12380:	9203      	str	r2, [sp, #12]
   12382:	7832      	ldrb	r2, [r6, #0]
   12384:	2128      	movs	r1, #40	; 0x28
   12386:	9202      	str	r2, [sp, #8]
   12388:	2200      	movs	r2, #0
   1238a:	56aa      	ldrsb	r2, [r5, r2]
   1238c:	980d      	ldr	r0, [sp, #52]	; 0x34
   1238e:	9201      	str	r2, [sp, #4]
   12390:	466a      	mov	r2, sp
   12392:	1852      	adds	r2, r2, r1
   12394:	7812      	ldrb	r2, [r2, #0]
   12396:	990e      	ldr	r1, [sp, #56]	; 0x38
   12398:	b252      	sxtb	r2, r2
   1239a:	9200      	str	r2, [sp, #0]
   1239c:	9a12      	ldr	r2, [sp, #72]	; 0x48
   1239e:	f009 fd6c 	bl	1be7a <production_radio_config_tx_calist>
   123a2:	e6d6      	b.n	12152 <at_handle_NRDEXEC_cmd_set+0x1b6>
    else if (at_strcmp(str_function, AT_NRDEXEC_RXCALIST_STRING) == 0)
   123a4:	493e      	ldr	r1, [pc, #248]	; (124a0 <at_handle_NRDEXEC_cmd_set+0x504>)
   123a6:	a80f      	add	r0, sp, #60	; 0x3c
   123a8:	f008 ffda 	bl	1b360 <strcmp>
   123ac:	2800      	cmp	r0, #0
   123ae:	d000      	beq.n	123b2 <at_handle_NRDEXEC_cmd_set+0x416>
   123b0:	e606      	b.n	11fc0 <at_handle_NRDEXEC_cmd_set+0x24>
        if (num_recvparams != AT_NRDEXEC_RXCALIST_PARAM_NUM)
   123b2:	7823      	ldrb	r3, [r4, #0]
   123b4:	2b0b      	cmp	r3, #11
   123b6:	d000      	beq.n	123ba <at_handle_NRDEXEC_cmd_set+0x41e>
   123b8:	e602      	b.n	11fc0 <at_handle_NRDEXEC_cmd_set+0x24>
    cause = at_get_uint32_param(AT_PARSE_SECOND_PARAM_POS, &start_frequency, true);
   123ba:	2201      	movs	r2, #1
   123bc:	a90b      	add	r1, sp, #44	; 0x2c
   123be:	0010      	movs	r0, r2
   123c0:	f7f8 f82c 	bl	a41c <at_get_uint32_param>
    if (cause != AT_RET_OK)
   123c4:	2800      	cmp	r0, #0
   123c6:	d000      	beq.n	123ca <at_handle_NRDEXEC_cmd_set+0x42e>
   123c8:	e5fa      	b.n	11fc0 <at_handle_NRDEXEC_cmd_set+0x24>
    cause = at_get_uint32_param(AT_PARSE_THIRD_PARAM_POS, &step_frequency, true);
   123ca:	2201      	movs	r2, #1
   123cc:	a90c      	add	r1, sp, #48	; 0x30
   123ce:	2002      	movs	r0, #2
   123d0:	f7f8 f824 	bl	a41c <at_get_uint32_param>
    if (cause != AT_RET_OK)
   123d4:	2800      	cmp	r0, #0
   123d6:	d000      	beq.n	123da <at_handle_NRDEXEC_cmd_set+0x43e>
   123d8:	e5f2      	b.n	11fc0 <at_handle_NRDEXEC_cmd_set+0x24>
    cause = at_get_uint32_param(AT_PARSE_FOURTH_PARAM_POS, &stop_frequency, true);
   123da:	2201      	movs	r2, #1
   123dc:	a90d      	add	r1, sp, #52	; 0x34
   123de:	3003      	adds	r0, #3
   123e0:	f7f8 f81c 	bl	a41c <at_get_uint32_param>
    if (cause != AT_RET_OK)
   123e4:	2800      	cmp	r0, #0
   123e6:	d000      	beq.n	123ea <at_handle_NRDEXEC_cmd_set+0x44e>
   123e8:	e5ea      	b.n	11fc0 <at_handle_NRDEXEC_cmd_set+0x24>
    cause = at_get_uint8_param(AT_PARSE_FIFTH_PARAM_POS, &start_agc_index, true);
   123ea:	2723      	movs	r7, #35	; 0x23
   123ec:	446f      	add	r7, sp
   123ee:	2201      	movs	r2, #1
   123f0:	0039      	movs	r1, r7
   123f2:	3004      	adds	r0, #4
   123f4:	f7f8 f90a 	bl	a60c <at_get_uint8_param>
    if (cause != AT_RET_OK)
   123f8:	2800      	cmp	r0, #0
   123fa:	d000      	beq.n	123fe <at_handle_NRDEXEC_cmd_set+0x462>
   123fc:	e5e0      	b.n	11fc0 <at_handle_NRDEXEC_cmd_set+0x24>
    cause = at_get_uint8_param(AT_PARSE_SIXTH_PARAM_POS, &step_agc_index, true);
   123fe:	2201      	movs	r2, #1
   12400:	a909      	add	r1, sp, #36	; 0x24
   12402:	3005      	adds	r0, #5
   12404:	f7f8 f902 	bl	a60c <at_get_uint8_param>
    if (cause != AT_RET_OK)
   12408:	2800      	cmp	r0, #0
   1240a:	d000      	beq.n	1240e <at_handle_NRDEXEC_cmd_set+0x472>
   1240c:	e5d8      	b.n	11fc0 <at_handle_NRDEXEC_cmd_set+0x24>
    cause = at_get_uint8_param(AT_PARSE_SEVENTH_PARAM_POS, &stop_agc_index, true);
   1240e:	2426      	movs	r4, #38	; 0x26
   12410:	446c      	add	r4, sp
   12412:	2201      	movs	r2, #1
   12414:	0021      	movs	r1, r4
   12416:	3006      	adds	r0, #6
   12418:	f7f8 f8f8 	bl	a60c <at_get_uint8_param>
    if (cause != AT_RET_OK)
   1241c:	2800      	cmp	r0, #0
   1241e:	d000      	beq.n	12422 <at_handle_NRDEXEC_cmd_set+0x486>
   12420:	e5ce      	b.n	11fc0 <at_handle_NRDEXEC_cmd_set+0x24>
    cause = at_get_int16_param(AT_PARSE_EIGHTH_PARAM_POS, &ul_power, true);
   12422:	252a      	movs	r5, #42	; 0x2a
   12424:	446d      	add	r5, sp
   12426:	2201      	movs	r2, #1
   12428:	0029      	movs	r1, r5
   1242a:	3007      	adds	r0, #7
   1242c:	f7f8 f920 	bl	a670 <at_get_int16_param>
    if (cause != AT_RET_OK)
   12430:	2800      	cmp	r0, #0
   12432:	d000      	beq.n	12436 <at_handle_NRDEXEC_cmd_set+0x49a>
   12434:	e5c4      	b.n	11fc0 <at_handle_NRDEXEC_cmd_set+0x24>
    cause = at_get_uint32_param(AT_PARSE_NINTH_PARAM_POS, &ul_freq, true);
   12436:	2201      	movs	r2, #1
   12438:	a90e      	add	r1, sp, #56	; 0x38
   1243a:	3008      	adds	r0, #8
   1243c:	f7f7 ffee 	bl	a41c <at_get_uint32_param>
    if (cause != AT_RET_OK)
   12440:	2800      	cmp	r0, #0
   12442:	d000      	beq.n	12446 <at_handle_NRDEXEC_cmd_set+0x4aa>
   12444:	e5bc      	b.n	11fc0 <at_handle_NRDEXEC_cmd_set+0x24>
    cause = at_get_uint32_param(AT_PARSE_TENTH_PARAM_POS, &rssi_meas_duration, true);
   12446:	2201      	movs	r2, #1
   12448:	a912      	add	r1, sp, #72	; 0x48
   1244a:	3009      	adds	r0, #9
   1244c:	f7f7 ffe6 	bl	a41c <at_get_uint32_param>
    if (cause != AT_RET_OK)
   12450:	2800      	cmp	r0, #0
   12452:	d000      	beq.n	12456 <at_handle_NRDEXEC_cmd_set+0x4ba>
   12454:	e5b4      	b.n	11fc0 <at_handle_NRDEXEC_cmd_set+0x24>
    cause = at_get_uint8_param(AT_PARSE_ELEVENTH_PARAM_POS, &sweep_band, true);
   12456:	ae0a      	add	r6, sp, #40	; 0x28
   12458:	2201      	movs	r2, #1
   1245a:	0031      	movs	r1, r6
   1245c:	300a      	adds	r0, #10
   1245e:	f7f8 f8d5 	bl	a60c <at_get_uint8_param>
    if (cause != AT_RET_OK)
   12462:	2800      	cmp	r0, #0
   12464:	d000      	beq.n	12468 <at_handle_NRDEXEC_cmd_set+0x4cc>
   12466:	e5ab      	b.n	11fc0 <at_handle_NRDEXEC_cmd_set+0x24>
    result =  production_radio_config_rx_calist(start_frequency, step_frequency, stop_frequency, start_agc_index, step_agc_index, stop_agc_index, ul_power, ul_freq, rssi_meas_duration, sweep_band, nrdexec_rxlist_callback);
   12468:	4a0e      	ldr	r2, [pc, #56]	; (124a4 <at_handle_NRDEXEC_cmd_set+0x508>)
   1246a:	783b      	ldrb	r3, [r7, #0]
   1246c:	9206      	str	r2, [sp, #24]
   1246e:	7832      	ldrb	r2, [r6, #0]
   12470:	980b      	ldr	r0, [sp, #44]	; 0x2c
   12472:	9205      	str	r2, [sp, #20]
   12474:	9a12      	ldr	r2, [sp, #72]	; 0x48
   12476:	9204      	str	r2, [sp, #16]
   12478:	9a0e      	ldr	r2, [sp, #56]	; 0x38
   1247a:	9203      	str	r2, [sp, #12]
   1247c:	2100      	movs	r1, #0
   1247e:	5e6a      	ldrsh	r2, [r5, r1]
   12480:	2124      	movs	r1, #36	; 0x24
   12482:	9202      	str	r2, [sp, #8]
   12484:	7822      	ldrb	r2, [r4, #0]
   12486:	9201      	str	r2, [sp, #4]
   12488:	466a      	mov	r2, sp
   1248a:	1852      	adds	r2, r2, r1
   1248c:	7812      	ldrb	r2, [r2, #0]
   1248e:	990c      	ldr	r1, [sp, #48]	; 0x30
   12490:	9200      	str	r2, [sp, #0]
   12492:	9a0d      	ldr	r2, [sp, #52]	; 0x34
   12494:	f009 fd12 	bl	1bebc <production_radio_config_rx_calist>
   12498:	e65b      	b.n	12152 <at_handle_NRDEXEC_cmd_set+0x1b6>
   1249a:	46c0      	nop			; (mov r8, r8)
   1249c:	00025346 	.word	0x00025346
   124a0:	0002534f 	.word	0x0002534f
   124a4:	000127fd 	.word	0x000127fd

000124a8 <at_handle_NRDSET_cmd_read>:
{
   124a8:	b5f0      	push	{r4, r5, r6, r7, lr}
   124aa:	b095      	sub	sp, #84	; 0x54
    char              pio_string[AT_MAX_NRDSET_PIO_READ_RSP_LEN] = {0x00};
   124ac:	221f      	movs	r2, #31
   124ae:	2100      	movs	r1, #0
   124b0:	a80b      	add	r0, sp, #44	; 0x2c
    if (production_radio_config_get_gpio(&pio) != NEUL_RET_OK)
   124b2:	ac08      	add	r4, sp, #32
    char              pio_string[AT_MAX_NRDSET_PIO_READ_RSP_LEN] = {0x00};
   124b4:	f7ed ff14 	bl	2e0 <memset>
    if (production_radio_config_get_gpio(&pio) != NEUL_RET_OK)
   124b8:	0020      	movs	r0, r4
   124ba:	f009 fd5f 	bl	1bf7c <production_radio_config_get_gpio>
   124be:	0005      	movs	r5, r0
        return AT_RET_PROGRESS_ERROR;
   124c0:	2006      	movs	r0, #6
    if (production_radio_config_get_gpio(&pio) != NEUL_RET_OK)
   124c2:	2d00      	cmp	r5, #0
   124c4:	d13b      	bne.n	1253e <at_handle_NRDSET_cmd_read+0x96>
    (void)snprintf(pio_string, AT_MAX_NRDSET_PIO_READ_RSP_LEN, "%s%s,0x%llx", AT_NRDSET_TEST_PREFIX, AT_NRDSET_PIO_STRING, pio);
   124c6:	9a08      	ldr	r2, [sp, #32]
   124c8:	9b09      	ldr	r3, [sp, #36]	; 0x24
   124ca:	4e1e      	ldr	r6, [pc, #120]	; (12544 <at_handle_NRDSET_cmd_read+0x9c>)
   124cc:	9202      	str	r2, [sp, #8]
   124ce:	9303      	str	r3, [sp, #12]
   124d0:	4b1d      	ldr	r3, [pc, #116]	; (12548 <at_handle_NRDSET_cmd_read+0xa0>)
   124d2:	4a1e      	ldr	r2, [pc, #120]	; (1254c <at_handle_NRDSET_cmd_read+0xa4>)
   124d4:	211f      	movs	r1, #31
   124d6:	9300      	str	r3, [sp, #0]
   124d8:	a80b      	add	r0, sp, #44	; 0x2c
   124da:	0033      	movs	r3, r6
   124dc:	f008 f9c6 	bl	1a86c <snprintf>
    app_at_send_at_rsp_string_lines_with_claim_and_log(pio_string);
   124e0:	a80b      	add	r0, sp, #44	; 0x2c
   124e2:	f7f7 f87f 	bl	95e4 <app_at_send_at_rsp_string_lines_with_claim_and_log>
    if( production_radio_config_get_tx_gains(&tx_drive_level, &tx_coarse_gain, &rf_gain, &ext_pa_gain) != NEUL_RET_OK)
   124e6:	271d      	movs	r7, #29
    char                rsp_string[AT_MAX_NRDSET_GAIN_READ_RSP_LEN] = {0};
   124e8:	0029      	movs	r1, r5
   124ea:	2221      	movs	r2, #33	; 0x21
   124ec:	a80b      	add	r0, sp, #44	; 0x2c
   124ee:	f7ed fef7 	bl	2e0 <memset>
    if( production_radio_config_get_tx_gains(&tx_drive_level, &tx_coarse_gain, &rf_gain, &ext_pa_gain) != NEUL_RET_OK)
   124f2:	201e      	movs	r0, #30
   124f4:	446f      	add	r7, sp
   124f6:	0023      	movs	r3, r4
   124f8:	003a      	movs	r2, r7
   124fa:	a907      	add	r1, sp, #28
   124fc:	4468      	add	r0, sp
   124fe:	f009 fc62 	bl	1bdc6 <production_radio_config_get_tx_gains>
   12502:	0005      	movs	r5, r0
        return AT_RET_PROGRESS_ERROR;
   12504:	2006      	movs	r0, #6
    if( production_radio_config_get_tx_gains(&tx_drive_level, &tx_coarse_gain, &rf_gain, &ext_pa_gain) != NEUL_RET_OK)
   12506:	2d00      	cmp	r5, #0
   12508:	d119      	bne.n	1253e <at_handle_NRDSET_cmd_read+0x96>
    (void)snprintf(rsp_string, AT_MAX_NRDSET_GAIN_READ_RSP_LEN, "%s%s,%d,%d,%d,%d%s", AT_NRDSET_TEST_PREFIX, AT_NRDSET_GAIN_STRING, tx_drive_level, tx_coarse_gain, rf_gain, ext_pa_gain, APP_AT_STR_RN);
   1250a:	4b11      	ldr	r3, [pc, #68]	; (12550 <at_handle_NRDSET_cmd_read+0xa8>)
   1250c:	4a11      	ldr	r2, [pc, #68]	; (12554 <at_handle_NRDSET_cmd_read+0xac>)
   1250e:	9305      	str	r3, [sp, #20]
   12510:	8823      	ldrh	r3, [r4, #0]
   12512:	2121      	movs	r1, #33	; 0x21
   12514:	9304      	str	r3, [sp, #16]
   12516:	783b      	ldrb	r3, [r7, #0]
   12518:	a80b      	add	r0, sp, #44	; 0x2c
   1251a:	9303      	str	r3, [sp, #12]
   1251c:	466b      	mov	r3, sp
   1251e:	7f1b      	ldrb	r3, [r3, #28]
   12520:	9302      	str	r3, [sp, #8]
   12522:	466b      	mov	r3, sp
   12524:	8bdb      	ldrh	r3, [r3, #30]
   12526:	9301      	str	r3, [sp, #4]
   12528:	4b0b      	ldr	r3, [pc, #44]	; (12558 <at_handle_NRDSET_cmd_read+0xb0>)
   1252a:	9300      	str	r3, [sp, #0]
   1252c:	0033      	movs	r3, r6
   1252e:	f008 f99d 	bl	1a86c <snprintf>
    app_at_send_at_rsp_string(rsp_string, true, AT_FLAG_LOGABLE);
   12532:	a80b      	add	r0, sp, #44	; 0x2c
   12534:	2208      	movs	r2, #8
   12536:	2101      	movs	r1, #1
   12538:	f7f7 f846 	bl	95c8 <app_at_send_at_rsp_string>
    return AT_RET_OK;
   1253c:	0028      	movs	r0, r5
}
   1253e:	b015      	add	sp, #84	; 0x54
   12540:	bdf0      	pop	{r4, r5, r6, r7, pc}
   12542:	46c0      	nop			; (mov r8, r8)
   12544:	000253cd 	.word	0x000253cd
   12548:	000253e2 	.word	0x000253e2
   1254c:	000253d6 	.word	0x000253d6
   12550:	00022d8f 	.word	0x00022d8f
   12554:	000253e6 	.word	0x000253e6
   12558:	000253f9 	.word	0x000253f9

0001255c <at_handle_NRDSET_cmd_set>:
{
   1255c:	b5f0      	push	{r4, r5, r6, r7, lr}
   1255e:	b089      	sub	sp, #36	; 0x24
   12560:	0005      	movs	r5, r0
    uint8               str_function[AT_CMD_NRDSET_PREFIX_LEN]   = {0};
   12562:	2205      	movs	r2, #5
   12564:	2100      	movs	r1, #0
   12566:	a804      	add	r0, sp, #16
   12568:	f7ed feba 	bl	2e0 <memset>
    if (at_create_param_array(p_atparams_string, &num_recvparams, 1, 5) != AT_RET_OK)
   1256c:	466b      	mov	r3, sp
   1256e:	1ddc      	adds	r4, r3, #7
   12570:	2201      	movs	r2, #1
   12572:	2305      	movs	r3, #5
   12574:	0021      	movs	r1, r4
   12576:	0028      	movs	r0, r5
   12578:	f7f7 feb4 	bl	a2e4 <at_create_param_array>
   1257c:	2800      	cmp	r0, #0
   1257e:	d003      	beq.n	12588 <at_handle_NRDSET_cmd_set+0x2c>
        return AT_RET_SYNTAX_ERROR;
   12580:	2401      	movs	r4, #1
}
   12582:	0020      	movs	r0, r4
   12584:	b009      	add	sp, #36	; 0x24
   12586:	bdf0      	pop	{r4, r5, r6, r7, pc}
    if (at_get_string_param(AT_PARSE_FIRST_PARAM_POS, str_function, AT_CMD_NRDSET_PREFIX_LEN, true) != AT_RET_OK)
   12588:	2301      	movs	r3, #1
   1258a:	2205      	movs	r2, #5
   1258c:	a904      	add	r1, sp, #16
   1258e:	f7f8 f8fb 	bl	a788 <at_get_string_param>
   12592:	2800      	cmp	r0, #0
   12594:	d1f4      	bne.n	12580 <at_handle_NRDSET_cmd_set+0x24>
    if (at_strcmp(str_function, AT_NRDSET_RIO_STRING) == 0)
   12596:	4950      	ldr	r1, [pc, #320]	; (126d8 <at_handle_NRDSET_cmd_set+0x17c>)
   12598:	a804      	add	r0, sp, #16
   1259a:	f008 fee1 	bl	1b360 <strcmp>
   1259e:	2800      	cmp	r0, #0
   125a0:	d11d      	bne.n	125de <at_handle_NRDSET_cmd_set+0x82>
        if (num_recvparams != AT_NRDSET_RIO_PARAM_NUM)
   125a2:	7823      	ldrb	r3, [r4, #0]
   125a4:	2b03      	cmp	r3, #3
   125a6:	d1eb      	bne.n	12580 <at_handle_NRDSET_cmd_set+0x24>
    cause = at_get_uint16_param(AT_PARSE_SECOND_PARAM_POS, &rio, true);
   125a8:	2201      	movs	r2, #1
   125aa:	ad03      	add	r5, sp, #12
   125ac:	0029      	movs	r1, r5
   125ae:	0010      	movs	r0, r2
   125b0:	f7f7 ffac 	bl	a50c <at_get_uint16_param>
   125b4:	1e04      	subs	r4, r0, #0
    if(cause != AT_RET_OK)
   125b6:	d1e4      	bne.n	12582 <at_handle_NRDSET_cmd_set+0x26>
    cause = at_get_uint16_param(AT_PARSE_THIRD_PARAM_POS, &mv, true);
   125b8:	ae06      	add	r6, sp, #24
   125ba:	2201      	movs	r2, #1
   125bc:	0031      	movs	r1, r6
   125be:	2002      	movs	r0, #2
   125c0:	f7f7 ffa4 	bl	a50c <at_get_uint16_param>
   125c4:	1e04      	subs	r4, r0, #0
    if(cause != AT_RET_OK)
   125c6:	d1dc      	bne.n	12582 <at_handle_NRDSET_cmd_set+0x26>
    result = production_radio_config_set_rio_v((uint8)rio, mv);
   125c8:	8831      	ldrh	r1, [r6, #0]
   125ca:	7828      	ldrb	r0, [r5, #0]
   125cc:	f009 fc18 	bl	1be00 <production_radio_config_set_rio_v>
    if (result == NEUL_RET_DISABLED_OPERATION)
   125d0:	280e      	cmp	r0, #14
   125d2:	d100      	bne.n	125d6 <at_handle_NRDSET_cmd_set+0x7a>
   125d4:	e07e      	b.n	126d4 <at_handle_NRDSET_cmd_set+0x178>
    else if (result != NEUL_RET_OK)
   125d6:	2800      	cmp	r0, #0
   125d8:	d0d3      	beq.n	12582 <at_handle_NRDSET_cmd_set+0x26>
        return AT_RET_PROGRESS_ERROR;
   125da:	2406      	movs	r4, #6
        return at_handle_nrdset_gain();
   125dc:	e7d1      	b.n	12582 <at_handle_NRDSET_cmd_set+0x26>
    else if (at_strcmp(str_function, AT_NRDSET_PIO_STRING) == 0)
   125de:	493f      	ldr	r1, [pc, #252]	; (126dc <at_handle_NRDSET_cmd_set+0x180>)
   125e0:	a804      	add	r0, sp, #16
   125e2:	f008 febd 	bl	1b360 <strcmp>
   125e6:	2800      	cmp	r0, #0
   125e8:	d127      	bne.n	1263a <at_handle_NRDSET_cmd_set+0xde>
        if (num_recvparams != AT_NRDSET_PIO_PARAM_NUM)
   125ea:	7823      	ldrb	r3, [r4, #0]
   125ec:	2b02      	cmp	r3, #2
   125ee:	d1c7      	bne.n	12580 <at_handle_NRDSET_cmd_set+0x24>
    uint64            pio = 0;
   125f0:	2200      	movs	r2, #0
   125f2:	2300      	movs	r3, #0
    cause = at_get_hexstring_param(AT_PARSE_SECOND_PARAM_POS, &data_string, &data_string_len, true);
   125f4:	250a      	movs	r5, #10
    uint64            pio = 0;
   125f6:	9206      	str	r2, [sp, #24]
   125f8:	9307      	str	r3, [sp, #28]
    cause = at_get_hexstring_param(AT_PARSE_SECOND_PARAM_POS, &data_string, &data_string_len, true);
   125fa:	2301      	movs	r3, #1
   125fc:	446d      	add	r5, sp
   125fe:	002a      	movs	r2, r5
   12600:	a903      	add	r1, sp, #12
   12602:	0018      	movs	r0, r3
   12604:	f7f8 f912 	bl	a82c <at_get_hexstring_param>
   12608:	1e04      	subs	r4, r0, #0
    if (cause != AT_RET_OK)
   1260a:	d1ba      	bne.n	12582 <at_handle_NRDSET_cmd_set+0x26>
    if (at_check_hex_string_prefix(data_string, data_string_len))
   1260c:	8829      	ldrh	r1, [r5, #0]
   1260e:	9803      	ldr	r0, [sp, #12]
   12610:	f7f7 fee6 	bl	a3e0 <at_check_hex_string_prefix>
   12614:	2800      	cmp	r0, #0
   12616:	d0b3      	beq.n	12580 <at_handle_NRDSET_cmd_set+0x24>
        data_string_len = data_string_len - AT_CMD_HEX_PREFIX_LENGTH;
   12618:	882a      	ldrh	r2, [r5, #0]
        data_string = data_string + AT_CMD_HEX_PREFIX_LENGTH;
   1261a:	9b03      	ldr	r3, [sp, #12]
        data_string_len = data_string_len - AT_CMD_HEX_PREFIX_LENGTH;
   1261c:	3a02      	subs	r2, #2
        data_string = data_string + AT_CMD_HEX_PREFIX_LENGTH;
   1261e:	1c98      	adds	r0, r3, #2
        data_string_len = data_string_len - AT_CMD_HEX_PREFIX_LENGTH;
   12620:	b292      	uxth	r2, r2
    if (at_parse_buf_hex_to_uint64(data_string, &pio, data_string_len) == false)
   12622:	a906      	add	r1, sp, #24
        data_string = data_string + AT_CMD_HEX_PREFIX_LENGTH;
   12624:	9003      	str	r0, [sp, #12]
        data_string_len = data_string_len - AT_CMD_HEX_PREFIX_LENGTH;
   12626:	802a      	strh	r2, [r5, #0]
    if (at_parse_buf_hex_to_uint64(data_string, &pio, data_string_len) == false)
   12628:	f7f7 fdff 	bl	a22a <at_parse_buf_hex_to_uint64>
   1262c:	2800      	cmp	r0, #0
   1262e:	d0a7      	beq.n	12580 <at_handle_NRDSET_cmd_set+0x24>
    result = production_radio_config_set_gpio(pio);
   12630:	9806      	ldr	r0, [sp, #24]
   12632:	9907      	ldr	r1, [sp, #28]
   12634:	f009 fbf2 	bl	1be1c <production_radio_config_set_gpio>
   12638:	e7ca      	b.n	125d0 <at_handle_NRDSET_cmd_set+0x74>
    else if (at_strcmp(str_function, AT_NRDSET_TONE_STRING) == 0)
   1263a:	4929      	ldr	r1, [pc, #164]	; (126e0 <at_handle_NRDSET_cmd_set+0x184>)
   1263c:	a804      	add	r0, sp, #16
   1263e:	f008 fe8f 	bl	1b360 <strcmp>
   12642:	2800      	cmp	r0, #0
   12644:	d10f      	bne.n	12666 <at_handle_NRDSET_cmd_set+0x10a>
        if (num_recvparams != AT_NRDSET_TONE_PARAM_NUM)
   12646:	7823      	ldrb	r3, [r4, #0]
   12648:	2b02      	cmp	r3, #2
   1264a:	d000      	beq.n	1264e <at_handle_NRDSET_cmd_set+0xf2>
   1264c:	e798      	b.n	12580 <at_handle_NRDSET_cmd_set+0x24>
    cause = at_get_uint32_param(AT_PARSE_SECOND_PARAM_POS, &freq, true);
   1264e:	2201      	movs	r2, #1
   12650:	a906      	add	r1, sp, #24
   12652:	0010      	movs	r0, r2
   12654:	f7f7 fee2 	bl	a41c <at_get_uint32_param>
   12658:	1e04      	subs	r4, r0, #0
    if(cause != AT_RET_OK)
   1265a:	d000      	beq.n	1265e <at_handle_NRDSET_cmd_set+0x102>
   1265c:	e791      	b.n	12582 <at_handle_NRDSET_cmd_set+0x26>
    result = production_radio_config_tx_tone(freq);
   1265e:	9806      	ldr	r0, [sp, #24]
   12660:	f009 fb93 	bl	1bd8a <production_radio_config_tx_tone>
   12664:	e7b4      	b.n	125d0 <at_handle_NRDSET_cmd_set+0x74>
    else if (at_strcmp(str_function, AT_NRDSET_GAIN_STRING) == 0)
   12666:	491f      	ldr	r1, [pc, #124]	; (126e4 <at_handle_NRDSET_cmd_set+0x188>)
   12668:	a804      	add	r0, sp, #16
   1266a:	f008 fe79 	bl	1b360 <strcmp>
   1266e:	2800      	cmp	r0, #0
   12670:	d000      	beq.n	12674 <at_handle_NRDSET_cmd_set+0x118>
   12672:	e785      	b.n	12580 <at_handle_NRDSET_cmd_set+0x24>
        if (num_recvparams != AT_NRDSET_GAIN_PARAM_NUM)
   12674:	7823      	ldrb	r3, [r4, #0]
   12676:	2b05      	cmp	r3, #5
   12678:	d000      	beq.n	1267c <at_handle_NRDSET_cmd_set+0x120>
   1267a:	e781      	b.n	12580 <at_handle_NRDSET_cmd_set+0x24>
    cause = at_get_uint16_param(AT_PARSE_SECOND_PARAM_POS, &tx_drive_level, true);
   1267c:	2201      	movs	r2, #1
   1267e:	a902      	add	r1, sp, #8
   12680:	0010      	movs	r0, r2
   12682:	f7f7 ff43 	bl	a50c <at_get_uint16_param>
    if (cause != AT_RET_OK)
   12686:	2800      	cmp	r0, #0
   12688:	d000      	beq.n	1268c <at_handle_NRDSET_cmd_set+0x130>
   1268a:	e779      	b.n	12580 <at_handle_NRDSET_cmd_set+0x24>
    cause = at_get_uint16_param(AT_PARSE_THIRD_PARAM_POS, &tx_coarse_gain, true);
   1268c:	250a      	movs	r5, #10
   1268e:	446d      	add	r5, sp
   12690:	2201      	movs	r2, #1
   12692:	0029      	movs	r1, r5
   12694:	2002      	movs	r0, #2
   12696:	f7f7 ff39 	bl	a50c <at_get_uint16_param>
    if (cause != AT_RET_OK)
   1269a:	2800      	cmp	r0, #0
   1269c:	d000      	beq.n	126a0 <at_handle_NRDSET_cmd_set+0x144>
   1269e:	e76f      	b.n	12580 <at_handle_NRDSET_cmd_set+0x24>
    cause = at_get_uint16_param(AT_PARSE_FOURTH_PARAM_POS, &rf_gain, true);
   126a0:	ae03      	add	r6, sp, #12
   126a2:	2201      	movs	r2, #1
   126a4:	0031      	movs	r1, r6
   126a6:	3003      	adds	r0, #3
   126a8:	f7f7 ff30 	bl	a50c <at_get_uint16_param>
    if (cause != AT_RET_OK)
   126ac:	2800      	cmp	r0, #0
   126ae:	d000      	beq.n	126b2 <at_handle_NRDSET_cmd_set+0x156>
   126b0:	e766      	b.n	12580 <at_handle_NRDSET_cmd_set+0x24>
    cause = at_get_uint16_param(AT_PARSE_FIFTH_PARAM_POS, &mv, true);
   126b2:	af06      	add	r7, sp, #24
   126b4:	2201      	movs	r2, #1
   126b6:	0039      	movs	r1, r7
   126b8:	3004      	adds	r0, #4
   126ba:	f7f7 ff27 	bl	a50c <at_get_uint16_param>
   126be:	1e04      	subs	r4, r0, #0
    if (cause != AT_RET_OK)
   126c0:	d000      	beq.n	126c4 <at_handle_NRDSET_cmd_set+0x168>
   126c2:	e75d      	b.n	12580 <at_handle_NRDSET_cmd_set+0x24>
    result = production_radio_config_set_tx_gains(tx_drive_level, (uint8)tx_coarse_gain, (uint8)rf_gain, (uint16)mv);
   126c4:	4668      	mov	r0, sp
   126c6:	883b      	ldrh	r3, [r7, #0]
   126c8:	7832      	ldrb	r2, [r6, #0]
   126ca:	7829      	ldrb	r1, [r5, #0]
   126cc:	8900      	ldrh	r0, [r0, #8]
   126ce:	f009 fb6a 	bl	1bda6 <production_radio_config_set_tx_gains>
   126d2:	e77d      	b.n	125d0 <at_handle_NRDSET_cmd_set+0x74>
        return AT_RET_COMMAND_DISABLED;
   126d4:	0004      	movs	r4, r0
   126d6:	e754      	b.n	12582 <at_handle_NRDSET_cmd_set+0x26>
   126d8:	000253fe 	.word	0x000253fe
   126dc:	000253e2 	.word	0x000253e2
   126e0:	00024f04 	.word	0x00024f04
   126e4:	000253f9 	.word	0x000253f9

000126e8 <at_handle_NRDCTRL_cmd_set>:
{
   126e8:	b51f      	push	{r0, r1, r2, r3, r4, lr}
   126ea:	0004      	movs	r4, r0
    uint8               str_function[AT_CMD_NRDCTRL_PREFIX_LEN]   = {0};
   126ec:	220b      	movs	r2, #11
   126ee:	2100      	movs	r1, #0
   126f0:	a801      	add	r0, sp, #4
   126f2:	f7ed fdf5 	bl	2e0 <memset>
    if (at_create_param_array(p_atparams_string, &num_recvparams, 1, 1) != AT_RET_OK)
   126f6:	2301      	movs	r3, #1
   126f8:	4669      	mov	r1, sp
   126fa:	001a      	movs	r2, r3
   126fc:	3103      	adds	r1, #3
   126fe:	0020      	movs	r0, r4
   12700:	f7f7 fdf0 	bl	a2e4 <at_create_param_array>
   12704:	2800      	cmp	r0, #0
   12706:	d003      	beq.n	12710 <at_handle_NRDCTRL_cmd_set+0x28>
       return AT_RET_SYNTAX_ERROR;
   12708:	2401      	movs	r4, #1
}
   1270a:	0020      	movs	r0, r4
   1270c:	b004      	add	sp, #16
   1270e:	bd10      	pop	{r4, pc}
    if (at_get_string_param(AT_PARSE_FIRST_PARAM_POS, str_function, AT_CMD_NRDCTRL_PREFIX_LEN, true) != AT_RET_OK)
   12710:	2301      	movs	r3, #1
   12712:	220b      	movs	r2, #11
   12714:	a901      	add	r1, sp, #4
   12716:	f7f8 f837 	bl	a788 <at_get_string_param>
   1271a:	1e04      	subs	r4, r0, #0
   1271c:	d1f4      	bne.n	12708 <at_handle_NRDCTRL_cmd_set+0x20>
    if (at_strcmp(str_function, AT_NRDCTRL_ACTIVE_STRING) == 0)
   1271e:	490e      	ldr	r1, [pc, #56]	; (12758 <at_handle_NRDCTRL_cmd_set+0x70>)
   12720:	a801      	add	r0, sp, #4
   12722:	f008 fe1d 	bl	1b360 <strcmp>
   12726:	2800      	cmp	r0, #0
   12728:	d014      	beq.n	12754 <at_handle_NRDCTRL_cmd_set+0x6c>
    else if (at_strcmp(str_function, AT_NRDCTRL_DEACTIVATE_STRING) == 0)
   1272a:	490c      	ldr	r1, [pc, #48]	; (1275c <at_handle_NRDCTRL_cmd_set+0x74>)
   1272c:	a801      	add	r0, sp, #4
   1272e:	f008 fe17 	bl	1b360 <strcmp>
        cmd_value = RF_CONFIG_CTRL_CMD_DEACTIVATE;
   12732:	2301      	movs	r3, #1
    else if (at_strcmp(str_function, AT_NRDCTRL_DEACTIVATE_STRING) == 0)
   12734:	2800      	cmp	r0, #0
   12736:	d006      	beq.n	12746 <at_handle_NRDCTRL_cmd_set+0x5e>
    else if (at_strcmp(str_function, AT_NRDCTRL_RESET_STRING) == 0)
   12738:	4909      	ldr	r1, [pc, #36]	; (12760 <at_handle_NRDCTRL_cmd_set+0x78>)
   1273a:	a801      	add	r0, sp, #4
   1273c:	f008 fe10 	bl	1b360 <strcmp>
        cmd_value = RF_CONFIG_CTRL_CMD_RESET;
   12740:	2302      	movs	r3, #2
    else if (at_strcmp(str_function, AT_NRDCTRL_RESET_STRING) == 0)
   12742:	2800      	cmp	r0, #0
   12744:	d1e0      	bne.n	12708 <at_handle_NRDCTRL_cmd_set+0x20>
    if (production_radio_config_ctrl(cmd_value) != NEUL_RET_OK)
   12746:	0018      	movs	r0, r3
   12748:	f009 fada 	bl	1bd00 <production_radio_config_ctrl>
   1274c:	2800      	cmp	r0, #0
   1274e:	d0dc      	beq.n	1270a <at_handle_NRDCTRL_cmd_set+0x22>
        return AT_RET_PROGRESS_ERROR;
   12750:	2406      	movs	r4, #6
   12752:	e7da      	b.n	1270a <at_handle_NRDCTRL_cmd_set+0x22>
        cmd_value = RF_CONFIG_CTRL_CMD_ACTIVATE;
   12754:	0023      	movs	r3, r4
   12756:	e7f6      	b.n	12746 <at_handle_NRDCTRL_cmd_set+0x5e>
   12758:	000252e0 	.word	0x000252e0
   1275c:	000252de 	.word	0x000252de
   12760:	00022c6b 	.word	0x00022c6b

00012764 <at_handle_NCALTEMPSENSOR_cmd_set>:
{
   12764:	b513      	push	{r0, r1, r4, lr}
    cause = at_create_param_array(p_atparams_string, &num_recvparams, 1, 1);
   12766:	2301      	movs	r3, #1
   12768:	4669      	mov	r1, sp
   1276a:	001a      	movs	r2, r3
   1276c:	3105      	adds	r1, #5
   1276e:	f7f7 fdb9 	bl	a2e4 <at_create_param_array>
    if(cause != AT_RET_OK)
   12772:	2800      	cmp	r0, #0
   12774:	d10d      	bne.n	12792 <at_handle_NCALTEMPSENSOR_cmd_set+0x2e>
    cause = at_get_1dp_to_int16_param(AT_PARSE_FIRST_PARAM_POS, &temperature_dC, true);
   12776:	466b      	mov	r3, sp
   12778:	1d9c      	adds	r4, r3, #6
   1277a:	2201      	movs	r2, #1
   1277c:	0021      	movs	r1, r4
   1277e:	f7f7 ffb1 	bl	a6e4 <at_get_1dp_to_int16_param>
    if (cause != AT_RET_OK)
   12782:	2800      	cmp	r0, #0
   12784:	d105      	bne.n	12792 <at_handle_NCALTEMPSENSOR_cmd_set+0x2e>
    result = production_calibrate_temperature(temperature_dC);
   12786:	2300      	movs	r3, #0
   12788:	5ee0      	ldrsh	r0, [r4, r3]
   1278a:	f009 fc16 	bl	1bfba <production_calibrate_temperature>
    return at_parse_convert_neul_result(result);
   1278e:	f7f7 fd7f 	bl	a290 <at_parse_convert_neul_result>
}
   12792:	bd16      	pop	{r1, r2, r4, pc}

00012794 <nrdexec_rxlist_callback.part.1>:
static void nrdexec_rxlist_callback(uint8 retcode, uint16 length, const uint8 *data)
   12794:	b5f0      	push	{r4, r5, r6, r7, lr}
   12796:	000d      	movs	r5, r1
            rsp_len = (uint16)snprintf(rsp_string, AT_RX_CALIST_RSP_LEN, "%d,", length);
   12798:	214e      	movs	r1, #78	; 0x4e
static void nrdexec_rxlist_callback(uint8 retcode, uint16 length, const uint8 *data)
   1279a:	b0d5      	sub	sp, #340	; 0x154
   1279c:	0006      	movs	r6, r0
            rsp_len = (uint16)snprintf(rsp_string, AT_RX_CALIST_RSP_LEN, "%d,", length);
   1279e:	0003      	movs	r3, r0
   127a0:	4a13      	ldr	r2, [pc, #76]	; (127f0 <nrdexec_rxlist_callback.part.1+0x5c>)
   127a2:	31ff      	adds	r1, #255	; 0xff
   127a4:	4668      	mov	r0, sp
   127a6:	f008 f861 	bl	1a86c <snprintf>
            for (loop = 0; (loop < length) &&(rsp_len<AT_RX_CALIST_RSP_LEN) ; loop++)
   127aa:	27a6      	movs	r7, #166	; 0xa6
            rsp_len = (uint16)snprintf(rsp_string, AT_RX_CALIST_RSP_LEN, "%d,", length);
   127ac:	b284      	uxth	r4, r0
   127ae:	19ae      	adds	r6, r5, r6
            for (loop = 0; (loop < length) &&(rsp_len<AT_RX_CALIST_RSP_LEN) ; loop++)
   127b0:	007f      	lsls	r7, r7, #1
   127b2:	42ae      	cmp	r6, r5
   127b4:	d001      	beq.n	127ba <nrdexec_rxlist_callback.part.1+0x26>
   127b6:	42bc      	cmp	r4, r7
   127b8:	d907      	bls.n	127ca <nrdexec_rxlist_callback.part.1+0x36>
            app_at_send_at_rsp_string_lines_with_claim_and_log(rsp_string);
   127ba:	4668      	mov	r0, sp
   127bc:	f7f6 ff12 	bl	95e4 <app_at_send_at_rsp_string_lines_with_claim_and_log>
            app_at_send_callback_response(AT_RET_OK);
   127c0:	2000      	movs	r0, #0
   127c2:	f7f5 fe81 	bl	84c8 <app_at_send_callback_response>
}
   127c6:	b055      	add	sp, #340	; 0x154
   127c8:	bdf0      	pop	{r4, r5, r6, r7, pc}
   127ca:	214e      	movs	r1, #78	; 0x4e
   127cc:	0020      	movs	r0, r4
                if (data[loop] == 0)
   127ce:	782b      	ldrb	r3, [r5, #0]
   127d0:	31ff      	adds	r1, #255	; 0xff
   127d2:	4468      	add	r0, sp
   127d4:	1b09      	subs	r1, r1, r4
   127d6:	2b00      	cmp	r3, #0
   127d8:	d106      	bne.n	127e8 <nrdexec_rxlist_callback.part.1+0x54>
                    rsp_len += (uint16)snprintf(rsp_string + rsp_len, AT_RX_CALIST_RSP_LEN - rsp_len, "00");
   127da:	4a06      	ldr	r2, [pc, #24]	; (127f4 <nrdexec_rxlist_callback.part.1+0x60>)
   127dc:	f008 f846 	bl	1a86c <snprintf>
                    rsp_len += (uint16)snprintf(rsp_string + rsp_len, AT_RX_CALIST_RSP_LEN - rsp_len, "%02x", data[loop]);
   127e0:	1824      	adds	r4, r4, r0
   127e2:	b2a4      	uxth	r4, r4
   127e4:	3501      	adds	r5, #1
   127e6:	e7e4      	b.n	127b2 <nrdexec_rxlist_callback.part.1+0x1e>
   127e8:	4a03      	ldr	r2, [pc, #12]	; (127f8 <nrdexec_rxlist_callback.part.1+0x64>)
   127ea:	f008 f83f 	bl	1a86c <snprintf>
   127ee:	e7f7      	b.n	127e0 <nrdexec_rxlist_callback.part.1+0x4c>
   127f0:	000234e4 	.word	0x000234e4
   127f4:	000254d4 	.word	0x000254d4
   127f8:	0002393f 	.word	0x0002393f

000127fc <nrdexec_rxlist_callback>:
{
   127fc:	b510      	push	{r4, lr}
   127fe:	000b      	movs	r3, r1
    if ((RADIO_TEST_RET)retcode ==  RADIO_TEST_RET_OK)
   12800:	2800      	cmp	r0, #0
   12802:	d106      	bne.n	12812 <nrdexec_rxlist_callback+0x16>
        if (length != 0)
   12804:	2900      	cmp	r1, #0
   12806:	d004      	beq.n	12812 <nrdexec_rxlist_callback+0x16>
   12808:	0011      	movs	r1, r2
   1280a:	0018      	movs	r0, r3
   1280c:	f7ff ffc2 	bl	12794 <nrdexec_rxlist_callback.part.1>
}
   12810:	bd10      	pop	{r4, pc}
            app_at_send_callback_response(AT_RET_PROGRESS_ERROR);
   12812:	2006      	movs	r0, #6
   12814:	f7f5 fe58 	bl	84c8 <app_at_send_callback_response>
}
   12818:	e7fa      	b.n	12810 <nrdexec_rxlist_callback+0x14>
	...

0001281c <production_at_cmd_init>:
    //calibrate temperature
    {AT_FLAG_UNVISIABLE | AT_FLAG_LOGABLE, "+NCALTEMPSENSOR", at_handle_NCALTEMPSENSOR_cmd_set, NULL, at_handle_NCALTEMPSENSOR_cmd_test, NULL},
};

void production_at_cmd_init(void)
{
   1281c:	b570      	push	{r4, r5, r6, lr}
    uint8 table_size;
    uint8 i;
    static bool initialed = false;

    if (initialed)
   1281e:	4d0d      	ldr	r5, [pc, #52]	; (12854 <production_at_cmd_init+0x38>)
   12820:	782b      	ldrb	r3, [r5, #0]
   12822:	2b00      	cmp	r3, #0
   12824:	d115      	bne.n	12852 <production_at_cmd_init+0x36>
    }

    table_size = sizeof(production_at_cmd_table)/sizeof(AT_CMD_CB_s);
    for (i = 0; i < table_size; i++)
    {
        (void)at_cmd_register(&production_at_cmd_table[i]);
   12826:	4c0c      	ldr	r4, [pc, #48]	; (12858 <production_at_cmd_init+0x3c>)
   12828:	0020      	movs	r0, r4
   1282a:	f7ff f927 	bl	11a7c <at_cmd_register>
   1282e:	0020      	movs	r0, r4
   12830:	3018      	adds	r0, #24
   12832:	f7ff f923 	bl	11a7c <at_cmd_register>
   12836:	0020      	movs	r0, r4
   12838:	3030      	adds	r0, #48	; 0x30
   1283a:	f7ff f91f 	bl	11a7c <at_cmd_register>
   1283e:	0020      	movs	r0, r4
   12840:	3048      	adds	r0, #72	; 0x48
   12842:	f7ff f91b 	bl	11a7c <at_cmd_register>
   12846:	0020      	movs	r0, r4
   12848:	3060      	adds	r0, #96	; 0x60
   1284a:	f7ff f917 	bl	11a7c <at_cmd_register>
    }
    initialed = true;
   1284e:	2301      	movs	r3, #1
   12850:	702b      	strb	r3, [r5, #0]

    return;
}
   12852:	bd70      	pop	{r4, r5, r6, pc}
   12854:	010024e4 	.word	0x010024e4
   12858:	00025420 	.word	0x00025420

0001285c <open_logical_channel>:
 * @param application ID length
 * @param channel_num
 * @return ret
 */
NEUL_RET open_logical_channel(uint8 *app_id, uint16 app_id_len, uint8 *channel_num)
{
   1285c:	b573      	push	{r0, r1, r4, r5, r6, lr}
   1285e:	0006      	movs	r6, r0
   12860:	0014      	movs	r4, r2
   12862:	0008      	movs	r0, r1
    NEUL_RET ret;

    if ((!app_id) || (!channel_num) ||
   12864:	2e00      	cmp	r6, #0
   12866:	d101      	bne.n	1286c <open_logical_channel+0x10>
        (app_id_len > APP_ID_MAX_LENGTH) || (app_id_len < APP_ID_MIN_LENGTH))
    {
        return NEUL_RET_ERROR;
   12868:	2001      	movs	r0, #1
    else
    {
        *channel_num = FIRST_CHANNEL_NB;
        return ret;
    }
}
   1286a:	bd76      	pop	{r1, r2, r4, r5, r6, pc}
    if ((!app_id) || (!channel_num) ||
   1286c:	2a00      	cmp	r2, #0
   1286e:	d0fb      	beq.n	12868 <open_logical_channel+0xc>
        (app_id_len > APP_ID_MAX_LENGTH) || (app_id_len < APP_ID_MIN_LENGTH))
   12870:	1e4b      	subs	r3, r1, #1
   12872:	2b0f      	cmp	r3, #15
   12874:	d8f8      	bhi.n	12868 <open_logical_channel+0xc>
    if(command_open_logical_channel(app_id_len, app_id, (uint8 *)&ret, channel_num) != RPC_ERR_OK)
   12876:	466b      	mov	r3, sp
   12878:	1ddd      	adds	r5, r3, #7
   1287a:	0031      	movs	r1, r6
   1287c:	0013      	movs	r3, r2
   1287e:	002a      	movs	r2, r5
   12880:	f7f3 fa32 	bl	5ce8 <command_open_logical_channel>
   12884:	2800      	cmp	r0, #0
   12886:	d1ef      	bne.n	12868 <open_logical_channel+0xc>
    if ((ret == NEUL_RET_OK) && (*channel_num != FIRST_CHANNEL_NB) && (*channel_num <= LAST_CHANNEL_NB))
   12888:	7828      	ldrb	r0, [r5, #0]
   1288a:	2800      	cmp	r0, #0
   1288c:	d103      	bne.n	12896 <open_logical_channel+0x3a>
   1288e:	7823      	ldrb	r3, [r4, #0]
   12890:	3b01      	subs	r3, #1
   12892:	2b02      	cmp	r3, #2
   12894:	d9e9      	bls.n	1286a <open_logical_channel+0xe>
        *channel_num = FIRST_CHANNEL_NB;
   12896:	2300      	movs	r3, #0
   12898:	7023      	strb	r3, [r4, #0]
        return ret;
   1289a:	e7e6      	b.n	1286a <open_logical_channel+0xe>

0001289c <close_logical_channel>:
 * @brief close_logical_channel
 * @param channel number
 * @return ret
 */
NEUL_RET close_logical_channel(uint8 channel_num)
{
   1289c:	b537      	push	{r0, r1, r2, r4, r5, lr}
    NEUL_RET ret = NEUL_RET_ERROR;
   1289e:	466b      	mov	r3, sp
   128a0:	2401      	movs	r4, #1
   128a2:	1ddd      	adds	r5, r3, #7

    if(command_close_logical_channel(channel_num, (uint8 *)&ret) != RPC_ERR_OK)
   128a4:	0029      	movs	r1, r5
    NEUL_RET ret = NEUL_RET_ERROR;
   128a6:	71dc      	strb	r4, [r3, #7]
    if(command_close_logical_channel(channel_num, (uint8 *)&ret) != RPC_ERR_OK)
   128a8:	f7f3 fa54 	bl	5d54 <command_close_logical_channel>
   128ac:	2800      	cmp	r0, #0
   128ae:	d100      	bne.n	128b2 <close_logical_channel+0x16>
    {
        return NEUL_RET_ERROR;
    }

    return ret;
   128b0:	782c      	ldrb	r4, [r5, #0]
}
   128b2:	0020      	movs	r0, r4
   128b4:	bd3e      	pop	{r1, r2, r3, r4, r5, pc}

000128b6 <generic_uicc_logical_channel_access>:
 * @param rsp response data received from the card
 * @param rsp_len response data length
 * @return ret
 */
NEUL_RET generic_uicc_logical_channel_access(uint8 channel_num,  uint8 *cmd, uint16 cmd_len, uint8 *rsp, uint16 *rsp_len)
{
   128b6:	b5f0      	push	{r4, r5, r6, r7, lr}
    NEUL_RET ret = NEUL_RET_ERROR;
   128b8:	2417      	movs	r4, #23
   128ba:	2501      	movs	r5, #1
{
   128bc:	b087      	sub	sp, #28
    NEUL_RET ret = NEUL_RET_ERROR;
   128be:	446c      	add	r4, sp
{
   128c0:	0017      	movs	r7, r2
    NEUL_RET ret = NEUL_RET_ERROR;
   128c2:	7025      	strb	r5, [r4, #0]

    if ((!cmd) || (!rsp) || (cmd_len > MAX_SEND_DATA_LEN) ||
        (!rsp_len) || ((cmd[COMMAND_CLA] & 0x0F) != channel_num))
    {
        return NEUL_RET_ERROR_IN_PARAMETERS;
   128c4:	2203      	movs	r2, #3
    if ((!cmd) || (!rsp) || (cmd_len > MAX_SEND_DATA_LEN) ||
   128c6:	2900      	cmp	r1, #0
   128c8:	d01d      	beq.n	12906 <generic_uicc_logical_channel_access+0x50>
   128ca:	2b00      	cmp	r3, #0
   128cc:	d01b      	beq.n	12906 <generic_uicc_logical_channel_access+0x50>
   128ce:	2606      	movs	r6, #6
   128d0:	36ff      	adds	r6, #255	; 0xff
   128d2:	42b7      	cmp	r7, r6
   128d4:	d817      	bhi.n	12906 <generic_uicc_logical_channel_access+0x50>
   128d6:	9e0c      	ldr	r6, [sp, #48]	; 0x30
   128d8:	2e00      	cmp	r6, #0
   128da:	d014      	beq.n	12906 <generic_uicc_logical_channel_access+0x50>
        (!rsp_len) || ((cmd[COMMAND_CLA] & 0x0F) != channel_num))
   128dc:	780e      	ldrb	r6, [r1, #0]
   128de:	320c      	adds	r2, #12
   128e0:	4016      	ands	r6, r2
        return NEUL_RET_ERROR_IN_PARAMETERS;
   128e2:	3a0c      	subs	r2, #12
        (!rsp_len) || ((cmd[COMMAND_CLA] & 0x0F) != channel_num))
   128e4:	42b0      	cmp	r0, r6
   128e6:	d10e      	bne.n	12906 <generic_uicc_logical_channel_access+0x50>
    }

    if (command_generic_uicc_logical_channel_access(channel_num, cmd_len, cmd, (uint8 *)&ret, MAX_RECV_DATA_LEN, rsp_len, rsp) != RPC_ERR_OK)
   128e8:	9302      	str	r3, [sp, #8]
   128ea:	9b0c      	ldr	r3, [sp, #48]	; 0x30
   128ec:	000a      	movs	r2, r1
   128ee:	9301      	str	r3, [sp, #4]
   128f0:	2381      	movs	r3, #129	; 0x81
   128f2:	005b      	lsls	r3, r3, #1
   128f4:	9300      	str	r3, [sp, #0]
   128f6:	0039      	movs	r1, r7
   128f8:	0023      	movs	r3, r4
   128fa:	f7f3 fa54 	bl	5da6 <command_generic_uicc_logical_channel_access>
    {
        return NEUL_RET_ERROR;
   128fe:	002a      	movs	r2, r5
    if (command_generic_uicc_logical_channel_access(channel_num, cmd_len, cmd, (uint8 *)&ret, MAX_RECV_DATA_LEN, rsp_len, rsp) != RPC_ERR_OK)
   12900:	2800      	cmp	r0, #0
   12902:	d100      	bne.n	12906 <generic_uicc_logical_channel_access+0x50>
    }

    return ret;
   12904:	7822      	ldrb	r2, [r4, #0]
}
   12906:	0010      	movs	r0, r2
   12908:	b007      	add	sp, #28
   1290a:	bdf0      	pop	{r4, r5, r6, r7, pc}

0001290c <uicc_status_control>:
 * @brief control uicc status, power on/off
 * @param status uicc power on/off
 * @return success or error
 */
NEUL_RET uicc_status_control(NEUL_UICC_STATUS status)
{
   1290c:	b537      	push	{r0, r1, r2, r4, r5, lr}
    NEUL_RET ret = NEUL_RET_ERROR;
   1290e:	466b      	mov	r3, sp
   12910:	2401      	movs	r4, #1
   12912:	1ddd      	adds	r5, r3, #7

    if (command_uicc_status_control((uint8)status, (uint8 *)&ret) != RPC_ERR_OK)
   12914:	0029      	movs	r1, r5
    NEUL_RET ret = NEUL_RET_ERROR;
   12916:	71dc      	strb	r4, [r3, #7]
    if (command_uicc_status_control((uint8)status, (uint8 *)&ret) != RPC_ERR_OK)
   12918:	f7f3 fc94 	bl	6244 <command_uicc_status_control>
   1291c:	2800      	cmp	r0, #0
   1291e:	d100      	bne.n	12922 <uicc_status_control+0x16>
    {
        return NEUL_RET_ERROR;
    }

    return ret;
   12920:	782c      	ldrb	r4, [r5, #0]
}
   12922:	0020      	movs	r0, r4
   12924:	bd3e      	pop	{r1, r2, r3, r4, r5, pc}

00012926 <restricted_sim_access>:
 * @param rsp response data received from the card
 * @param rsp_len response data length
 * @return ret
 */
NEUL_RET restricted_sim_access(crsm_command *cmd, uint8 *rsp, uint16 *rsp_len)
{
   12926:	b530      	push	{r4, r5, lr}
    NEUL_RET ret = NEUL_RET_ERROR;
   12928:	240f      	movs	r4, #15
   1292a:	2501      	movs	r5, #1
{
   1292c:	b085      	sub	sp, #20
    NEUL_RET ret = NEUL_RET_ERROR;
   1292e:	446c      	add	r4, sp
   12930:	7025      	strb	r5, [r4, #0]

    if ((!cmd) || (!rsp) || (!rsp_len))
    {
        return NEUL_RET_ERROR_IN_PARAMETERS;
   12932:	2303      	movs	r3, #3
    if ((!cmd) || (!rsp) || (!rsp_len))
   12934:	2800      	cmp	r0, #0
   12936:	d010      	beq.n	1295a <restricted_sim_access+0x34>
   12938:	2900      	cmp	r1, #0
   1293a:	d00e      	beq.n	1295a <restricted_sim_access+0x34>
   1293c:	2a00      	cmp	r2, #0
   1293e:	d00c      	beq.n	1295a <restricted_sim_access+0x34>
    }

    if (command_restricted_sim_access(sizeof(crsm_command), (uint8 *)cmd, (uint8 *)&ret, MAX_RECV_DATA_LEN, rsp_len, rsp) != RPC_ERR_OK)
   12940:	9101      	str	r1, [sp, #4]
   12942:	0001      	movs	r1, r0
   12944:	208b      	movs	r0, #139	; 0x8b
   12946:	9200      	str	r2, [sp, #0]
   12948:	33ff      	adds	r3, #255	; 0xff
   1294a:	0022      	movs	r2, r4
   1294c:	0040      	lsls	r0, r0, #1
   1294e:	f7f3 fca2 	bl	6296 <command_restricted_sim_access>
    {
        return NEUL_RET_ERROR;
   12952:	002b      	movs	r3, r5
    if (command_restricted_sim_access(sizeof(crsm_command), (uint8 *)cmd, (uint8 *)&ret, MAX_RECV_DATA_LEN, rsp_len, rsp) != RPC_ERR_OK)
   12954:	2800      	cmp	r0, #0
   12956:	d100      	bne.n	1295a <restricted_sim_access+0x34>
    }

    return ret;
   12958:	7823      	ldrb	r3, [r4, #0]
}
   1295a:	0018      	movs	r0, r3
   1295c:	b005      	add	sp, #20
   1295e:	bd30      	pop	{r4, r5, pc}

00012960 <trace_fn>:
 * This is only documented at
 * http://stackoverflow.com/questions/3398664/how-to-get-a-call-stack-backtrace-deeply-embedded-no-library-support
 * as far as I can see.
 */
static _Unwind_Reason_Code trace_fn(_Unwind_Context *ctx, void *dummy)
{
   12960:	b51f      	push	{r0, r1, r2, r3, r4, lr}
    UNUSED(dummy);
    if (backtrace.depth < BACKTRACE_DEPTH)
   12962:	4c0b      	ldr	r4, [pc, #44]	; (12990 <trace_fn+0x30>)
   12964:	6823      	ldr	r3, [r4, #0]
   12966:	2b09      	cmp	r3, #9
   12968:	dc0f      	bgt.n	1298a <trace_fn+0x2a>

  static inline _Unwind_Word
  _Unwind_GetGR (_Unwind_Context *context, int regno)
    {
      _uw val;
      _Unwind_VRS_Get (context, _UVRSC_CORE, regno, _UVRSD_UINT32, &val);
   1296a:	ab03      	add	r3, sp, #12
   1296c:	9300      	str	r3, [sp, #0]
   1296e:	2300      	movs	r3, #0
   12970:	220f      	movs	r2, #15
   12972:	0019      	movs	r1, r3
   12974:	f7ee f972 	bl	c5c <_Unwind_VRS_Get>
    {
        backtrace.entries[backtrace.depth] = _Unwind_GetIP(ctx);
   12978:	2101      	movs	r1, #1
   1297a:	6823      	ldr	r3, [r4, #0]
   1297c:	9803      	ldr	r0, [sp, #12]
   1297e:	009a      	lsls	r2, r3, #2
   12980:	18a2      	adds	r2, r4, r2
   12982:	4388      	bics	r0, r1
        backtrace.depth ++;
   12984:	3301      	adds	r3, #1
        backtrace.entries[backtrace.depth] = _Unwind_GetIP(ctx);
   12986:	6050      	str	r0, [r2, #4]
        backtrace.depth ++;
   12988:	6023      	str	r3, [r4, #0]
    }
    return _URC_NO_REASON;
}
   1298a:	2000      	movs	r0, #0
   1298c:	b004      	add	sp, #16
   1298e:	bd10      	pop	{r4, pc}
   12990:	01002f30 	.word	0x01002f30

00012994 <record_backtrace>:

void record_backtrace(void)
{
   12994:	b570      	push	{r4, r5, r6, lr}
    if (!already_tracing)
   12996:	4d08      	ldr	r5, [pc, #32]	; (129b8 <record_backtrace+0x24>)
   12998:	782c      	ldrb	r4, [r5, #0]
   1299a:	2c00      	cmp	r4, #0
   1299c:	d10b      	bne.n	129b6 <record_backtrace+0x22>
    {
        already_tracing = true;
   1299e:	2301      	movs	r3, #1
        memset(&backtrace, 0, sizeof(backtrace));
   129a0:	222c      	movs	r2, #44	; 0x2c
   129a2:	0021      	movs	r1, r4
   129a4:	4805      	ldr	r0, [pc, #20]	; (129bc <record_backtrace+0x28>)
        already_tracing = true;
   129a6:	702b      	strb	r3, [r5, #0]
        memset(&backtrace, 0, sizeof(backtrace));
   129a8:	f7ed fc9a 	bl	2e0 <memset>
        (void)_Unwind_Backtrace(trace_fn, NULL);
   129ac:	0021      	movs	r1, r4
   129ae:	4804      	ldr	r0, [pc, #16]	; (129c0 <record_backtrace+0x2c>)
   129b0:	f7ee fd12 	bl	13d8 <_Unwind_Backtrace>
        already_tracing = false;
   129b4:	702c      	strb	r4, [r5, #0]
    }
}
   129b6:	bd70      	pop	{r4, r5, r6, pc}
   129b8:	010024e5 	.word	0x010024e5
   129bc:	01002f30 	.word	0x01002f30
   129c0:	00012961 	.word	0x00012961

000129c4 <get_backtrace>:
    // Loop and wait for the watchdog to kill us.
    forever {}
}

bool get_backtrace(backtrace_t *out)
{
   129c4:	b570      	push	{r4, r5, r6, lr}
   129c6:	0004      	movs	r4, r0
    bool ret;
    ret = preserve_valid() && backtrace.depth != 0;
   129c8:	f008 ff02 	bl	1b7d0 <preserve_valid>
   129cc:	490a      	ldr	r1, [pc, #40]	; (129f8 <get_backtrace+0x34>)
   129ce:	2800      	cmp	r0, #0
   129d0:	d00c      	beq.n	129ec <get_backtrace+0x28>
   129d2:	680b      	ldr	r3, [r1, #0]
   129d4:	2b00      	cmp	r3, #0
   129d6:	d00c      	beq.n	129f2 <get_backtrace+0x2e>

    if (ret)
    {
        *out = backtrace;
   129d8:	0023      	movs	r3, r4
   129da:	000a      	movs	r2, r1
   129dc:	ca70      	ldmia	r2!, {r4, r5, r6}
   129de:	c370      	stmia	r3!, {r4, r5, r6}
   129e0:	ca70      	ldmia	r2!, {r4, r5, r6}
   129e2:	c370      	stmia	r3!, {r4, r5, r6}
   129e4:	ca70      	ldmia	r2!, {r4, r5, r6}
   129e6:	c370      	stmia	r3!, {r4, r5, r6}
   129e8:	ca30      	ldmia	r2!, {r4, r5}
   129ea:	c330      	stmia	r3!, {r4, r5}
    }
    backtrace.depth = 0;
   129ec:	2300      	movs	r3, #0
   129ee:	600b      	str	r3, [r1, #0]
    return ret;
}
   129f0:	bd70      	pop	{r4, r5, r6, pc}
    ret = preserve_valid() && backtrace.depth != 0;
   129f2:	0018      	movs	r0, r3
   129f4:	e7fa      	b.n	129ec <get_backtrace+0x28>
   129f6:	46c0      	nop			; (mov r8, r8)
   129f8:	01002f30 	.word	0x01002f30

000129fc <irmalloc_init_default>:
typedef long bufsize;

void irmalloc_init_default(void)
{
    // Give irmalloc the heap to allocate from
}
   129fc:	4770      	bx	lr
	...

00012a00 <irmalloc>:

    return mem;
}

void *irmalloc(size_t size)
{
   12a00:	b510      	push	{r4, lr}
    mem = LOS_MemAlloc(m_aucSysMem0, (UINT32)size);
   12a02:	4b03      	ldr	r3, [pc, #12]	; (12a10 <irmalloc+0x10>)
{
   12a04:	0001      	movs	r1, r0
    mem = LOS_MemAlloc(m_aucSysMem0, (UINT32)size);
   12a06:	6818      	ldr	r0, [r3, #0]
   12a08:	f000 f86c 	bl	12ae4 <LOS_MemAlloc>
        mem = (void *) ((uint32 *) mem + 1);
    }
#endif

    return mem;
}
   12a0c:	bd10      	pop	{r4, pc}
   12a0e:	46c0      	nop			; (mov r8, r8)
   12a10:	01002e40 	.word	0x01002e40

00012a14 <irzalloc>:

    return mem;
}

void *irzalloc(size_t size)
{
   12a14:	b570      	push	{r4, r5, r6, lr}

    void *buf = LOS_MemAlloc(m_aucSysMem0, (UINT32)size);
   12a16:	4b07      	ldr	r3, [pc, #28]	; (12a34 <irzalloc+0x20>)
   12a18:	0001      	movs	r1, r0
{
   12a1a:	0005      	movs	r5, r0
    void *buf = LOS_MemAlloc(m_aucSysMem0, (UINT32)size);
   12a1c:	6818      	ldr	r0, [r3, #0]
   12a1e:	f000 f861 	bl	12ae4 <LOS_MemAlloc>
   12a22:	1e04      	subs	r4, r0, #0
        *(uint32 *) buf = (uintptr) __builtin_return_address(0);
        buf = (void *) ((uint32 *) buf + 1);
    }
#endif

    if (buf)
   12a24:	d003      	beq.n	12a2e <irzalloc+0x1a>
    {
        memset(buf, 0, size);
   12a26:	002a      	movs	r2, r5
   12a28:	2100      	movs	r1, #0
   12a2a:	f7ed fc59 	bl	2e0 <memset>
    }

    return buf;
}
   12a2e:	0020      	movs	r0, r4
   12a30:	bd70      	pop	{r4, r5, r6, pc}
   12a32:	46c0      	nop			; (mov r8, r8)
   12a34:	01002e40 	.word	0x01002e40

00012a38 <irfree>:
    return mem;
}
/*lint -e429 */
/*lint -e593 */
void irfree(void *buf)
{
   12a38:	b510      	push	{r4, lr}
   12a3a:	1e01      	subs	r1, r0, #0
    if (!buf)
   12a3c:	d003      	beq.n	12a46 <irfree+0xe>
#ifdef DEBUG_MALLOC_TRACE_OWNER
    // Restore the pointer we got from extram_bget originally.
    buf = (void *) ((uint32 *) buf - 1);
#endif

    (void)LOS_MemFree(m_aucSysMem0, buf);
   12a3e:	4b02      	ldr	r3, [pc, #8]	; (12a48 <irfree+0x10>)
   12a40:	6818      	ldr	r0, [r3, #0]
   12a42:	f000 f869 	bl	12b18 <LOS_MemFree>
}
   12a46:	bd10      	pop	{r4, pc}
   12a48:	01002e40 	.word	0x01002e40

00012a4c <irmalloc_get_machine_readable_stats>:
}
/*lint +e438 */
/**Get some machine readable statistics on the memory management state
 */
void irmalloc_get_machine_readable_stats(uint32 *current_allocated, uint32 *total_free, uint32 *max_free, uint32 *num_allocs, uint32 *num_frees)
{
   12a4c:	b573      	push	{r0, r1, r4, r5, r6, lr}
   12a4e:	0015      	movs	r5, r2
   12a50:	001a      	movs	r2, r3

    UINT32 all_heap = 0;
   12a52:	2300      	movs	r3, #0
{
   12a54:	000c      	movs	r4, r1
   12a56:	0006      	movs	r6, r0
    UINT32 all_heap = 0;
   12a58:	9301      	str	r3, [sp, #4]

    (void)LOS_MemStatisticsGet((UINT32 *)&all_heap, (UINT32 *)total_free, (UINT32 *)num_allocs, (UINT32 *)num_frees);
   12a5a:	a801      	add	r0, sp, #4
   12a5c:	9b06      	ldr	r3, [sp, #24]
   12a5e:	f000 f875 	bl	12b4c <LOS_MemStatisticsGet>
    *current_allocated = all_heap - *total_free;
   12a62:	6823      	ldr	r3, [r4, #0]
   12a64:	9a01      	ldr	r2, [sp, #4]
   12a66:	1ad3      	subs	r3, r2, r3
   12a68:	6033      	str	r3, [r6, #0]
    *max_free = LOS_MemGetMaxBlkSize();
   12a6a:	f000 f8ae 	bl	12bca <LOS_MemGetMaxBlkSize>
   12a6e:	6028      	str	r0, [r5, #0]

}
   12a70:	bd73      	pop	{r0, r1, r4, r5, r6, pc}
	...

00012a74 <LOS_mem_reg_ex_ope>:

UINT8 *m_aucSysMem0;

INT32 LOS_mem_reg_ex_ope(void (*_init)(void), void *(*_malloc)(UINT32), bool
(*_free)(void*));
INT32 LOS_mem_reg_ex_ope(void (*_init)(void), void *(*_malloc)(UINT32), bool (*_free)(void*)) {
   12a74:	b570      	push	{r4, r5, r6, lr}
    if (upper_ope.init != NULL)
   12a76:	4b06      	ldr	r3, [pc, #24]	; (12a90 <LOS_mem_reg_ex_ope+0x1c>)
INT32 LOS_mem_reg_ex_ope(void (*_init)(void), void *(*_malloc)(UINT32), bool (*_free)(void*)) {
   12a78:	0005      	movs	r5, r0
    if (upper_ope.init != NULL)
   12a7a:	681c      	ldr	r4, [r3, #0]
        return LOS_NOK;
   12a7c:	2001      	movs	r0, #1
    if (upper_ope.init != NULL)
   12a7e:	2c00      	cmp	r4, #0
   12a80:	d104      	bne.n	12a8c <LOS_mem_reg_ex_ope+0x18>
    upper_ope.init = _init;
   12a82:	601d      	str	r5, [r3, #0]
    upper_ope.malloc = _malloc;
   12a84:	6059      	str	r1, [r3, #4]
    upper_ope.free = _free;
   12a86:	609a      	str	r2, [r3, #8]

    /* init first */
    upper_ope.init();
   12a88:	47a8      	blx	r5
    return LOS_OK;
   12a8a:	0020      	movs	r0, r4
}
   12a8c:	bd70      	pop	{r4, r5, r6, pc}
   12a8e:	46c0      	nop			; (mov r8, r8)
   12a90:	010024e8 	.word	0x010024e8

00012a94 <osMemSystemInit>:

UINT32 osMemSystemInit(VOID);
LITE_OS_SEC_TEXT_INIT UINT32 osMemSystemInit(VOID)
{
   12a94:	b507      	push	{r0, r1, r2, lr}
    UINT32 uwRet = LOS_OK;
    m_aucSysMem0 = (UINT8 *)hal_sectors_ram_heap_start;
   12a96:	4b0c      	ldr	r3, [pc, #48]	; (12ac8 <osMemSystemInit+0x34>)
    uwRet = RAM_HEAP_INIT();
   12a98:	4a0c      	ldr	r2, [pc, #48]	; (12acc <osMemSystemInit+0x38>)
    m_aucSysMem0 = (UINT8 *)hal_sectors_ram_heap_start;
   12a9a:	6819      	ldr	r1, [r3, #0]
   12a9c:	4b0c      	ldr	r3, [pc, #48]	; (12ad0 <osMemSystemInit+0x3c>)
    uwRet = RAM_HEAP_INIT();
   12a9e:	6812      	ldr	r2, [r2, #0]
    m_aucSysMem0 = (UINT8 *)hal_sectors_ram_heap_start;
   12aa0:	6019      	str	r1, [r3, #0]
    uwRet = RAM_HEAP_INIT();
   12aa2:	2307      	movs	r3, #7
   12aa4:	18c9      	adds	r1, r1, r3
   12aa6:	9201      	str	r2, [sp, #4]
   12aa8:	4399      	bics	r1, r3
   12aaa:	439a      	bics	r2, r3
   12aac:	4809      	ldr	r0, [pc, #36]	; (12ad4 <osMemSystemInit+0x40>)
   12aae:	f000 fe07 	bl	136c0 <osHeapInit>
    if (uwRet != true) {
        //PRINT_ERR("tcm osHeapInit err(%d)\n", uwRet);
        return LOS_NOK;
   12ab2:	2301      	movs	r3, #1
    if (uwRet != true) {
   12ab4:	2800      	cmp	r0, #0
   12ab6:	d005      	beq.n	12ac4 <osMemSystemInit+0x30>
    }

    (VOID)LOS_mem_reg_ex_ope(osSlabMemInit, osSlabMemAlloc, osSlabMemFree);
   12ab8:	4a07      	ldr	r2, [pc, #28]	; (12ad8 <osMemSystemInit+0x44>)
   12aba:	4908      	ldr	r1, [pc, #32]	; (12adc <osMemSystemInit+0x48>)
   12abc:	4808      	ldr	r0, [pc, #32]	; (12ae0 <osMemSystemInit+0x4c>)
   12abe:	f7ff ffd9 	bl	12a74 <LOS_mem_reg_ex_ope>

#if (LOSCFG_BASE_MEM_NODE_INTEGRITY_CHECK == YES)
    //osExcRegister(OS_EXC_TYPE_MEM, (EXC_INFO_SAVE_CALLBACK)LOS_MemExcInfoGet, g_aucMemMang);
#endif

    return LOS_OK;
   12ac2:	2300      	movs	r3, #0
}
   12ac4:	0018      	movs	r0, r3
   12ac6:	bd0e      	pop	{r1, r2, r3, pc}
   12ac8:	010005d4 	.word	0x010005d4
   12acc:	0002558c 	.word	0x0002558c
   12ad0:	01002e40 	.word	0x01002e40
   12ad4:	01002e8c 	.word	0x01002e8c
   12ad8:	00012cc9 	.word	0x00012cc9
   12adc:	00012c31 	.word	0x00012c31
   12ae0:	00012bf1 	.word	0x00012bf1

00012ae4 <LOS_MemAlloc>:
//     pool:    Pointer to memory pool
//     size:    Size of memory in bytes to allocate
//   Return:    Pointer to allocated memory

LITE_OS_SEC_TEXT void *LOS_MemAlloc (void *pool, UINT32 size)
{
   12ae4:	b510      	push	{r4, lr}
    UNUSED(pool);
    void *ret = NULL;

    if(size == 0)
        return (void *)NULL;
   12ae6:	0008      	movs	r0, r1
{
   12ae8:	1e0c      	subs	r4, r1, #0
    if(size == 0)
   12aea:	d007      	beq.n	12afc <LOS_MemAlloc+0x18>

    if (upper_ope.malloc != NULL)
   12aec:	4b06      	ldr	r3, [pc, #24]	; (12b08 <LOS_MemAlloc+0x24>)
   12aee:	685b      	ldr	r3, [r3, #4]
   12af0:	2b00      	cmp	r3, #0
   12af2:	d104      	bne.n	12afe <LOS_MemAlloc+0x1a>
        ret = upper_ope.malloc(size);
    if (ret == NULL)
        ret = RAM_HEAP_ALLOC(size);
   12af4:	0021      	movs	r1, r4
   12af6:	4805      	ldr	r0, [pc, #20]	; (12b0c <LOS_MemAlloc+0x28>)
   12af8:	f000 fe0e 	bl	13718 <osHeapAlloc>

    return ret;
}
   12afc:	bd10      	pop	{r4, pc}
        ret = upper_ope.malloc(size);
   12afe:	4798      	blx	r3
    if (ret == NULL)
   12b00:	2800      	cmp	r0, #0
   12b02:	d1fb      	bne.n	12afc <LOS_MemAlloc+0x18>
   12b04:	e7f6      	b.n	12af4 <LOS_MemAlloc+0x10>
   12b06:	46c0      	nop			; (mov r8, r8)
   12b08:	010024e8 	.word	0x010024e8
   12b0c:	01002e8c 	.word	0x01002e8c

00012b10 <LOS_MemAllocAlign>:
                 uwBoundary -- align form
 Output      : None
 Return      : Pointer to allocated memory node
*****************************************************************************/
LITE_OS_SEC_TEXT VOID *LOS_MemAllocAlign(VOID *pPool, UINT32 uwSize, UINT32 uwBoundary)
{
   12b10:	b510      	push	{r4, lr}
    UNUSED(uwBoundary);
    return LOS_MemAlloc(pPool, uwSize);
   12b12:	f7ff ffe7 	bl	12ae4 <LOS_MemAlloc>
}
   12b16:	bd10      	pop	{r4, pc}

00012b18 <LOS_MemFree>:
//     pool:    Pointer to memory pool
//     mem:     Pointer to memory to free
//   Return:    0 - OK, 1 - Error

LITE_OS_SEC_TEXT UINT32 LOS_MemFree (void *pool, void *pMem)
{
   12b18:	b510      	push	{r4, lr}
    UNUSED(pool);
    bool ret = false;

    if (pMem == NULL)
        return LOS_NOK;
   12b1a:	2001      	movs	r0, #1
{
   12b1c:	1e0c      	subs	r4, r1, #0
    if (pMem == NULL)
   12b1e:	d00a      	beq.n	12b36 <LOS_MemFree+0x1e>

    if (upper_ope.free != NULL)
   12b20:	4b08      	ldr	r3, [pc, #32]	; (12b44 <LOS_MemFree+0x2c>)
   12b22:	689b      	ldr	r3, [r3, #8]
   12b24:	2b00      	cmp	r3, #0
   12b26:	d107      	bne.n	12b38 <LOS_MemFree+0x20>
        ret = upper_ope.free(pMem);
    if (ret != true)
        ret = RAM_HEAP_FREE(pMem);
   12b28:	0021      	movs	r1, r4
   12b2a:	4807      	ldr	r0, [pc, #28]	; (12b48 <LOS_MemFree+0x30>)
   12b2c:	f000 fe56 	bl	137dc <osHeapFree>

    return (ret == true ? LOS_OK : LOS_NOK);
   12b30:	2301      	movs	r3, #1
   12b32:	4058      	eors	r0, r3
   12b34:	b2c0      	uxtb	r0, r0
}
   12b36:	bd10      	pop	{r4, pc}
        ret = upper_ope.free(pMem);
   12b38:	0008      	movs	r0, r1
   12b3a:	4798      	blx	r3
    if (ret != true)
   12b3c:	2800      	cmp	r0, #0
   12b3e:	d0f3      	beq.n	12b28 <LOS_MemFree+0x10>
   12b40:	e7f6      	b.n	12b30 <LOS_MemFree+0x18>
   12b42:	46c0      	nop			; (mov r8, r8)
   12b44:	010024e8 	.word	0x010024e8
   12b48:	01002e8c 	.word	0x01002e8c

00012b4c <LOS_MemStatisticsGet>:

LITE_OS_SEC_TEXT UINT32 LOS_MemStatisticsGet(UINT32 *pTolalMem, UINT32 *pFreeMem,
                                              UINT32 *pAllocCount, UINT32 *pFreeCount)
{
   12b4c:	b5f0      	push	{r4, r5, r6, r7, lr}
    UINTPTR uvIntSave;

    UINT32 TotalMem = 0;
   12b4e:	2400      	movs	r4, #0
{
   12b50:	b08b      	sub	sp, #44	; 0x2c
   12b52:	0007      	movs	r7, r0
   12b54:	000e      	movs	r6, r1
   12b56:	0015      	movs	r5, r2
   12b58:	9300      	str	r3, [sp, #0]
    UINT32 TotalMem = 0;
   12b5a:	9402      	str	r4, [sp, #8]
    UINT32 UsedMem = 0;;
   12b5c:	9403      	str	r4, [sp, #12]
    UINT32 SlabTotal = 0;
   12b5e:	9404      	str	r4, [sp, #16]
    UINT32 SlabUsed = 0;
   12b60:	9405      	str	r4, [sp, #20]

    UINT32 AllocCount = 0;
   12b62:	9406      	str	r4, [sp, #24]
    UINT32 FreeCount = 0;
   12b64:	9407      	str	r4, [sp, #28]
    UINT32 SlabAllocCount = 0;
   12b66:	9408      	str	r4, [sp, #32]
    UINT32 SlabFreeCount = 0;
   12b68:	9409      	str	r4, [sp, #36]	; 0x24

    if ((NULL == pTolalMem) || (NULL == pFreeMem) ||
        (NULL == pAllocCount) || (NULL == pFreeCount))
    {
        return LOS_NOK;
   12b6a:	2001      	movs	r0, #1
    if ((NULL == pTolalMem) || (NULL == pFreeMem) ||
   12b6c:	42a7      	cmp	r7, r4
   12b6e:	d02a      	beq.n	12bc6 <LOS_MemStatisticsGet+0x7a>
   12b70:	42a1      	cmp	r1, r4
   12b72:	d028      	beq.n	12bc6 <LOS_MemStatisticsGet+0x7a>
   12b74:	42a2      	cmp	r2, r4
   12b76:	d026      	beq.n	12bc6 <LOS_MemStatisticsGet+0x7a>
        (NULL == pAllocCount) || (NULL == pFreeCount))
   12b78:	42a3      	cmp	r3, r4
   12b7a:	d024      	beq.n	12bc6 <LOS_MemStatisticsGet+0x7a>
    }

    uvIntSave = LOS_IntLock();
   12b7c:	f7ed faef 	bl	15e <LOS_IntLock>

    (VOID)osHeapStatisticsGet(&TotalMem, &UsedMem, &AllocCount, &FreeCount);
   12b80:	ab07      	add	r3, sp, #28
    uvIntSave = LOS_IntLock();
   12b82:	9001      	str	r0, [sp, #4]
    (VOID)osHeapStatisticsGet(&TotalMem, &UsedMem, &AllocCount, &FreeCount);
   12b84:	aa06      	add	r2, sp, #24
   12b86:	a903      	add	r1, sp, #12
   12b88:	a802      	add	r0, sp, #8
   12b8a:	f000 fe87 	bl	1389c <osHeapStatisticsGet>
    (VOID)osSlabStatisticsGet(&SlabTotal, &SlabUsed, &SlabAllocCount, &SlabFreeCount);
   12b8e:	ab09      	add	r3, sp, #36	; 0x24
   12b90:	aa08      	add	r2, sp, #32
   12b92:	a905      	add	r1, sp, #20
   12b94:	a804      	add	r0, sp, #16
   12b96:	f000 f8d9 	bl	12d4c <osSlabStatisticsGet>

    LOS_IntRestore(uvIntSave);
   12b9a:	9801      	ldr	r0, [sp, #4]
   12b9c:	f7ed fae7 	bl	16e <LOS_IntRestore>
    *pTolalMem = TotalMem;
    *pFreeMem = (TotalMem - UsedMem) + (SlabTotal - SlabUsed);
    *pAllocCount = AllocCount + SlabAllocCount;
    *pFreeCount = FreeCount + SlabFreeCount;

    return LOS_OK;
   12ba0:	0020      	movs	r0, r4
    *pTolalMem = TotalMem;
   12ba2:	9b02      	ldr	r3, [sp, #8]
    *pFreeMem = (TotalMem - UsedMem) + (SlabTotal - SlabUsed);
   12ba4:	9a04      	ldr	r2, [sp, #16]
    *pTolalMem = TotalMem;
   12ba6:	603b      	str	r3, [r7, #0]
    *pFreeMem = (TotalMem - UsedMem) + (SlabTotal - SlabUsed);
   12ba8:	189b      	adds	r3, r3, r2
   12baa:	9a03      	ldr	r2, [sp, #12]
   12bac:	1a9b      	subs	r3, r3, r2
   12bae:	9a05      	ldr	r2, [sp, #20]
   12bb0:	1a9b      	subs	r3, r3, r2
   12bb2:	6033      	str	r3, [r6, #0]
    *pAllocCount = AllocCount + SlabAllocCount;
   12bb4:	9a08      	ldr	r2, [sp, #32]
   12bb6:	9b06      	ldr	r3, [sp, #24]
   12bb8:	189b      	adds	r3, r3, r2
   12bba:	602b      	str	r3, [r5, #0]
    *pFreeCount = FreeCount + SlabFreeCount;
   12bbc:	9a09      	ldr	r2, [sp, #36]	; 0x24
   12bbe:	9b07      	ldr	r3, [sp, #28]
   12bc0:	189b      	adds	r3, r3, r2
   12bc2:	9a00      	ldr	r2, [sp, #0]
   12bc4:	6013      	str	r3, [r2, #0]
}
   12bc6:	b00b      	add	sp, #44	; 0x2c
   12bc8:	bdf0      	pop	{r4, r5, r6, r7, pc}

00012bca <LOS_MemGetMaxBlkSize>:

UINT32 LOS_MemGetMaxBlkSize(VOID)
{
   12bca:	b570      	push	{r4, r5, r6, lr}
    UINTPTR uvIntSave;

    uvIntSave = LOS_IntLock();
   12bcc:	f7ed fac7 	bl	15e <LOS_IntLock>
   12bd0:	0006      	movs	r6, r0

    UINT32 MaxFreeSize = osHeapGetMaxBlkSize();
   12bd2:	f000 fe8d 	bl	138f0 <osHeapGetMaxBlkSize>
   12bd6:	0004      	movs	r4, r0
    UINT32 MaxSlabFreeSize = osSlabGetMaxBlkSize();
   12bd8:	f000 f902 	bl	12de0 <osSlabGetMaxBlkSize>
   12bdc:	0005      	movs	r5, r0

    LOS_IntRestore(uvIntSave);
   12bde:	0030      	movs	r0, r6
   12be0:	f7ed fac5 	bl	16e <LOS_IntRestore>

#ifndef max
    #define max(x,y) (x)>(y)?(x):(y)
#endif
    return max(MaxFreeSize, MaxSlabFreeSize);
   12be4:	0020      	movs	r0, r4
   12be6:	42ac      	cmp	r4, r5
   12be8:	d200      	bcs.n	12bec <LOS_MemGetMaxBlkSize+0x22>
   12bea:	0028      	movs	r0, r5
}
   12bec:	bd70      	pop	{r4, r5, r6, pc}
	...

00012bf0 <osSlabMemInit>:
 Input       : None
 Output      : None
 Return      : None
*****************************************************************************/
void osSlabMemInit(void)
{
   12bf0:	b513      	push	{r0, r1, r4, lr}
    if (pSlabMemAllocator == NULL) {
   12bf2:	4c0a      	ldr	r4, [pc, #40]	; (12c1c <osSlabMemInit+0x2c>)
   12bf4:	6823      	ldr	r3, [r4, #0]
   12bf6:	2b00      	cmp	r3, #0
   12bf8:	d108      	bne.n	12c0c <osSlabMemInit+0x1c>
        /* according to the application ,we can alloc an half of memory size,to avoid waste */
        pSlabMemAllocator = osSlabAllocatorNew(sizeof(struct LOS_SLAB_MEM_ALLOCATOR), sizeof(UINT32), (RAM_HEAP_SIZE / SLAB_MEM_ALLOCATOR_SIZE) >> 1);
   12bfa:	4b09      	ldr	r3, [pc, #36]	; (12c20 <osSlabMemInit+0x30>)
   12bfc:	2104      	movs	r1, #4
   12bfe:	681b      	ldr	r3, [r3, #0]
   12c00:	2008      	movs	r0, #8
   12c02:	0a9a      	lsrs	r2, r3, #10
   12c04:	9301      	str	r3, [sp, #4]
   12c06:	f000 fe87 	bl	13918 <osSlabAllocatorNew>
   12c0a:	6020      	str	r0, [r4, #0]
    } else {
        PRINT_WARN("pSlabMemAllocator inited before?\n");
    }
    slab_mem_count = sizeof(slab_mem) /sizeof(slab_mem[0]);
   12c0c:	2204      	movs	r2, #4
   12c0e:	4b05      	ldr	r3, [pc, #20]	; (12c24 <osSlabMemInit+0x34>)
   12c10:	601a      	str	r2, [r3, #0]
    p_slab_last = (slab_mem + slab_mem_count);
   12c12:	4b05      	ldr	r3, [pc, #20]	; (12c28 <osSlabMemInit+0x38>)
   12c14:	4a05      	ldr	r2, [pc, #20]	; (12c2c <osSlabMemInit+0x3c>)
   12c16:	3330      	adds	r3, #48	; 0x30
   12c18:	6013      	str	r3, [r2, #0]
}
   12c1a:	bd13      	pop	{r0, r1, r4, pc}
   12c1c:	01002e48 	.word	0x01002e48
   12c20:	0002558c 	.word	0x0002558c
   12c24:	01002e44 	.word	0x01002e44
   12c28:	01000598 	.word	0x01000598
   12c2c:	010024fc 	.word	0x010024fc

00012c30 <osSlabMemAlloc>:
 Input       :  UITN32 sz --- size of the  memory we want to alloc
 Output      : None
 Return      : pointer :the address of the memory we alloced
*****************************************************************************/
void *osSlabMemAlloc(UINT32 sz)
{
   12c30:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
    void *ret;
    UINTPTR uvIntSave;
    struct LOS_SLAB_MEM *p_slab_mem = slab_mem;
    struct LOS_SLAB_MEM_ALLOCATOR **pAlloc;
    while (p_slab_mem < p_slab_last) {
   12c32:	4b21      	ldr	r3, [pc, #132]	; (12cb8 <osSlabMemAlloc+0x88>)
    struct LOS_SLAB_MEM *p_slab_mem = slab_mem;
   12c34:	4e21      	ldr	r6, [pc, #132]	; (12cbc <osSlabMemAlloc+0x8c>)
    while (p_slab_mem < p_slab_last) {
   12c36:	681b      	ldr	r3, [r3, #0]
   12c38:	42b3      	cmp	r3, r6
   12c3a:	d802      	bhi.n	12c42 <osSlabMemAlloc+0x12>
        if (sz <= p_slab_mem->blkSz) {
            goto FOUND;
        }
        p_slab_mem ++;
    }
    return NULL;
   12c3c:	2400      	movs	r4, #0
    if (NULL != ret)
    {
        g_SlabAllocCount++;
    }
    return ret;
}
   12c3e:	0020      	movs	r0, r4
   12c40:	bdfe      	pop	{r1, r2, r3, r4, r5, r6, r7, pc}
        if (sz <= p_slab_mem->blkSz) {
   12c42:	6832      	ldr	r2, [r6, #0]
   12c44:	4282      	cmp	r2, r0
   12c46:	d201      	bcs.n	12c4c <osSlabMemAlloc+0x1c>
        p_slab_mem ++;
   12c48:	360c      	adds	r6, #12
   12c4a:	e7f5      	b.n	12c38 <osSlabMemAlloc+0x8>
    uvIntSave = LOS_IntLock();//PRIMASK_DISABLE_IRQ();
   12c4c:	f7ed fa87 	bl	15e <LOS_IntLock>
    pAlloc = &p_slab_mem->alloc;
   12c50:	0035      	movs	r5, r6
    uvIntSave = LOS_IntLock();//PRIMASK_DISABLE_IRQ();
   12c52:	9001      	str	r0, [sp, #4]
    pAlloc = &p_slab_mem->alloc;
   12c54:	3508      	adds	r5, #8
    while (*pAlloc != NULL) {
   12c56:	682c      	ldr	r4, [r5, #0]
   12c58:	2c00      	cmp	r4, #0
   12c5a:	d120      	bne.n	12c9e <osSlabMemAlloc+0x6e>
    (*pAlloc) = osSlabAllocatorAlloc(pSlabMemAllocator);
   12c5c:	4b18      	ldr	r3, [pc, #96]	; (12cc0 <osSlabMemAlloc+0x90>)
   12c5e:	6818      	ldr	r0, [r3, #0]
   12c60:	f000 fe8a 	bl	13978 <osSlabAllocatorAlloc>
   12c64:	1e07      	subs	r7, r0, #0
   12c66:	6028      	str	r0, [r5, #0]
    if ((*pAlloc) == NULL)
   12c68:	d00f      	beq.n	12c8a <osSlabMemAlloc+0x5a>
    (*pAlloc)->slabAlloc = osSlabAllocatorNew(p_slab_mem->blkSz, sizeof(UINT32), p_slab_mem->blkCnt);
   12c6a:	2104      	movs	r1, #4
   12c6c:	6872      	ldr	r2, [r6, #4]
   12c6e:	6830      	ldr	r0, [r6, #0]
   12c70:	f000 fe52 	bl	13918 <osSlabAllocatorNew>
   12c74:	6078      	str	r0, [r7, #4]
    if ((*pAlloc)->slabAlloc) {
   12c76:	6829      	ldr	r1, [r5, #0]
   12c78:	684b      	ldr	r3, [r1, #4]
   12c7a:	2b00      	cmp	r3, #0
   12c7c:	d016      	beq.n	12cac <osSlabMemAlloc+0x7c>
        (*pAlloc)->next = NULL;
   12c7e:	600c      	str	r4, [r1, #0]
        ret = osSlabAllocatorAlloc((*pAlloc)->slabAlloc);
   12c80:	682b      	ldr	r3, [r5, #0]
   12c82:	6858      	ldr	r0, [r3, #4]
   12c84:	f000 fe78 	bl	13978 <osSlabAllocatorAlloc>
   12c88:	0004      	movs	r4, r0
    (VOID)LOS_IntRestore(uvIntSave);
   12c8a:	9801      	ldr	r0, [sp, #4]
   12c8c:	f7ed fa6f 	bl	16e <LOS_IntRestore>
    if (NULL != ret)
   12c90:	2c00      	cmp	r4, #0
   12c92:	d0d4      	beq.n	12c3e <osSlabMemAlloc+0xe>
        g_SlabAllocCount++;
   12c94:	4a0b      	ldr	r2, [pc, #44]	; (12cc4 <osSlabMemAlloc+0x94>)
   12c96:	6813      	ldr	r3, [r2, #0]
   12c98:	3301      	adds	r3, #1
   12c9a:	6013      	str	r3, [r2, #0]
   12c9c:	e7cf      	b.n	12c3e <osSlabMemAlloc+0xe>
        ret = osSlabAllocatorAlloc((*pAlloc)->slabAlloc);
   12c9e:	6860      	ldr	r0, [r4, #4]
   12ca0:	f000 fe6a 	bl	13978 <osSlabAllocatorAlloc>
   12ca4:	1e04      	subs	r4, r0, #0
        if (NULL != ret) {
   12ca6:	d1f0      	bne.n	12c8a <osSlabMemAlloc+0x5a>
        pAlloc = &((*pAlloc)->next);
   12ca8:	682d      	ldr	r5, [r5, #0]
   12caa:	e7d4      	b.n	12c56 <osSlabMemAlloc+0x26>
        (VOID)osSlabAllocatorFree(pSlabMemAllocator, *pAlloc);
   12cac:	4b04      	ldr	r3, [pc, #16]	; (12cc0 <osSlabMemAlloc+0x90>)
   12cae:	6818      	ldr	r0, [r3, #0]
   12cb0:	f000 fe70 	bl	13994 <osSlabAllocatorFree>
        (*pAlloc) = NULL;
   12cb4:	602c      	str	r4, [r5, #0]
   12cb6:	e7e8      	b.n	12c8a <osSlabMemAlloc+0x5a>
   12cb8:	010024fc 	.word	0x010024fc
   12cbc:	01000598 	.word	0x01000598
   12cc0:	01002e48 	.word	0x01002e48
   12cc4:	010024f4 	.word	0x010024f4

00012cc8 <osSlabMemFree>:
 Input       : void* ptr: the pointer of heap memory we want to free
 Output      : None
 Return      : 1:success 0:error
*****************************************************************************/
bool osSlabMemFree(void* ptr)
{
   12cc8:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
   12cca:	9001      	str	r0, [sp, #4]
    UINTPTR uvIntSave;
    struct LOS_SLAB_MEM *p_slab_mem = slab_mem;
    bool ret = false;
    struct LOS_SLAB_MEM_ALLOCATOR **pAlloc;
    struct LOS_SLAB_ALLOCATOR *pSlabAlloc;
    uvIntSave = LOS_IntLock();//	PRIMASK_DISABLE_IRQ();
   12ccc:	f7ed fa47 	bl	15e <LOS_IntLock>
   12cd0:	4c1a      	ldr	r4, [pc, #104]	; (12d3c <osSlabMemFree+0x74>)
   12cd2:	9000      	str	r0, [sp, #0]
   12cd4:	3408      	adds	r4, #8
    while (p_slab_mem < p_slab_last) {
   12cd6:	4b1a      	ldr	r3, [pc, #104]	; (12d40 <osSlabMemFree+0x78>)
   12cd8:	681a      	ldr	r2, [r3, #0]
   12cda:	0023      	movs	r3, r4
   12cdc:	3b08      	subs	r3, #8
   12cde:	429a      	cmp	r2, r3
   12ce0:	d801      	bhi.n	12ce6 <osSlabMemFree+0x1e>
    bool ret = false;
   12ce2:	2500      	movs	r5, #0
   12ce4:	e01d      	b.n	12d22 <osSlabMemFree+0x5a>
        pAlloc = &p_slab_mem->alloc;
   12ce6:	0026      	movs	r6, r4
        while (*pAlloc != NULL) {
   12ce8:	6833      	ldr	r3, [r6, #0]
   12cea:	2b00      	cmp	r3, #0
   12cec:	d101      	bne.n	12cf2 <osSlabMemFree+0x2a>
   12cee:	340c      	adds	r4, #12
   12cf0:	e7f1      	b.n	12cd6 <osSlabMemFree+0xe>
            pSlabAlloc = (*pAlloc)->slabAlloc;
   12cf2:	685f      	ldr	r7, [r3, #4]
            if (osSlabAllocatorFree(pSlabAlloc, ptr) == TRUE) {
   12cf4:	9901      	ldr	r1, [sp, #4]
   12cf6:	0038      	movs	r0, r7
   12cf8:	f000 fe4c 	bl	13994 <osSlabAllocatorFree>
   12cfc:	1e05      	subs	r5, r0, #0
   12cfe:	d01b      	beq.n	12d38 <osSlabMemFree+0x70>
                /* try to destroy slabAllocator if needed */
                if (osSlabAllocatorEmpty(pSlabAlloc) == TRUE) {
   12d00:	0038      	movs	r0, r7
   12d02:	f000 fe65 	bl	139d0 <osSlabAllocatorEmpty>
   12d06:	1e04      	subs	r4, r0, #0
   12d08:	d00b      	beq.n	12d22 <osSlabMemFree+0x5a>
                    struct LOS_SLAB_MEM_ALLOCATOR *alloc = *pAlloc;
   12d0a:	6835      	ldr	r5, [r6, #0]
                    (*pAlloc) = (*pAlloc)->next;	/* delete node in list */
   12d0c:	682b      	ldr	r3, [r5, #0]
   12d0e:	6033      	str	r3, [r6, #0]
                    osSlabAllocatorDestroy(alloc->slabAlloc); /* destory slabAllocator */
   12d10:	6868      	ldr	r0, [r5, #4]
   12d12:	f000 fe29 	bl	13968 <osSlabAllocatorDestroy>
                    (VOID)osSlabAllocatorFree(pSlabMemAllocator, alloc);
   12d16:	4b0b      	ldr	r3, [pc, #44]	; (12d44 <osSlabMemFree+0x7c>)
   12d18:	0029      	movs	r1, r5
   12d1a:	6818      	ldr	r0, [r3, #0]
   12d1c:	f000 fe3a 	bl	13994 <osSlabAllocatorFree>
                }
                ret = true;
   12d20:	0025      	movs	r5, r4
            pAlloc = &((*pAlloc)->next);
        }
        p_slab_mem ++;
    }
OUT:
    (VOID)LOS_IntRestore(uvIntSave);
   12d22:	9800      	ldr	r0, [sp, #0]
   12d24:	f7ed fa23 	bl	16e <LOS_IntRestore>
    if (true == ret)
   12d28:	2d00      	cmp	r5, #0
   12d2a:	d003      	beq.n	12d34 <osSlabMemFree+0x6c>
    {
        g_SlabFreeCount++;
   12d2c:	4a06      	ldr	r2, [pc, #24]	; (12d48 <osSlabMemFree+0x80>)
   12d2e:	6813      	ldr	r3, [r2, #0]
   12d30:	3301      	adds	r3, #1
   12d32:	6013      	str	r3, [r2, #0]
    }
    return ret;
}
   12d34:	0028      	movs	r0, r5
   12d36:	bdfe      	pop	{r1, r2, r3, r4, r5, r6, r7, pc}
            pAlloc = &((*pAlloc)->next);
   12d38:	6836      	ldr	r6, [r6, #0]
   12d3a:	e7d5      	b.n	12ce8 <osSlabMemFree+0x20>
   12d3c:	01000598 	.word	0x01000598
   12d40:	010024fc 	.word	0x010024fc
   12d44:	01002e48 	.word	0x01002e48
   12d48:	010024f8 	.word	0x010024f8

00012d4c <osSlabStatisticsGet>:
    (VOID)LOS_IntRestore(uvIntSave);
    return retBlkSz;
}

UINT32 osSlabStatisticsGet(UINT32 *Total, UINT32 *Used, UINT32 *AllocCount, UINT32 *FreeCount)
{
   12d4c:	b5f0      	push	{r4, r5, r6, r7, lr}
   12d4e:	b089      	sub	sp, #36	; 0x24
   12d50:	0007      	movs	r7, r0
   12d52:	9101      	str	r1, [sp, #4]
   12d54:	9202      	str	r2, [sp, #8]
   12d56:	9303      	str	r3, [sp, #12]
    if ((NULL == Total) || (NULL == Used))
    {
        return LOS_NOK;
   12d58:	2001      	movs	r0, #1
    if ((NULL == Total) || (NULL == Used))
   12d5a:	2f00      	cmp	r7, #0
   12d5c:	d01f      	beq.n	12d9e <osSlabStatisticsGet+0x52>
   12d5e:	2900      	cmp	r1, #0
   12d60:	d01d      	beq.n	12d9e <osSlabStatisticsGet+0x52>
    }

    struct LOS_SLAB_MEM *p_slab_mem = slab_mem;
    struct LOS_SLAB_MEM_ALLOCATOR **pAlloc;
    struct LOS_SLAB_ALLOCATOR *pSlabAlloc = NULL;
    UINT32 item_sz = 0;
   12d62:	2400      	movs	r4, #0
   12d64:	4d1a      	ldr	r5, [pc, #104]	; (12dd0 <osSlabStatisticsGet+0x84>)
   12d66:	9405      	str	r4, [sp, #20]
    UINT32 item_cnt = 0;
   12d68:	9406      	str	r4, [sp, #24]
    UINT32 cur_usage = 0;
   12d6a:	9407      	str	r4, [sp, #28]
   12d6c:	3508      	adds	r5, #8
    UINT32 TotalUsage = 0;
   12d6e:	9400      	str	r4, [sp, #0]
    UINT32 TotalMem = 0;

    while (p_slab_mem < p_slab_last)
   12d70:	4b18      	ldr	r3, [pc, #96]	; (12dd4 <osSlabStatisticsGet+0x88>)
   12d72:	681a      	ldr	r2, [r3, #0]
   12d74:	002b      	movs	r3, r5
   12d76:	3b08      	subs	r3, #8
   12d78:	429a      	cmp	r2, r3
   12d7a:	d812      	bhi.n	12da2 <osSlabStatisticsGet+0x56>

    *Total = TotalMem;
    *Used = TotalUsage;
    *AllocCount = g_SlabAllocCount;
    *FreeCount = g_SlabFreeCount;
    return LOS_OK;
   12d7c:	2000      	movs	r0, #0
    *Used = TotalUsage;
   12d7e:	9a00      	ldr	r2, [sp, #0]
   12d80:	9b01      	ldr	r3, [sp, #4]
    *Total = TotalMem;
   12d82:	603c      	str	r4, [r7, #0]
    *Used = TotalUsage;
   12d84:	601a      	str	r2, [r3, #0]
    *AllocCount = g_SlabAllocCount;
   12d86:	4b14      	ldr	r3, [pc, #80]	; (12dd8 <osSlabStatisticsGet+0x8c>)
   12d88:	681b      	ldr	r3, [r3, #0]
   12d8a:	9300      	str	r3, [sp, #0]
   12d8c:	9a00      	ldr	r2, [sp, #0]
   12d8e:	9b02      	ldr	r3, [sp, #8]
   12d90:	601a      	str	r2, [r3, #0]
    *FreeCount = g_SlabFreeCount;
   12d92:	4b12      	ldr	r3, [pc, #72]	; (12ddc <osSlabStatisticsGet+0x90>)
   12d94:	681b      	ldr	r3, [r3, #0]
   12d96:	9300      	str	r3, [sp, #0]
   12d98:	9a00      	ldr	r2, [sp, #0]
   12d9a:	9b03      	ldr	r3, [sp, #12]
   12d9c:	601a      	str	r2, [r3, #0]
}
   12d9e:	b009      	add	sp, #36	; 0x24
   12da0:	bdf0      	pop	{r4, r5, r6, r7, pc}
        pAlloc = &p_slab_mem->alloc;
   12da2:	002e      	movs	r6, r5
        while (*pAlloc != NULL)
   12da4:	6830      	ldr	r0, [r6, #0]
   12da6:	2800      	cmp	r0, #0
   12da8:	d101      	bne.n	12dae <osSlabStatisticsGet+0x62>
   12daa:	350c      	adds	r5, #12
   12dac:	e7e0      	b.n	12d70 <osSlabStatisticsGet+0x24>
            osSlabAllocatorGetSlabInfo(pSlabAlloc, &item_sz, &item_cnt, &cur_usage);
   12dae:	ab07      	add	r3, sp, #28
   12db0:	aa06      	add	r2, sp, #24
   12db2:	a905      	add	r1, sp, #20
   12db4:	6840      	ldr	r0, [r0, #4]
   12db6:	f000 fe27 	bl	13a08 <osSlabAllocatorGetSlabInfo>
            TotalUsage += (cur_usage * item_sz);
   12dba:	9b05      	ldr	r3, [sp, #20]
   12dbc:	9a07      	ldr	r2, [sp, #28]
   12dbe:	9900      	ldr	r1, [sp, #0]
   12dc0:	435a      	muls	r2, r3
   12dc2:	188a      	adds	r2, r1, r2
   12dc4:	9200      	str	r2, [sp, #0]
            TotalMem += (item_cnt * item_sz);
   12dc6:	9a06      	ldr	r2, [sp, #24]
            pAlloc = &((*pAlloc)->next);
   12dc8:	6836      	ldr	r6, [r6, #0]
            TotalMem += (item_cnt * item_sz);
   12dca:	4353      	muls	r3, r2
   12dcc:	18e4      	adds	r4, r4, r3
   12dce:	e7e9      	b.n	12da4 <osSlabStatisticsGet+0x58>
   12dd0:	01000598 	.word	0x01000598
   12dd4:	010024fc 	.word	0x010024fc
   12dd8:	010024f4 	.word	0x010024f4
   12ddc:	010024f8 	.word	0x010024f8

00012de0 <osSlabGetMaxBlkSize>:

UINT32 osSlabGetMaxBlkSize(VOID)
{
   12de0:	b530      	push	{r4, r5, lr}
    struct LOS_SLAB_MEM *p_slab_mem = (p_slab_last - 1);
   12de2:	4b12      	ldr	r3, [pc, #72]	; (12e2c <osSlabGetMaxBlkSize+0x4c>)
{
   12de4:	b085      	sub	sp, #20
    struct LOS_SLAB_MEM *p_slab_mem = (p_slab_last - 1);
   12de6:	681c      	ldr	r4, [r3, #0]
    struct LOS_SLAB_MEM_ALLOCATOR **pAlloc;
    struct LOS_SLAB_ALLOCATOR *pSlabAlloc = NULL;
    UINT32 item_sz = 0;
   12de8:	2300      	movs	r3, #0
    struct LOS_SLAB_MEM *p_slab_mem = (p_slab_last - 1);
   12dea:	3c0c      	subs	r4, #12
    UINT32 item_sz = 0;
   12dec:	9301      	str	r3, [sp, #4]
    UINT32 item_cnt = 0;
   12dee:	9302      	str	r3, [sp, #8]
    UINT32 cur_usage = 0;
   12df0:	9303      	str	r3, [sp, #12]

    while (p_slab_mem >= slab_mem)
   12df2:	4b0f      	ldr	r3, [pc, #60]	; (12e30 <osSlabGetMaxBlkSize+0x50>)
   12df4:	429c      	cmp	r4, r3
   12df6:	d201      	bcs.n	12dfc <osSlabGetMaxBlkSize+0x1c>
        }

        p_slab_mem--;
    }

    return 0;
   12df8:	2000      	movs	r0, #0
   12dfa:	e013      	b.n	12e24 <osSlabGetMaxBlkSize+0x44>
   12dfc:	0025      	movs	r5, r4
   12dfe:	3508      	adds	r5, #8
        while (*pAlloc != NULL)
   12e00:	682b      	ldr	r3, [r5, #0]
   12e02:	2b00      	cmp	r3, #0
   12e04:	d101      	bne.n	12e0a <osSlabGetMaxBlkSize+0x2a>
        p_slab_mem--;
   12e06:	3c0c      	subs	r4, #12
   12e08:	e7f3      	b.n	12df2 <osSlabGetMaxBlkSize+0x12>
            pSlabAlloc = (*pAlloc)->slabAlloc;
   12e0a:	6858      	ldr	r0, [r3, #4]
            if (pSlabAlloc)
   12e0c:	2800      	cmp	r0, #0
   12e0e:	d00b      	beq.n	12e28 <osSlabGetMaxBlkSize+0x48>
                osSlabAllocatorGetSlabInfo(pSlabAlloc, &item_sz, &item_cnt, &cur_usage);
   12e10:	ab03      	add	r3, sp, #12
   12e12:	aa02      	add	r2, sp, #8
   12e14:	a901      	add	r1, sp, #4
   12e16:	f000 fdf7 	bl	13a08 <osSlabAllocatorGetSlabInfo>
                if (cur_usage != item_cnt)
   12e1a:	9b03      	ldr	r3, [sp, #12]
   12e1c:	9a02      	ldr	r2, [sp, #8]
   12e1e:	4293      	cmp	r3, r2
   12e20:	d002      	beq.n	12e28 <osSlabGetMaxBlkSize+0x48>
                    return item_sz;
   12e22:	9801      	ldr	r0, [sp, #4]
}
   12e24:	b005      	add	sp, #20
   12e26:	bd30      	pop	{r4, r5, pc}
            pAlloc = &((*pAlloc)->next);
   12e28:	682d      	ldr	r5, [r5, #0]
   12e2a:	e7e9      	b.n	12e00 <osSlabGetMaxBlkSize+0x20>
   12e2c:	010024fc 	.word	0x010024fc
   12e30:	01000598 	.word	0x01000598

00012e34 <LOS_ListDelete>:
 *@see LOS_ListAdd
 *@since Huawei LiteOS V100R001C00
 */
LITE_OS_SEC_ALW_INLINE INLINE VOID LOS_ListDelete(LOS_DL_LIST *pstNode)
{
    pstNode->pstNext->pstPrev = pstNode->pstPrev;
   12e34:	6843      	ldr	r3, [r0, #4]
   12e36:	6802      	ldr	r2, [r0, #0]
   12e38:	601a      	str	r2, [r3, #0]
    pstNode->pstPrev->pstNext = pstNode->pstNext;
   12e3a:	6803      	ldr	r3, [r0, #0]
   12e3c:	6842      	ldr	r2, [r0, #4]
   12e3e:	605a      	str	r2, [r3, #4]
    pstNode->pstNext = (LOS_DL_LIST *)NULL;
   12e40:	2300      	movs	r3, #0
   12e42:	6043      	str	r3, [r0, #4]
    pstNode->pstPrev = (LOS_DL_LIST *)NULL;
   12e44:	6003      	str	r3, [r0, #0]
}
   12e46:	4770      	bx	lr

00012e48 <osTskSortLinkTicksGet>:
    UINT32 uwTaskSortLinkTick = 0;
    LOS_DL_LIST *pstListObject;
    UINT32 uwTempTicks = 0;
    UINT32 i =0;

    for (i = 0; i < OS_TSK_SORTLINK_LEN; i++)
   12e48:	2200      	movs	r2, #0
{
   12e4a:	b5f0      	push	{r4, r5, r6, r7, lr}
    UINT32 uwTaskSortLinkTick = 0;
   12e4c:	0010      	movs	r0, r2
    {
        pstListObject = g_stTskSortLink.pstSortLink + (g_stTskSortLink.usCursor + i)%OS_TSK_SORTLINK_LEN;
   12e4e:	251f      	movs	r5, #31
        if (pstListObject->pstNext != pstListObject)
        {
            pstTaskCB = LOS_DL_LIST_ENTRY((pstListObject)->pstNext, LOS_TASK_CB, stTimerList);
            uwTempTicks = (i == 0) ? OS_TSK_SORTLINK_LEN : i;
   12e50:	2620      	movs	r6, #32
        pstListObject = g_stTskSortLink.pstSortLink + (g_stTskSortLink.usCursor + i)%OS_TSK_SORTLINK_LEN;
   12e52:	4b0e      	ldr	r3, [pc, #56]	; (12e8c <osTskSortLinkTicksGet+0x44>)
   12e54:	6819      	ldr	r1, [r3, #0]
   12e56:	889c      	ldrh	r4, [r3, #4]
   12e58:	18a3      	adds	r3, r4, r2
   12e5a:	402b      	ands	r3, r5
   12e5c:	00db      	lsls	r3, r3, #3
   12e5e:	18cb      	adds	r3, r1, r3
        if (pstListObject->pstNext != pstListObject)
   12e60:	685f      	ldr	r7, [r3, #4]
   12e62:	46bc      	mov	ip, r7
   12e64:	429f      	cmp	r7, r3
   12e66:	d00c      	beq.n	12e82 <osTskSortLinkTicksGet+0x3a>
            uwTempTicks = (i == 0) ? OS_TSK_SORTLINK_LEN : i;
   12e68:	0037      	movs	r7, r6
   12e6a:	2a00      	cmp	r2, #0
   12e6c:	d000      	beq.n	12e70 <osTskSortLinkTicksGet+0x28>
   12e6e:	0017      	movs	r7, r2
            uwTempTicks += (UINT32)(UWROLLNUM(pstTaskCB->uwIdxRollNum) * OS_TSK_SORTLINK_LEN);
   12e70:	4663      	mov	r3, ip
   12e72:	689b      	ldr	r3, [r3, #8]
   12e74:	015b      	lsls	r3, r3, #5
   12e76:	19db      	adds	r3, r3, r7
            if(uwTaskSortLinkTick == 0 || uwTaskSortLinkTick > uwTempTicks)
   12e78:	2800      	cmp	r0, #0
   12e7a:	d001      	beq.n	12e80 <osTskSortLinkTicksGet+0x38>
   12e7c:	4298      	cmp	r0, r3
   12e7e:	d900      	bls.n	12e82 <osTskSortLinkTicksGet+0x3a>
            uwTempTicks += (UINT32)(UWROLLNUM(pstTaskCB->uwIdxRollNum) * OS_TSK_SORTLINK_LEN);
   12e80:	0018      	movs	r0, r3
    for (i = 0; i < OS_TSK_SORTLINK_LEN; i++)
   12e82:	3201      	adds	r2, #1
   12e84:	2a20      	cmp	r2, #32
   12e86:	d1e7      	bne.n	12e58 <osTskSortLinkTicksGet+0x10>
            }
        }
    }

    return uwTaskSortLinkTick;
}
   12e88:	bdf0      	pop	{r4, r5, r6, r7, pc}
   12e8a:	46c0      	nop			; (mov r8, r8)
   12e8c:	01002e5c 	.word	0x01002e5c

00012e90 <osIdleTask>:
 Input       : None
 Output      : None
 Return      : None
 *****************************************************************************/
LITE_OS_SEC_TEXT VOID osIdleTask(VOID)
{
   12e90:	b570      	push	{r4, r5, r6, lr}
        }
        SwtmrExpectTime = osSwTmrGetNextTimeout();
        TaskExpectTime = osTskSortLinkTicksGet();
        if(TaskExpectTime == 0)
        {
            TaskExpectTime = LOS_WAIT_FOREVER;
   12e92:	2501      	movs	r5, #1
   12e94:	426d      	negs	r5, r5
        watchdog_kick();
   12e96:	f005 fcff 	bl	18898 <watchdog_kick>
        non_os_enter_critical();
   12e9a:	f005 f98b 	bl	181b4 <non_os_enter_critical>
        if (uart_is_need_awake_callback != NULL)
   12e9e:	4b0c      	ldr	r3, [pc, #48]	; (12ed0 <osIdleTask+0x40>)
   12ea0:	681b      	ldr	r3, [r3, #0]
   12ea2:	2b00      	cmp	r3, #0
   12ea4:	d005      	beq.n	12eb2 <osIdleTask+0x22>
            if(!uart_is_need_awake_callback())
   12ea6:	4798      	blx	r3
   12ea8:	2800      	cmp	r0, #0
   12eaa:	d102      	bne.n	12eb2 <osIdleTask+0x22>
        }
        IdleExpectTime = SwtmrExpectTime > TaskExpectTime ? TaskExpectTime : SwtmrExpectTime;
        los_SuppressTicksAndSleep(IdleExpectTime);
        non_os_exit_critical();
   12eac:	f005 f996 	bl	181dc <non_os_exit_critical>
   12eb0:	e7f1      	b.n	12e96 <osIdleTask+0x6>
        SwtmrExpectTime = osSwTmrGetNextTimeout();
   12eb2:	f001 f879 	bl	13fa8 <osSwTmrGetNextTimeout>
   12eb6:	0004      	movs	r4, r0
        TaskExpectTime = osTskSortLinkTicksGet();
   12eb8:	f7ff ffc6 	bl	12e48 <osTskSortLinkTicksGet>
        if(TaskExpectTime == 0)
   12ebc:	2800      	cmp	r0, #0
   12ebe:	d100      	bne.n	12ec2 <osIdleTask+0x32>
            TaskExpectTime = LOS_WAIT_FOREVER;
   12ec0:	0028      	movs	r0, r5
        IdleExpectTime = SwtmrExpectTime > TaskExpectTime ? TaskExpectTime : SwtmrExpectTime;
   12ec2:	42a0      	cmp	r0, r4
   12ec4:	d900      	bls.n	12ec8 <osIdleTask+0x38>
   12ec6:	0020      	movs	r0, r4
        los_SuppressTicksAndSleep(IdleExpectTime);
   12ec8:	f000 fe7e 	bl	13bc8 <los_SuppressTicksAndSleep>
   12ecc:	e7ee      	b.n	12eac <osIdleTask+0x1c>
   12ece:	46c0      	nop			; (mov r8, r8)
   12ed0:	01002538 	.word	0x01002538

00012ed4 <osTskSortLinkUpdate>:
{
   12ed4:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
    uwcount = uwSleepTicks % OS_TSK_SORTLINK_LEN;
   12ed6:	271f      	movs	r7, #31
    uwIdxRollNum = uwSleepTicks / OS_TSK_SORTLINK_LEN;
   12ed8:	0944      	lsrs	r4, r0, #5
    uwcount = uwSleepTicks % OS_TSK_SORTLINK_LEN;
   12eda:	4007      	ands	r7, r0
    if (uwcount ==  0)
   12edc:	d101      	bne.n	12ee2 <osTskSortLinkUpdate+0xe>
        uwIdxRollNum -= 1;
   12ede:	3c01      	subs	r4, #1
        uwcount = 32;
   12ee0:	3720      	adds	r7, #32
        pstListObject = g_stTskSortLink.pstSortLink + (g_stTskSortLink.usCursor + i) % OS_TSK_SORTLINK_LEN;
   12ee2:	4b16      	ldr	r3, [pc, #88]	; (12f3c <osTskSortLinkUpdate+0x68>)
    for (i = 0; i < OS_TSK_SORTLINK_LEN; i++)
   12ee4:	2100      	movs	r1, #0
        pstListObject = g_stTskSortLink.pstSortLink + (g_stTskSortLink.usCursor + i) % OS_TSK_SORTLINK_LEN;
   12ee6:	681a      	ldr	r2, [r3, #0]
            UWROLLNUMSUB(pstTaskCB->uwIdxRollNum, uwIdxRollNum);
   12ee8:	0164      	lsls	r4, r4, #5
        pstListObject = g_stTskSortLink.pstSortLink + (g_stTskSortLink.usCursor + i) % OS_TSK_SORTLINK_LEN;
   12eea:	9201      	str	r2, [sp, #4]
   12eec:	889a      	ldrh	r2, [r3, #4]
   12eee:	231f      	movs	r3, #31
   12ef0:	469c      	mov	ip, r3
            UWROLLNUMSUB(pstTaskCB->uwIdxRollNum, uwIdxRollNum);
   12ef2:	0964      	lsrs	r4, r4, #5
        pstListObject = g_stTskSortLink.pstSortLink + (g_stTskSortLink.usCursor + i) % OS_TSK_SORTLINK_LEN;
   12ef4:	4665      	mov	r5, ip
   12ef6:	1853      	adds	r3, r2, r1
   12ef8:	402b      	ands	r3, r5
   12efa:	9d01      	ldr	r5, [sp, #4]
   12efc:	00db      	lsls	r3, r3, #3
   12efe:	18eb      	adds	r3, r5, r3
        if (pstListObject->pstNext != pstListObject)
   12f00:	685d      	ldr	r5, [r3, #4]
   12f02:	429d      	cmp	r5, r3
   12f04:	d00e      	beq.n	12f24 <osTskSortLinkUpdate+0x50>
            UWROLLNUMSUB(pstTaskCB->uwIdxRollNum, uwIdxRollNum);
   12f06:	68ae      	ldr	r6, [r5, #8]
   12f08:	3d34      	subs	r5, #52	; 0x34
   12f0a:	0173      	lsls	r3, r6, #5
   12f0c:	095b      	lsrs	r3, r3, #5
   12f0e:	0ef6      	lsrs	r6, r6, #27
   12f10:	1b1b      	subs	r3, r3, r4
   12f12:	06f6      	lsls	r6, r6, #27
   12f14:	431e      	orrs	r6, r3
   12f16:	63ee      	str	r6, [r5, #60]	; 0x3c
            if(i > 0 && i< uwcount)
   12f18:	2900      	cmp	r1, #0
   12f1a:	d00d      	beq.n	12f38 <osTskSortLinkUpdate+0x64>
   12f1c:	428f      	cmp	r7, r1
   12f1e:	d901      	bls.n	12f24 <osTskSortLinkUpdate+0x50>
                UWROLLNUMDEC(pstTaskCB->uwIdxRollNum);
   12f20:	3e01      	subs	r6, #1
   12f22:	63ee      	str	r6, [r5, #60]	; 0x3c
    for (i = 0; i < OS_TSK_SORTLINK_LEN; i++)
   12f24:	3101      	adds	r1, #1
   12f26:	2920      	cmp	r1, #32
   12f28:	d1e4      	bne.n	12ef4 <osTskSortLinkUpdate+0x20>
    g_stTskSortLink.usCursor = (g_stTskSortLink.usCursor + uwSleepTicks - 1) % OS_TSK_SORTLINK_LEN;
   12f2a:	3a01      	subs	r2, #1
   12f2c:	1810      	adds	r0, r2, r0
   12f2e:	221f      	movs	r2, #31
   12f30:	4b02      	ldr	r3, [pc, #8]	; (12f3c <osTskSortLinkUpdate+0x68>)
   12f32:	4010      	ands	r0, r2
   12f34:	8098      	strh	r0, [r3, #4]
}
   12f36:	bdf7      	pop	{r0, r1, r2, r4, r5, r6, r7, pc}
    for (i = 0; i < OS_TSK_SORTLINK_LEN; i++)
   12f38:	2101      	movs	r1, #1
   12f3a:	e7db      	b.n	12ef4 <osTskSortLinkUpdate+0x20>
   12f3c:	01002e5c 	.word	0x01002e5c

00012f40 <osTaskPriModify>:
                 usPriority      --- priority
 Output      : None
 Return      : None
 *****************************************************************************/
LITE_OS_SEC_TEXT_MINOR VOID osTaskPriModify(LOS_TASK_CB *pstTaskCB, UINT16 usPriority)
{
   12f40:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    if (pstTaskCB->usTaskStatus & OS_TASK_STATUS_READY)
   12f42:	2504      	movs	r5, #4
   12f44:	8883      	ldrh	r3, [r0, #4]
{
   12f46:	0004      	movs	r4, r0
   12f48:	000e      	movs	r6, r1
    if (pstTaskCB->usTaskStatus & OS_TASK_STATUS_READY)
   12f4a:	422b      	tst	r3, r5
   12f4c:	d00e      	beq.n	12f6c <osTaskPriModify+0x2c>
    {
        osPriqueueDequeue(&pstTaskCB->stPendList);
   12f4e:	0007      	movs	r7, r0
   12f50:	372c      	adds	r7, #44	; 0x2c
   12f52:	0038      	movs	r0, r7
   12f54:	f000 ff08 	bl	13d68 <osPriqueueDequeue>
        pstTaskCB->usTaskStatus &= (~OS_TASK_STATUS_READY);
   12f58:	88a3      	ldrh	r3, [r4, #4]
        pstTaskCB->usPriority = usPriority;
   12f5a:	80e6      	strh	r6, [r4, #6]
        pstTaskCB->usTaskStatus &= (~OS_TASK_STATUS_READY);
   12f5c:	43ab      	bics	r3, r5
        pstTaskCB->usTaskStatus |= OS_TASK_STATUS_READY;
   12f5e:	431d      	orrs	r5, r3
   12f60:	80a5      	strh	r5, [r4, #4]
        osPriqueueEnqueue(&pstTaskCB->stPendList, pstTaskCB->usPriority);
   12f62:	0031      	movs	r1, r6
   12f64:	0038      	movs	r0, r7
   12f66:	f000 fef1 	bl	13d4c <osPriqueueEnqueue>
    }
    else
    {
        pstTaskCB->usPriority = usPriority;
    }
}
   12f6a:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
        pstTaskCB->usPriority = usPriority;
   12f6c:	80e1      	strh	r1, [r4, #6]
}
   12f6e:	e7fc      	b.n	12f6a <osTaskPriModify+0x2a>

00012f70 <osTaskAdd2TimerList>:
               uwTimeout    --- wait time, ticks
 Output      : None
 Return      : None
 *****************************************************************************/
LITE_OS_SEC_TEXT VOID osTaskAdd2TimerList(LOS_TASK_CB *pstTaskCB, UINT32 uwTimeout)
{
   12f70:	b5f0      	push	{r4, r5, r6, r7, lr}
    LOS_TASK_CB *pstTskDelay;
    LOS_DL_LIST *pstListObject;
    UINT32 uwSortIndex;
    UINT32 uwRollNum;

    uwSortIndex = uwTimeout & OS_TSK_SORTLINK_MASK;
   12f72:	000a      	movs	r2, r1
   12f74:	241f      	movs	r4, #31
   12f76:	4022      	ands	r2, r4
    uwRollNum = (uwTimeout >> OS_TSK_SORTLINK_LOGLEN);
    (uwSortIndex > 0) ? 0 : (uwRollNum--);
   12f78:	4253      	negs	r3, r2
   12f7a:	4153      	adcs	r3, r2
    uwRollNum = (uwTimeout >> OS_TSK_SORTLINK_LOGLEN);
   12f7c:	0949      	lsrs	r1, r1, #5
    (uwSortIndex > 0) ? 0 : (uwRollNum--);
   12f7e:	1ac9      	subs	r1, r1, r3
    EVALUATE_L(pstTaskCB->uwIdxRollNum, uwRollNum);
    uwSortIndex = (uwSortIndex + g_stTskSortLink.usCursor);
   12f80:	4b1a      	ldr	r3, [pc, #104]	; (12fec <osTaskAdd2TimerList+0x7c>)
    uwSortIndex = uwSortIndex & OS_TSK_SORTLINK_MASK;
    EVALUATE_H(pstTaskCB->uwIdxRollNum, uwSortIndex);
   12f82:	0149      	lsls	r1, r1, #5
    uwSortIndex = (uwSortIndex + g_stTskSortLink.usCursor);
   12f84:	889f      	ldrh	r7, [r3, #4]
    EVALUATE_H(pstTaskCB->uwIdxRollNum, uwSortIndex);
   12f86:	0949      	lsrs	r1, r1, #5
    uwSortIndex = (uwSortIndex + g_stTskSortLink.usCursor);
   12f88:	18bf      	adds	r7, r7, r2
    uwSortIndex = uwSortIndex & OS_TSK_SORTLINK_MASK;
   12f8a:	4027      	ands	r7, r4
    EVALUATE_H(pstTaskCB->uwIdxRollNum, uwSortIndex);
   12f8c:	06fa      	lsls	r2, r7, #27
    pstListObject = g_stTskSortLink.pstSortLink + uwSortIndex;
   12f8e:	681b      	ldr	r3, [r3, #0]
    EVALUATE_H(pstTaskCB->uwIdxRollNum, uwSortIndex);
   12f90:	4311      	orrs	r1, r2
    pstListObject = g_stTskSortLink.pstSortLink + uwSortIndex;
   12f92:	00ff      	lsls	r7, r7, #3
    EVALUATE_H(pstTaskCB->uwIdxRollNum, uwSortIndex);
   12f94:	63c1      	str	r1, [r0, #60]	; 0x3c
    pstListObject = g_stTskSortLink.pstSortLink + uwSortIndex;
   12f96:	19df      	adds	r7, r3, r7
    if (pstListObject->pstNext == pstListObject)
   12f98:	687b      	ldr	r3, [r7, #4]
   12f9a:	0004      	movs	r4, r0
    {
        LOS_ListTailInsert(pstListObject, &pstTaskCB->stTimerList);
    }
    else
    {
        pstTskDelay = LOS_DL_LIST_ENTRY((pstListObject)->pstNext, LOS_TASK_CB, stTimerList); /*lint !e413*/
   12f9c:	0019      	movs	r1, r3
   12f9e:	3434      	adds	r4, #52	; 0x34
   12fa0:	3934      	subs	r1, #52	; 0x34
    if (pstListObject->pstNext == pstListObject)
   12fa2:	42bb      	cmp	r3, r7
   12fa4:	d107      	bne.n	12fb6 <osTaskAdd2TimerList+0x46>
   12fa6:	681b      	ldr	r3, [r3, #0]
    pstNode->pstNext = pstList->pstNext;
   12fa8:	685a      	ldr	r2, [r3, #4]
    pstNode->pstPrev = pstList;
   12faa:	6343      	str	r3, [r0, #52]	; 0x34
    pstNode->pstNext = pstList->pstNext;
   12fac:	6382      	str	r2, [r0, #56]	; 0x38
    pstList->pstNext->pstPrev = pstNode;
   12fae:	685a      	ldr	r2, [r3, #4]
   12fb0:	6014      	str	r4, [r2, #0]
    pstList->pstNext = pstNode;
   12fb2:	605c      	str	r4, [r3, #4]
            pstTskDelay = LOS_DL_LIST_ENTRY(pstTskDelay->stTimerList.pstNext, LOS_TASK_CB, stTimerList); /*lint !e413*/
        } while (&pstTskDelay->stTimerList != (pstListObject));

        LOS_ListTailInsert(&pstTskDelay->stTimerList, &pstTaskCB->stTimerList);
    }
}
   12fb4:	bdf0      	pop	{r4, r5, r6, r7, pc}
            if (UWROLLNUM(pstTskDelay->uwIdxRollNum) <= UWROLLNUM(pstTaskCB->uwIdxRollNum))
   12fb6:	6bcb      	ldr	r3, [r1, #60]	; 0x3c
   12fb8:	6bc2      	ldr	r2, [r0, #60]	; 0x3c
   12fba:	015d      	lsls	r5, r3, #5
   12fbc:	0156      	lsls	r6, r2, #5
   12fbe:	096d      	lsrs	r5, r5, #5
   12fc0:	0976      	lsrs	r6, r6, #5
   12fc2:	42b5      	cmp	r5, r6
   12fc4:	d80b      	bhi.n	12fde <osTaskAdd2TimerList+0x6e>
                UWROLLNUMSUB(pstTaskCB->uwIdxRollNum, pstTskDelay->uwIdxRollNum);
   12fc6:	0ed2      	lsrs	r2, r2, #27
   12fc8:	06d2      	lsls	r2, r2, #27
   12fca:	1b75      	subs	r5, r6, r5
   12fcc:	432a      	orrs	r2, r5
   12fce:	63c2      	str	r2, [r0, #60]	; 0x3c
            pstTskDelay = LOS_DL_LIST_ENTRY(pstTskDelay->stTimerList.pstNext, LOS_TASK_CB, stTimerList); /*lint !e413*/
   12fd0:	6b8b      	ldr	r3, [r1, #56]	; 0x38
   12fd2:	0019      	movs	r1, r3
   12fd4:	3934      	subs	r1, #52	; 0x34
        } while (&pstTskDelay->stTimerList != (pstListObject));
   12fd6:	429f      	cmp	r7, r3
   12fd8:	d1ed      	bne.n	12fb6 <osTaskAdd2TimerList+0x46>
   12fda:	6b4b      	ldr	r3, [r1, #52]	; 0x34
   12fdc:	e7e4      	b.n	12fa8 <osTaskAdd2TimerList+0x38>
                UWROLLNUMSUB(pstTskDelay->uwIdxRollNum, pstTaskCB->uwIdxRollNum);
   12fde:	0edb      	lsrs	r3, r3, #27
   12fe0:	06db      	lsls	r3, r3, #27
   12fe2:	1bad      	subs	r5, r5, r6
   12fe4:	432b      	orrs	r3, r5
   12fe6:	63cb      	str	r3, [r1, #60]	; 0x3c
                break;
   12fe8:	e7f7      	b.n	12fda <osTaskAdd2TimerList+0x6a>
   12fea:	46c0      	nop			; (mov r8, r8)
   12fec:	01002e5c 	.word	0x01002e5c

00012ff0 <osTimerListDelete>:


LITE_OS_SEC_TEXT VOID osTimerListDelete(LOS_TASK_CB *pstTaskCB)
{
   12ff0:	b510      	push	{r4, lr}
    LOS_DL_LIST  *pstListObject;
    LOS_TASK_CB  *pstNextTask;
    UINT32 uwSortIndex;

    uwSortIndex = UWSORTINDEX(pstTaskCB->uwIdxRollNum);
    pstListObject = g_stTskSortLink.pstSortLink + uwSortIndex;
   12ff2:	4b0b      	ldr	r3, [pc, #44]	; (13020 <osTimerListDelete+0x30>)
    uwSortIndex = UWSORTINDEX(pstTaskCB->uwIdxRollNum);
   12ff4:	6bc4      	ldr	r4, [r0, #60]	; 0x3c
    pstListObject = g_stTskSortLink.pstSortLink + uwSortIndex;
   12ff6:	681b      	ldr	r3, [r3, #0]
    uwSortIndex = UWSORTINDEX(pstTaskCB->uwIdxRollNum);
   12ff8:	0ee2      	lsrs	r2, r4, #27
    pstListObject = g_stTskSortLink.pstSortLink + uwSortIndex;
   12ffa:	00d2      	lsls	r2, r2, #3

    if (pstListObject != pstTaskCB->stTimerList.pstNext)
   12ffc:	6b81      	ldr	r1, [r0, #56]	; 0x38
    pstListObject = g_stTskSortLink.pstSortLink + uwSortIndex;
   12ffe:	189b      	adds	r3, r3, r2
    if (pstListObject != pstTaskCB->stTimerList.pstNext)
   13000:	4299      	cmp	r1, r3
   13002:	d009      	beq.n	13018 <osTimerListDelete+0x28>
    {
        pstNextTask = LOS_DL_LIST_ENTRY(pstTaskCB->stTimerList.pstNext, LOS_TASK_CB, stTimerList); /*lint !e413*/
        UWROLLNUMADD(pstNextTask->uwIdxRollNum, pstTaskCB->uwIdxRollNum);
   13004:	688a      	ldr	r2, [r1, #8]
   13006:	0164      	lsls	r4, r4, #5
   13008:	0153      	lsls	r3, r2, #5
   1300a:	095b      	lsrs	r3, r3, #5
   1300c:	0964      	lsrs	r4, r4, #5
   1300e:	0ed2      	lsrs	r2, r2, #27
   13010:	191b      	adds	r3, r3, r4
   13012:	06d2      	lsls	r2, r2, #27
   13014:	4313      	orrs	r3, r2
   13016:	608b      	str	r3, [r1, #8]
    }

    LOS_ListDelete(&pstTaskCB->stTimerList);
   13018:	3034      	adds	r0, #52	; 0x34
   1301a:	f7ff ff0b 	bl	12e34 <LOS_ListDelete>
}
   1301e:	bd10      	pop	{r4, pc}
   13020:	01002e5c 	.word	0x01002e5c

00013024 <osTaskScan>:

LITE_OS_SEC_TEXT VOID osTaskScan(UINT32 ticks)
{
   13024:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
    LOS_TASK_CB *pstTaskCB;
    BOOL bNeedSchedule = FALSE;
    LOS_DL_LIST *pstListObject;
    UINT16 usTempStatus;

    g_stTskSortLink.usCursor = (g_stTskSortLink.usCursor + ticks) % OS_TSK_SORTLINK_LEN;
   13026:	4b2a      	ldr	r3, [pc, #168]	; (130d0 <osTaskScan+0xac>)
   13028:	889d      	ldrh	r5, [r3, #4]
   1302a:	182d      	adds	r5, r5, r0
   1302c:	201f      	movs	r0, #31
   1302e:	4005      	ands	r5, r0
    pstListObject = g_stTskSortLink.pstSortLink + g_stTskSortLink.usCursor;
   13030:	6818      	ldr	r0, [r3, #0]
    g_stTskSortLink.usCursor = (g_stTskSortLink.usCursor + ticks) % OS_TSK_SORTLINK_LEN;
   13032:	809d      	strh	r5, [r3, #4]
    pstListObject = g_stTskSortLink.pstSortLink + g_stTskSortLink.usCursor;
   13034:	00ed      	lsls	r5, r5, #3
   13036:	1945      	adds	r5, r0, r5
    if (pstListObject->pstNext == pstListObject)
   13038:	686c      	ldr	r4, [r5, #4]
   1303a:	42ac      	cmp	r4, r5
   1303c:	d012      	beq.n	13064 <osTaskScan+0x40>
    BOOL bNeedSchedule = FALSE;
   1303e:	2300      	movs	r3, #0
    {
        return;
    }

    for (pstTaskCB = LOS_DL_LIST_ENTRY((pstListObject)->pstNext, LOS_TASK_CB, stTimerList);&pstTaskCB->stTimerList != (pstListObject);) /*lint !e413*/
   13040:	3c34      	subs	r4, #52	; 0x34
    BOOL bNeedSchedule = FALSE;
   13042:	9301      	str	r3, [sp, #4]
    for (pstTaskCB = LOS_DL_LIST_ENTRY((pstListObject)->pstNext, LOS_TASK_CB, stTimerList);&pstTaskCB->stTimerList != (pstListObject);) /*lint !e413*/
   13044:	0020      	movs	r0, r4
   13046:	3034      	adds	r0, #52	; 0x34
   13048:	42a8      	cmp	r0, r5
   1304a:	d006      	beq.n	1305a <osTaskScan+0x36>
    {
        usTempStatus = pstTaskCB->usTaskStatus;
        if (UWROLLNUM(pstTaskCB->uwIdxRollNum) > 0)
   1304c:	6be3      	ldr	r3, [r4, #60]	; 0x3c
        usTempStatus = pstTaskCB->usTaskStatus;
   1304e:	88a7      	ldrh	r7, [r4, #4]
        if (UWROLLNUM(pstTaskCB->uwIdxRollNum) > 0)
   13050:	015e      	lsls	r6, r3, #5
   13052:	0976      	lsrs	r6, r6, #5
   13054:	d007      	beq.n	13066 <osTaskScan+0x42>
        {
            UWROLLNUMDEC(pstTaskCB->uwIdxRollNum);
   13056:	3b01      	subs	r3, #1
   13058:	63e3      	str	r3, [r4, #60]	; 0x3c
        }

        pstTaskCB = LOS_DL_LIST_ENTRY(pstListObject->pstNext, LOS_TASK_CB, stTimerList); /*lint !e413*/
    }

    if (bNeedSchedule)
   1305a:	9b01      	ldr	r3, [sp, #4]
   1305c:	2b00      	cmp	r3, #0
   1305e:	d001      	beq.n	13064 <osTaskScan+0x40>
    {
        LOS_Schedule();
   13060:	f000 fcec 	bl	13a3c <LOS_Schedule>
    }
}
   13064:	bdf7      	pop	{r0, r1, r2, r4, r5, r6, r7, pc}
        LOS_ListDelete(&pstTaskCB->stTimerList);
   13066:	f7ff fee5 	bl	12e34 <LOS_ListDelete>
        if (OS_TASK_STATUS_PEND & usTempStatus)
   1306a:	2308      	movs	r3, #8
   1306c:	421f      	tst	r7, r3
   1306e:	d019      	beq.n	130a4 <osTaskScan+0x80>
            pstTaskCB->usTaskStatus &= ~(OS_TASK_STATUS_PEND);
   13070:	2208      	movs	r2, #8
            LOS_ListDelete(&pstTaskCB->stPendList);
   13072:	0020      	movs	r0, r4
            pstTaskCB->usTaskStatus &= ~(OS_TASK_STATUS_PEND);
   13074:	88a3      	ldrh	r3, [r4, #4]
            LOS_ListDelete(&pstTaskCB->stPendList);
   13076:	302c      	adds	r0, #44	; 0x2c
            pstTaskCB->usTaskStatus &= ~(OS_TASK_STATUS_PEND);
   13078:	4393      	bics	r3, r2
   1307a:	80a3      	strh	r3, [r4, #4]
            LOS_ListDelete(&pstTaskCB->stPendList);
   1307c:	f7ff feda 	bl	12e34 <LOS_ListDelete>
            pstTaskCB->pTaskSem = NULL;
   13080:	61a6      	str	r6, [r4, #24]
            pstTaskCB->pTaskMux = NULL;
   13082:	6266      	str	r6, [r4, #36]	; 0x24
        if (!((OS_TASK_STATUS_SUSPEND) & usTempStatus))
   13084:	07bb      	lsls	r3, r7, #30
   13086:	d40a      	bmi.n	1309e <osTaskScan+0x7a>
            pstTaskCB->usTaskStatus |= OS_TASK_STATUS_READY;
   13088:	2304      	movs	r3, #4
            osPriqueueEnqueue(&pstTaskCB->stPendList, pstTaskCB->usPriority);
   1308a:	0020      	movs	r0, r4
            pstTaskCB->usTaskStatus |= OS_TASK_STATUS_READY;
   1308c:	88a2      	ldrh	r2, [r4, #4]
            osPriqueueEnqueue(&pstTaskCB->stPendList, pstTaskCB->usPriority);
   1308e:	88e1      	ldrh	r1, [r4, #6]
            pstTaskCB->usTaskStatus |= OS_TASK_STATUS_READY;
   13090:	4313      	orrs	r3, r2
   13092:	80a3      	strh	r3, [r4, #4]
            osPriqueueEnqueue(&pstTaskCB->stPendList, pstTaskCB->usPriority);
   13094:	302c      	adds	r0, #44	; 0x2c
   13096:	f000 fe59 	bl	13d4c <osPriqueueEnqueue>
            bNeedSchedule = TRUE;
   1309a:	2301      	movs	r3, #1
   1309c:	9301      	str	r3, [sp, #4]
        pstTaskCB = LOS_DL_LIST_ENTRY(pstListObject->pstNext, LOS_TASK_CB, stTimerList); /*lint !e413*/
   1309e:	686c      	ldr	r4, [r5, #4]
   130a0:	3c34      	subs	r4, #52	; 0x34
   130a2:	e7cf      	b.n	13044 <osTaskScan+0x20>
        else if (OS_TASK_STATUS_EVENT & usTempStatus)
   130a4:	2380      	movs	r3, #128	; 0x80
   130a6:	00db      	lsls	r3, r3, #3
   130a8:	421f      	tst	r7, r3
   130aa:	d004      	beq.n	130b6 <osTaskScan+0x92>
            pstTaskCB->usTaskStatus &= ~(OS_TASK_STATUS_EVENT);
   130ac:	88a3      	ldrh	r3, [r4, #4]
   130ae:	4a09      	ldr	r2, [pc, #36]	; (130d4 <osTaskScan+0xb0>)
            pstTaskCB->usTaskStatus &= ~(OS_TASK_STATUS_PEND_QUEUE);
   130b0:	4013      	ands	r3, r2
            pstTaskCB->usTaskStatus &= ~(OS_TASK_STATUS_DELAY);
   130b2:	80a3      	strh	r3, [r4, #4]
   130b4:	e7e6      	b.n	13084 <osTaskScan+0x60>
        else if (OS_TASK_STATUS_PEND_QUEUE & usTempStatus)
   130b6:	04bb      	lsls	r3, r7, #18
   130b8:	d506      	bpl.n	130c8 <osTaskScan+0xa4>
            LOS_ListDelete(&pstTaskCB->stPendList);
   130ba:	0020      	movs	r0, r4
   130bc:	302c      	adds	r0, #44	; 0x2c
   130be:	f7ff feb9 	bl	12e34 <LOS_ListDelete>
            pstTaskCB->usTaskStatus &= ~(OS_TASK_STATUS_PEND_QUEUE);
   130c2:	88a3      	ldrh	r3, [r4, #4]
   130c4:	4a04      	ldr	r2, [pc, #16]	; (130d8 <osTaskScan+0xb4>)
   130c6:	e7f3      	b.n	130b0 <osTaskScan+0x8c>
            pstTaskCB->usTaskStatus &= ~(OS_TASK_STATUS_DELAY);
   130c8:	2220      	movs	r2, #32
   130ca:	88a3      	ldrh	r3, [r4, #4]
   130cc:	4393      	bics	r3, r2
   130ce:	e7f0      	b.n	130b2 <osTaskScan+0x8e>
   130d0:	01002e5c 	.word	0x01002e5c
   130d4:	fffffbff 	.word	0xfffffbff
   130d8:	ffffdfff 	.word	0xffffdfff

000130dc <osTaskInit>:
 Output      : None
 Return      : LOS_OK on success or error code on failure
 *****************************************************************************/
extern void *memset(void *s, int c, size_t n);
LITE_OS_SEC_TEXT_INIT UINT32 osTaskInit(VOID)
{
   130dc:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
    UINT32 uwSize;
    UINT32 uwIndex;
    LOS_DL_LIST *pstListObject;

    uwSize = (g_uwTskMaxNum + 1) * sizeof(LOS_TASK_CB);
   130de:	2758      	movs	r7, #88	; 0x58
   130e0:	4e2e      	ldr	r6, [pc, #184]	; (1319c <osTaskInit+0xc0>)
   130e2:	6833      	ldr	r3, [r6, #0]
   130e4:	1c5c      	adds	r4, r3, #1
   130e6:	437c      	muls	r4, r7
    g_pstTaskCBArray = (LOS_TASK_CB *)LOS_MemAlloc(m_aucSysMem0, uwSize);
   130e8:	4b2d      	ldr	r3, [pc, #180]	; (131a0 <osTaskInit+0xc4>)
   130ea:	0021      	movs	r1, r4
   130ec:	6818      	ldr	r0, [r3, #0]
   130ee:	f7ff fcf9 	bl	12ae4 <LOS_MemAlloc>
   130f2:	4d2c      	ldr	r5, [pc, #176]	; (131a4 <osTaskInit+0xc8>)
   130f4:	6028      	str	r0, [r5, #0]
    if (NULL == g_pstTaskCBArray)
   130f6:	2800      	cmp	r0, #0
   130f8:	d04e      	beq.n	13198 <osTaskInit+0xbc>
    {
        return LOS_ERRNO_TSK_NO_MEMORY;
    }

    (VOID)memset(g_pstTaskCBArray, 0, uwSize);
   130fa:	0022      	movs	r2, r4
   130fc:	2100      	movs	r1, #0
   130fe:	f7ed f8ef 	bl	2e0 <memset>
    pstList->pstNext = pstList;
   13102:	4b29      	ldr	r3, [pc, #164]	; (131a8 <osTaskInit+0xcc>)
    LOS_ListInit(&g_stTaskTimerList);
    LOS_ListInit(&g_stLosFreeTask);
    LOS_ListInit(&g_stTskRecyleList);
    for (uwIndex = 0; uwIndex <= LOSCFG_BASE_CORE_TSK_LIMIT; uwIndex++)
   13104:	2400      	movs	r4, #0
   13106:	605b      	str	r3, [r3, #4]
    pstList->pstPrev = pstList;
   13108:	601b      	str	r3, [r3, #0]
    pstList->pstNext = pstList;
   1310a:	4b28      	ldr	r3, [pc, #160]	; (131ac <osTaskInit+0xd0>)
   1310c:	4a28      	ldr	r2, [pc, #160]	; (131b0 <osTaskInit+0xd4>)
   1310e:	469c      	mov	ip, r3
    {
        g_pstTaskCBArray[uwIndex].usTaskStatus = OS_TASK_STATUS_UNUSED;
   13110:	9701      	str	r7, [sp, #4]
   13112:	605b      	str	r3, [r3, #4]
    pstList->pstPrev = pstList;
   13114:	601b      	str	r3, [r3, #0]
    pstList->pstNext = pstList;
   13116:	6052      	str	r2, [r2, #4]
    pstList->pstPrev = pstList;
   13118:	6012      	str	r2, [r2, #0]
   1311a:	3f57      	subs	r7, #87	; 0x57
   1311c:	9801      	ldr	r0, [sp, #4]
   1311e:	4663      	mov	r3, ip
   13120:	4360      	muls	r0, r4
   13122:	682a      	ldr	r2, [r5, #0]
   13124:	1810      	adds	r0, r2, r0
        g_pstTaskCBArray[uwIndex].uwTaskID = uwIndex;
        LOS_ListTailInsert(&g_stLosFreeTask, &g_pstTaskCBArray[uwIndex].stPendList);
   13126:	0001      	movs	r1, r0
   13128:	681a      	ldr	r2, [r3, #0]
        g_pstTaskCBArray[uwIndex].uwTaskID = uwIndex;
   1312a:	6104      	str	r4, [r0, #16]
        g_pstTaskCBArray[uwIndex].usTaskStatus = OS_TASK_STATUS_UNUSED;
   1312c:	8087      	strh	r7, [r0, #4]
    pstNode->pstNext = pstList->pstNext;
   1312e:	6853      	ldr	r3, [r2, #4]
    pstNode->pstPrev = pstList;
   13130:	62c2      	str	r2, [r0, #44]	; 0x2c
    pstNode->pstNext = pstList->pstNext;
   13132:	6303      	str	r3, [r0, #48]	; 0x30
    pstList->pstNext->pstPrev = pstNode;
   13134:	6850      	ldr	r0, [r2, #4]
        LOS_ListTailInsert(&g_stLosFreeTask, &g_pstTaskCBArray[uwIndex].stPendList);
   13136:	312c      	adds	r1, #44	; 0x2c
    for (uwIndex = 0; uwIndex <= LOSCFG_BASE_CORE_TSK_LIMIT; uwIndex++)
   13138:	3401      	adds	r4, #1
   1313a:	6001      	str	r1, [r0, #0]
    pstList->pstNext = pstNode;
   1313c:	6051      	str	r1, [r2, #4]
   1313e:	2c0b      	cmp	r4, #11
   13140:	d1ec      	bne.n	1311c <osTaskInit+0x40>
    }

    (VOID)memset((void *)(&g_stLosTask), 0, sizeof(g_stLosTask));
   13142:	4f1c      	ldr	r7, [pc, #112]	; (131b4 <osTaskInit+0xd8>)
   13144:	2100      	movs	r1, #0
   13146:	2208      	movs	r2, #8
   13148:	0038      	movs	r0, r7
   1314a:	f7ed f8c9 	bl	2e0 <memset>
    g_stLosTask.pstRunTask = &g_pstTaskCBArray[g_uwTskMaxNum];
   1314e:	9b01      	ldr	r3, [sp, #4]
   13150:	6832      	ldr	r2, [r6, #0]
   13152:	435a      	muls	r2, r3
   13154:	682b      	ldr	r3, [r5, #0]
   13156:	189b      	adds	r3, r3, r2
    g_stLosTask.pstRunTask->uwTaskID = uwIndex;
    g_stLosTask.pstRunTask->usTaskStatus = (OS_TASK_STATUS_UNUSED | OS_TASK_STATUS_RUNNING);
   13158:	4a17      	ldr	r2, [pc, #92]	; (131b8 <osTaskInit+0xdc>)
    g_stLosTask.pstRunTask->uwTaskID = uwIndex;
   1315a:	611c      	str	r4, [r3, #16]
    g_stLosTask.pstRunTask->usTaskStatus = (OS_TASK_STATUS_UNUSED | OS_TASK_STATUS_RUNNING);
   1315c:	605a      	str	r2, [r3, #4]
    g_stLosTask.pstRunTask = &g_pstTaskCBArray[g_uwTskMaxNum];
   1315e:	603b      	str	r3, [r7, #0]
    g_stLosTask.pstRunTask->usPriority = OS_TASK_PRIORITY_LOWEST + 1;
    osPriqueueInit();
   13160:	f000 fdda 	bl	13d18 <osPriqueueInit>
    uwSize = sizeof(LOS_DL_LIST) * OS_TSK_SORTLINK_LEN;
    pstListObject = (LOS_DL_LIST *)LOS_MemAlloc(m_aucSysMem0, uwSize);
   13164:	2180      	movs	r1, #128	; 0x80
   13166:	4b0e      	ldr	r3, [pc, #56]	; (131a0 <osTaskInit+0xc4>)
   13168:	0049      	lsls	r1, r1, #1
   1316a:	6818      	ldr	r0, [r3, #0]
   1316c:	f7ff fcba 	bl	12ae4 <LOS_MemAlloc>
   13170:	1e04      	subs	r4, r0, #0
    if (NULL == pstListObject)
   13172:	d011      	beq.n	13198 <osTaskInit+0xbc>
    {
        return LOS_ERRNO_TSK_NO_MEMORY;
    }

    (VOID)memset((void *)pstListObject, 0, uwSize);
   13174:	2280      	movs	r2, #128	; 0x80
   13176:	2100      	movs	r1, #0
   13178:	0052      	lsls	r2, r2, #1
   1317a:	f7ed f8b1 	bl	2e0 <memset>
    g_stTskSortLink.pstSortLink = pstListObject;
    g_stTskSortLink.usCursor = 0;
   1317e:	2200      	movs	r2, #0
    g_stTskSortLink.pstSortLink = pstListObject;
   13180:	4b0e      	ldr	r3, [pc, #56]	; (131bc <osTaskInit+0xe0>)
   13182:	601c      	str	r4, [r3, #0]
    g_stTskSortLink.usCursor = 0;
   13184:	809a      	strh	r2, [r3, #4]
   13186:	1c63      	adds	r3, r4, #1
   13188:	33ff      	adds	r3, #255	; 0xff
    pstList->pstNext = pstList;
   1318a:	6064      	str	r4, [r4, #4]
    pstList->pstPrev = pstList;
   1318c:	6024      	str	r4, [r4, #0]
    for (uwIndex = 0; uwIndex < OS_TSK_SORTLINK_LEN; uwIndex++, pstListObject++)
   1318e:	3408      	adds	r4, #8
   13190:	42a3      	cmp	r3, r4
   13192:	d1fa      	bne.n	1318a <osTaskInit+0xae>
    {
        LOS_ListInit(pstListObject);
    }

    return LOS_OK;
   13194:	2000      	movs	r0, #0
}
   13196:	bdfe      	pop	{r1, r2, r3, r4, r5, r6, r7, pc}
        return LOS_ERRNO_TSK_NO_MEMORY;
   13198:	4809      	ldr	r0, [pc, #36]	; (131c0 <osTaskInit+0xe4>)
   1319a:	e7fc      	b.n	13196 <osTaskInit+0xba>
   1319c:	01002e68 	.word	0x01002e68
   131a0:	01002e40 	.word	0x01002e40
   131a4:	01002e64 	.word	0x01002e64
   131a8:	01002e84 	.word	0x01002e84
   131ac:	01002e7c 	.word	0x01002e7c
   131b0:	01002e54 	.word	0x01002e54
   131b4:	01002e70 	.word	0x01002e70
   131b8:	00200011 	.word	0x00200011
   131bc:	01002e5c 	.word	0x01002e5c
   131c0:	03000200 	.word	0x03000200

000131c4 <osTaskSelfDelete>:
                 uvIntSave   --- interrupt flag
 Output      : None
 Return      : LOS_OK on success or error code on failure
 *****************************************************************************/
LITE_OS_SEC_TEXT_INIT UINT32 osTaskSelfDelete(UINT32 uwTaskID, UINTPTR uvIntSave)
{
   131c4:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
    LOS_TASK_CB *pstTaskCB;
    UINT16 usTempStatus;

    pstTaskCB = OS_TCB_FROM_TID(uwTaskID);
   131c6:	2458      	movs	r4, #88	; 0x58
   131c8:	4f2c      	ldr	r7, [pc, #176]	; (1327c <osTaskSelfDelete+0xb8>)
   131ca:	4344      	muls	r4, r0
   131cc:	683b      	ldr	r3, [r7, #0]
{
   131ce:	9001      	str	r0, [sp, #4]
    pstTaskCB = OS_TCB_FROM_TID(uwTaskID);
   131d0:	191c      	adds	r4, r3, r4
    usTempStatus = pstTaskCB->usTaskStatus;
    if (OS_TASK_STATUS_READY & usTempStatus)
   131d2:	2304      	movs	r3, #4
    usTempStatus = pstTaskCB->usTaskStatus;
   131d4:	88a6      	ldrh	r6, [r4, #4]
{
   131d6:	000d      	movs	r5, r1
    if (OS_TASK_STATUS_READY & usTempStatus)
   131d8:	421e      	tst	r6, r3
   131da:	d03b      	beq.n	13254 <osTaskSelfDelete+0x90>
    {
        osPriqueueDequeue(&pstTaskCB->stPendList);
   131dc:	0020      	movs	r0, r4
   131de:	302c      	adds	r0, #44	; 0x2c
   131e0:	f000 fdc2 	bl	13d68 <osPriqueueDequeue>
        pstTaskCB->usTaskStatus &= (~OS_TASK_STATUS_READY);
   131e4:	2204      	movs	r2, #4
   131e6:	88a3      	ldrh	r3, [r4, #4]
   131e8:	4393      	bics	r3, r2
   131ea:	80a3      	strh	r3, [r4, #4]
        {
            osTimerListDelete(pstTaskCB);
        }
    }

    pstTaskCB->usTaskStatus &= (~(OS_TASK_STATUS_SUSPEND));
   131ec:	2202      	movs	r2, #2
    pstTaskCB->usTaskStatus |= OS_TASK_STATUS_UNUSED;
   131ee:	2601      	movs	r6, #1
    pstTaskCB->usTaskStatus &= (~(OS_TASK_STATUS_SUSPEND));
   131f0:	88a3      	ldrh	r3, [r4, #4]
   131f2:	4393      	bics	r3, r2
    pstTaskCB->usTaskStatus |= OS_TASK_STATUS_UNUSED;
   131f4:	4333      	orrs	r3, r6
   131f6:	80a3      	strh	r3, [r4, #4]
    pstTaskCB->uwEvent.uwEventID = 0xFFFFFFFF;
   131f8:	2301      	movs	r3, #1
   131fa:	425b      	negs	r3, r3
   131fc:	6423      	str	r3, [r4, #64]	; 0x40
    pstTaskCB->uwEventMask = 0;
   131fe:	2300      	movs	r3, #0
   13200:	64e3      	str	r3, [r4, #76]	; 0x4c

    g_stLosTask.pstNewTask = LOS_DL_LIST_ENTRY(osPriqueueTop(), LOS_TASK_CB, stPendList); /*lint !e413*/
   13202:	f000 fdbb 	bl	13d7c <osPriqueueTop>
   13206:	491e      	ldr	r1, [pc, #120]	; (13280 <osTaskSelfDelete+0xbc>)
   13208:	382c      	subs	r0, #44	; 0x2c
   1320a:	6048      	str	r0, [r1, #4]
    if (OS_TASK_STATUS_RUNNING & pstTaskCB->usTaskStatus)
   1320c:	88a3      	ldrh	r3, [r4, #4]
   1320e:	06da      	lsls	r2, r3, #27
   13210:	d52e      	bpl.n	13270 <osTaskSelfDelete+0xac>
    {
        LOS_ListTailInsert(&g_stTskRecyleList, &pstTaskCB->stPendList);
   13212:	0022      	movs	r2, r4
   13214:	4b1b      	ldr	r3, [pc, #108]	; (13284 <osTaskSelfDelete+0xc0>)
   13216:	322c      	adds	r2, #44	; 0x2c
   13218:	681b      	ldr	r3, [r3, #0]
    pstNode->pstNext = pstList->pstNext;
   1321a:	6858      	ldr	r0, [r3, #4]
    pstNode->pstPrev = pstList;
   1321c:	62e3      	str	r3, [r4, #44]	; 0x2c
    pstNode->pstNext = pstList->pstNext;
   1321e:	6320      	str	r0, [r4, #48]	; 0x30
    pstList->pstNext->pstPrev = pstNode;
   13220:	6858      	ldr	r0, [r3, #4]
   13222:	6002      	str	r2, [r0, #0]
    pstList->pstNext = pstNode;
   13224:	605a      	str	r2, [r3, #4]
        g_stLosTask.pstRunTask = &g_pstTaskCBArray[g_uwTskMaxNum];
   13226:	2258      	movs	r2, #88	; 0x58
        g_stLosTask.pstRunTask->uwTaskID = uwTaskID;
        g_stLosTask.pstRunTask->usTaskStatus = pstTaskCB->usTaskStatus;
        g_stLosTask.pstRunTask->uwTopOfStack = pstTaskCB->uwTopOfStack;
        g_stLosTask.pstRunTask->pcTaskName = pstTaskCB->pcTaskName;
        pstTaskCB->usTaskStatus = OS_TASK_STATUS_UNUSED;
        (VOID)LOS_IntRestore(uvIntSave);
   13228:	0028      	movs	r0, r5
        g_stLosTask.pstRunTask = &g_pstTaskCBArray[g_uwTskMaxNum];
   1322a:	4b17      	ldr	r3, [pc, #92]	; (13288 <osTaskSelfDelete+0xc4>)
   1322c:	681b      	ldr	r3, [r3, #0]
   1322e:	435a      	muls	r2, r3
   13230:	683b      	ldr	r3, [r7, #0]
   13232:	189b      	adds	r3, r3, r2
        g_stLosTask.pstRunTask->uwTaskID = uwTaskID;
   13234:	9a01      	ldr	r2, [sp, #4]
        g_stLosTask.pstRunTask = &g_pstTaskCBArray[g_uwTskMaxNum];
   13236:	600b      	str	r3, [r1, #0]
        g_stLosTask.pstRunTask->uwTaskID = uwTaskID;
   13238:	611a      	str	r2, [r3, #16]
        g_stLosTask.pstRunTask->usTaskStatus = pstTaskCB->usTaskStatus;
   1323a:	88a2      	ldrh	r2, [r4, #4]
   1323c:	809a      	strh	r2, [r3, #4]
        g_stLosTask.pstRunTask->uwTopOfStack = pstTaskCB->uwTopOfStack;
   1323e:	68e2      	ldr	r2, [r4, #12]
   13240:	60da      	str	r2, [r3, #12]
        g_stLosTask.pstRunTask->pcTaskName = pstTaskCB->pcTaskName;
   13242:	6aa2      	ldr	r2, [r4, #40]	; 0x28
   13244:	629a      	str	r2, [r3, #40]	; 0x28
        pstTaskCB->usTaskStatus = OS_TASK_STATUS_UNUSED;
   13246:	80a6      	strh	r6, [r4, #4]
        osSchedule();
        return LOS_OK;
    }
    else if (OS_TASK_STATUS_UNUSED & pstTaskCB->usTaskStatus)
    {
        (VOID)LOS_IntRestore(uvIntSave);
   13248:	f7ec ff91 	bl	16e <LOS_IntRestore>
        osSchedule();
   1324c:	f000 fbf2 	bl	13a34 <osSchedule>
        return LOS_OK;
    }

    (VOID)LOS_IntRestore(uvIntSave);
    return LOS_OK;
}
   13250:	2000      	movs	r0, #0
   13252:	bdfe      	pop	{r1, r2, r3, r4, r5, r6, r7, pc}
    else if ((OS_TASK_STATUS_PEND | OS_TASK_STATUS_PEND_QUEUE) & usTempStatus)
   13254:	4b0d      	ldr	r3, [pc, #52]	; (1328c <osTaskSelfDelete+0xc8>)
   13256:	421e      	tst	r6, r3
   13258:	d0c8      	beq.n	131ec <osTaskSelfDelete+0x28>
        LOS_ListDelete(&pstTaskCB->stPendList);
   1325a:	0020      	movs	r0, r4
   1325c:	302c      	adds	r0, #44	; 0x2c
   1325e:	f7ff fde9 	bl	12e34 <LOS_ListDelete>
        if ((OS_TASK_STATUS_DELAY | OS_TASK_STATUS_TIMEOUT) & usTempStatus)
   13262:	2360      	movs	r3, #96	; 0x60
   13264:	421e      	tst	r6, r3
   13266:	d0c1      	beq.n	131ec <osTaskSelfDelete+0x28>
            osTimerListDelete(pstTaskCB);
   13268:	0020      	movs	r0, r4
   1326a:	f7ff fec1 	bl	12ff0 <osTimerListDelete>
   1326e:	e7bd      	b.n	131ec <osTaskSelfDelete+0x28>
        (VOID)LOS_IntRestore(uvIntSave);
   13270:	0028      	movs	r0, r5
    else if (OS_TASK_STATUS_UNUSED & pstTaskCB->usTaskStatus)
   13272:	4233      	tst	r3, r6
   13274:	d1e8      	bne.n	13248 <osTaskSelfDelete+0x84>
    (VOID)LOS_IntRestore(uvIntSave);
   13276:	f7ec ff7a 	bl	16e <LOS_IntRestore>
    return LOS_OK;
   1327a:	e7e9      	b.n	13250 <osTaskSelfDelete+0x8c>
   1327c:	01002e64 	.word	0x01002e64
   13280:	01002e70 	.word	0x01002e70
   13284:	01002e54 	.word	0x01002e54
   13288:	01002e68 	.word	0x01002e68
   1328c:	00002008 	.word	0x00002008

00013290 <osTaskEntry>:
 Input       : uwTaskID     --- The ID of the task to be run
 Output      : None
 Return      : None
 *****************************************************************************/
LITE_OS_SEC_TEXT_INIT VOID osTaskEntry(UINT32 uwTaskID)
{
   13290:	b510      	push	{r4, lr}
    LOS_TASK_CB *pstTaskCB;
    UINT32 uwIntSave;

    OS_TASK_ID_CHECK(uwTaskID);

    pstTaskCB = OS_TCB_FROM_TID(uwTaskID);
   13292:	2458      	movs	r4, #88	; 0x58
   13294:	4b0a      	ldr	r3, [pc, #40]	; (132c0 <osTaskEntry+0x30>)
   13296:	4360      	muls	r0, r4
   13298:	681c      	ldr	r4, [r3, #0]
   1329a:	1824      	adds	r4, r4, r0
    if (pstTaskCB->pThreadJoin)
   1329c:	69e2      	ldr	r2, [r4, #28]
   1329e:	6963      	ldr	r3, [r4, #20]
   132a0:	2a00      	cmp	r2, #0
   132a2:	d00b      	beq.n	132bc <osTaskEntry+0x2c>
    {
        pstTaskCB->pThreadJoinRetval =  pstTaskCB->pfnTaskEntry();
   132a4:	4798      	blx	r3
   132a6:	6220      	str	r0, [r4, #32]
    else
    {
        pstTaskCB->pfnTaskEntry(); /*lint !e534*/
    }

	uwIntSave = LOS_IntLock();
   132a8:	f7ec ff59 	bl	15e <LOS_IntLock>
	g_usLosTaskLock = 0;
   132ac:	2200      	movs	r2, #0
   132ae:	4b05      	ldr	r3, [pc, #20]	; (132c4 <osTaskEntry+0x34>)
	uwIntSave = LOS_IntLock();
   132b0:	0001      	movs	r1, r0
	(VOID)osTaskSelfDelete(pstTaskCB->uwTaskID, uwIntSave);
   132b2:	6920      	ldr	r0, [r4, #16]
	g_usLosTaskLock = 0;
   132b4:	801a      	strh	r2, [r3, #0]
	(VOID)osTaskSelfDelete(pstTaskCB->uwTaskID, uwIntSave);
   132b6:	f7ff ff85 	bl	131c4 <osTaskSelfDelete>
}
   132ba:	bd10      	pop	{r4, pc}
        pstTaskCB->pfnTaskEntry(); /*lint !e534*/
   132bc:	4798      	blx	r3
   132be:	e7f3      	b.n	132a8 <osTaskEntry+0x18>
   132c0:	01002e64 	.word	0x01002e64
   132c4:	01002e6c 	.word	0x01002e6c

000132c8 <LOS_TaskCreateOnly>:
 Input       : pstInitParam --- Task init parameters
 Output      : puwTaskID    --- Save task ID
 Return      : LOS_OK on success or error code on failure
 *****************************************************************************/
LITE_OS_SEC_TEXT_INIT UINT32 LOS_TaskCreateOnly(UINT32 *puwTaskID, TSK_INIT_PARAM_S *pstInitParam)
{
   132c8:	b5f0      	push	{r4, r5, r6, r7, lr}
   132ca:	b085      	sub	sp, #20
   132cc:	9003      	str	r0, [sp, #12]
   132ce:	000d      	movs	r5, r1
    VOID  *pTopStack;
    VOID  *pStackPtr;
    LOS_TASK_CB *pstTaskCB;
    UINT32 uwErrRet = OS_ERROR;

    if (NULL == puwTaskID)
   132d0:	2800      	cmp	r0, #0
   132d2:	d100      	bne.n	132d6 <LOS_TaskCreateOnly+0xe>
   132d4:	e095      	b.n	13402 <LOS_TaskCreateOnly+0x13a>
    {
        return LOS_ERRNO_TSK_ID_INVALID;
    }

    if (NULL == pstInitParam)
   132d6:	2900      	cmp	r1, #0
   132d8:	d100      	bne.n	132dc <LOS_TaskCreateOnly+0x14>
   132da:	e094      	b.n	13406 <LOS_TaskCreateOnly+0x13e>
    {
        return LOS_ERRNO_TSK_PTR_NULL;
    }

    if (NULL == pstInitParam->pcName)
   132dc:	68cb      	ldr	r3, [r1, #12]
   132de:	2b00      	cmp	r3, #0
   132e0:	d100      	bne.n	132e4 <LOS_TaskCreateOnly+0x1c>
   132e2:	e092      	b.n	1340a <LOS_TaskCreateOnly+0x142>
    {
        return LOS_ERRNO_TSK_NAME_EMPTY;
    }

    if (NULL == pstInitParam->pfnTaskEntry)
   132e4:	680b      	ldr	r3, [r1, #0]
   132e6:	2b00      	cmp	r3, #0
   132e8:	d100      	bne.n	132ec <LOS_TaskCreateOnly+0x24>
   132ea:	e090      	b.n	1340e <LOS_TaskCreateOnly+0x146>
    {
        return LOS_ERRNO_TSK_ENTRY_NULL;
    }

    if ((pstInitParam->usTaskPrio) > OS_TASK_PRIORITY_LOWEST)
   132ec:	888a      	ldrh	r2, [r1, #4]
   132ee:	2a1f      	cmp	r2, #31
   132f0:	d900      	bls.n	132f4 <LOS_TaskCreateOnly+0x2c>
   132f2:	e08e      	b.n	13412 <LOS_TaskCreateOnly+0x14a>
    {
        return LOS_ERRNO_TSK_PRIOR_ERROR;
    }

    if (((pstInitParam->usTaskPrio) == OS_TASK_PRIORITY_LOWEST)
   132f4:	d103      	bne.n	132fe <LOS_TaskCreateOnly+0x36>
        && (pstInitParam->pfnTaskEntry != OS_IDLE_TASK_ENTRY))
   132f6:	4a4a      	ldr	r2, [pc, #296]	; (13420 <LOS_TaskCreateOnly+0x158>)
   132f8:	4293      	cmp	r3, r2
   132fa:	d000      	beq.n	132fe <LOS_TaskCreateOnly+0x36>
   132fc:	e089      	b.n	13412 <LOS_TaskCreateOnly+0x14a>
    {
        return LOS_ERRNO_TSK_PRIOR_ERROR;
    }

    if (pstInitParam->uwStackSize > OS_SYS_MEM_SIZE)
   132fe:	4a49      	ldr	r2, [pc, #292]	; (13424 <LOS_TaskCreateOnly+0x15c>)
   13300:	68ab      	ldr	r3, [r5, #8]
   13302:	6812      	ldr	r2, [r2, #0]
   13304:	9201      	str	r2, [sp, #4]
   13306:	4293      	cmp	r3, r2
   13308:	d900      	bls.n	1330c <LOS_TaskCreateOnly+0x44>
   1330a:	e084      	b.n	13416 <LOS_TaskCreateOnly+0x14e>
    {
        return LOS_ERRNO_TSK_STKSZ_TOO_LARGE;
    }

    if (0 == pstInitParam->uwStackSize)
   1330c:	2b00      	cmp	r3, #0
   1330e:	d102      	bne.n	13316 <LOS_TaskCreateOnly+0x4e>
    {
        pstInitParam->uwStackSize = LOSCFG_BASE_CORE_TSK_DEFAULT_STACK_SIZE;
   13310:	3301      	adds	r3, #1
   13312:	33ff      	adds	r3, #255	; 0xff
   13314:	60ab      	str	r3, [r5, #8]
    }
    pstInitParam->uwStackSize = ALIGN(pstInitParam->uwStackSize , 8);
   13316:	2108      	movs	r1, #8
   13318:	68a8      	ldr	r0, [r5, #8]
   1331a:	f000 fb7f 	bl	13a1c <LOS_Align>

    if (pstInitParam->uwStackSize < LOS_TASK_MIN_STACK_SIZE)
   1331e:	2104      	movs	r1, #4
    pstInitParam->uwStackSize = ALIGN(pstInitParam->uwStackSize , 8);
   13320:	0004      	movs	r4, r0
   13322:	60a8      	str	r0, [r5, #8]
    if (pstInitParam->uwStackSize < LOS_TASK_MIN_STACK_SIZE)
   13324:	2080      	movs	r0, #128	; 0x80
   13326:	f000 fb79 	bl	13a1c <LOS_Align>
   1332a:	4284      	cmp	r4, r0
   1332c:	d200      	bcs.n	13330 <LOS_TaskCreateOnly+0x68>
   1332e:	e074      	b.n	1341a <LOS_TaskCreateOnly+0x152>
    {
        return LOS_ERRNO_TSK_STKSZ_TOO_SMALL;
    }

    uvIntSave = LOS_IntLock();
   13330:	f7ec ff15 	bl	15e <LOS_IntLock>
   13334:	9001      	str	r0, [sp, #4]
 *@see
 *@since Huawei LiteOS V100R001C00
 */
LITE_OS_SEC_ALW_INLINE INLINE BOOL LOS_ListEmpty(LOS_DL_LIST *pstList)
{
    return (BOOL)(pstList->pstNext == pstList);
   13336:	4b3c      	ldr	r3, [pc, #240]	; (13428 <LOS_TaskCreateOnly+0x160>)
   13338:	4e3c      	ldr	r6, [pc, #240]	; (1342c <LOS_TaskCreateOnly+0x164>)
   1333a:	685f      	ldr	r7, [r3, #4]
    while (!LOS_ListEmpty(&g_stTskRecyleList))
   1333c:	429f      	cmp	r7, r3
   1333e:	d123      	bne.n	13388 <LOS_TaskCreateOnly+0xc0>
   13340:	6877      	ldr	r7, [r6, #4]
        LOS_ListAdd(&g_stLosFreeTask, &pstTaskCB->stPendList);
        (VOID)LOS_MemFree(m_aucSysMem0, (VOID *)pstTaskCB->uwTopOfStack);
        pstTaskCB->uwTopOfStack = (UINT32)NULL;
    }

    if (LOS_ListEmpty(&g_stLosFreeTask))
   13342:	42b7      	cmp	r7, r6
   13344:	d05b      	beq.n	133fe <LOS_TaskCreateOnly+0x136>
    }

    pstTaskCB = OS_TCB_FROM_PENDLIST(LOS_DL_LIST_FIRST(&g_stLosFreeTask)); /*lint !e413*/
    LOS_ListDelete(LOS_DL_LIST_FIRST(&g_stLosFreeTask));
    (VOID)LOS_IntRestore(uvIntSave);
    uwTaskID = pstTaskCB->uwTaskID;
   13346:	003c      	movs	r4, r7
    LOS_ListDelete(LOS_DL_LIST_FIRST(&g_stLosFreeTask));
   13348:	0038      	movs	r0, r7
   1334a:	f7ff fd73 	bl	12e34 <LOS_ListDelete>
    uwTaskID = pstTaskCB->uwTaskID;
   1334e:	3c2c      	subs	r4, #44	; 0x2c
    (VOID)LOS_IntRestore(uvIntSave);
   13350:	9801      	ldr	r0, [sp, #4]
   13352:	f7ec ff0c 	bl	16e <LOS_IntRestore>
    uwTaskID = pstTaskCB->uwTaskID;
   13356:	6923      	ldr	r3, [r4, #16]

    pTopStack = (void *)LOS_MemAllocAlign(m_aucSysMem0, pstInitParam->uwStackSize, 8);
   13358:	2208      	movs	r2, #8
    uwTaskID = pstTaskCB->uwTaskID;
   1335a:	9302      	str	r3, [sp, #8]
    pTopStack = (void *)LOS_MemAllocAlign(m_aucSysMem0, pstInitParam->uwStackSize, 8);
   1335c:	4b34      	ldr	r3, [pc, #208]	; (13430 <LOS_TaskCreateOnly+0x168>)
   1335e:	68a9      	ldr	r1, [r5, #8]
   13360:	6818      	ldr	r0, [r3, #0]
   13362:	f7ff fbd5 	bl	12b10 <LOS_MemAllocAlign>
   13366:	9001      	str	r0, [sp, #4]

    if (NULL == pTopStack)
   13368:	2800      	cmp	r0, #0
   1336a:	d120      	bne.n	133ae <LOS_TaskCreateOnly+0xe6>
    {
        uvIntSave = LOS_IntLock();
   1336c:	f7ec fef7 	bl	15e <LOS_IntLock>
    pstNode->pstNext = pstList->pstNext;
   13370:	6873      	ldr	r3, [r6, #4]
    pstNode->pstPrev = pstList;
   13372:	603e      	str	r6, [r7, #0]
    pstNode->pstNext = pstList->pstNext;
   13374:	607b      	str	r3, [r7, #4]
    pstList->pstNext->pstPrev = pstNode;
   13376:	6873      	ldr	r3, [r6, #4]
        LOS_ListAdd(&g_stLosFreeTask, &pstTaskCB->stPendList);
        uwErrRet = LOS_ERRNO_TSK_NO_MEMORY;
   13378:	4d2e      	ldr	r5, [pc, #184]	; (13434 <LOS_TaskCreateOnly+0x16c>)
   1337a:	601f      	str	r7, [r3, #0]
        uvIntSave = LOS_IntLock();
   1337c:	9001      	str	r0, [sp, #4]
    pstList->pstNext = pstNode;
   1337e:	6077      	str	r7, [r6, #4]
    pstTaskCB->puwMsg = NULL;
    *puwTaskID = uwTaskID;
    return LOS_OK;

LOS_ERREND:
    (VOID)LOS_IntRestore(uvIntSave);
   13380:	9801      	ldr	r0, [sp, #4]
   13382:	f7ec fef4 	bl	16e <LOS_IntRestore>
   13386:	e037      	b.n	133f8 <LOS_TaskCreateOnly+0x130>
        LOS_ListAdd(&g_stLosFreeTask, &pstTaskCB->stPendList);
   13388:	003c      	movs	r4, r7
        LOS_ListDelete(LOS_DL_LIST_FIRST(&g_stTskRecyleList));
   1338a:	0038      	movs	r0, r7
   1338c:	f7ff fd52 	bl	12e34 <LOS_ListDelete>
    pstNode->pstNext = pstList->pstNext;
   13390:	6873      	ldr	r3, [r6, #4]
    pstNode->pstPrev = pstList;
   13392:	603e      	str	r6, [r7, #0]
    pstNode->pstNext = pstList->pstNext;
   13394:	607b      	str	r3, [r7, #4]
    pstList->pstNext->pstPrev = pstNode;
   13396:	6873      	ldr	r3, [r6, #4]
        LOS_ListAdd(&g_stLosFreeTask, &pstTaskCB->stPendList);
   13398:	3c2c      	subs	r4, #44	; 0x2c
   1339a:	601f      	str	r7, [r3, #0]
        (VOID)LOS_MemFree(m_aucSysMem0, (VOID *)pstTaskCB->uwTopOfStack);
   1339c:	4b24      	ldr	r3, [pc, #144]	; (13430 <LOS_TaskCreateOnly+0x168>)
    pstList->pstNext = pstNode;
   1339e:	6077      	str	r7, [r6, #4]
   133a0:	6818      	ldr	r0, [r3, #0]
   133a2:	68e1      	ldr	r1, [r4, #12]
   133a4:	f7ff fbb8 	bl	12b18 <LOS_MemFree>
        pstTaskCB->uwTopOfStack = (UINT32)NULL;
   133a8:	2300      	movs	r3, #0
   133aa:	60e3      	str	r3, [r4, #12]
   133ac:	e7c3      	b.n	13336 <LOS_TaskCreateOnly+0x6e>
    pStackPtr = osTskStackInit(uwTaskID, pstInitParam->uwStackSize, pTopStack);
   133ae:	68a9      	ldr	r1, [r5, #8]
   133b0:	9a01      	ldr	r2, [sp, #4]
   133b2:	9802      	ldr	r0, [sp, #8]
   133b4:	f000 fb60 	bl	13a78 <osTskStackInit>
    pstTaskCB->uwTopOfStack = (UINT32)pTopStack;
   133b8:	9b01      	ldr	r3, [sp, #4]
    pstTaskCB->pStackPointer = pStackPtr;
   133ba:	6020      	str	r0, [r4, #0]
    pstTaskCB->uwTopOfStack = (UINT32)pTopStack;
   133bc:	60e3      	str	r3, [r4, #12]
    pstTaskCB->uwStackSize = pstInitParam->uwStackSize;
   133be:	68ab      	ldr	r3, [r5, #8]
    pstTaskCB->usTaskStatus = OS_TASK_STATUS_SUSPEND;
   133c0:	2102      	movs	r1, #2
    pstTaskCB->uwStackSize = pstInitParam->uwStackSize;
   133c2:	60a3      	str	r3, [r4, #8]
    pstTaskCB->pTaskSem = NULL;
   133c4:	2300      	movs	r3, #0
    pstTaskCB->usTaskStatus = OS_TASK_STATUS_SUSPEND;
   133c6:	80a1      	strh	r1, [r4, #4]
    pstTaskCB->pTaskSem = NULL;
   133c8:	61a3      	str	r3, [r4, #24]
    pstTaskCB->pThreadJoin = NULL;
   133ca:	61e3      	str	r3, [r4, #28]
    pstTaskCB->pTaskMux = NULL;
   133cc:	6263      	str	r3, [r4, #36]	; 0x24
    pstTaskCB->usTaskStatus |= (pstInitParam->uwResved ? LOS_TASK_STATUS_DETACHED : 0);/*set the task is detached or joinable*/
   133ce:	692a      	ldr	r2, [r5, #16]
   133d0:	1e50      	subs	r0, r2, #1
   133d2:	4182      	sbcs	r2, r0
   133d4:	01d2      	lsls	r2, r2, #7
   133d6:	430a      	orrs	r2, r1
   133d8:	80a2      	strh	r2, [r4, #4]
    pstTaskCB->usPriority = pstInitParam->usTaskPrio;
   133da:	88aa      	ldrh	r2, [r5, #4]
    *puwTaskID = uwTaskID;
   133dc:	9902      	ldr	r1, [sp, #8]
    pstTaskCB->usPriority = pstInitParam->usTaskPrio;
   133de:	80e2      	strh	r2, [r4, #6]
    pstTaskCB->pfnTaskEntry = pstInitParam->pfnTaskEntry;
   133e0:	682a      	ldr	r2, [r5, #0]
    pstTaskCB->uwEventMask = 0;
   133e2:	64e3      	str	r3, [r4, #76]	; 0x4c
    pstTaskCB->pfnTaskEntry = pstInitParam->pfnTaskEntry;
   133e4:	6162      	str	r2, [r4, #20]
    pstTaskCB->uwEvent.uwEventID = 0xFFFFFFFF;
   133e6:	2201      	movs	r2, #1
   133e8:	4252      	negs	r2, r2
   133ea:	6422      	str	r2, [r4, #64]	; 0x40
    pstTaskCB->pcTaskName   = pstInitParam->pcName;
   133ec:	68ea      	ldr	r2, [r5, #12]
    return LOS_OK;
   133ee:	001d      	movs	r5, r3
    pstTaskCB->pcTaskName   = pstInitParam->pcName;
   133f0:	62a2      	str	r2, [r4, #40]	; 0x28
    *puwTaskID = uwTaskID;
   133f2:	9a03      	ldr	r2, [sp, #12]
    pstTaskCB->puwMsg = NULL;
   133f4:	6563      	str	r3, [r4, #84]	; 0x54
    *puwTaskID = uwTaskID;
   133f6:	6011      	str	r1, [r2, #0]
    return uwErrRet;
}
   133f8:	0028      	movs	r0, r5
   133fa:	b005      	add	sp, #20
   133fc:	bdf0      	pop	{r4, r5, r6, r7, pc}
        uwErrRet = LOS_ERRNO_TSK_TCB_UNAVAILABLE;
   133fe:	4d0e      	ldr	r5, [pc, #56]	; (13438 <LOS_TaskCreateOnly+0x170>)
   13400:	e7be      	b.n	13380 <LOS_TaskCreateOnly+0xb8>
        return LOS_ERRNO_TSK_ID_INVALID;
   13402:	4d0e      	ldr	r5, [pc, #56]	; (1343c <LOS_TaskCreateOnly+0x174>)
   13404:	e7f8      	b.n	133f8 <LOS_TaskCreateOnly+0x130>
        return LOS_ERRNO_TSK_PTR_NULL;
   13406:	4d0e      	ldr	r5, [pc, #56]	; (13440 <LOS_TaskCreateOnly+0x178>)
   13408:	e7f6      	b.n	133f8 <LOS_TaskCreateOnly+0x130>
        return LOS_ERRNO_TSK_NAME_EMPTY;
   1340a:	4d0e      	ldr	r5, [pc, #56]	; (13444 <LOS_TaskCreateOnly+0x17c>)
   1340c:	e7f4      	b.n	133f8 <LOS_TaskCreateOnly+0x130>
        return LOS_ERRNO_TSK_ENTRY_NULL;
   1340e:	4d0e      	ldr	r5, [pc, #56]	; (13448 <LOS_TaskCreateOnly+0x180>)
   13410:	e7f2      	b.n	133f8 <LOS_TaskCreateOnly+0x130>
        return LOS_ERRNO_TSK_PRIOR_ERROR;
   13412:	4d0e      	ldr	r5, [pc, #56]	; (1344c <LOS_TaskCreateOnly+0x184>)
   13414:	e7f0      	b.n	133f8 <LOS_TaskCreateOnly+0x130>
        return LOS_ERRNO_TSK_STKSZ_TOO_LARGE;
   13416:	4d0e      	ldr	r5, [pc, #56]	; (13450 <LOS_TaskCreateOnly+0x188>)
   13418:	e7ee      	b.n	133f8 <LOS_TaskCreateOnly+0x130>
        return LOS_ERRNO_TSK_STKSZ_TOO_SMALL;
   1341a:	4d0e      	ldr	r5, [pc, #56]	; (13454 <LOS_TaskCreateOnly+0x18c>)
   1341c:	e7ec      	b.n	133f8 <LOS_TaskCreateOnly+0x130>
   1341e:	46c0      	nop			; (mov r8, r8)
   13420:	00012e91 	.word	0x00012e91
   13424:	0002558c 	.word	0x0002558c
   13428:	01002e54 	.word	0x01002e54
   1342c:	01002e7c 	.word	0x01002e7c
   13430:	01002e40 	.word	0x01002e40
   13434:	03000200 	.word	0x03000200
   13438:	02000211 	.word	0x02000211
   1343c:	02000207 	.word	0x02000207
   13440:	02000201 	.word	0x02000201
   13444:	02000205 	.word	0x02000205
   13448:	02000204 	.word	0x02000204
   1344c:	02000203 	.word	0x02000203
   13450:	02000220 	.word	0x02000220
   13454:	02000206 	.word	0x02000206

00013458 <LOS_TaskCreate>:
 Input       : pstInitParam --- Task init parameters
 Output      : puwTaskID    --- Save task ID
 Return      : LOS_OK on success or error code on failure
 *****************************************************************************/
LITE_OS_SEC_TEXT_INIT UINT32 LOS_TaskCreate(UINT32 *puwTaskID, TSK_INIT_PARAM_S *pstInitParam)
{
   13458:	b570      	push	{r4, r5, r6, lr}
   1345a:	0004      	movs	r4, r0
    UINT32 uwRet = LOS_OK;
    UINTPTR uvIntSave;
    LOS_TASK_CB *pstTaskCB;

    uwRet = LOS_TaskCreateOnly(puwTaskID, pstInitParam);
   1345c:	f7ff ff34 	bl	132c8 <LOS_TaskCreateOnly>
   13460:	1e05      	subs	r5, r0, #0
    if (LOS_OK != uwRet)
   13462:	d129      	bne.n	134b8 <LOS_TaskCreate+0x60>
    {
        return uwRet;
    }
    pstTaskCB = OS_TCB_FROM_TID(*puwTaskID);
   13464:	2058      	movs	r0, #88	; 0x58
   13466:	6824      	ldr	r4, [r4, #0]
   13468:	4b16      	ldr	r3, [pc, #88]	; (134c4 <LOS_TaskCreate+0x6c>)
   1346a:	4360      	muls	r0, r4
   1346c:	681c      	ldr	r4, [r3, #0]
   1346e:	1824      	adds	r4, r4, r0

    uvIntSave = LOS_IntLock();
   13470:	f7ec fe75 	bl	15e <LOS_IntLock>
    pstTaskCB->usTaskStatus &= (~OS_TASK_STATUS_SUSPEND);
   13474:	2202      	movs	r2, #2
   13476:	88a3      	ldrh	r3, [r4, #4]
    uvIntSave = LOS_IntLock();
   13478:	0006      	movs	r6, r0
    pstTaskCB->usTaskStatus &= (~OS_TASK_STATUS_SUSPEND);
   1347a:	4393      	bics	r3, r2
   1347c:	001a      	movs	r2, r3
    pstTaskCB->usTaskStatus |= OS_TASK_STATUS_READY;
   1347e:	2304      	movs	r3, #4

    osPriqueueEnqueue(&pstTaskCB->stPendList, pstTaskCB->usPriority);
   13480:	0020      	movs	r0, r4
    pstTaskCB->usTaskStatus |= OS_TASK_STATUS_READY;
   13482:	4313      	orrs	r3, r2
   13484:	80a3      	strh	r3, [r4, #4]
    osPriqueueEnqueue(&pstTaskCB->stPendList, pstTaskCB->usPriority);
   13486:	88e1      	ldrh	r1, [r4, #6]
   13488:	302c      	adds	r0, #44	; 0x2c
   1348a:	f000 fc5f 	bl	13d4c <osPriqueueEnqueue>
    g_stLosTask.pstNewTask = LOS_DL_LIST_ENTRY(osPriqueueTop(), LOS_TASK_CB, stPendList); /*lint !e413*/
   1348e:	f000 fc75 	bl	13d7c <osPriqueueTop>

    if ((g_bTaskScheduled) && (g_usLosTaskLock == 0))
   13492:	4a0d      	ldr	r2, [pc, #52]	; (134c8 <LOS_TaskCreate+0x70>)
    g_stLosTask.pstNewTask = LOS_DL_LIST_ENTRY(osPriqueueTop(), LOS_TASK_CB, stPendList); /*lint !e413*/
   13494:	4b0d      	ldr	r3, [pc, #52]	; (134cc <LOS_TaskCreate+0x74>)
    if ((g_bTaskScheduled) && (g_usLosTaskLock == 0))
   13496:	6812      	ldr	r2, [r2, #0]
    g_stLosTask.pstNewTask = LOS_DL_LIST_ENTRY(osPriqueueTop(), LOS_TASK_CB, stPendList); /*lint !e413*/
   13498:	382c      	subs	r0, #44	; 0x2c
   1349a:	6058      	str	r0, [r3, #4]
    if ((g_bTaskScheduled) && (g_usLosTaskLock == 0))
   1349c:	2a00      	cmp	r2, #0
   1349e:	d00d      	beq.n	134bc <LOS_TaskCreate+0x64>
   134a0:	4a0b      	ldr	r2, [pc, #44]	; (134d0 <LOS_TaskCreate+0x78>)
   134a2:	8812      	ldrh	r2, [r2, #0]
   134a4:	2a00      	cmp	r2, #0
   134a6:	d109      	bne.n	134bc <LOS_TaskCreate+0x64>
    {
        if (g_stLosTask.pstRunTask != g_stLosTask.pstNewTask)
   134a8:	681b      	ldr	r3, [r3, #0]
   134aa:	4298      	cmp	r0, r3
   134ac:	d006      	beq.n	134bc <LOS_TaskCreate+0x64>
        {
            if (LOS_CHECK_SCHEDULE)
            {
                (VOID)LOS_IntRestore(uvIntSave);
   134ae:	0030      	movs	r0, r6
   134b0:	f7ec fe5d 	bl	16e <LOS_IntRestore>
                osSchedule();
   134b4:	f000 fabe 	bl	13a34 <osSchedule>
        }
    }

    (VOID)LOS_IntRestore(uvIntSave);
    return LOS_OK;
}
   134b8:	0028      	movs	r0, r5
   134ba:	bd70      	pop	{r4, r5, r6, pc}
    (VOID)LOS_IntRestore(uvIntSave);
   134bc:	0030      	movs	r0, r6
   134be:	f7ec fe56 	bl	16e <LOS_IntRestore>
   134c2:	e7f9      	b.n	134b8 <LOS_TaskCreate+0x60>
   134c4:	01002e64 	.word	0x01002e64
   134c8:	01002e78 	.word	0x01002e78
   134cc:	01002e70 	.word	0x01002e70
   134d0:	01002e6c 	.word	0x01002e6c

000134d4 <osIdleTaskCreate>:
{
   134d4:	b510      	push	{r4, lr}
   134d6:	b086      	sub	sp, #24
    (VOID)memset((void *)(&stTaskInitParam), 0, sizeof(TSK_INIT_PARAM_S));
   134d8:	ac01      	add	r4, sp, #4
   134da:	2214      	movs	r2, #20
   134dc:	2100      	movs	r1, #0
   134de:	0020      	movs	r0, r4
   134e0:	f7ec fefe 	bl	2e0 <memset>
    stTaskInitParam.pfnTaskEntry = (TSK_ENTRY_FUNC)osIdleTask;
   134e4:	4b07      	ldr	r3, [pc, #28]	; (13504 <osIdleTaskCreate+0x30>)
    uwRet = LOS_TaskCreate(&g_uwIdleTaskID, &stTaskInitParam);
   134e6:	0021      	movs	r1, r4
    stTaskInitParam.pfnTaskEntry = (TSK_ENTRY_FUNC)osIdleTask;
   134e8:	9301      	str	r3, [sp, #4]
    stTaskInitParam.uwStackSize = LOSCFG_BASE_CORE_TSK_IDLE_STACK_SIZE;
   134ea:	23c0      	movs	r3, #192	; 0xc0
   134ec:	005b      	lsls	r3, r3, #1
   134ee:	60a3      	str	r3, [r4, #8]
    stTaskInitParam.pcName = "IdleCore000";
   134f0:	4b05      	ldr	r3, [pc, #20]	; (13508 <osIdleTaskCreate+0x34>)
    uwRet = LOS_TaskCreate(&g_uwIdleTaskID, &stTaskInitParam);
   134f2:	4806      	ldr	r0, [pc, #24]	; (1350c <osIdleTaskCreate+0x38>)
    stTaskInitParam.pcName = "IdleCore000";
   134f4:	60e3      	str	r3, [r4, #12]
    stTaskInitParam.usTaskPrio = OS_TASK_PRIORITY_LOWEST;
   134f6:	231f      	movs	r3, #31
   134f8:	80a3      	strh	r3, [r4, #4]
    uwRet = LOS_TaskCreate(&g_uwIdleTaskID, &stTaskInitParam);
   134fa:	f7ff ffad 	bl	13458 <LOS_TaskCreate>
}
   134fe:	b006      	add	sp, #24
   13500:	bd10      	pop	{r4, pc}
   13502:	46c0      	nop			; (mov r8, r8)
   13504:	00012e91 	.word	0x00012e91
   13508:	000254cb 	.word	0x000254cb
   1350c:	01002e4c 	.word	0x01002e4c

00013510 <osTaskWait>:
               uwTimeOut -- Expiry time
 Output      : none
 Return      : LOS_OK on success or LOS_NOK on failure
**************************************************************************/
VOID osTaskWait(LOS_DL_LIST *pstList, UINT32 uwTaskStatus, UINT32 uwTimeOut)
{
   13510:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
    LOS_TASK_CB *pstRunTsk;
    LOS_DL_LIST *pstPendObj;

    pstRunTsk = g_stLosTask.pstRunTask;
   13512:	4b11      	ldr	r3, [pc, #68]	; (13558 <osTaskWait+0x48>)
{
   13514:	0007      	movs	r7, r0
    pstRunTsk = g_stLosTask.pstRunTask;
   13516:	681c      	ldr	r4, [r3, #0]
{
   13518:	0016      	movs	r6, r2
    osPriqueueDequeue(&pstRunTsk->stPendList);
   1351a:	0025      	movs	r5, r4
   1351c:	352c      	adds	r5, #44	; 0x2c
   1351e:	0028      	movs	r0, r5
{
   13520:	9101      	str	r1, [sp, #4]
    osPriqueueDequeue(&pstRunTsk->stPendList);
   13522:	f000 fc21 	bl	13d68 <osPriqueueDequeue>
    pstRunTsk->usTaskStatus &= (~OS_TASK_STATUS_READY);
   13526:	2204      	movs	r2, #4
   13528:	88a3      	ldrh	r3, [r4, #4]
   1352a:	4393      	bics	r3, r2
    pstPendObj = &pstRunTsk->stPendList;
    pstRunTsk->usTaskStatus |= uwTaskStatus;
   1352c:	9a01      	ldr	r2, [sp, #4]
   1352e:	4313      	orrs	r3, r2
   13530:	80a3      	strh	r3, [r4, #4]
   13532:	683b      	ldr	r3, [r7, #0]
    pstNode->pstNext = pstList->pstNext;
   13534:	685a      	ldr	r2, [r3, #4]
    pstNode->pstPrev = pstList;
   13536:	62e3      	str	r3, [r4, #44]	; 0x2c
    pstNode->pstNext = pstList->pstNext;
   13538:	6322      	str	r2, [r4, #48]	; 0x30
    pstList->pstNext->pstPrev = pstNode;
   1353a:	685a      	ldr	r2, [r3, #4]
   1353c:	6015      	str	r5, [r2, #0]
    pstList->pstNext = pstNode;
   1353e:	605d      	str	r5, [r3, #4]
    LOS_ListTailInsert(pstList,pstPendObj);
    if (uwTimeOut != LOS_WAIT_FOREVER)
   13540:	1c73      	adds	r3, r6, #1
   13542:	d007      	beq.n	13554 <osTaskWait+0x44>
    {
        pstRunTsk->usTaskStatus |= OS_TASK_STATUS_TIMEOUT;
   13544:	2340      	movs	r3, #64	; 0x40
   13546:	88a2      	ldrh	r2, [r4, #4]
        osTaskAdd2TimerList((LOS_TASK_CB *)pstRunTsk, uwTimeOut);
   13548:	0031      	movs	r1, r6
        pstRunTsk->usTaskStatus |= OS_TASK_STATUS_TIMEOUT;
   1354a:	4313      	orrs	r3, r2
   1354c:	80a3      	strh	r3, [r4, #4]
        osTaskAdd2TimerList((LOS_TASK_CB *)pstRunTsk, uwTimeOut);
   1354e:	0020      	movs	r0, r4
   13550:	f7ff fd0e 	bl	12f70 <osTaskAdd2TimerList>
    }
}
   13554:	bdf7      	pop	{r0, r1, r2, r4, r5, r6, r7, pc}
   13556:	46c0      	nop			; (mov r8, r8)
   13558:	01002e70 	.word	0x01002e70

0001355c <osTaskWake>:
 Input       : pstResumedTask --> resumed task
 Output      : pstResumedTask
 Return      : none
**************************************************************************/
VOID osTaskWake(LOS_TASK_CB *pstResumedTask, UINT32 uwTaskStatus)
{
   1355c:	b570      	push	{r4, r5, r6, lr}
    LOS_ListDelete(&pstResumedTask->stPendList);
   1355e:	0005      	movs	r5, r0
{
   13560:	0004      	movs	r4, r0
   13562:	000e      	movs	r6, r1
    LOS_ListDelete(&pstResumedTask->stPendList);
   13564:	352c      	adds	r5, #44	; 0x2c
   13566:	0028      	movs	r0, r5
   13568:	f7ff fc64 	bl	12e34 <LOS_ListDelete>
    pstResumedTask->usTaskStatus &= (~uwTaskStatus);
   1356c:	88a3      	ldrh	r3, [r4, #4]
   1356e:	43b3      	bics	r3, r6
    if (pstResumedTask->usTaskStatus & OS_TASK_STATUS_TIMEOUT)
   13570:	2640      	movs	r6, #64	; 0x40
    pstResumedTask->usTaskStatus &= (~uwTaskStatus);
   13572:	80a3      	strh	r3, [r4, #4]
    if (pstResumedTask->usTaskStatus & OS_TASK_STATUS_TIMEOUT)
   13574:	4233      	tst	r3, r6
   13576:	d005      	beq.n	13584 <osTaskWake+0x28>
    {
        osTimerListDelete(pstResumedTask);
   13578:	0020      	movs	r0, r4
   1357a:	f7ff fd39 	bl	12ff0 <osTimerListDelete>
        pstResumedTask->usTaskStatus &= (~OS_TASK_STATUS_TIMEOUT);
   1357e:	88a3      	ldrh	r3, [r4, #4]
   13580:	43b3      	bics	r3, r6
   13582:	80a3      	strh	r3, [r4, #4]
    }
    if (!(pstResumedTask->usTaskStatus & OS_TASK_STATUS_SUSPEND))
   13584:	88a2      	ldrh	r2, [r4, #4]
   13586:	0793      	lsls	r3, r2, #30
   13588:	d406      	bmi.n	13598 <osTaskWake+0x3c>
    {
        pstResumedTask->usTaskStatus |= OS_TASK_STATUS_READY;
   1358a:	2304      	movs	r3, #4
   1358c:	4313      	orrs	r3, r2
   1358e:	80a3      	strh	r3, [r4, #4]
        osPriqueueEnqueue(&pstResumedTask->stPendList, pstResumedTask->usPriority);
   13590:	88e1      	ldrh	r1, [r4, #6]
   13592:	0028      	movs	r0, r5
   13594:	f000 fbda 	bl	13d4c <osPriqueueEnqueue>
    }
}
   13598:	bd70      	pop	{r4, r5, r6, pc}
	...

0001359c <LOS_TaskYield>:
               uwNextTask
 Output      : None
 Return      : LOS_OK on success or error code on failure
 *****************************************************************************/
LITE_OS_SEC_TEXT_MINOR UINT32 LOS_TaskYield(VOID)
{
   1359c:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    UINT32 uwTskCount = 0;
    UINTPTR uvIntSave;

    if(g_stLosTask.pstRunTask->uwTaskID >= g_uwTskMaxNum)
   1359e:	4f17      	ldr	r7, [pc, #92]	; (135fc <LOS_TaskYield+0x60>)
   135a0:	4a17      	ldr	r2, [pc, #92]	; (13600 <LOS_TaskYield+0x64>)
   135a2:	683b      	ldr	r3, [r7, #0]
   135a4:	6812      	ldr	r2, [r2, #0]
   135a6:	6919      	ldr	r1, [r3, #16]
   135a8:	4291      	cmp	r1, r2
   135aa:	d225      	bcs.n	135f8 <LOS_TaskYield+0x5c>
    {
        return LOS_ERRNO_TSK_ID_INVALID;
    }
    if(!(g_stLosTask.pstRunTask->usTaskStatus & OS_TASK_STATUS_READY))
   135ac:	2604      	movs	r6, #4
   135ae:	889b      	ldrh	r3, [r3, #4]
    {
        return LOS_OK;
   135b0:	2400      	movs	r4, #0
    if(!(g_stLosTask.pstRunTask->usTaskStatus & OS_TASK_STATUS_READY))
   135b2:	4233      	tst	r3, r6
   135b4:	d019      	beq.n	135ea <LOS_TaskYield+0x4e>
    }
    uvIntSave = LOS_IntLock();
   135b6:	f7ec fdd2 	bl	15e <LOS_IntLock>
    uwTskCount = osPriqueueSize(g_stLosTask.pstRunTask->usPriority);
   135ba:	683b      	ldr	r3, [r7, #0]
    uvIntSave = LOS_IntLock();
   135bc:	0005      	movs	r5, r0
    uwTskCount = osPriqueueSize(g_stLosTask.pstRunTask->usPriority);
   135be:	88d8      	ldrh	r0, [r3, #6]
   135c0:	f000 fbec 	bl	13d9c <osPriqueueSize>
    if (uwTskCount > 1)
   135c4:	2801      	cmp	r0, #1
   135c6:	d912      	bls.n	135ee <LOS_TaskYield+0x52>
    {

        LOS_ListDelete(&(g_stLosTask.pstRunTask->stPendList));
   135c8:	6838      	ldr	r0, [r7, #0]
   135ca:	302c      	adds	r0, #44	; 0x2c
   135cc:	f7ff fc32 	bl	12e34 <LOS_ListDelete>
        g_stLosTask.pstRunTask->usTaskStatus |= OS_TASK_STATUS_READY;
   135d0:	6838      	ldr	r0, [r7, #0]
   135d2:	8883      	ldrh	r3, [r0, #4]
        osPriqueueEnqueue(&(g_stLosTask.pstRunTask->stPendList), g_stLosTask.pstRunTask->usPriority);
   135d4:	88c1      	ldrh	r1, [r0, #6]
        g_stLosTask.pstRunTask->usTaskStatus |= OS_TASK_STATUS_READY;
   135d6:	431e      	orrs	r6, r3
   135d8:	8086      	strh	r6, [r0, #4]
        osPriqueueEnqueue(&(g_stLosTask.pstRunTask->stPendList), g_stLosTask.pstRunTask->usPriority);
   135da:	302c      	adds	r0, #44	; 0x2c
   135dc:	f000 fbb6 	bl	13d4c <osPriqueueEnqueue>
    else
    {
        (VOID)LOS_IntRestore(uvIntSave);
        return LOS_ERRNO_TSK_YIELD_NOT_ENOUGH_TASK;
    }
    (VOID)LOS_IntRestore(uvIntSave);
   135e0:	0028      	movs	r0, r5
   135e2:	f7ec fdc4 	bl	16e <LOS_IntRestore>
    LOS_Schedule();
   135e6:	f000 fa29 	bl	13a3c <LOS_Schedule>
    return LOS_OK;
}
   135ea:	0020      	movs	r0, r4
   135ec:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
        (VOID)LOS_IntRestore(uvIntSave);
   135ee:	0028      	movs	r0, r5
   135f0:	f7ec fdbd 	bl	16e <LOS_IntRestore>
        return LOS_ERRNO_TSK_YIELD_NOT_ENOUGH_TASK;
   135f4:	4c03      	ldr	r4, [pc, #12]	; (13604 <LOS_TaskYield+0x68>)
   135f6:	e7f8      	b.n	135ea <LOS_TaskYield+0x4e>
        return LOS_ERRNO_TSK_ID_INVALID;
   135f8:	4c03      	ldr	r4, [pc, #12]	; (13608 <LOS_TaskYield+0x6c>)
   135fa:	e7f6      	b.n	135ea <LOS_TaskYield+0x4e>
   135fc:	01002e70 	.word	0x01002e70
   13600:	01002e68 	.word	0x01002e68
   13604:	02000210 	.word	0x02000210
   13608:	02000207 	.word	0x02000207

0001360c <LOS_TaskDelay>:
{
   1360c:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
   1360e:	0007      	movs	r7, r0
    if (OS_INT_ACTIVE)
   13610:	f004 fe18 	bl	18244 <non_os_is_this_interrupt_context>
   13614:	2800      	cmp	r0, #0
   13616:	d124      	bne.n	13662 <LOS_TaskDelay+0x56>
    if (g_usLosTaskLock != 0)
   13618:	4b14      	ldr	r3, [pc, #80]	; (1366c <LOS_TaskDelay+0x60>)
   1361a:	881c      	ldrh	r4, [r3, #0]
   1361c:	2c00      	cmp	r4, #0
   1361e:	d122      	bne.n	13666 <LOS_TaskDelay+0x5a>
    if (uwTick == 0)
   13620:	2f00      	cmp	r7, #0
   13622:	d102      	bne.n	1362a <LOS_TaskDelay+0x1e>
        return LOS_TaskYield();
   13624:	f7ff ffba 	bl	1359c <LOS_TaskYield>
}
   13628:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
        uvIntSave = LOS_IntLock();
   1362a:	f7ec fd98 	bl	15e <LOS_IntLock>
        osPriqueueDequeue(&(g_stLosTask.pstRunTask->stPendList));
   1362e:	4e10      	ldr	r6, [pc, #64]	; (13670 <LOS_TaskDelay+0x64>)
        uvIntSave = LOS_IntLock();
   13630:	0005      	movs	r5, r0
        osPriqueueDequeue(&(g_stLosTask.pstRunTask->stPendList));
   13632:	6830      	ldr	r0, [r6, #0]
   13634:	302c      	adds	r0, #44	; 0x2c
   13636:	f000 fb97 	bl	13d68 <osPriqueueDequeue>
        g_stLosTask.pstRunTask->usTaskStatus &= (~OS_TASK_STATUS_READY);
   1363a:	2204      	movs	r2, #4
   1363c:	6830      	ldr	r0, [r6, #0]
        osTaskAdd2TimerList((LOS_TASK_CB *)g_stLosTask.pstRunTask, uwTick);
   1363e:	0039      	movs	r1, r7
        g_stLosTask.pstRunTask->usTaskStatus &= (~OS_TASK_STATUS_READY);
   13640:	8883      	ldrh	r3, [r0, #4]
   13642:	4393      	bics	r3, r2
   13644:	8083      	strh	r3, [r0, #4]
        osTaskAdd2TimerList((LOS_TASK_CB *)g_stLosTask.pstRunTask, uwTick);
   13646:	f7ff fc93 	bl	12f70 <osTaskAdd2TimerList>
        g_stLosTask.pstRunTask->usTaskStatus |= OS_TASK_STATUS_DELAY;
   1364a:	2320      	movs	r3, #32
   1364c:	6832      	ldr	r2, [r6, #0]
        (VOID)LOS_IntRestore(uvIntSave);
   1364e:	0028      	movs	r0, r5
        g_stLosTask.pstRunTask->usTaskStatus |= OS_TASK_STATUS_DELAY;
   13650:	8891      	ldrh	r1, [r2, #4]
   13652:	430b      	orrs	r3, r1
   13654:	8093      	strh	r3, [r2, #4]
        (VOID)LOS_IntRestore(uvIntSave);
   13656:	f7ec fd8a 	bl	16e <LOS_IntRestore>
        LOS_Schedule();
   1365a:	f000 f9ef 	bl	13a3c <LOS_Schedule>
    return LOS_OK;
   1365e:	0020      	movs	r0, r4
   13660:	e7e2      	b.n	13628 <LOS_TaskDelay+0x1c>
        return LOS_ERRNO_TSK_DELAY_IN_INT;
   13662:	4804      	ldr	r0, [pc, #16]	; (13674 <LOS_TaskDelay+0x68>)
   13664:	e7e0      	b.n	13628 <LOS_TaskDelay+0x1c>
        return LOS_ERRNO_TSK_DELAY_IN_LOCK;
   13666:	4804      	ldr	r0, [pc, #16]	; (13678 <LOS_TaskDelay+0x6c>)
   13668:	e7de      	b.n	13628 <LOS_TaskDelay+0x1c>
   1366a:	46c0      	nop			; (mov r8, r8)
   1366c:	01002e6c 	.word	0x01002e6c
   13670:	01002e70 	.word	0x01002e70
   13674:	0300020d 	.word	0x0300020d
   13678:	0200020e 	.word	0x0200020e

0001367c <LOS_TaskLock>:
 Input       : None
 Output      : None
 Return      : None
 *****************************************************************************/
LITE_OS_SEC_TEXT_MINOR VOID LOS_TaskLock(VOID)
{
   1367c:	b510      	push	{r4, lr}
    UINTPTR uvIntSave;

    uvIntSave = LOS_IntLock();
   1367e:	f7ec fd6e 	bl	15e <LOS_IntLock>
    g_usLosTaskLock++;
   13682:	4a03      	ldr	r2, [pc, #12]	; (13690 <LOS_TaskLock+0x14>)
   13684:	8813      	ldrh	r3, [r2, #0]
   13686:	3301      	adds	r3, #1
   13688:	8013      	strh	r3, [r2, #0]
    (VOID)LOS_IntRestore(uvIntSave);
   1368a:	f7ec fd70 	bl	16e <LOS_IntRestore>
}
   1368e:	bd10      	pop	{r4, pc}
   13690:	01002e6c 	.word	0x01002e6c

00013694 <LOS_TaskUnlock>:
 Input       : None
 Output      : None
 Return      : None
 *****************************************************************************/
LITE_OS_SEC_TEXT_MINOR VOID LOS_TaskUnlock(VOID)
{
   13694:	b510      	push	{r4, lr}
    UINTPTR uvIntSave;

    uvIntSave = LOS_IntLock();
   13696:	f7ec fd62 	bl	15e <LOS_IntLock>
    if (g_usLosTaskLock > 0)
   1369a:	4a08      	ldr	r2, [pc, #32]	; (136bc <LOS_TaskUnlock+0x28>)
   1369c:	8813      	ldrh	r3, [r2, #0]
   1369e:	2b00      	cmp	r3, #0
   136a0:	d009      	beq.n	136b6 <LOS_TaskUnlock+0x22>
    {
        g_usLosTaskLock--;
   136a2:	3b01      	subs	r3, #1
   136a4:	b29b      	uxth	r3, r3
   136a6:	8013      	strh	r3, [r2, #0]
        if (0 == g_usLosTaskLock)
   136a8:	2b00      	cmp	r3, #0
   136aa:	d104      	bne.n	136b6 <LOS_TaskUnlock+0x22>
        {
            (VOID)LOS_IntRestore(uvIntSave);
   136ac:	f7ec fd5f 	bl	16e <LOS_IntRestore>
            LOS_Schedule();
   136b0:	f000 f9c4 	bl	13a3c <LOS_Schedule>
            return;
        }
    }

    (VOID)LOS_IntRestore(uvIntSave);
}
   136b4:	bd10      	pop	{r4, pc}
    (VOID)LOS_IntRestore(uvIntSave);
   136b6:	f7ec fd5a 	bl	16e <LOS_IntRestore>
   136ba:	e7fb      	b.n	136b4 <LOS_TaskUnlock+0x20>
   136bc:	01002e6c 	.word	0x01002e6c

000136c0 <osHeapInit>:
               UITN32 sz --- size of the heap memory pool
 Output      : None
 Return      : 1:success 0:error
*****************************************************************************/
bool osHeapInit(struct LOS_HEAP_MANAGER *pHeapMan, void *p, UINT32 sz)
{
   136c0:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
   136c2:	0006      	movs	r6, r0
   136c4:	000c      	movs	r4, r1
   136c6:	0017      	movs	r7, r2
    struct LOS_HEAP_NODE* node;

    if (!pHeapMan || !p || (sz < sizeof(struct LOS_HEAP_NODE))
        || (sz > RAM_HEAP_MAX_SIZE))
        return false;
   136c8:	1e05      	subs	r5, r0, #0
    if (!pHeapMan || !p || (sz < sizeof(struct LOS_HEAP_NODE))
   136ca:	d020      	beq.n	1370e <osHeapInit+0x4e>
        return false;
   136cc:	1e0d      	subs	r5, r1, #0
    if (!pHeapMan || !p || (sz < sizeof(struct LOS_HEAP_NODE))
   136ce:	d01e      	beq.n	1370e <osHeapInit+0x4e>
   136d0:	0013      	movs	r3, r2
   136d2:	3b08      	subs	r3, #8
   136d4:	9301      	str	r3, [sp, #4]
   136d6:	9a01      	ldr	r2, [sp, #4]
   136d8:	4b0e      	ldr	r3, [pc, #56]	; (13714 <osHeapInit+0x54>)
        return false;
   136da:	2500      	movs	r5, #0
    if (!pHeapMan || !p || (sz < sizeof(struct LOS_HEAP_NODE))
   136dc:	429a      	cmp	r2, r3
   136de:	d816      	bhi.n	1370e <osHeapInit+0x4e>

    memset(p, 0, sz);
   136e0:	003a      	movs	r2, r7
   136e2:	0029      	movs	r1, r5
   136e4:	0020      	movs	r0, r4
   136e6:	f7ec fdfb 	bl	2e0 <memset>

    node = pHeapMan->pstHead = (struct LOS_HEAP_NODE*)p;

    pHeapMan->pstTail = node;

    node->uwUsed = 0;
   136ea:	227f      	movs	r2, #127	; 0x7f
    pHeapMan->pPool = p;
   136ec:	60b4      	str	r4, [r6, #8]
    pHeapMan->uwSize = sz;
   136ee:	60f7      	str	r7, [r6, #12]
    node = pHeapMan->pstHead = (struct LOS_HEAP_NODE*)p;
   136f0:	6034      	str	r4, [r6, #0]
    pHeapMan->pstTail = node;
   136f2:	6074      	str	r4, [r6, #4]
    node->uwUsed = 0;
   136f4:	79e3      	ldrb	r3, [r4, #7]
    node->pstPrev = NULL;
   136f6:	6025      	str	r5, [r4, #0]
    node->uwUsed = 0;
   136f8:	4013      	ands	r3, r2
   136fa:	71e3      	strb	r3, [r4, #7]
    node->uwSize = sz - sizeof(struct LOS_HEAP_NODE);
   136fc:	9b01      	ldr	r3, [sp, #4]

    return true;
   136fe:	3501      	adds	r5, #1
    node->uwSize = sz - sizeof(struct LOS_HEAP_NODE);
   13700:	005a      	lsls	r2, r3, #1
   13702:	6863      	ldr	r3, [r4, #4]
   13704:	0852      	lsrs	r2, r2, #1
   13706:	0fdb      	lsrs	r3, r3, #31
   13708:	07db      	lsls	r3, r3, #31
   1370a:	4313      	orrs	r3, r2
   1370c:	6063      	str	r3, [r4, #4]
}
   1370e:	0028      	movs	r0, r5
   13710:	bdfe      	pop	{r1, r2, r3, r4, r5, r6, r7, pc}
   13712:	46c0      	nop			; (mov r8, r8)
   13714:	7ffffff7 	.word	0x7ffffff7

00013718 <osHeapAlloc>:
               UITN32 sz --- size of the heap memory pool
 Output      : None
 Return      : NULL:error    other value:the address of the memory we alloced
*****************************************************************************/
void* osHeapAlloc(struct LOS_HEAP_MANAGER *pHeapMan, UINT32 sz)
{
   13718:	b570      	push	{r4, r5, r6, lr}
   1371a:	000d      	movs	r5, r1
   1371c:	0004      	movs	r4, r0
    struct LOS_HEAP_NODE *node, *t, *best = NULL;
    void* ret = NULL;
    UINT32 uvIntSave;

    uvIntSave = LOS_IntLock();
   1371e:	f7ec fd1e 	bl	15e <LOS_IntLock>

    sz = (sz + 7) & (~7);
   13722:	2307      	movs	r3, #7
   13724:	1de9      	adds	r1, r5, #7
   13726:	4399      	bics	r1, r3
    struct LOS_HEAP_NODE *node, *t, *best = NULL;
   13728:	2300      	movs	r3, #0
    node = pHeapMan->pstTail;
   1372a:	6862      	ldr	r2, [r4, #4]

    while (node) {
   1372c:	2a00      	cmp	r2, #0
   1372e:	d13d      	bne.n	137ac <osHeapAlloc+0x94>
    void* ret = NULL;
   13730:	1e1d      	subs	r5, r3, #0
                goto SIZE_MATCH;
        }
        node = node->pstPrev;
    }

    if (!best) {/*alloc failed*/
   13732:	d031      	beq.n	13798 <osHeapAlloc+0x80>
        //PRINT_ERR("%s: there's not enough whole to alloc %x Bytes!\n", __func__, sz);
        goto out;
    }

    if (best->uwSize - sz > sizeof(struct LOS_HEAP_NODE)) {
   13734:	685a      	ldr	r2, [r3, #4]
   13736:	0052      	lsls	r2, r2, #1
   13738:	0852      	lsrs	r2, r2, #1
   1373a:	1a52      	subs	r2, r2, r1
   1373c:	2a08      	cmp	r2, #8
   1373e:	d924      	bls.n	1378a <osHeapAlloc+0x72>
        /* hole divide into 2 */
        node = (struct LOS_HEAP_NODE*)(best->ucData + sz);

        node->uwUsed = 0;
   13740:	267f      	movs	r6, #127	; 0x7f
        node = (struct LOS_HEAP_NODE*)(best->ucData + sz);
   13742:	3508      	adds	r5, #8
   13744:	186d      	adds	r5, r5, r1
        node->uwUsed = 0;
   13746:	79ea      	ldrb	r2, [r5, #7]
   13748:	4032      	ands	r2, r6
   1374a:	71ea      	strb	r2, [r5, #7]
        node->uwSize = best->uwSize - sz - sizeof(struct LOS_HEAP_NODE);
   1374c:	685a      	ldr	r2, [r3, #4]
   1374e:	686e      	ldr	r6, [r5, #4]
   13750:	0052      	lsls	r2, r2, #1
   13752:	0852      	lsrs	r2, r2, #1
   13754:	1a52      	subs	r2, r2, r1
   13756:	3a08      	subs	r2, #8
   13758:	0052      	lsls	r2, r2, #1
   1375a:	0ff6      	lsrs	r6, r6, #31
   1375c:	0852      	lsrs	r2, r2, #1
   1375e:	07f6      	lsls	r6, r6, #31
   13760:	4316      	orrs	r6, r2
   13762:	606e      	str	r6, [r5, #4]
        node->pstPrev = best;
   13764:	602b      	str	r3, [r5, #0]

        if (best != pHeapMan->pstTail)
   13766:	6866      	ldr	r6, [r4, #4]
   13768:	429e      	cmp	r6, r3
   1376a:	d033      	beq.n	137d4 <osHeapAlloc+0xbc>
    return (pHeapMan->pstTail == node) ? NULL : (struct LOS_HEAP_NODE*)(node->ucData + node->uwSize);
   1376c:	42ae      	cmp	r6, r5
   1376e:	d005      	beq.n	1377c <osHeapAlloc+0x64>
   13770:	002c      	movs	r4, r5
   13772:	3408      	adds	r4, #8
   13774:	18a2      	adds	r2, r4, r2
        {
            if ((t = osHeapPrvGetNext(pHeapMan, node)))
   13776:	2a00      	cmp	r2, #0
   13778:	d000      	beq.n	1377c <osHeapAlloc+0x64>
                t->pstPrev = node;
   1377a:	6015      	str	r5, [r2, #0]
        }
        else
            pHeapMan->pstTail = node;

        best->uwSize = sz;
   1377c:	685a      	ldr	r2, [r3, #4]
   1377e:	0049      	lsls	r1, r1, #1
   13780:	0fd2      	lsrs	r2, r2, #31
   13782:	0849      	lsrs	r1, r1, #1
   13784:	07d2      	lsls	r2, r2, #31
   13786:	4311      	orrs	r1, r2
   13788:	6059      	str	r1, [r3, #4]
    }

SIZE_MATCH:
    best->uwUsed = 1;
   1378a:	2280      	movs	r2, #128	; 0x80
   1378c:	79d9      	ldrb	r1, [r3, #7]
   1378e:	4252      	negs	r2, r2
   13790:	430a      	orrs	r2, r1
   13792:	71da      	strb	r2, [r3, #7]
    ret = best->ucData;
   13794:	3308      	adds	r3, #8
   13796:	001d      	movs	r5, r3

out:
    LOS_IntRestore(uvIntSave);
   13798:	f7ec fce9 	bl	16e <LOS_IntRestore>
    if (NULL != ret)
   1379c:	2d00      	cmp	r5, #0
   1379e:	d003      	beq.n	137a8 <osHeapAlloc+0x90>
    {
        g_uwAllocCount++;
   137a0:	4a0d      	ldr	r2, [pc, #52]	; (137d8 <osHeapAlloc+0xc0>)
   137a2:	6813      	ldr	r3, [r2, #0]
   137a4:	3301      	adds	r3, #1
   137a6:	6013      	str	r3, [r2, #0]
    }
    return ret;
}
   137a8:	0028      	movs	r0, r5
   137aa:	bd70      	pop	{r4, r5, r6, pc}
        if (!node->uwUsed && node->uwSize >= sz && (!best || best->uwSize > node->uwSize)) {
   137ac:	79d5      	ldrb	r5, [r2, #7]
   137ae:	2d7f      	cmp	r5, #127	; 0x7f
   137b0:	d80e      	bhi.n	137d0 <osHeapAlloc+0xb8>
   137b2:	6855      	ldr	r5, [r2, #4]
   137b4:	006d      	lsls	r5, r5, #1
   137b6:	086d      	lsrs	r5, r5, #1
   137b8:	428d      	cmp	r5, r1
   137ba:	d309      	bcc.n	137d0 <osHeapAlloc+0xb8>
   137bc:	2b00      	cmp	r3, #0
   137be:	d004      	beq.n	137ca <osHeapAlloc+0xb2>
   137c0:	685e      	ldr	r6, [r3, #4]
   137c2:	0076      	lsls	r6, r6, #1
   137c4:	0876      	lsrs	r6, r6, #1
   137c6:	42b5      	cmp	r5, r6
   137c8:	d202      	bcs.n	137d0 <osHeapAlloc+0xb8>
SIZE_MATCH:
   137ca:	0013      	movs	r3, r2
            if (best->uwSize == sz)
   137cc:	428d      	cmp	r5, r1
   137ce:	d0dc      	beq.n	1378a <osHeapAlloc+0x72>
        node = node->pstPrev;
   137d0:	6812      	ldr	r2, [r2, #0]
   137d2:	e7ab      	b.n	1372c <osHeapAlloc+0x14>
            pHeapMan->pstTail = node;
   137d4:	6065      	str	r5, [r4, #4]
   137d6:	e7d1      	b.n	1377c <osHeapAlloc+0x64>
   137d8:	01002500 	.word	0x01002500

000137dc <osHeapFree>:
               void* ptr: the pointer of heap memory we want to free
 Output      : None
 Return      : 1:success 0:error
*****************************************************************************/
bool osHeapFree(struct LOS_HEAP_MANAGER *pHeapMan, void* ptr)
{
   137dc:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    struct LOS_HEAP_NODE *node, *t;
    UINT32 uvIntSave;
    bool ret = true;

    if ((UINT32)ptr < (UINT32)pHeapMan->pstHead
   137de:	6803      	ldr	r3, [r0, #0]
{
   137e0:	0005      	movs	r5, r0
   137e2:	000c      	movs	r4, r1
    if ((UINT32)ptr < (UINT32)pHeapMan->pstHead
   137e4:	428b      	cmp	r3, r1
   137e6:	d902      	bls.n	137ee <osHeapFree+0x12>
        || (UINT32)ptr > ((UINT32)pHeapMan->pstTail + sizeof(struct LOS_HEAP_NODE))) {
        //PRINT_ERR("%s: %x out of range!\n", __func__, (UINT32)ptr);
        return false;
   137e8:	2400      	movs	r4, #0
    if (true == ret)
    {
        g_uwFreeCount++;
    }
    return ret;
}
   137ea:	0020      	movs	r0, r4
   137ec:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
        || (UINT32)ptr > ((UINT32)pHeapMan->pstTail + sizeof(struct LOS_HEAP_NODE))) {
   137ee:	6843      	ldr	r3, [r0, #4]
   137f0:	3308      	adds	r3, #8
   137f2:	4299      	cmp	r1, r3
   137f4:	d8f8      	bhi.n	137e8 <osHeapFree+0xc>
    uvIntSave = LOS_IntLock();
   137f6:	f7ec fcb2 	bl	15e <LOS_IntLock>
    node = ((struct LOS_HEAP_NODE*)ptr) - 1;
   137fa:	0021      	movs	r1, r4
    if (!((UINT32)node == (UINT32)pHeapMan->pstHead)
   137fc:	682b      	ldr	r3, [r5, #0]
    node = ((struct LOS_HEAP_NODE*)ptr) - 1;
   137fe:	3908      	subs	r1, #8
    if (!((UINT32)node == (UINT32)pHeapMan->pstHead)
   13800:	428b      	cmp	r3, r1
   13802:	d014      	beq.n	1382e <osHeapFree+0x52>
        && ((UINT32)node->pstPrev < (UINT32)pHeapMan->pstHead
   13804:	680a      	ldr	r2, [r1, #0]
        ret = false;
   13806:	2400      	movs	r4, #0
        && ((UINT32)node->pstPrev < (UINT32)pHeapMan->pstHead
   13808:	4293      	cmp	r3, r2
   1380a:	d83b      	bhi.n	13884 <osHeapFree+0xa8>
            || (UINT32)node->pstPrev > ((UINT32)pHeapMan->pstTail + sizeof(struct LOS_HEAP_NODE))
   1380c:	686e      	ldr	r6, [r5, #4]
   1380e:	0033      	movs	r3, r6
   13810:	3308      	adds	r3, #8
   13812:	429a      	cmp	r2, r3
   13814:	d836      	bhi.n	13884 <osHeapFree+0xa8>
    return (pHeapMan->pstTail == node) ? NULL : (struct LOS_HEAP_NODE*)(node->ucData + node->uwSize);
   13816:	0023      	movs	r3, r4
   13818:	42b2      	cmp	r2, r6
   1381a:	d005      	beq.n	13828 <osHeapFree+0x4c>
   1381c:	0014      	movs	r4, r2
   1381e:	6853      	ldr	r3, [r2, #4]
   13820:	3408      	adds	r4, #8
   13822:	005b      	lsls	r3, r3, #1
   13824:	085b      	lsrs	r3, r3, #1
   13826:	18e3      	adds	r3, r4, r3
        ret = false;
   13828:	2400      	movs	r4, #0
            || ((UINT32)osHeapPrvGetNext(pHeapMan, node->pstPrev) != (UINT32)node)
   1382a:	428b      	cmp	r3, r1
   1382c:	d12a      	bne.n	13884 <osHeapFree+0xa8>
    node->uwUsed = 0;
   1382e:	227f      	movs	r2, #127	; 0x7f
   13830:	79cb      	ldrb	r3, [r1, #7]
   13832:	4013      	ands	r3, r2
   13834:	71cb      	strb	r3, [r1, #7]
    while (node->pstPrev && !node->pstPrev->uwUsed)
   13836:	680b      	ldr	r3, [r1, #0]
   13838:	2b00      	cmp	r3, #0
   1383a:	d003      	beq.n	13844 <osHeapFree+0x68>
   1383c:	2207      	movs	r2, #7
   1383e:	569a      	ldrsb	r2, [r3, r2]
   13840:	2a00      	cmp	r2, #0
   13842:	da02      	bge.n	1384a <osHeapFree+0x6e>
    return (pHeapMan->pstTail == node) ? NULL : (struct LOS_HEAP_NODE*)(node->ucData + node->uwSize);
   13844:	000e      	movs	r6, r1
   13846:	3608      	adds	r6, #8
   13848:	e00e      	b.n	13868 <osHeapFree+0x8c>
   1384a:	0019      	movs	r1, r3
   1384c:	e7f3      	b.n	13836 <osHeapFree+0x5a>
        node->uwSize += sizeof(struct LOS_HEAP_NODE) + t->uwSize;
   1384e:	6867      	ldr	r7, [r4, #4]
   13850:	3208      	adds	r2, #8
   13852:	18ba      	adds	r2, r7, r2
   13854:	0052      	lsls	r2, r2, #1
   13856:	0fdb      	lsrs	r3, r3, #31
   13858:	07db      	lsls	r3, r3, #31
   1385a:	0852      	lsrs	r2, r2, #1
   1385c:	431a      	orrs	r2, r3
   1385e:	604a      	str	r2, [r1, #4]
        if (pHeapMan->pstTail == t)
   13860:	686b      	ldr	r3, [r5, #4]
   13862:	42a3      	cmp	r3, r4
   13864:	d100      	bne.n	13868 <osHeapFree+0x8c>
            pHeapMan->pstTail = node;
   13866:	6069      	str	r1, [r5, #4]
    return (pHeapMan->pstTail == node) ? NULL : (struct LOS_HEAP_NODE*)(node->ucData + node->uwSize);
   13868:	686b      	ldr	r3, [r5, #4]
   1386a:	4299      	cmp	r1, r3
   1386c:	d009      	beq.n	13882 <osHeapFree+0xa6>
   1386e:	684b      	ldr	r3, [r1, #4]
   13870:	005a      	lsls	r2, r3, #1
   13872:	0852      	lsrs	r2, r2, #1
   13874:	18b4      	adds	r4, r6, r2
    while ((t = osHeapPrvGetNext(pHeapMan, node)) && !t->uwUsed) {
   13876:	2c00      	cmp	r4, #0
   13878:	d003      	beq.n	13882 <osHeapFree+0xa6>
   1387a:	79e7      	ldrb	r7, [r4, #7]
   1387c:	2f7f      	cmp	r7, #127	; 0x7f
   1387e:	d9e6      	bls.n	1384e <osHeapFree+0x72>
        t->pstPrev = node;
   13880:	6021      	str	r1, [r4, #0]
    bool ret = true;
   13882:	2401      	movs	r4, #1
    LOS_IntRestore(uvIntSave);
   13884:	f7ec fc73 	bl	16e <LOS_IntRestore>
    if (true == ret)
   13888:	2c00      	cmp	r4, #0
   1388a:	d0ad      	beq.n	137e8 <osHeapFree+0xc>
        g_uwFreeCount++;
   1388c:	4a02      	ldr	r2, [pc, #8]	; (13898 <osHeapFree+0xbc>)
   1388e:	6813      	ldr	r3, [r2, #0]
   13890:	3301      	adds	r3, #1
   13892:	6013      	str	r3, [r2, #0]
   13894:	e7a9      	b.n	137ea <osHeapFree+0xe>
   13896:	46c0      	nop			; (mov r8, r8)
   13898:	01002504 	.word	0x01002504

0001389c <osHeapStatisticsGet>:

UINT32 osHeapStatisticsGet(UINT32 *total, UINT32 *used, UINT32 *AllocCount, UINT32 *FreeCount)
{
   1389c:	b5f0      	push	{r4, r5, r6, r7, lr}
    if ((NULL == total) || (NULL == used) || (NULL == AllocCount) || (NULL == FreeCount))
    {
        return LOS_NOK;
   1389e:	2401      	movs	r4, #1
    if ((NULL == total) || (NULL == used) || (NULL == AllocCount) || (NULL == FreeCount))
   138a0:	2800      	cmp	r0, #0
   138a2:	d013      	beq.n	138cc <osHeapStatisticsGet+0x30>
   138a4:	2900      	cmp	r1, #0
   138a6:	d011      	beq.n	138cc <osHeapStatisticsGet+0x30>
   138a8:	2a00      	cmp	r2, #0
   138aa:	d00f      	beq.n	138cc <osHeapStatisticsGet+0x30>
   138ac:	2b00      	cmp	r3, #0
   138ae:	d00d      	beq.n	138cc <osHeapStatisticsGet+0x30>
    }

    UINT32 HeapUsed = 0;
   138b0:	2600      	movs	r6, #0
    struct LOS_HEAP_NODE *node = NULL;

    node = ramHeap.pstTail;
   138b2:	4f0c      	ldr	r7, [pc, #48]	; (138e4 <osHeapStatisticsGet+0x48>)
   138b4:	687c      	ldr	r4, [r7, #4]
    while (node)
   138b6:	2c00      	cmp	r4, #0
   138b8:	d10a      	bne.n	138d0 <osHeapStatisticsGet+0x34>
            HeapUsed += node->uwSize;
        }
        node = node->pstPrev;
    }

    *used = HeapUsed;
   138ba:	600e      	str	r6, [r1, #0]
    *total = ramHeap.uwSize;
   138bc:	68f9      	ldr	r1, [r7, #12]
   138be:	6001      	str	r1, [r0, #0]
    *AllocCount = g_uwAllocCount;
   138c0:	4909      	ldr	r1, [pc, #36]	; (138e8 <osHeapStatisticsGet+0x4c>)
   138c2:	6809      	ldr	r1, [r1, #0]
   138c4:	6011      	str	r1, [r2, #0]
    *FreeCount = g_uwFreeCount;
   138c6:	4a09      	ldr	r2, [pc, #36]	; (138ec <osHeapStatisticsGet+0x50>)
   138c8:	6812      	ldr	r2, [r2, #0]
   138ca:	601a      	str	r2, [r3, #0]
    return LOS_OK;
}
   138cc:	0020      	movs	r0, r4
   138ce:	bdf0      	pop	{r4, r5, r6, r7, pc}
        if (node->uwUsed)
   138d0:	79e5      	ldrb	r5, [r4, #7]
   138d2:	2d7f      	cmp	r5, #127	; 0x7f
   138d4:	d903      	bls.n	138de <osHeapStatisticsGet+0x42>
            HeapUsed += node->uwSize;
   138d6:	6865      	ldr	r5, [r4, #4]
   138d8:	006d      	lsls	r5, r5, #1
   138da:	086d      	lsrs	r5, r5, #1
   138dc:	1976      	adds	r6, r6, r5
        node = node->pstPrev;
   138de:	6824      	ldr	r4, [r4, #0]
   138e0:	e7e9      	b.n	138b6 <osHeapStatisticsGet+0x1a>
   138e2:	46c0      	nop			; (mov r8, r8)
   138e4:	01002e8c 	.word	0x01002e8c
   138e8:	01002500 	.word	0x01002500
   138ec:	01002504 	.word	0x01002504

000138f0 <osHeapGetMaxBlkSize>:

UINT32 osHeapGetMaxBlkSize(VOID)
{
    UINT32 size = 0;
   138f0:	2000      	movs	r0, #0
    UINT32 t = 0;
    struct LOS_HEAP_NODE *node = NULL;

    node = ramHeap.pstTail;
   138f2:	4b08      	ldr	r3, [pc, #32]	; (13914 <osHeapGetMaxBlkSize+0x24>)
   138f4:	685a      	ldr	r2, [r3, #4]
    while (node)
   138f6:	2a00      	cmp	r2, #0
   138f8:	d100      	bne.n	138fc <osHeapGetMaxBlkSize+0xc>
            }
        }
        node = node->pstPrev;
    }
    return size;
}
   138fa:	4770      	bx	lr
        if (!(node->uwUsed))
   138fc:	79d3      	ldrb	r3, [r2, #7]
   138fe:	2b7f      	cmp	r3, #127	; 0x7f
   13900:	d805      	bhi.n	1390e <osHeapGetMaxBlkSize+0x1e>
            t = node->uwSize;
   13902:	6853      	ldr	r3, [r2, #4]
   13904:	005b      	lsls	r3, r3, #1
   13906:	085b      	lsrs	r3, r3, #1
   13908:	4298      	cmp	r0, r3
   1390a:	d200      	bcs.n	1390e <osHeapGetMaxBlkSize+0x1e>
   1390c:	0018      	movs	r0, r3
        node = node->pstPrev;
   1390e:	6812      	ldr	r2, [r2, #0]
   13910:	e7f1      	b.n	138f6 <osHeapGetMaxBlkSize+0x6>
   13912:	46c0      	nop			; (mov r8, r8)
   13914:	01002e8c 	.word	0x01002e8c

00013918 <osSlabAllocatorNew>:
    UINT8 *ucDataChunks;
    struct AtomicBitset bitset[0];/*lint !e43*/
};

struct LOS_SLAB_ALLOCATOR* osSlabAllocatorNew(UINT32 itemSz, UINT32 itemAlign, UINT32 numItems)
{
   13918:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
   1391a:	0007      	movs	r7, r0
    struct LOS_SLAB_ALLOCATOR *allocator;
    UINT32 bitsetSz, dataSz;

    /* calcualte size */
    bitsetSz = ATOMIC_BITSET_SZ(numItems);
   1391c:	0010      	movs	r0, r2
   1391e:	301f      	adds	r0, #31
    bitsetSz = ((bitsetSz + itemAlign - 1) / itemAlign) * itemAlign;
   13920:	1ccb      	adds	r3, r1, #3
    bitsetSz = ATOMIC_BITSET_SZ(numItems);
   13922:	08c0      	lsrs	r0, r0, #3
    bitsetSz = ((bitsetSz + itemAlign - 1) / itemAlign) * itemAlign;
   13924:	18c0      	adds	r0, r0, r3
{
   13926:	000c      	movs	r4, r1
   13928:	0016      	movs	r6, r2
    bitsetSz = ((bitsetSz + itemAlign - 1) / itemAlign) * itemAlign;
   1392a:	f7ec fd45 	bl	3b8 <__udivsi3>
   1392e:	4360      	muls	r0, r4
   13930:	0005      	movs	r5, r0

    itemSz = ((itemSz + itemAlign - 1) / itemAlign) * itemAlign;
   13932:	1e78      	subs	r0, r7, #1
   13934:	0021      	movs	r1, r4
   13936:	1900      	adds	r0, r0, r4
   13938:	f7ec fd3e 	bl	3b8 <__udivsi3>
   1393c:	4344      	muls	r4, r0
    dataSz = itemSz * numItems;
   1393e:	0021      	movs	r1, r4
   13940:	4371      	muls	r1, r6

    /* allocate & init*/
    allocator = (struct LOS_SLAB_ALLOCATOR*)RAM_HEAP_ALLOC(sizeof(struct LOS_SLAB_ALLOCATOR) + bitsetSz + dataSz);
   13942:	3108      	adds	r1, #8
   13944:	1949      	adds	r1, r1, r5
   13946:	4807      	ldr	r0, [pc, #28]	; (13964 <osSlabAllocatorNew+0x4c>)
   13948:	f7ff fee6 	bl	13718 <osHeapAlloc>
   1394c:	1e07      	subs	r7, r0, #0
    if (allocator) {
   1394e:	d006      	beq.n	1395e <osSlabAllocatorNew+0x46>
        allocator->uwItemSz = itemSz;
   13950:	6004      	str	r4, [r0, #0]
        allocator->ucDataChunks = ((UINT8*)allocator->bitset) + bitsetSz;
   13952:	3008      	adds	r0, #8
   13954:	1945      	adds	r5, r0, r5
   13956:	607d      	str	r5, [r7, #4]
        osAtomicBitsetInit(allocator->bitset, numItems);
   13958:	0031      	movs	r1, r6
   1395a:	f000 fe2f 	bl	145bc <osAtomicBitsetInit>
    }

    return allocator;
}
   1395e:	0038      	movs	r0, r7
   13960:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
   13962:	46c0      	nop			; (mov r8, r8)
   13964:	01002e8c 	.word	0x01002e8c

00013968 <osSlabAllocatorDestroy>:

void osSlabAllocatorDestroy(struct LOS_SLAB_ALLOCATOR *allocator)
{
   13968:	b510      	push	{r4, lr}
   1396a:	0001      	movs	r1, r0
    (VOID)RAM_HEAP_FREE(allocator);
   1396c:	4801      	ldr	r0, [pc, #4]	; (13974 <osSlabAllocatorDestroy+0xc>)
   1396e:	f7ff ff35 	bl	137dc <osHeapFree>
}
   13972:	bd10      	pop	{r4, pc}
   13974:	01002e8c 	.word	0x01002e8c

00013978 <osSlabAllocatorAlloc>:

void* osSlabAllocatorAlloc(struct LOS_SLAB_ALLOCATOR *allocator)
{
   13978:	b510      	push	{r4, lr}
   1397a:	0004      	movs	r4, r0
    INT32 itemIdx = osAtomicBitsetFindClearAndSet(allocator->bitset);
   1397c:	3008      	adds	r0, #8
   1397e:	f000 fe52 	bl	14626 <osAtomicBitsetFindClearAndSet>
   13982:	0003      	movs	r3, r0
    if (itemIdx < 0)
        return NULL;
   13984:	2000      	movs	r0, #0
    if (itemIdx < 0)
   13986:	4283      	cmp	r3, r0
   13988:	db03      	blt.n	13992 <osSlabAllocatorAlloc+0x1a>

    return allocator->ucDataChunks + allocator->uwItemSz * itemIdx;
   1398a:	6822      	ldr	r2, [r4, #0]
   1398c:	6860      	ldr	r0, [r4, #4]
   1398e:	4353      	muls	r3, r2
   13990:	18c0      	adds	r0, r0, r3
}
   13992:	bd10      	pop	{r4, pc}

00013994 <osSlabAllocatorFree>:

bool osSlabAllocatorFree(struct LOS_SLAB_ALLOCATOR *allocator, void* ptrP)
{
   13994:	b570      	push	{r4, r5, r6, lr}
   13996:	0004      	movs	r4, r0
    UINT8 *ptr = (UINT8*)ptrP;
    UINT32 itemOffset = ptr - allocator->ucDataChunks;
   13998:	6843      	ldr	r3, [r0, #4]
   1399a:	1ac8      	subs	r0, r1, r3
   1399c:	6821      	ldr	r1, [r4, #0]
   1399e:	f7ec fd91 	bl	4c4 <__aeabi_uidivmod>
   139a2:	0005      	movs	r5, r0
    UINT32 itemIdx = itemOffset / allocator->uwItemSz;

    //check for invalid inputs
    if ((itemOffset % allocator->uwItemSz) || (itemIdx >= osAtomicBitsetGetNumBits(allocator->bitset)) || !osAtomicBitsetGetBit(allocator->bitset, itemIdx))
   139a4:	2900      	cmp	r1, #0
   139a6:	d001      	beq.n	139ac <osSlabAllocatorFree+0x18>
        return FALSE;
   139a8:	2000      	movs	r0, #0

    osAtomicBitsetClearBit(allocator->bitset, itemIdx);
    return TRUE;
}
   139aa:	bd70      	pop	{r4, r5, r6, pc}
    if ((itemOffset % allocator->uwItemSz) || (itemIdx >= osAtomicBitsetGetNumBits(allocator->bitset)) || !osAtomicBitsetGetBit(allocator->bitset, itemIdx))
   139ac:	3408      	adds	r4, #8
   139ae:	0020      	movs	r0, r4
   139b0:	f000 fe19 	bl	145e6 <osAtomicBitsetGetNumBits>
   139b4:	42a8      	cmp	r0, r5
   139b6:	d9f7      	bls.n	139a8 <osSlabAllocatorFree+0x14>
   139b8:	0029      	movs	r1, r5
   139ba:	0020      	movs	r0, r4
   139bc:	f000 fe15 	bl	145ea <osAtomicBitsetGetBit>
   139c0:	2800      	cmp	r0, #0
   139c2:	d0f1      	beq.n	139a8 <osSlabAllocatorFree+0x14>
    osAtomicBitsetClearBit(allocator->bitset, itemIdx);
   139c4:	0020      	movs	r0, r4
   139c6:	0029      	movs	r1, r5
   139c8:	f000 fe1e 	bl	14608 <osAtomicBitsetClearBit>
    return TRUE;
   139cc:	2001      	movs	r0, #1
   139ce:	e7ec      	b.n	139aa <osSlabAllocatorFree+0x16>

000139d0 <osSlabAllocatorEmpty>:
{
    return osAtomicBitsetGetNumBits(allocator->bitset);
}

bool osSlabAllocatorEmpty(struct LOS_SLAB_ALLOCATOR *allocator)
{
   139d0:	b510      	push	{r4, lr}
    return osBitsetEmpty(allocator->bitset);
   139d2:	3008      	adds	r0, #8
   139d4:	f000 fe47 	bl	14666 <osBitsetEmpty>
   139d8:	1e43      	subs	r3, r0, #1
   139da:	4198      	sbcs	r0, r3
   139dc:	b2c0      	uxtb	r0, r0
}
   139de:	bd10      	pop	{r4, pc}

000139e0 <osSlabAllocatorGetUsedItemCnt>:

UINT32 osSlabAllocatorGetUsedItemCnt(struct LOS_SLAB_ALLOCATOR *allocator)
{
   139e0:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    UINT32 used, i;
    struct AtomicBitset *p_bitset = allocator->bitset;
    for (used = 0, i = 0; i < p_bitset->numBits; i++){
   139e2:	2400      	movs	r4, #0
    struct AtomicBitset *p_bitset = allocator->bitset;
   139e4:	0007      	movs	r7, r0
{
   139e6:	0006      	movs	r6, r0
    for (used = 0, i = 0; i < p_bitset->numBits; i++){
   139e8:	0025      	movs	r5, r4
    struct AtomicBitset *p_bitset = allocator->bitset;
   139ea:	3708      	adds	r7, #8
    for (used = 0, i = 0; i < p_bitset->numBits; i++){
   139ec:	68b3      	ldr	r3, [r6, #8]
   139ee:	42a3      	cmp	r3, r4
   139f0:	d801      	bhi.n	139f6 <osSlabAllocatorGetUsedItemCnt+0x16>
        if (osAtomicBitsetGetBit(p_bitset, i)) {
            used ++;
        }
    }
    return used;
}
   139f2:	0028      	movs	r0, r5
   139f4:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
        if (osAtomicBitsetGetBit(p_bitset, i)) {
   139f6:	0021      	movs	r1, r4
   139f8:	0038      	movs	r0, r7
   139fa:	f000 fdf6 	bl	145ea <osAtomicBitsetGetBit>
            used ++;
   139fe:	1e43      	subs	r3, r0, #1
   13a00:	4198      	sbcs	r0, r3
    for (used = 0, i = 0; i < p_bitset->numBits; i++){
   13a02:	3401      	adds	r4, #1
            used ++;
   13a04:	182d      	adds	r5, r5, r0
   13a06:	e7f1      	b.n	139ec <osSlabAllocatorGetUsedItemCnt+0xc>

00013a08 <osSlabAllocatorGetSlabInfo>:

void osSlabAllocatorGetSlabInfo(struct LOS_SLAB_ALLOCATOR *allocator, UINT32 *item_sz, UINT32 *item_cnt, UINT32 *cur_usage)
{
   13a08:	b510      	push	{r4, lr}
   13a0a:	001c      	movs	r4, r3
    *item_sz = allocator->uwItemSz;
   13a0c:	6803      	ldr	r3, [r0, #0]
   13a0e:	600b      	str	r3, [r1, #0]
    *item_cnt = allocator->bitset->numBits;/*lint !e663*/
   13a10:	6883      	ldr	r3, [r0, #8]
   13a12:	6013      	str	r3, [r2, #0]
    *cur_usage = osSlabAllocatorGetUsedItemCnt(allocator);
   13a14:	f7ff ffe4 	bl	139e0 <osSlabAllocatorGetUsedItemCnt>
   13a18:	6020      	str	r0, [r4, #0]
}
   13a1a:	bd10      	pop	{r4, pc}

00013a1c <LOS_Align>:
#include "los_sys.ph"
#include "los_task.ph"

LITE_OS_SEC_TEXT UINT32 LOS_Align(UINT32 uwAddr, UINT32 uwBoundary)
{
    if (uwAddr + uwBoundary - 1 > uwAddr) {
   13a1c:	1e4b      	subs	r3, r1, #1
   13a1e:	181b      	adds	r3, r3, r0
   13a20:	4249      	negs	r1, r1
{
   13a22:	0002      	movs	r2, r0
        return (uwAddr + uwBoundary - 1) & ~(uwBoundary - 1);
    } else {
        return uwAddr & ~(uwBoundary - 1);
   13a24:	4008      	ands	r0, r1
    if (uwAddr + uwBoundary - 1 > uwAddr) {
   13a26:	4293      	cmp	r3, r2
   13a28:	d901      	bls.n	13a2e <LOS_Align+0x12>
        return (uwAddr + uwBoundary - 1) & ~(uwBoundary - 1);
   13a2a:	400b      	ands	r3, r1
   13a2c:	0018      	movs	r0, r3
    }
}
   13a2e:	4770      	bx	lr

00013a30 <osTaskExit>:
  This function disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
   13a30:	b672      	cpsid	i
   13a32:	e7fe      	b.n	13a32 <osTaskExit+0x2>

00013a34 <osSchedule>:
 Input       : None
 Output      : None
 Return      : None
 *****************************************************************************/
VOID osSchedule(VOID)
{
   13a34:	b510      	push	{r4, lr}
    osTaskSchedule();
   13a36:	f7ec fb9d 	bl	174 <osTaskSchedule>
}
   13a3a:	bd10      	pop	{r4, pc}

00013a3c <LOS_Schedule>:
 Input       : None
 Output      : None
 Return      : None
 *****************************************************************************/
VOID LOS_Schedule(VOID)
{
   13a3c:	b510      	push	{r4, lr}
    UINTPTR uvIntSave;
    uvIntSave = LOS_IntLock();
   13a3e:	f7ec fb8e 	bl	15e <LOS_IntLock>
   13a42:	0004      	movs	r4, r0

    /* Find the highest task */
    g_stLosTask.pstNewTask = LOS_DL_LIST_ENTRY(osPriqueueTop(), LOS_TASK_CB, stPendList);
   13a44:	f000 f99a 	bl	13d7c <osPriqueueTop>
   13a48:	4b09      	ldr	r3, [pc, #36]	; (13a70 <LOS_Schedule+0x34>)
   13a4a:	382c      	subs	r0, #44	; 0x2c
   13a4c:	6058      	str	r0, [r3, #4]

    /* In case that running is not highest then reschedule */
    if (g_stLosTask.pstRunTask != g_stLosTask.pstNewTask)
   13a4e:	681b      	ldr	r3, [r3, #0]
   13a50:	4298      	cmp	r0, r3
   13a52:	d009      	beq.n	13a68 <LOS_Schedule+0x2c>
    {
        if ((!g_usLosTaskLock))
   13a54:	4b07      	ldr	r3, [pc, #28]	; (13a74 <LOS_Schedule+0x38>)
   13a56:	881b      	ldrh	r3, [r3, #0]
   13a58:	2b00      	cmp	r3, #0
   13a5a:	d105      	bne.n	13a68 <LOS_Schedule+0x2c>
        {
            (VOID)LOS_IntRestore(uvIntSave);
   13a5c:	0020      	movs	r0, r4
   13a5e:	f7ec fb86 	bl	16e <LOS_IntRestore>

            osTaskSchedule();
   13a62:	f7ec fb87 	bl	174 <osTaskSchedule>
            return;
        }
    }

    (VOID)LOS_IntRestore(uvIntSave);
}
   13a66:	bd10      	pop	{r4, pc}
    (VOID)LOS_IntRestore(uvIntSave);
   13a68:	0020      	movs	r0, r4
   13a6a:	f7ec fb80 	bl	16e <LOS_IntRestore>
   13a6e:	e7fa      	b.n	13a66 <LOS_Schedule+0x2a>
   13a70:	01002e70 	.word	0x01002e70
   13a74:	01002e6c 	.word	0x01002e6c

00013a78 <osTskStackInit>:
{
    UINT32 uwIdx;
    TSK_CONTEXT_S  *pstContext;

    /*initialize the task stack, write magic num to stack top*/
    for (uwIdx = 1; uwIdx < (uwStackSize/sizeof(UINT32)); uwIdx++)
   13a78:	2301      	movs	r3, #1
{
   13a7a:	b570      	push	{r4, r5, r6, lr}
    {
        *((UINT32 *)pTopStack + uwIdx) = OS_TASK_STACK_INIT;
   13a7c:	4d17      	ldr	r5, [pc, #92]	; (13adc <osTskStackInit+0x64>)
    for (uwIdx = 1; uwIdx < (uwStackSize/sizeof(UINT32)); uwIdx++)
   13a7e:	088c      	lsrs	r4, r1, #2
   13a80:	429c      	cmp	r4, r3
   13a82:	d827      	bhi.n	13ad4 <osTskStackInit+0x5c>
    }
    *((UINT32 *)(pTopStack)) = OS_TASK_MAGIC_WORD;
   13a84:	4b16      	ldr	r3, [pc, #88]	; (13ae0 <osTskStackInit+0x68>)
   13a86:	6013      	str	r3, [r2, #0]

    pstContext    = (TSK_CONTEXT_S *)(((UINT32)pTopStack + uwStackSize) - sizeof(TSK_CONTEXT_S));
   13a88:	1852      	adds	r2, r2, r1

    pstContext->uwR4  = 0x04040404L;
   13a8a:	4b16      	ldr	r3, [pc, #88]	; (13ae4 <osTskStackInit+0x6c>)
    pstContext    = (TSK_CONTEXT_S *)(((UINT32)pTopStack + uwStackSize) - sizeof(TSK_CONTEXT_S));
   13a8c:	3a44      	subs	r2, #68	; 0x44
    pstContext->uwR4  = 0x04040404L;
   13a8e:	6013      	str	r3, [r2, #0]
    pstContext->uwR5  = 0x05050505L;
   13a90:	4b15      	ldr	r3, [pc, #84]	; (13ae8 <osTskStackInit+0x70>)
    pstContext->uwR8  = 0x08080808L;
    pstContext->uwR9  = 0x09090909L;
    pstContext->uwR10 = 0x10101010L;
    pstContext->uwR11 = 0x11111111L;
    pstContext->uwPriMask = 0;
    pstContext->uwR0  = uwTaskID;
   13a92:	6250      	str	r0, [r2, #36]	; 0x24
    pstContext->uwR5  = 0x05050505L;
   13a94:	6053      	str	r3, [r2, #4]
    pstContext->uwR6  = 0x06060606L;
   13a96:	4b15      	ldr	r3, [pc, #84]	; (13aec <osTskStackInit+0x74>)
    pstContext->uwLR  = (UINT32)osTaskExit;
    pstContext->uwPC  = (UINT32)osTaskEntry;
    pstContext->uwxPSR = 0x01000000L;

    return (VOID *)pstContext;
}
   13a98:	0010      	movs	r0, r2
    pstContext->uwR6  = 0x06060606L;
   13a9a:	6093      	str	r3, [r2, #8]
    pstContext->uwR7  = 0x07070707L;
   13a9c:	4b14      	ldr	r3, [pc, #80]	; (13af0 <osTskStackInit+0x78>)
   13a9e:	60d3      	str	r3, [r2, #12]
    pstContext->uwR8  = 0x08080808L;
   13aa0:	4b14      	ldr	r3, [pc, #80]	; (13af4 <osTskStackInit+0x7c>)
   13aa2:	6113      	str	r3, [r2, #16]
    pstContext->uwR9  = 0x09090909L;
   13aa4:	4b14      	ldr	r3, [pc, #80]	; (13af8 <osTskStackInit+0x80>)
   13aa6:	6153      	str	r3, [r2, #20]
    pstContext->uwR10 = 0x10101010L;
   13aa8:	4b14      	ldr	r3, [pc, #80]	; (13afc <osTskStackInit+0x84>)
   13aaa:	6193      	str	r3, [r2, #24]
    pstContext->uwR11 = 0x11111111L;
   13aac:	4b14      	ldr	r3, [pc, #80]	; (13b00 <osTskStackInit+0x88>)
   13aae:	61d3      	str	r3, [r2, #28]
    pstContext->uwPriMask = 0;
   13ab0:	2300      	movs	r3, #0
   13ab2:	6213      	str	r3, [r2, #32]
    pstContext->uwR1  = 0x01010101L;
   13ab4:	4b13      	ldr	r3, [pc, #76]	; (13b04 <osTskStackInit+0x8c>)
   13ab6:	6293      	str	r3, [r2, #40]	; 0x28
    pstContext->uwR2  = 0x02020202L;
   13ab8:	4b13      	ldr	r3, [pc, #76]	; (13b08 <osTskStackInit+0x90>)
   13aba:	62d3      	str	r3, [r2, #44]	; 0x2c
    pstContext->uwR3  = 0x03030303L;
   13abc:	4b13      	ldr	r3, [pc, #76]	; (13b0c <osTskStackInit+0x94>)
   13abe:	6313      	str	r3, [r2, #48]	; 0x30
    pstContext->uwR12 = 0x12121212L;
   13ac0:	4b13      	ldr	r3, [pc, #76]	; (13b10 <osTskStackInit+0x98>)
   13ac2:	6353      	str	r3, [r2, #52]	; 0x34
    pstContext->uwLR  = (UINT32)osTaskExit;
   13ac4:	4b13      	ldr	r3, [pc, #76]	; (13b14 <osTskStackInit+0x9c>)
   13ac6:	6393      	str	r3, [r2, #56]	; 0x38
    pstContext->uwPC  = (UINT32)osTaskEntry;
   13ac8:	4b13      	ldr	r3, [pc, #76]	; (13b18 <osTskStackInit+0xa0>)
   13aca:	63d3      	str	r3, [r2, #60]	; 0x3c
    pstContext->uwxPSR = 0x01000000L;
   13acc:	2380      	movs	r3, #128	; 0x80
   13ace:	045b      	lsls	r3, r3, #17
   13ad0:	6413      	str	r3, [r2, #64]	; 0x40
}
   13ad2:	bd70      	pop	{r4, r5, r6, pc}
        *((UINT32 *)pTopStack + uwIdx) = OS_TASK_STACK_INIT;
   13ad4:	009e      	lsls	r6, r3, #2
   13ad6:	5195      	str	r5, [r2, r6]
    for (uwIdx = 1; uwIdx < (uwStackSize/sizeof(UINT32)); uwIdx++)
   13ad8:	3301      	adds	r3, #1
   13ada:	e7d1      	b.n	13a80 <osTskStackInit+0x8>
   13adc:	cacacaca 	.word	0xcacacaca
   13ae0:	cccccccc 	.word	0xcccccccc
   13ae4:	04040404 	.word	0x04040404
   13ae8:	05050505 	.word	0x05050505
   13aec:	06060606 	.word	0x06060606
   13af0:	07070707 	.word	0x07070707
   13af4:	08080808 	.word	0x08080808
   13af8:	09090909 	.word	0x09090909
   13afc:	10101010 	.word	0x10101010
   13b00:	11111111 	.word	0x11111111
   13b04:	01010101 	.word	0x01010101
   13b08:	02020202 	.word	0x02020202
   13b0c:	03030303 	.word	0x03030303
   13b10:	12121212 	.word	0x12121212
   13b14:	00013a31 	.word	0x00013a31
   13b18:	00013291 	.word	0x00013291

00013b1c <los_rtc_callback>:
    return RtcMs;
}

void los_rtc_callback(void)
{
    counter_handle = 0;
   13b1c:	2200      	movs	r2, #0
   13b1e:	4b01      	ldr	r3, [pc, #4]	; (13b24 <los_rtc_callback+0x8>)
   13b20:	601a      	str	r2, [r3, #0]
}
   13b22:	4770      	bx	lr
   13b24:	01002510 	.word	0x01002510

00013b28 <los_lpt_set_delay_ms>:

void los_lpt_set_delay_ms(UINT64 delay_ms)
{
   13b28:	b570      	push	{r4, r5, r6, lr}
    if (counter_handle != 0)
   13b2a:	4b08      	ldr	r3, [pc, #32]	; (13b4c <los_lpt_set_delay_ms+0x24>)
{
   13b2c:	0004      	movs	r4, r0
    if (counter_handle != 0)
   13b2e:	6818      	ldr	r0, [r3, #0]
{
   13b30:	000d      	movs	r5, r1
    if (counter_handle != 0)
   13b32:	2800      	cmp	r0, #0
   13b34:	d001      	beq.n	13b3a <los_lpt_set_delay_ms+0x12>
    {
        (void)rtc_delete(counter_handle);
   13b36:	f004 fd29 	bl	1858c <rtc_delete>
    }
    if (delay_ms < MINIMUM_RTC_DELAY)
    {
        delay_ms = MINIMUM_RTC_DELAY;
    }
    rtc_delay = delay_ms;
   13b3a:	4b05      	ldr	r3, [pc, #20]	; (13b50 <los_lpt_set_delay_ms+0x28>)
   13b3c:	2d00      	cmp	r5, #0
   13b3e:	d102      	bne.n	13b46 <los_lpt_set_delay_ms+0x1e>
   13b40:	2c04      	cmp	r4, #4
   13b42:	d200      	bcs.n	13b46 <los_lpt_set_delay_ms+0x1e>
   13b44:	2404      	movs	r4, #4
   13b46:	c330      	stmia	r3!, {r4, r5}
}
   13b48:	bd70      	pop	{r4, r5, r6, pc}
   13b4a:	46c0      	nop			; (mov r8, r8)
   13b4c:	01002510 	.word	0x01002510
   13b50:	01002528 	.word	0x01002528

00013b54 <los_lpt_start>:

/**Start low power timer
 * @note This will panic if an already running timer is started
 */
void los_lpt_start(void)
{
   13b54:	b510      	push	{r4, lr}
    if (counter_handle != 0)
   13b56:	4c07      	ldr	r4, [pc, #28]	; (13b74 <los_lpt_start+0x20>)
   13b58:	6820      	ldr	r0, [r4, #0]
   13b5a:	2800      	cmp	r0, #0
   13b5c:	d001      	beq.n	13b62 <los_lpt_start+0xe>
    {
        (void)rtc_delete(counter_handle);
   13b5e:	f004 fd15 	bl	1858c <rtc_delete>
    }
    counter_handle = rtc_add_at((uint64)rtc_delay, los_rtc_callback, RTC_FLAG_NORMAL);
   13b62:	4b05      	ldr	r3, [pc, #20]	; (13b78 <los_lpt_start+0x24>)
   13b64:	4a05      	ldr	r2, [pc, #20]	; (13b7c <los_lpt_start+0x28>)
   13b66:	6818      	ldr	r0, [r3, #0]
   13b68:	6859      	ldr	r1, [r3, #4]
   13b6a:	2300      	movs	r3, #0
   13b6c:	f004 fd26 	bl	185bc <rtc_add_at>
   13b70:	6020      	str	r0, [r4, #0]
}
   13b72:	bd10      	pop	{r4, pc}
   13b74:	01002510 	.word	0x01002510
   13b78:	01002528 	.word	0x01002528
   13b7c:	00013b1d 	.word	0x00013b1d

00013b80 <los_lpt_disable>:

void los_lpt_disable(void)
{
   13b80:	b510      	push	{r4, lr}
    if (counter_handle != 0)
   13b82:	4c04      	ldr	r4, [pc, #16]	; (13b94 <los_lpt_disable+0x14>)
   13b84:	6820      	ldr	r0, [r4, #0]
   13b86:	2800      	cmp	r0, #0
   13b88:	d003      	beq.n	13b92 <los_lpt_disable+0x12>
    {
        (void)rtc_delete(counter_handle);
   13b8a:	f004 fcff 	bl	1858c <rtc_delete>
        counter_handle = 0;
   13b8e:	2300      	movs	r3, #0
   13b90:	6023      	str	r3, [r4, #0]
    }
}
   13b92:	bd10      	pop	{r4, pc}
   13b94:	01002510 	.word	0x01002510

00013b98 <TaskStepTick>:
extern LITE_OS_SEC_TEXT UINT32 osSwTmrGetNextTimeout(VOID);
void TaskStepTick( const UINT32 xTicksToJump )
{
   13b98:	b570      	push	{r4, r5, r6, lr}
   13b9a:	0004      	movs	r4, r0
   13b9c:	4675      	mov	r5, lr
    /* Correct the tick count value after a period during which the tick
    was suppressed.  Note this does *not* call the tick hook function for
    each stepped tick. */
    assert( xTicksToJump <= osSwTmrGetNextTimeout());
   13b9e:	f000 fa03 	bl	13fa8 <osSwTmrGetNextTimeout>
   13ba2:	42a0      	cmp	r0, r4
   13ba4:	d203      	bcs.n	13bae <TaskStepTick+0x16>
   13ba6:	0029      	movs	r1, r5
   13ba8:	2016      	movs	r0, #22
   13baa:	f7ed ffb1 	bl	1b10 <panic>
    g_ullTickCount += xTicksToJump;
   13bae:	0022      	movs	r2, r4
   13bb0:	2300      	movs	r3, #0
   13bb2:	4904      	ldr	r1, [pc, #16]	; (13bc4 <TaskStepTick+0x2c>)
   13bb4:	680c      	ldr	r4, [r1, #0]
   13bb6:	684d      	ldr	r5, [r1, #4]
   13bb8:	1912      	adds	r2, r2, r4
   13bba:	416b      	adcs	r3, r5
   13bbc:	600a      	str	r2, [r1, #0]
   13bbe:	604b      	str	r3, [r1, #4]
}
   13bc0:	bd70      	pop	{r4, r5, r6, pc}
   13bc2:	46c0      	nop			; (mov r8, r8)
   13bc4:	01002eb0 	.word	0x01002eb0

00013bc8 <los_SuppressTicksAndSleep>:
    hal_lpc_enter_wfi();
    system_status_signal_exit_wfi();
}

void los_SuppressTicksAndSleep(UINT32 xExpectedIdleTime)
{
   13bc8:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
   13bca:	0004      	movs	r4, r0
    UINT32 delay_time_ms;
    UINT64 rtc_time;
    UINT64 wake_time;
   (void)xExpectedIdleTime;

    if (SystickCountToRtcMs(xExpectedIdleTime) < MINIMUM_RTC_DELAY)
   13bcc:	2803      	cmp	r0, #3
   13bce:	d969      	bls.n	13ca4 <los_SuppressTicksAndSleep+0xdc>
        // Will not support it - so just return.
        return;
    }

    // Stop the sys-tick to stop it from changing and waking the processor up
    *(NVIC_SYSTICK_CTRL) = NVIC_SYSTICK_CLK | NVIC_SYSTICK_INT;
   13bd0:	2306      	movs	r3, #6
   13bd2:	4d35      	ldr	r5, [pc, #212]	; (13ca8 <los_SuppressTicksAndSleep+0xe0>)
   13bd4:	602b      	str	r3, [r5, #0]

    // Stop interrupt processing but allow the processor to wake up once put to sleep via the wfi instruction
    non_os_enter_critical();
   13bd6:	f004 faed 	bl	181b4 <non_os_enter_critical>
                xExpectedIdleTime = MaximumPossibleSuppressedTicksWait;
        }

        delay_time_ms = SystickCountToRtcMs(xExpectedIdleTime);
        // Record the sleep entry time so the delta can be returned
        MyEntryTime = rtc_get_time();
   13bda:	f004 fd09 	bl	185f0 <rtc_get_time>
   13bde:	4b33      	ldr	r3, [pc, #204]	; (13cac <los_SuppressTicksAndSleep+0xe4>)
   13be0:	6018      	str	r0, [r3, #0]
   13be2:	6059      	str	r1, [r3, #4]
        // Configure the low power timer to wake the processor back up and start the timer running
        // Set the rtc timer for the given time

        wake_time = (UINT64)(rtc_get_time() + RTC_MS_CONVERT_TO_RTC(delay_time_ms));
   13be4:	f004 fd04 	bl	185f0 <rtc_get_time>
   13be8:	2300      	movs	r3, #0
   13bea:	227d      	movs	r2, #125	; 0x7d
   13bec:	0006      	movs	r6, r0
   13bee:	000f      	movs	r7, r1
   13bf0:	0320      	lsls	r0, r4, #12
   13bf2:	0d21      	lsrs	r1, r4, #20
   13bf4:	f7ec fd56 	bl	6a4 <__aeabi_uldivmod>
   13bf8:	1836      	adds	r6, r6, r0
   13bfa:	414f      	adcs	r7, r1
        los_lpt_set_delay_ms( wake_time );
   13bfc:	0039      	movs	r1, r7
   13bfe:	0030      	movs	r0, r6
   13c00:	f7ff ff92 	bl	13b28 <los_lpt_set_delay_ms>
        los_lpt_start();
   13c04:	f7ff ffa6 	bl	13b54 <los_lpt_start>
        hal_lpc_set_sleep_on_exit(false);
   13c08:	2000      	movs	r0, #0
   13c0a:	f005 fd43 	bl	19694 <hal_lpc_set_sleep_on_exit>
        watchdog_disable();
   13c0e:	f004 fe55 	bl	188bc <watchdog_disable>
/** The number of vetoes registered for disallowing the system clock from being stopped
 * @note Get the stop clock vetoes value.
 */
uint32 getStopClockVetoesValue(void)
{
    return ulStopClockVetoes;
   13c12:	4b27      	ldr	r3, [pc, #156]	; (13cb0 <los_SuppressTicksAndSleep+0xe8>)
   13c14:	9501      	str	r5, [sp, #4]
        if ((getStopClockVetoesValue()== 0) && (delay_time_ms > SLEEP_CUTOFF_LIMIT_MS)){
   13c16:	681b      	ldr	r3, [r3, #0]
   13c18:	4d26      	ldr	r5, [pc, #152]	; (13cb4 <los_SuppressTicksAndSleep+0xec>)
   13c1a:	2b00      	cmp	r3, #0
   13c1c:	d102      	bne.n	13c24 <los_SuppressTicksAndSleep+0x5c>
            hal_lpc_set_sleep_mode(HAL_LPC_SLEEP_MODE_DEEP);
   13c1e:	2001      	movs	r0, #1
        if ((getStopClockVetoesValue()== 0) && (delay_time_ms > SLEEP_CUTOFF_LIMIT_MS)){
   13c20:	2c19      	cmp	r4, #25
   13c22:	d800      	bhi.n	13c26 <los_SuppressTicksAndSleep+0x5e>
            hal_lpc_set_sleep_mode(HAL_LPC_SLEEP_MODE_LIGHT);
   13c24:	2000      	movs	r0, #0
   13c26:	f005 fd27 	bl	19678 <hal_lpc_set_sleep_mode>
            osEnterSleep(wake_time);
   13c2a:	0030      	movs	r0, r6
   13c2c:	0039      	movs	r1, r7
   13c2e:	47a8      	blx	r5
        watchdog_enable();
   13c30:	f004 fe0a 	bl	18848 <watchdog_enable>
        los_lpt_disable();
   13c34:	f7ff ffa4 	bl	13b80 <los_lpt_disable>
        MyExitTime = rtc_get_time();
   13c38:	f004 fcda 	bl	185f0 <rtc_get_time>
        rtc_time      = ((MyExitTime - MyEntryTime) * LOSCFG_BASE_CORE_TICK_PER_SECOND) + losRtcTimeCalibrate;
   13c3c:	4b1b      	ldr	r3, [pc, #108]	; (13cac <los_SuppressTicksAndSleep+0xe4>)
   13c3e:	681a      	ldr	r2, [r3, #0]
   13c40:	685b      	ldr	r3, [r3, #4]
   13c42:	1a80      	subs	r0, r0, r2
   13c44:	4199      	sbcs	r1, r3
   13c46:	22fa      	movs	r2, #250	; 0xfa
   13c48:	2300      	movs	r3, #0
   13c4a:	0092      	lsls	r2, r2, #2
   13c4c:	f7ec fd4a 	bl	6e4 <__aeabi_lmul>
   13c50:	4b19      	ldr	r3, [pc, #100]	; (13cb8 <los_SuppressTicksAndSleep+0xf0>)
   13c52:	681d      	ldr	r5, [r3, #0]
   13c54:	685e      	ldr	r6, [r3, #4]
   13c56:	1940      	adds	r0, r0, r5
   13c58:	4171      	adcs	r1, r6
        ElapsedTicks = (UINT32)(rtc_time >> 15);
   13c5a:	044a      	lsls	r2, r1, #17
   13c5c:	0bc5      	lsrs	r5, r0, #15
   13c5e:	4315      	orrs	r5, r2
        losRtcTimeCalibrate = rtc_time & 0x7FFF;
   13c60:	2200      	movs	r2, #0
   13c62:	0440      	lsls	r0, r0, #17
   13c64:	0c40      	lsrs	r0, r0, #17
   13c66:	6018      	str	r0, [r3, #0]
   13c68:	605a      	str	r2, [r3, #4]
        ElapsedTicks += losSystickCalibrate;
   13c6a:	4b14      	ldr	r3, [pc, #80]	; (13cbc <los_SuppressTicksAndSleep+0xf4>)
   13c6c:	6819      	ldr	r1, [r3, #0]
   13c6e:	186d      	adds	r5, r5, r1
        if (ElapsedTicks > xExpectedIdleTime)
   13c70:	42ac      	cmp	r4, r5
   13c72:	d20f      	bcs.n	13c94 <los_SuppressTicksAndSleep+0xcc>
            losSystickCalibrate = ElapsedTicks - xExpectedIdleTime;
   13c74:	1b2d      	subs	r5, r5, r4
   13c76:	601d      	str	r5, [r3, #0]
   13c78:	0025      	movs	r5, r4
            TaskStepTick(ElapsedTicks);
   13c7a:	0028      	movs	r0, r5
   13c7c:	f7ff ff8c 	bl	13b98 <TaskStepTick>
            osTskSortLinkUpdate(ElapsedTicks);
   13c80:	0028      	movs	r0, r5
   13c82:	f7ff f927 	bl	12ed4 <osTskSortLinkUpdate>
            osTaskScan(1);
   13c86:	2001      	movs	r0, #1
   13c88:	f7ff f9cc 	bl	13024 <osTaskScan>
            osSwTmrAdjust(ElapsedTicks);
   13c8c:	0028      	movs	r0, r5
   13c8e:	f000 f997 	bl	13fc0 <osSwTmrAdjust>
   13c92:	e002      	b.n	13c9a <los_SuppressTicksAndSleep+0xd2>
           losSystickCalibrate = 0;
   13c94:	601a      	str	r2, [r3, #0]
        if (ElapsedTicks > 0)
   13c96:	2d00      	cmp	r5, #0
   13c98:	d1ef      	bne.n	13c7a <los_SuppressTicksAndSleep+0xb2>
        *(NVIC_SYSTICK_CTRL) = NVIC_SYSTICK_CLK | NVIC_SYSTICK_INT | NVIC_SYSTICK_ENABLE;
   13c9a:	2307      	movs	r3, #7
   13c9c:	9a01      	ldr	r2, [sp, #4]
   13c9e:	6013      	str	r3, [r2, #0]
        non_os_exit_critical();
   13ca0:	f004 fa9c 	bl	181dc <non_os_exit_critical>
}
   13ca4:	bdf7      	pop	{r0, r1, r2, r4, r5, r6, r7, pc}
   13ca6:	46c0      	nop			; (mov r8, r8)
   13ca8:	e000e010 	.word	0xe000e010
   13cac:	01002508 	.word	0x01002508
   13cb0:	01002530 	.word	0x01002530
   13cb4:	01000401 	.word	0x01000401
   13cb8:	01002518 	.word	0x01002518
   13cbc:	01002520 	.word	0x01002520

00013cc0 <tickless_add_stop_clocks_veto>:
 *       Many vetoes may be independently added or removed; one or more will prevent RTOS stopping the system clocks.
 *       This function may be called in an interrupt context
 *       This function is thread safe and may be called before or after the RTOS scheduler is started
 */
void tickless_add_stop_clocks_veto(void)
{
   13cc0:	b510      	push	{r4, lr}
#if defined (LOS_RUNSTOP)
    // Critical sections are only needed and safe to use if RTOS is running
    if (osKernelGetState() == osKernelRunning)
   13cc2:	f000 fd07 	bl	146d4 <osKernelGetState>
   13cc6:	4c07      	ldr	r4, [pc, #28]	; (13ce4 <tickless_add_stop_clocks_veto+0x24>)
   13cc8:	2802      	cmp	r0, #2
   13cca:	d107      	bne.n	13cdc <tickless_add_stop_clocks_veto+0x1c>
    {
        non_os_enter_critical();
   13ccc:	f004 fa72 	bl	181b4 <non_os_enter_critical>

        ulStopClockVetoes++;
   13cd0:	6823      	ldr	r3, [r4, #0]
   13cd2:	3301      	adds	r3, #1
   13cd4:	6023      	str	r3, [r4, #0]

        non_os_exit_critical();
   13cd6:	f004 fa81 	bl	181dc <non_os_exit_critical>
    else
    {
        ulStopClockVetoes++;
    }
#endif
}
   13cda:	bd10      	pop	{r4, pc}
        ulStopClockVetoes++;
   13cdc:	6823      	ldr	r3, [r4, #0]
   13cde:	3301      	adds	r3, #1
   13ce0:	6023      	str	r3, [r4, #0]
}
   13ce2:	e7fa      	b.n	13cda <tickless_add_stop_clocks_veto+0x1a>
   13ce4:	01002530 	.word	0x01002530

00013ce8 <tickless_remove_stop_clocks_veto>:
 *       Many vetoes may be independently added or removed; one or more will prevent RTOS stopping the system clocks.
 *       This function may be called in an interrupt context
 *       This function is thread safe and may be called before or after the RTOS scheduler is started
 */
void tickless_remove_stop_clocks_veto(void)
{
   13ce8:	b510      	push	{r4, lr}
#if defined (LOS_RUNSTOP)
    // Critical sections are only needed and safe to use if RTOS is running
    if (osKernelGetState() == osKernelRunning)
   13cea:	f000 fcf3 	bl	146d4 <osKernelGetState>
   13cee:	4c09      	ldr	r4, [pc, #36]	; (13d14 <tickless_remove_stop_clocks_veto+0x2c>)
   13cf0:	2802      	cmp	r0, #2
   13cf2:	d109      	bne.n	13d08 <tickless_remove_stop_clocks_veto+0x20>
    {
        non_os_enter_critical();
   13cf4:	f004 fa5e 	bl	181b4 <non_os_enter_critical>

        if (ulStopClockVetoes != 0) ulStopClockVetoes--;
   13cf8:	6823      	ldr	r3, [r4, #0]
   13cfa:	2b00      	cmp	r3, #0
   13cfc:	d001      	beq.n	13d02 <tickless_remove_stop_clocks_veto+0x1a>
   13cfe:	3b01      	subs	r3, #1
   13d00:	6023      	str	r3, [r4, #0]

        non_os_exit_critical();
   13d02:	f004 fa6b 	bl	181dc <non_os_exit_critical>
    else
    {
        if (ulStopClockVetoes != 0) ulStopClockVetoes--;
    }
#endif
}
   13d06:	bd10      	pop	{r4, pc}
        if (ulStopClockVetoes != 0) ulStopClockVetoes--;
   13d08:	6823      	ldr	r3, [r4, #0]
   13d0a:	2b00      	cmp	r3, #0
   13d0c:	d0fb      	beq.n	13d06 <tickless_remove_stop_clocks_veto+0x1e>
   13d0e:	3b01      	subs	r3, #1
   13d10:	6023      	str	r3, [r4, #0]
}
   13d12:	e7f8      	b.n	13d06 <tickless_remove_stop_clocks_veto+0x1e>
   13d14:	01002530 	.word	0x01002530

00013d18 <osPriqueueInit>:
{
    UINT32 uwPri = 0;
    UINT32 uwSize = 0;

    uwSize = OS_PRIORITY_QUEUE_PRIORITYNUM * sizeof(LOS_DL_LIST);
    g_pstLosPriorityQueueList = (LOS_DL_LIST *)LOS_MemAlloc(m_aucSysMem0, uwSize);
   13d18:	2180      	movs	r1, #128	; 0x80
{
   13d1a:	b510      	push	{r4, lr}
    g_pstLosPriorityQueueList = (LOS_DL_LIST *)LOS_MemAlloc(m_aucSysMem0, uwSize);
   13d1c:	4b09      	ldr	r3, [pc, #36]	; (13d44 <osPriqueueInit+0x2c>)
   13d1e:	0049      	lsls	r1, r1, #1
   13d20:	6818      	ldr	r0, [r3, #0]
   13d22:	f7fe fedf 	bl	12ae4 <LOS_MemAlloc>
   13d26:	4908      	ldr	r1, [pc, #32]	; (13d48 <osPriqueueInit+0x30>)
   13d28:	6008      	str	r0, [r1, #0]
    if (NULL == g_pstLosPriorityQueueList)
   13d2a:	2800      	cmp	r0, #0
   13d2c:	d009      	beq.n	13d42 <osPriqueueInit+0x2a>
    {
        return;
    }

    for (uwPri = 0; uwPri < OS_PRIORITY_QUEUE_PRIORITYNUM; ++uwPri)
   13d2e:	2080      	movs	r0, #128	; 0x80
   13d30:	2200      	movs	r2, #0
   13d32:	0040      	lsls	r0, r0, #1
    {
        LOS_ListInit(&g_pstLosPriorityQueueList[uwPri]);
   13d34:	680b      	ldr	r3, [r1, #0]
   13d36:	189b      	adds	r3, r3, r2
   13d38:	3208      	adds	r2, #8
    pstList->pstNext = pstList;
   13d3a:	605b      	str	r3, [r3, #4]
    pstList->pstPrev = pstList;
   13d3c:	601b      	str	r3, [r3, #0]
    for (uwPri = 0; uwPri < OS_PRIORITY_QUEUE_PRIORITYNUM; ++uwPri)
   13d3e:	4282      	cmp	r2, r0
   13d40:	d1f8      	bne.n	13d34 <osPriqueueInit+0x1c>
    }
}
   13d42:	bd10      	pop	{r4, pc}
   13d44:	01002e40 	.word	0x01002e40
   13d48:	01002e9c 	.word	0x01002e9c

00013d4c <osPriqueueEnqueue>:
{
    LOS_ListHeadInsert(&g_pstLosPriorityQueueList[uwPri], ptrPQItem);
}

VOID osPriqueueEnqueue(LOS_DL_LIST *ptrPQItem, UINT32 uwPri)
{
   13d4c:	4b05      	ldr	r3, [pc, #20]	; (13d64 <osPriqueueEnqueue+0x18>)
   13d4e:	00c9      	lsls	r1, r1, #3
   13d50:	681b      	ldr	r3, [r3, #0]
    LOS_ListTailInsert(&g_pstLosPriorityQueueList[uwPri], ptrPQItem);
}
   13d52:	58cb      	ldr	r3, [r1, r3]
    pstNode->pstNext = pstList->pstNext;
   13d54:	685a      	ldr	r2, [r3, #4]
    pstNode->pstPrev = pstList;
   13d56:	6003      	str	r3, [r0, #0]
    pstNode->pstNext = pstList->pstNext;
   13d58:	6042      	str	r2, [r0, #4]
    pstList->pstNext->pstPrev = pstNode;
   13d5a:	685a      	ldr	r2, [r3, #4]
   13d5c:	6010      	str	r0, [r2, #0]
    pstList->pstNext = pstNode;
   13d5e:	6058      	str	r0, [r3, #4]
   13d60:	4770      	bx	lr
   13d62:	46c0      	nop			; (mov r8, r8)
   13d64:	01002e9c 	.word	0x01002e9c

00013d68 <osPriqueueDequeue>:
    pstNode->pstNext->pstPrev = pstNode->pstPrev;
   13d68:	6843      	ldr	r3, [r0, #4]
   13d6a:	6802      	ldr	r2, [r0, #0]
   13d6c:	601a      	str	r2, [r3, #0]
    pstNode->pstPrev->pstNext = pstNode->pstNext;
   13d6e:	6803      	ldr	r3, [r0, #0]
   13d70:	6842      	ldr	r2, [r0, #4]
   13d72:	605a      	str	r2, [r3, #4]
    pstNode->pstNext = (LOS_DL_LIST *)NULL;
   13d74:	2300      	movs	r3, #0
   13d76:	6043      	str	r3, [r0, #4]
    pstNode->pstPrev = (LOS_DL_LIST *)NULL;
   13d78:	6003      	str	r3, [r0, #0]

VOID osPriqueueDequeue(LOS_DL_LIST *ptrPQItem)
{
    LOS_ListDelete(ptrPQItem);
}
   13d7a:	4770      	bx	lr

00013d7c <osPriqueueTop>:
{
    UINT32 uwPri = 0;

    for (uwPri = 0; uwPri < OS_PRIORITY_QUEUE_PRIORITYNUM; ++uwPri)
    {
        if (!LOS_ListEmpty(&g_pstLosPriorityQueueList[uwPri]))
   13d7c:	4b06      	ldr	r3, [pc, #24]	; (13d98 <osPriqueueTop+0x1c>)
   13d7e:	681b      	ldr	r3, [r3, #0]
   13d80:	1c5a      	adds	r2, r3, #1
   13d82:	32ff      	adds	r2, #255	; 0xff
    return (BOOL)(pstList->pstNext == pstList);
   13d84:	6858      	ldr	r0, [r3, #4]
   13d86:	4283      	cmp	r3, r0
   13d88:	d104      	bne.n	13d94 <osPriqueueTop+0x18>
   13d8a:	0003      	movs	r3, r0
   13d8c:	3308      	adds	r3, #8
    for (uwPri = 0; uwPri < OS_PRIORITY_QUEUE_PRIORITYNUM; ++uwPri)
   13d8e:	429a      	cmp	r2, r3
   13d90:	d1f8      	bne.n	13d84 <osPriqueueTop+0x8>
        {
            return LOS_DL_LIST_FIRST(&g_pstLosPriorityQueueList[uwPri]);
        }
    }

    return (LOS_DL_LIST *)NULL;
   13d92:	2000      	movs	r0, #0
}
   13d94:	4770      	bx	lr
   13d96:	46c0      	nop			; (mov r8, r8)
   13d98:	01002e9c 	.word	0x01002e9c

00013d9c <osPriqueueSize>:
UINT32 osPriqueueSize(UINT32 uwPri)
{
    UINT32      uwItemCnt = 0;
    LOS_DL_LIST *pstCurPQNode = (LOS_DL_LIST *)NULL;

    LOS_DL_LIST_FOR_EACH(pstCurPQNode, &g_pstLosPriorityQueueList[uwPri])
   13d9c:	4b05      	ldr	r3, [pc, #20]	; (13db4 <osPriqueueSize+0x18>)
   13d9e:	00c0      	lsls	r0, r0, #3
   13da0:	681b      	ldr	r3, [r3, #0]
   13da2:	181b      	adds	r3, r3, r0
    UINT32      uwItemCnt = 0;
   13da4:	2000      	movs	r0, #0
    LOS_DL_LIST_FOR_EACH(pstCurPQNode, &g_pstLosPriorityQueueList[uwPri])
   13da6:	685a      	ldr	r2, [r3, #4]
   13da8:	4293      	cmp	r3, r2
   13daa:	d100      	bne.n	13dae <osPriqueueSize+0x12>
    {
        ++uwItemCnt;
    }

    return uwItemCnt;
}
   13dac:	4770      	bx	lr
        ++uwItemCnt;
   13dae:	3001      	adds	r0, #1
    LOS_DL_LIST_FOR_EACH(pstCurPQNode, &g_pstLosPriorityQueueList[uwPri])
   13db0:	6852      	ldr	r2, [r2, #4]
   13db2:	e7f9      	b.n	13da8 <osPriqueueSize+0xc>
   13db4:	01002e9c 	.word	0x01002e9c

00013db8 <osSwTmrTask>:
Input      : None
Output     : None
Return     : None
*****************************************************************************/
LITE_OS_SEC_TEXT VOID osSwTmrTask(VOID)
{
   13db8:	b530      	push	{r4, r5, lr}

    for ( ; ; )
    {
        memset(&stSwtmrHandle, 0, sizeof(SWTMR_HANDLER_ITEM_S));
        uwReadSzie = sizeof(SWTMR_HANDLER_ITEM_S);
        uwRet = LOS_QueueReadCopy(m_uwSwTmrHandlerQueue, &stSwtmrHandle, &uwReadSzie, LOS_WAIT_FOREVER);
   13dba:	2501      	movs	r5, #1
        memset(&stSwtmrHandle, 0, sizeof(SWTMR_HANDLER_ITEM_S));
   13dbc:	2408      	movs	r4, #8
{
   13dbe:	b085      	sub	sp, #20
        uwRet = LOS_QueueReadCopy(m_uwSwTmrHandlerQueue, &stSwtmrHandle, &uwReadSzie, LOS_WAIT_FOREVER);
   13dc0:	426d      	negs	r5, r5
        memset(&stSwtmrHandle, 0, sizeof(SWTMR_HANDLER_ITEM_S));
   13dc2:	0022      	movs	r2, r4
   13dc4:	2100      	movs	r1, #0
   13dc6:	a802      	add	r0, sp, #8
   13dc8:	f7ec fa8a 	bl	2e0 <memset>
        uwRet = LOS_QueueReadCopy(m_uwSwTmrHandlerQueue, &stSwtmrHandle, &uwReadSzie, LOS_WAIT_FOREVER);
   13dcc:	4809      	ldr	r0, [pc, #36]	; (13df4 <osSwTmrTask+0x3c>)
   13dce:	002b      	movs	r3, r5
   13dd0:	aa01      	add	r2, sp, #4
   13dd2:	a902      	add	r1, sp, #8
   13dd4:	6800      	ldr	r0, [r0, #0]
        uwReadSzie = sizeof(SWTMR_HANDLER_ITEM_S);
   13dd6:	9401      	str	r4, [sp, #4]
        uwRet = LOS_QueueReadCopy(m_uwSwTmrHandlerQueue, &stSwtmrHandle, &uwReadSzie, LOS_WAIT_FOREVER);
   13dd8:	f000 fb9a 	bl	14510 <LOS_QueueReadCopy>
        if (uwRet == LOS_OK && uwReadSzie == sizeof(SWTMR_HANDLER_ITEM_S))
   13ddc:	2800      	cmp	r0, #0
   13dde:	d1f0      	bne.n	13dc2 <osSwTmrTask+0xa>
   13de0:	9b01      	ldr	r3, [sp, #4]
   13de2:	2b08      	cmp	r3, #8
   13de4:	d1ed      	bne.n	13dc2 <osSwTmrTask+0xa>
        {
            if (stSwtmrHandle.pfnHandler != NULL)
   13de6:	9b02      	ldr	r3, [sp, #8]
   13de8:	2b00      	cmp	r3, #0
   13dea:	d0ea      	beq.n	13dc2 <osSwTmrTask+0xa>
            {
                stSwtmrHandle.pfnHandler(stSwtmrHandle.uwArg);
   13dec:	9803      	ldr	r0, [sp, #12]
   13dee:	4798      	blx	r3
   13df0:	e7e7      	b.n	13dc2 <osSwTmrTask+0xa>
   13df2:	46c0      	nop			; (mov r8, r8)
   13df4:	01002ea8 	.word	0x01002ea8

00013df8 <osSwTmrTaskCreate>:
Input      : None
Output     : None
Return     : LOS_OK on success or error code on failure
*****************************************************************************/
LITE_OS_SEC_TEXT_INIT UINT32 osSwTmrTaskCreate(VOID)
{
   13df8:	b510      	push	{r4, lr}
   13dfa:	b086      	sub	sp, #24
    UINT32 uwRet;
    TSK_INIT_PARAM_S stSwTmrTask;

    (VOID)memset(&stSwTmrTask, 0, sizeof(TSK_INIT_PARAM_S));
   13dfc:	ac01      	add	r4, sp, #4
   13dfe:	2214      	movs	r2, #20
   13e00:	2100      	movs	r1, #0
   13e02:	0020      	movs	r0, r4
   13e04:	f7ec fa6c 	bl	2e0 <memset>
    stSwTmrTask.pfnTaskEntry    = (TSK_ENTRY_FUNC)osSwTmrTask;
   13e08:	4b08      	ldr	r3, [pc, #32]	; (13e2c <osSwTmrTaskCreate+0x34>)
    stSwTmrTask.uwStackSize     = SIZE(0x400);
    stSwTmrTask.pcName          = "Swt_Task";
    stSwTmrTask.usTaskPrio      = 0;
    stSwTmrTask.uwResved        = LOS_TASK_STATUS_DETACHED;
    uwRet = LOS_TaskCreate(&g_uwSwtmrTaskID, &stSwTmrTask);
   13e0a:	0021      	movs	r1, r4
    stSwTmrTask.pfnTaskEntry    = (TSK_ENTRY_FUNC)osSwTmrTask;
   13e0c:	9301      	str	r3, [sp, #4]
    stSwTmrTask.uwStackSize     = SIZE(0x400);
   13e0e:	2380      	movs	r3, #128	; 0x80
   13e10:	00db      	lsls	r3, r3, #3
   13e12:	60a3      	str	r3, [r4, #8]
    stSwTmrTask.pcName          = "Swt_Task";
   13e14:	4b06      	ldr	r3, [pc, #24]	; (13e30 <osSwTmrTaskCreate+0x38>)
    uwRet = LOS_TaskCreate(&g_uwSwtmrTaskID, &stSwTmrTask);
   13e16:	4807      	ldr	r0, [pc, #28]	; (13e34 <osSwTmrTaskCreate+0x3c>)
    stSwTmrTask.pcName          = "Swt_Task";
   13e18:	60e3      	str	r3, [r4, #12]
    stSwTmrTask.usTaskPrio      = 0;
   13e1a:	2300      	movs	r3, #0
   13e1c:	80a3      	strh	r3, [r4, #4]
    stSwTmrTask.uwResved        = LOS_TASK_STATUS_DETACHED;
   13e1e:	3380      	adds	r3, #128	; 0x80
   13e20:	6123      	str	r3, [r4, #16]
    uwRet = LOS_TaskCreate(&g_uwSwtmrTaskID, &stSwTmrTask);
   13e22:	f7ff fb19 	bl	13458 <LOS_TaskCreate>
    return uwRet;
}
   13e26:	b006      	add	sp, #24
   13e28:	bd10      	pop	{r4, pc}
   13e2a:	46c0      	nop			; (mov r8, r8)
   13e2c:	00013db9 	.word	0x00013db9
   13e30:	000254d7 	.word	0x000254d7
   13e34:	01002e50 	.word	0x01002e50

00013e38 <osSwTmrInit>:
Input      : None
Output     : None
Return     : LOS_OK on success or error code on failure
*****************************************************************************/
LITE_OS_SEC_TEXT_INIT UINT32 osSwTmrInit(VOID)
{
   13e38:	b537      	push	{r0, r1, r2, r4, r5, lr}
    if (0 == LOSCFG_BASE_CORE_SWTMR_LIMIT)  /*lint !e506*/
    {
        return LOS_ERRNO_SWTMR_MAXSIZE_INVALID;
    }

    m_pstSwtmrSortList = (SWTMR_CTRL_S *)NULL;
   13e3a:	2500      	movs	r5, #0
    uwSize = sizeof(SWTMR_CTRL_S) * LOSCFG_BASE_CORE_SWTMR_LIMIT;
    pstSwtmr = (SWTMR_CTRL_S *)LOS_MemAlloc(m_aucSysMem0, uwSize);
   13e3c:	2198      	movs	r1, #152	; 0x98
    m_pstSwtmrSortList = (SWTMR_CTRL_S *)NULL;
   13e3e:	4b1b      	ldr	r3, [pc, #108]	; (13eac <osSwTmrInit+0x74>)
    pstSwtmr = (SWTMR_CTRL_S *)LOS_MemAlloc(m_aucSysMem0, uwSize);
   13e40:	0089      	lsls	r1, r1, #2
    m_pstSwtmrSortList = (SWTMR_CTRL_S *)NULL;
   13e42:	601d      	str	r5, [r3, #0]
    pstSwtmr = (SWTMR_CTRL_S *)LOS_MemAlloc(m_aucSysMem0, uwSize);
   13e44:	4b1a      	ldr	r3, [pc, #104]	; (13eb0 <osSwTmrInit+0x78>)
   13e46:	6818      	ldr	r0, [r3, #0]
   13e48:	f7fe fe4c 	bl	12ae4 <LOS_MemAlloc>
   13e4c:	0004      	movs	r4, r0
    if (NULL == pstSwtmr)
   13e4e:	42a8      	cmp	r0, r5
   13e50:	d027      	beq.n	13ea2 <osSwTmrInit+0x6a>
    {
        return LOS_ERRNO_SWTMR_NO_MEMORY;
    }

    (VOID)memset((void *)pstSwtmr, 0, uwSize);
   13e52:	2298      	movs	r2, #152	; 0x98
   13e54:	0029      	movs	r1, r5
   13e56:	0092      	lsls	r2, r2, #2
   13e58:	f7ec fa42 	bl	2e0 <memset>
    m_pstSwtmrCBArray = pstSwtmr;
   13e5c:	4b15      	ldr	r3, [pc, #84]	; (13eb4 <osSwTmrInit+0x7c>)
    m_pstSwtmrFreeList = pstSwtmr;
    pstSwtmr->usTimerID = 0;
    pstTemp = pstSwtmr;
    pstSwtmr++;
    for (usIndex = 1; usIndex < LOSCFG_BASE_CORE_SWTMR_LIMIT; usIndex++, pstSwtmr++)
   13e5e:	2101      	movs	r1, #1
    m_pstSwtmrCBArray = pstSwtmr;
   13e60:	601c      	str	r4, [r3, #0]
    m_pstSwtmrFreeList = pstSwtmr;
   13e62:	4b15      	ldr	r3, [pc, #84]	; (13eb8 <osSwTmrInit+0x80>)
    pstSwtmr->usTimerID = 0;
   13e64:	8125      	strh	r5, [r4, #8]
    m_pstSwtmrFreeList = pstSwtmr;
   13e66:	601c      	str	r4, [r3, #0]
    pstSwtmr++;
   13e68:	0023      	movs	r3, r4
   13e6a:	3320      	adds	r3, #32
    {
        pstSwtmr->usTimerID = usIndex;
        pstTemp->pstNext = pstSwtmr;
   13e6c:	001a      	movs	r2, r3
        pstSwtmr->usTimerID = usIndex;
   13e6e:	8119      	strh	r1, [r3, #8]
    for (usIndex = 1; usIndex < LOSCFG_BASE_CORE_SWTMR_LIMIT; usIndex++, pstSwtmr++)
   13e70:	3101      	adds	r1, #1
        pstTemp->pstNext = pstSwtmr;
   13e72:	3a20      	subs	r2, #32
    for (usIndex = 1; usIndex < LOSCFG_BASE_CORE_SWTMR_LIMIT; usIndex++, pstSwtmr++)
   13e74:	b289      	uxth	r1, r1
        pstTemp->pstNext = pstSwtmr;
   13e76:	6013      	str	r3, [r2, #0]
    for (usIndex = 1; usIndex < LOSCFG_BASE_CORE_SWTMR_LIMIT; usIndex++, pstSwtmr++)
   13e78:	3320      	adds	r3, #32
   13e7a:	2913      	cmp	r1, #19
   13e7c:	d1f6      	bne.n	13e6c <osSwTmrInit+0x34>
        pstTemp = pstSwtmr;
    }
    pstTemp->pstNext = (struct tagSwTmrCtrl *)NULL;
   13e7e:	2390      	movs	r3, #144	; 0x90
   13e80:	2000      	movs	r0, #0
   13e82:	009b      	lsls	r3, r3, #2
   13e84:	50e0      	str	r0, [r4, r3]

    uwRet = LOS_QueueCreate((CHAR *)NULL, OS_SWTMR_HANDLE_QUEUE_SIZE, &m_uwSwTmrHandlerQueue, 0, sizeof(SWTMR_HANDLER_ITEM_S));
   13e86:	2308      	movs	r3, #8
   13e88:	4a0c      	ldr	r2, [pc, #48]	; (13ebc <osSwTmrInit+0x84>)
   13e8a:	9300      	str	r3, [sp, #0]
   13e8c:	0003      	movs	r3, r0
   13e8e:	f000 fa0b 	bl	142a8 <LOS_QueueCreate>
    if (uwRet != LOS_OK)
   13e92:	2800      	cmp	r0, #0
   13e94:	d107      	bne.n	13ea6 <osSwTmrInit+0x6e>
    {
        return LOS_ERRNO_SWTMR_QUEUE_CREATE_FAILED;
    }

    uwRet = osSwTmrTaskCreate();
   13e96:	f7ff ffaf 	bl	13df8 <osSwTmrTaskCreate>
    if (LOS_OK != uwRet)
   13e9a:	2800      	cmp	r0, #0
   13e9c:	d002      	beq.n	13ea4 <osSwTmrInit+0x6c>
    {
        return LOS_ERRNO_SWTMR_TASK_CREATE_FAILED;
   13e9e:	4808      	ldr	r0, [pc, #32]	; (13ec0 <osSwTmrInit+0x88>)
   13ea0:	e000      	b.n	13ea4 <osSwTmrInit+0x6c>
        return LOS_ERRNO_SWTMR_NO_MEMORY;
   13ea2:	4808      	ldr	r0, [pc, #32]	; (13ec4 <osSwTmrInit+0x8c>)
    }

    return LOS_OK;
}
   13ea4:	bd3e      	pop	{r1, r2, r3, r4, r5, pc}
        return LOS_ERRNO_SWTMR_QUEUE_CREATE_FAILED;
   13ea6:	4808      	ldr	r0, [pc, #32]	; (13ec8 <osSwTmrInit+0x90>)
   13ea8:	e7fc      	b.n	13ea4 <osSwTmrInit+0x6c>
   13eaa:	46c0      	nop			; (mov r8, r8)
   13eac:	01002eac 	.word	0x01002eac
   13eb0:	01002e40 	.word	0x01002e40
   13eb4:	01002ea4 	.word	0x01002ea4
   13eb8:	01002ea0 	.word	0x01002ea0
   13ebc:	01002ea8 	.word	0x01002ea8
   13ec0:	0200030c 	.word	0x0200030c
   13ec4:	02000307 	.word	0x02000307
   13ec8:	0200030b 	.word	0x0200030b

00013ecc <osSwTmrStart>:
LITE_OS_SEC_TEXT VOID osSwTmrStart(SWTMR_CTRL_S *pstSwtmr)
{
    SWTMR_CTRL_S *pstPrev = (SWTMR_CTRL_S *)NULL;
    SWTMR_CTRL_S *pstCur = (SWTMR_CTRL_S *)NULL;

    if (pstSwtmr->ucOverrun == 0 && (pstSwtmr->ucMode == LOS_SWTMR_MODE_ONCE || pstSwtmr->ucMode == LOS_SWTMR_MODE_OPP ||
   13ecc:	7983      	ldrb	r3, [r0, #6]
{
   13ece:	b530      	push	{r4, r5, lr}
    if (pstSwtmr->ucOverrun == 0 && (pstSwtmr->ucMode == LOS_SWTMR_MODE_ONCE || pstSwtmr->ucMode == LOS_SWTMR_MODE_OPP ||
   13ed0:	2b00      	cmp	r3, #0
   13ed2:	d119      	bne.n	13f08 <osSwTmrStart+0x3c>
   13ed4:	7943      	ldrb	r3, [r0, #5]
   13ed6:	2b00      	cmp	r3, #0
   13ed8:	d002      	beq.n	13ee0 <osSwTmrStart+0x14>
   13eda:	3b02      	subs	r3, #2
   13edc:	2b01      	cmp	r3, #1
   13ede:	d813      	bhi.n	13f08 <osSwTmrStart+0x3c>
        pstSwtmr->ucMode == LOS_SWTMR_MODE_NO_SELFDELETE))
    {
        pstSwtmr->uwCount = pstSwtmr->uwExpiry;
   13ee0:	6943      	ldr	r3, [r0, #20]
    SWTMR_CTRL_S *pstPrev = (SWTMR_CTRL_S *)NULL;
   13ee2:	2100      	movs	r1, #0
    }
    else
    {
        pstSwtmr->uwCount = pstSwtmr->uwInterval;
    }
    pstCur = m_pstSwtmrSortList;
   13ee4:	4c0f      	ldr	r4, [pc, #60]	; (13f24 <osSwTmrStart+0x58>)
        pstSwtmr->uwCount = pstSwtmr->uwInterval;
   13ee6:	60c3      	str	r3, [r0, #12]
    pstCur = m_pstSwtmrSortList;
   13ee8:	6823      	ldr	r3, [r4, #0]

    while (pstCur != NULL)
   13eea:	2b00      	cmp	r3, #0
   13eec:	d10e      	bne.n	13f0c <osSwTmrStart+0x40>
        pstSwtmr->uwCount -= pstCur->uwCount;
        pstPrev = pstCur;
        pstCur = pstCur->pstNext;
    }

    pstSwtmr->pstNext = pstCur;
   13eee:	6003      	str	r3, [r0, #0]

    if (pstCur != NULL)
   13ef0:	2b00      	cmp	r3, #0
   13ef2:	d003      	beq.n	13efc <osSwTmrStart+0x30>
    {
        pstCur->uwCount -= pstSwtmr->uwCount;
   13ef4:	68da      	ldr	r2, [r3, #12]
   13ef6:	68c5      	ldr	r5, [r0, #12]
   13ef8:	1b52      	subs	r2, r2, r5
   13efa:	60da      	str	r2, [r3, #12]
    }

    if (pstPrev == NULL)
   13efc:	2900      	cmp	r1, #0
   13efe:	d10e      	bne.n	13f1e <osSwTmrStart+0x52>
    {
        m_pstSwtmrSortList = pstSwtmr;
   13f00:	6020      	str	r0, [r4, #0]
    else
    {
        pstPrev->pstNext = pstSwtmr;
    }

    pstSwtmr->ucState = OS_SWTMR_STATUS_TICKING;
   13f02:	2302      	movs	r3, #2
   13f04:	7103      	strb	r3, [r0, #4]

    return;
}
   13f06:	bd30      	pop	{r4, r5, pc}
        pstSwtmr->uwCount = pstSwtmr->uwInterval;
   13f08:	6903      	ldr	r3, [r0, #16]
   13f0a:	e7ea      	b.n	13ee2 <osSwTmrStart+0x16>
        if (pstCur->uwCount > pstSwtmr->uwCount)
   13f0c:	68dd      	ldr	r5, [r3, #12]
   13f0e:	68c2      	ldr	r2, [r0, #12]
   13f10:	4295      	cmp	r5, r2
   13f12:	d8ec      	bhi.n	13eee <osSwTmrStart+0x22>
        pstSwtmr->uwCount -= pstCur->uwCount;
   13f14:	1b52      	subs	r2, r2, r5
   13f16:	60c2      	str	r2, [r0, #12]
        pstCur = pstCur->pstNext;
   13f18:	0019      	movs	r1, r3
   13f1a:	681b      	ldr	r3, [r3, #0]
   13f1c:	e7e5      	b.n	13eea <osSwTmrStart+0x1e>
        pstPrev->pstNext = pstSwtmr;
   13f1e:	6008      	str	r0, [r1, #0]
   13f20:	e7ef      	b.n	13f02 <osSwTmrStart+0x36>
   13f22:	46c0      	nop			; (mov r8, r8)
   13f24:	01002eac 	.word	0x01002eac

00013f28 <osSwTmrTimeoutHandle>:
Input      : None
Output     : None
Return     : None
*****************************************************************************/
LITE_OS_SEC_TEXT static VOID osSwTmrTimeoutHandle(VOID)
{
   13f28:	b573      	push	{r0, r1, r4, r5, r6, lr}
	SWTMR_HANDLER_ITEM_S stSwtmrHandler;

    while (pstSwtmr != NULL && pstSwtmr->uwCount == 0)
    {
        m_pstSwtmrSortList = pstSwtmr->pstNext;
        pstSwtmr->ucState = OS_SWTMR_STATUS_CREATED;
   13f2a:	2601      	movs	r6, #1
    SWTMR_CTRL_S *pstSwtmr = m_pstSwtmrSortList;
   13f2c:	4d13      	ldr	r5, [pc, #76]	; (13f7c <osSwTmrTimeoutHandle+0x54>)
   13f2e:	682c      	ldr	r4, [r5, #0]
    while (pstSwtmr != NULL && pstSwtmr->uwCount == 0)
   13f30:	2c00      	cmp	r4, #0
   13f32:	d002      	beq.n	13f3a <osSwTmrTimeoutHandle+0x12>
   13f34:	68e3      	ldr	r3, [r4, #12]
   13f36:	2b00      	cmp	r3, #0
   13f38:	d000      	beq.n	13f3c <osSwTmrTimeoutHandle+0x14>
            osSwTmrStart(pstSwtmr);
        }

        pstSwtmr = m_pstSwtmrSortList;
    }
}
   13f3a:	bd73      	pop	{r0, r1, r4, r5, r6, pc}
        m_pstSwtmrSortList = pstSwtmr->pstNext;
   13f3c:	6822      	ldr	r2, [r4, #0]
        LOS_QueueWriteCopy(m_uwSwTmrHandlerQueue, &stSwtmrHandler, sizeof(SWTMR_HANDLER_ITEM_S), LOS_NO_WAIT);
   13f3e:	4810      	ldr	r0, [pc, #64]	; (13f80 <osSwTmrTimeoutHandle+0x58>)
        m_pstSwtmrSortList = pstSwtmr->pstNext;
   13f40:	602a      	str	r2, [r5, #0]
        stSwtmrHandler.pfnHandler = pstSwtmr->pfnHandler;
   13f42:	69e2      	ldr	r2, [r4, #28]
        pstSwtmr->ucState = OS_SWTMR_STATUS_CREATED;
   13f44:	7126      	strb	r6, [r4, #4]
        stSwtmrHandler.pfnHandler = pstSwtmr->pfnHandler;
   13f46:	9200      	str	r2, [sp, #0]
        stSwtmrHandler.uwArg = pstSwtmr->uwArg;
   13f48:	69a2      	ldr	r2, [r4, #24]
        LOS_QueueWriteCopy(m_uwSwTmrHandlerQueue, &stSwtmrHandler, sizeof(SWTMR_HANDLER_ITEM_S), LOS_NO_WAIT);
   13f4a:	4669      	mov	r1, sp
        stSwtmrHandler.uwArg = pstSwtmr->uwArg;
   13f4c:	9201      	str	r2, [sp, #4]
        LOS_QueueWriteCopy(m_uwSwTmrHandlerQueue, &stSwtmrHandler, sizeof(SWTMR_HANDLER_ITEM_S), LOS_NO_WAIT);
   13f4e:	6800      	ldr	r0, [r0, #0]
   13f50:	2208      	movs	r2, #8
   13f52:	f000 fb09 	bl	14568 <LOS_QueueWriteCopy>
        if (pstSwtmr->ucMode == LOS_SWTMR_MODE_ONCE)
   13f56:	7963      	ldrb	r3, [r4, #5]
   13f58:	2b00      	cmp	r3, #0
   13f5a:	d106      	bne.n	13f6a <osSwTmrTimeoutHandle+0x42>
extern SWTMR_CTRL_S *m_pstSwtmrFreeList;
/*lint -e14 */
INLINE VOID osSwtmrDelete(SWTMR_CTRL_S *pstSwtmr)
{
    /**insert to free list **/
    pstSwtmr->pstNext = m_pstSwtmrFreeList;
   13f5c:	4a09      	ldr	r2, [pc, #36]	; (13f84 <osSwTmrTimeoutHandle+0x5c>)
    m_pstSwtmrFreeList = pstSwtmr;
    pstSwtmr->ucState = OS_SWTMR_STATUS_UNUSED;
   13f5e:	7123      	strb	r3, [r4, #4]
    pstSwtmr->pstNext = m_pstSwtmrFreeList;
   13f60:	6811      	ldr	r1, [r2, #0]
   13f62:	6021      	str	r1, [r4, #0]
    m_pstSwtmrFreeList = pstSwtmr;
   13f64:	6014      	str	r4, [r2, #0]
        pstSwtmr = m_pstSwtmrSortList;
   13f66:	682c      	ldr	r4, [r5, #0]
   13f68:	e7e2      	b.n	13f30 <osSwTmrTimeoutHandle+0x8>
        else if(pstSwtmr->ucMode == LOS_SWTMR_MODE_PERIOD)
   13f6a:	2b01      	cmp	r3, #1
   13f6c:	d1fb      	bne.n	13f66 <osSwTmrTimeoutHandle+0x3e>
            pstSwtmr->ucOverrun++;
   13f6e:	79a3      	ldrb	r3, [r4, #6]
            osSwTmrStart(pstSwtmr);
   13f70:	0020      	movs	r0, r4
            pstSwtmr->ucOverrun++;
   13f72:	3301      	adds	r3, #1
   13f74:	71a3      	strb	r3, [r4, #6]
            osSwTmrStart(pstSwtmr);
   13f76:	f7ff ffa9 	bl	13ecc <osSwTmrStart>
   13f7a:	e7f4      	b.n	13f66 <osSwTmrTimeoutHandle+0x3e>
   13f7c:	01002eac 	.word	0x01002eac
   13f80:	01002ea8 	.word	0x01002ea8
   13f84:	01002ea0 	.word	0x01002ea0

00013f88 <osSwtmrScan>:
Input      : None
Output     : None
Return     : LOS_OK on success or error code on failure
*****************************************************************************/
LITE_OS_SEC_TEXT UINT32 osSwtmrScan(VOID)
{
   13f88:	b510      	push	{r4, lr}
    if (m_pstSwtmrSortList != NULL)
   13f8a:	4b06      	ldr	r3, [pc, #24]	; (13fa4 <osSwtmrScan+0x1c>)
   13f8c:	681a      	ldr	r2, [r3, #0]
   13f8e:	2a00      	cmp	r2, #0
   13f90:	d006      	beq.n	13fa0 <osSwtmrScan+0x18>
    {
        if (--(m_pstSwtmrSortList->uwCount) == 0)
   13f92:	68d3      	ldr	r3, [r2, #12]
   13f94:	3b01      	subs	r3, #1
   13f96:	60d3      	str	r3, [r2, #12]
   13f98:	2b00      	cmp	r3, #0
   13f9a:	d101      	bne.n	13fa0 <osSwtmrScan+0x18>
        {
            osSwTmrTimeoutHandle();
   13f9c:	f7ff ffc4 	bl	13f28 <osSwTmrTimeoutHandle>
        }
    }
    return LOS_OK;
}
   13fa0:	2000      	movs	r0, #0
   13fa2:	bd10      	pop	{r4, pc}
   13fa4:	01002eac 	.word	0x01002eac

00013fa8 <osSwTmrGetNextTimeout>:
Output     : None
Return     : Count of the Timer list
*****************************************************************************/
LITE_OS_SEC_TEXT UINT32 osSwTmrGetNextTimeout(VOID)
{
    if (m_pstSwtmrSortList == NULL)
   13fa8:	4b04      	ldr	r3, [pc, #16]	; (13fbc <osSwTmrGetNextTimeout+0x14>)
   13faa:	681b      	ldr	r3, [r3, #0]
   13fac:	2b00      	cmp	r3, #0
   13fae:	d001      	beq.n	13fb4 <osSwTmrGetNextTimeout+0xc>
    {
        return 0xFFFFFFFF;
    }
    return m_pstSwtmrSortList->uwCount;
   13fb0:	68d8      	ldr	r0, [r3, #12]
}
   13fb2:	4770      	bx	lr
        return 0xFFFFFFFF;
   13fb4:	2001      	movs	r0, #1
   13fb6:	4240      	negs	r0, r0
   13fb8:	e7fb      	b.n	13fb2 <osSwTmrGetNextTimeout+0xa>
   13fba:	46c0      	nop			; (mov r8, r8)
   13fbc:	01002eac 	.word	0x01002eac

00013fc0 <osSwTmrAdjust>:
Input      : sleep_time
Output     : None
Return     : None
*****************************************************************************/
LITE_OS_SEC_TEXT VOID osSwTmrAdjust(UINT32 uwsleep_time)
{
   13fc0:	b510      	push	{r4, lr}
    if (m_pstSwtmrSortList == NULL)
   13fc2:	4b07      	ldr	r3, [pc, #28]	; (13fe0 <osSwTmrAdjust+0x20>)
   13fc4:	681a      	ldr	r2, [r3, #0]
   13fc6:	2a00      	cmp	r2, #0
   13fc8:	d009      	beq.n	13fde <osSwTmrAdjust+0x1e>
    {
        return ;
    }

    if (uwsleep_time > m_pstSwtmrSortList->uwCount)
   13fca:	68d3      	ldr	r3, [r2, #12]
    {
        uwsleep_time = m_pstSwtmrSortList->uwCount;
    }

    m_pstSwtmrSortList->uwCount -= uwsleep_time;
   13fcc:	0019      	movs	r1, r3
   13fce:	4283      	cmp	r3, r0
   13fd0:	d900      	bls.n	13fd4 <osSwTmrAdjust+0x14>
   13fd2:	0001      	movs	r1, r0
   13fd4:	1a5b      	subs	r3, r3, r1
   13fd6:	60d3      	str	r3, [r2, #12]

    if (m_pstSwtmrSortList->uwCount == 0)
   13fd8:	d101      	bne.n	13fde <osSwTmrAdjust+0x1e>
    {
        osSwTmrTimeoutHandle();
   13fda:	f7ff ffa5 	bl	13f28 <osSwTmrTimeoutHandle>
    }
}
   13fde:	bd10      	pop	{r4, pc}
   13fe0:	01002eac 	.word	0x01002eac

00013fe4 <osSwtmrStop>:
Input      : pstSwtmr
Output     : None
Return     : None
*****************************************************************************/
LITE_OS_SEC_TEXT VOID osSwtmrStop(SWTMR_CTRL_S *pstSwtmr)
{
   13fe4:	b530      	push	{r4, r5, lr}
    SWTMR_CTRL_S *pstPrev = (SWTMR_CTRL_S *)NULL;
    SWTMR_CTRL_S *pstCur = (SWTMR_CTRL_S *)NULL;

    if(!m_pstSwtmrSortList)
   13fe6:	4c0e      	ldr	r4, [pc, #56]	; (14020 <osSwtmrStop+0x3c>)
    SWTMR_CTRL_S *pstPrev = (SWTMR_CTRL_S *)NULL;
   13fe8:	2100      	movs	r1, #0
    if(!m_pstSwtmrSortList)
   13fea:	6823      	ldr	r3, [r4, #0]
   13fec:	2b00      	cmp	r3, #0
   13fee:	d102      	bne.n	13ff6 <osSwtmrStop+0x12>
    }

    pstCur->pstNext = (SWTMR_CTRL_S *)NULL;
    pstCur->ucState = OS_SWTMR_STATUS_CREATED;
    pstCur->ucOverrun = 0;
}
   13ff0:	bd30      	pop	{r4, r5, pc}
   13ff2:	0019      	movs	r1, r3
   13ff4:	0013      	movs	r3, r2
   13ff6:	681a      	ldr	r2, [r3, #0]
    while (pstCur != pstSwtmr)
   13ff8:	4283      	cmp	r3, r0
   13ffa:	d1fa      	bne.n	13ff2 <osSwtmrStop+0xe>
    if (pstCur->pstNext != NULL)
   13ffc:	2a00      	cmp	r2, #0
   13ffe:	d003      	beq.n	14008 <osSwtmrStop+0x24>
        pstCur->pstNext->uwCount += pstCur->uwCount;
   14000:	68d0      	ldr	r0, [r2, #12]
   14002:	68dd      	ldr	r5, [r3, #12]
   14004:	1940      	adds	r0, r0, r5
   14006:	60d0      	str	r0, [r2, #12]
   14008:	681a      	ldr	r2, [r3, #0]
    if (pstPrev == NULL)
   1400a:	2900      	cmp	r1, #0
   1400c:	d106      	bne.n	1401c <osSwtmrStop+0x38>
        m_pstSwtmrSortList = pstCur->pstNext;
   1400e:	6022      	str	r2, [r4, #0]
    pstCur->pstNext = (SWTMR_CTRL_S *)NULL;
   14010:	2200      	movs	r2, #0
    pstCur->ucState = OS_SWTMR_STATUS_CREATED;
   14012:	2101      	movs	r1, #1
    pstCur->pstNext = (SWTMR_CTRL_S *)NULL;
   14014:	601a      	str	r2, [r3, #0]
    pstCur->ucState = OS_SWTMR_STATUS_CREATED;
   14016:	7119      	strb	r1, [r3, #4]
    pstCur->ucOverrun = 0;
   14018:	719a      	strb	r2, [r3, #6]
   1401a:	e7e9      	b.n	13ff0 <osSwtmrStop+0xc>
        pstPrev->pstNext = pstCur->pstNext;
   1401c:	600a      	str	r2, [r1, #0]
   1401e:	e7f7      	b.n	14010 <osSwtmrStop+0x2c>
   14020:	01002eac 	.word	0x01002eac

00014024 <LOS_SwtmrCreate>:
LITE_OS_SEC_TEXT_INIT UINT32 LOS_SwtmrCreate(UINT32  uwInterval,
                                        UINT8           ucMode,
                                        SWTMR_PROC_FUNC pfnHandler,
                                        UINT16          *pusSwTmrID,
                                        UINT32          uwArg)
{
   14024:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
   14026:	0005      	movs	r5, r0
   14028:	000e      	movs	r6, r1
   1402a:	0017      	movs	r7, r2
   1402c:	9301      	str	r3, [sp, #4]
    SWTMR_CTRL_S  *pstSwtmr;
    UINTPTR  uvIntSave;

    if (0 == uwInterval)
   1402e:	2800      	cmp	r0, #0
   14030:	d023      	beq.n	1407a <LOS_SwtmrCreate+0x56>
    {
        return LOS_ERRNO_SWTMR_INTERVAL_NOT_SUITED;
    }

    if ((LOS_SWTMR_MODE_ONCE != ucMode) && (LOS_SWTMR_MODE_PERIOD != ucMode) &&
   14032:	2902      	cmp	r1, #2
   14034:	d823      	bhi.n	1407e <LOS_SwtmrCreate+0x5a>
        (LOS_SWTMR_MODE_NO_SELFDELETE != ucMode))
    {
        return LOS_ERRNO_SWTMR_MODE_INVALID;
    }

    if (NULL == pfnHandler)
   14036:	2a00      	cmp	r2, #0
   14038:	d023      	beq.n	14082 <LOS_SwtmrCreate+0x5e>
    {
        return LOS_ERRNO_SWTMR_PTR_NULL;
    }

    if (NULL == pusSwTmrID)
   1403a:	2b00      	cmp	r3, #0
   1403c:	d023      	beq.n	14086 <LOS_SwtmrCreate+0x62>
    {
        return LOS_ERRNO_SWTMR_RET_PTR_NULL;
    }

    uvIntSave = LOS_IntLock();
   1403e:	f7ec f88e 	bl	15e <LOS_IntLock>
    if (NULL == m_pstSwtmrFreeList)
   14042:	4b12      	ldr	r3, [pc, #72]	; (1408c <LOS_SwtmrCreate+0x68>)
   14044:	681c      	ldr	r4, [r3, #0]
   14046:	2c00      	cmp	r4, #0
   14048:	d103      	bne.n	14052 <LOS_SwtmrCreate+0x2e>
    {
        LOS_IntRestore(uvIntSave);
   1404a:	f7ec f890 	bl	16e <LOS_IntRestore>
        return LOS_ERRNO_SWTMR_MAXSIZE;
   1404e:	4810      	ldr	r0, [pc, #64]	; (14090 <LOS_SwtmrCreate+0x6c>)
    pstSwtmr->uwArg         = uwArg;
    pstSwtmr->ucState       = OS_SWTMR_STATUS_CREATED;
    *pusSwTmrID = pstSwtmr->usTimerID;

    return LOS_OK;
}
   14050:	bdfe      	pop	{r1, r2, r3, r4, r5, r6, r7, pc}
    m_pstSwtmrFreeList = pstSwtmr->pstNext;
   14052:	6822      	ldr	r2, [r4, #0]
   14054:	601a      	str	r2, [r3, #0]
    LOS_IntRestore(uvIntSave);
   14056:	f7ec f88a 	bl	16e <LOS_IntRestore>
    pstSwtmr->uwArg         = uwArg;
   1405a:	9b08      	ldr	r3, [sp, #32]
    pstSwtmr->ucOverrun     = 0;
   1405c:	2000      	movs	r0, #0
    pstSwtmr->uwArg         = uwArg;
   1405e:	61a3      	str	r3, [r4, #24]
    pstSwtmr->ucState       = OS_SWTMR_STATUS_CREATED;
   14060:	2301      	movs	r3, #1
    *pusSwTmrID = pstSwtmr->usTimerID;
   14062:	9a01      	ldr	r2, [sp, #4]
    pstSwtmr->ucState       = OS_SWTMR_STATUS_CREATED;
   14064:	7123      	strb	r3, [r4, #4]
    *pusSwTmrID = pstSwtmr->usTimerID;
   14066:	8923      	ldrh	r3, [r4, #8]
    pstSwtmr->pfnHandler    = pfnHandler;
   14068:	61e7      	str	r7, [r4, #28]
    pstSwtmr->ucMode        = ucMode;
   1406a:	7166      	strb	r6, [r4, #5]
    pstSwtmr->ucOverrun     = 0;
   1406c:	71a0      	strb	r0, [r4, #6]
    pstSwtmr->uwInterval    = uwInterval;
   1406e:	6125      	str	r5, [r4, #16]
    pstSwtmr->uwExpiry      = uwInterval;
   14070:	6165      	str	r5, [r4, #20]
    pstSwtmr->pstNext       = (SWTMR_CTRL_S *)NULL;
   14072:	6020      	str	r0, [r4, #0]
    pstSwtmr->uwCount       = 0; //uwInterval;
   14074:	60e0      	str	r0, [r4, #12]
    *pusSwTmrID = pstSwtmr->usTimerID;
   14076:	8013      	strh	r3, [r2, #0]
    return LOS_OK;
   14078:	e7ea      	b.n	14050 <LOS_SwtmrCreate+0x2c>
        return LOS_ERRNO_SWTMR_INTERVAL_NOT_SUITED;
   1407a:	4806      	ldr	r0, [pc, #24]	; (14094 <LOS_SwtmrCreate+0x70>)
   1407c:	e7e8      	b.n	14050 <LOS_SwtmrCreate+0x2c>
        return LOS_ERRNO_SWTMR_MODE_INVALID;
   1407e:	4806      	ldr	r0, [pc, #24]	; (14098 <LOS_SwtmrCreate+0x74>)
   14080:	e7e6      	b.n	14050 <LOS_SwtmrCreate+0x2c>
        return LOS_ERRNO_SWTMR_PTR_NULL;
   14082:	4806      	ldr	r0, [pc, #24]	; (1409c <LOS_SwtmrCreate+0x78>)
   14084:	e7e4      	b.n	14050 <LOS_SwtmrCreate+0x2c>
        return LOS_ERRNO_SWTMR_RET_PTR_NULL;
   14086:	4806      	ldr	r0, [pc, #24]	; (140a0 <LOS_SwtmrCreate+0x7c>)
   14088:	e7e2      	b.n	14050 <LOS_SwtmrCreate+0x2c>
   1408a:	46c0      	nop			; (mov r8, r8)
   1408c:	01002ea0 	.word	0x01002ea0
   14090:	02000304 	.word	0x02000304
   14094:	02000301 	.word	0x02000301
   14098:	02000302 	.word	0x02000302
   1409c:	02000300 	.word	0x02000300
   140a0:	02000303 	.word	0x02000303

000140a4 <LOS_SwtmrStart>:
Input      : usSwTmrID ------- Software timer ID
Output     : None
Return     : LOS_OK on success or error code on failure
*****************************************************************************/
LITE_OS_SEC_TEXT UINT32 LOS_SwtmrStart(UINT16 usSwTmrID)
{
   140a4:	b570      	push	{r4, r5, r6, lr}
   140a6:	0004      	movs	r4, r0
    SWTMR_CTRL_S  *pstSwtmr;
    UINTPTR  uvIntSave;
    UINT32 uwRet = LOS_OK;

    if (usSwTmrID >= LOSCFG_BASE_CORE_SWTMR_LIMIT)
   140a8:	2812      	cmp	r0, #18
   140aa:	d81d      	bhi.n	140e8 <LOS_SwtmrStart+0x44>
    {
        return LOS_ERRNO_SWTMR_ID_INVALID;
    }

    uvIntSave = LOS_IntLock();
   140ac:	f7ec f857 	bl	15e <LOS_IntLock>
    pstSwtmr = m_pstSwtmrCBArray + usSwTmrID;
   140b0:	4a0e      	ldr	r2, [pc, #56]	; (140ec <LOS_SwtmrStart+0x48>)
   140b2:	0163      	lsls	r3, r4, #5
   140b4:	6814      	ldr	r4, [r2, #0]
    uvIntSave = LOS_IntLock();
   140b6:	0005      	movs	r5, r0
    pstSwtmr = m_pstSwtmrCBArray + usSwTmrID;
   140b8:	18e4      	adds	r4, r4, r3

    switch (pstSwtmr->ucState)
   140ba:	7923      	ldrb	r3, [r4, #4]
   140bc:	2b01      	cmp	r3, #1
   140be:	d00c      	beq.n	140da <LOS_SwtmrStart+0x36>
   140c0:	2b00      	cmp	r3, #0
   140c2:	d00f      	beq.n	140e4 <LOS_SwtmrStart+0x40>
   140c4:	2b02      	cmp	r3, #2
   140c6:	d005      	beq.n	140d4 <LOS_SwtmrStart+0x30>
        /* FALLTHRU */
    case OS_SWTMR_STATUS_CREATED: /*lint !e616*/
        osSwTmrStart(pstSwtmr);
        break;
    default:
        uwRet = LOS_ERRNO_SWTMR_STATUS_INVALID;
   140c8:	4c09      	ldr	r4, [pc, #36]	; (140f0 <LOS_SwtmrStart+0x4c>)
        break;
    }

    LOS_IntRestore(uvIntSave);
   140ca:	0028      	movs	r0, r5
   140cc:	f7ec f84f 	bl	16e <LOS_IntRestore>
    return uwRet;
}
   140d0:	0020      	movs	r0, r4
   140d2:	bd70      	pop	{r4, r5, r6, pc}
        osSwtmrStop(pstSwtmr);
   140d4:	0020      	movs	r0, r4
   140d6:	f7ff ff85 	bl	13fe4 <osSwtmrStop>
        osSwTmrStart(pstSwtmr);
   140da:	0020      	movs	r0, r4
   140dc:	f7ff fef6 	bl	13ecc <osSwTmrStart>
    UINT32 uwRet = LOS_OK;
   140e0:	2400      	movs	r4, #0
        break;
   140e2:	e7f2      	b.n	140ca <LOS_SwtmrStart+0x26>
        uwRet = LOS_ERRNO_SWTMR_NOT_CREATED;
   140e4:	4c03      	ldr	r4, [pc, #12]	; (140f4 <LOS_SwtmrStart+0x50>)
   140e6:	e7f0      	b.n	140ca <LOS_SwtmrStart+0x26>
        return LOS_ERRNO_SWTMR_ID_INVALID;
   140e8:	4c03      	ldr	r4, [pc, #12]	; (140f8 <LOS_SwtmrStart+0x54>)
   140ea:	e7f1      	b.n	140d0 <LOS_SwtmrStart+0x2c>
   140ec:	01002ea4 	.word	0x01002ea4
   140f0:	0200030e 	.word	0x0200030e
   140f4:	02000306 	.word	0x02000306
   140f8:	02000305 	.word	0x02000305

000140fc <LOS_SwtmrStop>:
Input      : usSwTmrID ------- Software timer ID
Output     : None
Return     : LOS_OK on success or error code on failure
*****************************************************************************/
LITE_OS_SEC_TEXT UINT32 LOS_SwtmrStop(UINT16 usSwTmrID)
{
   140fc:	b570      	push	{r4, r5, r6, lr}
   140fe:	0004      	movs	r4, r0
    SWTMR_CTRL_S *pstSwtmr;
    UINTPTR uvIntSave;
    UINT32 uwRet = LOS_OK;


    if (usSwTmrID >= LOSCFG_BASE_CORE_SWTMR_LIMIT)
   14100:	2812      	cmp	r0, #18
   14102:	d81b      	bhi.n	1413c <LOS_SwtmrStop+0x40>
    {
        return LOS_ERRNO_SWTMR_ID_INVALID;
    }

    uvIntSave = LOS_IntLock();
   14104:	f7ec f82b 	bl	15e <LOS_IntLock>
    pstSwtmr = m_pstSwtmrCBArray + usSwTmrID;
   14108:	4b0d      	ldr	r3, [pc, #52]	; (14140 <LOS_SwtmrStop+0x44>)
    uvIntSave = LOS_IntLock();
   1410a:	0005      	movs	r5, r0
    pstSwtmr = m_pstSwtmrCBArray + usSwTmrID;
   1410c:	6818      	ldr	r0, [r3, #0]
   1410e:	0164      	lsls	r4, r4, #5
   14110:	1900      	adds	r0, r0, r4

    switch (pstSwtmr->ucState)
   14112:	7903      	ldrb	r3, [r0, #4]
   14114:	2b01      	cmp	r3, #1
   14116:	d005      	beq.n	14124 <LOS_SwtmrStop+0x28>
   14118:	2b00      	cmp	r3, #0
   1411a:	d00d      	beq.n	14138 <LOS_SwtmrStop+0x3c>
   1411c:	2b02      	cmp	r3, #2
   1411e:	d007      	beq.n	14130 <LOS_SwtmrStop+0x34>
        break;
    case OS_SWTMR_STATUS_TICKING:
        osSwtmrStop(pstSwtmr);
        break;
    default:
        uwRet = LOS_ERRNO_SWTMR_STATUS_INVALID;
   14120:	4c08      	ldr	r4, [pc, #32]	; (14144 <LOS_SwtmrStop+0x48>)
        break;
   14122:	e000      	b.n	14126 <LOS_SwtmrStop+0x2a>
        uwRet = LOS_ERRNO_SWTMR_NOT_STARTED;
   14124:	4c08      	ldr	r4, [pc, #32]	; (14148 <LOS_SwtmrStop+0x4c>)
    }

    LOS_IntRestore(uvIntSave);
   14126:	0028      	movs	r0, r5
   14128:	f7ec f821 	bl	16e <LOS_IntRestore>
    return uwRet;
}
   1412c:	0020      	movs	r0, r4
   1412e:	bd70      	pop	{r4, r5, r6, pc}
        osSwtmrStop(pstSwtmr);
   14130:	f7ff ff58 	bl	13fe4 <osSwtmrStop>
    UINT32 uwRet = LOS_OK;
   14134:	2400      	movs	r4, #0
        break;
   14136:	e7f6      	b.n	14126 <LOS_SwtmrStop+0x2a>
        uwRet = LOS_ERRNO_SWTMR_NOT_CREATED;
   14138:	4c04      	ldr	r4, [pc, #16]	; (1414c <LOS_SwtmrStop+0x50>)
   1413a:	e7f4      	b.n	14126 <LOS_SwtmrStop+0x2a>
        return LOS_ERRNO_SWTMR_ID_INVALID;
   1413c:	4c04      	ldr	r4, [pc, #16]	; (14150 <LOS_SwtmrStop+0x54>)
   1413e:	e7f5      	b.n	1412c <LOS_SwtmrStop+0x30>
   14140:	01002ea4 	.word	0x01002ea4
   14144:	0200030e 	.word	0x0200030e
   14148:	0200030d 	.word	0x0200030d
   1414c:	02000306 	.word	0x02000306
   14150:	02000305 	.word	0x02000305

00014154 <LOS_SwtmrDelete>:
Input      : usSwTmrID ------- Software timer ID
Output     : None
Return     : LOS_OK on success or error code on failure
*****************************************************************************/
LITE_OS_SEC_TEXT UINT32 LOS_SwtmrDelete(UINT16 usSwTmrID)
{
   14154:	b570      	push	{r4, r5, r6, lr}
   14156:	0005      	movs	r5, r0
    SWTMR_CTRL_S  *pstSwtmr;
    UINTPTR  uvIntSave;
    UINT32 uwRet = LOS_OK;


    if (usSwTmrID >= LOSCFG_BASE_CORE_SWTMR_LIMIT)
   14158:	2812      	cmp	r0, #18
   1415a:	d81f      	bhi.n	1419c <LOS_SwtmrDelete+0x48>
    {
        return LOS_ERRNO_SWTMR_ID_INVALID;
    }

    uvIntSave = LOS_IntLock();
   1415c:	f7eb ffff 	bl	15e <LOS_IntLock>
    pstSwtmr = m_pstSwtmrCBArray + usSwTmrID;
   14160:	4b0f      	ldr	r3, [pc, #60]	; (141a0 <LOS_SwtmrDelete+0x4c>)
   14162:	016d      	lsls	r5, r5, #5
   14164:	681b      	ldr	r3, [r3, #0]
    uvIntSave = LOS_IntLock();
   14166:	0006      	movs	r6, r0
    pstSwtmr = m_pstSwtmrCBArray + usSwTmrID;
   14168:	195d      	adds	r5, r3, r5

    switch (pstSwtmr->ucState)
   1416a:	792b      	ldrb	r3, [r5, #4]
   1416c:	2b01      	cmp	r3, #1
   1416e:	d00c      	beq.n	1418a <LOS_SwtmrDelete+0x36>
   14170:	2b00      	cmp	r3, #0
   14172:	d011      	beq.n	14198 <LOS_SwtmrDelete+0x44>
   14174:	2b02      	cmp	r3, #2
   14176:	d005      	beq.n	14184 <LOS_SwtmrDelete+0x30>
        /* FALLTHRU */
    case OS_SWTMR_STATUS_CREATED:  /*lint !e616*/
        osSwtmrDelete(pstSwtmr);
        break;
    default:
        uwRet = LOS_ERRNO_SWTMR_STATUS_INVALID;
   14178:	4c0a      	ldr	r4, [pc, #40]	; (141a4 <LOS_SwtmrDelete+0x50>)
        break;
    }

    LOS_IntRestore(uvIntSave);
   1417a:	0030      	movs	r0, r6
   1417c:	f7eb fff7 	bl	16e <LOS_IntRestore>
    return uwRet;
}
   14180:	0020      	movs	r0, r4
   14182:	bd70      	pop	{r4, r5, r6, pc}
        osSwtmrStop(pstSwtmr);
   14184:	0028      	movs	r0, r5
   14186:	f7ff ff2d 	bl	13fe4 <osSwtmrStop>
    pstSwtmr->ucState = OS_SWTMR_STATUS_UNUSED;
   1418a:	2400      	movs	r4, #0
    pstSwtmr->pstNext = m_pstSwtmrFreeList;
   1418c:	4b06      	ldr	r3, [pc, #24]	; (141a8 <LOS_SwtmrDelete+0x54>)
    pstSwtmr->ucState = OS_SWTMR_STATUS_UNUSED;
   1418e:	712c      	strb	r4, [r5, #4]
    pstSwtmr->pstNext = m_pstSwtmrFreeList;
   14190:	681a      	ldr	r2, [r3, #0]
   14192:	602a      	str	r2, [r5, #0]
    m_pstSwtmrFreeList = pstSwtmr;
   14194:	601d      	str	r5, [r3, #0]
   14196:	e7f0      	b.n	1417a <LOS_SwtmrDelete+0x26>
        uwRet = LOS_ERRNO_SWTMR_NOT_CREATED;
   14198:	4c04      	ldr	r4, [pc, #16]	; (141ac <LOS_SwtmrDelete+0x58>)
   1419a:	e7ee      	b.n	1417a <LOS_SwtmrDelete+0x26>
        return LOS_ERRNO_SWTMR_ID_INVALID;
   1419c:	4c04      	ldr	r4, [pc, #16]	; (141b0 <LOS_SwtmrDelete+0x5c>)
   1419e:	e7ef      	b.n	14180 <LOS_SwtmrDelete+0x2c>
   141a0:	01002ea4 	.word	0x01002ea4
   141a4:	0200030e 	.word	0x0200030e
   141a8:	01002ea0 	.word	0x01002ea0
   141ac:	02000306 	.word	0x02000306
   141b0:	02000305 	.word	0x02000305

000141b4 <LOS_Tick2MS>:
Output     : None
Return     : milliseconds
*****************************************************************************/
LITE_OS_SEC_TEXT_MINOR UINT32 LOS_Tick2MS(UINT32 uwTick)
{
    return ((UINT64)uwTick * OS_SYS_MS_PER_SECOND) / LOSCFG_BASE_CORE_TICK_PER_SECOND;
   141b4:	22fa      	movs	r2, #250	; 0xfa
{
   141b6:	b510      	push	{r4, lr}
    return ((UINT64)uwTick * OS_SYS_MS_PER_SECOND) / LOSCFG_BASE_CORE_TICK_PER_SECOND;
   141b8:	0092      	lsls	r2, r2, #2
   141ba:	2300      	movs	r3, #0
   141bc:	2100      	movs	r1, #0
   141be:	f7ec fa91 	bl	6e4 <__aeabi_lmul>
   141c2:	22fa      	movs	r2, #250	; 0xfa
   141c4:	2300      	movs	r3, #0
   141c6:	0092      	lsls	r2, r2, #2
   141c8:	f7ec fa6c 	bl	6a4 <__aeabi_uldivmod>
}
   141cc:	bd10      	pop	{r4, pc}
	...

000141d0 <SysTick_Handler>:

#if (LOSCFG_BASE_CORE_TICK_HW_TIME == YES)
    hal_clock_irqclear();//diff from every platform
#endif

    g_ullTickCount ++;
   141d0:	2201      	movs	r2, #1
   141d2:	2300      	movs	r3, #0
{
   141d4:	b570      	push	{r4, r5, r6, lr}
    g_ullTickCount ++;
   141d6:	4907      	ldr	r1, [pc, #28]	; (141f4 <SysTick_Handler+0x24>)
   141d8:	680c      	ldr	r4, [r1, #0]
   141da:	684d      	ldr	r5, [r1, #4]
   141dc:	1912      	adds	r2, r2, r4
   141de:	416b      	adcs	r3, r5
   141e0:	600a      	str	r2, [r1, #0]
   141e2:	604b      	str	r3, [r1, #4]

#if(LOSCFG_BASE_CORE_TIMESLICE == YES)
    osTimesliceCheck();
   141e4:	f000 f810 	bl	14208 <osTimesliceCheck>
#endif

    osTaskScan(1);   //task timeout scan
   141e8:	2001      	movs	r0, #1
   141ea:	f7fe ff1b 	bl	13024 <osTaskScan>

#if (LOSCFG_BASE_CORE_SWTMR == YES)
    (VOID)osSwtmrScan();
   141ee:	f7ff fecb 	bl	13f88 <osSwtmrScan>
#endif
}
   141f2:	bd70      	pop	{r4, r5, r6, pc}
   141f4:	01002eb0 	.word	0x01002eb0

000141f8 <osTimesliceInit>:
 Output       : None
 Return       : None
 *****************************************************************************/
LITE_OS_SEC_TEXT_INIT VOID osTimesliceInit(VOID)
{
    g_stTaskTimeSlice.pstTask = (LOS_TASK_CB *)NULL;
   141f8:	2200      	movs	r2, #0
   141fa:	4b02      	ldr	r3, [pc, #8]	; (14204 <osTimesliceInit+0xc>)
   141fc:	601a      	str	r2, [r3, #0]
    g_stTaskTimeSlice.usTout = LOSCFG_BASE_CORE_TIMESLICE_TIMEOUT;
   141fe:	320a      	adds	r2, #10
   14200:	80da      	strh	r2, [r3, #6]
}
   14202:	4770      	bx	lr
   14204:	01002ec0 	.word	0x01002ec0

00014208 <osTimesliceCheck>:
 Input        : None
 Output       : None
 Return       : None
 *****************************************************************************/
LITE_OS_SEC_TEXT VOID osTimesliceCheck(VOID)
{
   14208:	b510      	push	{r4, lr}
    if (g_stTaskTimeSlice.pstTask != g_stLosTask.pstRunTask)
   1420a:	4b0b      	ldr	r3, [pc, #44]	; (14238 <osTimesliceCheck+0x30>)
   1420c:	681a      	ldr	r2, [r3, #0]
   1420e:	4b0b      	ldr	r3, [pc, #44]	; (1423c <osTimesliceCheck+0x34>)
   14210:	6819      	ldr	r1, [r3, #0]
   14212:	4b0b      	ldr	r3, [pc, #44]	; (14240 <osTimesliceCheck+0x38>)
   14214:	b289      	uxth	r1, r1
   14216:	6818      	ldr	r0, [r3, #0]
   14218:	4290      	cmp	r0, r2
   1421a:	d004      	beq.n	14226 <osTimesliceCheck+0x1e>
    {
        g_stTaskTimeSlice.pstTask = g_stLosTask.pstRunTask;
   1421c:	601a      	str	r2, [r3, #0]
        g_stTaskTimeSlice.usTime = (UINT16)g_ullTickCount + g_stTaskTimeSlice.usTout - 1;
   1421e:	88da      	ldrh	r2, [r3, #6]
   14220:	3a01      	subs	r2, #1
   14222:	188a      	adds	r2, r1, r2
   14224:	809a      	strh	r2, [r3, #4]
    }

    if (g_stTaskTimeSlice.usTime == (UINT16)g_ullTickCount)
   14226:	889a      	ldrh	r2, [r3, #4]
   14228:	428a      	cmp	r2, r1
   1422a:	d103      	bne.n	14234 <osTimesliceCheck+0x2c>
    {
        g_stTaskTimeSlice.pstTask = (LOS_TASK_CB *)NULL;
   1422c:	2200      	movs	r2, #0
   1422e:	601a      	str	r2, [r3, #0]
        if (LOS_TaskYield() != LOS_OK)
   14230:	f7ff f9b4 	bl	1359c <LOS_TaskYield>
        {
            PRINT_INFO("%s, %d\n", __FUNCTION__, __LINE__);
        }
    } /*lint !e548*/
}
   14234:	bd10      	pop	{r4, pc}
   14236:	46c0      	nop			; (mov r8, r8)
   14238:	01002e70 	.word	0x01002e70
   1423c:	01002eb0 	.word	0x01002eb0
   14240:	01002ec0 	.word	0x01002ec0

00014244 <osQueueInit>:
    if (0 == LOSCFG_BASE_IPC_QUEUE_LIMIT)   /*lint !e506*/
    {
        return LOS_ERRNO_QUEUE_MAXNUM_ZERO;
    }

    g_pstAllQueue = (QUEUE_CB_S *)LOS_MemAlloc(m_aucSysMem0, LOSCFG_BASE_IPC_QUEUE_LIMIT * sizeof(QUEUE_CB_S));
   14244:	21a5      	movs	r1, #165	; 0xa5
{
   14246:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    g_pstAllQueue = (QUEUE_CB_S *)LOS_MemAlloc(m_aucSysMem0, LOSCFG_BASE_IPC_QUEUE_LIMIT * sizeof(QUEUE_CB_S));
   14248:	4b13      	ldr	r3, [pc, #76]	; (14298 <osQueueInit+0x54>)
   1424a:	0089      	lsls	r1, r1, #2
   1424c:	6818      	ldr	r0, [r3, #0]
   1424e:	f7fe fc49 	bl	12ae4 <LOS_MemAlloc>
   14252:	4c12      	ldr	r4, [pc, #72]	; (1429c <osQueueInit+0x58>)
   14254:	6020      	str	r0, [r4, #0]
    if (NULL == g_pstAllQueue)
   14256:	2800      	cmp	r0, #0
   14258:	d01c      	beq.n	14294 <osQueueInit+0x50>
    {
        return LOS_ERRNO_QUEUE_NO_MEMORY;
    }

    (VOID)memset(g_pstAllQueue, 0, LOSCFG_BASE_IPC_QUEUE_LIMIT * sizeof(QUEUE_CB_S));
   1425a:	22a5      	movs	r2, #165	; 0xa5
   1425c:	2100      	movs	r1, #0
   1425e:	0092      	lsls	r2, r2, #2
   14260:	f7ec f83e 	bl	2e0 <memset>

    LOS_ListInit(&g_stFreeQueueList);
    for (usIndex = 0; usIndex < LOSCFG_BASE_IPC_QUEUE_LIMIT; usIndex++)
    {
        pstQueueNode = ((QUEUE_CB_S *)g_pstAllQueue) + usIndex;
   14264:	262c      	movs	r6, #44	; 0x2c
    pstList->pstPrev = pstList;
   14266:	2200      	movs	r2, #0
    pstList->pstNext = pstList;
   14268:	490d      	ldr	r1, [pc, #52]	; (142a0 <osQueueInit+0x5c>)
   1426a:	6049      	str	r1, [r1, #4]
    pstList->pstPrev = pstList;
   1426c:	6009      	str	r1, [r1, #0]
   1426e:	0033      	movs	r3, r6
   14270:	4353      	muls	r3, r2
   14272:	6820      	ldr	r0, [r4, #0]
   14274:	18c3      	adds	r3, r0, r3
        pstQueueNode->usQueueID = usIndex;
        LOS_ListTailInsert(&g_stFreeQueueList, &pstQueueNode->stReadWriteList[OS_QUEUE_WRITE]);
   14276:	001d      	movs	r5, r3
   14278:	6808      	ldr	r0, [r1, #0]
        pstQueueNode->usQueueID = usIndex;
   1427a:	815a      	strh	r2, [r3, #10]
    pstNode->pstNext = pstList->pstNext;
   1427c:	6847      	ldr	r7, [r0, #4]
    pstNode->pstPrev = pstList;
   1427e:	61d8      	str	r0, [r3, #28]
    pstNode->pstNext = pstList->pstNext;
   14280:	621f      	str	r7, [r3, #32]
    pstList->pstNext->pstPrev = pstNode;
   14282:	6843      	ldr	r3, [r0, #4]
        LOS_ListTailInsert(&g_stFreeQueueList, &pstQueueNode->stReadWriteList[OS_QUEUE_WRITE]);
   14284:	351c      	adds	r5, #28
   14286:	3201      	adds	r2, #1
   14288:	601d      	str	r5, [r3, #0]
    pstList->pstNext = pstNode;
   1428a:	6045      	str	r5, [r0, #4]
    for (usIndex = 0; usIndex < LOSCFG_BASE_IPC_QUEUE_LIMIT; usIndex++)
   1428c:	2a0f      	cmp	r2, #15
   1428e:	d1ee      	bne.n	1426e <osQueueInit+0x2a>
    }

    return LOS_OK;
   14290:	2000      	movs	r0, #0
}
   14292:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
        return LOS_ERRNO_QUEUE_NO_MEMORY;
   14294:	4803      	ldr	r0, [pc, #12]	; (142a4 <osQueueInit+0x60>)
   14296:	e7fc      	b.n	14292 <osQueueInit+0x4e>
   14298:	01002e40 	.word	0x01002e40
   1429c:	01002ed0 	.word	0x01002ed0
   142a0:	01002ec8 	.word	0x01002ec8
   142a4:	02000601 	.word	0x02000601

000142a8 <LOS_QueueCreate>:
LITE_OS_SEC_TEXT_INIT UINT32 LOS_QueueCreate(CHAR *pcQueueName,
                                          UINT16 usLen,
                                          UINT32 *puwQueueID,
                                          UINT32 uwFlags,
                                          UINT16 usMaxMsgSize )
{
   142a8:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
   142aa:	ab08      	add	r3, sp, #32
   142ac:	000d      	movs	r5, r1
   142ae:	0017      	movs	r7, r2
   142b0:	881b      	ldrh	r3, [r3, #0]
    UINT16          usMsgSize = usMaxMsgSize + sizeof(UINT32);

    (VOID)pcQueueName;
    (VOID)uwFlags;

    if (NULL == puwQueueID)
   142b2:	2a00      	cmp	r2, #0
   142b4:	d042      	beq.n	1433c <LOS_QueueCreate+0x94>
    {
        return LOS_ERRNO_QUEUE_CREAT_PTR_NULL;
    }

    if(usMaxMsgSize > OS_NULL_SHORT -4)
   142b6:	4a25      	ldr	r2, [pc, #148]	; (1434c <LOS_QueueCreate+0xa4>)
   142b8:	4293      	cmp	r3, r2
   142ba:	d841      	bhi.n	14340 <LOS_QueueCreate+0x98>
    {
        return LOS_ERRNO_QUEUE_SIZE_TOO_BIG;
    }

    if ((0 == usLen) || (0 == usMaxMsgSize))
   142bc:	2900      	cmp	r1, #0
   142be:	d041      	beq.n	14344 <LOS_QueueCreate+0x9c>
   142c0:	2b00      	cmp	r3, #0
   142c2:	d03f      	beq.n	14344 <LOS_QueueCreate+0x9c>
    UINT16          usMsgSize = usMaxMsgSize + sizeof(UINT32);
   142c4:	3304      	adds	r3, #4
   142c6:	b29b      	uxth	r3, r3
        return LOS_ERRNO_QUEUE_PARA_ISZERO;
    }

    /* Memory allocation is time-consuming, to shorten the time of disable interrupt,
       move the memory allocation to here. */
    pucQueue = (UINT8 *)LOS_MemAlloc(m_aucSysMem0, usLen * usMsgSize);
   142c8:	0019      	movs	r1, r3
   142ca:	4c21      	ldr	r4, [pc, #132]	; (14350 <LOS_QueueCreate+0xa8>)
   142cc:	4369      	muls	r1, r5
   142ce:	6820      	ldr	r0, [r4, #0]
    UINT16          usMsgSize = usMaxMsgSize + sizeof(UINT32);
   142d0:	9301      	str	r3, [sp, #4]
    pucQueue = (UINT8 *)LOS_MemAlloc(m_aucSysMem0, usLen * usMsgSize);
   142d2:	f7fe fc07 	bl	12ae4 <LOS_MemAlloc>
   142d6:	1e06      	subs	r6, r0, #0
    if (NULL == pucQueue)
   142d8:	d036      	beq.n	14348 <LOS_QueueCreate+0xa0>
    {
        return LOS_ERRNO_QUEUE_CREATE_NO_MEMORY;
    }

    uvIntSave = LOS_IntLock();
   142da:	f7eb ff40 	bl	15e <LOS_IntLock>
    return (BOOL)(pstList->pstNext == pstList);
   142de:	4a1d      	ldr	r2, [pc, #116]	; (14354 <LOS_QueueCreate+0xac>)
   142e0:	6853      	ldr	r3, [r2, #4]
    if (LOS_ListEmpty(&g_stFreeQueueList))
   142e2:	4293      	cmp	r3, r2
   142e4:	d107      	bne.n	142f6 <LOS_QueueCreate+0x4e>
    {
        LOS_IntRestore(uvIntSave);
   142e6:	f7eb ff42 	bl	16e <LOS_IntRestore>
        (VOID)LOS_MemFree(m_aucSysMem0, pucQueue);
   142ea:	0031      	movs	r1, r6
   142ec:	6820      	ldr	r0, [r4, #0]
   142ee:	f7fe fc13 	bl	12b18 <LOS_MemFree>
        return LOS_ERRNO_QUEUE_CB_UNAVAILABLE;
   142f2:	4819      	ldr	r0, [pc, #100]	; (14358 <LOS_QueueCreate+0xb0>)
    LOS_IntRestore(uvIntSave);

    *puwQueueID = pstQueueCB->usQueueID;

    return LOS_OK;
}
   142f4:	bdfe      	pop	{r1, r2, r3, r4, r5, r6, r7, pc}
    pstNode->pstNext->pstPrev = pstNode->pstPrev;
   142f6:	685a      	ldr	r2, [r3, #4]
   142f8:	6819      	ldr	r1, [r3, #0]
    pstQueueCB->usQueueLen = usLen;
   142fa:	001c      	movs	r4, r3
   142fc:	6011      	str	r1, [r2, #0]
    pstNode->pstPrev->pstNext = pstNode->pstNext;
   142fe:	681a      	ldr	r2, [r3, #0]
   14300:	6859      	ldr	r1, [r3, #4]
   14302:	3c1c      	subs	r4, #28
   14304:	6051      	str	r1, [r2, #4]
    pstQueueCB->usQueueSize = usMsgSize;
   14306:	466a      	mov	r2, sp
   14308:	8892      	ldrh	r2, [r2, #4]
    pstQueueCB->pucQueue = pucQueue;
   1430a:	6026      	str	r6, [r4, #0]
    pstQueueCB->usQueueSize = usMsgSize;
   1430c:	8122      	strh	r2, [r4, #8]
    pstQueueCB->usQueueState = OS_QUEUE_INUSED;
   1430e:	2201      	movs	r2, #1
   14310:	80a2      	strh	r2, [r4, #4]
    LOS_ListInit(&pstQueueCB->stReadWriteList[OS_QUEUE_READ]);
   14312:	001a      	movs	r2, r3
    pstQueueCB->usReadWriteableCnt[OS_QUEUE_READ]  = 0;
   14314:	2600      	movs	r6, #0
    LOS_ListInit(&pstQueueCB->stReadWriteList[OS_QUEUE_READ]);
   14316:	3a08      	subs	r2, #8
    pstQueueCB->usQueueLen = usLen;
   14318:	80e5      	strh	r5, [r4, #6]
    pstQueueCB->usReadWriteableCnt[OS_QUEUE_READ]  = 0;
   1431a:	8226      	strh	r6, [r4, #16]
    pstQueueCB->usReadWriteableCnt[OS_QUEUE_WRITE] = usLen;
   1431c:	8265      	strh	r5, [r4, #18]
    pstQueueCB->usQueueHead = 0;
   1431e:	81a6      	strh	r6, [r4, #12]
    pstQueueCB->usQueueTail = 0;
   14320:	81e6      	strh	r6, [r4, #14]
    pstList->pstNext = pstList;
   14322:	6052      	str	r2, [r2, #4]
    pstList->pstPrev = pstList;
   14324:	6012      	str	r2, [r2, #0]
    LOS_ListInit(&pstQueueCB->stMemList);
   14326:	3210      	adds	r2, #16
    pstList->pstNext = pstList;
   14328:	605b      	str	r3, [r3, #4]
    pstList->pstPrev = pstList;
   1432a:	601b      	str	r3, [r3, #0]
    pstList->pstNext = pstList;
   1432c:	60da      	str	r2, [r3, #12]
    pstList->pstPrev = pstList;
   1432e:	609a      	str	r2, [r3, #8]
    LOS_IntRestore(uvIntSave);
   14330:	f7eb ff1d 	bl	16e <LOS_IntRestore>
    *puwQueueID = pstQueueCB->usQueueID;
   14334:	8963      	ldrh	r3, [r4, #10]
    return LOS_OK;
   14336:	0030      	movs	r0, r6
    *puwQueueID = pstQueueCB->usQueueID;
   14338:	603b      	str	r3, [r7, #0]
    return LOS_OK;
   1433a:	e7db      	b.n	142f4 <LOS_QueueCreate+0x4c>
        return LOS_ERRNO_QUEUE_CREAT_PTR_NULL;
   1433c:	4807      	ldr	r0, [pc, #28]	; (1435c <LOS_QueueCreate+0xb4>)
   1433e:	e7d9      	b.n	142f4 <LOS_QueueCreate+0x4c>
        return LOS_ERRNO_QUEUE_SIZE_TOO_BIG;
   14340:	4807      	ldr	r0, [pc, #28]	; (14360 <LOS_QueueCreate+0xb8>)
   14342:	e7d7      	b.n	142f4 <LOS_QueueCreate+0x4c>
        return LOS_ERRNO_QUEUE_PARA_ISZERO;
   14344:	4807      	ldr	r0, [pc, #28]	; (14364 <LOS_QueueCreate+0xbc>)
   14346:	e7d5      	b.n	142f4 <LOS_QueueCreate+0x4c>
        return LOS_ERRNO_QUEUE_CREATE_NO_MEMORY;
   14348:	4807      	ldr	r0, [pc, #28]	; (14368 <LOS_QueueCreate+0xc0>)
   1434a:	e7d3      	b.n	142f4 <LOS_QueueCreate+0x4c>
   1434c:	0000fffb 	.word	0x0000fffb
   14350:	01002e40 	.word	0x01002e40
   14354:	01002ec8 	.word	0x01002ec8
   14358:	02000604 	.word	0x02000604
   1435c:	0200060c 	.word	0x0200060c
   14360:	02000603 	.word	0x02000603
   14364:	0200060d 	.word	0x0200060d
   14368:	02000602 	.word	0x02000602

0001436c <osQueueOperate>:
    }
}


UINT32 osQueueOperate(UINT32 uwQueueID, UINT32 uwOperateType, VOID *pBufferAddr, UINT32 *puwBufferSize, UINT32 uwTimeOut)
{
   1436c:	b5f0      	push	{r4, r5, r6, r7, lr}
   1436e:	b087      	sub	sp, #28
   14370:	0004      	movs	r4, r0
   14372:	001e      	movs	r6, r3
   14374:	9102      	str	r1, [sp, #8]
   14376:	9203      	str	r2, [sp, #12]
    UINTPTR      uvIntSave;
    LOS_TASK_CB  *pstResumedTask;
    UINT32       uwRet = LOS_OK;
    UINT32       uwReadWrite = OS_QUEUE_READ_WRITE_GET(uwOperateType);

    uvIntSave = LOS_IntLock();
   14378:	f7eb fef1 	bl	15e <LOS_IntLock>

    pstQueueCB = (QUEUE_CB_S *)GET_QUEUE_HANDLE(uwQueueID);
   1437c:	232c      	movs	r3, #44	; 0x2c
   1437e:	435c      	muls	r4, r3
   14380:	4b5a      	ldr	r3, [pc, #360]	; (144ec <osQueueOperate+0x180>)
    uvIntSave = LOS_IntLock();
   14382:	9001      	str	r0, [sp, #4]
    pstQueueCB = (QUEUE_CB_S *)GET_QUEUE_HANDLE(uwQueueID);
   14384:	681b      	ldr	r3, [r3, #0]
   14386:	191c      	adds	r4, r3, r4
    if (OS_QUEUE_UNUSED == pstQueueCB->usQueueState)
   14388:	88a3      	ldrh	r3, [r4, #4]
   1438a:	2b00      	cmp	r3, #0
   1438c:	d100      	bne.n	14390 <osQueueOperate+0x24>
   1438e:	e0a6      	b.n	144de <osQueueOperate+0x172>
    UINT32       uwReadWrite = OS_QUEUE_READ_WRITE_GET(uwOperateType);
   14390:	2701      	movs	r7, #1
   14392:	9b02      	ldr	r3, [sp, #8]
   14394:	6832      	ldr	r2, [r6, #0]
   14396:	401f      	ands	r7, r3
   14398:	8923      	ldrh	r3, [r4, #8]
   1439a:	3b04      	subs	r3, #4
        uwRet = LOS_ERRNO_QUEUE_NOT_CREATE;
        goto QUEUE_END;

    }

    if(OS_QUEUE_IS_READ(uwOperateType) && (*puwBufferSize < pstQueueCB->usQueueSize - sizeof(UINT32)))
   1439c:	2f00      	cmp	r7, #0
   1439e:	d113      	bne.n	143c8 <osQueueOperate+0x5c>
   143a0:	4293      	cmp	r3, r2
   143a2:	d900      	bls.n	143a6 <osQueueOperate+0x3a>
   143a4:	e09d      	b.n	144e2 <osQueueOperate+0x176>
   143a6:	007b      	lsls	r3, r7, #1
   143a8:	18e3      	adds	r3, r4, r3
    {
        uwRet = LOS_ERRNO_QUEUE_WRITE_SIZE_TOO_BIG;
        goto QUEUE_END;
    }

    if (0 == pstQueueCB->usReadWriteableCnt[uwReadWrite])
   143aa:	8a1a      	ldrh	r2, [r3, #16]
   143ac:	2a00      	cmp	r2, #0
   143ae:	d12f      	bne.n	14410 <osQueueOperate+0xa4>
    {
        if (LOS_NO_WAIT == uwTimeOut)
   143b0:	9b0c      	ldr	r3, [sp, #48]	; 0x30
   143b2:	2b00      	cmp	r3, #0
   143b4:	d10c      	bne.n	143d0 <osQueueOperate+0x64>
        {
            uwRet = OS_QUEUE_IS_READ(uwOperateType) ? LOS_ERRNO_QUEUE_ISEMPTY : LOS_ERRNO_QUEUE_ISFULL;
   143b6:	3306      	adds	r3, #6
   143b8:	427f      	negs	r7, r7
   143ba:	439f      	bics	r7, r3
   143bc:	4b4c      	ldr	r3, [pc, #304]	; (144f0 <osQueueOperate+0x184>)
   143be:	18ff      	adds	r7, r7, r3
    {
        pstQueueCB->usReadWriteableCnt[!uwReadWrite]++; /*lint !e514*/
    }

QUEUE_END:
    LOS_IntRestore(uvIntSave);
   143c0:	9801      	ldr	r0, [sp, #4]
   143c2:	f7eb fed4 	bl	16e <LOS_IntRestore>
    return uwRet;
   143c6:	e046      	b.n	14456 <osQueueOperate+0xea>
    else if(OS_QUEUE_IS_WRITE(uwOperateType) && (*puwBufferSize > pstQueueCB->usQueueSize - sizeof(UINT32)))
   143c8:	4293      	cmp	r3, r2
   143ca:	d2ec      	bcs.n	143a6 <osQueueOperate+0x3a>
        uwRet = LOS_ERRNO_QUEUE_WRITE_SIZE_TOO_BIG;
   143cc:	4f49      	ldr	r7, [pc, #292]	; (144f4 <osQueueOperate+0x188>)
   143ce:	e7f7      	b.n	143c0 <osQueueOperate+0x54>
        if (g_usLosTaskLock)
   143d0:	4b49      	ldr	r3, [pc, #292]	; (144f8 <osQueueOperate+0x18c>)
   143d2:	881b      	ldrh	r3, [r3, #0]
   143d4:	2b00      	cmp	r3, #0
   143d6:	d000      	beq.n	143da <osQueueOperate+0x6e>
   143d8:	e085      	b.n	144e6 <osQueueOperate+0x17a>
        osTaskWait(&pstQueueCB->stReadWriteList[uwReadWrite], OS_TASK_STATUS_PEND_QUEUE, uwTimeOut);
   143da:	2180      	movs	r1, #128	; 0x80
   143dc:	1cb8      	adds	r0, r7, #2
   143de:	00c0      	lsls	r0, r0, #3
        pstRunTsk = (LOS_TASK_CB *)g_stLosTask.pstRunTask;
   143e0:	4b46      	ldr	r3, [pc, #280]	; (144fc <osQueueOperate+0x190>)
        osTaskWait(&pstQueueCB->stReadWriteList[uwReadWrite], OS_TASK_STATUS_PEND_QUEUE, uwTimeOut);
   143e2:	3004      	adds	r0, #4
   143e4:	9a0c      	ldr	r2, [sp, #48]	; 0x30
   143e6:	0189      	lsls	r1, r1, #6
   143e8:	1820      	adds	r0, r4, r0
        pstRunTsk = (LOS_TASK_CB *)g_stLosTask.pstRunTask;
   143ea:	681d      	ldr	r5, [r3, #0]
        osTaskWait(&pstQueueCB->stReadWriteList[uwReadWrite], OS_TASK_STATUS_PEND_QUEUE, uwTimeOut);
   143ec:	f7ff f890 	bl	13510 <osTaskWait>
        LOS_IntRestore(uvIntSave);
   143f0:	9801      	ldr	r0, [sp, #4]
   143f2:	f7eb febc 	bl	16e <LOS_IntRestore>
        LOS_Schedule();
   143f6:	f7ff fb21 	bl	13a3c <LOS_Schedule>
        uvIntSave = LOS_IntLock();
   143fa:	f7eb feb0 	bl	15e <LOS_IntLock>
        if (pstRunTsk->usTaskStatus & OS_TASK_STATUS_TIMEOUT)
   143fe:	2240      	movs	r2, #64	; 0x40
        uvIntSave = LOS_IntLock();
   14400:	9001      	str	r0, [sp, #4]
        if (pstRunTsk->usTaskStatus & OS_TASK_STATUS_TIMEOUT)
   14402:	88ab      	ldrh	r3, [r5, #4]
   14404:	4213      	tst	r3, r2
   14406:	d005      	beq.n	14414 <osQueueOperate+0xa8>
            pstRunTsk->usTaskStatus &= (~OS_TASK_STATUS_TIMEOUT);
   14408:	4393      	bics	r3, r2
   1440a:	80ab      	strh	r3, [r5, #4]
            uwRet = LOS_ERRNO_QUEUE_TIMEOUT;
   1440c:	4f3c      	ldr	r7, [pc, #240]	; (14500 <osQueueOperate+0x194>)
            goto QUEUE_END;
   1440e:	e7d7      	b.n	143c0 <osQueueOperate+0x54>
        pstQueueCB->usReadWriteableCnt[uwReadWrite]--;
   14410:	3a01      	subs	r2, #1
   14412:	821a      	strh	r2, [r3, #16]
    UINT32       uwMsgDataSize = 0;
   14414:	2200      	movs	r2, #0
    switch (OS_QUEUE_OPERATE_GET(uwOperateType))
   14416:	2303      	movs	r3, #3
   14418:	9902      	ldr	r1, [sp, #8]
    UINT32       uwMsgDataSize = 0;
   1441a:	9205      	str	r2, [sp, #20]
    switch (OS_QUEUE_OPERATE_GET(uwOperateType))
   1441c:	400b      	ands	r3, r1
   1441e:	2b01      	cmp	r3, #1
   14420:	d038      	beq.n	14494 <osQueueOperate+0x128>
   14422:	4293      	cmp	r3, r2
   14424:	d01a      	beq.n	1445c <osQueueOperate+0xf0>
   14426:	2b03      	cmp	r3, #3
   14428:	d03c      	beq.n	144a4 <osQueueOperate+0x138>
   1442a:	2201      	movs	r2, #1
   1442c:	9b02      	ldr	r3, [sp, #8]
   1442e:	439a      	bics	r2, r3
    return (BOOL)(pstList->pstNext == pstList);
   14430:	1c93      	adds	r3, r2, #2
   14432:	00db      	lsls	r3, r3, #3
   14434:	18e1      	adds	r1, r4, r3
   14436:	6888      	ldr	r0, [r1, #8]
    if (!LOS_ListEmpty(&pstQueueCB->stReadWriteList[!uwReadWrite])) /*lint !e514*/
   14438:	3304      	adds	r3, #4
   1443a:	18e3      	adds	r3, r4, r3
   1443c:	4298      	cmp	r0, r3
   1443e:	d047      	beq.n	144d0 <osQueueOperate+0x164>
        osTaskWake(pstResumedTask, OS_TASK_STATUS_PEND_QUEUE);
   14440:	2180      	movs	r1, #128	; 0x80
        pstResumedTask = OS_TCB_FROM_PENDLIST(LOS_DL_LIST_FIRST(&pstQueueCB->stReadWriteList[!uwReadWrite])); /*lint !e413 !e514*/
   14442:	382c      	subs	r0, #44	; 0x2c
        osTaskWake(pstResumedTask, OS_TASK_STATUS_PEND_QUEUE);
   14444:	0189      	lsls	r1, r1, #6
   14446:	f7ff f889 	bl	1355c <osTaskWake>
        LOS_IntRestore(uvIntSave);
   1444a:	9801      	ldr	r0, [sp, #4]
   1444c:	f7eb fe8f 	bl	16e <LOS_IntRestore>
        return LOS_OK;
   14450:	2700      	movs	r7, #0
        LOS_Schedule();
   14452:	f7ff faf3 	bl	13a3c <LOS_Schedule>
}
   14456:	0038      	movs	r0, r7
   14458:	b007      	add	sp, #28
   1445a:	bdf0      	pop	{r4, r5, r6, r7, pc}
            usQueuePosion = pstQueueCB->usQueueHead;
   1445c:	89a5      	ldrh	r5, [r4, #12]
            (pstQueueCB->usQueueHead + 1 == pstQueueCB->usQueueLen) ? (pstQueueCB->usQueueHead = 0) : (pstQueueCB->usQueueHead++);
   1445e:	88e1      	ldrh	r1, [r4, #6]
   14460:	1c6a      	adds	r2, r5, #1
   14462:	428a      	cmp	r2, r1
   14464:	d114      	bne.n	14490 <osQueueOperate+0x124>
   14466:	81a3      	strh	r3, [r4, #12]
    pucQueueNode = &(pstQueueCB->pucQueue[(usQueuePosion * (pstQueueCB->usQueueSize))]);
   14468:	8921      	ldrh	r1, [r4, #8]
   1446a:	6823      	ldr	r3, [r4, #0]
   1446c:	434d      	muls	r5, r1
   1446e:	195d      	adds	r5, r3, r5
    if(OS_QUEUE_IS_READ(uwOperateType))
   14470:	2f00      	cmp	r7, #0
   14472:	d120      	bne.n	144b6 <osQueueOperate+0x14a>
        memcpy((void *)&uwMsgDataSize, (void *)(pucQueueNode + pstQueueCB->usQueueSize - sizeof(UINT32)), sizeof(UINT32));
   14474:	3904      	subs	r1, #4
   14476:	1869      	adds	r1, r5, r1
   14478:	2204      	movs	r2, #4
   1447a:	a805      	add	r0, sp, #20
   1447c:	f7eb feb8 	bl	1f0 <memcpy>
        memcpy((void *)pBufferAddr, (void *)pucQueueNode, uwMsgDataSize);
   14480:	9f05      	ldr	r7, [sp, #20]
   14482:	0029      	movs	r1, r5
   14484:	003a      	movs	r2, r7
   14486:	9803      	ldr	r0, [sp, #12]
   14488:	f7eb feb2 	bl	1f0 <memcpy>
        *puwBufferSize = uwMsgDataSize;
   1448c:	6037      	str	r7, [r6, #0]
   1448e:	e7cc      	b.n	1442a <osQueueOperate+0xbe>
            (pstQueueCB->usQueueHead + 1 == pstQueueCB->usQueueLen) ? (pstQueueCB->usQueueHead = 0) : (pstQueueCB->usQueueHead++);
   14490:	81a2      	strh	r2, [r4, #12]
   14492:	e7e9      	b.n	14468 <osQueueOperate+0xfc>
            (0 == pstQueueCB->usQueueHead) ? (pstQueueCB->usQueueHead = pstQueueCB->usQueueLen - 1) : (--pstQueueCB->usQueueHead);
   14494:	89a3      	ldrh	r3, [r4, #12]
   14496:	2b00      	cmp	r3, #0
   14498:	d100      	bne.n	1449c <osQueueOperate+0x130>
   1449a:	88e3      	ldrh	r3, [r4, #6]
   1449c:	3b01      	subs	r3, #1
   1449e:	81a3      	strh	r3, [r4, #12]
            usQueuePosion = pstQueueCB->usQueueHead;
   144a0:	89a5      	ldrh	r5, [r4, #12]
   144a2:	e7e1      	b.n	14468 <osQueueOperate+0xfc>
            usQueuePosion = pstQueueCB->usQueueTail;
   144a4:	89e5      	ldrh	r5, [r4, #14]
            (pstQueueCB->usQueueTail + 1 == pstQueueCB->usQueueLen) ? (pstQueueCB->usQueueTail = 0) : (pstQueueCB->usQueueTail++);
   144a6:	88e1      	ldrh	r1, [r4, #6]
   144a8:	1c6b      	adds	r3, r5, #1
   144aa:	428b      	cmp	r3, r1
   144ac:	d101      	bne.n	144b2 <osQueueOperate+0x146>
   144ae:	81e2      	strh	r2, [r4, #14]
   144b0:	e7da      	b.n	14468 <osQueueOperate+0xfc>
   144b2:	81e3      	strh	r3, [r4, #14]
   144b4:	e7d8      	b.n	14468 <osQueueOperate+0xfc>
        memcpy((void *)pucQueueNode, (void *)pBufferAddr, *puwBufferSize);
   144b6:	6832      	ldr	r2, [r6, #0]
   144b8:	9903      	ldr	r1, [sp, #12]
   144ba:	0028      	movs	r0, r5
   144bc:	f7eb fe98 	bl	1f0 <memcpy>
        memcpy((void *)(pucQueueNode + pstQueueCB->usQueueSize - sizeof(UINT32)), puwBufferSize, sizeof(UINT32));
   144c0:	8920      	ldrh	r0, [r4, #8]
   144c2:	2204      	movs	r2, #4
   144c4:	3804      	subs	r0, #4
   144c6:	1828      	adds	r0, r5, r0
   144c8:	0031      	movs	r1, r6
   144ca:	f7eb fe91 	bl	1f0 <memcpy>
   144ce:	e7ac      	b.n	1442a <osQueueOperate+0xbe>
   144d0:	0052      	lsls	r2, r2, #1
   144d2:	18a4      	adds	r4, r4, r2
        pstQueueCB->usReadWriteableCnt[!uwReadWrite]++; /*lint !e514*/
   144d4:	8a23      	ldrh	r3, [r4, #16]
    UINT32       uwRet = LOS_OK;
   144d6:	2700      	movs	r7, #0
        pstQueueCB->usReadWriteableCnt[!uwReadWrite]++; /*lint !e514*/
   144d8:	3301      	adds	r3, #1
   144da:	8223      	strh	r3, [r4, #16]
   144dc:	e770      	b.n	143c0 <osQueueOperate+0x54>
        uwRet = LOS_ERRNO_QUEUE_NOT_CREATE;
   144de:	4f09      	ldr	r7, [pc, #36]	; (14504 <osQueueOperate+0x198>)
   144e0:	e76e      	b.n	143c0 <osQueueOperate+0x54>
        uwRet = LOS_ERRNO_QUEUE_READ_SIZE_TOO_SMALL;
   144e2:	4f09      	ldr	r7, [pc, #36]	; (14508 <osQueueOperate+0x19c>)
   144e4:	e76c      	b.n	143c0 <osQueueOperate+0x54>
            uwRet = LOS_ERRNO_QUEUE_PEND_IN_LOCK;
   144e6:	4f09      	ldr	r7, [pc, #36]	; (1450c <osQueueOperate+0x1a0>)
   144e8:	e76a      	b.n	143c0 <osQueueOperate+0x54>
   144ea:	46c0      	nop			; (mov r8, r8)
   144ec:	01002ed0 	.word	0x01002ed0
   144f0:	0200061d 	.word	0x0200061d
   144f4:	02000615 	.word	0x02000615
   144f8:	01002e6c 	.word	0x01002e6c
   144fc:	01002e70 	.word	0x01002e70
   14500:	02000607 	.word	0x02000607
   14504:	0200060a 	.word	0x0200060a
   14508:	0200061f 	.word	0x0200061f
   1450c:	02000606 	.word	0x02000606

00014510 <LOS_QueueReadCopy>:
 *****************************************************************************/
LITE_OS_SEC_TEXT UINT32 LOS_QueueReadCopy(UINT32  uwQueueID,
                    VOID *  pBufferAddr,
                    UINT32 * puwBufferSize,
                    UINT32  uwTimeOut)
{
   14510:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
   14512:	0005      	movs	r5, r0
   14514:	000e      	movs	r6, r1
   14516:	0014      	movs	r4, r2
   14518:	001f      	movs	r7, r3
    if (uwQueueID >= LOSCFG_BASE_IPC_QUEUE_LIMIT)
   1451a:	280e      	cmp	r0, #14
   1451c:	d816      	bhi.n	1454c <LOS_QueueReadCopy+0x3c>
    if ((NULL == pBufferAddr) || (NULL == puwBufferSize))
   1451e:	2900      	cmp	r1, #0
   14520:	d016      	beq.n	14550 <LOS_QueueReadCopy+0x40>
   14522:	2a00      	cmp	r2, #0
   14524:	d014      	beq.n	14550 <LOS_QueueReadCopy+0x40>
    if (0 == *puwBufferSize)
   14526:	6813      	ldr	r3, [r2, #0]
   14528:	2b00      	cmp	r3, #0
   1452a:	d013      	beq.n	14554 <LOS_QueueReadCopy+0x44>
    if (LOS_NO_WAIT != uwTimeOut)
   1452c:	2f00      	cmp	r7, #0
   1452e:	d107      	bne.n	14540 <LOS_QueueReadCopy+0x30>
    {
        return uwRet;
    }

    uwOperateType = OS_QUEUE_OPERATE_TYPE(OS_QUEUE_READ, OS_QUEUE_HEAD);
    return osQueueOperate(uwQueueID, uwOperateType, pBufferAddr, puwBufferSize, uwTimeOut);
   14530:	9700      	str	r7, [sp, #0]
   14532:	0023      	movs	r3, r4
   14534:	0032      	movs	r2, r6
   14536:	2100      	movs	r1, #0
   14538:	0028      	movs	r0, r5
   1453a:	f7ff ff17 	bl	1436c <osQueueOperate>
}
   1453e:	bdfe      	pop	{r1, r2, r3, r4, r5, r6, r7, pc}
        if (OS_INT_ACTIVE)
   14540:	f003 fe80 	bl	18244 <non_os_is_this_interrupt_context>
   14544:	2800      	cmp	r0, #0
   14546:	d0f3      	beq.n	14530 <LOS_QueueReadCopy+0x20>
            return LOS_ERRNO_QUEUE_READ_IN_INTERRUPT;
   14548:	4803      	ldr	r0, [pc, #12]	; (14558 <LOS_QueueReadCopy+0x48>)
   1454a:	e7f8      	b.n	1453e <LOS_QueueReadCopy+0x2e>
        return LOS_ERRNO_QUEUE_INVALID;
   1454c:	4803      	ldr	r0, [pc, #12]	; (1455c <LOS_QueueReadCopy+0x4c>)
   1454e:	e7f6      	b.n	1453e <LOS_QueueReadCopy+0x2e>
        return LOS_ERRNO_QUEUE_READ_PTR_NULL;
   14550:	4803      	ldr	r0, [pc, #12]	; (14560 <LOS_QueueReadCopy+0x50>)
   14552:	e7f4      	b.n	1453e <LOS_QueueReadCopy+0x2e>
        return LOS_ERRNO_QUEUE_READSIZE_ISZERO;
   14554:	4803      	ldr	r0, [pc, #12]	; (14564 <LOS_QueueReadCopy+0x54>)
   14556:	e7f2      	b.n	1453e <LOS_QueueReadCopy+0x2e>
   14558:	02000618 	.word	0x02000618
   1455c:	0200060e 	.word	0x0200060e
   14560:	0200060f 	.word	0x0200060f
   14564:	02000610 	.word	0x02000610

00014568 <LOS_QueueWriteCopy>:
 *****************************************************************************/
LITE_OS_SEC_TEXT UINT32 LOS_QueueWriteCopy( UINT32 uwQueueID,
                                     VOID * pBufferAddr,
                                     UINT32 uwBufferSize,
                                     UINT32 uwTimeOut )
{
   14568:	b57f      	push	{r0, r1, r2, r3, r4, r5, r6, lr}
   1456a:	0004      	movs	r4, r0
   1456c:	000d      	movs	r5, r1
   1456e:	9203      	str	r2, [sp, #12]
   14570:	001e      	movs	r6, r3
    if (uwQueueID >= LOSCFG_BASE_IPC_QUEUE_LIMIT)
   14572:	280e      	cmp	r0, #14
   14574:	d814      	bhi.n	145a0 <LOS_QueueWriteCopy+0x38>
    if (NULL == pBufferAddr)
   14576:	2900      	cmp	r1, #0
   14578:	d014      	beq.n	145a4 <LOS_QueueWriteCopy+0x3c>
    if (0 == *puwBufferSize)
   1457a:	2a00      	cmp	r2, #0
   1457c:	d014      	beq.n	145a8 <LOS_QueueWriteCopy+0x40>
    if (LOS_NO_WAIT != uwTimeOut)
   1457e:	2e00      	cmp	r6, #0
   14580:	d108      	bne.n	14594 <LOS_QueueWriteCopy+0x2c>
    {
        return uwRet;
    }

    uwOperateType = OS_QUEUE_OPERATE_TYPE(OS_QUEUE_WRITE, OS_QUEUE_TAIL);
    return osQueueOperate(uwQueueID, uwOperateType, pBufferAddr, &uwBufferSize, uwTimeOut);
   14582:	9600      	str	r6, [sp, #0]
   14584:	ab03      	add	r3, sp, #12
   14586:	002a      	movs	r2, r5
   14588:	2103      	movs	r1, #3
   1458a:	0020      	movs	r0, r4
   1458c:	f7ff feee 	bl	1436c <osQueueOperate>
}
   14590:	b004      	add	sp, #16
   14592:	bd70      	pop	{r4, r5, r6, pc}
        if (OS_INT_ACTIVE)
   14594:	f003 fe56 	bl	18244 <non_os_is_this_interrupt_context>
   14598:	2800      	cmp	r0, #0
   1459a:	d0f2      	beq.n	14582 <LOS_QueueWriteCopy+0x1a>
            return LOS_ERRNO_QUEUE_WRITE_IN_INTERRUPT;
   1459c:	4803      	ldr	r0, [pc, #12]	; (145ac <LOS_QueueWriteCopy+0x44>)
   1459e:	e7f7      	b.n	14590 <LOS_QueueWriteCopy+0x28>
        return LOS_ERRNO_QUEUE_INVALID;
   145a0:	4803      	ldr	r0, [pc, #12]	; (145b0 <LOS_QueueWriteCopy+0x48>)
   145a2:	e7f5      	b.n	14590 <LOS_QueueWriteCopy+0x28>
        return LOS_ERRNO_QUEUE_WRITE_PTR_NULL;
   145a4:	4803      	ldr	r0, [pc, #12]	; (145b4 <LOS_QueueWriteCopy+0x4c>)
   145a6:	e7f3      	b.n	14590 <LOS_QueueWriteCopy+0x28>
        return LOS_ERRNO_QUEUE_WRITESIZE_ISZERO;
   145a8:	4803      	ldr	r0, [pc, #12]	; (145b8 <LOS_QueueWriteCopy+0x50>)
   145aa:	e7f1      	b.n	14590 <LOS_QueueWriteCopy+0x28>
   145ac:	02000609 	.word	0x02000609
   145b0:	0200060e 	.word	0x0200060e
   145b4:	02000612 	.word	0x02000612
   145b8:	02000613 	.word	0x02000613

000145bc <osAtomicBitsetInit>:
 *  -esym(10,*) -esym(530,*) -esym(529,*) -esym(522,*) -esym(550,*)*/

void osAtomicBitsetInit(struct AtomicBitset *set, UINT32 numBits)
{
    set->numBits = numBits;
    memset(set->words, 0, (numBits + 31) / 8);
   145bc:	000a      	movs	r2, r1
   145be:	321f      	adds	r2, #31
{
   145c0:	b570      	push	{r4, r5, r6, lr}
    memset(set->words, 0, (numBits + 31) / 8);
   145c2:	08d2      	lsrs	r2, r2, #3
{
   145c4:	0005      	movs	r5, r0
   145c6:	000c      	movs	r4, r1
    set->numBits = numBits;
   145c8:	c002      	stmia	r0!, {r1}
    memset(set->words, 0, (numBits + 31) / 8);
   145ca:	2100      	movs	r1, #0
   145cc:	f7eb fe88 	bl	2e0 <memset>
    if (numBits & 31) //mark all high bits so that osAtomicBitsetFindClearAndSet() is simpler
   145d0:	231f      	movs	r3, #31
   145d2:	4023      	ands	r3, r4
   145d4:	d006      	beq.n	145e4 <osAtomicBitsetInit+0x28>
        set->words[numBits / 32] = ((UINT32)((INT32)-1LL)) << (numBits & 31);
   145d6:	2201      	movs	r2, #1
   145d8:	4252      	negs	r2, r2
   145da:	409a      	lsls	r2, r3
   145dc:	0964      	lsrs	r4, r4, #5
   145de:	00a4      	lsls	r4, r4, #2
   145e0:	192c      	adds	r4, r5, r4
   145e2:	6062      	str	r2, [r4, #4]
}
   145e4:	bd70      	pop	{r4, r5, r6, pc}

000145e6 <osAtomicBitsetGetNumBits>:
/*lint -e695*/
inline UINT32 osAtomicBitsetGetNumBits(const struct AtomicBitset *set)
{
    return set->numBits;
   145e6:	6800      	ldr	r0, [r0, #0]
}
   145e8:	4770      	bx	lr

000145ea <osAtomicBitsetGetBit>:
/*lint +e695*/
BOOL osAtomicBitsetGetBit(const struct AtomicBitset *set, UINT32 num)
{
   145ea:	0003      	movs	r3, r0
    if (num >= set->numBits) /* any value is as good as the next */
   145ec:	681a      	ldr	r2, [r3, #0]
        return FALSE;
   145ee:	2000      	movs	r0, #0
    if (num >= set->numBits) /* any value is as good as the next */
   145f0:	428a      	cmp	r2, r1
   145f2:	d908      	bls.n	14606 <osAtomicBitsetGetBit+0x1c>

    return !!((set->words[num / 32]) & (1UL << (num & 31)));
   145f4:	221f      	movs	r2, #31
   145f6:	0948      	lsrs	r0, r1, #5
   145f8:	0080      	lsls	r0, r0, #2
   145fa:	181b      	adds	r3, r3, r0
   145fc:	6858      	ldr	r0, [r3, #4]
   145fe:	4011      	ands	r1, r2
   14600:	40c8      	lsrs	r0, r1
   14602:	2301      	movs	r3, #1
   14604:	4018      	ands	r0, r3
}
   14606:	4770      	bx	lr

00014608 <osAtomicBitsetClearBit>:

void osAtomicBitsetClearBit(struct AtomicBitset *set, UINT32 num)
{
    UINT32 *wordPtr = set->words + num / 32;

    if (num >= set->numBits)
   14608:	6803      	ldr	r3, [r0, #0]
   1460a:	428b      	cmp	r3, r1
   1460c:	d90a      	bls.n	14624 <osAtomicBitsetClearBit+0x1c>
    UINT32 *wordPtr = set->words + num / 32;
   1460e:	094b      	lsrs	r3, r1, #5
   14610:	009b      	lsls	r3, r3, #2
   14612:	3004      	adds	r0, #4
   14614:	18c0      	adds	r0, r0, r3
        return;

    (*wordPtr) &= ~(1UL << (num & 31));
   14616:	231f      	movs	r3, #31
   14618:	4019      	ands	r1, r3
   1461a:	3b1e      	subs	r3, #30
   1461c:	408b      	lsls	r3, r1
   1461e:	6802      	ldr	r2, [r0, #0]
   14620:	439a      	bics	r2, r3
   14622:	6002      	str	r2, [r0, #0]
}
   14624:	4770      	bx	lr

00014626 <osAtomicBitsetFindClearAndSet>:
    UINT32 uwIdx, uwNumWords = (set->numBits + 31) / 32;
    UINT32 *puwWordPtr = set->words;
    UINT32 uwTmpWord;
    INT32 cnt = 0;

    for (uwIdx = 0; uwIdx < uwNumWords; uwIdx++, puwWordPtr++)
   14626:	2300      	movs	r3, #0
{
   14628:	b530      	push	{r4, r5, lr}
    UINT32 uwIdx, uwNumWords = (set->numBits + 31) / 32;
   1462a:	c804      	ldmia	r0!, {r2}
   1462c:	321f      	adds	r2, #31
   1462e:	0952      	lsrs	r2, r2, #5
    for (uwIdx = 0; uwIdx < uwNumWords; uwIdx++, puwWordPtr++)
   14630:	4293      	cmp	r3, r2
   14632:	d102      	bne.n	1463a <osAtomicBitsetFindClearAndSet+0x14>
        *puwWordPtr |= (1UL << (cnt - 1));

        return (INT32)(uwIdx * 32 + cnt - 1);
    }

    return -1;
   14634:	2001      	movs	r0, #1
   14636:	4240      	negs	r0, r0
   14638:	e012      	b.n	14660 <osAtomicBitsetFindClearAndSet+0x3a>
        if (*puwWordPtr == 0xFFFFFFFF)
   1463a:	6801      	ldr	r1, [r0, #0]
   1463c:	1c4c      	adds	r4, r1, #1
   1463e:	d102      	bne.n	14646 <osAtomicBitsetFindClearAndSet+0x20>
    for (uwIdx = 0; uwIdx < uwNumWords; uwIdx++, puwWordPtr++)
   14640:	3301      	adds	r3, #1
   14642:	3004      	adds	r0, #4
   14644:	e7f4      	b.n	14630 <osAtomicBitsetFindClearAndSet+0xa>
    uwTmpWord = ~(*puwWordPtr);
   14646:	43ca      	mvns	r2, r1
    INT32 cnt = 0;
   14648:	2500      	movs	r5, #0
            uwTmpWord = uwTmpWord >> 1UL;
   1464a:	0852      	lsrs	r2, r2, #1
            cnt++;
   1464c:	1c6c      	adds	r4, r5, #1
        while(uwTmpWord)
   1464e:	2a00      	cmp	r2, #0
   14650:	d107      	bne.n	14662 <osAtomicBitsetFindClearAndSet+0x3c>
        *puwWordPtr |= (1UL << (cnt - 1));
   14652:	3201      	adds	r2, #1
   14654:	40aa      	lsls	r2, r5
   14656:	430a      	orrs	r2, r1
   14658:	6002      	str	r2, [r0, #0]
        return (INT32)(uwIdx * 32 + cnt - 1);
   1465a:	0158      	lsls	r0, r3, #5
   1465c:	3801      	subs	r0, #1
   1465e:	1900      	adds	r0, r0, r4
}
   14660:	bd30      	pop	{r4, r5, pc}
            cnt++;
   14662:	0025      	movs	r5, r4
   14664:	e7f1      	b.n	1464a <osAtomicBitsetFindClearAndSet+0x24>

00014666 <osBitsetEmpty>:
}

BOOL osBitsetEmpty(struct AtomicBitset *bitset)
{
	UINT32 idx;
	for (idx = 0; idx < bitset->numBits / 32;){
   14666:	2300      	movs	r3, #0
{
   14668:	b510      	push	{r4, lr}
	for (idx = 0; idx < bitset->numBits / 32;){
   1466a:	6802      	ldr	r2, [r0, #0]
   1466c:	0951      	lsrs	r1, r2, #5
   1466e:	4299      	cmp	r1, r3
   14670:	d10f      	bne.n	14692 <osBitsetEmpty+0x2c>
		if (bitset->words[idx] != 0)
			return FALSE;
		idx++;
	}
	if (bitset->numBits & 31) {
   14672:	231f      	movs	r3, #31
   14674:	401a      	ands	r2, r3
		if (bitset->words[idx] & ~(0xFFFFFFFF << (bitset->numBits & 31))) {
			return FALSE;
		}
	}

	return TRUE;
   14676:	3b1e      	subs	r3, #30
	if (bitset->numBits & 31) {
   14678:	2a00      	cmp	r2, #0
   1467a:	d008      	beq.n	1468e <osBitsetEmpty+0x28>
		if (bitset->words[idx] & ~(0xFFFFFFFF << (bitset->numBits & 31))) {
   1467c:	3b02      	subs	r3, #2
   1467e:	4093      	lsls	r3, r2
   14680:	001a      	movs	r2, r3
   14682:	0089      	lsls	r1, r1, #2
   14684:	1840      	adds	r0, r0, r1
   14686:	6843      	ldr	r3, [r0, #4]
   14688:	4393      	bics	r3, r2
			return FALSE;
   1468a:	4258      	negs	r0, r3
   1468c:	4143      	adcs	r3, r0
}
   1468e:	0018      	movs	r0, r3
   14690:	bd10      	pop	{r4, pc}
		if (bitset->words[idx] != 0)
   14692:	009c      	lsls	r4, r3, #2
   14694:	1904      	adds	r4, r0, r4
   14696:	6864      	ldr	r4, [r4, #4]
   14698:	2c00      	cmp	r4, #0
   1469a:	d101      	bne.n	146a0 <osBitsetEmpty+0x3a>
		idx++;
   1469c:	3301      	adds	r3, #1
   1469e:	e7e6      	b.n	1466e <osBitsetEmpty+0x8>
			return FALSE;
   146a0:	2300      	movs	r3, #0
   146a2:	e7f4      	b.n	1468e <osBitsetEmpty+0x28>

000146a4 <osKernelInitialize>:
//  ==== Kernel Management Functions ====
uint32_t osTaskStackWaterMarkGet(UINT32 uwTaskID);


osStatus_t osKernelInitialize (void)
{
   146a4:	b510      	push	{r4, lr}
    if (OS_INT_ACTIVE)
   146a6:	f003 fdcd 	bl	18244 <non_os_is_this_interrupt_context>
   146aa:	2800      	cmp	r0, #0
   146ac:	d10d      	bne.n	146ca <osKernelInitialize+0x26>
    {
        return osErrorISR;
    }

    if (KernelState != osKernelInactive)
   146ae:	4c08      	ldr	r4, [pc, #32]	; (146d0 <osKernelInitialize+0x2c>)
   146b0:	6823      	ldr	r3, [r4, #0]
   146b2:	2b00      	cmp	r3, #0
   146b4:	d002      	beq.n	146bc <osKernelInitialize+0x18>
    {
        return osError;
   146b6:	2001      	movs	r0, #1
        return osErrorISR;
   146b8:	4240      	negs	r0, r0
   146ba:	e005      	b.n	146c8 <osKernelInitialize+0x24>
    }

    if(LOS_OK == osMain())
   146bc:	f00d f816 	bl	216ec <osMain>
   146c0:	2800      	cmp	r0, #0
   146c2:	d1f8      	bne.n	146b6 <osKernelInitialize+0x12>
    {
        KernelState = osKernelReady;
   146c4:	2301      	movs	r3, #1
   146c6:	6023      	str	r3, [r4, #0]
    }
    else
    {
        return osError;
    }
}
   146c8:	bd10      	pop	{r4, pc}
        return osErrorISR;
   146ca:	2006      	movs	r0, #6
   146cc:	e7f4      	b.n	146b8 <osKernelInitialize+0x14>
   146ce:	46c0      	nop			; (mov r8, r8)
   146d0:	01002534 	.word	0x01002534

000146d4 <osKernelGetState>:
    return osOK;
}


osKernelState_t osKernelGetState (void)
{
   146d4:	b510      	push	{r4, lr}
    if (OS_INT_ACTIVE)
   146d6:	f003 fdb5 	bl	18244 <non_os_is_this_interrupt_context>
   146da:	2800      	cmp	r0, #0
   146dc:	d10f      	bne.n	146fe <osKernelGetState+0x2a>
    {
        return osKernelError;
    }

    if(!g_bTaskScheduled)
   146de:	4b09      	ldr	r3, [pc, #36]	; (14704 <osKernelGetState+0x30>)
   146e0:	681b      	ldr	r3, [r3, #0]
   146e2:	2b00      	cmp	r3, #0
   146e4:	d105      	bne.n	146f2 <osKernelGetState+0x1e>
    {
        if (KernelState == osKernelReady)
   146e6:	4b08      	ldr	r3, [pc, #32]	; (14708 <osKernelGetState+0x34>)
   146e8:	6818      	ldr	r0, [r3, #0]
   146ea:	3801      	subs	r0, #1
        return osKernelError;
   146ec:	4243      	negs	r3, r0
   146ee:	4158      	adcs	r0, r3
    }
    else
    {
        return osKernelRunning;
    }
}
   146f0:	bd10      	pop	{r4, pc}
    else if(g_usLosTaskLock > 0)
   146f2:	4b06      	ldr	r3, [pc, #24]	; (1470c <osKernelGetState+0x38>)
   146f4:	8818      	ldrh	r0, [r3, #0]
        return osKernelRunning;
   146f6:	1e43      	subs	r3, r0, #1
   146f8:	4198      	sbcs	r0, r3
   146fa:	3002      	adds	r0, #2
   146fc:	e7f8      	b.n	146f0 <osKernelGetState+0x1c>
        return osKernelError;
   146fe:	2001      	movs	r0, #1
   14700:	4240      	negs	r0, r0
   14702:	e7f5      	b.n	146f0 <osKernelGetState+0x1c>
   14704:	01002e78 	.word	0x01002e78
   14708:	01002534 	.word	0x01002534
   1470c:	01002e6c 	.word	0x01002e6c

00014710 <osKernelStart>:


osStatus_t osKernelStart (void)
{
   14710:	b510      	push	{r4, lr}
    if(OS_INT_ACTIVE)
   14712:	f003 fd97 	bl	18244 <non_os_is_this_interrupt_context>
   14716:	2800      	cmp	r0, #0
   14718:	d10d      	bne.n	14736 <osKernelStart+0x26>
    {
        return osErrorISR;
    }

    if(KernelState == osKernelReady)
   1471a:	4c08      	ldr	r4, [pc, #32]	; (1473c <osKernelStart+0x2c>)
   1471c:	6823      	ldr	r3, [r4, #0]
   1471e:	2b01      	cmp	r3, #1
   14720:	d002      	beq.n	14728 <osKernelStart+0x18>
            return osError;
        }
    }
    else
    {
        return osError;
   14722:	2001      	movs	r0, #1
        return osErrorISR;
   14724:	4240      	negs	r0, r0
   14726:	e005      	b.n	14734 <osKernelStart+0x24>
        if(LOS_OK == LOS_Start())
   14728:	f00c ffd6 	bl	216d8 <LOS_Start>
   1472c:	2800      	cmp	r0, #0
   1472e:	d1f8      	bne.n	14722 <osKernelStart+0x12>
            KernelState = osKernelRunning;
   14730:	2302      	movs	r3, #2
   14732:	6023      	str	r3, [r4, #0]
    }
}
   14734:	bd10      	pop	{r4, pc}
        return osErrorISR;
   14736:	2006      	movs	r0, #6
   14738:	e7f4      	b.n	14724 <osKernelStart+0x14>
   1473a:	46c0      	nop			; (mov r8, r8)
   1473c:	01002534 	.word	0x01002534

00014740 <osKernelLock>:


int32_t osKernelLock (void)
{
   14740:	b510      	push	{r4, lr}
    int32_t lock;

    if(OS_INT_ACTIVE)
   14742:	f003 fd7f 	bl	18244 <non_os_is_this_interrupt_context>
   14746:	2800      	cmp	r0, #0
   14748:	d10c      	bne.n	14764 <osKernelLock+0x24>
    {
        return (int32_t)osErrorISR;
    }

    if(!g_bTaskScheduled)
   1474a:	4b09      	ldr	r3, [pc, #36]	; (14770 <osKernelLock+0x30>)
   1474c:	681b      	ldr	r3, [r3, #0]
   1474e:	2b00      	cmp	r3, #0
   14750:	d00b      	beq.n	1476a <osKernelLock+0x2a>
    {
        return (int32_t)osError;
    }

    if(g_usLosTaskLock > 0)
   14752:	4b08      	ldr	r3, [pc, #32]	; (14774 <osKernelLock+0x34>)
    {
        lock = 1;
   14754:	3001      	adds	r0, #1
    if(g_usLosTaskLock > 0)
   14756:	881c      	ldrh	r4, [r3, #0]
   14758:	2c00      	cmp	r4, #0
   1475a:	d102      	bne.n	14762 <osKernelLock+0x22>
    }
    else
    {
        LOS_TaskLock();
   1475c:	f7fe ff8e 	bl	1367c <LOS_TaskLock>
        lock = 0;
   14760:	0020      	movs	r0, r4
    }

    return lock;
}
   14762:	bd10      	pop	{r4, pc}
        return (int32_t)osErrorISR;
   14764:	2006      	movs	r0, #6
        return (int32_t)osError;
   14766:	4240      	negs	r0, r0
   14768:	e7fb      	b.n	14762 <osKernelLock+0x22>
   1476a:	2001      	movs	r0, #1
   1476c:	e7fb      	b.n	14766 <osKernelLock+0x26>
   1476e:	46c0      	nop			; (mov r8, r8)
   14770:	01002e78 	.word	0x01002e78
   14774:	01002e6c 	.word	0x01002e6c

00014778 <osKernelUnlock>:


int32_t osKernelUnlock (void)
{
   14778:	b510      	push	{r4, lr}
    int32_t lock;

    if(OS_INT_ACTIVE)
   1477a:	f003 fd63 	bl	18244 <non_os_is_this_interrupt_context>
   1477e:	2800      	cmp	r0, #0
   14780:	d111      	bne.n	147a6 <osKernelUnlock+0x2e>
    {
        return (int32_t)osErrorISR;
    }

    if(!g_bTaskScheduled)
   14782:	4b0a      	ldr	r3, [pc, #40]	; (147ac <osKernelUnlock+0x34>)
   14784:	681b      	ldr	r3, [r3, #0]
   14786:	2b00      	cmp	r3, #0
   14788:	d102      	bne.n	14790 <osKernelUnlock+0x18>
    {
        return (int32_t)osError;
   1478a:	2001      	movs	r0, #1
        return (int32_t)osErrorISR;
   1478c:	4240      	negs	r0, r0
   1478e:	e009      	b.n	147a4 <osKernelUnlock+0x2c>
    }

    if(g_usLosTaskLock > 0)
   14790:	4c07      	ldr	r4, [pc, #28]	; (147b0 <osKernelUnlock+0x38>)
   14792:	8823      	ldrh	r3, [r4, #0]
   14794:	2b00      	cmp	r3, #0
   14796:	d005      	beq.n	147a4 <osKernelUnlock+0x2c>
    {
        LOS_TaskUnlock();
   14798:	f7fe ff7c 	bl	13694 <LOS_TaskUnlock>
        if (g_usLosTaskLock != 0)
   1479c:	8823      	ldrh	r3, [r4, #0]
        {
            return (int32_t)osError;
        }
        lock = 1;
   1479e:	2001      	movs	r0, #1
        if (g_usLosTaskLock != 0)
   147a0:	2b00      	cmp	r3, #0
   147a2:	d1f2      	bne.n	1478a <osKernelUnlock+0x12>
    {
        lock = 0;
    }

    return lock;
}
   147a4:	bd10      	pop	{r4, pc}
        return (int32_t)osErrorISR;
   147a6:	2006      	movs	r0, #6
   147a8:	e7f0      	b.n	1478c <osKernelUnlock+0x14>
   147aa:	46c0      	nop			; (mov r8, r8)
   147ac:	01002e78 	.word	0x01002e78
   147b0:	01002e6c 	.word	0x01002e6c

000147b4 <osKernelGetTickCount>:

}


uint64_t osKernelGetTickCount (void)
{
   147b4:	b570      	push	{r4, r5, r6, lr}
    uint64_t ticks;
    UINTPTR uvIntSave;

    if(OS_INT_ACTIVE)
   147b6:	f003 fd45 	bl	18244 <non_os_is_this_interrupt_context>
    {
        ticks = 0U;
   147ba:	2400      	movs	r4, #0
   147bc:	2500      	movs	r5, #0
    if(OS_INT_ACTIVE)
   147be:	2800      	cmp	r0, #0
   147c0:	d106      	bne.n	147d0 <osKernelGetTickCount+0x1c>
    }
    else
    {
        uvIntSave = LOS_IntLock();
   147c2:	f7eb fccc 	bl	15e <LOS_IntLock>
        ticks = g_ullTickCount;
   147c6:	4b04      	ldr	r3, [pc, #16]	; (147d8 <osKernelGetTickCount+0x24>)
   147c8:	681c      	ldr	r4, [r3, #0]
   147ca:	685d      	ldr	r5, [r3, #4]
        LOS_IntRestore(uvIntSave);
   147cc:	f7eb fccf 	bl	16e <LOS_IntRestore>
    }

    return ticks;
}
   147d0:	0029      	movs	r1, r5
   147d2:	0020      	movs	r0, r4
   147d4:	bd70      	pop	{r4, r5, r6, pc}
   147d6:	46c0      	nop			; (mov r8, r8)
   147d8:	01002eb0 	.word	0x01002eb0

000147dc <osKernelGetTick2ms>:


uint64_t osKernelGetTick2ms(void)
{
   147dc:	b510      	push	{r4, lr}
    return osKernelGetTickCount() * (OS_SYS_MS_PER_SECOND / LOSCFG_BASE_CORE_TICK_PER_SECOND);
   147de:	f7ff ffe9 	bl	147b4 <osKernelGetTickCount>
}
   147e2:	bd10      	pop	{r4, pc}

000147e4 <osMs2Tick>:

uint64_t osMs2Tick(uint64_t ms)
{

    return ms * (LOSCFG_BASE_CORE_TICK_PER_SECOND / OS_SYS_MS_PER_SECOND);
}
   147e4:	4770      	bx	lr
	...

000147e8 <osThreadNew>:


//  ==== Thread Management Functions ====

osThreadId_t osThreadNew (osThreadFunc_t func, void *argument, const osThreadAttr_t *attr)
{
   147e8:	b570      	push	{r4, r5, r6, lr}
   147ea:	b086      	sub	sp, #24
   147ec:	0006      	movs	r6, r0
   147ee:	0015      	movs	r5, r2
    UINT32 uwTid;
    UINT32 uwRet;
    LOS_TASK_CB *pstTaskCB = NULL;
    TSK_INIT_PARAM_S stTskInitParam;

    if (OS_INT_ACTIVE)
   147f0:	f003 fd28 	bl	18244 <non_os_is_this_interrupt_context>
   147f4:	1e01      	subs	r1, r0, #0
   147f6:	d002      	beq.n	147fe <osThreadNew+0x16>
    {
        return NULL;
   147f8:	2000      	movs	r0, #0
    }

    pstTaskCB = OS_TCB_FROM_TID(uwTid);

    return (osThreadId_t)pstTaskCB;
}
   147fa:	b006      	add	sp, #24
   147fc:	bd70      	pop	{r4, r5, r6, pc}
    if ((attr == NULL) ||
   147fe:	2d00      	cmp	r5, #0
   14800:	d0fa      	beq.n	147f8 <osThreadNew+0x10>
   14802:	2e00      	cmp	r6, #0
   14804:	d0f8      	beq.n	147f8 <osThreadNew+0x10>
        (func == NULL) ||
   14806:	69ab      	ldr	r3, [r5, #24]
   14808:	3b09      	subs	r3, #9
   1480a:	2b1d      	cmp	r3, #29
   1480c:	d8f4      	bhi.n	147f8 <osThreadNew+0x10>
    memset(&stTskInitParam, 0, sizeof(TSK_INIT_PARAM_S));
   1480e:	ac01      	add	r4, sp, #4
   14810:	2214      	movs	r2, #20
   14812:	0020      	movs	r0, r4
   14814:	f7eb fd64 	bl	2e0 <memset>
    stTskInitParam.uwStackSize  = attr->stack_size*4;
   14818:	696b      	ldr	r3, [r5, #20]
    stTskInitParam.usTaskPrio   = OS_TASK_PRIORITY_LOWEST - ((UINT16)(attr->priority) - LOS_PRIORITY_WIN); /*0~31*/
   1481a:	69aa      	ldr	r2, [r5, #24]
    stTskInitParam.uwStackSize  = attr->stack_size*4;
   1481c:	009b      	lsls	r3, r3, #2
   1481e:	60a3      	str	r3, [r4, #8]
    stTskInitParam.pcName       = (CHAR *)attr->name;
   14820:	682b      	ldr	r3, [r5, #0]
    uwRet = LOS_TaskCreate(&uwTid, &stTskInitParam);
   14822:	0021      	movs	r1, r4
    stTskInitParam.pcName       = (CHAR *)attr->name;
   14824:	60e3      	str	r3, [r4, #12]
    stTskInitParam.usTaskPrio   = OS_TASK_PRIORITY_LOWEST - ((UINT16)(attr->priority) - LOS_PRIORITY_WIN); /*0~31*/
   14826:	2327      	movs	r3, #39	; 0x27
   14828:	1a9b      	subs	r3, r3, r2
   1482a:	80a3      	strh	r3, [r4, #4]
    stTskInitParam.uwResved     = LOS_TASK_STATUS_DETACHED; /*the cmsis task is detached,the task can deleteself*/
   1482c:	2380      	movs	r3, #128	; 0x80
    uwRet = LOS_TaskCreate(&uwTid, &stTskInitParam);
   1482e:	4668      	mov	r0, sp
    stTskInitParam.pfnTaskEntry = (TSK_ENTRY_FUNC)func;
   14830:	9601      	str	r6, [sp, #4]
    stTskInitParam.uwResved     = LOS_TASK_STATUS_DETACHED; /*the cmsis task is detached,the task can deleteself*/
   14832:	6123      	str	r3, [r4, #16]
    uwRet = LOS_TaskCreate(&uwTid, &stTskInitParam);
   14834:	f7fe fe10 	bl	13458 <LOS_TaskCreate>
    if (LOS_OK != uwRet)
   14838:	2800      	cmp	r0, #0
   1483a:	d1dd      	bne.n	147f8 <osThreadNew+0x10>
    pstTaskCB = OS_TCB_FROM_TID(uwTid);
   1483c:	2358      	movs	r3, #88	; 0x58
   1483e:	9a00      	ldr	r2, [sp, #0]
   14840:	4353      	muls	r3, r2
   14842:	4a02      	ldr	r2, [pc, #8]	; (1484c <osThreadNew+0x64>)
   14844:	6810      	ldr	r0, [r2, #0]
   14846:	18c0      	adds	r0, r0, r3
    return (osThreadId_t)pstTaskCB;
   14848:	e7d7      	b.n	147fa <osThreadNew+0x12>
   1484a:	46c0      	nop			; (mov r8, r8)
   1484c:	01002e64 	.word	0x01002e64

00014850 <osThreadYield>:
    return (osPriority_t)(OS_TASK_PRIORITY_LOWEST - (usRet - LOS_PRIORITY_WIN));
}


osStatus_t osThreadYield (void)
{
   14850:	b510      	push	{r4, lr}
    UINT32 uwRet;

    if (OS_INT_ACTIVE)
   14852:	f003 fcf7 	bl	18244 <non_os_is_this_interrupt_context>
   14856:	2800      	cmp	r0, #0
   14858:	d105      	bne.n	14866 <osThreadYield+0x16>
    {
        return osErrorISR;
    }

    uwRet = LOS_TaskYield();
   1485a:	f7fe fe9f 	bl	1359c <LOS_TaskYield>

    if (uwRet == LOS_OK)
   1485e:	1e43      	subs	r3, r0, #1
   14860:	4198      	sbcs	r0, r3
        return osErrorISR;
   14862:	4240      	negs	r0, r0
    {
        return osOK;
    }

    return osError;
}
   14864:	bd10      	pop	{r4, pc}
        return osErrorISR;
   14866:	2006      	movs	r0, #6
   14868:	e7fb      	b.n	14862 <osThreadYield+0x12>

0001486a <osDelay>:


//  ==== Generic Wait Functions ====

osStatus_t osDelay (uint32_t ticks)
{
   1486a:	b510      	push	{r4, lr}
    UINT32 uwRet = 0;

    uwRet = LOS_TaskDelay(ticks);
   1486c:	f7fe fece 	bl	1360c <LOS_TaskDelay>
    if(uwRet == LOS_OK)
   14870:	1e43      	subs	r3, r0, #1
   14872:	4198      	sbcs	r0, r3
   14874:	4240      	negs	r0, r0
    }
    else
    {
        return osError;
    }
}
   14876:	bd10      	pop	{r4, pc}

00014878 <osTimerNew>:
}

//  ==== Timer Management Functions ====
#if (LOSCFG_BASE_CORE_SWTMR == YES)
osTimerId_t osTimerNew (osTimerFunc_t func, osTimerType_t type, void *argument, const osTimerAttr_t *attr)
{
   14878:	b57f      	push	{r0, r1, r2, r3, r4, r5, r6, lr}
   1487a:	0005      	movs	r5, r0
   1487c:	000c      	movs	r4, r1
   1487e:	0016      	movs	r6, r2
    UNUSED(attr);
    UINT16 usSwTmrID;
    UINT8 mode;

    if ((OS_INT_ACTIVE) || (NULL == func) ||
   14880:	f003 fce0 	bl	18244 <non_os_is_this_interrupt_context>
   14884:	2800      	cmp	r0, #0
   14886:	d002      	beq.n	1488e <osTimerNew+0x16>
        ((osTimerOnce != type) && (osTimerPeriodic != type)))
    {
        return (osTimerId_t)NULL;
   14888:	2000      	movs	r0, #0
    {
        return (osTimerId_t)NULL;
    }

    return (osTimerId_t)OS_SWT_FROM_SID(usSwTmrID);
}
   1488a:	b004      	add	sp, #16
   1488c:	bd70      	pop	{r4, r5, r6, pc}
    if ((OS_INT_ACTIVE) || (NULL == func) ||
   1488e:	2d00      	cmp	r5, #0
   14890:	d0fa      	beq.n	14888 <osTimerNew+0x10>
   14892:	2c01      	cmp	r4, #1
   14894:	d8f8      	bhi.n	14888 <osTimerNew+0x10>
        mode = LOS_SWTMR_MODE_PERIOD;
   14896:	4261      	negs	r1, r4
   14898:	4161      	adcs	r1, r4
    if (LOS_OK != LOS_SwtmrCreate(1, mode, (SWTMR_PROC_FUNC)func, &usSwTmrID, (UINT32)argument))
   1489a:	240e      	movs	r4, #14
   1489c:	446c      	add	r4, sp
        mode = LOS_SWTMR_MODE_PERIOD;
   1489e:	3101      	adds	r1, #1
    if (LOS_OK != LOS_SwtmrCreate(1, mode, (SWTMR_PROC_FUNC)func, &usSwTmrID, (UINT32)argument))
   148a0:	9600      	str	r6, [sp, #0]
   148a2:	0023      	movs	r3, r4
   148a4:	002a      	movs	r2, r5
   148a6:	2001      	movs	r0, #1
   148a8:	f7ff fbbc 	bl	14024 <LOS_SwtmrCreate>
   148ac:	2800      	cmp	r0, #0
   148ae:	d1eb      	bne.n	14888 <osTimerNew+0x10>
    return (osTimerId_t)OS_SWT_FROM_SID(usSwTmrID);
   148b0:	8820      	ldrh	r0, [r4, #0]
   148b2:	2113      	movs	r1, #19
   148b4:	f7eb fe06 	bl	4c4 <__aeabi_uidivmod>
   148b8:	4b02      	ldr	r3, [pc, #8]	; (148c4 <osTimerNew+0x4c>)
   148ba:	b288      	uxth	r0, r1
   148bc:	6819      	ldr	r1, [r3, #0]
   148be:	0140      	lsls	r0, r0, #5
   148c0:	1808      	adds	r0, r1, r0
   148c2:	e7e2      	b.n	1488a <osTimerNew+0x12>
   148c4:	01002ea4 	.word	0x01002ea4

000148c8 <osTimerStart>:


osStatus_t osTimerStart (osTimerId_t timer_id, uint32_t ticks)
{
   148c8:	b570      	push	{r4, r5, r6, lr}
   148ca:	0004      	movs	r4, r0
   148cc:	1e0d      	subs	r5, r1, #0
    UINT32 uwRet;
    SWTMR_CTRL_S *pstSwtmr;

    if ((0 == ticks) || (NULL == timer_id))
   148ce:	d103      	bne.n	148d8 <osTimerStart+0x10>
    {
        return osErrorParameter;
   148d0:	2304      	movs	r3, #4
    {
        return osErrorParameter;
    }
    else
    {
        return osErrorResource;
   148d2:	425b      	negs	r3, r3
    }
}
   148d4:	0018      	movs	r0, r3
   148d6:	bd70      	pop	{r4, r5, r6, pc}
    if ((0 == ticks) || (NULL == timer_id))
   148d8:	2800      	cmp	r0, #0
   148da:	d0f9      	beq.n	148d0 <osTimerStart+0x8>
    pstSwtmr->uwInterval = LOS_Tick2MS(ticks);
   148dc:	0008      	movs	r0, r1
   148de:	f7ff fc69 	bl	141b4 <LOS_Tick2MS>
   148e2:	6120      	str	r0, [r4, #16]
    pstSwtmr->uwExpiry = LOS_Tick2MS(ticks);
   148e4:	0028      	movs	r0, r5
   148e6:	f7ff fc65 	bl	141b4 <LOS_Tick2MS>
   148ea:	6160      	str	r0, [r4, #20]
    uwRet = LOS_SwtmrStart(pstSwtmr->usTimerID);
   148ec:	8920      	ldrh	r0, [r4, #8]
   148ee:	f7ff fbd9 	bl	140a4 <LOS_SwtmrStart>
        return osOK;
   148f2:	2300      	movs	r3, #0
    if (LOS_OK == uwRet)
   148f4:	4298      	cmp	r0, r3
   148f6:	d0ed      	beq.n	148d4 <osTimerStart+0xc>
    else if (LOS_ERRNO_SWTMR_ID_INVALID == uwRet)
   148f8:	4b02      	ldr	r3, [pc, #8]	; (14904 <osTimerStart+0x3c>)
   148fa:	4298      	cmp	r0, r3
   148fc:	d0e8      	beq.n	148d0 <osTimerStart+0x8>
        return osErrorResource;
   148fe:	2303      	movs	r3, #3
   14900:	e7e7      	b.n	148d2 <osTimerStart+0xa>
   14902:	46c0      	nop			; (mov r8, r8)
   14904:	02000305 	.word	0x02000305

00014908 <osTimerStop>:
    return (const char *)NULL;
}


osStatus_t osTimerStop (osTimerId_t timer_id)
{
   14908:	b570      	push	{r4, r5, r6, lr}
   1490a:	0005      	movs	r5, r0
    UINT32 uwRet;
    SWTMR_CTRL_S *pstSwtmr = (SWTMR_CTRL_S *)timer_id;

    if (OS_INT_ACTIVE)
   1490c:	f003 fc9a 	bl	18244 <non_os_is_this_interrupt_context>
   14910:	1e04      	subs	r4, r0, #0
   14912:	d110      	bne.n	14936 <osTimerStop+0x2e>
    {
        return osErrorISR;
    }

    if (NULL == pstSwtmr)
   14914:	2d00      	cmp	r5, #0
   14916:	d102      	bne.n	1491e <osTimerStop+0x16>
    {
        return osErrorParameter;
   14918:	2004      	movs	r0, #4
        return osErrorISR;
   1491a:	4240      	negs	r0, r0
    }
    else
    {
        return osErrorResource;
    }
}
   1491c:	bd70      	pop	{r4, r5, r6, pc}
    uwRet = LOS_SwtmrStop(pstSwtmr->usTimerID);
   1491e:	8928      	ldrh	r0, [r5, #8]
   14920:	f7ff fbec 	bl	140fc <LOS_SwtmrStop>
   14924:	0003      	movs	r3, r0
        return osOK;
   14926:	0020      	movs	r0, r4
    if (LOS_OK == uwRet)
   14928:	2b00      	cmp	r3, #0
   1492a:	d0f7      	beq.n	1491c <osTimerStop+0x14>
    else if (LOS_ERRNO_SWTMR_ID_INVALID == uwRet)
   1492c:	4a03      	ldr	r2, [pc, #12]	; (1493c <osTimerStop+0x34>)
        return osErrorResource;
   1492e:	2003      	movs	r0, #3
    else if (LOS_ERRNO_SWTMR_ID_INVALID == uwRet)
   14930:	4293      	cmp	r3, r2
   14932:	d1f2      	bne.n	1491a <osTimerStop+0x12>
   14934:	e7f0      	b.n	14918 <osTimerStop+0x10>
        return osErrorISR;
   14936:	2006      	movs	r0, #6
   14938:	e7ef      	b.n	1491a <osTimerStop+0x12>
   1493a:	46c0      	nop			; (mov r8, r8)
   1493c:	02000305 	.word	0x02000305

00014940 <osTimerDelete>:
    return (OS_SWTMR_STATUS_TICKING == ((SWTMR_CTRL_S *)timer_id)->ucState);
}


osStatus_t osTimerDelete (osTimerId_t timer_id)
{
   14940:	b570      	push	{r4, r5, r6, lr}
   14942:	0005      	movs	r5, r0
    UINT32 uwRet;
    SWTMR_CTRL_S  *pstSwtmr = (SWTMR_CTRL_S *)timer_id;

    if (OS_INT_ACTIVE)
   14944:	f003 fc7e 	bl	18244 <non_os_is_this_interrupt_context>
   14948:	1e04      	subs	r4, r0, #0
   1494a:	d110      	bne.n	1496e <osTimerDelete+0x2e>
    {
        return osErrorISR;
    }

    if (NULL == pstSwtmr)
   1494c:	2d00      	cmp	r5, #0
   1494e:	d102      	bne.n	14956 <osTimerDelete+0x16>
    {
        return osErrorParameter;
   14950:	2004      	movs	r0, #4
        return osErrorISR;
   14952:	4240      	negs	r0, r0
    }
    else
    {
        return osErrorResource;
    }
}
   14954:	bd70      	pop	{r4, r5, r6, pc}
    uwRet = LOS_SwtmrDelete(pstSwtmr->usTimerID);
   14956:	8928      	ldrh	r0, [r5, #8]
   14958:	f7ff fbfc 	bl	14154 <LOS_SwtmrDelete>
   1495c:	0003      	movs	r3, r0
        return osOK;
   1495e:	0020      	movs	r0, r4
    if (LOS_OK == uwRet)
   14960:	2b00      	cmp	r3, #0
   14962:	d0f7      	beq.n	14954 <osTimerDelete+0x14>
    else if (LOS_ERRNO_SWTMR_ID_INVALID == uwRet)
   14964:	4a03      	ldr	r2, [pc, #12]	; (14974 <osTimerDelete+0x34>)
        return osErrorResource;
   14966:	2003      	movs	r0, #3
    else if (LOS_ERRNO_SWTMR_ID_INVALID == uwRet)
   14968:	4293      	cmp	r3, r2
   1496a:	d1f2      	bne.n	14952 <osTimerDelete+0x12>
   1496c:	e7f0      	b.n	14950 <osTimerDelete+0x10>
        return osErrorISR;
   1496e:	2006      	movs	r0, #6
   14970:	e7ef      	b.n	14952 <osTimerDelete+0x12>
   14972:	46c0      	nop			; (mov r8, r8)
   14974:	02000305 	.word	0x02000305

00014978 <osMutexNew>:


//  ==== Mutex Management Functions ====
#if (LOSCFG_BASE_IPC_MUX == YES)
osMutexId_t osMutexNew (const osMutexAttr_t *attr)
{
   14978:	b507      	push	{r0, r1, r2, lr}
    UINT32 uwRet;
    UINT32 uwMuxId;

    UNUSED(attr);

    if (OS_INT_ACTIVE)
   1497a:	f003 fc63 	bl	18244 <non_os_is_this_interrupt_context>
   1497e:	2800      	cmp	r0, #0
   14980:	d001      	beq.n	14986 <osMutexNew+0xe>
    {
        return NULL;
   14982:	2000      	movs	r0, #0
    }
    else
    {
        return (osMutexId_t)NULL;
    }
}
   14984:	bd0e      	pop	{r1, r2, r3, pc}
    uwRet = LOS_MuxCreate(&uwMuxId);
   14986:	a801      	add	r0, sp, #4
   14988:	f00c fbc2 	bl	21110 <LOS_MuxCreate>
    if(uwRet == LOS_OK)
   1498c:	2800      	cmp	r0, #0
   1498e:	d1f8      	bne.n	14982 <osMutexNew+0xa>
        return (osMutexId_t)(GET_MUX(uwMuxId));
   14990:	2318      	movs	r3, #24
   14992:	9a01      	ldr	r2, [sp, #4]
   14994:	4353      	muls	r3, r2
   14996:	4a02      	ldr	r2, [pc, #8]	; (149a0 <osMutexNew+0x28>)
   14998:	6810      	ldr	r0, [r2, #0]
   1499a:	18c0      	adds	r0, r0, r3
   1499c:	e7f2      	b.n	14984 <osMutexNew+0xc>
   1499e:	46c0      	nop			; (mov r8, r8)
   149a0:	01002f10 	.word	0x01002f10

000149a4 <osMutexAcquire>:


osStatus_t osMutexAcquire (osMutexId_t mutex_id, uint32_t timeout)
{
   149a4:	b570      	push	{r4, r5, r6, lr}
   149a6:	0005      	movs	r5, r0
   149a8:	000c      	movs	r4, r1
    UINT32  uwRet;

    if (mutex_id == NULL)
   149aa:	2800      	cmp	r0, #0
   149ac:	d103      	bne.n	149b6 <osMutexAcquire+0x12>
    {
        return osErrorParameter;
   149ae:	2304      	movs	r3, #4
    {
        return osOK;
    }
    else if (uwRet == LOS_ERRNO_MUX_TIMEOUT)
    {
        return osErrorTimeout;
   149b0:	425b      	negs	r3, r3
    }
    else
    {
        return osErrorResource;
    }
}
   149b2:	0018      	movs	r0, r3
   149b4:	bd70      	pop	{r4, r5, r6, pc}
    if (OS_INT_ACTIVE && (timeout != LOS_NO_WAIT))
   149b6:	f003 fc45 	bl	18244 <non_os_is_this_interrupt_context>
        timeout = 0;
   149ba:	4243      	negs	r3, r0
   149bc:	4158      	adcs	r0, r3
   149be:	4240      	negs	r0, r0
   149c0:	4004      	ands	r4, r0
    uwRet = LOS_MuxPend(((MUX_CB_S*)mutex_id)->ucMuxID, timeout);
   149c2:	0021      	movs	r1, r4
   149c4:	6868      	ldr	r0, [r5, #4]
   149c6:	f00c fc15 	bl	211f4 <LOS_MuxPend>
        return osOK;
   149ca:	2300      	movs	r3, #0
    if(uwRet == LOS_OK)
   149cc:	4298      	cmp	r0, r3
   149ce:	d0f0      	beq.n	149b2 <osMutexAcquire+0xe>
    else if (uwRet == LOS_ERRNO_MUX_TIMEOUT)
   149d0:	4b04      	ldr	r3, [pc, #16]	; (149e4 <osMutexAcquire+0x40>)
   149d2:	4298      	cmp	r0, r3
   149d4:	d004      	beq.n	149e0 <osMutexAcquire+0x3c>
    else if (uwRet == LOS_ERRNO_MUX_INVALID)
   149d6:	4b04      	ldr	r3, [pc, #16]	; (149e8 <osMutexAcquire+0x44>)
   149d8:	4298      	cmp	r0, r3
   149da:	d0e8      	beq.n	149ae <osMutexAcquire+0xa>
        return osErrorResource;
   149dc:	2303      	movs	r3, #3
   149de:	e7e7      	b.n	149b0 <osMutexAcquire+0xc>
        return osErrorTimeout;
   149e0:	2302      	movs	r3, #2
   149e2:	e7e5      	b.n	149b0 <osMutexAcquire+0xc>
   149e4:	02001d07 	.word	0x02001d07
   149e8:	02001d01 	.word	0x02001d01

000149ec <osMutexRelease>:


osStatus_t osMutexRelease (osMutexId_t mutex_id)
{
   149ec:	b510      	push	{r4, lr}
    UINT32  uwRet;

    if (mutex_id == NULL)
   149ee:	2800      	cmp	r0, #0
   149f0:	d008      	beq.n	14a04 <osMutexRelease+0x18>
    {
        return osErrorParameter;
    }

    uwRet = LOS_MuxPost(((MUX_CB_S*)mutex_id)->ucMuxID);
   149f2:	6840      	ldr	r0, [r0, #4]
   149f4:	f00c fc8c 	bl	21310 <LOS_MuxPost>

    if (uwRet == LOS_OK)
    {
        return osOK;
   149f8:	2300      	movs	r3, #0
    if (uwRet == LOS_OK)
   149fa:	4298      	cmp	r0, r3
   149fc:	d000      	beq.n	14a00 <osMutexRelease+0x14>
    }
    else
    {
        return osErrorResource;
   149fe:	3b03      	subs	r3, #3
    }
}
   14a00:	0018      	movs	r0, r3
   14a02:	bd10      	pop	{r4, pc}
        return osErrorParameter;
   14a04:	2304      	movs	r3, #4
   14a06:	425b      	negs	r3, r3
   14a08:	e7fa      	b.n	14a00 <osMutexRelease+0x14>
	...

00014a0c <osMutexDelete>:
    return (osThreadId_t)pstTaskCB;
}


osStatus_t osMutexDelete (osMutexId_t mutex_id)
{
   14a0c:	b570      	push	{r4, r5, r6, lr}
   14a0e:	0005      	movs	r5, r0
    UINT32  uwRet;

    if (OS_INT_ACTIVE)
   14a10:	f003 fc18 	bl	18244 <non_os_is_this_interrupt_context>
   14a14:	1e04      	subs	r4, r0, #0
   14a16:	d110      	bne.n	14a3a <osMutexDelete+0x2e>
    {
        return osErrorISR;
    }

    if (mutex_id == NULL)
   14a18:	2d00      	cmp	r5, #0
   14a1a:	d102      	bne.n	14a22 <osMutexDelete+0x16>
    {
        return osErrorParameter;
   14a1c:	2004      	movs	r0, #4
        return osErrorISR;
   14a1e:	4240      	negs	r0, r0
    }
    else
    {
        return osErrorResource;
    }
}
   14a20:	bd70      	pop	{r4, r5, r6, pc}
    uwRet = LOS_MuxDelete(((MUX_CB_S*)mutex_id)->ucMuxID);
   14a22:	6868      	ldr	r0, [r5, #4]
   14a24:	f00c fbaa 	bl	2117c <LOS_MuxDelete>
   14a28:	0003      	movs	r3, r0
        return osOK;
   14a2a:	0020      	movs	r0, r4
    if(uwRet == LOS_OK)
   14a2c:	2b00      	cmp	r3, #0
   14a2e:	d0f7      	beq.n	14a20 <osMutexDelete+0x14>
    else if (uwRet == LOS_ERRNO_MUX_INVALID)
   14a30:	4a03      	ldr	r2, [pc, #12]	; (14a40 <osMutexDelete+0x34>)
        return osErrorResource;
   14a32:	2003      	movs	r0, #3
    else if (uwRet == LOS_ERRNO_MUX_INVALID)
   14a34:	4293      	cmp	r3, r2
   14a36:	d1f2      	bne.n	14a1e <osMutexDelete+0x12>
   14a38:	e7f0      	b.n	14a1c <osMutexDelete+0x10>
        return osErrorISR;
   14a3a:	2006      	movs	r0, #6
   14a3c:	e7ef      	b.n	14a1e <osMutexDelete+0x12>
   14a3e:	46c0      	nop			; (mov r8, r8)
   14a40:	02001d01 	.word	0x02001d01

00014a44 <osSemaphoreNew>:

//  ==== Semaphore Management Functions ====
#if (LOSCFG_BASE_IPC_SEM == YES)

osSemaphoreId_t osSemaphoreNew (uint32_t max_count, uint32_t initial_count, const osSemaphoreAttr_t *attr)
{
   14a44:	b537      	push	{r0, r1, r2, r4, r5, lr}
   14a46:	0005      	movs	r5, r0
   14a48:	000c      	movs	r4, r1
    UINT32 uwRet;
    UINT32 uwSemId;

    UNUSED(attr);

    if (OS_INT_ACTIVE)
   14a4a:	f003 fbfb 	bl	18244 <non_os_is_this_interrupt_context>
   14a4e:	2800      	cmp	r0, #0
   14a50:	d001      	beq.n	14a56 <osSemaphoreNew+0x12>
    {
        return (osSemaphoreId_t)NULL;
   14a52:	2000      	movs	r0, #0
    }
    else
    {
        return (osSemaphoreId_t)NULL;
    }
}
   14a54:	bd3e      	pop	{r1, r2, r3, r4, r5, pc}
   14a56:	b2a0      	uxth	r0, r4
        uwRet = LOS_BinarySemCreate((UINT16)initial_count, &uwSemId);
   14a58:	a901      	add	r1, sp, #4
    if(1 == max_count)
   14a5a:	2d01      	cmp	r5, #1
   14a5c:	d109      	bne.n	14a72 <osSemaphoreNew+0x2e>
        uwRet = LOS_BinarySemCreate((UINT16)initial_count, &uwSemId);
   14a5e:	f00c fd17 	bl	21490 <LOS_BinarySemCreate>
    if (uwRet == LOS_OK)
   14a62:	2800      	cmp	r0, #0
   14a64:	d1f5      	bne.n	14a52 <osSemaphoreNew+0xe>
        return (osSemaphoreId_t)(GET_SEM(uwSemId));
   14a66:	4a04      	ldr	r2, [pc, #16]	; (14a78 <osSemaphoreNew+0x34>)
   14a68:	9b01      	ldr	r3, [sp, #4]
   14a6a:	6810      	ldr	r0, [r2, #0]
   14a6c:	011b      	lsls	r3, r3, #4
   14a6e:	18c0      	adds	r0, r0, r3
   14a70:	e7f0      	b.n	14a54 <osSemaphoreNew+0x10>
        uwRet = LOS_SemCreate((UINT16)initial_count, &uwSemId);
   14a72:	f00c fccd 	bl	21410 <LOS_SemCreate>
   14a76:	e7f4      	b.n	14a62 <osSemaphoreNew+0x1e>
   14a78:	01002f24 	.word	0x01002f24

00014a7c <osSemaphoreAcquire>:


osStatus_t osSemaphoreAcquire (osSemaphoreId_t semaphore_id, uint32_t timeout)
{
   14a7c:	b570      	push	{r4, r5, r6, lr}
   14a7e:	0004      	movs	r4, r0
   14a80:	000d      	movs	r5, r1
    UINT32 uwRet;

    if (semaphore_id == NULL)
   14a82:	2800      	cmp	r0, #0
   14a84:	d103      	bne.n	14a8e <osSemaphoreAcquire+0x12>
    {
        return osErrorParameter;
   14a86:	2304      	movs	r3, #4
    {
        return osOK;
    }
    else if (uwRet == LOS_ERRNO_SEM_TIMEOUT)
    {
        return osErrorTimeout;
   14a88:	425b      	negs	r3, r3
    }
    else
    {
        return osErrorResource;
    }
}
   14a8a:	0018      	movs	r0, r3
   14a8c:	bd70      	pop	{r4, r5, r6, pc}
    if (OS_INT_ACTIVE && (timeout != LOS_NO_WAIT))
   14a8e:	f003 fbd9 	bl	18244 <non_os_is_this_interrupt_context>
   14a92:	2800      	cmp	r0, #0
   14a94:	d003      	beq.n	14a9e <osSemaphoreAcquire+0x22>
   14a96:	2d00      	cmp	r5, #0
   14a98:	d001      	beq.n	14a9e <osSemaphoreAcquire+0x22>
        return osErrorISR;
   14a9a:	2306      	movs	r3, #6
   14a9c:	e7f4      	b.n	14a88 <osSemaphoreAcquire+0xc>
    uwRet = LOS_SemPend(((SEM_CB_S *)semaphore_id)->usSemID, timeout);
   14a9e:	0029      	movs	r1, r5
   14aa0:	6860      	ldr	r0, [r4, #4]
   14aa2:	f00c fd1b 	bl	214dc <LOS_SemPend>
        return osOK;
   14aa6:	2300      	movs	r3, #0
    if (uwRet == LOS_OK)
   14aa8:	4298      	cmp	r0, r3
   14aaa:	d0ee      	beq.n	14a8a <osSemaphoreAcquire+0xe>
    else if (uwRet == LOS_ERRNO_SEM_TIMEOUT)
   14aac:	4b06      	ldr	r3, [pc, #24]	; (14ac8 <osSemaphoreAcquire+0x4c>)
   14aae:	4298      	cmp	r0, r3
   14ab0:	d007      	beq.n	14ac2 <osSemaphoreAcquire+0x46>
    else if (uwRet == LOS_ERRNO_SEM_INVALID)
   14ab2:	4b06      	ldr	r3, [pc, #24]	; (14acc <osSemaphoreAcquire+0x50>)
   14ab4:	4298      	cmp	r0, r3
   14ab6:	d0e6      	beq.n	14a86 <osSemaphoreAcquire+0xa>
    else if (uwRet == LOS_ERRNO_SEM_PEND_INTERR)
   14ab8:	4b05      	ldr	r3, [pc, #20]	; (14ad0 <osSemaphoreAcquire+0x54>)
   14aba:	4298      	cmp	r0, r3
   14abc:	d0ed      	beq.n	14a9a <osSemaphoreAcquire+0x1e>
        return osErrorResource;
   14abe:	2303      	movs	r3, #3
   14ac0:	e7e2      	b.n	14a88 <osSemaphoreAcquire+0xc>
        return osErrorTimeout;
   14ac2:	2302      	movs	r3, #2
   14ac4:	e7e0      	b.n	14a88 <osSemaphoreAcquire+0xc>
   14ac6:	46c0      	nop			; (mov r8, r8)
   14ac8:	02000707 	.word	0x02000707
   14acc:	02000701 	.word	0x02000701
   14ad0:	02000705 	.word	0x02000705

00014ad4 <osSemaphoreRelease>:


osStatus_t osSemaphoreRelease (osSemaphoreId_t semaphore_id)
{
   14ad4:	b510      	push	{r4, lr}
    UINT32  uwRet;

    if (semaphore_id == NULL)
   14ad6:	2800      	cmp	r0, #0
   14ad8:	d103      	bne.n	14ae2 <osSemaphoreRelease+0xe>
    {
        return osErrorParameter;
   14ada:	2304      	movs	r3, #4
    {
        return osErrorParameter;
    }
    else
    {
        return osErrorResource;
   14adc:	425b      	negs	r3, r3
    }
}
   14ade:	0018      	movs	r0, r3
   14ae0:	bd10      	pop	{r4, pc}
    uwRet = LOS_SemPost(((SEM_CB_S *)semaphore_id)->usSemID);
   14ae2:	6840      	ldr	r0, [r0, #4]
   14ae4:	f00c fd6e 	bl	215c4 <LOS_SemPost>
        return osOK;
   14ae8:	2300      	movs	r3, #0
    if (uwRet == LOS_OK)
   14aea:	4298      	cmp	r0, r3
   14aec:	d0f7      	beq.n	14ade <osSemaphoreRelease+0xa>
    else if (uwRet == LOS_ERRNO_SEM_INVALID)
   14aee:	4b02      	ldr	r3, [pc, #8]	; (14af8 <osSemaphoreRelease+0x24>)
   14af0:	4298      	cmp	r0, r3
   14af2:	d0f2      	beq.n	14ada <osSemaphoreRelease+0x6>
        return osErrorResource;
   14af4:	2303      	movs	r3, #3
   14af6:	e7f1      	b.n	14adc <osSemaphoreRelease+0x8>
   14af8:	02000701 	.word	0x02000701

00014afc <osMessageQueueNew>:


//  ==== Message Queue Management Functions ====
#if (LOSCFG_BASE_IPC_QUEUE == YES)
osMessageQueueId_t osMessageQueueNew (uint32_t msg_count, uint32_t msg_size, const osMessageQueueAttr_t *attr)
{
   14afc:	b530      	push	{r4, r5, lr}
   14afe:	0004      	movs	r4, r0
   14b00:	b085      	sub	sp, #20
   14b02:	000d      	movs	r5, r1
    UINT32 uwQueueID;
    UINT32 uwRet;
    UNUSED(attr);
    osMessageQueueId_t handle;

    if(0 == msg_count || 0 == msg_size || OS_INT_ACTIVE)
   14b04:	2800      	cmp	r0, #0
   14b06:	d102      	bne.n	14b0e <osMessageQueueNew+0x12>
    {
        return (osMessageQueueId_t)NULL;
   14b08:	2000      	movs	r0, #0
    {
        handle = (osMessageQueueId_t)NULL;
    }

    return handle;
}
   14b0a:	b005      	add	sp, #20
   14b0c:	bd30      	pop	{r4, r5, pc}
    if(0 == msg_count || 0 == msg_size || OS_INT_ACTIVE)
   14b0e:	2900      	cmp	r1, #0
   14b10:	d0fa      	beq.n	14b08 <osMessageQueueNew+0xc>
   14b12:	f003 fb97 	bl	18244 <non_os_is_this_interrupt_context>
   14b16:	2800      	cmp	r0, #0
   14b18:	d1f6      	bne.n	14b08 <osMessageQueueNew+0xc>
    uwRet = LOS_QueueCreate((char *)NULL, (UINT16)msg_count, &uwQueueID, 0,(UINT16)msg_size);
   14b1a:	b2ad      	uxth	r5, r5
   14b1c:	b2a1      	uxth	r1, r4
   14b1e:	9500      	str	r5, [sp, #0]
   14b20:	0003      	movs	r3, r0
   14b22:	aa03      	add	r2, sp, #12
   14b24:	f7ff fbc0 	bl	142a8 <LOS_QueueCreate>
    if (uwRet == LOS_OK)
   14b28:	2800      	cmp	r0, #0
   14b2a:	d1ed      	bne.n	14b08 <osMessageQueueNew+0xc>
        handle = (osMessageQueueId_t)(GET_QUEUE_HANDLE(uwQueueID));
   14b2c:	232c      	movs	r3, #44	; 0x2c
   14b2e:	9a03      	ldr	r2, [sp, #12]
   14b30:	4353      	muls	r3, r2
   14b32:	4a02      	ldr	r2, [pc, #8]	; (14b3c <osMessageQueueNew+0x40>)
   14b34:	6810      	ldr	r0, [r2, #0]
   14b36:	18c0      	adds	r0, r0, r3
   14b38:	e7e7      	b.n	14b0a <osMessageQueueNew+0xe>
   14b3a:	46c0      	nop			; (mov r8, r8)
   14b3c:	01002ed0 	.word	0x01002ed0

00014b40 <osMessageQueuePut>:


osStatus_t osMessageQueuePut (osMessageQueueId_t mq_id, const void *msg_ptr, uint8_t msg_prio, uint32_t timeout)
{
   14b40:	b570      	push	{r4, r5, r6, lr}
   14b42:	0004      	movs	r4, r0
   14b44:	000d      	movs	r5, r1
   14b46:	001e      	movs	r6, r3
    UNUSED(msg_prio);
    UINT32 uwRet;
    UINT32 uwBufferSize;
    QUEUE_CB_S *pstQueue = (QUEUE_CB_S *)mq_id;

    if (pstQueue == NULL || msg_ptr == NULL || ((OS_INT_ACTIVE) && (0 != timeout)))
   14b48:	2800      	cmp	r0, #0
   14b4a:	d103      	bne.n	14b54 <osMessageQueuePut+0x14>
    {
        return osErrorParameter;
   14b4c:	2304      	movs	r3, #4
   14b4e:	425b      	negs	r3, r3
    }
    else
    {
        return osErrorResource;
    }
}
   14b50:	0018      	movs	r0, r3
   14b52:	bd70      	pop	{r4, r5, r6, pc}
    if (pstQueue == NULL || msg_ptr == NULL || ((OS_INT_ACTIVE) && (0 != timeout)))
   14b54:	2900      	cmp	r1, #0
   14b56:	d0f9      	beq.n	14b4c <osMessageQueuePut+0xc>
   14b58:	f003 fb74 	bl	18244 <non_os_is_this_interrupt_context>
   14b5c:	2800      	cmp	r0, #0
   14b5e:	d001      	beq.n	14b64 <osMessageQueuePut+0x24>
   14b60:	2e00      	cmp	r6, #0
   14b62:	d1f3      	bne.n	14b4c <osMessageQueuePut+0xc>
    uwBufferSize = (UINT32)(pstQueue->usQueueSize - sizeof(UINT32));
   14b64:	8922      	ldrh	r2, [r4, #8]
    uwRet = LOS_QueueWriteCopy((UINT32)pstQueue->usQueueID, (void*)msg_ptr, uwBufferSize, timeout);
   14b66:	0033      	movs	r3, r6
    uwBufferSize = (UINT32)(pstQueue->usQueueSize - sizeof(UINT32));
   14b68:	3a04      	subs	r2, #4
    uwRet = LOS_QueueWriteCopy((UINT32)pstQueue->usQueueID, (void*)msg_ptr, uwBufferSize, timeout);
   14b6a:	8960      	ldrh	r0, [r4, #10]
   14b6c:	0029      	movs	r1, r5
   14b6e:	f7ff fcfb 	bl	14568 <LOS_QueueWriteCopy>
        return osOK;
   14b72:	2300      	movs	r3, #0
    if (uwRet == LOS_OK)
   14b74:	4298      	cmp	r0, r3
   14b76:	d0eb      	beq.n	14b50 <osMessageQueuePut+0x10>
    else if(uwRet == LOS_ERRNO_QUEUE_INVALID || uwRet == LOS_ERRNO_QUEUE_NOT_CREATE)
   14b78:	0002      	movs	r2, r0
   14b7a:	3304      	adds	r3, #4
   14b7c:	439a      	bics	r2, r3
   14b7e:	4b04      	ldr	r3, [pc, #16]	; (14b90 <osMessageQueuePut+0x50>)
   14b80:	429a      	cmp	r2, r3
   14b82:	d0e3      	beq.n	14b4c <osMessageQueuePut+0xc>
        return osErrorResource;
   14b84:	4b03      	ldr	r3, [pc, #12]	; (14b94 <osMessageQueuePut+0x54>)
   14b86:	18c0      	adds	r0, r0, r3
   14b88:	4243      	negs	r3, r0
   14b8a:	4143      	adcs	r3, r0
   14b8c:	3b03      	subs	r3, #3
   14b8e:	e7df      	b.n	14b50 <osMessageQueuePut+0x10>
   14b90:	0200060a 	.word	0x0200060a
   14b94:	fdfff9f9 	.word	0xfdfff9f9

00014b98 <osMessageQueueGet>:


osStatus_t osMessageQueueGet (osMessageQueueId_t mq_id, void *msg_ptr, uint8_t *msg_prio, uint32_t timeout)
{
   14b98:	b573      	push	{r0, r1, r4, r5, r6, lr}
   14b9a:	0004      	movs	r4, r0
   14b9c:	000d      	movs	r5, r1
   14b9e:	001e      	movs	r6, r3
    UNUSED(msg_prio);
    UINT32 uwRet;
    UINT32 uwBufferSize;
    QUEUE_CB_S *pstQueue = (QUEUE_CB_S *)mq_id;

    if (pstQueue == NULL || msg_ptr == NULL || ((OS_INT_ACTIVE) && (0 != timeout)))
   14ba0:	2800      	cmp	r0, #0
   14ba2:	d103      	bne.n	14bac <osMessageQueueGet+0x14>
    {
        return osErrorParameter;
   14ba4:	2304      	movs	r3, #4
   14ba6:	425b      	negs	r3, r3
    }
    else
    {
        return osErrorResource;
    }
}
   14ba8:	0018      	movs	r0, r3
   14baa:	bd76      	pop	{r1, r2, r4, r5, r6, pc}
    if (pstQueue == NULL || msg_ptr == NULL || ((OS_INT_ACTIVE) && (0 != timeout)))
   14bac:	2900      	cmp	r1, #0
   14bae:	d0f9      	beq.n	14ba4 <osMessageQueueGet+0xc>
   14bb0:	f003 fb48 	bl	18244 <non_os_is_this_interrupt_context>
   14bb4:	2800      	cmp	r0, #0
   14bb6:	d001      	beq.n	14bbc <osMessageQueueGet+0x24>
   14bb8:	2e00      	cmp	r6, #0
   14bba:	d1f3      	bne.n	14ba4 <osMessageQueueGet+0xc>
    uwBufferSize = (UINT32)(pstQueue->usQueueSize - sizeof(UINT32));
   14bbc:	8923      	ldrh	r3, [r4, #8]
    uwRet = LOS_QueueReadCopy((UINT32)pstQueue->usQueueID, msg_ptr, &uwBufferSize, timeout);
   14bbe:	8960      	ldrh	r0, [r4, #10]
    uwBufferSize = (UINT32)(pstQueue->usQueueSize - sizeof(UINT32));
   14bc0:	3b04      	subs	r3, #4
   14bc2:	9301      	str	r3, [sp, #4]
    uwRet = LOS_QueueReadCopy((UINT32)pstQueue->usQueueID, msg_ptr, &uwBufferSize, timeout);
   14bc4:	aa01      	add	r2, sp, #4
   14bc6:	0033      	movs	r3, r6
   14bc8:	0029      	movs	r1, r5
   14bca:	f7ff fca1 	bl	14510 <LOS_QueueReadCopy>
        return osOK;
   14bce:	2300      	movs	r3, #0
    if (uwRet == LOS_OK)
   14bd0:	4298      	cmp	r0, r3
   14bd2:	d0e9      	beq.n	14ba8 <osMessageQueueGet+0x10>
    else if (uwRet == LOS_ERRNO_QUEUE_INVALID || uwRet == LOS_ERRNO_QUEUE_NOT_CREATE)
   14bd4:	0002      	movs	r2, r0
   14bd6:	3304      	adds	r3, #4
   14bd8:	439a      	bics	r2, r3
   14bda:	4b04      	ldr	r3, [pc, #16]	; (14bec <osMessageQueueGet+0x54>)
   14bdc:	429a      	cmp	r2, r3
   14bde:	d0e1      	beq.n	14ba4 <osMessageQueueGet+0xc>
        return osErrorResource;
   14be0:	4b03      	ldr	r3, [pc, #12]	; (14bf0 <osMessageQueueGet+0x58>)
   14be2:	18c0      	adds	r0, r0, r3
   14be4:	4243      	negs	r3, r0
   14be6:	4143      	adcs	r3, r0
   14be8:	3b03      	subs	r3, #3
   14bea:	e7dd      	b.n	14ba8 <osMessageQueueGet+0x10>
   14bec:	0200060a 	.word	0x0200060a
   14bf0:	fdfff9f9 	.word	0xfdfff9f9

00014bf4 <osUartVetoCallbackRegister>:
#endif

#ifdef LOS_RUNSTOP
void osUartVetoCallbackRegister(cb_uart_is_need_awake_fn cb)
{
    if (cb != NULL)
   14bf4:	2800      	cmp	r0, #0
   14bf6:	d001      	beq.n	14bfc <osUartVetoCallbackRegister+0x8>
    {
        uart_is_need_awake_callback = (cb_uart_is_need_awake_fn)cb;
   14bf8:	4b01      	ldr	r3, [pc, #4]	; (14c00 <osUartVetoCallbackRegister+0xc>)
   14bfa:	6018      	str	r0, [r3, #0]
    }
    return;
}
   14bfc:	4770      	bx	lr
   14bfe:	46c0      	nop			; (mov r8, r8)
   14c00:	01002538 	.word	0x01002538

00014c04 <osAddStopClocksVeto>:
#endif

void osAddStopClocksVeto(void)
{
   14c04:	b510      	push	{r4, lr}
     tickless_add_stop_clocks_veto();
   14c06:	f7ff f85b 	bl	13cc0 <tickless_add_stop_clocks_veto>
}
   14c0a:	bd10      	pop	{r4, pc}

00014c0c <osRemoveStopClocksVeto>:

void osRemoveStopClocksVeto(void)
{
   14c0c:	b510      	push	{r4, lr}
     tickless_remove_stop_clocks_veto();
   14c0e:	f7ff f86b 	bl	13ce8 <tickless_remove_stop_clocks_veto>
}
   14c12:	bd10      	pop	{r4, pc}

00014c14 <uart_rx_buffer_unsent_data>:
 */
inline static uint16 uart_rx_buffer_unsent_data( UART_BUS uart )
{
    uint16 data_available = 0;

    if( uart_rx_state[uart]->rx_buffer_unsent )
   14c14:	4b0a      	ldr	r3, [pc, #40]	; (14c40 <uart_rx_buffer_unsent_data+0x2c>)
   14c16:	0080      	lsls	r0, r0, #2
   14c18:	58c3      	ldr	r3, [r0, r3]
    uint16 data_available = 0;
   14c1a:	2000      	movs	r0, #0
    if( uart_rx_state[uart]->rx_buffer_unsent )
   14c1c:	7e5a      	ldrb	r2, [r3, #25]
   14c1e:	4282      	cmp	r2, r0
   14c20:	d008      	beq.n	14c34 <uart_rx_buffer_unsent_data+0x20>
    {   // There is data to send
        if ( uart_rx_state[uart]->new_rx_pos >= uart_rx_state[uart]->first_pos_to_send )
   14c22:	8a58      	ldrh	r0, [r3, #18]
   14c24:	8a9a      	ldrh	r2, [r3, #20]
   14c26:	4290      	cmp	r0, r2
   14c28:	d305      	bcc.n	14c36 <uart_rx_buffer_unsent_data+0x22>
        {   // Circular buffer has not wrapped
            data_available = (uart_rx_state[uart]->new_rx_pos - uart_rx_state[uart]->first_pos_to_send);
   14c2a:	1a80      	subs	r0, r0, r2
   14c2c:	b280      	uxth	r0, r0
            if( data_available == 0 )
   14c2e:	2800      	cmp	r0, #0
   14c30:	d100      	bne.n	14c34 <uart_rx_buffer_unsent_data+0x20>
            {   //  Next write position (new_rx_pos) same as first send position implies that buffer is full
                data_available = uart_rx_state[uart]->rx_buffer_size;
   14c32:	8818      	ldrh	r0, [r3, #0]
            data_available = uart_rx_state[uart]->rx_buffer_size - (uart_rx_state[uart]->first_pos_to_send - uart_rx_state[uart]->new_rx_pos);
        }
    }

    return data_available;
}
   14c34:	4770      	bx	lr
            data_available = uart_rx_state[uart]->rx_buffer_size - (uart_rx_state[uart]->first_pos_to_send - uart_rx_state[uart]->new_rx_pos);
   14c36:	881b      	ldrh	r3, [r3, #0]
   14c38:	18c0      	adds	r0, r0, r3
   14c3a:	1a80      	subs	r0, r0, r2
   14c3c:	b280      	uxth	r0, r0
   14c3e:	e7f9      	b.n	14c34 <uart_rx_buffer_unsent_data+0x20>
   14c40:	01002578 	.word	0x01002578

00014c44 <uart_helper_invoke_rx_callback>:

inline static uint16 uart_helper_invoke_rx_callback( UART_BUS uart, uint16 data_available )
{
   14c44:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
   14c46:	000c      	movs	r4, r1
    // Ensure we don't let callback read past end of our circular buffer
    uint16 data_issued;
    if( (uart_rx_state[uart]->first_pos_to_send + data_available) > uart_rx_state[uart]->rx_buffer_size )
   14c48:	4f12      	ldr	r7, [pc, #72]	; (14c94 <uart_helper_invoke_rx_callback+0x50>)
   14c4a:	0086      	lsls	r6, r0, #2
   14c4c:	59f3      	ldr	r3, [r6, r7]
    {
        data_issued = uart_rx_state[uart]->rx_buffer_size - uart_rx_state[uart]->first_pos_to_send;
    }
    else
    {
        data_issued = data_available;
   14c4e:	0025      	movs	r5, r4
    if( (uart_rx_state[uart]->first_pos_to_send + data_available) > uart_rx_state[uart]->rx_buffer_size )
   14c50:	8a98      	ldrh	r0, [r3, #20]
   14c52:	881a      	ldrh	r2, [r3, #0]
   14c54:	1841      	adds	r1, r0, r1
   14c56:	4291      	cmp	r1, r2
   14c58:	dd01      	ble.n	14c5e <uart_helper_invoke_rx_callback+0x1a>
        data_issued = uart_rx_state[uart]->rx_buffer_size - uart_rx_state[uart]->first_pos_to_send;
   14c5a:	1a15      	subs	r5, r2, r0
   14c5c:	b2ad      	uxth	r5, r5
    }

    // Invoke the callback
    uart_rx_state[uart]->rx_callback(uart_rx_state[uart]->data_buffer + uart_rx_state[uart]->first_pos_to_send, data_issued, uart_release_functions[uart]);
   14c5e:	6a1a      	ldr	r2, [r3, #32]
   14c60:	0029      	movs	r1, r5
   14c62:	1810      	adds	r0, r2, r0
   14c64:	4a0c      	ldr	r2, [pc, #48]	; (14c98 <uart_helper_invoke_rx_callback+0x54>)
   14c66:	685b      	ldr	r3, [r3, #4]
   14c68:	5992      	ldr	r2, [r2, r6]
   14c6a:	4798      	blx	r3
#if defined UART_DEBUG
    uart_rx_state[uart]->data_bytes_sent += data_issued;
#endif

    // Update the pointers
    uart_rx_state[uart]->first_pos_to_send += data_issued;
   14c6c:	59bb      	ldr	r3, [r7, r6]
   14c6e:	8a9a      	ldrh	r2, [r3, #20]
    if( uart_rx_state[uart]->first_pos_to_send >= uart_rx_state[uart]->rx_buffer_size )
   14c70:	8819      	ldrh	r1, [r3, #0]
    uart_rx_state[uart]->first_pos_to_send += data_issued;
   14c72:	18aa      	adds	r2, r5, r2
   14c74:	b292      	uxth	r2, r2
   14c76:	829a      	strh	r2, [r3, #20]
    if( uart_rx_state[uart]->first_pos_to_send >= uart_rx_state[uart]->rx_buffer_size )
   14c78:	4291      	cmp	r1, r2
   14c7a:	d801      	bhi.n	14c80 <uart_helper_invoke_rx_callback+0x3c>
    {   // Wrap to beginning of buffer
        uart_rx_state[uart]->first_pos_to_send = 0;
   14c7c:	2200      	movs	r2, #0
   14c7e:	829a      	strh	r2, [r3, #20]
    }

    if( uart_rx_state[uart]->first_pos_to_send == uart_rx_state[uart]->new_rx_pos )
   14c80:	8a99      	ldrh	r1, [r3, #20]
   14c82:	8a5a      	ldrh	r2, [r3, #18]
   14c84:	4291      	cmp	r1, r2
   14c86:	d101      	bne.n	14c8c <uart_helper_invoke_rx_callback+0x48>
    {   // We've now reached the last write position, so client has been informed of all data received
        uart_rx_state[uart]->rx_buffer_unsent = false;
   14c88:	2200      	movs	r2, #0
   14c8a:	765a      	strb	r2, [r3, #25]
    }

    return (data_available - data_issued);
   14c8c:	1b60      	subs	r0, r4, r5
   14c8e:	b280      	uxth	r0, r0
}
   14c90:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
   14c92:	46c0      	nop			; (mov r8, r8)
   14c94:	01002578 	.word	0x01002578
   14c98:	00025528 	.word	0x00025528

00014c9c <uart_rx_dma_transfer_finish_manipulate>:
{
   14c9c:	b570      	push	{r4, r5, r6, lr}
    assert((*uart_dmac_register[uart] & UART_RXDMAE_MASK) != 0);
   14c9e:	4d08      	ldr	r5, [pc, #32]	; (14cc0 <uart_rx_dma_transfer_finish_manipulate+0x24>)
   14ca0:	0084      	lsls	r4, r0, #2
   14ca2:	5963      	ldr	r3, [r4, r5]
   14ca4:	681b      	ldr	r3, [r3, #0]
   14ca6:	07db      	lsls	r3, r3, #31
   14ca8:	d403      	bmi.n	14cb2 <uart_rx_dma_transfer_finish_manipulate+0x16>
   14caa:	4671      	mov	r1, lr
   14cac:	2016      	movs	r0, #22
   14cae:	f7ec ff2f 	bl	1b10 <panic>
    *uart_dmac_register[uart] &= ~UART_RXDMAE_MASK;
   14cb2:	2101      	movs	r1, #1
   14cb4:	592a      	ldr	r2, [r5, r4]
   14cb6:	6813      	ldr	r3, [r2, #0]
   14cb8:	438b      	bics	r3, r1
   14cba:	6013      	str	r3, [r2, #0]
}
   14cbc:	bd70      	pop	{r4, r5, r6, pc}
   14cbe:	46c0      	nop			; (mov r8, r8)
   14cc0:	01002548 	.word	0x01002548

00014cc4 <uart_rx_dma_transfer_prepare_manipulate>:
{
   14cc4:	b570      	push	{r4, r5, r6, lr}
    assert((*uart_dmac_register[uart] & UART_RXDMAE_MASK) == 0);
   14cc6:	4d08      	ldr	r5, [pc, #32]	; (14ce8 <uart_rx_dma_transfer_prepare_manipulate+0x24>)
   14cc8:	0084      	lsls	r4, r0, #2
   14cca:	5963      	ldr	r3, [r4, r5]
   14ccc:	681b      	ldr	r3, [r3, #0]
   14cce:	07db      	lsls	r3, r3, #31
   14cd0:	d503      	bpl.n	14cda <uart_rx_dma_transfer_prepare_manipulate+0x16>
   14cd2:	4671      	mov	r1, lr
   14cd4:	2016      	movs	r0, #22
   14cd6:	f7ec ff1b 	bl	1b10 <panic>
    *uart_dmac_register[uart] |= UART_RXDMAE_MASK;
   14cda:	2301      	movs	r3, #1
   14cdc:	592a      	ldr	r2, [r5, r4]
   14cde:	6811      	ldr	r1, [r2, #0]
   14ce0:	430b      	orrs	r3, r1
   14ce2:	6013      	str	r3, [r2, #0]
}
   14ce4:	bd70      	pop	{r4, r5, r6, pc}
   14ce6:	46c0      	nop			; (mov r8, r8)
   14ce8:	01002548 	.word	0x01002548

00014cec <uart_tx_dma_transfer_finish_manipulate>:
{
   14cec:	b570      	push	{r4, r5, r6, lr}
    assert((*uart_dmac_register[uart] & UART_TXDMAE_MASK) != 0);
   14cee:	4d08      	ldr	r5, [pc, #32]	; (14d10 <uart_tx_dma_transfer_finish_manipulate+0x24>)
   14cf0:	0084      	lsls	r4, r0, #2
   14cf2:	5963      	ldr	r3, [r4, r5]
   14cf4:	681b      	ldr	r3, [r3, #0]
   14cf6:	079b      	lsls	r3, r3, #30
   14cf8:	d403      	bmi.n	14d02 <uart_tx_dma_transfer_finish_manipulate+0x16>
   14cfa:	4671      	mov	r1, lr
   14cfc:	2016      	movs	r0, #22
   14cfe:	f7ec ff07 	bl	1b10 <panic>
    *uart_dmac_register[uart] &= ~UART_TXDMAE_MASK;
   14d02:	2102      	movs	r1, #2
   14d04:	592a      	ldr	r2, [r5, r4]
   14d06:	6813      	ldr	r3, [r2, #0]
   14d08:	438b      	bics	r3, r1
   14d0a:	6013      	str	r3, [r2, #0]
}
   14d0c:	bd70      	pop	{r4, r5, r6, pc}
   14d0e:	46c0      	nop			; (mov r8, r8)
   14d10:	01002548 	.word	0x01002548

00014d14 <uart_tx_dma_transfer_prepare_manipulate>:
{
   14d14:	b570      	push	{r4, r5, r6, lr}
    assert((*uart_dmac_register[uart] & UART_TXDMAE_MASK) == 0);
   14d16:	4d08      	ldr	r5, [pc, #32]	; (14d38 <uart_tx_dma_transfer_prepare_manipulate+0x24>)
   14d18:	0084      	lsls	r4, r0, #2
   14d1a:	5963      	ldr	r3, [r4, r5]
   14d1c:	681b      	ldr	r3, [r3, #0]
   14d1e:	079b      	lsls	r3, r3, #30
   14d20:	d503      	bpl.n	14d2a <uart_tx_dma_transfer_prepare_manipulate+0x16>
   14d22:	4671      	mov	r1, lr
   14d24:	2016      	movs	r0, #22
   14d26:	f7ec fef3 	bl	1b10 <panic>
    *uart_dmac_register[uart] |= UART_TXDMAE_MASK;
   14d2a:	2302      	movs	r3, #2
   14d2c:	592a      	ldr	r2, [r5, r4]
   14d2e:	6811      	ldr	r1, [r2, #0]
   14d30:	430b      	orrs	r3, r1
   14d32:	6013      	str	r3, [r2, #0]
}
   14d34:	bd70      	pop	{r4, r5, r6, pc}
   14d36:	46c0      	nop			; (mov r8, r8)
   14d38:	01002548 	.word	0x01002548

00014d3c <uart_helper_tx_fragments_claim_next_available>:

    hal_uart_clear_interrupt(uart,HAL_UART_INTERRUPT_ERROR);
}

static UART_TX_FRAGMENT * uart_helper_tx_fragments_claim_next_available( UART_BUS uart )
{
   14d3c:	b570      	push	{r4, r5, r6, lr}
   14d3e:	4675      	mov	r5, lr
   14d40:	0004      	movs	r4, r0
    assert( uart < UART_BUS_MAX_NUMBER );
   14d42:	2802      	cmp	r0, #2
   14d44:	d903      	bls.n	14d4e <uart_helper_tx_fragments_claim_next_available+0x12>
   14d46:	4671      	mov	r1, lr
   14d48:	2016      	movs	r0, #22
   14d4a:	f7ec fee1 	bl	1b10 <panic>
    assert( uart_tx_state[uart] != NULL );
   14d4e:	4e13      	ldr	r6, [pc, #76]	; (14d9c <uart_helper_tx_fragments_claim_next_available+0x60>)
   14d50:	00a4      	lsls	r4, r4, #2
   14d52:	59a3      	ldr	r3, [r4, r6]
   14d54:	2b00      	cmp	r3, #0
   14d56:	d103      	bne.n	14d60 <uart_helper_tx_fragments_claim_next_available+0x24>
   14d58:	0029      	movs	r1, r5
   14d5a:	2016      	movs	r0, #22
   14d5c:	f7ec fed8 	bl	1b10 <panic>

    // Iterate trough the blocks looking for a the first one with free fragments
    while ( block_i != NULL)
    {
        // check if the current block has free fragments
        if( block_i->next_free_fragment != NULL)
   14d60:	22a0      	movs	r2, #160	; 0xa0
    block_i = uart_tx_state[ uart ]->blocks_head;
   14d62:	5933      	ldr	r3, [r6, r4]
            break;
        }
        else
        {
            // move to the next block
            block_i = block_i->next;
   14d64:	490e      	ldr	r1, [pc, #56]	; (14da0 <uart_helper_tx_fragments_claim_next_available+0x64>)
    block_i = uart_tx_state[ uart ]->blocks_head;
   14d66:	68db      	ldr	r3, [r3, #12]
        if( block_i->next_free_fragment != NULL)
   14d68:	00d2      	lsls	r2, r2, #3
    while ( block_i != NULL)
   14d6a:	2b00      	cmp	r3, #0
   14d6c:	d101      	bne.n	14d72 <uart_helper_tx_fragments_claim_next_available+0x36>
    fragment = NULL;
   14d6e:	001c      	movs	r4, r3
        }
    }
    return fragment;
   14d70:	e010      	b.n	14d94 <uart_helper_tx_fragments_claim_next_available+0x58>
        if( block_i->next_free_fragment != NULL)
   14d72:	589c      	ldr	r4, [r3, r2]
   14d74:	2c00      	cmp	r4, #0
   14d76:	d00f      	beq.n	14d98 <uart_helper_tx_fragments_claim_next_available+0x5c>
            block_i->next_free_fragment = block_i->next_free_fragment->next;
   14d78:	6921      	ldr	r1, [r4, #16]
   14d7a:	5099      	str	r1, [r3, r2]
            block_i->fragments_in_use++;
   14d7c:	21a1      	movs	r1, #161	; 0xa1
   14d7e:	00c9      	lsls	r1, r1, #3
   14d80:	5c5a      	ldrb	r2, [r3, r1]
   14d82:	3201      	adds	r2, #1
   14d84:	b2d2      	uxtb	r2, r2
   14d86:	545a      	strb	r2, [r3, r1]
            assert( block_i->fragments_in_use <= UART_NUMBER_OF_FRAGMENTS_IN_BLOCK );
   14d88:	2a40      	cmp	r2, #64	; 0x40
   14d8a:	d903      	bls.n	14d94 <uart_helper_tx_fragments_claim_next_available+0x58>
   14d8c:	0029      	movs	r1, r5
   14d8e:	2016      	movs	r0, #22
   14d90:	f7ec febe 	bl	1b10 <panic>
}
   14d94:	0020      	movs	r0, r4
   14d96:	bd70      	pop	{r4, r5, r6, pc}
            block_i = block_i->next;
   14d98:	585b      	ldr	r3, [r3, r1]
   14d9a:	e7e6      	b.n	14d6a <uart_helper_tx_fragments_claim_next_available+0x2e>
   14d9c:	01002594 	.word	0x01002594
   14da0:	00000504 	.word	0x00000504

00014da4 <uart_ensure_sleep_vetoed>:

    non_os_exit_critical();
}

static void uart_ensure_sleep_vetoed(void)
{
   14da4:	b510      	push	{r4, lr}
    non_os_enter_critical();
   14da6:	f003 fa05 	bl	181b4 <non_os_enter_critical>

    if (!uart_sleep_vetoed)
   14daa:	4b05      	ldr	r3, [pc, #20]	; (14dc0 <uart_ensure_sleep_vetoed+0x1c>)
   14dac:	781a      	ldrb	r2, [r3, #0]
   14dae:	2a00      	cmp	r2, #0
   14db0:	d103      	bne.n	14dba <uart_ensure_sleep_vetoed+0x16>
    {
        uart_sleep_vetoed = true;
   14db2:	3201      	adds	r2, #1
   14db4:	701a      	strb	r2, [r3, #0]
        osAddStopClocksVeto();
   14db6:	f7ff ff25 	bl	14c04 <osAddStopClocksVeto>
    }

    non_os_exit_critical();
   14dba:	f003 fa0f 	bl	181dc <non_os_exit_critical>
}
   14dbe:	bd10      	pop	{r4, pc}
   14dc0:	01002584 	.word	0x01002584

00014dc4 <uart_helper_get_used_rx_buffer_space>:
{
   14dc4:	b510      	push	{r4, lr}
   14dc6:	0004      	movs	r4, r0
    non_os_enter_critical();
   14dc8:	f003 f9f4 	bl	181b4 <non_os_enter_critical>
    uint16 used_buffer_space = uart_rx_state[uart]->rx_buffer_size;
   14dcc:	4b09      	ldr	r3, [pc, #36]	; (14df4 <uart_helper_get_used_rx_buffer_space+0x30>)
   14dce:	00a4      	lsls	r4, r4, #2
   14dd0:	58e3      	ldr	r3, [r4, r3]
    if( !uart_rx_state[uart]->rx_buffer_full )
   14dd2:	7e1a      	ldrb	r2, [r3, #24]
    uint16 used_buffer_space = uart_rx_state[uart]->rx_buffer_size;
   14dd4:	881c      	ldrh	r4, [r3, #0]
    if( !uart_rx_state[uart]->rx_buffer_full )
   14dd6:	2a00      	cmp	r2, #0
   14dd8:	d105      	bne.n	14de6 <uart_helper_get_used_rx_buffer_space+0x22>
        if (uart_rx_state[uart]->first_reserved_pos <= uart_rx_state[uart]->new_rx_pos)
   14dda:	8ada      	ldrh	r2, [r3, #22]
   14ddc:	8a58      	ldrh	r0, [r3, #18]
   14dde:	4282      	cmp	r2, r0
   14de0:	d805      	bhi.n	14dee <uart_helper_get_used_rx_buffer_space+0x2a>
            used_buffer_space = (uart_rx_state[uart]->rx_buffer_size - uart_rx_state[uart]->first_reserved_pos) + uart_rx_state[uart]->new_rx_pos;
   14de2:	1a80      	subs	r0, r0, r2
   14de4:	b284      	uxth	r4, r0
    non_os_exit_critical();
   14de6:	f003 f9f9 	bl	181dc <non_os_exit_critical>
}
   14dea:	0020      	movs	r0, r4
   14dec:	bd10      	pop	{r4, pc}
   14dee:	1900      	adds	r0, r0, r4
   14df0:	e7f7      	b.n	14de2 <uart_helper_get_used_rx_buffer_space+0x1e>
   14df2:	46c0      	nop			; (mov r8, r8)
   14df4:	01002578 	.word	0x01002578

00014df8 <uart_remove_any_sleep_veto>:
{
   14df8:	b510      	push	{r4, lr}
    non_os_enter_critical();
   14dfa:	f003 f9db 	bl	181b4 <non_os_enter_critical>
    if (uart_sleep_vetoed)
   14dfe:	4b05      	ldr	r3, [pc, #20]	; (14e14 <uart_remove_any_sleep_veto+0x1c>)
   14e00:	781a      	ldrb	r2, [r3, #0]
   14e02:	2a00      	cmp	r2, #0
   14e04:	d003      	beq.n	14e0e <uart_remove_any_sleep_veto+0x16>
        uart_sleep_vetoed = false;
   14e06:	2200      	movs	r2, #0
   14e08:	701a      	strb	r2, [r3, #0]
        osRemoveStopClocksVeto();
   14e0a:	f7ff feff 	bl	14c0c <osRemoveStopClocksVeto>
    non_os_exit_critical();
   14e0e:	f003 f9e5 	bl	181dc <non_os_exit_critical>
}
   14e12:	bd10      	pop	{r4, pc}
   14e14:	01002584 	.word	0x01002584

00014e18 <uart_assert_software_tx_flow_control>:
{
   14e18:	b570      	push	{r4, r5, r6, lr}
   14e1a:	0004      	movs	r4, r0
    assert( non_os_is_driver_initialised(DRIVER_INIT_UART) );
   14e1c:	2008      	movs	r0, #8
   14e1e:	4676      	mov	r6, lr
{
   14e20:	000d      	movs	r5, r1
    assert( non_os_is_driver_initialised(DRIVER_INIT_UART) );
   14e22:	f003 f9ef 	bl	18204 <non_os_is_driver_initialised>
   14e26:	2800      	cmp	r0, #0
   14e28:	d103      	bne.n	14e32 <uart_assert_software_tx_flow_control+0x1a>
   14e2a:	0031      	movs	r1, r6
   14e2c:	3016      	adds	r0, #22
   14e2e:	f7ec fe6f 	bl	1b10 <panic>
    non_os_enter_critical();
   14e32:	f003 f9bf 	bl	181b4 <non_os_enter_critical>
   14e36:	4b0b      	ldr	r3, [pc, #44]	; (14e64 <uart_assert_software_tx_flow_control+0x4c>)
   14e38:	00a2      	lsls	r2, r4, #2
    if( asserted )
   14e3a:	2d00      	cmp	r5, #0
   14e3c:	d10b      	bne.n	14e56 <uart_assert_software_tx_flow_control+0x3e>
        uart_flow_control_state_array[uart].tx_requested = UART_FLOW_CONTROL_DEASSERTED;
   14e3e:	189b      	adds	r3, r3, r2
   14e40:	70dd      	strb	r5, [r3, #3]
        uart_ensure_sleep_vetoed();
   14e42:	f7ff ffaf 	bl	14da4 <uart_ensure_sleep_vetoed>
        hal_uart_enable_interrupt(uart,HAL_UART_INTERRUPT_TX);
   14e46:	0020      	movs	r0, r4
   14e48:	2101      	movs	r1, #1
   14e4a:	f004 fdc4 	bl	199d6 <hal_uart_enable_interrupt>
        hal_uart_force_tx_isr(uart);
   14e4e:	0020      	movs	r0, r4
   14e50:	f004 fecc 	bl	19bec <hal_uart_force_tx_isr>
   14e54:	e002      	b.n	14e5c <uart_assert_software_tx_flow_control+0x44>
        uart_flow_control_state_array[uart].tx_requested = UART_FLOW_CONTROL_ASSERTED;
   14e56:	189b      	adds	r3, r3, r2
   14e58:	2201      	movs	r2, #1
   14e5a:	70da      	strb	r2, [r3, #3]
    non_os_exit_critical();
   14e5c:	f003 f9be 	bl	181dc <non_os_exit_critical>
}
   14e60:	bd70      	pop	{r4, r5, r6, pc}
   14e62:	46c0      	nop			; (mov r8, r8)
   14e64:	01002554 	.word	0x01002554

00014e68 <uart_helper_handle_received_control_char>:
{
   14e68:	b510      	push	{r4, lr}
    switch( uart_data )
   14e6a:	2911      	cmp	r1, #17
   14e6c:	d006      	beq.n	14e7c <uart_helper_handle_received_control_char+0x14>
   14e6e:	2913      	cmp	r1, #19
   14e70:	d106      	bne.n	14e80 <uart_helper_handle_received_control_char+0x18>
        uart_assert_software_tx_flow_control( uart, true );
   14e72:	3912      	subs	r1, #18
        uart_assert_software_tx_flow_control( uart, false );
   14e74:	f7ff ffd0 	bl	14e18 <uart_assert_software_tx_flow_control>
        control_char_received = true;
   14e78:	2001      	movs	r0, #1
}
   14e7a:	bd10      	pop	{r4, pc}
        uart_assert_software_tx_flow_control( uart, false );
   14e7c:	2100      	movs	r1, #0
   14e7e:	e7f9      	b.n	14e74 <uart_helper_handle_received_control_char+0xc>
    bool control_char_received = false;
   14e80:	2000      	movs	r0, #0
   14e82:	e7fa      	b.n	14e7a <uart_helper_handle_received_control_char+0x12>

00014e84 <uart_assert_software_tx_flow_control2>:
{
    uart_assert_software_rx_flow_control( UART_BUS_2, asserted );
}

static void uart_assert_software_tx_flow_control2( bool asserted )
{
   14e84:	b510      	push	{r4, lr}
   14e86:	0001      	movs	r1, r0
    uart_assert_software_tx_flow_control( UART_BUS_2, asserted );
   14e88:	2002      	movs	r0, #2
   14e8a:	f7ff ffc5 	bl	14e18 <uart_assert_software_tx_flow_control>
}
   14e8e:	bd10      	pop	{r4, pc}

00014e90 <uart_assert_software_tx_flow_control1>:
{
   14e90:	b510      	push	{r4, lr}
   14e92:	0001      	movs	r1, r0
    uart_assert_software_tx_flow_control( UART_BUS_1, asserted );
   14e94:	2001      	movs	r0, #1
   14e96:	f7ff ffbf 	bl	14e18 <uart_assert_software_tx_flow_control>
}
   14e9a:	bd10      	pop	{r4, pc}

00014e9c <uart_assert_software_tx_flow_control0>:
{
   14e9c:	b510      	push	{r4, lr}
   14e9e:	0001      	movs	r1, r0
    uart_assert_software_tx_flow_control( UART_BUS_0, asserted );
   14ea0:	2000      	movs	r0, #0
   14ea2:	f7ff ffb9 	bl	14e18 <uart_assert_software_tx_flow_control>
}
   14ea6:	bd10      	pop	{r4, pc}

00014ea8 <uart_issue_rx_flow_control_char>:
{
   14ea8:	b570      	push	{r4, r5, r6, lr}
    if( uart_flow_control_state_array[uart].rx_issued != uart_flow_control_state_array[uart].rx_required )
   14eaa:	4c0d      	ldr	r4, [pc, #52]	; (14ee0 <uart_issue_rx_flow_control_char+0x38>)
   14eac:	0085      	lsls	r5, r0, #2
   14eae:	1964      	adds	r4, r4, r5
   14eb0:	78a1      	ldrb	r1, [r4, #2]
   14eb2:	7862      	ldrb	r2, [r4, #1]
    return true;
   14eb4:	2301      	movs	r3, #1
    if( uart_flow_control_state_array[uart].rx_issued != uart_flow_control_state_array[uart].rx_required )
   14eb6:	4291      	cmp	r1, r2
   14eb8:	d00d      	beq.n	14ed6 <uart_issue_rx_flow_control_char+0x2e>
        if( hal_uart_is_tx_fifo_full(uart) )
   14eba:	f004 fe81 	bl	19bc0 <hal_uart_is_tx_fifo_full>
            return false;
   14ebe:	2300      	movs	r3, #0
        if( hal_uart_is_tx_fifo_full(uart) )
   14ec0:	4298      	cmp	r0, r3
   14ec2:	d108      	bne.n	14ed6 <uart_issue_rx_flow_control_char+0x2e>
        uart_flow_control_state_array[uart].rx_issued = uart_flow_control_state_array[uart].rx_required;
   14ec4:	7862      	ldrb	r2, [r4, #1]
   14ec6:	4b07      	ldr	r3, [pc, #28]	; (14ee4 <uart_issue_rx_flow_control_char+0x3c>)
   14ec8:	70a2      	strb	r2, [r4, #2]
   14eca:	58eb      	ldr	r3, [r5, r3]
        if( uart_flow_control_state_array[uart].rx_required == UART_FLOW_CONTROL_DEASSERTED )
   14ecc:	2a00      	cmp	r2, #0
   14ece:	d104      	bne.n	14eda <uart_issue_rx_flow_control_char+0x32>
            *(uart_data_register[uart]) = uart_flow_control_chars[ UART_FLOW_CONTROL_DEASSERTED ];
   14ed0:	3211      	adds	r2, #17
            *(uart_data_register[uart]) = uart_flow_control_chars[ UART_FLOW_CONTROL_ASSERTED ];
   14ed2:	601a      	str	r2, [r3, #0]
    return true;
   14ed4:	2301      	movs	r3, #1
}
   14ed6:	0018      	movs	r0, r3
   14ed8:	bd70      	pop	{r4, r5, r6, pc}
            *(uart_data_register[uart]) = uart_flow_control_chars[ UART_FLOW_CONTROL_ASSERTED ];
   14eda:	2213      	movs	r2, #19
   14edc:	e7f9      	b.n	14ed2 <uart_issue_rx_flow_control_char+0x2a>
   14ede:	46c0      	nop			; (mov r8, r8)
   14ee0:	01002554 	.word	0x01002554
   14ee4:	0100253c 	.word	0x0100253c

00014ee8 <uart_assert_software_rx_flow_control>:
{
   14ee8:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
   14eea:	0004      	movs	r4, r0
    assert( non_os_is_driver_initialised(DRIVER_INIT_UART) );
   14eec:	2008      	movs	r0, #8
   14eee:	4675      	mov	r5, lr
{
   14ef0:	000f      	movs	r7, r1
    assert( non_os_is_driver_initialised(DRIVER_INIT_UART) );
   14ef2:	f003 f987 	bl	18204 <non_os_is_driver_initialised>
   14ef6:	2800      	cmp	r0, #0
   14ef8:	d103      	bne.n	14f02 <uart_assert_software_rx_flow_control+0x1a>
   14efa:	0029      	movs	r1, r5
   14efc:	3016      	adds	r0, #22
   14efe:	f7ec fe07 	bl	1b10 <panic>
    assert( uart < UART_BUS_MAX_NUMBER );
   14f02:	2c02      	cmp	r4, #2
   14f04:	d903      	bls.n	14f0e <uart_assert_software_rx_flow_control+0x26>
   14f06:	0029      	movs	r1, r5
   14f08:	2016      	movs	r0, #22
   14f0a:	f7ec fe01 	bl	1b10 <panic>
    if( uart_flow_control_state_array[uart].enabled )
   14f0e:	4d11      	ldr	r5, [pc, #68]	; (14f54 <uart_assert_software_rx_flow_control+0x6c>)
   14f10:	00a6      	lsls	r6, r4, #2
   14f12:	5d73      	ldrb	r3, [r6, r5]
   14f14:	2b00      	cmp	r3, #0
   14f16:	d01a      	beq.n	14f4e <uart_assert_software_rx_flow_control+0x66>
        non_os_enter_critical();
   14f18:	f003 f94c 	bl	181b4 <non_os_enter_critical>
   14f1c:	19ad      	adds	r5, r5, r6
        if( asserted )
   14f1e:	2f00      	cmp	r7, #0
   14f20:	d016      	beq.n	14f50 <uart_assert_software_rx_flow_control+0x68>
            uart_flow_control_state_array[uart].rx_required = UART_FLOW_CONTROL_ASSERTED;
   14f22:	2301      	movs	r3, #1
   14f24:	706b      	strb	r3, [r5, #1]
        if( uart_tx_state[uart] != NULL )
   14f26:	4b0c      	ldr	r3, [pc, #48]	; (14f58 <uart_assert_software_rx_flow_control+0x70>)
   14f28:	599b      	ldr	r3, [r3, r6]
   14f2a:	2b00      	cmp	r3, #0
   14f2c:	d00d      	beq.n	14f4a <uart_assert_software_rx_flow_control+0x62>
            if( !uart_issue_rx_flow_control_char(uart) )
   14f2e:	0020      	movs	r0, r4
   14f30:	f7ff ffba 	bl	14ea8 <uart_issue_rx_flow_control_char>
   14f34:	2800      	cmp	r0, #0
   14f36:	d108      	bne.n	14f4a <uart_assert_software_rx_flow_control+0x62>
                uart_ensure_sleep_vetoed();
   14f38:	f7ff ff34 	bl	14da4 <uart_ensure_sleep_vetoed>
                hal_uart_enable_interrupt( uart, HAL_UART_INTERRUPT_TX );
   14f3c:	0020      	movs	r0, r4
   14f3e:	2101      	movs	r1, #1
   14f40:	f004 fd49 	bl	199d6 <hal_uart_enable_interrupt>
                hal_uart_force_tx_isr( uart );
   14f44:	0020      	movs	r0, r4
   14f46:	f004 fe51 	bl	19bec <hal_uart_force_tx_isr>
        non_os_exit_critical();
   14f4a:	f003 f947 	bl	181dc <non_os_exit_critical>
}
   14f4e:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
            uart_flow_control_state_array[uart].rx_required = UART_FLOW_CONTROL_DEASSERTED;
   14f50:	706f      	strb	r7, [r5, #1]
   14f52:	e7e8      	b.n	14f26 <uart_assert_software_rx_flow_control+0x3e>
   14f54:	01002554 	.word	0x01002554
   14f58:	01002594 	.word	0x01002594

00014f5c <uart_helper_determine_rx_flow_control>:
{
   14f5c:	b570      	push	{r4, r5, r6, lr}
    if( uart_flow_control_state_array[uart].enabled )
   14f5e:	4b0b      	ldr	r3, [pc, #44]	; (14f8c <uart_helper_determine_rx_flow_control+0x30>)
   14f60:	0085      	lsls	r5, r0, #2
   14f62:	5ceb      	ldrb	r3, [r5, r3]
{
   14f64:	0004      	movs	r4, r0
    if( uart_flow_control_state_array[uart].enabled )
   14f66:	2b00      	cmp	r3, #0
   14f68:	d00e      	beq.n	14f88 <uart_helper_determine_rx_flow_control+0x2c>
        uint16 used_buffer_space = uart_helper_get_used_rx_buffer_space( uart );
   14f6a:	f7ff ff2b 	bl	14dc4 <uart_helper_get_used_rx_buffer_space>
        if( used_buffer_space >= uart_rx_state[uart]->rx_upper_water_margin )
   14f6e:	4b08      	ldr	r3, [pc, #32]	; (14f90 <uart_helper_determine_rx_flow_control+0x34>)
            uart_assert_software_rx_flow_control( uart, true );
   14f70:	2101      	movs	r1, #1
        if( used_buffer_space >= uart_rx_state[uart]->rx_upper_water_margin )
   14f72:	58eb      	ldr	r3, [r5, r3]
   14f74:	8b9a      	ldrh	r2, [r3, #28]
   14f76:	4282      	cmp	r2, r0
   14f78:	d903      	bls.n	14f82 <uart_helper_determine_rx_flow_control+0x26>
        else if( used_buffer_space <= uart_rx_state[uart]->rx_lower_water_margin )
   14f7a:	8bdb      	ldrh	r3, [r3, #30]
   14f7c:	4283      	cmp	r3, r0
   14f7e:	d303      	bcc.n	14f88 <uart_helper_determine_rx_flow_control+0x2c>
            uart_assert_software_rx_flow_control( uart, false );
   14f80:	2100      	movs	r1, #0
   14f82:	0020      	movs	r0, r4
   14f84:	f7ff ffb0 	bl	14ee8 <uart_assert_software_rx_flow_control>
}
   14f88:	bd70      	pop	{r4, r5, r6, pc}
   14f8a:	46c0      	nop			; (mov r8, r8)
   14f8c:	01002554 	.word	0x01002554
   14f90:	01002578 	.word	0x01002578

00014f94 <uart_helper_put_data_in_rx_buffer>:
{
   14f94:	b570      	push	{r4, r5, r6, lr}
    if( !uart_rx_state[uart]->rx_buffer_full )
   14f96:	4b10      	ldr	r3, [pc, #64]	; (14fd8 <uart_helper_put_data_in_rx_buffer+0x44>)
   14f98:	0082      	lsls	r2, r0, #2
   14f9a:	58d3      	ldr	r3, [r2, r3]
   14f9c:	7e1c      	ldrb	r4, [r3, #24]
   14f9e:	2c00      	cmp	r4, #0
   14fa0:	d118      	bne.n	14fd4 <uart_helper_put_data_in_rx_buffer+0x40>
        uart_rx_state[uart]->data_buffer[uart_rx_state[uart]->new_rx_pos] = (uint8)uart_data;                   // Extract data bits
   14fa2:	8a5a      	ldrh	r2, [r3, #18]
   14fa4:	6a1d      	ldr	r5, [r3, #32]
   14fa6:	54a9      	strb	r1, [r5, r2]
        uart_rx_state[uart]->error_buffer[uart_rx_state[uart]->new_rx_pos] = (uint8)((uart_data >> 8) & 0xF);   // Extract error flags
   14fa8:	8a5a      	ldrh	r2, [r3, #18]
   14faa:	0509      	lsls	r1, r1, #20
   14fac:	6a5d      	ldr	r5, [r3, #36]	; 0x24
   14fae:	0f09      	lsrs	r1, r1, #28
   14fb0:	54a9      	strb	r1, [r5, r2]
        uart_rx_state[uart]->new_rx_pos++;
   14fb2:	8a5a      	ldrh	r2, [r3, #18]
        if ( uart_rx_state[uart]->new_rx_pos >=  uart_rx_state[uart]->rx_buffer_size)
   14fb4:	8819      	ldrh	r1, [r3, #0]
        uart_rx_state[uart]->new_rx_pos++;
   14fb6:	3201      	adds	r2, #1
   14fb8:	b292      	uxth	r2, r2
   14fba:	825a      	strh	r2, [r3, #18]
        if ( uart_rx_state[uart]->new_rx_pos >=  uart_rx_state[uart]->rx_buffer_size)
   14fbc:	4291      	cmp	r1, r2
   14fbe:	d800      	bhi.n	14fc2 <uart_helper_put_data_in_rx_buffer+0x2e>
            uart_rx_state[uart]->new_rx_pos = 0;
   14fc0:	825c      	strh	r4, [r3, #18]
        if( uart_rx_state[uart]->new_rx_pos == uart_rx_state[uart]->first_reserved_pos)
   14fc2:	8a5c      	ldrh	r4, [r3, #18]
   14fc4:	8ad9      	ldrh	r1, [r3, #22]
   14fc6:	2201      	movs	r2, #1
   14fc8:	428c      	cmp	r4, r1
   14fca:	d100      	bne.n	14fce <uart_helper_put_data_in_rx_buffer+0x3a>
            uart_rx_state[uart]->rx_buffer_full = true;
   14fcc:	761a      	strb	r2, [r3, #24]
        uart_rx_state[uart]->rx_buffer_unsent = true;
   14fce:	765a      	strb	r2, [r3, #25]
        uart_helper_determine_rx_flow_control( uart );
   14fd0:	f7ff ffc4 	bl	14f5c <uart_helper_determine_rx_flow_control>
}
   14fd4:	bd70      	pop	{r4, r5, r6, pc}
   14fd6:	46c0      	nop			; (mov r8, r8)
   14fd8:	01002578 	.word	0x01002578

00014fdc <uart_error_isr>:
{
   14fdc:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
   14fde:	0004      	movs	r4, r0
    assert( non_os_is_driver_initialised(DRIVER_INIT_UART) );
   14fe0:	2008      	movs	r0, #8
   14fe2:	4677      	mov	r7, lr
   14fe4:	f003 f90e 	bl	18204 <non_os_is_driver_initialised>
   14fe8:	2800      	cmp	r0, #0
   14fea:	d103      	bne.n	14ff4 <uart_error_isr+0x18>
   14fec:	0039      	movs	r1, r7
   14fee:	3016      	adds	r0, #22
   14ff0:	f7ec fd8e 	bl	1b10 <panic>
    assert( uart_rx_state[uart] != NULL );
   14ff4:	4e31      	ldr	r6, [pc, #196]	; (150bc <uart_error_isr+0xe0>)
   14ff6:	00a5      	lsls	r5, r4, #2
   14ff8:	59ab      	ldr	r3, [r5, r6]
   14ffa:	2b00      	cmp	r3, #0
   14ffc:	d103      	bne.n	15006 <uart_error_isr+0x2a>
   14ffe:	0039      	movs	r1, r7
   15000:	2016      	movs	r0, #22
   15002:	f7ec fd85 	bl	1b10 <panic>
    if ((*hal_uart_get_error_register(uart)) & UART_PARITY_ERROR_MASK )
   15006:	0020      	movs	r0, r4
   15008:	f004 fc7c 	bl	19904 <hal_uart_get_error_register>
   1500c:	6803      	ldr	r3, [r0, #0]
   1500e:	05db      	lsls	r3, r3, #23
   15010:	d504      	bpl.n	1501c <uart_error_isr+0x40>
        if (uart_rx_state[uart]->parity_error_callback != NULL)
   15012:	5973      	ldr	r3, [r6, r5]
   15014:	689b      	ldr	r3, [r3, #8]
   15016:	2b00      	cmp	r3, #0
   15018:	d000      	beq.n	1501c <uart_error_isr+0x40>
            uart_rx_state[uart]->parity_error_callback();
   1501a:	4798      	blx	r3
    if ((*hal_uart_get_error_register(uart)) & UART_FRAME_ERROR_MASK )
   1501c:	0020      	movs	r0, r4
   1501e:	f004 fc71 	bl	19904 <hal_uart_get_error_register>
   15022:	6803      	ldr	r3, [r0, #0]
   15024:	061b      	lsls	r3, r3, #24
   15026:	d504      	bpl.n	15032 <uart_error_isr+0x56>
        if (uart_rx_state[uart]->frame_error_callback != NULL)
   15028:	5973      	ldr	r3, [r6, r5]
   1502a:	68db      	ldr	r3, [r3, #12]
   1502c:	2b00      	cmp	r3, #0
   1502e:	d000      	beq.n	15032 <uart_error_isr+0x56>
            uart_rx_state[uart]->frame_error_callback();
   15030:	4798      	blx	r3
    if( uart_flow_control_state_array[uart].enabled )
   15032:	4b23      	ldr	r3, [pc, #140]	; (150c0 <uart_error_isr+0xe4>)
   15034:	5d5b      	ldrb	r3, [r3, r5]
   15036:	2b00      	cmp	r3, #0
   15038:	d120      	bne.n	1507c <uart_error_isr+0xa0>
        while( !hal_uart_is_rx_fifo_empty(uart) && !uart_rx_state[uart]->rx_buffer_full )
   1503a:	0020      	movs	r0, r4
   1503c:	f004 fdce 	bl	19bdc <hal_uart_is_rx_fifo_empty>
   15040:	2800      	cmp	r0, #0
   15042:	d120      	bne.n	15086 <uart_error_isr+0xaa>
   15044:	5973      	ldr	r3, [r6, r5]
   15046:	7e1b      	ldrb	r3, [r3, #24]
   15048:	2b00      	cmp	r3, #0
   1504a:	d11c      	bne.n	15086 <uart_error_isr+0xaa>
            uart_error_isr_data = *(uart_data_register[uart]);
   1504c:	4b1d      	ldr	r3, [pc, #116]	; (150c4 <uart_error_isr+0xe8>)
            uart_helper_put_data_in_rx_buffer(uart, uart_error_isr_data);
   1504e:	0020      	movs	r0, r4
            uart_error_isr_data = *(uart_data_register[uart]);
   15050:	595b      	ldr	r3, [r3, r5]
   15052:	6819      	ldr	r1, [r3, #0]
            uart_helper_put_data_in_rx_buffer(uart, uart_error_isr_data);
   15054:	f7ff ff9e 	bl	14f94 <uart_helper_put_data_in_rx_buffer>
   15058:	e7ef      	b.n	1503a <uart_error_isr+0x5e>
        while( !hal_uart_is_rx_fifo_empty(uart) && !uart_rx_state[uart]->rx_buffer_full )
   1505a:	5973      	ldr	r3, [r6, r5]
   1505c:	7e1b      	ldrb	r3, [r3, #24]
   1505e:	2b00      	cmp	r3, #0
   15060:	d111      	bne.n	15086 <uart_error_isr+0xaa>
            uart_error_isr_data = *(uart_data_register[uart]);
   15062:	4b18      	ldr	r3, [pc, #96]	; (150c4 <uart_error_isr+0xe8>)
            if( !uart_helper_handle_received_control_char( uart, (uint8) uart_error_isr_data ) )
   15064:	0020      	movs	r0, r4
            uart_error_isr_data = *(uart_data_register[uart]);
   15066:	595b      	ldr	r3, [r3, r5]
   15068:	681f      	ldr	r7, [r3, #0]
            if( !uart_helper_handle_received_control_char( uart, (uint8) uart_error_isr_data ) )
   1506a:	b2f9      	uxtb	r1, r7
   1506c:	f7ff fefc 	bl	14e68 <uart_helper_handle_received_control_char>
   15070:	2800      	cmp	r0, #0
   15072:	d103      	bne.n	1507c <uart_error_isr+0xa0>
                uart_helper_put_data_in_rx_buffer(uart, uart_error_isr_data);
   15074:	0039      	movs	r1, r7
   15076:	0020      	movs	r0, r4
   15078:	f7ff ff8c 	bl	14f94 <uart_helper_put_data_in_rx_buffer>
        while( !hal_uart_is_rx_fifo_empty(uart) && !uart_rx_state[uart]->rx_buffer_full )
   1507c:	0020      	movs	r0, r4
   1507e:	f004 fdad 	bl	19bdc <hal_uart_is_rx_fifo_empty>
   15082:	2800      	cmp	r0, #0
   15084:	d0e9      	beq.n	1505a <uart_error_isr+0x7e>
        uart_error_isr_unsent_data = uart_rx_buffer_unsent_data(uart);
   15086:	0020      	movs	r0, r4
   15088:	f7ff fdc4 	bl	14c14 <uart_rx_buffer_unsent_data>
    while( uart_error_isr_unsent_data > 0 )
   1508c:	2800      	cmp	r0, #0
   1508e:	d104      	bne.n	1509a <uart_error_isr+0xbe>
    hal_uart_clear_interrupt(uart,HAL_UART_INTERRUPT_ERROR);
   15090:	2103      	movs	r1, #3
   15092:	0020      	movs	r0, r4
   15094:	f004 fd20 	bl	19ad8 <hal_uart_clear_interrupt>
}
   15098:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
        remaining = uart_helper_invoke_rx_callback(uart, min(uart_error_isr_unsent_data, uart_rx_state[uart]->rx_condition_size));
   1509a:	5973      	ldr	r3, [r6, r5]
   1509c:	8a1b      	ldrh	r3, [r3, #16]
   1509e:	1c19      	adds	r1, r3, #0
   150a0:	4283      	cmp	r3, r0
   150a2:	d900      	bls.n	150a6 <uart_error_isr+0xca>
   150a4:	1c01      	adds	r1, r0, #0
   150a6:	b289      	uxth	r1, r1
   150a8:	0020      	movs	r0, r4
   150aa:	f7ff fdcb 	bl	14c44 <uart_helper_invoke_rx_callback>
   150ae:	1e01      	subs	r1, r0, #0
        if( remaining )
   150b0:	d0e9      	beq.n	15086 <uart_error_isr+0xaa>
            (void)uart_helper_invoke_rx_callback(uart, remaining);
   150b2:	0020      	movs	r0, r4
   150b4:	f7ff fdc6 	bl	14c44 <uart_helper_invoke_rx_callback>
   150b8:	e7e5      	b.n	15086 <uart_error_isr+0xaa>
   150ba:	46c0      	nop			; (mov r8, r8)
   150bc:	01002578 	.word	0x01002578
   150c0:	01002554 	.word	0x01002554
   150c4:	0100253c 	.word	0x0100253c

000150c8 <uart_error_isr2>:
{
   150c8:	b510      	push	{r4, lr}
    uart_error_isr(UART_BUS_2);
   150ca:	2002      	movs	r0, #2
   150cc:	f7ff ff86 	bl	14fdc <uart_error_isr>
}
   150d0:	bd10      	pop	{r4, pc}

000150d2 <uart_error_isr1>:
{
   150d2:	b510      	push	{r4, lr}
    uart_error_isr(UART_BUS_1);
   150d4:	2001      	movs	r0, #1
   150d6:	f7ff ff81 	bl	14fdc <uart_error_isr>
}
   150da:	bd10      	pop	{r4, pc}

000150dc <uart_error_isr0>:
{
   150dc:	b510      	push	{r4, lr}
    uart_error_isr(UART_BUS_0);
   150de:	2000      	movs	r0, #0
   150e0:	f7ff ff7c 	bl	14fdc <uart_error_isr>
}
   150e4:	bd10      	pop	{r4, pc}

000150e6 <uart_assert_software_rx_flow_control2>:
{
   150e6:	b510      	push	{r4, lr}
   150e8:	0001      	movs	r1, r0
    uart_assert_software_rx_flow_control( UART_BUS_2, asserted );
   150ea:	2002      	movs	r0, #2
   150ec:	f7ff fefc 	bl	14ee8 <uart_assert_software_rx_flow_control>
}
   150f0:	bd10      	pop	{r4, pc}

000150f2 <uart_assert_software_rx_flow_control1>:
{
   150f2:	b510      	push	{r4, lr}
   150f4:	0001      	movs	r1, r0
    uart_assert_software_rx_flow_control( UART_BUS_1, asserted );
   150f6:	2001      	movs	r0, #1
   150f8:	f7ff fef6 	bl	14ee8 <uart_assert_software_rx_flow_control>
}
   150fc:	bd10      	pop	{r4, pc}

000150fe <uart_assert_software_rx_flow_control0>:
{
   150fe:	b510      	push	{r4, lr}
   15100:	0001      	movs	r1, r0
    uart_assert_software_rx_flow_control( UART_BUS_0, asserted );
   15102:	2000      	movs	r0, #0
   15104:	f7ff fef0 	bl	14ee8 <uart_assert_software_rx_flow_control>
}
   15108:	bd10      	pop	{r4, pc}
	...

0001510c <uart_idle_isr>:
{
   1510c:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
   1510e:	0004      	movs	r4, r0
    assert( non_os_is_driver_initialised(DRIVER_INIT_UART) );
   15110:	2008      	movs	r0, #8
   15112:	4677      	mov	r7, lr
   15114:	f003 f876 	bl	18204 <non_os_is_driver_initialised>
   15118:	2800      	cmp	r0, #0
   1511a:	d103      	bne.n	15124 <uart_idle_isr+0x18>
   1511c:	0039      	movs	r1, r7
   1511e:	3016      	adds	r0, #22
   15120:	f7ec fcf6 	bl	1b10 <panic>
    assert( uart_rx_state[uart] != NULL );
   15124:	4e2e      	ldr	r6, [pc, #184]	; (151e0 <uart_idle_isr+0xd4>)
   15126:	00a5      	lsls	r5, r4, #2
   15128:	59ab      	ldr	r3, [r5, r6]
   1512a:	2b00      	cmp	r3, #0
   1512c:	d103      	bne.n	15136 <uart_idle_isr+0x2a>
   1512e:	0039      	movs	r1, r7
   15130:	2016      	movs	r0, #22
   15132:	f7ec fced 	bl	1b10 <panic>
    if( uart_flow_control_state_array[uart].enabled )
   15136:	4b2b      	ldr	r3, [pc, #172]	; (151e4 <uart_idle_isr+0xd8>)
   15138:	5d5b      	ldrb	r3, [r3, r5]
   1513a:	2b00      	cmp	r3, #0
   1513c:	d120      	bne.n	15180 <uart_idle_isr+0x74>
        while( !hal_uart_is_rx_fifo_empty(uart) && !uart_rx_state[uart]->rx_buffer_full )
   1513e:	0020      	movs	r0, r4
   15140:	f004 fd4c 	bl	19bdc <hal_uart_is_rx_fifo_empty>
   15144:	2800      	cmp	r0, #0
   15146:	d120      	bne.n	1518a <uart_idle_isr+0x7e>
   15148:	5973      	ldr	r3, [r6, r5]
   1514a:	7e1b      	ldrb	r3, [r3, #24]
   1514c:	2b00      	cmp	r3, #0
   1514e:	d11c      	bne.n	1518a <uart_idle_isr+0x7e>
            uart_rx_isr_data = *(uart_data_register[uart]);
   15150:	4b25      	ldr	r3, [pc, #148]	; (151e8 <uart_idle_isr+0xdc>)
            uart_helper_put_data_in_rx_buffer(uart, uart_rx_isr_data);
   15152:	0020      	movs	r0, r4
            uart_rx_isr_data = *(uart_data_register[uart]);
   15154:	595b      	ldr	r3, [r3, r5]
   15156:	6819      	ldr	r1, [r3, #0]
            uart_helper_put_data_in_rx_buffer(uart, uart_rx_isr_data);
   15158:	f7ff ff1c 	bl	14f94 <uart_helper_put_data_in_rx_buffer>
   1515c:	e7ef      	b.n	1513e <uart_idle_isr+0x32>
        while( !hal_uart_is_rx_fifo_empty(uart) && !uart_rx_state[uart]->rx_buffer_full )
   1515e:	5973      	ldr	r3, [r6, r5]
   15160:	7e1b      	ldrb	r3, [r3, #24]
   15162:	2b00      	cmp	r3, #0
   15164:	d111      	bne.n	1518a <uart_idle_isr+0x7e>
            uart_rx_isr_data = *(uart_data_register[uart]);
   15166:	4b20      	ldr	r3, [pc, #128]	; (151e8 <uart_idle_isr+0xdc>)
            if( !uart_helper_handle_received_control_char( uart, (uint8) uart_rx_isr_data ) )
   15168:	0020      	movs	r0, r4
            uart_rx_isr_data = *(uart_data_register[uart]);
   1516a:	595b      	ldr	r3, [r3, r5]
   1516c:	681f      	ldr	r7, [r3, #0]
            if( !uart_helper_handle_received_control_char( uart, (uint8) uart_rx_isr_data ) )
   1516e:	b2f9      	uxtb	r1, r7
   15170:	f7ff fe7a 	bl	14e68 <uart_helper_handle_received_control_char>
   15174:	2800      	cmp	r0, #0
   15176:	d103      	bne.n	15180 <uart_idle_isr+0x74>
                uart_helper_put_data_in_rx_buffer(uart, uart_rx_isr_data);
   15178:	0039      	movs	r1, r7
   1517a:	0020      	movs	r0, r4
   1517c:	f7ff ff0a 	bl	14f94 <uart_helper_put_data_in_rx_buffer>
        while( !hal_uart_is_rx_fifo_empty(uart) && !uart_rx_state[uart]->rx_buffer_full )
   15180:	0020      	movs	r0, r4
   15182:	f004 fd2b 	bl	19bdc <hal_uart_is_rx_fifo_empty>
   15186:	2800      	cmp	r0, #0
   15188:	d0e9      	beq.n	1515e <uart_idle_isr+0x52>
    uart_rx_isr_unsent_data = uart_rx_buffer_unsent_data(uart);
   1518a:	0020      	movs	r0, r4
   1518c:	f7ff fd42 	bl	14c14 <uart_rx_buffer_unsent_data>
    while( ((uart_rx_isr_unsent_data > 0) && (uart_rx_state[uart]->rx_condition & UART_RX_CONDITION_MASK_IDLE)) ||  // Idle rx condition
   15190:	2701      	movs	r7, #1
   15192:	5973      	ldr	r3, [r6, r5]
   15194:	8a1a      	ldrh	r2, [r3, #16]
   15196:	2800      	cmp	r0, #0
   15198:	d002      	beq.n	151a0 <uart_idle_isr+0x94>
   1519a:	7e99      	ldrb	r1, [r3, #26]
   1519c:	4239      	tst	r1, r7
   1519e:	d10d      	bne.n	151bc <uart_idle_isr+0xb0>
   151a0:	4282      	cmp	r2, r0
   151a2:	d90b      	bls.n	151bc <uart_idle_isr+0xb0>
    if( uart_rx_state[uart]->rx_buffer_full )
   151a4:	7e1b      	ldrb	r3, [r3, #24]
   151a6:	2b00      	cmp	r3, #0
   151a8:	d007      	beq.n	151ba <uart_idle_isr+0xae>
        hal_uart_disable_interrupt( uart, HAL_UART_INTERRUPT_IDLE );
   151aa:	2102      	movs	r1, #2
   151ac:	0020      	movs	r0, r4
   151ae:	f004 fc35 	bl	19a1c <hal_uart_disable_interrupt>
        hal_uart_disable_interrupt( uart, HAL_UART_INTERRUPT_RX );
   151b2:	2100      	movs	r1, #0
   151b4:	0020      	movs	r0, r4
   151b6:	f004 fc31 	bl	19a1c <hal_uart_disable_interrupt>
}
   151ba:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
        remaining = uart_helper_invoke_rx_callback(uart, min(uart_rx_isr_unsent_data, uart_rx_state[uart]->rx_condition_size));
   151bc:	1c11      	adds	r1, r2, #0
   151be:	4282      	cmp	r2, r0
   151c0:	d900      	bls.n	151c4 <uart_idle_isr+0xb8>
   151c2:	1c01      	adds	r1, r0, #0
   151c4:	b289      	uxth	r1, r1
   151c6:	0020      	movs	r0, r4
   151c8:	f7ff fd3c 	bl	14c44 <uart_helper_invoke_rx_callback>
   151cc:	1e01      	subs	r1, r0, #0
        if( remaining )
   151ce:	d002      	beq.n	151d6 <uart_idle_isr+0xca>
            (void)uart_helper_invoke_rx_callback(uart, remaining);
   151d0:	0020      	movs	r0, r4
   151d2:	f7ff fd37 	bl	14c44 <uart_helper_invoke_rx_callback>
        uart_rx_isr_unsent_data = uart_rx_buffer_unsent_data(uart);
   151d6:	0020      	movs	r0, r4
   151d8:	f7ff fd1c 	bl	14c14 <uart_rx_buffer_unsent_data>
   151dc:	e7d9      	b.n	15192 <uart_idle_isr+0x86>
   151de:	46c0      	nop			; (mov r8, r8)
   151e0:	01002578 	.word	0x01002578
   151e4:	01002554 	.word	0x01002554
   151e8:	0100253c 	.word	0x0100253c

000151ec <uart_idle_isr2>:
{
   151ec:	b510      	push	{r4, lr}
    uart_idle_isr(UART_BUS_2);
   151ee:	2002      	movs	r0, #2
   151f0:	f7ff ff8c 	bl	1510c <uart_idle_isr>
}
   151f4:	bd10      	pop	{r4, pc}

000151f6 <uart_idle_isr1>:
{
   151f6:	b510      	push	{r4, lr}
    uart_idle_isr(UART_BUS_1);
   151f8:	2001      	movs	r0, #1
   151fa:	f7ff ff87 	bl	1510c <uart_idle_isr>
}
   151fe:	bd10      	pop	{r4, pc}

00015200 <uart_idle_isr0>:
{
   15200:	b510      	push	{r4, lr}
    uart_idle_isr(UART_BUS_0);
   15202:	2000      	movs	r0, #0
   15204:	f7ff ff82 	bl	1510c <uart_idle_isr>
}
   15208:	bd10      	pop	{r4, pc}
	...

0001520c <uart_tx_isr>:
{
   1520c:	4673      	mov	r3, lr
   1520e:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
   15210:	9000      	str	r0, [sp, #0]
    assert( non_os_is_driver_initialised(DRIVER_INIT_UART) );
   15212:	2008      	movs	r0, #8
   15214:	9301      	str	r3, [sp, #4]
   15216:	f002 fff5 	bl	18204 <non_os_is_driver_initialised>
   1521a:	2800      	cmp	r0, #0
   1521c:	d103      	bne.n	15226 <uart_tx_isr+0x1a>
   1521e:	9901      	ldr	r1, [sp, #4]
   15220:	3016      	adds	r0, #22
   15222:	f7ec fc75 	bl	1b10 <panic>
    assert( uart_tx_state[uart] != NULL );
   15226:	9b00      	ldr	r3, [sp, #0]
   15228:	4f47      	ldr	r7, [pc, #284]	; (15348 <uart_tx_isr+0x13c>)
   1522a:	009d      	lsls	r5, r3, #2
   1522c:	59eb      	ldr	r3, [r5, r7]
   1522e:	2b00      	cmp	r3, #0
   15230:	d103      	bne.n	1523a <uart_tx_isr+0x2e>
   15232:	9901      	ldr	r1, [sp, #4]
   15234:	2016      	movs	r0, #22
   15236:	f7ec fc6b 	bl	1b10 <panic>
    if( uart_flow_control_state_array[uart].enabled )
   1523a:	4e44      	ldr	r6, [pc, #272]	; (1534c <uart_tx_isr+0x140>)
    UART_TX_STATE *tx_state = uart_tx_state[uart];
   1523c:	597c      	ldr	r4, [r7, r5]
    if( uart_flow_control_state_array[uart].enabled )
   1523e:	5d73      	ldrb	r3, [r6, r5]
   15240:	2b00      	cmp	r3, #0
   15242:	d011      	beq.n	15268 <uart_tx_isr+0x5c>
        if( !uart_issue_rx_flow_control_char(uart) )
   15244:	9800      	ldr	r0, [sp, #0]
   15246:	f7ff fe2f 	bl	14ea8 <uart_issue_rx_flow_control_char>
   1524a:	2800      	cmp	r0, #0
   1524c:	d00b      	beq.n	15266 <uart_tx_isr+0x5a>
        if( uart_flow_control_state_array[uart].tx_requested == UART_FLOW_CONTROL_ASSERTED )
   1524e:	1976      	adds	r6, r6, r5
   15250:	78f3      	ldrb	r3, [r6, #3]
   15252:	2b01      	cmp	r3, #1
   15254:	d108      	bne.n	15268 <uart_tx_isr+0x5c>
            hal_uart_disable_interrupt(uart, HAL_UART_INTERRUPT_TX);
   15256:	2101      	movs	r1, #1
   15258:	9800      	ldr	r0, [sp, #0]
   1525a:	f004 fbdf 	bl	19a1c <hal_uart_disable_interrupt>
            hal_uart_clear_interrupt(uart, HAL_UART_INTERRUPT_TX);
   1525e:	2101      	movs	r1, #1
   15260:	9800      	ldr	r0, [sp, #0]
   15262:	f004 fc39 	bl	19ad8 <hal_uart_clear_interrupt>
}
   15266:	bdf7      	pop	{r0, r1, r2, r4, r5, r6, r7, pc}
    return (uart_tx_state[uart]->fragments_to_process > 0);
   15268:	597b      	ldr	r3, [r7, r5]
    if( uart_helper_are_there_fragments_to_process(uart) )
   1526a:	891b      	ldrh	r3, [r3, #8]
                if( !uart_helper_are_there_fragments_to_process(uart) )
   1526c:	2b00      	cmp	r3, #0
   1526e:	d0f2      	beq.n	15256 <uart_tx_isr+0x4a>
    register volatile uint32 *uartfr = hal_uart_get_flag_register(uart);
   15270:	9800      	ldr	r0, [sp, #0]
    current_fragment = tx_state->current_tx_fragment;
   15272:	6825      	ldr	r5, [r4, #0]
    current_fragment_pos = tx_state->current_tx_fragment_pos;
   15274:	8967      	ldrh	r7, [r4, #10]
    register volatile uint32 *uartfr = hal_uart_get_flag_register(uart);
   15276:	f004 fb4a 	bl	1990e <hal_uart_get_flag_register>
   1527a:	0006      	movs	r6, r0
    register volatile uint32 *uartdr = hal_uart_get_data_register(uart);
   1527c:	9800      	ldr	r0, [sp, #0]
   1527e:	f004 fb3d 	bl	198fc <hal_uart_get_data_register>
    register uint8 *uart_data = current_fragment->data + current_fragment_pos;
   15282:	682b      	ldr	r3, [r5, #0]
    register uint8 *uart_data_end = current_fragment->data + current_fragment->data_length;
   15284:	89aa      	ldrh	r2, [r5, #12]
    register uint8 *uart_data = current_fragment->data + current_fragment_pos;
   15286:	19df      	adds	r7, r3, r7
    register uint8 *uart_data_end = current_fragment->data + current_fragment->data_length;
   15288:	189a      	adds	r2, r3, r2
    while( ((*uartfr & HAL_UARTFR_TXFF_FLAG) == 0) && (uart_data < uart_data_end) )
   1528a:	2120      	movs	r1, #32
   1528c:	6833      	ldr	r3, [r6, #0]
   1528e:	420b      	tst	r3, r1
   15290:	d101      	bne.n	15296 <uart_tx_isr+0x8a>
   15292:	42ba      	cmp	r2, r7
   15294:	d853      	bhi.n	1533e <uart_tx_isr+0x132>
        while( uart_helper_send_next_chars(uart, tx_state) )
   15296:	2220      	movs	r2, #32
    tx_state->current_tx_fragment_pos = (uint16)(uart_data - current_fragment->data);
   15298:	682b      	ldr	r3, [r5, #0]
   1529a:	1aff      	subs	r7, r7, r3
   1529c:	b2bf      	uxth	r7, r7
   1529e:	8167      	strh	r7, [r4, #10]
    return ((*uartfr & HAL_UARTFR_TXFF_FLAG) == 0);
   152a0:	6833      	ldr	r3, [r6, #0]
        while( uart_helper_send_next_chars(uart, tx_state) )
   152a2:	4213      	tst	r3, r2
   152a4:	d1df      	bne.n	15266 <uart_tx_isr+0x5a>
            if( tx_state->current_tx_fragment_pos >= tx_state->current_tx_fragment->data_length )
   152a6:	6823      	ldr	r3, [r4, #0]
   152a8:	899b      	ldrh	r3, [r3, #12]
   152aa:	42bb      	cmp	r3, r7
   152ac:	d8e0      	bhi.n	15270 <uart_tx_isr+0x64>
    assert( uart_tx_state[uart] != NULL );
   152ae:	9b00      	ldr	r3, [sp, #0]
   152b0:	4e25      	ldr	r6, [pc, #148]	; (15348 <uart_tx_isr+0x13c>)
   152b2:	009d      	lsls	r5, r3, #2
   152b4:	59ab      	ldr	r3, [r5, r6]
   152b6:	2b00      	cmp	r3, #0
   152b8:	d103      	bne.n	152c2 <uart_tx_isr+0xb6>
   152ba:	9901      	ldr	r1, [sp, #4]
   152bc:	2016      	movs	r0, #22
   152be:	f7ec fc27 	bl	1b10 <panic>
    current_fragment = uart_tx_state[uart]->current_tx_fragment;
   152c2:	5973      	ldr	r3, [r6, r5]
   152c4:	6818      	ldr	r0, [r3, #0]
    if (current_fragment->release_func != NULL)
   152c6:	6883      	ldr	r3, [r0, #8]
   152c8:	2b00      	cmp	r3, #0
   152ca:	d003      	beq.n	152d4 <uart_tx_isr+0xc8>
        current_fragment->release_func(current_fragment->data, current_fragment->data_length, current_fragment->params);
   152cc:	8981      	ldrh	r1, [r0, #12]
   152ce:	6842      	ldr	r2, [r0, #4]
   152d0:	6800      	ldr	r0, [r0, #0]
   152d2:	4798      	blx	r3
    assert( non_os_is_driver_initialised(DRIVER_INIT_UART) );
   152d4:	2008      	movs	r0, #8
   152d6:	f002 ff95 	bl	18204 <non_os_is_driver_initialised>
   152da:	2800      	cmp	r0, #0
   152dc:	d103      	bne.n	152e6 <uart_tx_isr+0xda>
   152de:	9901      	ldr	r1, [sp, #4]
   152e0:	3016      	adds	r0, #22
   152e2:	f7ec fc15 	bl	1b10 <panic>
    assert( uart_tx_state[uart] != NULL );
   152e6:	5973      	ldr	r3, [r6, r5]
   152e8:	2b00      	cmp	r3, #0
   152ea:	d103      	bne.n	152f4 <uart_tx_isr+0xe8>
   152ec:	9901      	ldr	r1, [sp, #4]
   152ee:	2016      	movs	r0, #22
   152f0:	f7ec fc0e 	bl	1b10 <panic>
    uart_tx_state[uart]->current_tx_fragment_pos = 0;
   152f4:	2000      	movs	r0, #0
    fragment_to_release = uart_tx_state[uart]->current_tx_fragment;
   152f6:	5972      	ldr	r2, [r6, r5]
   152f8:	6813      	ldr	r3, [r2, #0]
    uart_tx_state[uart]->current_tx_fragment = fragment_to_release->next;
   152fa:	6919      	ldr	r1, [r3, #16]
    uart_tx_state[uart]->current_tx_fragment_pos = 0;
   152fc:	8150      	strh	r0, [r2, #10]
    uart_tx_state[uart]->current_tx_fragment = fragment_to_release->next;
   152fe:	6011      	str	r1, [r2, #0]
    if(uart_tx_state[uart]->current_tx_fragment == NULL)
   15300:	4281      	cmp	r1, r0
   15302:	d100      	bne.n	15306 <uart_tx_isr+0xfa>
        uart_tx_state[uart]->last_tx_fragment = NULL;
   15304:	6051      	str	r1, [r2, #4]
    block_i = uart_tx_state[ uart ]->blocks_head;
   15306:	5972      	ldr	r2, [r6, r5]
        block_i = block_i->next;
   15308:	4911      	ldr	r1, [pc, #68]	; (15350 <uart_tx_isr+0x144>)
    block_i = uart_tx_state[ uart ]->blocks_head;
   1530a:	68d0      	ldr	r0, [r2, #12]
   1530c:	e000      	b.n	15310 <uart_tx_isr+0x104>
        block_i = block_i->next;
   1530e:	5840      	ldr	r0, [r0, r1]
    while ( block_i != NULL)
   15310:	2800      	cmp	r0, #0
   15312:	d00f      	beq.n	15334 <uart_tx_isr+0x128>
        if (    fragment_to_release >= block_i->fragments
   15314:	4283      	cmp	r3, r0
   15316:	d3fa      	bcc.n	1530e <uart_tx_isr+0x102>
             && fragment_to_release <= ( block_i->fragments  + UART_NUMBER_OF_FRAGMENTS_IN_BLOCK -1 ) )
   15318:	4d0e      	ldr	r5, [pc, #56]	; (15354 <uart_tx_isr+0x148>)
   1531a:	1945      	adds	r5, r0, r5
   1531c:	42ab      	cmp	r3, r5
   1531e:	d8f6      	bhi.n	1530e <uart_tx_isr+0x102>
            block_i->fragments_in_use--;
   15320:	25a1      	movs	r5, #161	; 0xa1
   15322:	00ed      	lsls	r5, r5, #3
   15324:	5d41      	ldrb	r1, [r0, r5]
   15326:	3901      	subs	r1, #1
   15328:	5541      	strb	r1, [r0, r5]
            fragment_to_release->next = block_i->next_free_fragment;
   1532a:	21a0      	movs	r1, #160	; 0xa0
   1532c:	00c9      	lsls	r1, r1, #3
   1532e:	5845      	ldr	r5, [r0, r1]
   15330:	611d      	str	r5, [r3, #16]
            block_i->next_free_fragment = fragment_to_release;
   15332:	5043      	str	r3, [r0, r1]
    uart_tx_state[uart]->fragments_to_process--;
   15334:	8913      	ldrh	r3, [r2, #8]
   15336:	3b01      	subs	r3, #1
   15338:	b29b      	uxth	r3, r3
   1533a:	8113      	strh	r3, [r2, #8]
   1533c:	e796      	b.n	1526c <uart_tx_isr+0x60>
        *uartdr = *uart_data++;
   1533e:	783b      	ldrb	r3, [r7, #0]
   15340:	3701      	adds	r7, #1
   15342:	6003      	str	r3, [r0, #0]
   15344:	e7a1      	b.n	1528a <uart_tx_isr+0x7e>
   15346:	46c0      	nop			; (mov r8, r8)
   15348:	01002594 	.word	0x01002594
   1534c:	01002554 	.word	0x01002554
   15350:	00000504 	.word	0x00000504
   15354:	000004ec 	.word	0x000004ec

00015358 <uart_tx_isr2>:
{
   15358:	b510      	push	{r4, lr}
    uart_tx_isr(UART_BUS_2);
   1535a:	2002      	movs	r0, #2
   1535c:	f7ff ff56 	bl	1520c <uart_tx_isr>
}
   15360:	bd10      	pop	{r4, pc}

00015362 <uart_tx_isr1>:
{
   15362:	b510      	push	{r4, lr}
    uart_tx_isr(UART_BUS_1);
   15364:	2001      	movs	r0, #1
   15366:	f7ff ff51 	bl	1520c <uart_tx_isr>
}
   1536a:	bd10      	pop	{r4, pc}

0001536c <uart_tx_isr0>:
{
   1536c:	b510      	push	{r4, lr}
    uart_tx_isr(UART_BUS_0);
   1536e:	2000      	movs	r0, #0
   15370:	f7ff ff4c 	bl	1520c <uart_tx_isr>
}
   15374:	bd10      	pop	{r4, pc}
	...

00015378 <uart_rx_isr>:
{
   15378:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
   1537a:	0004      	movs	r4, r0
    assert( non_os_is_driver_initialised(DRIVER_INIT_UART) );
   1537c:	2008      	movs	r0, #8
   1537e:	4676      	mov	r6, lr
   15380:	f002 ff40 	bl	18204 <non_os_is_driver_initialised>
   15384:	2800      	cmp	r0, #0
   15386:	d103      	bne.n	15390 <uart_rx_isr+0x18>
   15388:	0031      	movs	r1, r6
   1538a:	3016      	adds	r0, #22
   1538c:	f7ec fbc0 	bl	1b10 <panic>
    assert( uart_rx_state[uart] != NULL );
   15390:	4f2e      	ldr	r7, [pc, #184]	; (1544c <uart_rx_isr+0xd4>)
   15392:	00a5      	lsls	r5, r4, #2
   15394:	59eb      	ldr	r3, [r5, r7]
   15396:	2b00      	cmp	r3, #0
   15398:	d103      	bne.n	153a2 <uart_rx_isr+0x2a>
   1539a:	0031      	movs	r1, r6
   1539c:	2016      	movs	r0, #22
   1539e:	f7ec fbb7 	bl	1b10 <panic>
    if( uart_flow_control_state_array[uart].enabled )
   153a2:	4b2b      	ldr	r3, [pc, #172]	; (15450 <uart_rx_isr+0xd8>)
        uint8 fifo_level = hal_uart_get_rx_fifo_level(uart);
   153a4:	0020      	movs	r0, r4
    if( uart_flow_control_state_array[uart].enabled )
   153a6:	5d5b      	ldrb	r3, [r3, r5]
   153a8:	2b00      	cmp	r3, #0
   153aa:	d02e      	beq.n	1540a <uart_rx_isr+0x92>
        uint8 fifo_level = hal_uart_get_rx_fifo_level(uart);
   153ac:	f004 fa98 	bl	198e0 <hal_uart_get_rx_fifo_level>
   153b0:	0006      	movs	r6, r0
        while( --fifo_level && !hal_uart_is_rx_fifo_empty(uart) && !uart_rx_state[uart]->rx_buffer_full )
   153b2:	3e01      	subs	r6, #1
   153b4:	b2f6      	uxtb	r6, r6
   153b6:	2e00      	cmp	r6, #0
   153b8:	d10e      	bne.n	153d8 <uart_rx_isr+0x60>
        uart_rx_isr_unsent_data = uart_rx_buffer_unsent_data(uart);
   153ba:	0020      	movs	r0, r4
   153bc:	f7ff fc2a 	bl	14c14 <uart_rx_buffer_unsent_data>
    while( uart_rx_isr_unsent_data >= uart_rx_state[uart]->rx_condition_size )   // Full or Sufficient Data rx conditions
   153c0:	597b      	ldr	r3, [r7, r5]
   153c2:	8a19      	ldrh	r1, [r3, #16]
   153c4:	4281      	cmp	r1, r0
   153c6:	d937      	bls.n	15438 <uart_rx_isr+0xc0>
    if( uart_rx_state[uart]->rx_buffer_full )
   153c8:	7e1b      	ldrb	r3, [r3, #24]
   153ca:	2b00      	cmp	r3, #0
   153cc:	d003      	beq.n	153d6 <uart_rx_isr+0x5e>
        hal_uart_disable_interrupt( uart, HAL_UART_INTERRUPT_RX );
   153ce:	2100      	movs	r1, #0
   153d0:	0020      	movs	r0, r4
   153d2:	f004 fb23 	bl	19a1c <hal_uart_disable_interrupt>
}
   153d6:	bdf7      	pop	{r0, r1, r2, r4, r5, r6, r7, pc}
        while( --fifo_level && !hal_uart_is_rx_fifo_empty(uart) && !uart_rx_state[uart]->rx_buffer_full )
   153d8:	0020      	movs	r0, r4
   153da:	f004 fbff 	bl	19bdc <hal_uart_is_rx_fifo_empty>
   153de:	2800      	cmp	r0, #0
   153e0:	d1eb      	bne.n	153ba <uart_rx_isr+0x42>
   153e2:	597b      	ldr	r3, [r7, r5]
   153e4:	7e1b      	ldrb	r3, [r3, #24]
   153e6:	2b00      	cmp	r3, #0
   153e8:	d1e7      	bne.n	153ba <uart_rx_isr+0x42>
            uart_rx_isr_data = *(uart_data_register[uart]);
   153ea:	4b1a      	ldr	r3, [pc, #104]	; (15454 <uart_rx_isr+0xdc>)
            if( !uart_helper_handle_received_control_char( uart, (uint8) uart_rx_isr_data ) )
   153ec:	0020      	movs	r0, r4
            uart_rx_isr_data = *(uart_data_register[uart]);
   153ee:	595b      	ldr	r3, [r3, r5]
   153f0:	681b      	ldr	r3, [r3, #0]
   153f2:	9301      	str	r3, [sp, #4]
            if( !uart_helper_handle_received_control_char( uart, (uint8) uart_rx_isr_data ) )
   153f4:	466b      	mov	r3, sp
   153f6:	7919      	ldrb	r1, [r3, #4]
   153f8:	f7ff fd36 	bl	14e68 <uart_helper_handle_received_control_char>
   153fc:	2800      	cmp	r0, #0
   153fe:	d1d8      	bne.n	153b2 <uart_rx_isr+0x3a>
                uart_helper_put_data_in_rx_buffer(uart, uart_rx_isr_data);
   15400:	9901      	ldr	r1, [sp, #4]
   15402:	0020      	movs	r0, r4
   15404:	f7ff fdc6 	bl	14f94 <uart_helper_put_data_in_rx_buffer>
   15408:	e7d3      	b.n	153b2 <uart_rx_isr+0x3a>
        uint8 fifo_level = hal_uart_get_rx_fifo_level(uart);
   1540a:	f004 fa69 	bl	198e0 <hal_uart_get_rx_fifo_level>
   1540e:	0006      	movs	r6, r0
        while( --fifo_level && !hal_uart_is_rx_fifo_empty(uart) && !uart_rx_state[uart]->rx_buffer_full )
   15410:	3e01      	subs	r6, #1
   15412:	b2f6      	uxtb	r6, r6
   15414:	2e00      	cmp	r6, #0
   15416:	d0d0      	beq.n	153ba <uart_rx_isr+0x42>
   15418:	0020      	movs	r0, r4
   1541a:	f004 fbdf 	bl	19bdc <hal_uart_is_rx_fifo_empty>
   1541e:	2800      	cmp	r0, #0
   15420:	d1cb      	bne.n	153ba <uart_rx_isr+0x42>
   15422:	597b      	ldr	r3, [r7, r5]
   15424:	7e1b      	ldrb	r3, [r3, #24]
   15426:	2b00      	cmp	r3, #0
   15428:	d1c7      	bne.n	153ba <uart_rx_isr+0x42>
            uart_rx_isr_data = *(uart_data_register[uart]);
   1542a:	4b0a      	ldr	r3, [pc, #40]	; (15454 <uart_rx_isr+0xdc>)
            uart_helper_put_data_in_rx_buffer(uart, uart_rx_isr_data);
   1542c:	0020      	movs	r0, r4
            uart_rx_isr_data = *(uart_data_register[uart]);
   1542e:	595b      	ldr	r3, [r3, r5]
   15430:	6819      	ldr	r1, [r3, #0]
            uart_helper_put_data_in_rx_buffer(uart, uart_rx_isr_data);
   15432:	f7ff fdaf 	bl	14f94 <uart_helper_put_data_in_rx_buffer>
   15436:	e7eb      	b.n	15410 <uart_rx_isr+0x98>
        remaining = uart_helper_invoke_rx_callback(uart, uart_rx_state[uart]->rx_condition_size);
   15438:	0020      	movs	r0, r4
   1543a:	f7ff fc03 	bl	14c44 <uart_helper_invoke_rx_callback>
   1543e:	1e01      	subs	r1, r0, #0
        if( remaining )
   15440:	d0bb      	beq.n	153ba <uart_rx_isr+0x42>
            (void)uart_helper_invoke_rx_callback(uart, remaining);
   15442:	0020      	movs	r0, r4
   15444:	f7ff fbfe 	bl	14c44 <uart_helper_invoke_rx_callback>
   15448:	e7b7      	b.n	153ba <uart_rx_isr+0x42>
   1544a:	46c0      	nop			; (mov r8, r8)
   1544c:	01002578 	.word	0x01002578
   15450:	01002554 	.word	0x01002554
   15454:	0100253c 	.word	0x0100253c

00015458 <uart_rx_isr2>:
{
   15458:	b510      	push	{r4, lr}
    uart_rx_isr(UART_BUS_2);
   1545a:	2002      	movs	r0, #2
   1545c:	f7ff ff8c 	bl	15378 <uart_rx_isr>
}
   15460:	bd10      	pop	{r4, pc}

00015462 <uart_rx_isr1>:
{
   15462:	b510      	push	{r4, lr}
    uart_rx_isr(UART_BUS_1);
   15464:	2001      	movs	r0, #1
   15466:	f7ff ff87 	bl	15378 <uart_rx_isr>
}
   1546a:	bd10      	pop	{r4, pc}

0001546c <uart_rx_isr0>:
{
   1546c:	b510      	push	{r4, lr}
    uart_rx_isr(UART_BUS_0);
   1546e:	2000      	movs	r0, #0
   15470:	f7ff ff82 	bl	15378 <uart_rx_isr>
}
   15474:	bd10      	pop	{r4, pc}
	...

00015478 <uart_is_need_awake>:
{
   15478:	b570      	push	{r4, r5, r6, lr}
   1547a:	2400      	movs	r4, #0
            remain_awake = remain_awake || ( (uart_tx_state[uart]->fragments_to_process > 0) || hal_uart_is_busy(uart) );
   1547c:	2501      	movs	r5, #1
    bool remain_awake = false;
   1547e:	0023      	movs	r3, r4
        if( uart_tx_state[uart] != NULL )
   15480:	4a0d      	ldr	r2, [pc, #52]	; (154b8 <uart_is_need_awake+0x40>)
   15482:	00a1      	lsls	r1, r4, #2
   15484:	5889      	ldr	r1, [r1, r2]
   15486:	b2e0      	uxtb	r0, r4
   15488:	2900      	cmp	r1, #0
   1548a:	d00a      	beq.n	154a2 <uart_is_need_awake+0x2a>
            remain_awake = remain_awake || ( (uart_tx_state[uart]->fragments_to_process > 0) || hal_uart_is_busy(uart) );
   1548c:	002a      	movs	r2, r5
   1548e:	2b00      	cmp	r3, #0
   15490:	d105      	bne.n	1549e <uart_is_need_awake+0x26>
   15492:	890b      	ldrh	r3, [r1, #8]
   15494:	2b00      	cmp	r3, #0
   15496:	d102      	bne.n	1549e <uart_is_need_awake+0x26>
   15498:	f004 fb99 	bl	19bce <hal_uart_is_busy>
   1549c:	0002      	movs	r2, r0
   1549e:	0013      	movs	r3, r2
   154a0:	402b      	ands	r3, r5
   154a2:	3401      	adds	r4, #1
    for( UART_BUS uart = UART_BUS_0; uart < UART_BUS_MAX_NUMBER; uart++ )
   154a4:	2c03      	cmp	r4, #3
   154a6:	d1eb      	bne.n	15480 <uart_is_need_awake+0x8>
    return false;
   154a8:	2000      	movs	r0, #0
    if (!remain_awake)
   154aa:	4283      	cmp	r3, r0
   154ac:	d102      	bne.n	154b4 <uart_is_need_awake+0x3c>
        uart_remove_any_sleep_veto();
   154ae:	f7ff fca3 	bl	14df8 <uart_remove_any_sleep_veto>
        return true;
   154b2:	2001      	movs	r0, #1
}
   154b4:	bd70      	pop	{r4, r5, r6, pc}
   154b6:	46c0      	nop			; (mov r8, r8)
   154b8:	01002594 	.word	0x01002594

000154bc <uart_rx_dma_transfer_finish.part.0>:
static void uart_rx_dma_transfer_finish(DMA_PERIPHERAL peripheral)
   154bc:	b510      	push	{r4, lr}
            assert(false);
   154be:	4671      	mov	r1, lr
   154c0:	2016      	movs	r0, #22
   154c2:	f7ec fb25 	bl	1b10 <panic>
}
   154c6:	bd10      	pop	{r4, pc}

000154c8 <uart_rx_dma_transfer_finish>:
{
   154c8:	b510      	push	{r4, lr}
    switch (peripheral)
   154ca:	2806      	cmp	r0, #6
   154cc:	d007      	beq.n	154de <uart_rx_dma_transfer_finish+0x16>
   154ce:	2808      	cmp	r0, #8
   154d0:	d007      	beq.n	154e2 <uart_rx_dma_transfer_finish+0x1a>
   154d2:	2804      	cmp	r0, #4
   154d4:	d107      	bne.n	154e6 <uart_rx_dma_transfer_finish+0x1e>
            uart_rx_dma_transfer_finish_manipulate(UART_BUS_0);
   154d6:	2000      	movs	r0, #0
            uart_rx_dma_transfer_finish_manipulate(UART_BUS_2);
   154d8:	f7ff fbe0 	bl	14c9c <uart_rx_dma_transfer_finish_manipulate>
}
   154dc:	bd10      	pop	{r4, pc}
            uart_rx_dma_transfer_finish_manipulate(UART_BUS_1);
   154de:	2001      	movs	r0, #1
   154e0:	e7fa      	b.n	154d8 <uart_rx_dma_transfer_finish+0x10>
            uart_rx_dma_transfer_finish_manipulate(UART_BUS_2);
   154e2:	2002      	movs	r0, #2
   154e4:	e7f8      	b.n	154d8 <uart_rx_dma_transfer_finish+0x10>
   154e6:	f7ff ffe9 	bl	154bc <uart_rx_dma_transfer_finish.part.0>
   154ea:	e7f7      	b.n	154dc <uart_rx_dma_transfer_finish+0x14>

000154ec <uart_rx_dma_transfer_prepare>:
{
   154ec:	b510      	push	{r4, lr}
    switch (peripheral)
   154ee:	2806      	cmp	r0, #6
   154f0:	d007      	beq.n	15502 <uart_rx_dma_transfer_prepare+0x16>
   154f2:	2808      	cmp	r0, #8
   154f4:	d007      	beq.n	15506 <uart_rx_dma_transfer_prepare+0x1a>
   154f6:	2804      	cmp	r0, #4
   154f8:	d107      	bne.n	1550a <uart_rx_dma_transfer_prepare+0x1e>
            uart_rx_dma_transfer_prepare_manipulate(UART_BUS_0);
   154fa:	2000      	movs	r0, #0
            uart_rx_dma_transfer_prepare_manipulate(UART_BUS_2);
   154fc:	f7ff fbe2 	bl	14cc4 <uart_rx_dma_transfer_prepare_manipulate>
}
   15500:	bd10      	pop	{r4, pc}
            uart_rx_dma_transfer_prepare_manipulate(UART_BUS_1);
   15502:	2001      	movs	r0, #1
   15504:	e7fa      	b.n	154fc <uart_rx_dma_transfer_prepare+0x10>
            uart_rx_dma_transfer_prepare_manipulate(UART_BUS_2);
   15506:	2002      	movs	r0, #2
   15508:	e7f8      	b.n	154fc <uart_rx_dma_transfer_prepare+0x10>
   1550a:	f7ff ffd7 	bl	154bc <uart_rx_dma_transfer_finish.part.0>
   1550e:	e7f7      	b.n	15500 <uart_rx_dma_transfer_prepare+0x14>

00015510 <uart_tx_dma_transfer_finish>:
{
   15510:	b510      	push	{r4, lr}
    switch (peripheral)
   15512:	2805      	cmp	r0, #5
   15514:	d007      	beq.n	15526 <uart_tx_dma_transfer_finish+0x16>
   15516:	2807      	cmp	r0, #7
   15518:	d007      	beq.n	1552a <uart_tx_dma_transfer_finish+0x1a>
   1551a:	2803      	cmp	r0, #3
   1551c:	d107      	bne.n	1552e <uart_tx_dma_transfer_finish+0x1e>
            uart_tx_dma_transfer_finish_manipulate(UART_BUS_0);
   1551e:	2000      	movs	r0, #0
            uart_tx_dma_transfer_finish_manipulate(UART_BUS_2);
   15520:	f7ff fbe4 	bl	14cec <uart_tx_dma_transfer_finish_manipulate>
}
   15524:	bd10      	pop	{r4, pc}
            uart_tx_dma_transfer_finish_manipulate(UART_BUS_1);
   15526:	2001      	movs	r0, #1
   15528:	e7fa      	b.n	15520 <uart_tx_dma_transfer_finish+0x10>
            uart_tx_dma_transfer_finish_manipulate(UART_BUS_2);
   1552a:	2002      	movs	r0, #2
   1552c:	e7f8      	b.n	15520 <uart_tx_dma_transfer_finish+0x10>
   1552e:	f7ff ffc5 	bl	154bc <uart_rx_dma_transfer_finish.part.0>
   15532:	e7f7      	b.n	15524 <uart_tx_dma_transfer_finish+0x14>

00015534 <uart_tx_dma_transfer_prepare>:
{
   15534:	b510      	push	{r4, lr}
    switch (peripheral)
   15536:	2805      	cmp	r0, #5
   15538:	d007      	beq.n	1554a <uart_tx_dma_transfer_prepare+0x16>
   1553a:	2807      	cmp	r0, #7
   1553c:	d007      	beq.n	1554e <uart_tx_dma_transfer_prepare+0x1a>
   1553e:	2803      	cmp	r0, #3
   15540:	d107      	bne.n	15552 <uart_tx_dma_transfer_prepare+0x1e>
            uart_tx_dma_transfer_prepare_manipulate(UART_BUS_0);
   15542:	2000      	movs	r0, #0
            uart_tx_dma_transfer_prepare_manipulate(UART_BUS_2);
   15544:	f7ff fbe6 	bl	14d14 <uart_tx_dma_transfer_prepare_manipulate>
}
   15548:	bd10      	pop	{r4, pc}
            uart_tx_dma_transfer_prepare_manipulate(UART_BUS_1);
   1554a:	2001      	movs	r0, #1
   1554c:	e7fa      	b.n	15544 <uart_tx_dma_transfer_prepare+0x10>
            uart_tx_dma_transfer_prepare_manipulate(UART_BUS_2);
   1554e:	2002      	movs	r0, #2
   15550:	e7f8      	b.n	15544 <uart_tx_dma_transfer_prepare+0x10>
   15552:	f7ff ffb3 	bl	154bc <uart_rx_dma_transfer_finish.part.0>
   15556:	e7f7      	b.n	15548 <uart_tx_dma_transfer_prepare+0x14>

00015558 <uart_helper_take_semaphore_or_panic>:
{
   15558:	b510      	push	{r4, lr}
    if (osMutexAcquire(semaphore, blockTime) != osOK)
   1555a:	f7ff fa23 	bl	149a4 <osMutexAcquire>
   1555e:	2800      	cmp	r0, #0
   15560:	d003      	beq.n	1556a <uart_helper_take_semaphore_or_panic+0x12>
        panic(PANIC_UART, PANIC_UART_UNABLE_TO_TAKE_SEMAPHORE);
   15562:	210c      	movs	r1, #12
   15564:	2007      	movs	r0, #7
   15566:	f7ec fad3 	bl	1b10 <panic>
}//lint !e454 semaphore is gived in uart_helper_give_semaphore_or_panic
   1556a:	bd10      	pop	{r4, pc}

0001556c <uart_claim_mutexes>:
{
   1556c:	b510      	push	{r4, lr}
    assert( uart < UART_BUS_MAX_NUMBER );
   1556e:	2802      	cmp	r0, #2
   15570:	d904      	bls.n	1557c <uart_claim_mutexes+0x10>
   15572:	4671      	mov	r1, lr
   15574:	2016      	movs	r0, #22
   15576:	f7ec facb 	bl	1b10 <panic>
}
   1557a:	bd10      	pop	{r4, pc}
        if( uart_rx_mutex[uart] != NULL )
   1557c:	4b07      	ldr	r3, [pc, #28]	; (1559c <uart_claim_mutexes+0x30>)
   1557e:	0084      	lsls	r4, r0, #2
   15580:	58e0      	ldr	r0, [r4, r3]
   15582:	2800      	cmp	r0, #0
   15584:	d002      	beq.n	1558c <uart_claim_mutexes+0x20>
            uart_helper_take_semaphore_or_panic( uart_rx_mutex[uart], 0 );
   15586:	2100      	movs	r1, #0
   15588:	f7ff ffe6 	bl	15558 <uart_helper_take_semaphore_or_panic>
        if( uart_tx_mutex[uart] != NULL )
   1558c:	4b04      	ldr	r3, [pc, #16]	; (155a0 <uart_claim_mutexes+0x34>)
   1558e:	5918      	ldr	r0, [r3, r4]
   15590:	2800      	cmp	r0, #0
   15592:	d0f2      	beq.n	1557a <uart_claim_mutexes+0xe>
            uart_helper_take_semaphore_or_panic( uart_tx_mutex[uart], 0 );
   15594:	2100      	movs	r1, #0
   15596:	f7ff ffdf 	bl	15558 <uart_helper_take_semaphore_or_panic>
}
   1559a:	e7ee      	b.n	1557a <uart_claim_mutexes+0xe>
   1559c:	0100256c 	.word	0x0100256c
   155a0:	01002588 	.word	0x01002588

000155a4 <uart_helper_give_semaphore_or_panic>:
{
   155a4:	b510      	push	{r4, lr}
    if (osMutexRelease(semaphore) != osOK) //lint !e455 semaphore is taked in uart_helper_take_semaphore_or_panic
   155a6:	f7ff fa21 	bl	149ec <osMutexRelease>
   155aa:	2800      	cmp	r0, #0
   155ac:	d003      	beq.n	155b6 <uart_helper_give_semaphore_or_panic+0x12>
        panic(PANIC_UART, PANIC_UART_UNABLE_TO_GIVE_SEMAPHORE);
   155ae:	210d      	movs	r1, #13
   155b0:	2007      	movs	r0, #7
   155b2:	f7ec faad 	bl	1b10 <panic>
}
   155b6:	bd10      	pop	{r4, pc}

000155b8 <uart_release_mutexes>:
{
   155b8:	b510      	push	{r4, lr}
    assert( uart < UART_BUS_MAX_NUMBER );
   155ba:	2802      	cmp	r0, #2
   155bc:	d904      	bls.n	155c8 <uart_release_mutexes+0x10>
   155be:	4671      	mov	r1, lr
   155c0:	2016      	movs	r0, #22
   155c2:	f7ec faa5 	bl	1b10 <panic>
}
   155c6:	bd10      	pop	{r4, pc}
        if( uart_rx_mutex[uart] != NULL )
   155c8:	4b06      	ldr	r3, [pc, #24]	; (155e4 <uart_release_mutexes+0x2c>)
   155ca:	0084      	lsls	r4, r0, #2
   155cc:	58e0      	ldr	r0, [r4, r3]
   155ce:	2800      	cmp	r0, #0
   155d0:	d001      	beq.n	155d6 <uart_release_mutexes+0x1e>
            uart_helper_give_semaphore_or_panic( uart_rx_mutex[uart] );
   155d2:	f7ff ffe7 	bl	155a4 <uart_helper_give_semaphore_or_panic>
        if( uart_tx_mutex[uart] != NULL )
   155d6:	4b04      	ldr	r3, [pc, #16]	; (155e8 <uart_release_mutexes+0x30>)
   155d8:	5918      	ldr	r0, [r3, r4]
   155da:	2800      	cmp	r0, #0
   155dc:	d0f3      	beq.n	155c6 <uart_release_mutexes+0xe>
            uart_helper_give_semaphore_or_panic( uart_tx_mutex[uart] );
   155de:	f7ff ffe1 	bl	155a4 <uart_helper_give_semaphore_or_panic>
}
   155e2:	e7f0      	b.n	155c6 <uart_release_mutexes+0xe>
   155e4:	0100256c 	.word	0x0100256c
   155e8:	01002588 	.word	0x01002588

000155ec <uart_rx_buffer_release.isra.9>:
inline static void uart_rx_buffer_release( UART_BUS uart, const void *buffer, uint16 length )
   155ec:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
   155ee:	0004      	movs	r4, r0
    assert( non_os_is_driver_initialised(DRIVER_INIT_UART) );
   155f0:	2008      	movs	r0, #8
   155f2:	4675      	mov	r5, lr
inline static void uart_rx_buffer_release( UART_BUS uart, const void *buffer, uint16 length )
   155f4:	9101      	str	r1, [sp, #4]
    assert( non_os_is_driver_initialised(DRIVER_INIT_UART) );
   155f6:	f002 fe05 	bl	18204 <non_os_is_driver_initialised>
   155fa:	2800      	cmp	r0, #0
   155fc:	d103      	bne.n	15606 <uart_rx_buffer_release.isra.9+0x1a>
   155fe:	0029      	movs	r1, r5
   15600:	3016      	adds	r0, #22
   15602:	f7ec fa85 	bl	1b10 <panic>
    assert( uart < UART_BUS_MAX_NUMBER );
   15606:	2c02      	cmp	r4, #2
   15608:	d903      	bls.n	15612 <uart_rx_buffer_release.isra.9+0x26>
   1560a:	0029      	movs	r1, r5
   1560c:	2016      	movs	r0, #22
   1560e:	f7ec fa7f 	bl	1b10 <panic>
    assert( uart_rx_state[uart] != NULL );
   15612:	4f12      	ldr	r7, [pc, #72]	; (1565c <uart_rx_buffer_release.isra.9+0x70>)
   15614:	00a6      	lsls	r6, r4, #2
   15616:	59f3      	ldr	r3, [r6, r7]
   15618:	2b00      	cmp	r3, #0
   1561a:	d103      	bne.n	15624 <uart_rx_buffer_release.isra.9+0x38>
   1561c:	0029      	movs	r1, r5
   1561e:	2016      	movs	r0, #22
   15620:	f7ec fa76 	bl	1b10 <panic>
    non_os_enter_critical();
   15624:	f002 fdc6 	bl	181b4 <non_os_enter_critical>
    uart_rx_state[uart]->first_reserved_pos += length;
   15628:	59ba      	ldr	r2, [r7, r6]
   1562a:	9901      	ldr	r1, [sp, #4]
   1562c:	8ad3      	ldrh	r3, [r2, #22]
    if (uart_rx_state[uart]->first_reserved_pos >= uart_rx_state[uart]->rx_buffer_size)
   1562e:	8810      	ldrh	r0, [r2, #0]
    uart_rx_state[uart]->first_reserved_pos += length;
   15630:	18cb      	adds	r3, r1, r3
    uart_rx_state[uart]->rx_buffer_full = false;
   15632:	2100      	movs	r1, #0
    uart_rx_state[uart]->first_reserved_pos += length;
   15634:	b29b      	uxth	r3, r3
   15636:	82d3      	strh	r3, [r2, #22]
    uart_rx_state[uart]->rx_buffer_full = false;
   15638:	7611      	strb	r1, [r2, #24]
    if (uart_rx_state[uart]->first_reserved_pos >= uart_rx_state[uart]->rx_buffer_size)
   1563a:	4298      	cmp	r0, r3
   1563c:	d800      	bhi.n	15640 <uart_rx_buffer_release.isra.9+0x54>
        uart_rx_state[uart]->first_reserved_pos = 0;
   1563e:	82d1      	strh	r1, [r2, #22]
    non_os_exit_critical();
   15640:	f002 fdcc 	bl	181dc <non_os_exit_critical>
    uart_helper_determine_rx_flow_control( uart );
   15644:	0020      	movs	r0, r4
   15646:	f7ff fc89 	bl	14f5c <uart_helper_determine_rx_flow_control>
    hal_uart_enable_interrupt( uart, HAL_UART_INTERRUPT_IDLE );
   1564a:	0020      	movs	r0, r4
   1564c:	2102      	movs	r1, #2
   1564e:	f004 f9c2 	bl	199d6 <hal_uart_enable_interrupt>
    hal_uart_enable_interrupt( uart, HAL_UART_INTERRUPT_RX );
   15652:	2100      	movs	r1, #0
   15654:	0020      	movs	r0, r4
   15656:	f004 f9be 	bl	199d6 <hal_uart_enable_interrupt>
}
   1565a:	bdf7      	pop	{r0, r1, r2, r4, r5, r6, r7, pc}
   1565c:	01002578 	.word	0x01002578

00015660 <uart_rx_buffer_release2>:
{
   15660:	b510      	push	{r4, lr}
    uart_rx_buffer_release(UART_BUS_2, buffer, length);
   15662:	2002      	movs	r0, #2
   15664:	f7ff ffc2 	bl	155ec <uart_rx_buffer_release.isra.9>
}
   15668:	bd10      	pop	{r4, pc}

0001566a <uart_rx_buffer_release1>:
{
   1566a:	b510      	push	{r4, lr}
    uart_rx_buffer_release(UART_BUS_1, buffer, length);
   1566c:	2001      	movs	r0, #1
   1566e:	f7ff ffbd 	bl	155ec <uart_rx_buffer_release.isra.9>
}
   15672:	bd10      	pop	{r4, pc}

00015674 <uart_rx_buffer_release0>:
{
   15674:	b510      	push	{r4, lr}
    uart_rx_buffer_release(UART_BUS_0, buffer, length);
   15676:	2000      	movs	r0, #0
   15678:	f7ff ffb8 	bl	155ec <uart_rx_buffer_release.isra.9>
}
   1567c:	bd10      	pop	{r4, pc}
	...

00015680 <uart_deconfigure_state>:
{
   15680:	b570      	push	{r4, r5, r6, lr}
    assert( uart < UART_BUS_MAX_NUMBER );
   15682:	2802      	cmp	r0, #2
   15684:	d90a      	bls.n	1569c <uart_deconfigure_state+0x1c>
   15686:	4671      	mov	r1, lr
   15688:	2016      	movs	r0, #22
   1568a:	f7ec fa41 	bl	1b10 <panic>
}
   1568e:	bd70      	pop	{r4, r5, r6, pc}
            irfree( uart_tx_state[uart] );
   15690:	5928      	ldr	r0, [r5, r4]
   15692:	f7fd f9d1 	bl	12a38 <irfree>
            uart_tx_state[uart] = NULL;
   15696:	2300      	movs	r3, #0
   15698:	512b      	str	r3, [r5, r4]
}
   1569a:	e7f8      	b.n	1568e <uart_deconfigure_state+0xe>
        if( uart_rx_state[uart] != NULL )
   1569c:	4d0a      	ldr	r5, [pc, #40]	; (156c8 <uart_deconfigure_state+0x48>)
   1569e:	0084      	lsls	r4, r0, #2
   156a0:	5960      	ldr	r0, [r4, r5]
   156a2:	2800      	cmp	r0, #0
   156a4:	d003      	beq.n	156ae <uart_deconfigure_state+0x2e>
            irfree( uart_rx_state[uart] );
   156a6:	f7fd f9c7 	bl	12a38 <irfree>
            uart_rx_state[uart] = NULL;
   156aa:	2300      	movs	r3, #0
   156ac:	5163      	str	r3, [r4, r5]
        if( uart_tx_state[uart] != NULL )
   156ae:	4d07      	ldr	r5, [pc, #28]	; (156cc <uart_deconfigure_state+0x4c>)
   156b0:	592b      	ldr	r3, [r5, r4]
   156b2:	2b00      	cmp	r3, #0
   156b4:	d0eb      	beq.n	1568e <uart_deconfigure_state+0xe>
            if( uart_tx_state[uart]->blocks_head != NULL )
   156b6:	68d8      	ldr	r0, [r3, #12]
   156b8:	2800      	cmp	r0, #0
   156ba:	d0e9      	beq.n	15690 <uart_deconfigure_state+0x10>
        blocks_to_remove_head = blocks_to_remove_head->next;
   156bc:	4b04      	ldr	r3, [pc, #16]	; (156d0 <uart_deconfigure_state+0x50>)
   156be:	58c6      	ldr	r6, [r0, r3]
        irfree( block_to_remove );
   156c0:	f7fd f9ba 	bl	12a38 <irfree>
   156c4:	0030      	movs	r0, r6
   156c6:	e7f7      	b.n	156b8 <uart_deconfigure_state+0x38>
   156c8:	01002578 	.word	0x01002578
   156cc:	01002594 	.word	0x01002594
   156d0:	00000504 	.word	0x00000504

000156d4 <uart_init>:
{
   156d4:	b570      	push	{r4, r5, r6, lr}
    assert(non_os_is_driver_initialised(DRIVER_INIT_UART) != true);
   156d6:	2008      	movs	r0, #8
   156d8:	4674      	mov	r4, lr
   156da:	f002 fd93 	bl	18204 <non_os_is_driver_initialised>
   156de:	2800      	cmp	r0, #0
   156e0:	d003      	beq.n	156ea <uart_init+0x16>
   156e2:	0021      	movs	r1, r4
   156e4:	2016      	movs	r0, #22
   156e6:	f7ec fa13 	bl	1b10 <panic>
    hal_uart_init();
   156ea:	f004 f86b 	bl	197c4 <hal_uart_init>
   156ee:	2400      	movs	r4, #0
   156f0:	b2e6      	uxtb	r6, r4
        uart_data_register[uart_i] = hal_uart_get_data_register((UART_BUS) uart_i);
   156f2:	0030      	movs	r0, r6
   156f4:	f004 f902 	bl	198fc <hal_uart_get_data_register>
   156f8:	4b0a      	ldr	r3, [pc, #40]	; (15724 <uart_init+0x50>)
   156fa:	00a5      	lsls	r5, r4, #2
   156fc:	50e8      	str	r0, [r5, r3]
        uart_dmac_register[uart_i] = hal_uart_get_dmac_register((UART_BUS) uart_i);
   156fe:	0030      	movs	r0, r6
   15700:	f004 fa90 	bl	19c24 <hal_uart_get_dmac_register>
   15704:	4b08      	ldr	r3, [pc, #32]	; (15728 <uart_init+0x54>)
   15706:	3401      	adds	r4, #1
   15708:	50e8      	str	r0, [r5, r3]
    for (uart_i = 0; uart_i < UART_BUS_MAX_NUMBER; uart_i++)
   1570a:	2c03      	cmp	r4, #3
   1570c:	d1f0      	bne.n	156f0 <uart_init+0x1c>
    osUartVetoCallbackRegister(uart_is_need_awake);
   1570e:	4807      	ldr	r0, [pc, #28]	; (1572c <uart_init+0x58>)
   15710:	f7ff fa70 	bl	14bf4 <osUartVetoCallbackRegister>
    uart_sleep_vetoed = false;
   15714:	2200      	movs	r2, #0
   15716:	4b06      	ldr	r3, [pc, #24]	; (15730 <uart_init+0x5c>)
    non_os_set_driver_initalised(DRIVER_INIT_UART, true);
   15718:	2101      	movs	r1, #1
   1571a:	2008      	movs	r0, #8
    uart_sleep_vetoed = false;
   1571c:	701a      	strb	r2, [r3, #0]
    non_os_set_driver_initalised(DRIVER_INIT_UART, true);
   1571e:	f002 fd7b 	bl	18218 <non_os_set_driver_initalised>
}
   15722:	bd70      	pop	{r4, r5, r6, pc}
   15724:	0100253c 	.word	0x0100253c
   15728:	01002548 	.word	0x01002548
   1572c:	00015479 	.word	0x00015479
   15730:	01002584 	.word	0x01002584

00015734 <uart_claim>:
{
   15734:	b5f0      	push	{r4, r5, r6, r7, lr}
   15736:	b085      	sub	sp, #20
   15738:	4676      	mov	r6, lr
   1573a:	0005      	movs	r5, r0
    UART_COMMON_VALIDATE_PINS validate_pins = uart_common_validate_pin_config( claim_pins );
   1573c:	f001 fb0e 	bl	16d5c <uart_common_validate_pin_config>
   15740:	0003      	movs	r3, r0
    switch( validate_pins )
   15742:	3801      	subs	r0, #1
   15744:	2804      	cmp	r0, #4
   15746:	d815      	bhi.n	15774 <uart_claim+0x40>
   15748:	f7ea fe2c 	bl	3a4 <__gnu_thumb1_case_uqi>
   1574c:	0e100c03 	.word	0x0e100c03
   15750:	12          	.byte	0x12
   15751:	00          	.byte	0x00
        panic( PANIC_UART, PANIC_UART_ERROR_IN_THE_PARAMETERS_SENT_TO_OPEN_UART);
   15752:	2100      	movs	r1, #0
        panic( PANIC_UART, PANIC_UART_INVALID_CLEAR_TO_SEND_PIN);
   15754:	2007      	movs	r0, #7
   15756:	f7ec f9db 	bl	1b10 <panic>
        return UART_BUS_NONE;
   1575a:	2303      	movs	r3, #3
   1575c:	9301      	str	r3, [sp, #4]
}
   1575e:	9801      	ldr	r0, [sp, #4]
   15760:	b005      	add	sp, #20
   15762:	bdf0      	pop	{r4, r5, r6, r7, pc}
        panic( PANIC_UART, PANIC_UART_INVALID_TRANSMISSION_PIN);
   15764:	2103      	movs	r1, #3
   15766:	e7f5      	b.n	15754 <uart_claim+0x20>
        panic( PANIC_UART, PANIC_UART_INVALID_READY_TO_SEND_PIN);
   15768:	2105      	movs	r1, #5
   1576a:	e7f3      	b.n	15754 <uart_claim+0x20>
        panic( PANIC_UART, PANIC_UART_INVALID_RECEPTION_PIN);
   1576c:	2104      	movs	r1, #4
   1576e:	e7f1      	b.n	15754 <uart_claim+0x20>
        panic( PANIC_UART, PANIC_UART_INVALID_CLEAR_TO_SEND_PIN);
   15770:	2106      	movs	r1, #6
   15772:	e7ef      	b.n	15754 <uart_claim+0x20>
        return UART_BUS_NONE;
   15774:	2203      	movs	r2, #3
   15776:	9201      	str	r2, [sp, #4]
    if( uart_validate_pin_config( claim_pins ) != UART_COMMON_VALIDATE_PINS_OK )
   15778:	2b00      	cmp	r3, #0
   1577a:	d1f0      	bne.n	1575e <uart_claim+0x2a>
    bool scheduler_running = (osKernelGetState() == osKernelRunning);
   1577c:	f7fe ffaa 	bl	146d4 <osKernelGetState>
   15780:	9002      	str	r0, [sp, #8]
    if( scheduler_running )
   15782:	2802      	cmp	r0, #2
   15784:	d101      	bne.n	1578a <uart_claim+0x56>
        (void)osKernelLock();
   15786:	f7fe ffdb 	bl	14740 <osKernelLock>
    UART_BUS uart = uart_common_claim( claim_pins );
   1578a:	0028      	movs	r0, r5
   1578c:	f001 fb28 	bl	16de0 <uart_common_claim>
   15790:	0004      	movs	r4, r0
   15792:	9001      	str	r0, [sp, #4]
    if( uart == UART_BUS_NONE )
   15794:	2803      	cmp	r0, #3
   15796:	d103      	bne.n	157a0 <uart_claim+0x6c>
        panic( PANIC_UART, PANIC_UART_ILLEGAL_ATTEMPT_TO_OPEN_AN_ALREADY_OPENED_UART );
   15798:	210b      	movs	r1, #11
   1579a:	2007      	movs	r0, #7
   1579c:	f7ec f9b8 	bl	1b10 <panic>
    uart_common_disable_uart( uart );    // Ensure the UART is disabled after claiming it
   157a0:	0020      	movs	r0, r4
   157a2:	f001 fc07 	bl	16fb4 <uart_common_disable_uart>
    assert( uart < UART_BUS_MAX_NUMBER );
   157a6:	2c02      	cmp	r4, #2
   157a8:	d903      	bls.n	157b2 <uart_claim+0x7e>
   157aa:	0031      	movs	r1, r6
   157ac:	2016      	movs	r0, #22
   157ae:	f7ec f9af 	bl	1b10 <panic>
    assert( claim_pins != NULL );
   157b2:	2d00      	cmp	r5, #0
   157b4:	d103      	bne.n	157be <uart_claim+0x8a>
   157b6:	0031      	movs	r1, r6
   157b8:	2016      	movs	r0, #22
   157ba:	f7ec f9a9 	bl	1b10 <panic>
    assert( uart_pin_config[uart] == NULL );
   157be:	4f45      	ldr	r7, [pc, #276]	; (158d4 <uart_claim+0x1a0>)
   157c0:	00a3      	lsls	r3, r4, #2
   157c2:	59db      	ldr	r3, [r3, r7]
   157c4:	9303      	str	r3, [sp, #12]
   157c6:	2b00      	cmp	r3, #0
   157c8:	d003      	beq.n	157d2 <uart_claim+0x9e>
   157ca:	0031      	movs	r1, r6
   157cc:	2016      	movs	r0, #22
   157ce:	f7ec f99f 	bl	1b10 <panic>
    if( (uart < UART_BUS_MAX_NUMBER) && (claim_pins != NULL) )    //lint !e774
   157d2:	2c02      	cmp	r4, #2
   157d4:	d879      	bhi.n	158ca <uart_claim+0x196>
   157d6:	2d00      	cmp	r5, #0
   157d8:	d014      	beq.n	15804 <uart_claim+0xd0>
        uart_pin_config[uart] = irmalloc( sizeof( uart_pin_configuration ) );
   157da:	2004      	movs	r0, #4
   157dc:	f7fd f910 	bl	12a00 <irmalloc>
   157e0:	00a3      	lsls	r3, r4, #2
   157e2:	50f8      	str	r0, [r7, r3]
        if( uart_pin_config[uart] == NULL )
   157e4:	2800      	cmp	r0, #0
   157e6:	d103      	bne.n	157f0 <uart_claim+0xbc>
            panic( PANIC_UART, PANIC_UART_UNABLE_TO_ALLOCATE_MEMORY_FOR_UART );  // TODO Needs a unique panic code
   157e8:	2101      	movs	r1, #1
   157ea:	3007      	adds	r0, #7
   157ec:	f7ec f990 	bl	1b10 <panic>
        uart_pin_config[uart]->tx_pin = claim_pins->tx_pin;
   157f0:	00a3      	lsls	r3, r4, #2
   157f2:	782a      	ldrb	r2, [r5, #0]
   157f4:	58fb      	ldr	r3, [r7, r3]
   157f6:	701a      	strb	r2, [r3, #0]
        uart_pin_config[uart]->rx_pin = claim_pins->rx_pin;
   157f8:	786a      	ldrb	r2, [r5, #1]
   157fa:	705a      	strb	r2, [r3, #1]
        uart_pin_config[uart]->rts_pin = claim_pins->rts_pin;
   157fc:	78ea      	ldrb	r2, [r5, #3]
   157fe:	70da      	strb	r2, [r3, #3]
        uart_pin_config[uart]->cts_pin = claim_pins->cts_pin;
   15800:	78aa      	ldrb	r2, [r5, #2]
   15802:	709a      	strb	r2, [r3, #2]
    assert( uart_tx_mutex[uart] == NULL );
   15804:	4b34      	ldr	r3, [pc, #208]	; (158d8 <uart_claim+0x1a4>)
   15806:	00a5      	lsls	r5, r4, #2
   15808:	58eb      	ldr	r3, [r5, r3]
   1580a:	2b00      	cmp	r3, #0
   1580c:	d003      	beq.n	15816 <uart_claim+0xe2>
   1580e:	0031      	movs	r1, r6
   15810:	2016      	movs	r0, #22
   15812:	f7ec f97d 	bl	1b10 <panic>
    assert( uart_rx_mutex[uart] == NULL );
   15816:	4b31      	ldr	r3, [pc, #196]	; (158dc <uart_claim+0x1a8>)
   15818:	595b      	ldr	r3, [r3, r5]
   1581a:	2b00      	cmp	r3, #0
   1581c:	d003      	beq.n	15826 <uart_claim+0xf2>
   1581e:	0031      	movs	r1, r6
   15820:	2016      	movs	r0, #22
   15822:	f7ec f975 	bl	1b10 <panic>
    assert( uart_pin_config[uart] != NULL );
   15826:	597b      	ldr	r3, [r7, r5]
   15828:	2b00      	cmp	r3, #0
   1582a:	d103      	bne.n	15834 <uart_claim+0x100>
   1582c:	0031      	movs	r1, r6
   1582e:	2016      	movs	r0, #22
   15830:	f7ec f96e 	bl	1b10 <panic>
    assert( (uart_pin_config[uart]->tx_pin != PIN_NONE) || (uart_pin_config[uart]->rx_pin != PIN_NONE) );
   15834:	00a3      	lsls	r3, r4, #2
   15836:	58fb      	ldr	r3, [r7, r3]
   15838:	781a      	ldrb	r2, [r3, #0]
   1583a:	2a28      	cmp	r2, #40	; 0x28
   1583c:	d106      	bne.n	1584c <uart_claim+0x118>
   1583e:	785b      	ldrb	r3, [r3, #1]
   15840:	2b28      	cmp	r3, #40	; 0x28
   15842:	d103      	bne.n	1584c <uart_claim+0x118>
   15844:	0031      	movs	r1, r6
   15846:	2016      	movs	r0, #22
   15848:	f7ec f962 	bl	1b10 <panic>
    if( (uart < UART_BUS_MAX_NUMBER) && (uart_tx_mutex[uart] == NULL) && (uart_rx_mutex[uart] == NULL) )
   1584c:	2c02      	cmp	r4, #2
   1584e:	d832      	bhi.n	158b6 <uart_claim+0x182>
   15850:	4b21      	ldr	r3, [pc, #132]	; (158d8 <uart_claim+0x1a4>)
   15852:	595b      	ldr	r3, [r3, r5]
   15854:	2b00      	cmp	r3, #0
   15856:	d12e      	bne.n	158b6 <uart_claim+0x182>
   15858:	4e20      	ldr	r6, [pc, #128]	; (158dc <uart_claim+0x1a8>)
   1585a:	5970      	ldr	r0, [r6, r5]
   1585c:	2800      	cmp	r0, #0
   1585e:	d12a      	bne.n	158b6 <uart_claim+0x182>
        if( (uart_pin_config[uart] != NULL) && (uart_pin_config[uart]->rx_pin != PIN_NONE) )
   15860:	597b      	ldr	r3, [r7, r5]
   15862:	2b00      	cmp	r3, #0
   15864:	d011      	beq.n	1588a <uart_claim+0x156>
   15866:	785b      	ldrb	r3, [r3, #1]
   15868:	2b28      	cmp	r3, #40	; 0x28
   1586a:	d00e      	beq.n	1588a <uart_claim+0x156>
            uart_rx_mutex[uart] = osMutexNew(NULL);
   1586c:	f7ff f884 	bl	14978 <osMutexNew>
   15870:	5170      	str	r0, [r6, r5]
            if( uart_rx_mutex[uart] == NULL )
   15872:	2800      	cmp	r0, #0
   15874:	d103      	bne.n	1587e <uart_claim+0x14a>
                panic(PANIC_UART, PANIC_UART_UNABLE_TO_CREATE_MUTEX);
   15876:	2102      	movs	r1, #2
   15878:	3007      	adds	r0, #7
   1587a:	f7ec f949 	bl	1b10 <panic>
            uart_helper_take_semaphore_or_panic( uart_rx_mutex[uart], 0 );
   1587e:	4b17      	ldr	r3, [pc, #92]	; (158dc <uart_claim+0x1a8>)
   15880:	00a2      	lsls	r2, r4, #2
   15882:	2100      	movs	r1, #0
   15884:	5898      	ldr	r0, [r3, r2]
   15886:	f7ff fe67 	bl	15558 <uart_helper_take_semaphore_or_panic>
        if( (uart_pin_config[uart] != NULL) && (uart_pin_config[uart]->tx_pin != PIN_NONE) )
   1588a:	597b      	ldr	r3, [r7, r5]
   1588c:	2b00      	cmp	r3, #0
   1588e:	d012      	beq.n	158b6 <uart_claim+0x182>
   15890:	781b      	ldrb	r3, [r3, #0]
   15892:	2b28      	cmp	r3, #40	; 0x28
   15894:	d00f      	beq.n	158b6 <uart_claim+0x182>
            uart_tx_mutex[uart] = osMutexNew(NULL);
   15896:	2000      	movs	r0, #0
   15898:	f7ff f86e 	bl	14978 <osMutexNew>
   1589c:	4e0e      	ldr	r6, [pc, #56]	; (158d8 <uart_claim+0x1a4>)
   1589e:	5170      	str	r0, [r6, r5]
            if( uart_tx_mutex[uart] == NULL )
   158a0:	2800      	cmp	r0, #0
   158a2:	d103      	bne.n	158ac <uart_claim+0x178>
                panic(PANIC_UART, PANIC_UART_UNABLE_TO_CREATE_MUTEX);
   158a4:	2102      	movs	r1, #2
   158a6:	3007      	adds	r0, #7
   158a8:	f7ec f932 	bl	1b10 <panic>
            uart_helper_take_semaphore_or_panic( uart_tx_mutex[uart], 0 );
   158ac:	00a3      	lsls	r3, r4, #2
   158ae:	2100      	movs	r1, #0
   158b0:	58f0      	ldr	r0, [r6, r3]
   158b2:	f7ff fe51 	bl	15558 <uart_helper_take_semaphore_or_panic>
    uart_release_mutexes( uart );
   158b6:	0020      	movs	r0, r4
   158b8:	f7ff fe7e 	bl	155b8 <uart_release_mutexes>
    if( scheduler_running )
   158bc:	9b02      	ldr	r3, [sp, #8]
   158be:	2b02      	cmp	r3, #2
   158c0:	d000      	beq.n	158c4 <uart_claim+0x190>
   158c2:	e74c      	b.n	1575e <uart_claim+0x2a>
        (void)osKernelUnlock();
   158c4:	f7fe ff58 	bl	14778 <osKernelUnlock>
   158c8:	e749      	b.n	1575e <uart_claim+0x2a>
    assert( uart < UART_BUS_MAX_NUMBER );
   158ca:	0031      	movs	r1, r6
   158cc:	2016      	movs	r0, #22
   158ce:	f7ec f91f 	bl	1b10 <panic>
   158d2:	e797      	b.n	15804 <uart_claim+0xd0>
   158d4:	01002560 	.word	0x01002560
   158d8:	01002588 	.word	0x01002588
   158dc:	0100256c 	.word	0x0100256c

000158e0 <uart_release>:
{
   158e0:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
   158e2:	0004      	movs	r4, r0
    assert( non_os_is_driver_initialised(DRIVER_INIT_UART) );
   158e4:	2008      	movs	r0, #8
   158e6:	4676      	mov	r6, lr
   158e8:	f002 fc8c 	bl	18204 <non_os_is_driver_initialised>
   158ec:	2800      	cmp	r0, #0
   158ee:	d103      	bne.n	158f8 <uart_release+0x18>
   158f0:	0031      	movs	r1, r6
   158f2:	3016      	adds	r0, #22
   158f4:	f7ec f90c 	bl	1b10 <panic>
    assert( uart < UART_BUS_MAX_NUMBER );
   158f8:	2c02      	cmp	r4, #2
   158fa:	d903      	bls.n	15904 <uart_release+0x24>
   158fc:	0031      	movs	r1, r6
   158fe:	2016      	movs	r0, #22
   15900:	f7ec f906 	bl	1b10 <panic>
    if( uart_common_is_claimed( uart ) )
   15904:	0020      	movs	r0, r4
   15906:	f001 facd 	bl	16ea4 <uart_common_is_claimed>
   1590a:	2800      	cmp	r0, #0
   1590c:	d028      	beq.n	15960 <uart_release+0x80>
        bool scheduler_running = (osKernelGetState() == osKernelRunning);
   1590e:	f7fe fee1 	bl	146d4 <osKernelGetState>
   15912:	9001      	str	r0, [sp, #4]
        if( scheduler_running )
   15914:	2802      	cmp	r0, #2
   15916:	d101      	bne.n	1591c <uart_release+0x3c>
            (void)osKernelLock();
   15918:	f7fe ff12 	bl	14740 <osKernelLock>
        uart_claim_mutexes( uart );
   1591c:	0020      	movs	r0, r4
   1591e:	f7ff fe25 	bl	1556c <uart_claim_mutexes>
        hal_uart_disable_uart(uart);
   15922:	0020      	movs	r0, r4
   15924:	f004 f8f7 	bl	19b16 <hal_uart_disable_uart>
        uart_deconfigure_state( uart );
   15928:	0020      	movs	r0, r4
   1592a:	f7ff fea9 	bl	15680 <uart_deconfigure_state>
        uart_common_release( uart, uart_pin_config[uart] );
   1592e:	4f15      	ldr	r7, [pc, #84]	; (15984 <uart_release+0xa4>)
   15930:	00a5      	lsls	r5, r4, #2
   15932:	59e9      	ldr	r1, [r5, r7]
   15934:	0020      	movs	r0, r4
   15936:	f001 fac1 	bl	16ebc <uart_common_release>
        irfree( uart_pin_config[uart] );
   1593a:	59e8      	ldr	r0, [r5, r7]
   1593c:	f7fd f87c 	bl	12a38 <irfree>
        uart_pin_config[uart] = NULL;
   15940:	2300      	movs	r3, #0
        uart_release_mutexes( uart );    // Mutexes need releasing before being deleted
   15942:	0020      	movs	r0, r4
        uart_pin_config[uart] = NULL;
   15944:	51eb      	str	r3, [r5, r7]
        uart_release_mutexes( uart );    // Mutexes need releasing before being deleted
   15946:	f7ff fe37 	bl	155b8 <uart_release_mutexes>
    assert( uart < UART_BUS_MAX_NUMBER );
   1594a:	2c02      	cmp	r4, #2
   1594c:	d909      	bls.n	15962 <uart_release+0x82>
   1594e:	0031      	movs	r1, r6
   15950:	2016      	movs	r0, #22
   15952:	f7ec f8dd 	bl	1b10 <panic>
        if( scheduler_running )
   15956:	9b01      	ldr	r3, [sp, #4]
   15958:	2b02      	cmp	r3, #2
   1595a:	d101      	bne.n	15960 <uart_release+0x80>
            (void)osKernelUnlock();
   1595c:	f7fe ff0c 	bl	14778 <osKernelUnlock>
}
   15960:	bdf7      	pop	{r0, r1, r2, r4, r5, r6, r7, pc}
        if( uart_rx_mutex[uart] != NULL )
   15962:	4c09      	ldr	r4, [pc, #36]	; (15988 <uart_release+0xa8>)
   15964:	5928      	ldr	r0, [r5, r4]
   15966:	2800      	cmp	r0, #0
   15968:	d003      	beq.n	15972 <uart_release+0x92>
            (void)osMutexDelete( uart_rx_mutex[uart] );
   1596a:	f7ff f84f 	bl	14a0c <osMutexDelete>
            uart_rx_mutex[uart] = NULL;
   1596e:	2300      	movs	r3, #0
   15970:	512b      	str	r3, [r5, r4]
        if( uart_tx_mutex[uart] != NULL )
   15972:	4c06      	ldr	r4, [pc, #24]	; (1598c <uart_release+0xac>)
   15974:	5960      	ldr	r0, [r4, r5]
   15976:	2800      	cmp	r0, #0
   15978:	d0ed      	beq.n	15956 <uart_release+0x76>
            (void)osMutexDelete( uart_tx_mutex[uart] );
   1597a:	f7ff f847 	bl	14a0c <osMutexDelete>
            uart_tx_mutex[uart] = NULL;
   1597e:	2300      	movs	r3, #0
   15980:	5163      	str	r3, [r4, r5]
   15982:	e7e8      	b.n	15956 <uart_release+0x76>
   15984:	01002560 	.word	0x01002560
   15988:	0100256c 	.word	0x0100256c
   1598c:	01002588 	.word	0x01002588

00015990 <uart_open>:
{
   15990:	b5f0      	push	{r4, r5, r6, r7, lr}
   15992:	4674      	mov	r4, lr
   15994:	b08b      	sub	sp, #44	; 0x2c
   15996:	9400      	str	r4, [sp, #0]
   15998:	0004      	movs	r4, r0
    assert(non_os_is_driver_initialised(DRIVER_INIT_UART) == true);
   1599a:	2008      	movs	r0, #8
{
   1599c:	000d      	movs	r5, r1
   1599e:	0017      	movs	r7, r2
   159a0:	9301      	str	r3, [sp, #4]
    assert(non_os_is_driver_initialised(DRIVER_INIT_UART) == true);
   159a2:	f002 fc2f 	bl	18204 <non_os_is_driver_initialised>
   159a6:	2800      	cmp	r0, #0
   159a8:	d103      	bne.n	159b2 <uart_open+0x22>
   159aa:	9900      	ldr	r1, [sp, #0]
   159ac:	3016      	adds	r0, #22
   159ae:	f7ec f8af 	bl	1b10 <panic>
    if( (uart >= UART_BUS_MAX_NUMBER) || (uart_line_config == NULL) )
   159b2:	2c02      	cmp	r4, #2
   159b4:	d801      	bhi.n	159ba <uart_open+0x2a>
   159b6:	2d00      	cmp	r5, #0
   159b8:	d106      	bne.n	159c8 <uart_open+0x38>
        panic( PANIC_UART, PANIC_UART_ERROR_IN_THE_PARAMETERS_SENT_TO_OPEN_UART);
   159ba:	2100      	movs	r1, #0
   159bc:	2007      	movs	r0, #7
   159be:	f7ec f8a7 	bl	1b10 <panic>
                return false;
   159c2:	2300      	movs	r3, #0
   159c4:	9302      	str	r3, [sp, #8]
   159c6:	e009      	b.n	159dc <uart_open+0x4c>
    if( !uart_common_is_claimed( uart ) )
   159c8:	0020      	movs	r0, r4
   159ca:	f001 fa6b 	bl	16ea4 <uart_common_is_claimed>
   159ce:	9002      	str	r0, [sp, #8]
   159d0:	2800      	cmp	r0, #0
   159d2:	d106      	bne.n	159e2 <uart_open+0x52>
        assert( false );
   159d4:	9900      	ldr	r1, [sp, #0]
   159d6:	2016      	movs	r0, #22
   159d8:	f7ec f89a 	bl	1b10 <panic>
}
   159dc:	9802      	ldr	r0, [sp, #8]
   159de:	b00b      	add	sp, #44	; 0x2c
   159e0:	bdf0      	pop	{r4, r5, r6, r7, pc}
    uart_claim_mutexes( uart );
   159e2:	0020      	movs	r0, r4
   159e4:	f7ff fdc2 	bl	1556c <uart_claim_mutexes>
    uart_common_disable_uart( uart );
   159e8:	0020      	movs	r0, r4
   159ea:	f001 fae3 	bl	16fb4 <uart_common_disable_uart>
    uart_release_mutexes( uart );
   159ee:	0020      	movs	r0, r4
   159f0:	f7ff fde2 	bl	155b8 <uart_release_mutexes>
    uart_common_configure_line_settings( uart, uart_line_config );
   159f4:	0029      	movs	r1, r5
   159f6:	0020      	movs	r0, r4
   159f8:	f001 fab8 	bl	16f6c <uart_common_configure_line_settings>
    assert( uart_rx_state[uart] == NULL );
   159fc:	4e85      	ldr	r6, [pc, #532]	; (15c14 <uart_open+0x284>)
   159fe:	00a5      	lsls	r5, r4, #2
   15a00:	59ab      	ldr	r3, [r5, r6]
   15a02:	2b00      	cmp	r3, #0
   15a04:	d003      	beq.n	15a0e <uart_open+0x7e>
   15a06:	9900      	ldr	r1, [sp, #0]
   15a08:	2016      	movs	r0, #22
   15a0a:	f7ec f881 	bl	1b10 <panic>
    assert( uart_pin_config[uart] != NULL );
   15a0e:	4b82      	ldr	r3, [pc, #520]	; (15c18 <uart_open+0x288>)
   15a10:	595b      	ldr	r3, [r3, r5]
   15a12:	9303      	str	r3, [sp, #12]
   15a14:	2b00      	cmp	r3, #0
   15a16:	d103      	bne.n	15a20 <uart_open+0x90>
   15a18:	9900      	ldr	r1, [sp, #0]
   15a1a:	2016      	movs	r0, #22
   15a1c:	f7ec f878 	bl	1b10 <panic>
    assert( (uart_pin_config[uart]->rx_pin == PIN_NONE) || (uart_buffer_config != NULL) );
   15a20:	4b7d      	ldr	r3, [pc, #500]	; (15c18 <uart_open+0x288>)
   15a22:	595b      	ldr	r3, [r3, r5]
   15a24:	785b      	ldrb	r3, [r3, #1]
   15a26:	2b28      	cmp	r3, #40	; 0x28
   15a28:	d005      	beq.n	15a36 <uart_open+0xa6>
   15a2a:	2f00      	cmp	r7, #0
   15a2c:	d103      	bne.n	15a36 <uart_open+0xa6>
   15a2e:	9900      	ldr	r1, [sp, #0]
   15a30:	2016      	movs	r0, #22
   15a32:	f7ec f86d 	bl	1b10 <panic>
    if( uart_rx_state[uart] != NULL )
   15a36:	5973      	ldr	r3, [r6, r5]
   15a38:	2b00      	cmp	r3, #0
   15a3a:	d139      	bne.n	15ab0 <uart_open+0x120>
    if( (uart_pin_config[uart] == NULL) || (uart_pin_config[uart]->rx_pin == PIN_NONE) )
   15a3c:	4b76      	ldr	r3, [pc, #472]	; (15c18 <uart_open+0x288>)
   15a3e:	595b      	ldr	r3, [r3, r5]
   15a40:	2b00      	cmp	r3, #0
   15a42:	d035      	beq.n	15ab0 <uart_open+0x120>
   15a44:	785b      	ldrb	r3, [r3, #1]
   15a46:	2b28      	cmp	r3, #40	; 0x28
   15a48:	d032      	beq.n	15ab0 <uart_open+0x120>
    if( (uart_buffer_config == NULL) || (uart_buffer_config->rx_buffer_size == 0) )
   15a4a:	2f00      	cmp	r7, #0
   15a4c:	d030      	beq.n	15ab0 <uart_open+0x120>
   15a4e:	883b      	ldrh	r3, [r7, #0]
   15a50:	2b00      	cmp	r3, #0
   15a52:	d02d      	beq.n	15ab0 <uart_open+0x120>
    uint16 rx_state_len = sizeof( UART_RX_STATE ) + (uint16) (2 * uart_buffer_config->rx_buffer_size);
   15a54:	3314      	adds	r3, #20
   15a56:	005b      	lsls	r3, r3, #1
    uart_rx_state[uart] = irmalloc( rx_state_len );
   15a58:	b29b      	uxth	r3, r3
   15a5a:	0018      	movs	r0, r3
   15a5c:	9303      	str	r3, [sp, #12]
   15a5e:	f7fc ffcf 	bl	12a00 <irmalloc>
   15a62:	5170      	str	r0, [r6, r5]
    if( uart_rx_state[uart] == NULL )
   15a64:	2800      	cmp	r0, #0
   15a66:	d103      	bne.n	15a70 <uart_open+0xe0>
        panic( PANIC_UART, PANIC_UART_UNABLE_TO_ALLOCATE_MEMORY_FOR_UART );
   15a68:	2101      	movs	r1, #1
   15a6a:	3007      	adds	r0, #7
   15a6c:	f7ec f850 	bl	1b10 <panic>
    memset( uart_rx_state[uart], 0, rx_state_len );
   15a70:	4d68      	ldr	r5, [pc, #416]	; (15c14 <uart_open+0x284>)
   15a72:	00a6      	lsls	r6, r4, #2
   15a74:	9a03      	ldr	r2, [sp, #12]
   15a76:	2100      	movs	r1, #0
   15a78:	5970      	ldr	r0, [r6, r5]
   15a7a:	f7ea fc31 	bl	2e0 <memset>
    uart_rx_state[uart]->data_buffer = (uint8 *)uart_rx_state[uart] + sizeof( UART_RX_STATE );
   15a7e:	5973      	ldr	r3, [r6, r5]
       uart_common_configure_rx_interrupts( uart, &uart_interrupt_handlers[uart] );
   15a80:	0020      	movs	r0, r4
    uart_rx_state[uart]->data_buffer = (uint8 *)uart_rx_state[uart] + sizeof( UART_RX_STATE );
   15a82:	001a      	movs	r2, r3
   15a84:	3228      	adds	r2, #40	; 0x28
   15a86:	621a      	str	r2, [r3, #32]
    uart_rx_state[uart]->error_buffer = uart_rx_state[uart]->data_buffer + uart_buffer_config->rx_buffer_size;
   15a88:	8839      	ldrh	r1, [r7, #0]
   15a8a:	1852      	adds	r2, r2, r1
   15a8c:	625a      	str	r2, [r3, #36]	; 0x24
    uart_rx_state[uart]->rx_buffer_size = uart_buffer_config->rx_buffer_size;
   15a8e:	883a      	ldrh	r2, [r7, #0]
   15a90:	801a      	strh	r2, [r3, #0]
    uart_rx_state[uart]->rx_upper_water_margin = uart_buffer_config->rx_buffer_size - (uart_buffer_config->rx_buffer_size >> 3);   // 7/8ths of buffer size
   15a92:	883a      	ldrh	r2, [r7, #0]
   15a94:	08d1      	lsrs	r1, r2, #3
   15a96:	1a52      	subs	r2, r2, r1
   15a98:	839a      	strh	r2, [r3, #28]
    uart_rx_state[uart]->rx_lower_water_margin = 0;
   15a9a:	2200      	movs	r2, #0
   15a9c:	83da      	strh	r2, [r3, #30]
    uart_rx_state[uart]->rx_condition = UART_RX_CONDITION_FULL_OR_IDLE;
   15a9e:	3205      	adds	r2, #5
   15aa0:	769a      	strb	r2, [r3, #26]
    uart_rx_state[uart]->rx_condition_size = uart_buffer_config->rx_buffer_size;
   15aa2:	883a      	ldrh	r2, [r7, #0]
       uart_common_configure_rx_interrupts( uart, &uart_interrupt_handlers[uart] );
   15aa4:	495d      	ldr	r1, [pc, #372]	; (15c1c <uart_open+0x28c>)
    uart_rx_state[uart]->rx_condition_size = uart_buffer_config->rx_buffer_size;
   15aa6:	821a      	strh	r2, [r3, #16]
       uart_common_configure_rx_interrupts( uart, &uart_interrupt_handlers[uart] );
   15aa8:	0123      	lsls	r3, r4, #4
   15aaa:	18c9      	adds	r1, r1, r3
   15aac:	f001 fa20 	bl	16ef0 <uart_common_configure_rx_interrupts>
    assert( uart_tx_state[uart] == NULL );
   15ab0:	4e5b      	ldr	r6, [pc, #364]	; (15c20 <uart_open+0x290>)
   15ab2:	00a5      	lsls	r5, r4, #2
   15ab4:	59ab      	ldr	r3, [r5, r6]
   15ab6:	2b00      	cmp	r3, #0
   15ab8:	d003      	beq.n	15ac2 <uart_open+0x132>
   15aba:	9900      	ldr	r1, [sp, #0]
   15abc:	2016      	movs	r0, #22
   15abe:	f7ec f827 	bl	1b10 <panic>
    if( uart_tx_state[uart] != NULL )
   15ac2:	5973      	ldr	r3, [r6, r5]
   15ac4:	2b00      	cmp	r3, #0
   15ac6:	d144      	bne.n	15b52 <uart_open+0x1c2>
   15ac8:	4b53      	ldr	r3, [pc, #332]	; (15c18 <uart_open+0x288>)
   15aca:	595b      	ldr	r3, [r3, r5]
    if( (uart_pin_config[uart] == NULL) || (uart_pin_config[uart]->tx_pin == PIN_NONE) )
   15acc:	2b00      	cmp	r3, #0
   15ace:	d040      	beq.n	15b52 <uart_open+0x1c2>
   15ad0:	781b      	ldrb	r3, [r3, #0]
   15ad2:	2b28      	cmp	r3, #40	; 0x28
   15ad4:	d03d      	beq.n	15b52 <uart_open+0x1c2>
    uart_tx_state[uart] = irmalloc( tx_state_len );
   15ad6:	2014      	movs	r0, #20
   15ad8:	f7fc ff92 	bl	12a00 <irmalloc>
   15adc:	5170      	str	r0, [r6, r5]
    if( uart_tx_state[uart] == NULL )
   15ade:	2800      	cmp	r0, #0
   15ae0:	d103      	bne.n	15aea <uart_open+0x15a>
        panic( PANIC_UART, PANIC_UART_UNABLE_TO_ALLOCATE_MEMORY_FOR_UART );
   15ae2:	2101      	movs	r1, #1
   15ae4:	3007      	adds	r0, #7
   15ae6:	f7ec f813 	bl	1b10 <panic>
    memset( uart_tx_state[uart], 0, tx_state_len );
   15aea:	2214      	movs	r2, #20
   15aec:	2100      	movs	r1, #0
   15aee:	5970      	ldr	r0, [r6, r5]
   15af0:	f7ea fbf6 	bl	2e0 <memset>
    uart_tx_state[uart]->current_tx_fragment = NULL; // the queue is empty.
   15af4:	2200      	movs	r2, #0
   15af6:	5973      	ldr	r3, [r6, r5]
    uart_tx_state[uart]->blocks_head = irmalloc( sizeof( uart_tx_fragments_block ) );
   15af8:	484a      	ldr	r0, [pc, #296]	; (15c24 <uart_open+0x294>)
    uart_tx_state[uart]->current_tx_fragment = NULL; // the queue is empty.
   15afa:	601a      	str	r2, [r3, #0]
    uart_tx_state[uart]->blocks_in_use = 1;
   15afc:	2301      	movs	r3, #1
   15afe:	5977      	ldr	r7, [r6, r5]
   15b00:	743b      	strb	r3, [r7, #16]
    uart_tx_state[uart]->blocks_head = irmalloc( sizeof( uart_tx_fragments_block ) );
   15b02:	f7fc ff7d 	bl	12a00 <irmalloc>
    if( uart_tx_state[uart]->blocks_head == NULL )
   15b06:	5973      	ldr	r3, [r6, r5]
    uart_tx_state[uart]->blocks_head = irmalloc( sizeof( uart_tx_fragments_block ) );
   15b08:	60f8      	str	r0, [r7, #12]
    if( uart_tx_state[uart]->blocks_head == NULL )
   15b0a:	68db      	ldr	r3, [r3, #12]
   15b0c:	2b00      	cmp	r3, #0
   15b0e:	d103      	bne.n	15b18 <uart_open+0x188>
        panic( PANIC_UART, PANIC_UART_UNABLE_TO_ALLOCATE_MEMORY_FOR_UART );
   15b10:	2101      	movs	r1, #1
   15b12:	2007      	movs	r0, #7
   15b14:	f7eb fffc 	bl	1b10 <panic>
    uart_helper_fragments_block_initialise( uart_tx_state[uart]->blocks_head );
   15b18:	4b41      	ldr	r3, [pc, #260]	; (15c20 <uart_open+0x290>)
   15b1a:	00a2      	lsls	r2, r4, #2
   15b1c:	58d3      	ldr	r3, [r2, r3]
   15b1e:	21a0      	movs	r1, #160	; 0xa0
   15b20:	68db      	ldr	r3, [r3, #12]
   15b22:	00c9      	lsls	r1, r1, #3
   15b24:	001a      	movs	r2, r3
   15b26:	1859      	adds	r1, r3, r1
   15b28:	3214      	adds	r2, #20
        block->fragments[i].next = &(block->fragments[i+1]);
   15b2a:	1f10      	subs	r0, r2, #4
   15b2c:	6002      	str	r2, [r0, #0]
   15b2e:	3214      	adds	r2, #20
    for ( i = 0; i < UART_NUMBER_OF_FRAGMENTS_IN_BLOCK - 1; i++)
   15b30:	4291      	cmp	r1, r2
   15b32:	d1fa      	bne.n	15b2a <uart_open+0x19a>
    block->fragments[ UART_NUMBER_OF_FRAGMENTS_IN_BLOCK -1 ].next = NULL;
   15b34:	2200      	movs	r2, #0
   15b36:	493c      	ldr	r1, [pc, #240]	; (15c28 <uart_open+0x298>)
       uart_common_configure_tx_interrupts( uart, &uart_interrupt_handlers[uart] );
   15b38:	0020      	movs	r0, r4
    block->fragments[ UART_NUMBER_OF_FRAGMENTS_IN_BLOCK -1 ].next = NULL;
   15b3a:	505a      	str	r2, [r3, r1]
    block->next_free_fragment = &(block->fragments[0]);
   15b3c:	3104      	adds	r1, #4
   15b3e:	505b      	str	r3, [r3, r1]
    block->fragments_in_use = 0;
   15b40:	3108      	adds	r1, #8
   15b42:	545a      	strb	r2, [r3, r1]
    block->next = NULL;
   15b44:	4939      	ldr	r1, [pc, #228]	; (15c2c <uart_open+0x29c>)
   15b46:	505a      	str	r2, [r3, r1]
       uart_common_configure_tx_interrupts( uart, &uart_interrupt_handlers[uart] );
   15b48:	4934      	ldr	r1, [pc, #208]	; (15c1c <uart_open+0x28c>)
   15b4a:	0123      	lsls	r3, r4, #4
   15b4c:	18c9      	adds	r1, r1, r3
   15b4e:	f001 f9f5 	bl	16f3c <uart_common_configure_tx_interrupts>
    uart_flow_control_state_array[uart].tx_requested = UART_FLOW_CONTROL_DEASSERTED;   // We are ok to TX
   15b52:	2300      	movs	r3, #0
   15b54:	4936      	ldr	r1, [pc, #216]	; (15c30 <uart_open+0x2a0>)
   15b56:	00a6      	lsls	r6, r4, #2
   15b58:	198a      	adds	r2, r1, r6
    uart_flow_control_state_array[uart].enabled = false;
   15b5a:	5473      	strb	r3, [r6, r1]
    uart_flow_control_state_array[uart].tx_requested = UART_FLOW_CONTROL_DEASSERTED;   // We are ok to TX
   15b5c:	70d3      	strb	r3, [r2, #3]
    uart_flow_control_state_array[uart].rx_required = UART_FLOW_CONTROL_DEASSERTED;    // We are ok to RX
   15b5e:	7053      	strb	r3, [r2, #1]
    uart_flow_control_state_array[uart].rx_issued = UART_FLOW_CONTROL_DEASSERTED;
   15b60:	7093      	strb	r3, [r2, #2]
    uart_common_enable_uart( uart, uart_pin_config[uart] );
   15b62:	4b2d      	ldr	r3, [pc, #180]	; (15c18 <uart_open+0x288>)
   15b64:	0020      	movs	r0, r4
   15b66:	58f1      	ldr	r1, [r6, r3]
   15b68:	f001 fa39 	bl	16fde <uart_common_enable_uart>
    if (uart_dma_config != NULL)
   15b6c:	9b01      	ldr	r3, [sp, #4]
   15b6e:	2b00      	cmp	r3, #0
   15b70:	d100      	bne.n	15b74 <uart_open+0x1e4>
   15b72:	e733      	b.n	159dc <uart_open+0x4c>
        assert(non_os_is_driver_initialised(DRIVER_INIT_DMA) == true);
   15b74:	200d      	movs	r0, #13
   15b76:	f002 fb45 	bl	18204 <non_os_is_driver_initialised>
   15b7a:	2800      	cmp	r0, #0
   15b7c:	d103      	bne.n	15b86 <uart_open+0x1f6>
   15b7e:	9900      	ldr	r1, [sp, #0]
   15b80:	3016      	adds	r0, #22
   15b82:	f7eb ffc5 	bl	1b10 <panic>
        periph_cfg.feature.periph_addr = (uint32)uart_data_register[uart];
   15b86:	4b2b      	ldr	r3, [pc, #172]	; (15c34 <uart_open+0x2a4>)
   15b88:	ad05      	add	r5, sp, #20
   15b8a:	599b      	ldr	r3, [r3, r6]
   15b8c:	60ab      	str	r3, [r5, #8]
        periph_cfg.feature.power_of_burst = DMA_POWER_OF_BURST_4;
   15b8e:	2304      	movs	r3, #4
   15b90:	712b      	strb	r3, [r5, #4]
        if (uart_dma_config->tx_use_dma)
   15b92:	9b01      	ldr	r3, [sp, #4]
   15b94:	781b      	ldrb	r3, [r3, #0]
   15b96:	2b00      	cmp	r3, #0
   15b98:	d120      	bne.n	15bdc <uart_open+0x24c>
        if (uart_dma_config->rx_use_dma)
   15b9a:	9b01      	ldr	r3, [sp, #4]
   15b9c:	785b      	ldrb	r3, [r3, #1]
   15b9e:	2b00      	cmp	r3, #0
   15ba0:	d100      	bne.n	15ba4 <uart_open+0x214>
   15ba2:	e71b      	b.n	159dc <uart_open+0x4c>
            periph_cfg.peripheral = uart_rx_dma_peripheral[uart];
   15ba4:	4b24      	ldr	r3, [pc, #144]	; (15c38 <uart_open+0x2a8>)
            ret = dma_ch_open(&uart_rx_dma_ch[uart], uart_dma_config->rx_dma_ch_priority, &periph_cfg);
   15ba6:	4e25      	ldr	r6, [pc, #148]	; (15c3c <uart_open+0x2ac>)
            periph_cfg.peripheral = uart_rx_dma_peripheral[uart];
   15ba8:	5d1b      	ldrb	r3, [r3, r4]
            ret = dma_ch_open(&uart_rx_dma_ch[uart], uart_dma_config->rx_dma_ch_priority, &periph_cfg);
   15baa:	002a      	movs	r2, r5
            periph_cfg.peripheral = uart_rx_dma_peripheral[uart];
   15bac:	702b      	strb	r3, [r5, #0]
            periph_cfg.feature.use_burst = false;
   15bae:	2300      	movs	r3, #0
   15bb0:	716b      	strb	r3, [r5, #5]
            periph_cfg.transfer_prepare = uart_rx_dma_transfer_prepare;
   15bb2:	4b23      	ldr	r3, [pc, #140]	; (15c40 <uart_open+0x2b0>)
            ret = dma_ch_open(&uart_rx_dma_ch[uart], uart_dma_config->rx_dma_ch_priority, &periph_cfg);
   15bb4:	1930      	adds	r0, r6, r4
            periph_cfg.transfer_prepare = uart_rx_dma_transfer_prepare;
   15bb6:	60eb      	str	r3, [r5, #12]
            periph_cfg.transfer_finish  = uart_rx_dma_transfer_finish;
   15bb8:	4b22      	ldr	r3, [pc, #136]	; (15c44 <uart_open+0x2b4>)
   15bba:	612b      	str	r3, [r5, #16]
            ret = dma_ch_open(&uart_rx_dma_ch[uart], uart_dma_config->rx_dma_ch_priority, &periph_cfg);
   15bbc:	9b01      	ldr	r3, [sp, #4]
   15bbe:	78d9      	ldrb	r1, [r3, #3]
   15bc0:	f000 ffd6 	bl	16b70 <dma_ch_open>
            assert(uart_rx_dma_ch[uart] != DMA_CHANNEL_NONE);
   15bc4:	5d33      	ldrb	r3, [r6, r4]
            ret = dma_ch_open(&uart_rx_dma_ch[uart], uart_dma_config->rx_dma_ch_priority, &periph_cfg);
   15bc6:	0005      	movs	r5, r0
            assert(uart_rx_dma_ch[uart] != DMA_CHANNEL_NONE);
   15bc8:	2b04      	cmp	r3, #4
   15bca:	d103      	bne.n	15bd4 <uart_open+0x244>
   15bcc:	9900      	ldr	r1, [sp, #0]
   15bce:	2016      	movs	r0, #22
   15bd0:	f7eb ff9e 	bl	1b10 <panic>
            if (ret != DMA_RET_OK)
   15bd4:	2d00      	cmp	r5, #0
   15bd6:	d000      	beq.n	15bda <uart_open+0x24a>
   15bd8:	e6f3      	b.n	159c2 <uart_open+0x32>
   15bda:	e6ff      	b.n	159dc <uart_open+0x4c>
            periph_cfg.peripheral = uart_tx_dma_peripheral[uart];
   15bdc:	4b1a      	ldr	r3, [pc, #104]	; (15c48 <uart_open+0x2b8>)
            ret = dma_ch_open(&uart_tx_dma_ch[uart], uart_dma_config->tx_dma_ch_priority, &periph_cfg);
   15bde:	4e1b      	ldr	r6, [pc, #108]	; (15c4c <uart_open+0x2bc>)
            periph_cfg.peripheral = uart_tx_dma_peripheral[uart];
   15be0:	5d1b      	ldrb	r3, [r3, r4]
            ret = dma_ch_open(&uart_tx_dma_ch[uart], uart_dma_config->tx_dma_ch_priority, &periph_cfg);
   15be2:	1930      	adds	r0, r6, r4
            periph_cfg.peripheral = uart_tx_dma_peripheral[uart];
   15be4:	702b      	strb	r3, [r5, #0]
            periph_cfg.feature.use_burst = true;
   15be6:	2301      	movs	r3, #1
   15be8:	716b      	strb	r3, [r5, #5]
            periph_cfg.transfer_prepare = uart_tx_dma_transfer_prepare;
   15bea:	4b19      	ldr	r3, [pc, #100]	; (15c50 <uart_open+0x2c0>)
            ret = dma_ch_open(&uart_tx_dma_ch[uart], uart_dma_config->tx_dma_ch_priority, &periph_cfg);
   15bec:	002a      	movs	r2, r5
            periph_cfg.transfer_prepare = uart_tx_dma_transfer_prepare;
   15bee:	60eb      	str	r3, [r5, #12]
            periph_cfg.transfer_finish  = uart_tx_dma_transfer_finish;
   15bf0:	4b18      	ldr	r3, [pc, #96]	; (15c54 <uart_open+0x2c4>)
   15bf2:	612b      	str	r3, [r5, #16]
            ret = dma_ch_open(&uart_tx_dma_ch[uart], uart_dma_config->tx_dma_ch_priority, &periph_cfg);
   15bf4:	9b01      	ldr	r3, [sp, #4]
   15bf6:	7899      	ldrb	r1, [r3, #2]
   15bf8:	f000 ffba 	bl	16b70 <dma_ch_open>
            assert(uart_tx_dma_ch[uart] != DMA_CHANNEL_NONE);
   15bfc:	5d33      	ldrb	r3, [r6, r4]
            ret = dma_ch_open(&uart_tx_dma_ch[uart], uart_dma_config->tx_dma_ch_priority, &periph_cfg);
   15bfe:	0007      	movs	r7, r0
            assert(uart_tx_dma_ch[uart] != DMA_CHANNEL_NONE);
   15c00:	2b04      	cmp	r3, #4
   15c02:	d103      	bne.n	15c0c <uart_open+0x27c>
   15c04:	9900      	ldr	r1, [sp, #0]
   15c06:	2016      	movs	r0, #22
   15c08:	f7eb ff82 	bl	1b10 <panic>
            if (ret != DMA_RET_OK)
   15c0c:	2f00      	cmp	r7, #0
   15c0e:	d000      	beq.n	15c12 <uart_open+0x282>
   15c10:	e6d7      	b.n	159c2 <uart_open+0x32>
   15c12:	e7c2      	b.n	15b9a <uart_open+0x20a>
   15c14:	01002578 	.word	0x01002578
   15c18:	01002560 	.word	0x01002560
   15c1c:	000254f8 	.word	0x000254f8
   15c20:	01002594 	.word	0x01002594
   15c24:	0000050c 	.word	0x0000050c
   15c28:	000004fc 	.word	0x000004fc
   15c2c:	00000504 	.word	0x00000504
   15c30:	01002554 	.word	0x01002554
   15c34:	0100253c 	.word	0x0100253c
   15c38:	00025534 	.word	0x00025534
   15c3c:	010005c8 	.word	0x010005c8
   15c40:	000154ed 	.word	0x000154ed
   15c44:	000154c9 	.word	0x000154c9
   15c48:	00025537 	.word	0x00025537
   15c4c:	010005cb 	.word	0x010005cb
   15c50:	00015535 	.word	0x00015535
   15c54:	00015511 	.word	0x00015511

00015c58 <uart_close>:
{
   15c58:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
   15c5a:	0004      	movs	r4, r0
    assert( non_os_is_driver_initialised(DRIVER_INIT_UART) );
   15c5c:	2008      	movs	r0, #8
   15c5e:	4676      	mov	r6, lr
   15c60:	f002 fad0 	bl	18204 <non_os_is_driver_initialised>
   15c64:	2800      	cmp	r0, #0
   15c66:	d103      	bne.n	15c70 <uart_close+0x18>
   15c68:	0031      	movs	r1, r6
   15c6a:	3016      	adds	r0, #22
   15c6c:	f7eb ff50 	bl	1b10 <panic>
    assert( uart < UART_BUS_MAX_NUMBER );
   15c70:	2c02      	cmp	r4, #2
   15c72:	d903      	bls.n	15c7c <uart_close+0x24>
   15c74:	0031      	movs	r1, r6
   15c76:	2016      	movs	r0, #22
   15c78:	f7eb ff4a 	bl	1b10 <panic>
    assert( (uart_tx_state[uart] != NULL) || (uart_rx_state[uart] != NULL) );
   15c7c:	4f18      	ldr	r7, [pc, #96]	; (15ce0 <uart_close+0x88>)
   15c7e:	00a5      	lsls	r5, r4, #2
   15c80:	59eb      	ldr	r3, [r5, r7]
   15c82:	2b00      	cmp	r3, #0
   15c84:	d107      	bne.n	15c96 <uart_close+0x3e>
   15c86:	4b17      	ldr	r3, [pc, #92]	; (15ce4 <uart_close+0x8c>)
   15c88:	58eb      	ldr	r3, [r5, r3]
   15c8a:	2b00      	cmp	r3, #0
   15c8c:	d120      	bne.n	15cd0 <uart_close+0x78>
   15c8e:	0031      	movs	r1, r6
   15c90:	2016      	movs	r0, #22
   15c92:	f7eb ff3d 	bl	1b10 <panic>
    if( (uart < UART_BUS_MAX_NUMBER) && ((uart_tx_state[uart] != NULL) || (uart_rx_state[uart] != NULL)) )
   15c96:	2c02      	cmp	r4, #2
   15c98:	d820      	bhi.n	15cdc <uart_close+0x84>
   15c9a:	597b      	ldr	r3, [r7, r5]
   15c9c:	2b00      	cmp	r3, #0
   15c9e:	d019      	beq.n	15cd4 <uart_close+0x7c>
        bool scheduler_running = (osKernelGetState() == osKernelRunning);
   15ca0:	f7fe fd18 	bl	146d4 <osKernelGetState>
   15ca4:	0005      	movs	r5, r0
        if( scheduler_running )
   15ca6:	2802      	cmp	r0, #2
   15ca8:	d101      	bne.n	15cae <uart_close+0x56>
            (void)osKernelLock();
   15caa:	f7fe fd49 	bl	14740 <osKernelLock>
        uart_claim_mutexes( uart );
   15cae:	0020      	movs	r0, r4
   15cb0:	f7ff fc5c 	bl	1556c <uart_claim_mutexes>
        hal_uart_disable_uart(uart);
   15cb4:	0020      	movs	r0, r4
   15cb6:	f003 ff2e 	bl	19b16 <hal_uart_disable_uart>
        uart_release_mutexes( uart );
   15cba:	0020      	movs	r0, r4
   15cbc:	f7ff fc7c 	bl	155b8 <uart_release_mutexes>
        uart_deconfigure_state( uart );
   15cc0:	0020      	movs	r0, r4
   15cc2:	f7ff fcdd 	bl	15680 <uart_deconfigure_state>
        if( scheduler_running )
   15cc6:	2d02      	cmp	r5, #2
   15cc8:	d108      	bne.n	15cdc <uart_close+0x84>
            (void)osKernelUnlock();
   15cca:	f7fe fd55 	bl	14778 <osKernelUnlock>
}
   15cce:	e005      	b.n	15cdc <uart_close+0x84>
    if( (uart < UART_BUS_MAX_NUMBER) && ((uart_tx_state[uart] != NULL) || (uart_rx_state[uart] != NULL)) )
   15cd0:	2c02      	cmp	r4, #2
   15cd2:	d803      	bhi.n	15cdc <uart_close+0x84>
   15cd4:	4b03      	ldr	r3, [pc, #12]	; (15ce4 <uart_close+0x8c>)
   15cd6:	595b      	ldr	r3, [r3, r5]
   15cd8:	2b00      	cmp	r3, #0
   15cda:	d1e1      	bne.n	15ca0 <uart_close+0x48>
}
   15cdc:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
   15cde:	46c0      	nop			; (mov r8, r8)
   15ce0:	01002594 	.word	0x01002594
   15ce4:	01002578 	.word	0x01002578

00015ce8 <uart_enable_software_flow_control>:
{
   15ce8:	b570      	push	{r4, r5, r6, lr}
   15cea:	0004      	movs	r4, r0
    assert( non_os_is_driver_initialised(DRIVER_INIT_UART) );
   15cec:	2008      	movs	r0, #8
   15cee:	4675      	mov	r5, lr
{
   15cf0:	000e      	movs	r6, r1
    assert( non_os_is_driver_initialised(DRIVER_INIT_UART) );
   15cf2:	f002 fa87 	bl	18204 <non_os_is_driver_initialised>
   15cf6:	2800      	cmp	r0, #0
   15cf8:	d103      	bne.n	15d02 <uart_enable_software_flow_control+0x1a>
   15cfa:	0029      	movs	r1, r5
   15cfc:	3016      	adds	r0, #22
   15cfe:	f7eb ff07 	bl	1b10 <panic>
    assert( uart < UART_BUS_MAX_NUMBER );
   15d02:	2c02      	cmp	r4, #2
   15d04:	d904      	bls.n	15d10 <uart_enable_software_flow_control+0x28>
   15d06:	0029      	movs	r1, r5
   15d08:	2016      	movs	r0, #22
   15d0a:	f7eb ff01 	bl	1b10 <panic>
}
   15d0e:	bd70      	pop	{r4, r5, r6, pc}
        non_os_enter_critical();
   15d10:	f002 fa50 	bl	181b4 <non_os_enter_critical>
        uart_flow_control_state_array[uart].enabled = enable;
   15d14:	4b02      	ldr	r3, [pc, #8]	; (15d20 <uart_enable_software_flow_control+0x38>)
   15d16:	00a4      	lsls	r4, r4, #2
   15d18:	54e6      	strb	r6, [r4, r3]
        non_os_exit_critical();
   15d1a:	f002 fa5f 	bl	181dc <non_os_exit_critical>
   15d1e:	e7f6      	b.n	15d0e <uart_enable_software_flow_control+0x26>
   15d20:	01002554 	.word	0x01002554

00015d24 <uart_set_software_flow_control_water_margin>:
{
   15d24:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
   15d26:	0006      	movs	r6, r0
    assert( non_os_is_driver_initialised(DRIVER_INIT_UART) );
   15d28:	2008      	movs	r0, #8
   15d2a:	4677      	mov	r7, lr
{
   15d2c:	000d      	movs	r5, r1
   15d2e:	0014      	movs	r4, r2
    assert( non_os_is_driver_initialised(DRIVER_INIT_UART) );
   15d30:	f002 fa68 	bl	18204 <non_os_is_driver_initialised>
   15d34:	2800      	cmp	r0, #0
   15d36:	d103      	bne.n	15d40 <uart_set_software_flow_control_water_margin+0x1c>
   15d38:	0039      	movs	r1, r7
   15d3a:	3016      	adds	r0, #22
   15d3c:	f7eb fee8 	bl	1b10 <panic>
    assert( uart < UART_BUS_MAX_NUMBER );
   15d40:	2e02      	cmp	r6, #2
   15d42:	d90f      	bls.n	15d64 <uart_set_software_flow_control_water_margin+0x40>
   15d44:	2016      	movs	r0, #22
   15d46:	0039      	movs	r1, r7
   15d48:	f7eb fee2 	bl	1b10 <panic>
    return false;
   15d4c:	2000      	movs	r0, #0
}
   15d4e:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    return false;
   15d50:	2000      	movs	r0, #0
        if ( (lower_water_margin <= upper_water_margin) && (upper_water_margin <= uart_rx_state[uart]->rx_buffer_size) )
   15d52:	42a5      	cmp	r5, r4
   15d54:	d8fb      	bhi.n	15d4e <uart_set_software_flow_control_water_margin+0x2a>
   15d56:	881a      	ldrh	r2, [r3, #0]
   15d58:	42a2      	cmp	r2, r4
   15d5a:	d3f8      	bcc.n	15d4e <uart_set_software_flow_control_water_margin+0x2a>
            uart_rx_state[uart]->rx_upper_water_margin = upper_water_margin;
   15d5c:	839c      	strh	r4, [r3, #28]
            uart_rx_state[uart]->rx_lower_water_margin = lower_water_margin;
   15d5e:	83dd      	strh	r5, [r3, #30]
            return true;
   15d60:	3001      	adds	r0, #1
   15d62:	e7f4      	b.n	15d4e <uart_set_software_flow_control_water_margin+0x2a>
    if( (uart < UART_BUS_MAX_NUMBER) && (uart_rx_state[uart] != NULL) )
   15d64:	4b03      	ldr	r3, [pc, #12]	; (15d74 <uart_set_software_flow_control_water_margin+0x50>)
   15d66:	00b6      	lsls	r6, r6, #2
   15d68:	58f3      	ldr	r3, [r6, r3]
   15d6a:	2b00      	cmp	r3, #0
   15d6c:	d1f0      	bne.n	15d50 <uart_set_software_flow_control_water_margin+0x2c>
    return false;
   15d6e:	0018      	movs	r0, r3
   15d70:	e7ed      	b.n	15d4e <uart_set_software_flow_control_water_margin+0x2a>
   15d72:	46c0      	nop			; (mov r8, r8)
   15d74:	01002578 	.word	0x01002578

00015d78 <uart_get_software_rx_flow_control_assert_function>:
{
   15d78:	b510      	push	{r4, lr}
    assert( uart < UART_BUS_MAX_NUMBER );
   15d7a:	2802      	cmp	r0, #2
   15d7c:	d905      	bls.n	15d8a <uart_get_software_rx_flow_control_assert_function+0x12>
   15d7e:	2016      	movs	r0, #22
   15d80:	4671      	mov	r1, lr
   15d82:	f7eb fec5 	bl	1b10 <panic>
    return NULL;
   15d86:	2000      	movs	r0, #0
}
   15d88:	bd10      	pop	{r4, pc}
        return uart_assert_software_rx_flow_control_functions[ uart ];
   15d8a:	4b02      	ldr	r3, [pc, #8]	; (15d94 <uart_get_software_rx_flow_control_assert_function+0x1c>)
   15d8c:	0080      	lsls	r0, r0, #2
   15d8e:	58c0      	ldr	r0, [r0, r3]
   15d90:	e7fa      	b.n	15d88 <uart_get_software_rx_flow_control_assert_function+0x10>
   15d92:	46c0      	nop			; (mov r8, r8)
   15d94:	000254e0 	.word	0x000254e0

00015d98 <uart_get_software_tx_flow_control_assert_function>:
{
   15d98:	b510      	push	{r4, lr}
    assert( uart < UART_BUS_MAX_NUMBER );
   15d9a:	2802      	cmp	r0, #2
   15d9c:	d905      	bls.n	15daa <uart_get_software_tx_flow_control_assert_function+0x12>
   15d9e:	2016      	movs	r0, #22
   15da0:	4671      	mov	r1, lr
   15da2:	f7eb feb5 	bl	1b10 <panic>
    return NULL;
   15da6:	2000      	movs	r0, #0
}
   15da8:	bd10      	pop	{r4, pc}
        return uart_assert_software_tx_flow_control_functions[ uart ];
   15daa:	4b02      	ldr	r3, [pc, #8]	; (15db4 <uart_get_software_tx_flow_control_assert_function+0x1c>)
   15dac:	0080      	lsls	r0, r0, #2
   15dae:	58c0      	ldr	r0, [r0, r3]
   15db0:	e7fa      	b.n	15da8 <uart_get_software_tx_flow_control_assert_function+0x10>
   15db2:	46c0      	nop			; (mov r8, r8)
   15db4:	000254ec 	.word	0x000254ec

00015db8 <uart_has_pending_transmissions>:
{
   15db8:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
   15dba:	0004      	movs	r4, r0
    assert( non_os_is_driver_initialised(DRIVER_INIT_UART) );
   15dbc:	2008      	movs	r0, #8
   15dbe:	4675      	mov	r5, lr
   15dc0:	f002 fa20 	bl	18204 <non_os_is_driver_initialised>
   15dc4:	2800      	cmp	r0, #0
   15dc6:	d103      	bne.n	15dd0 <uart_has_pending_transmissions+0x18>
   15dc8:	0029      	movs	r1, r5
   15dca:	3016      	adds	r0, #22
   15dcc:	f7eb fea0 	bl	1b10 <panic>
    assert( uart < UART_BUS_MAX_NUMBER );
   15dd0:	2c02      	cmp	r4, #2
   15dd2:	d903      	bls.n	15ddc <uart_has_pending_transmissions+0x24>
   15dd4:	0029      	movs	r1, r5
   15dd6:	2016      	movs	r0, #22
   15dd8:	f7eb fe9a 	bl	1b10 <panic>
    assert( uart_tx_state[uart] != NULL );
   15ddc:	4f09      	ldr	r7, [pc, #36]	; (15e04 <uart_has_pending_transmissions+0x4c>)
   15dde:	00a6      	lsls	r6, r4, #2
   15de0:	59f3      	ldr	r3, [r6, r7]
   15de2:	2b00      	cmp	r3, #0
   15de4:	d103      	bne.n	15dee <uart_has_pending_transmissions+0x36>
   15de6:	0029      	movs	r1, r5
   15de8:	2016      	movs	r0, #22
   15dea:	f7eb fe91 	bl	1b10 <panic>
    return ( (uart_tx_state[uart]->fragments_to_process > 0) || hal_uart_is_busy(uart) );
   15dee:	59bb      	ldr	r3, [r7, r6]
   15df0:	2001      	movs	r0, #1
   15df2:	891b      	ldrh	r3, [r3, #8]
   15df4:	2b00      	cmp	r3, #0
   15df6:	d102      	bne.n	15dfe <uart_has_pending_transmissions+0x46>
   15df8:	0020      	movs	r0, r4
   15dfa:	f003 fee8 	bl	19bce <hal_uart_is_busy>
   15dfe:	2301      	movs	r3, #1
   15e00:	4018      	ands	r0, r3
}
   15e02:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
   15e04:	01002594 	.word	0x01002594

00015e08 <uart_register_rx_callback>:
{
   15e08:	b5f0      	push	{r4, r5, r6, r7, lr}
   15e0a:	0005      	movs	r5, r0
   15e0c:	b085      	sub	sp, #20
    assert( non_os_is_driver_initialised(DRIVER_INIT_UART) );
   15e0e:	2008      	movs	r0, #8
   15e10:	4676      	mov	r6, lr
{
   15e12:	9100      	str	r1, [sp, #0]
   15e14:	9201      	str	r2, [sp, #4]
   15e16:	9302      	str	r3, [sp, #8]
    assert( non_os_is_driver_initialised(DRIVER_INIT_UART) );
   15e18:	f002 f9f4 	bl	18204 <non_os_is_driver_initialised>
   15e1c:	2800      	cmp	r0, #0
   15e1e:	d103      	bne.n	15e28 <uart_register_rx_callback+0x20>
   15e20:	0031      	movs	r1, r6
   15e22:	3016      	adds	r0, #22
   15e24:	f7eb fe74 	bl	1b10 <panic>
    assert( uart < UART_BUS_MAX_NUMBER );
   15e28:	2d02      	cmp	r5, #2
   15e2a:	d903      	bls.n	15e34 <uart_register_rx_callback+0x2c>
   15e2c:	0031      	movs	r1, r6
   15e2e:	2016      	movs	r0, #22
   15e30:	f7eb fe6e 	bl	1b10 <panic>
    assert( uart_rx_state[uart] != NULL );
   15e34:	4f1e      	ldr	r7, [pc, #120]	; (15eb0 <uart_register_rx_callback+0xa8>)
   15e36:	00ac      	lsls	r4, r5, #2
   15e38:	59e3      	ldr	r3, [r4, r7]
   15e3a:	2b00      	cmp	r3, #0
   15e3c:	d103      	bne.n	15e46 <uart_register_rx_callback+0x3e>
   15e3e:	0031      	movs	r1, r6
   15e40:	2016      	movs	r0, #22
   15e42:	f7eb fe65 	bl	1b10 <panic>
    assert( uart_rx_mutex[uart] != NULL );
   15e46:	4b1b      	ldr	r3, [pc, #108]	; (15eb4 <uart_register_rx_callback+0xac>)
   15e48:	591b      	ldr	r3, [r3, r4]
   15e4a:	9303      	str	r3, [sp, #12]
   15e4c:	2b00      	cmp	r3, #0
   15e4e:	d103      	bne.n	15e58 <uart_register_rx_callback+0x50>
   15e50:	0031      	movs	r1, r6
   15e52:	2016      	movs	r0, #22
   15e54:	f7eb fe5c 	bl	1b10 <panic>
    uart_helper_take_semaphore_or_panic(uart_rx_mutex[uart], osWaitForever);
   15e58:	2101      	movs	r1, #1
   15e5a:	4b16      	ldr	r3, [pc, #88]	; (15eb4 <uart_register_rx_callback+0xac>)
   15e5c:	4249      	negs	r1, r1
   15e5e:	5918      	ldr	r0, [r3, r4]
   15e60:	f7ff fb7a 	bl	15558 <uart_helper_take_semaphore_or_panic>
    non_os_enter_critical();
   15e64:	f002 f9a6 	bl	181b4 <non_os_enter_critical>
    uart_rx_state[uart]->rx_callback = callback;
   15e68:	593b      	ldr	r3, [r7, r4]
   15e6a:	9a02      	ldr	r2, [sp, #8]
   15e6c:	605a      	str	r2, [r3, #4]
    uart_rx_state[uart]->rx_condition = condition;
   15e6e:	466a      	mov	r2, sp
   15e70:	593b      	ldr	r3, [r7, r4]
   15e72:	7812      	ldrb	r2, [r2, #0]
   15e74:	769a      	strb	r2, [r3, #26]
    if( uart_rx_state[uart]->rx_condition & UART_RX_CONDITION_MASK_SUFFICIENT_DATA )
   15e76:	9a00      	ldr	r2, [sp, #0]
   15e78:	0792      	lsls	r2, r2, #30
   15e7a:	d516      	bpl.n	15eaa <uart_register_rx_callback+0xa2>
        uart_rx_state[uart]->rx_condition_size = size;
   15e7c:	466a      	mov	r2, sp
   15e7e:	8892      	ldrh	r2, [r2, #4]
        uart_rx_state[uart]->rx_condition_size = uart_rx_state[uart]->rx_buffer_size;
   15e80:	821a      	strh	r2, [r3, #16]
    hal_uart_enable_interrupt(uart,HAL_UART_INTERRUPT_RX);
   15e82:	0028      	movs	r0, r5
   15e84:	2100      	movs	r1, #0
   15e86:	f003 fda6 	bl	199d6 <hal_uart_enable_interrupt>
    hal_uart_enable_interrupt(uart,HAL_UART_INTERRUPT_ERROR);
   15e8a:	0028      	movs	r0, r5
   15e8c:	2103      	movs	r1, #3
   15e8e:	f003 fda2 	bl	199d6 <hal_uart_enable_interrupt>
    hal_uart_enable_interrupt(uart,HAL_UART_INTERRUPT_IDLE);
   15e92:	2102      	movs	r1, #2
   15e94:	0028      	movs	r0, r5
   15e96:	f003 fd9e 	bl	199d6 <hal_uart_enable_interrupt>
    non_os_exit_critical();
   15e9a:	f002 f99f 	bl	181dc <non_os_exit_critical>
    uart_helper_give_semaphore_or_panic(uart_rx_mutex[uart]);
   15e9e:	4b05      	ldr	r3, [pc, #20]	; (15eb4 <uart_register_rx_callback+0xac>)
   15ea0:	5918      	ldr	r0, [r3, r4]
   15ea2:	f7ff fb7f 	bl	155a4 <uart_helper_give_semaphore_or_panic>
}
   15ea6:	b005      	add	sp, #20
   15ea8:	bdf0      	pop	{r4, r5, r6, r7, pc}
        uart_rx_state[uart]->rx_condition_size = uart_rx_state[uart]->rx_buffer_size;
   15eaa:	881a      	ldrh	r2, [r3, #0]
   15eac:	e7e8      	b.n	15e80 <uart_register_rx_callback+0x78>
   15eae:	46c0      	nop			; (mov r8, r8)
   15eb0:	01002578 	.word	0x01002578
   15eb4:	0100256c 	.word	0x0100256c

00015eb8 <uart_register_parity_error_callback>:
{
   15eb8:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
   15eba:	0004      	movs	r4, r0
    assert( non_os_is_driver_initialised(DRIVER_INIT_UART) );
   15ebc:	2008      	movs	r0, #8
   15ebe:	4675      	mov	r5, lr
{
   15ec0:	9101      	str	r1, [sp, #4]
    assert( non_os_is_driver_initialised(DRIVER_INIT_UART) );
   15ec2:	f002 f99f 	bl	18204 <non_os_is_driver_initialised>
   15ec6:	2800      	cmp	r0, #0
   15ec8:	d103      	bne.n	15ed2 <uart_register_parity_error_callback+0x1a>
   15eca:	0029      	movs	r1, r5
   15ecc:	3016      	adds	r0, #22
   15ece:	f7eb fe1f 	bl	1b10 <panic>
    assert( uart < UART_BUS_MAX_NUMBER );
   15ed2:	2c02      	cmp	r4, #2
   15ed4:	d903      	bls.n	15ede <uart_register_parity_error_callback+0x26>
   15ed6:	0029      	movs	r1, r5
   15ed8:	2016      	movs	r0, #22
   15eda:	f7eb fe19 	bl	1b10 <panic>
    assert( uart_rx_state[uart] != NULL );
   15ede:	4f10      	ldr	r7, [pc, #64]	; (15f20 <uart_register_parity_error_callback+0x68>)
   15ee0:	00a4      	lsls	r4, r4, #2
   15ee2:	59e3      	ldr	r3, [r4, r7]
   15ee4:	2b00      	cmp	r3, #0
   15ee6:	d103      	bne.n	15ef0 <uart_register_parity_error_callback+0x38>
   15ee8:	0029      	movs	r1, r5
   15eea:	2016      	movs	r0, #22
   15eec:	f7eb fe10 	bl	1b10 <panic>
    assert( uart_rx_mutex[uart] != NULL );
   15ef0:	4e0c      	ldr	r6, [pc, #48]	; (15f24 <uart_register_parity_error_callback+0x6c>)
   15ef2:	5933      	ldr	r3, [r6, r4]
   15ef4:	2b00      	cmp	r3, #0
   15ef6:	d103      	bne.n	15f00 <uart_register_parity_error_callback+0x48>
   15ef8:	0029      	movs	r1, r5
   15efa:	2016      	movs	r0, #22
   15efc:	f7eb fe08 	bl	1b10 <panic>
    uart_helper_take_semaphore_or_panic(uart_rx_mutex[uart], osWaitForever);
   15f00:	2101      	movs	r1, #1
   15f02:	5930      	ldr	r0, [r6, r4]
   15f04:	4249      	negs	r1, r1
   15f06:	f7ff fb27 	bl	15558 <uart_helper_take_semaphore_or_panic>
    non_os_enter_critical();
   15f0a:	f002 f953 	bl	181b4 <non_os_enter_critical>
    uart_rx_state[uart]->parity_error_callback = callback;
   15f0e:	593b      	ldr	r3, [r7, r4]
   15f10:	9a01      	ldr	r2, [sp, #4]
   15f12:	609a      	str	r2, [r3, #8]
    non_os_exit_critical();
   15f14:	f002 f962 	bl	181dc <non_os_exit_critical>
    uart_helper_give_semaphore_or_panic(uart_rx_mutex[uart]);
   15f18:	5930      	ldr	r0, [r6, r4]
   15f1a:	f7ff fb43 	bl	155a4 <uart_helper_give_semaphore_or_panic>
}
   15f1e:	bdf7      	pop	{r0, r1, r2, r4, r5, r6, r7, pc}
   15f20:	01002578 	.word	0x01002578
   15f24:	0100256c 	.word	0x0100256c

00015f28 <uart_register_frame_error_callback>:
{
   15f28:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
   15f2a:	0004      	movs	r4, r0
    assert( non_os_is_driver_initialised(DRIVER_INIT_UART) );
   15f2c:	2008      	movs	r0, #8
   15f2e:	4675      	mov	r5, lr
{
   15f30:	9101      	str	r1, [sp, #4]
    assert( non_os_is_driver_initialised(DRIVER_INIT_UART) );
   15f32:	f002 f967 	bl	18204 <non_os_is_driver_initialised>
   15f36:	2800      	cmp	r0, #0
   15f38:	d103      	bne.n	15f42 <uart_register_frame_error_callback+0x1a>
   15f3a:	0029      	movs	r1, r5
   15f3c:	3016      	adds	r0, #22
   15f3e:	f7eb fde7 	bl	1b10 <panic>
    assert( uart < UART_BUS_MAX_NUMBER );
   15f42:	2c02      	cmp	r4, #2
   15f44:	d903      	bls.n	15f4e <uart_register_frame_error_callback+0x26>
   15f46:	0029      	movs	r1, r5
   15f48:	2016      	movs	r0, #22
   15f4a:	f7eb fde1 	bl	1b10 <panic>
    assert( uart_rx_state[uart] != NULL );
   15f4e:	4f10      	ldr	r7, [pc, #64]	; (15f90 <uart_register_frame_error_callback+0x68>)
   15f50:	00a4      	lsls	r4, r4, #2
   15f52:	59e3      	ldr	r3, [r4, r7]
   15f54:	2b00      	cmp	r3, #0
   15f56:	d103      	bne.n	15f60 <uart_register_frame_error_callback+0x38>
   15f58:	0029      	movs	r1, r5
   15f5a:	2016      	movs	r0, #22
   15f5c:	f7eb fdd8 	bl	1b10 <panic>
    assert( uart_rx_mutex[uart] != NULL );
   15f60:	4e0c      	ldr	r6, [pc, #48]	; (15f94 <uart_register_frame_error_callback+0x6c>)
   15f62:	5933      	ldr	r3, [r6, r4]
   15f64:	2b00      	cmp	r3, #0
   15f66:	d103      	bne.n	15f70 <uart_register_frame_error_callback+0x48>
   15f68:	0029      	movs	r1, r5
   15f6a:	2016      	movs	r0, #22
   15f6c:	f7eb fdd0 	bl	1b10 <panic>
    uart_helper_take_semaphore_or_panic(uart_rx_mutex[uart], osWaitForever);
   15f70:	2101      	movs	r1, #1
   15f72:	5930      	ldr	r0, [r6, r4]
   15f74:	4249      	negs	r1, r1
   15f76:	f7ff faef 	bl	15558 <uart_helper_take_semaphore_or_panic>
    non_os_enter_critical();
   15f7a:	f002 f91b 	bl	181b4 <non_os_enter_critical>
    uart_rx_state[uart]->frame_error_callback = callback;
   15f7e:	593b      	ldr	r3, [r7, r4]
   15f80:	9a01      	ldr	r2, [sp, #4]
   15f82:	60da      	str	r2, [r3, #12]
    non_os_exit_critical();
   15f84:	f002 f92a 	bl	181dc <non_os_exit_critical>
    uart_helper_give_semaphore_or_panic(uart_rx_mutex[uart]);
   15f88:	5930      	ldr	r0, [r6, r4]
   15f8a:	f7ff fb0b 	bl	155a4 <uart_helper_give_semaphore_or_panic>
}
   15f8e:	bdf7      	pop	{r0, r1, r2, r4, r5, r6, r7, pc}
   15f90:	01002578 	.word	0x01002578
   15f94:	0100256c 	.word	0x0100256c

00015f98 <uart_unregister_rx_callback>:
{
   15f98:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
   15f9a:	0005      	movs	r5, r0
    assert( non_os_is_driver_initialised(DRIVER_INIT_UART) );
   15f9c:	2008      	movs	r0, #8
   15f9e:	4676      	mov	r6, lr
   15fa0:	f002 f930 	bl	18204 <non_os_is_driver_initialised>
   15fa4:	2800      	cmp	r0, #0
   15fa6:	d103      	bne.n	15fb0 <uart_unregister_rx_callback+0x18>
   15fa8:	0031      	movs	r1, r6
   15faa:	3016      	adds	r0, #22
   15fac:	f7eb fdb0 	bl	1b10 <panic>
    assert( uart < UART_BUS_MAX_NUMBER );
   15fb0:	2d02      	cmp	r5, #2
   15fb2:	d903      	bls.n	15fbc <uart_unregister_rx_callback+0x24>
   15fb4:	0031      	movs	r1, r6
   15fb6:	2016      	movs	r0, #22
   15fb8:	f7eb fdaa 	bl	1b10 <panic>
    assert( uart_rx_state[uart] != NULL );
   15fbc:	4b1b      	ldr	r3, [pc, #108]	; (1602c <uart_unregister_rx_callback+0x94>)
   15fbe:	00ac      	lsls	r4, r5, #2
   15fc0:	58e3      	ldr	r3, [r4, r3]
   15fc2:	9301      	str	r3, [sp, #4]
   15fc4:	2b00      	cmp	r3, #0
   15fc6:	d103      	bne.n	15fd0 <uart_unregister_rx_callback+0x38>
   15fc8:	0031      	movs	r1, r6
   15fca:	2016      	movs	r0, #22
   15fcc:	f7eb fda0 	bl	1b10 <panic>
    assert( uart_rx_mutex[uart] != NULL );
   15fd0:	4f17      	ldr	r7, [pc, #92]	; (16030 <uart_unregister_rx_callback+0x98>)
   15fd2:	593b      	ldr	r3, [r7, r4]
   15fd4:	2b00      	cmp	r3, #0
   15fd6:	d103      	bne.n	15fe0 <uart_unregister_rx_callback+0x48>
   15fd8:	0031      	movs	r1, r6
   15fda:	2016      	movs	r0, #22
   15fdc:	f7eb fd98 	bl	1b10 <panic>
    uart_helper_take_semaphore_or_panic(uart_rx_mutex[uart], osWaitForever);
   15fe0:	2101      	movs	r1, #1
   15fe2:	5938      	ldr	r0, [r7, r4]
   15fe4:	4249      	negs	r1, r1
   15fe6:	f7ff fab7 	bl	15558 <uart_helper_take_semaphore_or_panic>
    non_os_enter_critical();
   15fea:	f002 f8e3 	bl	181b4 <non_os_enter_critical>
        uart_rx_state[uart]->rx_callback = NULL;
   15fee:	2100      	movs	r1, #0
   15ff0:	4b0e      	ldr	r3, [pc, #56]	; (1602c <uart_unregister_rx_callback+0x94>)
        hal_uart_disable_interrupt(uart,HAL_UART_INTERRUPT_RX);
   15ff2:	0028      	movs	r0, r5
        uart_rx_state[uart]->rx_callback = NULL;
   15ff4:	591b      	ldr	r3, [r3, r4]
   15ff6:	6059      	str	r1, [r3, #4]
        hal_uart_disable_interrupt(uart,HAL_UART_INTERRUPT_RX);
   15ff8:	f003 fd10 	bl	19a1c <hal_uart_disable_interrupt>
        hal_uart_disable_interrupt(uart,HAL_UART_INTERRUPT_ERROR);
   15ffc:	2103      	movs	r1, #3
   15ffe:	0028      	movs	r0, r5
   16000:	f003 fd0c 	bl	19a1c <hal_uart_disable_interrupt>
        hal_uart_disable_interrupt(uart,HAL_UART_INTERRUPT_IDLE);
   16004:	2102      	movs	r1, #2
   16006:	0028      	movs	r0, r5
   16008:	f003 fd08 	bl	19a1c <hal_uart_disable_interrupt>
        while (hal_uart_is_rx_fifo_empty(uart) == false)
   1600c:	0028      	movs	r0, r5
   1600e:	f003 fde5 	bl	19bdc <hal_uart_is_rx_fifo_empty>
   16012:	2800      	cmp	r0, #0
   16014:	d005      	beq.n	16022 <uart_unregister_rx_callback+0x8a>
    non_os_exit_critical();
   16016:	f002 f8e1 	bl	181dc <non_os_exit_critical>
    uart_helper_give_semaphore_or_panic(uart_rx_mutex[uart]);
   1601a:	5938      	ldr	r0, [r7, r4]
   1601c:	f7ff fac2 	bl	155a4 <uart_helper_give_semaphore_or_panic>
}
   16020:	bdf7      	pop	{r0, r1, r2, r4, r5, r6, r7, pc}
            flushed_data = *uart_data_register[uart];
   16022:	4b04      	ldr	r3, [pc, #16]	; (16034 <uart_unregister_rx_callback+0x9c>)
   16024:	591b      	ldr	r3, [r3, r4]
   16026:	681b      	ldr	r3, [r3, #0]
   16028:	e7f0      	b.n	1600c <uart_unregister_rx_callback+0x74>
   1602a:	46c0      	nop			; (mov r8, r8)
   1602c:	01002578 	.word	0x01002578
   16030:	0100256c 	.word	0x0100256c
   16034:	0100253c 	.word	0x0100253c

00016038 <uart_write>:
{
   16038:	b5f0      	push	{r4, r5, r6, r7, lr}
   1603a:	0006      	movs	r6, r0
   1603c:	b089      	sub	sp, #36	; 0x24
    assert( non_os_is_driver_initialised(DRIVER_INIT_UART) );
   1603e:	2008      	movs	r0, #8
   16040:	4674      	mov	r4, lr
{
   16042:	9103      	str	r1, [sp, #12]
   16044:	9205      	str	r2, [sp, #20]
   16046:	9302      	str	r3, [sp, #8]
    assert( non_os_is_driver_initialised(DRIVER_INIT_UART) );
   16048:	f002 f8dc 	bl	18204 <non_os_is_driver_initialised>
   1604c:	2800      	cmp	r0, #0
   1604e:	d103      	bne.n	16058 <uart_write+0x20>
   16050:	0021      	movs	r1, r4
   16052:	3016      	adds	r0, #22
   16054:	f7eb fd5c 	bl	1b10 <panic>
    assert( uart < UART_BUS_MAX_NUMBER );
   16058:	2e02      	cmp	r6, #2
   1605a:	d903      	bls.n	16064 <uart_write+0x2c>
   1605c:	0021      	movs	r1, r4
   1605e:	2016      	movs	r0, #22
   16060:	f7eb fd56 	bl	1b10 <panic>
    assert( uart_tx_state[uart] != NULL );
   16064:	4fac      	ldr	r7, [pc, #688]	; (16318 <uart_write+0x2e0>)
   16066:	00b5      	lsls	r5, r6, #2
   16068:	59eb      	ldr	r3, [r5, r7]
   1606a:	2b00      	cmp	r3, #0
   1606c:	d103      	bne.n	16076 <uart_write+0x3e>
   1606e:	0021      	movs	r1, r4
   16070:	2016      	movs	r0, #22
   16072:	f7eb fd4d 	bl	1b10 <panic>
    assert( buffer != NULL );
   16076:	9b03      	ldr	r3, [sp, #12]
   16078:	2b00      	cmp	r3, #0
   1607a:	d103      	bne.n	16084 <uart_write+0x4c>
   1607c:	0021      	movs	r1, r4
   1607e:	2016      	movs	r0, #22
   16080:	f7eb fd46 	bl	1b10 <panic>
    assert( uart_tx_mutex[uart] != NULL );
   16084:	4ba5      	ldr	r3, [pc, #660]	; (1631c <uart_write+0x2e4>)
   16086:	595b      	ldr	r3, [r3, r5]
   16088:	9301      	str	r3, [sp, #4]
   1608a:	2b00      	cmp	r3, #0
   1608c:	d103      	bne.n	16096 <uart_write+0x5e>
   1608e:	0021      	movs	r1, r4
   16090:	2016      	movs	r0, #22
   16092:	f7eb fd3d 	bl	1b10 <panic>
    if (uart_tx_dma_ch[uart] != DMA_CHANNEL_NONE)
   16096:	4ba2      	ldr	r3, [pc, #648]	; (16320 <uart_write+0x2e8>)
   16098:	5d9b      	ldrb	r3, [r3, r6]
   1609a:	2b04      	cmp	r3, #4
   1609c:	d047      	beq.n	1612e <uart_write+0xf6>
        assert(uart_tx_dma_ch[uart] < DMA_CHANNEL_MAX_NUM);
   1609e:	2b03      	cmp	r3, #3
   160a0:	d903      	bls.n	160aa <uart_write+0x72>
   160a2:	0021      	movs	r1, r4
   160a4:	2016      	movs	r0, #22
   160a6:	f7eb fd33 	bl	1b10 <panic>
        assert(params != NULL);
   160aa:	9b02      	ldr	r3, [sp, #8]
   160ac:	2b00      	cmp	r3, #0
   160ae:	d103      	bne.n	160b8 <uart_write+0x80>
   160b0:	0021      	movs	r1, r4
   160b2:	2016      	movs	r0, #22
   160b4:	f7eb fd2c 	bl	1b10 <panic>
        user_cfg.transfer_num = length;
   160b8:	466a      	mov	r2, sp
        user_cfg.addr = (uint32)buffer;
   160ba:	9b03      	ldr	r3, [sp, #12]
        user_cfg.transfer_num = length;
   160bc:	8a92      	ldrh	r2, [r2, #20]
        user_cfg.addr = (uint32)buffer;
   160be:	9306      	str	r3, [sp, #24]
        user_cfg.transfer_num = length;
   160c0:	ab06      	add	r3, sp, #24
   160c2:	809a      	strh	r2, [r3, #4]
        user_cfg.cycle_type = ((UART_WRITE_DMA_CONFIGURATION *)params)->cycle_type;
   160c4:	9b02      	ldr	r3, [sp, #8]
   160c6:	aa06      	add	r2, sp, #24
   160c8:	781b      	ldrb	r3, [r3, #0]
    uart_helper_take_semaphore_or_panic(uart_tx_mutex[uart], osWaitForever);
   160ca:	2101      	movs	r1, #1
        user_cfg.cycle_type = ((UART_WRITE_DMA_CONFIGURATION *)params)->cycle_type;
   160cc:	71d3      	strb	r3, [r2, #7]
        user_cfg.transfer_type = DMA_CH_TRANSFER_TYPE_MEM_TO_PERIPHERAL;
   160ce:	2301      	movs	r3, #1
   160d0:	7193      	strb	r3, [r2, #6]
        result = uart_write_by_dma(uart, &user_cfg, ((UART_WRITE_DMA_CONFIGURATION *)params)->done_callback);
   160d2:	9b02      	ldr	r3, [sp, #8]
    uart_helper_take_semaphore_or_panic(uart_tx_mutex[uart], osWaitForever);
   160d4:	4249      	negs	r1, r1
        result = uart_write_by_dma(uart, &user_cfg, ((UART_WRITE_DMA_CONFIGURATION *)params)->done_callback);
   160d6:	685b      	ldr	r3, [r3, #4]
   160d8:	9301      	str	r3, [sp, #4]
    uart_helper_take_semaphore_or_panic(uart_tx_mutex[uart], osWaitForever);
   160da:	4b90      	ldr	r3, [pc, #576]	; (1631c <uart_write+0x2e4>)
   160dc:	5958      	ldr	r0, [r3, r5]
   160de:	f7ff fa3b 	bl	15558 <uart_helper_take_semaphore_or_panic>
    ret = dma_transfer_peripheral_bytes(uart_tx_dma_ch[uart], user_dma_cfg, finished_with_transfer_func);
   160e2:	4f8f      	ldr	r7, [pc, #572]	; (16320 <uart_write+0x2e8>)
   160e4:	9a01      	ldr	r2, [sp, #4]
   160e6:	5db8      	ldrb	r0, [r7, r6]
   160e8:	a906      	add	r1, sp, #24
   160ea:	f000 fde5 	bl	16cb8 <dma_transfer_peripheral_bytes>
   160ee:	0004      	movs	r4, r0
    if (ret == DMA_RET_ONE_TIME_BATCHED_CONFIGS_EXCEEDED)
   160f0:	2808      	cmp	r0, #8
   160f2:	d108      	bne.n	16106 <uart_write+0xce>
        user_dma_cfg->cycle_type = DMA_CH_CYCLE_TYPE_BATCHED_END;
   160f4:	2302      	movs	r3, #2
   160f6:	aa06      	add	r2, sp, #24
   160f8:	71d3      	strb	r3, [r2, #7]
        ret = dma_transfer_peripheral_bytes(uart_tx_dma_ch[uart], user_dma_cfg, finished_with_transfer_func);
   160fa:	5db8      	ldrb	r0, [r7, r6]
   160fc:	9a01      	ldr	r2, [sp, #4]
   160fe:	a906      	add	r1, sp, #24
   16100:	f000 fdda 	bl	16cb8 <dma_transfer_peripheral_bytes>
   16104:	0004      	movs	r4, r0
    uart_helper_give_semaphore_or_panic(uart_tx_mutex[uart]);
   16106:	4b85      	ldr	r3, [pc, #532]	; (1631c <uart_write+0x2e4>)
   16108:	5958      	ldr	r0, [r3, r5]
   1610a:	f7ff fa4b 	bl	155a4 <uart_helper_give_semaphore_or_panic>
        return true;
   1610e:	2301      	movs	r3, #1
   16110:	9301      	str	r3, [sp, #4]
    if ((ret == DMA_RET_OK) || (ret == DMA_RET_INCOMPLETE_CONFIG))
   16112:	2c00      	cmp	r4, #0
   16114:	d004      	beq.n	16120 <uart_write+0xe8>
   16116:	3c07      	subs	r4, #7
   16118:	4266      	negs	r6, r4
   1611a:	4166      	adcs	r6, r4
   1611c:	b2f3      	uxtb	r3, r6
   1611e:	9301      	str	r3, [sp, #4]
        ((UART_WRITE_DMA_CONFIGURATION *)params)->cycle_type = user_cfg.cycle_type;
   16120:	ab06      	add	r3, sp, #24
   16122:	79db      	ldrb	r3, [r3, #7]
   16124:	9a02      	ldr	r2, [sp, #8]
   16126:	7013      	strb	r3, [r2, #0]
}
   16128:	9801      	ldr	r0, [sp, #4]
   1612a:	b009      	add	sp, #36	; 0x24
   1612c:	bdf0      	pop	{r4, r5, r6, r7, pc}
    uart_helper_take_semaphore_or_panic(uart_tx_mutex[uart], osWaitForever);
   1612e:	2101      	movs	r1, #1
   16130:	4b7a      	ldr	r3, [pc, #488]	; (1631c <uart_write+0x2e4>)
   16132:	4249      	negs	r1, r1
   16134:	5958      	ldr	r0, [r3, r5]
   16136:	f7ff fa0f 	bl	15558 <uart_helper_take_semaphore_or_panic>
    assert( non_os_is_driver_initialised(DRIVER_INIT_UART) );
   1613a:	2008      	movs	r0, #8
   1613c:	f002 f862 	bl	18204 <non_os_is_driver_initialised>
   16140:	2800      	cmp	r0, #0
   16142:	d103      	bne.n	1614c <uart_write+0x114>
   16144:	0021      	movs	r1, r4
   16146:	3016      	adds	r0, #22
   16148:	f7eb fce2 	bl	1b10 <panic>
    assert( uart < UART_BUS_MAX_NUMBER );
   1614c:	2e02      	cmp	r6, #2
   1614e:	d903      	bls.n	16158 <uart_write+0x120>
   16150:	0021      	movs	r1, r4
   16152:	2016      	movs	r0, #22
   16154:	f7eb fcdc 	bl	1b10 <panic>
    assert( uart_tx_state[uart] != NULL );
   16158:	00b3      	lsls	r3, r6, #2
   1615a:	9304      	str	r3, [sp, #16]
   1615c:	58fb      	ldr	r3, [r7, r3]
   1615e:	9301      	str	r3, [sp, #4]
   16160:	2b00      	cmp	r3, #0
   16162:	d103      	bne.n	1616c <uart_write+0x134>
   16164:	0021      	movs	r1, r4
   16166:	2016      	movs	r0, #22
   16168:	f7eb fcd2 	bl	1b10 <panic>
    non_os_enter_critical();
   1616c:	f002 f822 	bl	181b4 <non_os_enter_critical>
    fragment = uart_helper_tx_fragments_claim_next_available( uart );
   16170:	0030      	movs	r0, r6
   16172:	f7fe fde3 	bl	14d3c <uart_helper_tx_fragments_claim_next_available>
   16176:	0005      	movs	r5, r0
    non_os_exit_critical();
   16178:	f002 f830 	bl	181dc <non_os_exit_critical>
    if(fragment == NULL)
   1617c:	2d00      	cmp	r5, #0
   1617e:	d135      	bne.n	161ec <uart_write+0x1b4>
    assert( non_os_is_driver_initialised(DRIVER_INIT_UART) );
   16180:	2008      	movs	r0, #8
   16182:	f002 f83f 	bl	18204 <non_os_is_driver_initialised>
   16186:	2800      	cmp	r0, #0
   16188:	d103      	bne.n	16192 <uart_write+0x15a>
   1618a:	0021      	movs	r1, r4
   1618c:	3016      	adds	r0, #22
   1618e:	f7eb fcbf 	bl	1b10 <panic>
    assert( uart < UART_BUS_MAX_NUMBER );
   16192:	2e02      	cmp	r6, #2
   16194:	d903      	bls.n	1619e <uart_write+0x166>
   16196:	0021      	movs	r1, r4
   16198:	2016      	movs	r0, #22
   1619a:	f7eb fcb9 	bl	1b10 <panic>
    assert( uart_tx_state[uart] != NULL );
   1619e:	00b3      	lsls	r3, r6, #2
   161a0:	58fb      	ldr	r3, [r7, r3]
   161a2:	9301      	str	r3, [sp, #4]
   161a4:	2b00      	cmp	r3, #0
   161a6:	d103      	bne.n	161b0 <uart_write+0x178>
   161a8:	0021      	movs	r1, r4
   161aa:	2016      	movs	r0, #22
   161ac:	f7eb fcb0 	bl	1b10 <panic>
    assert( uart_tx_state[uart]->blocks_head != NULL);
   161b0:	00b3      	lsls	r3, r6, #2
   161b2:	58fb      	ldr	r3, [r7, r3]
   161b4:	68db      	ldr	r3, [r3, #12]
   161b6:	2b00      	cmp	r3, #0
   161b8:	d103      	bne.n	161c2 <uart_write+0x18a>
   161ba:	0021      	movs	r1, r4
   161bc:	2016      	movs	r0, #22
   161be:	f7eb fca7 	bl	1b10 <panic>
    block = irmalloc( sizeof( uart_tx_fragments_block ) );
   161c2:	4858      	ldr	r0, [pc, #352]	; (16324 <uart_write+0x2ec>)
   161c4:	f7fc fc1c 	bl	12a00 <irmalloc>
   161c8:	1e04      	subs	r4, r0, #0
    if (block != NULL)
   161ca:	d172      	bne.n	162b2 <uart_write+0x27a>
            panic(PANIC_UART, PANIC_UART_UNABLE_TO_ALLOCATE_MEMORY_FOR_UART);
   161cc:	2101      	movs	r1, #1
   161ce:	2007      	movs	r0, #7
   161d0:	f7eb fc9e 	bl	1b10 <panic>
        non_os_enter_critical();
   161d4:	f001 ffee 	bl	181b4 <non_os_enter_critical>
        fragment = uart_helper_tx_fragments_claim_next_available( uart );
   161d8:	0030      	movs	r0, r6
   161da:	f7fe fdaf 	bl	14d3c <uart_helper_tx_fragments_claim_next_available>
   161de:	0005      	movs	r5, r0
        non_os_exit_critical();
   161e0:	f001 fffc 	bl	181dc <non_os_exit_critical>
        return false;
   161e4:	2300      	movs	r3, #0
   161e6:	9301      	str	r3, [sp, #4]
    if (fragment != NULL)
   161e8:	429d      	cmp	r5, r3
   161ea:	d01c      	beq.n	16226 <uart_write+0x1ee>
        fragment->data = (uint8*) buffer;
   161ec:	9b03      	ldr	r3, [sp, #12]
   161ee:	602b      	str	r3, [r5, #0]
        fragment->params = params;
   161f0:	9b02      	ldr	r3, [sp, #8]
   161f2:	606b      	str	r3, [r5, #4]
        fragment->data_length = length;
   161f4:	466b      	mov	r3, sp
   161f6:	8a9b      	ldrh	r3, [r3, #20]
   161f8:	81ab      	strh	r3, [r5, #12]
        fragment->release_func = finished_with_buffer_func;
   161fa:	9b0e      	ldr	r3, [sp, #56]	; 0x38
   161fc:	60ab      	str	r3, [r5, #8]
        fragment->next = NULL;
   161fe:	2300      	movs	r3, #0
   16200:	612b      	str	r3, [r5, #16]
        non_os_enter_critical();
   16202:	f001 ffd7 	bl	181b4 <non_os_enter_critical>
        if( uart_tx_state[uart]->current_tx_fragment == NULL )
   16206:	00b2      	lsls	r2, r6, #2
   16208:	58bb      	ldr	r3, [r7, r2]
   1620a:	6819      	ldr	r1, [r3, #0]
   1620c:	2900      	cmp	r1, #0
   1620e:	d174      	bne.n	162fa <uart_write+0x2c2>
            uart_tx_state[uart]->current_tx_fragment = fragment;
   16210:	601d      	str	r5, [r3, #0]
            uart_tx_state[uart]->last_tx_fragment = fragment;
   16212:	58bb      	ldr	r3, [r7, r2]
            uart_tx_state[uart]->last_tx_fragment = fragment;
   16214:	605d      	str	r5, [r3, #4]
        uart_tx_state[uart]->fragments_to_process++;
   16216:	58ba      	ldr	r2, [r7, r2]
   16218:	8913      	ldrh	r3, [r2, #8]
   1621a:	3301      	adds	r3, #1
   1621c:	8113      	strh	r3, [r2, #8]
        non_os_exit_critical();
   1621e:	f001 ffdd 	bl	181dc <non_os_exit_critical>
    return true;
   16222:	2301      	movs	r3, #1
   16224:	9301      	str	r3, [sp, #4]
    uart_helper_give_semaphore_or_panic(uart_tx_mutex[uart]);
   16226:	4d3d      	ldr	r5, [pc, #244]	; (1631c <uart_write+0x2e4>)
   16228:	00b4      	lsls	r4, r6, #2
   1622a:	5960      	ldr	r0, [r4, r5]
   1622c:	f7ff f9ba 	bl	155a4 <uart_helper_give_semaphore_or_panic>
    if(fragment_added)
   16230:	9b01      	ldr	r3, [sp, #4]
   16232:	2b00      	cmp	r3, #0
   16234:	d008      	beq.n	16248 <uart_write+0x210>
        uart_ensure_sleep_vetoed();
   16236:	f7fe fdb5 	bl	14da4 <uart_ensure_sleep_vetoed>
        hal_uart_enable_interrupt(uart,HAL_UART_INTERRUPT_TX); // Enable TX Interrupts and continue there
   1623a:	0030      	movs	r0, r6
   1623c:	2101      	movs	r1, #1
   1623e:	f003 fbca 	bl	199d6 <hal_uart_enable_interrupt>
        hal_uart_force_tx_isr(uart);
   16242:	0030      	movs	r0, r6
   16244:	f003 fcd2 	bl	19bec <hal_uart_force_tx_isr>
    uart_helper_take_semaphore_or_panic(uart_tx_mutex[uart], osWaitForever);
   16248:	2101      	movs	r1, #1
   1624a:	9b04      	ldr	r3, [sp, #16]
   1624c:	4249      	negs	r1, r1
   1624e:	58e8      	ldr	r0, [r5, r3]
   16250:	f7ff f982 	bl	15558 <uart_helper_take_semaphore_or_panic>
    non_os_enter_critical();
   16254:	f001 ffae 	bl	181b4 <non_os_enter_critical>
    if ( uart_tx_state[uart]->blocks_in_use > UART_NUMBER_OF_FRAGMENTS_BLOCKS_TO_KEEP )
   16258:	9b04      	ldr	r3, [sp, #16]
    uart_tx_fragments_block * blocks_to_remove_head = NULL;
   1625a:	2500      	movs	r5, #0
    if ( uart_tx_state[uart]->blocks_in_use > UART_NUMBER_OF_FRAGMENTS_BLOCKS_TO_KEEP )
   1625c:	58ff      	ldr	r7, [r7, r3]
   1625e:	7c3b      	ldrb	r3, [r7, #16]
   16260:	2b04      	cmp	r3, #4
   16262:	d91d      	bls.n	162a0 <uart_write+0x268>
        while ( ( block_i->next != NULL ) && ( i < UART_NUMBER_OF_FRAGMENTS_BLOCKS_TO_KEEP -1 ) )
   16264:	4b30      	ldr	r3, [pc, #192]	; (16328 <uart_write+0x2f0>)
        block_i = uart_tx_state[uart]->blocks_head;
   16266:	2104      	movs	r1, #4
   16268:	0018      	movs	r0, r3
   1626a:	68fa      	ldr	r2, [r7, #12]
        while ( ( block_i->next != NULL ) && ( i < UART_NUMBER_OF_FRAGMENTS_BLOCKS_TO_KEEP -1 ) )
   1626c:	58d5      	ldr	r5, [r2, r3]
   1626e:	2d00      	cmp	r5, #0
   16270:	d016      	beq.n	162a0 <uart_write+0x268>
   16272:	3901      	subs	r1, #1
   16274:	b2c9      	uxtb	r1, r1
   16276:	2900      	cmp	r1, #0
   16278:	d142      	bne.n	16300 <uart_write+0x2c8>
   1627a:	002b      	movs	r3, r5
   1627c:	000d      	movs	r5, r1
            if ( block_next->fragments_in_use == 0 )
   1627e:	21a1      	movs	r1, #161	; 0xa1
   16280:	00c9      	lsls	r1, r1, #3
   16282:	468c      	mov	ip, r1
   16284:	4661      	mov	r1, ip
   16286:	5c59      	ldrb	r1, [r3, r1]
   16288:	2900      	cmp	r1, #0
   1628a:	d13b      	bne.n	16304 <uart_write+0x2cc>
                block_i->next = block_next->next;
   1628c:	5819      	ldr	r1, [r3, r0]
   1628e:	5011      	str	r1, [r2, r0]
                uart_tx_state[uart]->blocks_in_use--;
   16290:	7c39      	ldrb	r1, [r7, #16]
   16292:	3901      	subs	r1, #1
   16294:	7439      	strb	r1, [r7, #16]
                block_next->next = blocks_to_remove_head;
   16296:	501d      	str	r5, [r3, r0]
   16298:	001d      	movs	r5, r3
            block_next = block_i->next;
   1629a:	5813      	ldr	r3, [r2, r0]
        while ( block_next != NULL )
   1629c:	2b00      	cmp	r3, #0
   1629e:	d1f1      	bne.n	16284 <uart_write+0x24c>
    non_os_exit_critical();
   162a0:	f001 ff9c 	bl	181dc <non_os_exit_critical>
    while (blocks_to_remove_head != NULL)
   162a4:	2d00      	cmp	r5, #0
   162a6:	d12f      	bne.n	16308 <uart_write+0x2d0>
    uart_helper_give_semaphore_or_panic(uart_tx_mutex[uart]);
   162a8:	4b1c      	ldr	r3, [pc, #112]	; (1631c <uart_write+0x2e4>)
   162aa:	5918      	ldr	r0, [r3, r4]
   162ac:	f7ff f97a 	bl	155a4 <uart_helper_give_semaphore_or_panic>
    return uart_write_normal(uart, buffer, length, params, finished_with_buffer_func);
   162b0:	e73a      	b.n	16128 <uart_write+0xf0>
   162b2:	22a0      	movs	r2, #160	; 0xa0
   162b4:	0003      	movs	r3, r0
   162b6:	00d2      	lsls	r2, r2, #3
   162b8:	3314      	adds	r3, #20
   162ba:	1882      	adds	r2, r0, r2
        block->fragments[i].next = &(block->fragments[i+1]);
   162bc:	1f19      	subs	r1, r3, #4
   162be:	600b      	str	r3, [r1, #0]
   162c0:	3314      	adds	r3, #20
    for ( i = 0; i < UART_NUMBER_OF_FRAGMENTS_IN_BLOCK - 1; i++)
   162c2:	429a      	cmp	r2, r3
   162c4:	d1fa      	bne.n	162bc <uart_write+0x284>
    block->fragments[ UART_NUMBER_OF_FRAGMENTS_IN_BLOCK -1 ].next = NULL;
   162c6:	2300      	movs	r3, #0
   162c8:	4a18      	ldr	r2, [pc, #96]	; (1632c <uart_write+0x2f4>)
    block->next = NULL;
   162ca:	4d17      	ldr	r5, [pc, #92]	; (16328 <uart_write+0x2f0>)
    block->fragments[ UART_NUMBER_OF_FRAGMENTS_IN_BLOCK -1 ].next = NULL;
   162cc:	50a3      	str	r3, [r4, r2]
    block->next_free_fragment = &(block->fragments[0]);
   162ce:	3204      	adds	r2, #4
   162d0:	50a4      	str	r4, [r4, r2]
    block->fragments_in_use = 0;
   162d2:	3208      	adds	r2, #8
   162d4:	54a3      	strb	r3, [r4, r2]
    block->next = NULL;
   162d6:	5163      	str	r3, [r4, r5]
        non_os_enter_critical();
   162d8:	f001 ff6c 	bl	181b4 <non_os_enter_critical>
        block_old_tail = uart_tx_state[uart]->blocks_head;
   162dc:	9b04      	ldr	r3, [sp, #16]
   162de:	58fb      	ldr	r3, [r7, r3]
   162e0:	68da      	ldr	r2, [r3, #12]
        while ( block_old_tail->next != NULL )
   162e2:	5951      	ldr	r1, [r2, r5]
   162e4:	2900      	cmp	r1, #0
   162e6:	d106      	bne.n	162f6 <uart_write+0x2be>
        block_old_tail->next = block;
   162e8:	5154      	str	r4, [r2, r5]
        uart_tx_state[uart]->blocks_in_use++;
   162ea:	7c1a      	ldrb	r2, [r3, #16]
   162ec:	3201      	adds	r2, #1
   162ee:	741a      	strb	r2, [r3, #16]
        non_os_exit_critical();
   162f0:	f001 ff74 	bl	181dc <non_os_exit_critical>
   162f4:	e76e      	b.n	161d4 <uart_write+0x19c>
        while ( block_old_tail->next != NULL )
   162f6:	000a      	movs	r2, r1
   162f8:	e7f3      	b.n	162e2 <uart_write+0x2aa>
            (uart_tx_state[uart]->last_tx_fragment)->next = fragment;
   162fa:	6859      	ldr	r1, [r3, #4]
   162fc:	610d      	str	r5, [r1, #16]
   162fe:	e789      	b.n	16214 <uart_write+0x1dc>
        while ( ( block_i->next != NULL ) && ( i < UART_NUMBER_OF_FRAGMENTS_BLOCKS_TO_KEEP -1 ) )
   16300:	002a      	movs	r2, r5
   16302:	e7b3      	b.n	1626c <uart_write+0x234>
                block_i = block_i->next;
   16304:	5812      	ldr	r2, [r2, r0]
   16306:	e7c8      	b.n	1629a <uart_write+0x262>
        blocks_to_remove_head = blocks_to_remove_head->next;
   16308:	4b07      	ldr	r3, [pc, #28]	; (16328 <uart_write+0x2f0>)
        irfree( block_to_remove );
   1630a:	0028      	movs	r0, r5
        blocks_to_remove_head = blocks_to_remove_head->next;
   1630c:	58ef      	ldr	r7, [r5, r3]
        irfree( block_to_remove );
   1630e:	f7fc fb93 	bl	12a38 <irfree>
        blocks_to_remove_head = blocks_to_remove_head->next;
   16312:	003d      	movs	r5, r7
   16314:	e7c6      	b.n	162a4 <uart_write+0x26c>
   16316:	46c0      	nop			; (mov r8, r8)
   16318:	01002594 	.word	0x01002594
   1631c:	01002588 	.word	0x01002588
   16320:	010005cb 	.word	0x010005cb
   16324:	0000050c 	.word	0x0000050c
   16328:	00000504 	.word	0x00000504
   1632c:	000004fc 	.word	0x000004fc

00016330 <uart_write_immediately_char>:
{
   16330:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
   16332:	0004      	movs	r4, r0
    assert( non_os_is_driver_initialised(DRIVER_INIT_UART) );
   16334:	2008      	movs	r0, #8
   16336:	4675      	mov	r5, lr
{
   16338:	000f      	movs	r7, r1
    assert( non_os_is_driver_initialised(DRIVER_INIT_UART) );
   1633a:	f001 ff63 	bl	18204 <non_os_is_driver_initialised>
   1633e:	2800      	cmp	r0, #0
   16340:	d103      	bne.n	1634a <uart_write_immediately_char+0x1a>
   16342:	0029      	movs	r1, r5
   16344:	3016      	adds	r0, #22
   16346:	f7eb fbe3 	bl	1b10 <panic>
    assert( uart < UART_BUS_MAX_NUMBER );
   1634a:	2c02      	cmp	r4, #2
   1634c:	d903      	bls.n	16356 <uart_write_immediately_char+0x26>
   1634e:	0029      	movs	r1, r5
   16350:	2016      	movs	r0, #22
   16352:	f7eb fbdd 	bl	1b10 <panic>
    assert( uart_tx_state[uart] != NULL );
   16356:	4b0a      	ldr	r3, [pc, #40]	; (16380 <uart_write_immediately_char+0x50>)
   16358:	00a6      	lsls	r6, r4, #2
   1635a:	58f3      	ldr	r3, [r6, r3]
   1635c:	2b00      	cmp	r3, #0
   1635e:	d103      	bne.n	16368 <uart_write_immediately_char+0x38>
   16360:	0029      	movs	r1, r5
   16362:	2016      	movs	r0, #22
   16364:	f7eb fbd4 	bl	1b10 <panic>
    uart_ensure_sleep_vetoed();
   16368:	f7fe fd1c 	bl	14da4 <uart_ensure_sleep_vetoed>
        if (hal_uart_is_tx_fifo_full(uart) != true)
   1636c:	0020      	movs	r0, r4
   1636e:	f003 fc27 	bl	19bc0 <hal_uart_is_tx_fifo_full>
   16372:	2800      	cmp	r0, #0
   16374:	d1fa      	bne.n	1636c <uart_write_immediately_char+0x3c>
            *(uart_data_register[uart]) = (uint8)c;
   16376:	4b03      	ldr	r3, [pc, #12]	; (16384 <uart_write_immediately_char+0x54>)
   16378:	599b      	ldr	r3, [r3, r6]
   1637a:	601f      	str	r7, [r3, #0]
}
   1637c:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
   1637e:	46c0      	nop			; (mov r8, r8)
   16380:	01002594 	.word	0x01002594
   16384:	0100253c 	.word	0x0100253c

00016388 <uart_flush_data>:
{
   16388:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
   1638a:	0004      	movs	r4, r0
    assert( non_os_is_driver_initialised(DRIVER_INIT_UART) );
   1638c:	2008      	movs	r0, #8
   1638e:	4677      	mov	r7, lr
   16390:	f001 ff38 	bl	18204 <non_os_is_driver_initialised>
   16394:	2800      	cmp	r0, #0
   16396:	d103      	bne.n	163a0 <uart_flush_data+0x18>
   16398:	0039      	movs	r1, r7
   1639a:	3016      	adds	r0, #22
   1639c:	f7eb fbb8 	bl	1b10 <panic>
    assert( uart < UART_BUS_MAX_NUMBER );
   163a0:	2c02      	cmp	r4, #2
   163a2:	d903      	bls.n	163ac <uart_flush_data+0x24>
   163a4:	0039      	movs	r1, r7
   163a6:	2016      	movs	r0, #22
   163a8:	f7eb fbb2 	bl	1b10 <panic>
    assert( uart_rx_state[uart] != NULL );
   163ac:	4d11      	ldr	r5, [pc, #68]	; (163f4 <uart_flush_data+0x6c>)
   163ae:	00a6      	lsls	r6, r4, #2
   163b0:	5973      	ldr	r3, [r6, r5]
   163b2:	2b00      	cmp	r3, #0
   163b4:	d11b      	bne.n	163ee <uart_flush_data+0x66>
   163b6:	0039      	movs	r1, r7
   163b8:	2016      	movs	r0, #22
   163ba:	f7eb fba9 	bl	1b10 <panic>
    if( (uart >= UART_BUS_MAX_NUMBER) || (uart_rx_state[uart] == NULL) )
   163be:	2c02      	cmp	r4, #2
   163c0:	d902      	bls.n	163c8 <uart_flush_data+0x40>
        return 0;
   163c2:	2400      	movs	r4, #0
}
   163c4:	0020      	movs	r0, r4
   163c6:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    if( (uart >= UART_BUS_MAX_NUMBER) || (uart_rx_state[uart] == NULL) )
   163c8:	5973      	ldr	r3, [r6, r5]
   163ca:	2b00      	cmp	r3, #0
   163cc:	d0f9      	beq.n	163c2 <uart_flush_data+0x3a>
    non_os_enter_critical();
   163ce:	f001 fef1 	bl	181b4 <non_os_enter_critical>
    flushed_bytes = uart_helper_get_used_rx_buffer_space( uart );
   163d2:	0020      	movs	r0, r4
   163d4:	f7fe fcf6 	bl	14dc4 <uart_helper_get_used_rx_buffer_space>
    uart_rx_state[uart]->first_pos_to_send = 0;
   163d8:	2200      	movs	r2, #0
   163da:	59ab      	ldr	r3, [r5, r6]
    flushed_bytes = uart_helper_get_used_rx_buffer_space( uart );
   163dc:	0004      	movs	r4, r0
    uart_rx_state[uart]->first_pos_to_send = 0;
   163de:	829a      	strh	r2, [r3, #20]
    uart_rx_state[uart]->first_reserved_pos = 0;
   163e0:	82da      	strh	r2, [r3, #22]
    uart_rx_state[uart]->new_rx_pos = 0;
   163e2:	825a      	strh	r2, [r3, #18]
    uart_rx_state[uart]->rx_buffer_full = false;
   163e4:	761a      	strb	r2, [r3, #24]
    uart_rx_state[uart]->rx_buffer_unsent = false;
   163e6:	765a      	strb	r2, [r3, #25]
    non_os_exit_critical();
   163e8:	f001 fef8 	bl	181dc <non_os_exit_critical>
    return flushed_bytes;
   163ec:	e7ea      	b.n	163c4 <uart_flush_data+0x3c>
    if( (uart >= UART_BUS_MAX_NUMBER) || (uart_rx_state[uart] == NULL) )
   163ee:	2c02      	cmp	r4, #2
   163f0:	d8e7      	bhi.n	163c2 <uart_flush_data+0x3a>
   163f2:	e7ec      	b.n	163ce <uart_flush_data+0x46>
   163f4:	01002578 	.word	0x01002578

000163f8 <uart_get_data>:
{
   163f8:	b5f0      	push	{r4, r5, r6, r7, lr}
   163fa:	0006      	movs	r6, r0
   163fc:	b085      	sub	sp, #20
    assert( non_os_is_driver_initialised(DRIVER_INIT_UART) );
   163fe:	2008      	movs	r0, #8
   16400:	4674      	mov	r4, lr
{
   16402:	9100      	str	r1, [sp, #0]
   16404:	9202      	str	r2, [sp, #8]
   16406:	9301      	str	r3, [sp, #4]
    assert( non_os_is_driver_initialised(DRIVER_INIT_UART) );
   16408:	f001 fefc 	bl	18204 <non_os_is_driver_initialised>
   1640c:	2800      	cmp	r0, #0
   1640e:	d103      	bne.n	16418 <uart_get_data+0x20>
   16410:	0021      	movs	r1, r4
   16412:	3016      	adds	r0, #22
   16414:	f7eb fb7c 	bl	1b10 <panic>
    assert( uart < UART_BUS_MAX_NUMBER );
   16418:	2e02      	cmp	r6, #2
   1641a:	d903      	bls.n	16424 <uart_get_data+0x2c>
   1641c:	0021      	movs	r1, r4
   1641e:	2016      	movs	r0, #22
   16420:	f7eb fb76 	bl	1b10 <panic>
    assert( uart_rx_state[uart] != NULL );
   16424:	4f3f      	ldr	r7, [pc, #252]	; (16524 <uart_get_data+0x12c>)
   16426:	00b5      	lsls	r5, r6, #2
   16428:	59eb      	ldr	r3, [r5, r7]
   1642a:	2b00      	cmp	r3, #0
   1642c:	d103      	bne.n	16436 <uart_get_data+0x3e>
   1642e:	0021      	movs	r1, r4
   16430:	2016      	movs	r0, #22
   16432:	f7eb fb6d 	bl	1b10 <panic>
    assert( dest_buffer != NULL );
   16436:	9b00      	ldr	r3, [sp, #0]
   16438:	2b00      	cmp	r3, #0
   1643a:	d103      	bne.n	16444 <uart_get_data+0x4c>
   1643c:	0021      	movs	r1, r4
   1643e:	2016      	movs	r0, #22
   16440:	f7eb fb66 	bl	1b10 <panic>
    assert( errors != NULL );
   16444:	9b01      	ldr	r3, [sp, #4]
   16446:	2b00      	cmp	r3, #0
   16448:	d103      	bne.n	16452 <uart_get_data+0x5a>
   1644a:	0021      	movs	r1, r4
   1644c:	2016      	movs	r0, #22
   1644e:	f7eb fb5f 	bl	1b10 <panic>
    if( (uart >= UART_BUS_MAX_NUMBER) || (uart_rx_state[uart] == NULL) || (dest_buffer == NULL) || (dest_buffer_length == 0) || (errors == NULL) ) //lint !e774 !e845 always evaluates to false
   16452:	2e02      	cmp	r6, #2
   16454:	d862      	bhi.n	1651c <uart_get_data+0x124>
   16456:	597b      	ldr	r3, [r7, r5]
   16458:	2b00      	cmp	r3, #0
   1645a:	d05f      	beq.n	1651c <uart_get_data+0x124>
   1645c:	9b00      	ldr	r3, [sp, #0]
   1645e:	2b00      	cmp	r3, #0
   16460:	d05c      	beq.n	1651c <uart_get_data+0x124>
   16462:	9b02      	ldr	r3, [sp, #8]
   16464:	2b00      	cmp	r3, #0
   16466:	d059      	beq.n	1651c <uart_get_data+0x124>
   16468:	9b01      	ldr	r3, [sp, #4]
   1646a:	2b00      	cmp	r3, #0
   1646c:	d056      	beq.n	1651c <uart_get_data+0x124>
    uint16 available_data = uart_helper_get_used_rx_buffer_space( uart );
   1646e:	0030      	movs	r0, r6
   16470:	f7fe fca8 	bl	14dc4 <uart_helper_get_used_rx_buffer_space>
    if( available_data > 0 )
   16474:	2800      	cmp	r0, #0
   16476:	d051      	beq.n	1651c <uart_get_data+0x124>
   16478:	466b      	mov	r3, sp
   1647a:	9a02      	ldr	r2, [sp, #8]
   1647c:	891b      	ldrh	r3, [r3, #8]
   1647e:	4282      	cmp	r2, r0
   16480:	d900      	bls.n	16484 <uart_get_data+0x8c>
   16482:	1c03      	adds	r3, r0, #0
   16484:	b29b      	uxth	r3, r3
   16486:	001d      	movs	r5, r3
   16488:	9302      	str	r3, [sp, #8]
            non_os_enter_critical();
   1648a:	f001 fe93 	bl	181b4 <non_os_enter_critical>
            uint16 remaining_length = uart_rx_state[uart]->rx_buffer_size - uart_rx_state[uart]->first_reserved_pos;
   1648e:	4b25      	ldr	r3, [pc, #148]	; (16524 <uart_get_data+0x12c>)
   16490:	00b2      	lsls	r2, r6, #2
   16492:	58d3      	ldr	r3, [r2, r3]
   16494:	8ada      	ldrh	r2, [r3, #22]
   16496:	8819      	ldrh	r1, [r3, #0]
            uint8 *error_buffer = &uart_rx_state[uart]->error_buffer[uart_rx_state[uart]->first_reserved_pos];
   16498:	6a5c      	ldr	r4, [r3, #36]	; 0x24
            uint16 remaining_length = uart_rx_state[uart]->rx_buffer_size - uart_rx_state[uart]->first_reserved_pos;
   1649a:	1a89      	subs	r1, r1, r2
   1649c:	b28f      	uxth	r7, r1
            void *src_buffer = &uart_rx_state[uart]->data_buffer[uart_rx_state[uart]->first_reserved_pos];
   1649e:	6a19      	ldr	r1, [r3, #32]
            uint8 *error_buffer = &uart_rx_state[uart]->error_buffer[uart_rx_state[uart]->first_reserved_pos];
   164a0:	18a4      	adds	r4, r4, r2
            void *src_buffer = &uart_rx_state[uart]->data_buffer[uart_rx_state[uart]->first_reserved_pos];
   164a2:	1889      	adds	r1, r1, r2
   164a4:	9103      	str	r1, [sp, #12]
            non_os_exit_critical();
   164a6:	f001 fe99 	bl	181dc <non_os_exit_critical>
            if( remaining_length >= dest_buffer_length )
   164aa:	42af      	cmp	r7, r5
   164ac:	d318      	bcc.n	164e0 <uart_get_data+0xe8>
                memcpy( dest_buffer, src_buffer, dest_buffer_length );
   164ae:	002a      	movs	r2, r5
   164b0:	9903      	ldr	r1, [sp, #12]
   164b2:	9800      	ldr	r0, [sp, #0]
   164b4:	f7e9 fe9c 	bl	1f0 <memcpy>
    UART_ERROR errors = UART_ERROR_NONE;
   164b8:	2300      	movs	r3, #0
    uint8 *error_buffer_end = error_buffer + error_buffer_length;
   164ba:	1962      	adds	r2, r4, r5
    while( error_buffer < error_buffer_end )
   164bc:	42a2      	cmp	r2, r4
   164be:	d80b      	bhi.n	164d8 <uart_get_data+0xe0>
                *errors |= uart_get_errors( error_buffer, dest_buffer_length );   //lint !e655  UART_ERROR enum defined as bit fields
   164c0:	9a01      	ldr	r2, [sp, #4]
                uart_rx_buffer_release( uart, src_buffer, dest_buffer_length );
   164c2:	0029      	movs	r1, r5
                *errors |= uart_get_errors( error_buffer, dest_buffer_length );   //lint !e655  UART_ERROR enum defined as bit fields
   164c4:	7812      	ldrb	r2, [r2, #0]
                uart_rx_buffer_release( uart, src_buffer, dest_buffer_length );
   164c6:	0030      	movs	r0, r6
                *errors |= uart_get_errors( error_buffer, dest_buffer_length );   //lint !e655  UART_ERROR enum defined as bit fields
   164c8:	4313      	orrs	r3, r2
   164ca:	9a01      	ldr	r2, [sp, #4]
   164cc:	7013      	strb	r3, [r2, #0]
                uart_rx_buffer_release( uart, src_buffer, dest_buffer_length );
   164ce:	f7ff f88d 	bl	155ec <uart_rx_buffer_release.isra.9>
}
   164d2:	9802      	ldr	r0, [sp, #8]
   164d4:	b005      	add	sp, #20
   164d6:	bdf0      	pop	{r4, r5, r6, r7, pc}
        errors |= (UART_ERROR)*error_buffer++;   //lint !e655  UART_ERROR enum defined as bit fields
   164d8:	7821      	ldrb	r1, [r4, #0]
   164da:	3401      	adds	r4, #1
   164dc:	430b      	orrs	r3, r1
   164de:	e7ed      	b.n	164bc <uart_get_data+0xc4>
                memcpy( dest_buffer, src_buffer, remaining_length );
   164e0:	003a      	movs	r2, r7
   164e2:	9903      	ldr	r1, [sp, #12]
   164e4:	9800      	ldr	r0, [sp, #0]
   164e6:	f7e9 fe83 	bl	1f0 <memcpy>
    UART_ERROR errors = UART_ERROR_NONE;
   164ea:	2300      	movs	r3, #0
    uint8 *error_buffer_end = error_buffer + error_buffer_length;
   164ec:	19e2      	adds	r2, r4, r7
    while( error_buffer < error_buffer_end )
   164ee:	42a2      	cmp	r2, r4
   164f0:	d810      	bhi.n	16514 <uart_get_data+0x11c>
                *errors |= uart_get_errors( error_buffer, remaining_length );   //lint !e655  UART_ERROR enum defined as bit fields
   164f2:	9a01      	ldr	r2, [sp, #4]
                uart_rx_buffer_release( uart, src_buffer, remaining_length );
   164f4:	0039      	movs	r1, r7
                *errors |= uart_get_errors( error_buffer, remaining_length );   //lint !e655  UART_ERROR enum defined as bit fields
   164f6:	7812      	ldrb	r2, [r2, #0]
                uart_rx_buffer_release( uart, src_buffer, remaining_length );
   164f8:	0030      	movs	r0, r6
                *errors |= uart_get_errors( error_buffer, remaining_length );   //lint !e655  UART_ERROR enum defined as bit fields
   164fa:	4313      	orrs	r3, r2
   164fc:	9a01      	ldr	r2, [sp, #4]
                dest_buffer_length -= remaining_length;
   164fe:	1bed      	subs	r5, r5, r7
                *errors |= uart_get_errors( error_buffer, remaining_length );   //lint !e655  UART_ERROR enum defined as bit fields
   16500:	7013      	strb	r3, [r2, #0]
                uart_rx_buffer_release( uart, src_buffer, remaining_length );
   16502:	f7ff f873 	bl	155ec <uart_rx_buffer_release.isra.9>
                dest_buffer += remaining_length;
   16506:	9b00      	ldr	r3, [sp, #0]
                dest_buffer_length -= remaining_length;
   16508:	b2ad      	uxth	r5, r5
                dest_buffer += remaining_length;
   1650a:	19db      	adds	r3, r3, r7
   1650c:	9300      	str	r3, [sp, #0]
        while( dest_buffer_length > 0 )
   1650e:	2d00      	cmp	r5, #0
   16510:	d1bb      	bne.n	1648a <uart_get_data+0x92>
   16512:	e7de      	b.n	164d2 <uart_get_data+0xda>
        errors |= (UART_ERROR)*error_buffer++;   //lint !e655  UART_ERROR enum defined as bit fields
   16514:	7821      	ldrb	r1, [r4, #0]
   16516:	3401      	adds	r4, #1
   16518:	430b      	orrs	r3, r1
   1651a:	e7e8      	b.n	164ee <uart_get_data+0xf6>
        return 0;
   1651c:	2300      	movs	r3, #0
   1651e:	9302      	str	r3, [sp, #8]
   16520:	e7d7      	b.n	164d2 <uart_get_data+0xda>
   16522:	46c0      	nop			; (mov r8, r8)
   16524:	01002578 	.word	0x01002578

00016528 <aio_manager_get_status_table>:

// export the static status table
AIO_RESOURCES_STATUS *aio_manager_get_status_table(void)
{
    return aio_resources_status_table;
}
   16528:	4800      	ldr	r0, [pc, #0]	; (1652c <aio_manager_get_status_table+0x4>)
   1652a:	4770      	bx	lr
   1652c:	010025a0 	.word	0x010025a0

00016530 <aio_manager_get_deferred_mux_select_config>:

// export the static flag table
DEFERRED_MUX_SELECT_CONFIG *aio_manager_get_deferred_mux_select_config(void)
{
    return &deferred_mux_select_config;
}
   16530:	4800      	ldr	r0, [pc, #0]	; (16534 <aio_manager_get_deferred_mux_select_config+0x4>)
   16532:	4770      	bx	lr
   16534:	010025b7 	.word	0x010025b7

00016538 <temp_mon_set_coefficient>:
 */
TEMP_MON_RET temp_mon_set_coefficient(uint16 temperature_coefficient)
{
    TEMP_MON_RET ret_val = TEMP_MON_RET_ERROR;

    if ((temperature_coefficient >= TEMPERATURE_COEFFICIENT_MINIMUM) && (temperature_coefficient <= TEMPERATURE_COEFFICIENT_MAXIMUM))
   16538:	4b05      	ldr	r3, [pc, #20]	; (16550 <temp_mon_set_coefficient+0x18>)
   1653a:	4906      	ldr	r1, [pc, #24]	; (16554 <temp_mon_set_coefficient+0x1c>)
   1653c:	18c3      	adds	r3, r0, r3
   1653e:	b29b      	uxth	r3, r3
    TEMP_MON_RET ret_val = TEMP_MON_RET_ERROR;
   16540:	2201      	movs	r2, #1
    if ((temperature_coefficient >= TEMPERATURE_COEFFICIENT_MINIMUM) && (temperature_coefficient <= TEMPERATURE_COEFFICIENT_MAXIMUM))
   16542:	428b      	cmp	r3, r1
   16544:	d802      	bhi.n	1654c <temp_mon_set_coefficient+0x14>
    {
        temperature_coeff = temperature_coefficient;
        ret_val =  TEMP_MON_RET_OK;
   16546:	2200      	movs	r2, #0
        temperature_coeff = temperature_coefficient;
   16548:	4b03      	ldr	r3, [pc, #12]	; (16558 <temp_mon_set_coefficient+0x20>)
   1654a:	8018      	strh	r0, [r3, #0]
    }
    return ret_val;
}
   1654c:	0010      	movs	r0, r2
   1654e:	4770      	bx	lr
   16550:	ffffd7c4 	.word	0xffffd7c4
   16554:	000009c4 	.word	0x000009c4
   16558:	010005ce 	.word	0x010005ce

0001655c <dma_configs_adding_fsm_transit_batched_part>:
 * @param current_state configuraion adding FSM current state
 */
static void dma_configs_adding_fsm_transit_batched_part(HAL_DMA_CHANNEL ch, DMA_CH_CONFIGS_ADDING_STATE current_state)
{
    UNUSED(current_state);
    if (dma_config_controller[ch].configs_fsm.batched_configs_head == NULL)
   1655c:	2314      	movs	r3, #20
   1655e:	4343      	muls	r3, r0
   16560:	4804      	ldr	r0, [pc, #16]	; (16574 <dma_configs_adding_fsm_transit_batched_part+0x18>)
   16562:	18c0      	adds	r0, r0, r3
   16564:	6903      	ldr	r3, [r0, #16]
   16566:	2b00      	cmp	r3, #0
   16568:	d102      	bne.n	16570 <dma_configs_adding_fsm_transit_batched_part+0x14>
    {
        dma_config_controller[ch].configs_fsm.state = DMA_CH_CONFIGS_ADDING_STATE_BATCHED_START;
   1656a:	3301      	adds	r3, #1
        return;
    }
    dma_config_controller[ch].configs_fsm.state = DMA_CH_CONFIGS_ADDING_STATE_BATCHED_RUNNING;
   1656c:	7303      	strb	r3, [r0, #12]
}
   1656e:	4770      	bx	lr
    dma_config_controller[ch].configs_fsm.state = DMA_CH_CONFIGS_ADDING_STATE_BATCHED_RUNNING;
   16570:	2302      	movs	r3, #2
   16572:	e7fb      	b.n	1656c <dma_configs_adding_fsm_transit_batched_part+0x10>
   16574:	010025c4 	.word	0x010025c4

00016578 <dma_configs_adding_fsm_transit_batched_end>:
static void dma_configs_adding_fsm_transit_batched_end(HAL_DMA_CHANNEL ch, DMA_CH_CONFIGS_ADDING_STATE current_state)
{
    /* Any state can transit to BATCHED_COMPLETE state */
    UNUSED(current_state);
    //assert((current_state == DMA_CH_CONFIGS_ADDING_STATE_BATCHED_START) || (current_state == DMA_CH_CONFIGS_ADDING_STATE_BATCHED_RUNNING));
    if (dma_config_controller[ch].configs_fsm.batched_configs_head == NULL)
   16578:	2314      	movs	r3, #20
   1657a:	4343      	muls	r3, r0
   1657c:	4804      	ldr	r0, [pc, #16]	; (16590 <dma_configs_adding_fsm_transit_batched_end+0x18>)
   1657e:	18c0      	adds	r0, r0, r3
   16580:	6903      	ldr	r3, [r0, #16]
   16582:	2b00      	cmp	r3, #0
   16584:	d101      	bne.n	1658a <dma_configs_adding_fsm_transit_batched_end+0x12>
    {
        dma_config_controller[ch].configs_fsm.state = DMA_CH_CONFIGS_ADDING_STATE_SINGLE;
        return;
    }
    dma_config_controller[ch].configs_fsm.state = DMA_CH_CONFIGS_ADDING_STATE_BATCHED_COMPLETE;
   16586:	7303      	strb	r3, [r0, #12]
}
   16588:	4770      	bx	lr
    dma_config_controller[ch].configs_fsm.state = DMA_CH_CONFIGS_ADDING_STATE_BATCHED_COMPLETE;
   1658a:	2303      	movs	r3, #3
   1658c:	e7fb      	b.n	16586 <dma_configs_adding_fsm_transit_batched_end+0xe>
   1658e:	46c0      	nop			; (mov r8, r8)
   16590:	010025c4 	.word	0x010025c4

00016594 <dma_ch_config_peripheral_preprocess>:
 * @param ch DMA channel ID
 * @param cfg DMAC channel transfer configuration
 */
static void dma_ch_config_peripheral_preprocess(HAL_DMA_CHANNEL ch, hal_dma_ch_configuration *cfg)
{
    if (dma_config_controller[ch].periph_feature.use_burst)
   16594:	2314      	movs	r3, #20
{
   16596:	b510      	push	{r4, lr}
    if (dma_config_controller[ch].periph_feature.use_burst)
   16598:	4358      	muls	r0, r3
   1659a:	4b0b      	ldr	r3, [pc, #44]	; (165c8 <dma_ch_config_peripheral_preprocess+0x34>)
   1659c:	1818      	adds	r0, r3, r0
   1659e:	7943      	ldrb	r3, [r0, #5]
   165a0:	2b00      	cmp	r3, #0
   165a2:	d00f      	beq.n	165c4 <dma_ch_config_peripheral_preprocess+0x30>
    {
        uint16 r_power_transfers = HAL_DMA_R_POWER_TRANSFERS(cfg->r_power);
   165a4:	2301      	movs	r3, #1
   165a6:	7bca      	ldrb	r2, [r1, #15]
   165a8:	4093      	lsls	r3, r2

        if ((cfg->transfer_num > r_power_transfers) &&
   165aa:	898a      	ldrh	r2, [r1, #12]
   165ac:	b29c      	uxth	r4, r3
   165ae:	42a2      	cmp	r2, r4
   165b0:	d908      	bls.n	165c4 <dma_ch_config_peripheral_preprocess+0x30>
            ((cfg->transfer_num & (r_power_transfers - 1)) != 0))
   165b2:	0023      	movs	r3, r4
   165b4:	3b01      	subs	r3, #1
        if ((cfg->transfer_num > r_power_transfers) &&
   165b6:	421a      	tst	r2, r3
   165b8:	d004      	beq.n	165c4 <dma_ch_config_peripheral_preprocess+0x30>
        {
            cfg->cycle_type = HAL_DMA_CH_CYCLE_TYPE_SCATTER_GATHER_PERIPHERAL_ALT;
   165ba:	2307      	movs	r3, #7
   165bc:	738b      	strb	r3, [r1, #14]
            dma_config_controller[ch].configs_fsm.batched_configs_num++;
   165be:	7b83      	ldrb	r3, [r0, #14]
   165c0:	3301      	adds	r3, #1
   165c2:	7383      	strb	r3, [r0, #14]
        }
    }
}
   165c4:	bd10      	pop	{r4, pc}
   165c6:	46c0      	nop			; (mov r8, r8)
   165c8:	010025c4 	.word	0x010025c4

000165cc <dma_configs_adding_fsm_transit_single>:
{
   165cc:	b510      	push	{r4, lr}
   165ce:	0004      	movs	r4, r0
    assert((current_state == DMA_CH_CONFIGS_ADDING_STATE_SINGLE) || (current_state == DMA_CH_CONFIGS_ADDING_STATE_BATCHED_COMPLETE));
   165d0:	2900      	cmp	r1, #0
   165d2:	d005      	beq.n	165e0 <dma_configs_adding_fsm_transit_single+0x14>
   165d4:	2903      	cmp	r1, #3
   165d6:	d003      	beq.n	165e0 <dma_configs_adding_fsm_transit_single+0x14>
   165d8:	4671      	mov	r1, lr
   165da:	2016      	movs	r0, #22
   165dc:	f7eb fa98 	bl	1b10 <panic>
    dma_config_controller[ch].configs_fsm.state = DMA_CH_CONFIGS_ADDING_STATE_SINGLE;
   165e0:	2014      	movs	r0, #20
   165e2:	2300      	movs	r3, #0
   165e4:	4344      	muls	r4, r0
   165e6:	4802      	ldr	r0, [pc, #8]	; (165f0 <dma_configs_adding_fsm_transit_single+0x24>)
   165e8:	1900      	adds	r0, r0, r4
   165ea:	7303      	strb	r3, [r0, #12]
}
   165ec:	bd10      	pop	{r4, pc}
   165ee:	46c0      	nop			; (mov r8, r8)
   165f0:	010025c4 	.word	0x010025c4

000165f4 <dma_transfer>:
 * @param ch DMAC channel ID
 * @param cfg DMAC channel transfer configuration
 * @return OK if the operation succeeded or corresponding error code otherwise
 */
static DMA_RET dma_transfer(HAL_DMA_CHANNEL ch, hal_dma_ch_configuration *cfg)
{
   165f4:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
   165f6:	0005      	movs	r5, r0
    assert(non_os_is_driver_initialised(DRIVER_INIT_DMA));
   165f8:	200d      	movs	r0, #13
   165fa:	4677      	mov	r7, lr
{
   165fc:	000e      	movs	r6, r1
    assert(non_os_is_driver_initialised(DRIVER_INIT_DMA));
   165fe:	f001 fe01 	bl	18204 <non_os_is_driver_initialised>
   16602:	2800      	cmp	r0, #0
   16604:	d103      	bne.n	1660e <dma_transfer+0x1a>
   16606:	0039      	movs	r1, r7
   16608:	3016      	adds	r0, #22
   1660a:	f7eb fa81 	bl	1b10 <panic>
    assert(dma_config_controller[ch].error_times < DMA_CHANNEL_MAX_ERROR_TIMES);
   1660e:	2314      	movs	r3, #20
   16610:	436b      	muls	r3, r5
   16612:	4c09      	ldr	r4, [pc, #36]	; (16638 <dma_transfer+0x44>)
   16614:	5d1b      	ldrb	r3, [r3, r4]
   16616:	2b63      	cmp	r3, #99	; 0x63
   16618:	d903      	bls.n	16622 <dma_transfer+0x2e>
   1661a:	0039      	movs	r1, r7
   1661c:	2016      	movs	r0, #22
   1661e:	f7eb fa77 	bl	1b10 <panic>
     * |--------+----------------+---------------------------+---------------------------+----------------------+
     * | FINISH |                                                                                               |
     * | -ED    |               NOT             -           USED            -           STATE                   |
     * |--------+-----------------------------------------------------------------------------------------------+
     */
    ret = dma_configs_adding_fsm_handler_list[dma_config_controller[ch].configs_fsm.state](ch, cfg);
   16622:	2314      	movs	r3, #20
   16624:	436b      	muls	r3, r5
   16626:	18e4      	adds	r4, r4, r3
   16628:	7b23      	ldrb	r3, [r4, #12]
   1662a:	4a04      	ldr	r2, [pc, #16]	; (1663c <dma_transfer+0x48>)
   1662c:	009b      	lsls	r3, r3, #2
   1662e:	0031      	movs	r1, r6
   16630:	0028      	movs	r0, r5
   16632:	589b      	ldr	r3, [r3, r2]
   16634:	4798      	blx	r3
    return ret;
}
   16636:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
   16638:	010025c4 	.word	0x010025c4
   1663c:	00025548 	.word	0x00025548

00016640 <dma_release_mutexes>:
}

/** Release the DMA module mutexes
 */
static void dma_release_mutexes(void)
{
   16640:	b510      	push	{r4, lr}
    dma_helper_give_mutex_or_panic(dmac_mutex);
   16642:	4b05      	ldr	r3, [pc, #20]	; (16658 <dma_release_mutexes+0x18>)
    if (osMutexRelease(mutex) != osOK) //lint !e455 mutex is taked in dma_helper_take_mutex_or_panic
   16644:	6818      	ldr	r0, [r3, #0]
   16646:	f7fe f9d1 	bl	149ec <osMutexRelease>
   1664a:	2800      	cmp	r0, #0
   1664c:	d003      	beq.n	16656 <dma_release_mutexes+0x16>
        panic(PANIC_DMA, PANIC_DMA_UNABLE_TO_GIVE_MUTEX);
   1664e:	2102      	movs	r1, #2
   16650:	2023      	movs	r0, #35	; 0x23
   16652:	f7eb fa5d 	bl	1b10 <panic>
}
   16656:	bd10      	pop	{r4, pc}
   16658:	01002624 	.word	0x01002624

0001665c <dma_ch_remove_any_sleep_veto>:

/** Remove any sleep veto of the specific channel
 * @param ch DMAC channel ID
 */
static void dma_ch_remove_any_sleep_veto(HAL_DMA_CHANNEL ch)
{
   1665c:	b510      	push	{r4, lr}
   1665e:	0004      	movs	r4, r0
    non_os_enter_critical();
   16660:	f001 fda8 	bl	181b4 <non_os_enter_critical>

    if (dma_ch_sleep_veto[ch])
   16664:	4b05      	ldr	r3, [pc, #20]	; (1667c <dma_ch_remove_any_sleep_veto+0x20>)
   16666:	5d1a      	ldrb	r2, [r3, r4]
   16668:	2a00      	cmp	r2, #0
   1666a:	d003      	beq.n	16674 <dma_ch_remove_any_sleep_veto+0x18>
    {
        dma_ch_sleep_veto[ch] = false;
   1666c:	2200      	movs	r2, #0
   1666e:	551a      	strb	r2, [r3, r4]
        osRemoveStopClocksVeto();
   16670:	f7fe facc 	bl	14c0c <osRemoveStopClocksVeto>
    }

    non_os_exit_critical();
   16674:	f001 fdb2 	bl	181dc <non_os_exit_critical>
}
   16678:	bd10      	pop	{r4, pc}
   1667a:	46c0      	nop			; (mov r8, r8)
   1667c:	010025bd 	.word	0x010025bd

00016680 <dma_ch_open_set_peripheral_feature>:
{
   16680:	b537      	push	{r0, r1, r2, r4, r5, lr}
    assert((((uint8 *)feature)[0] <= (uint8)DMA_POWER_OF_BURST_10) && (((uint8 *)feature)[1] <= (uint8)true)); //lint !e685 I exactly want to validate the arguments
   16682:	780a      	ldrb	r2, [r1, #0]
   16684:	4673      	mov	r3, lr
{
   16686:	0005      	movs	r5, r0
   16688:	000c      	movs	r4, r1
    assert((((uint8 *)feature)[0] <= (uint8)DMA_POWER_OF_BURST_10) && (((uint8 *)feature)[1] <= (uint8)true)); //lint !e685 I exactly want to validate the arguments
   1668a:	2a0a      	cmp	r2, #10
   1668c:	d802      	bhi.n	16694 <dma_ch_open_set_peripheral_feature+0x14>
   1668e:	784a      	ldrb	r2, [r1, #1]
   16690:	2a01      	cmp	r2, #1
   16692:	d903      	bls.n	1669c <dma_ch_open_set_peripheral_feature+0x1c>
   16694:	0019      	movs	r1, r3
   16696:	2016      	movs	r0, #22
   16698:	f7eb fa3a 	bl	1b10 <panic>
    memcpy(&(dma_config_controller[ch].periph_feature), feature, sizeof(*feature));
   1669c:	2014      	movs	r0, #20
   1669e:	4368      	muls	r0, r5
   166a0:	4b06      	ldr	r3, [pc, #24]	; (166bc <dma_ch_open_set_peripheral_feature+0x3c>)
   166a2:	3004      	adds	r0, #4
   166a4:	2208      	movs	r2, #8
   166a6:	0021      	movs	r1, r4
   166a8:	1818      	adds	r0, r3, r0
   166aa:	f7e9 fda1 	bl	1f0 <memcpy>
    hal_feature.use_burst = feature->use_burst;
   166ae:	7863      	ldrb	r3, [r4, #1]
   166b0:	a901      	add	r1, sp, #4
    hal_dma_ch_configure_peripheral_feature((HAL_DMA_CHANNEL)ch, &hal_feature);
   166b2:	0028      	movs	r0, r5
    hal_feature.use_burst = feature->use_burst;
   166b4:	700b      	strb	r3, [r1, #0]
    hal_dma_ch_configure_peripheral_feature((HAL_DMA_CHANNEL)ch, &hal_feature);
   166b6:	f002 fc5d 	bl	18f74 <hal_dma_ch_configure_peripheral_feature>
}
   166ba:	bd37      	pop	{r0, r1, r2, r4, r5, pc}
   166bc:	010025c4 	.word	0x010025c4

000166c0 <dma_fill_driver_ch_config>:
{
   166c0:	b5f0      	push	{r4, r5, r6, r7, lr}
   166c2:	b087      	sub	sp, #28
   166c4:	9305      	str	r3, [sp, #20]
    return cycle_type_maps[user_cycle_type][transfer_type];
   166c6:	2303      	movs	r3, #3
{
   166c8:	0015      	movs	r5, r2
    DMA_CH_CONFIGS_ADDING_STATE state          = dma_config_controller[ch].configs_fsm.state;
   166ca:	2714      	movs	r7, #20
{
   166cc:	9104      	str	r1, [sp, #16]
    return cycle_type_maps[user_cycle_type][transfer_type];
   166ce:	7b92      	ldrb	r2, [r2, #14]
   166d0:	7829      	ldrb	r1, [r5, #0]
   166d2:	435a      	muls	r2, r3
   166d4:	4b29      	ldr	r3, [pc, #164]	; (1677c <dma_fill_driver_ch_config+0xbc>)
    DMA_CH_CONFIGS_ADDING_STATE state          = dma_config_controller[ch].configs_fsm.state;
   166d6:	4347      	muls	r7, r0
    return cycle_type_maps[user_cycle_type][transfer_type];
   166d8:	189b      	adds	r3, r3, r2
   166da:	5c5b      	ldrb	r3, [r3, r1]
    alloc_drv_cfg = hal_dma_ch_config_buffer_get_free_config(ch, 0);
   166dc:	2100      	movs	r1, #0
    return cycle_type_maps[user_cycle_type][transfer_type];
   166de:	9303      	str	r3, [sp, #12]
    DMA_CH_CONFIGS_ADDING_STATE state          = dma_config_controller[ch].configs_fsm.state;
   166e0:	4b27      	ldr	r3, [pc, #156]	; (16780 <dma_fill_driver_ch_config+0xc0>)
{
   166e2:	0006      	movs	r6, r0
    DMA_CH_CONFIGS_ADDING_STATE state          = dma_config_controller[ch].configs_fsm.state;
   166e4:	19df      	adds	r7, r3, r7
   166e6:	7b3b      	ldrb	r3, [r7, #12]
   166e8:	9302      	str	r3, [sp, #8]
    HAL_DMA_DATA_WIDTH          data_width     = user_common_config->data_width;
   166ea:	786b      	ldrb	r3, [r5, #1]
   166ec:	9301      	str	r3, [sp, #4]
    alloc_drv_cfg = hal_dma_ch_config_buffer_get_free_config(ch, 0);
   166ee:	f002 fca7 	bl	19040 <hal_dma_ch_config_buffer_get_free_config>
        return DMA_RET_CONFIG_QUEUE_FULL;
   166f2:	2309      	movs	r3, #9
    alloc_drv_cfg = hal_dma_ch_config_buffer_get_free_config(ch, 0);
   166f4:	1e04      	subs	r4, r0, #0
    if (alloc_drv_cfg == NULL)
   166f6:	d03e      	beq.n	16776 <dma_fill_driver_ch_config+0xb6>
    if ((perip_addr == 0) && (user_common_config->transfer_type != DMA_CH_TRANSFER_TYPE_MEM_TO_MEM))
   166f8:	68bb      	ldr	r3, [r7, #8]
   166fa:	2b00      	cmp	r3, #0
   166fc:	d106      	bne.n	1670c <dma_fill_driver_ch_config+0x4c>
   166fe:	782b      	ldrb	r3, [r5, #0]
   16700:	2b00      	cmp	r3, #0
   16702:	d003      	beq.n	1670c <dma_fill_driver_ch_config+0x4c>
        panic(PANIC_DMA, PANIC_DMA_PERIPHERAL_WAITING_FOR_FINISH);
   16704:	2105      	movs	r1, #5
   16706:	2023      	movs	r0, #35	; 0x23
   16708:	f7eb fa02 	bl	1b10 <panic>
    alloc_drv_cfg->ready = false;
   1670c:	2700      	movs	r7, #0
   1670e:	7467      	strb	r7, [r4, #17]
    alloc_drv_cfg->scatter_gather_configs = 0;
   16710:	7427      	strb	r7, [r4, #16]
    alloc_drv_cfg->src = user_common_config->src;
   16712:	686b      	ldr	r3, [r5, #4]
    alloc_drv_cfg->src_inc = dma_src_addr_inc_map[user_common_config->transfer_type][data_width];
   16714:	4a1b      	ldr	r2, [pc, #108]	; (16784 <dma_fill_driver_ch_config+0xc4>)
    alloc_drv_cfg->src = user_common_config->src;
   16716:	6023      	str	r3, [r4, #0]
    alloc_drv_cfg->dst = user_common_config->dst;
   16718:	68ab      	ldr	r3, [r5, #8]
    if (!hal_dma_check_ch_transfer_config(alloc_drv_cfg))
   1671a:	0020      	movs	r0, r4
    alloc_drv_cfg->dst = user_common_config->dst;
   1671c:	6063      	str	r3, [r4, #4]
    alloc_drv_cfg->transfer_num = user_common_config->transfer_num;
   1671e:	89ab      	ldrh	r3, [r5, #12]
   16720:	81a3      	strh	r3, [r4, #12]
    alloc_drv_cfg->cycle_type = drv_cycle_type;
   16722:	466b      	mov	r3, sp
   16724:	7b1b      	ldrb	r3, [r3, #12]
   16726:	73a3      	strb	r3, [r4, #14]
    alloc_drv_cfg->data_width = data_width;
   16728:	466b      	mov	r3, sp
   1672a:	791b      	ldrb	r3, [r3, #4]
   1672c:	7223      	strb	r3, [r4, #8]
    alloc_drv_cfg->src_inc = dma_src_addr_inc_map[user_common_config->transfer_type][data_width];
   1672e:	2303      	movs	r3, #3
   16730:	7829      	ldrb	r1, [r5, #0]
   16732:	4359      	muls	r1, r3
   16734:	1852      	adds	r2, r2, r1
   16736:	9901      	ldr	r1, [sp, #4]
   16738:	5c52      	ldrb	r2, [r2, r1]
   1673a:	7262      	strb	r2, [r4, #9]
    alloc_drv_cfg->dst_inc = dma_dst_addr_inc_map[user_common_config->transfer_type][data_width];
   1673c:	782a      	ldrb	r2, [r5, #0]
   1673e:	4353      	muls	r3, r2
   16740:	4a11      	ldr	r2, [pc, #68]	; (16788 <dma_fill_driver_ch_config+0xc8>)
   16742:	18d3      	adds	r3, r2, r3
   16744:	5c5b      	ldrb	r3, [r3, r1]
   16746:	72a3      	strb	r3, [r4, #10]
    alloc_drv_cfg->callback = (hal_dma_transfer_callback)callback;
   16748:	9b05      	ldr	r3, [sp, #20]
   1674a:	6163      	str	r3, [r4, #20]
    if (!hal_dma_check_ch_transfer_config(alloc_drv_cfg))
   1674c:	f002 fd26 	bl	1919c <hal_dma_check_ch_transfer_config>
        return DMA_RET_NOT_SUPPORTED_CONFIG;
   16750:	2305      	movs	r3, #5
    if (!hal_dma_check_ch_transfer_config(alloc_drv_cfg))
   16752:	42b8      	cmp	r0, r7
   16754:	d00f      	beq.n	16776 <dma_fill_driver_ch_config+0xb6>
    dma_config_controller[ch].configs_fsm.transfer_type = user_common_config->transfer_type;
   16756:	2214      	movs	r2, #20
    *driver_config = alloc_drv_cfg;
   16758:	9b04      	ldr	r3, [sp, #16]
    dma_config_controller[ch].configs_fsm.transfer_type = user_common_config->transfer_type;
   1675a:	4372      	muls	r2, r6
    *driver_config = alloc_drv_cfg;
   1675c:	601c      	str	r4, [r3, #0]
    dma_config_controller[ch].configs_fsm.transfer_type = user_common_config->transfer_type;
   1675e:	4b08      	ldr	r3, [pc, #32]	; (16780 <dma_fill_driver_ch_config+0xc0>)
   16760:	7829      	ldrb	r1, [r5, #0]
   16762:	189b      	adds	r3, r3, r2
   16764:	7359      	strb	r1, [r3, #13]
    dma_configs_adding_fsm_transit[user_common_config->cycle_type](ch, state);
   16766:	7bab      	ldrb	r3, [r5, #14]
   16768:	4a08      	ldr	r2, [pc, #32]	; (1678c <dma_fill_driver_ch_config+0xcc>)
   1676a:	009b      	lsls	r3, r3, #2
   1676c:	589b      	ldr	r3, [r3, r2]
   1676e:	9902      	ldr	r1, [sp, #8]
   16770:	0030      	movs	r0, r6
   16772:	4798      	blx	r3
    return DMA_RET_OK;
   16774:	003b      	movs	r3, r7
}
   16776:	0018      	movs	r0, r3
   16778:	b007      	add	sp, #28
   1677a:	bdf0      	pop	{r4, r5, r6, r7, pc}
   1677c:	0002553a 	.word	0x0002553a
   16780:	010025c4 	.word	0x010025c4
   16784:	0002556d 	.word	0x0002556d
   16788:	00025564 	.word	0x00025564
   1678c:	00025558 	.word	0x00025558

00016790 <dma_configs_adding_fsm_batched_running>:
{
   16790:	b570      	push	{r4, r5, r6, lr}
    uint8 saved_batched_configs_num = dma_config_controller[ch].configs_fsm.batched_configs_num;
   16792:	2414      	movs	r4, #20
   16794:	4344      	muls	r4, r0
   16796:	4b0a      	ldr	r3, [pc, #40]	; (167c0 <dma_configs_adding_fsm_batched_running+0x30>)
{
   16798:	0005      	movs	r5, r0
    uint8 saved_batched_configs_num = dma_config_controller[ch].configs_fsm.batched_configs_num;
   1679a:	191c      	adds	r4, r3, r4
   1679c:	7ba6      	ldrb	r6, [r4, #14]
    dma_ch_config_peripheral_preprocess(ch, cfg);
   1679e:	f7ff fef9 	bl	16594 <dma_ch_config_peripheral_preprocess>
    if (dma_config_controller[ch].configs_fsm.batched_configs_num > DMA_MAX_SUPPORTED_BATCHED_CONFIGS_BEFORE_END - 1)
   167a2:	7ba3      	ldrb	r3, [r4, #14]
   167a4:	2b06      	cmp	r3, #6
   167a6:	d902      	bls.n	167ae <dma_configs_adding_fsm_batched_running+0x1e>
        return DMA_RET_ONE_TIME_BATCHED_CONFIGS_EXCEEDED;
   167a8:	2008      	movs	r0, #8
        dma_config_controller[ch].configs_fsm.batched_configs_num = saved_batched_configs_num;
   167aa:	73a6      	strb	r6, [r4, #14]
}
   167ac:	bd70      	pop	{r4, r5, r6, pc}
    hal_dma_ch_config_buffer_add_config(ch);
   167ae:	0028      	movs	r0, r5
   167b0:	f002 fcaa 	bl	19108 <hal_dma_ch_config_buffer_add_config>
    dma_config_controller[ch].configs_fsm.batched_configs_num++;
   167b4:	7ba3      	ldrb	r3, [r4, #14]
    return DMA_RET_INCOMPLETE_CONFIG;
   167b6:	2007      	movs	r0, #7
    dma_config_controller[ch].configs_fsm.batched_configs_num++;
   167b8:	3301      	adds	r3, #1
   167ba:	73a3      	strb	r3, [r4, #14]
    return DMA_RET_INCOMPLETE_CONFIG;
   167bc:	e7f6      	b.n	167ac <dma_configs_adding_fsm_batched_running+0x1c>
   167be:	46c0      	nop			; (mov r8, r8)
   167c0:	010025c4 	.word	0x010025c4

000167c4 <dma_configs_adding_fsm_batched_complete>:
{
   167c4:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
    hal_dma_ch_configuration *batched_configs_head = dma_config_controller[ch].configs_fsm.batched_configs_head;
   167c6:	2614      	movs	r6, #20
   167c8:	4346      	muls	r6, r0
   167ca:	4b39      	ldr	r3, [pc, #228]	; (168b0 <dma_configs_adding_fsm_batched_complete+0xec>)
{
   167cc:	0004      	movs	r4, r0
    hal_dma_ch_configuration *batched_configs_head = dma_config_controller[ch].configs_fsm.batched_configs_head;
   167ce:	199e      	adds	r6, r3, r6
   167d0:	6933      	ldr	r3, [r6, #16]
{
   167d2:	000d      	movs	r5, r1
    hal_dma_ch_configuration *batched_configs_head = dma_config_controller[ch].configs_fsm.batched_configs_head;
   167d4:	9300      	str	r3, [sp, #0]
    if (dma_config_controller[ch].configs_fsm.transfer_type != DMA_CH_TRANSFER_TYPE_MEM_TO_MEM)
   167d6:	7b73      	ldrb	r3, [r6, #13]
   167d8:	2b00      	cmp	r3, #0
   167da:	d01e      	beq.n	1681a <dma_configs_adding_fsm_batched_complete+0x56>
        dma_ch_config_peripheral_preprocess(ch, cfg);
   167dc:	f7ff feda 	bl	16594 <dma_ch_config_peripheral_preprocess>
    hal_dma_ch_config_buffer_add_config(ch);
   167e0:	0020      	movs	r0, r4
   167e2:	f002 fc91 	bl	19108 <hal_dma_ch_config_buffer_add_config>
    dma_config_controller[ch].configs_fsm.batched_configs_num++;
   167e6:	2314      	movs	r3, #20
    dma_config_controller[ch].configs_fsm.batched_configs_num = 0;
   167e8:	2500      	movs	r5, #0
    dma_config_controller[ch].configs_fsm.batched_configs_num++;
   167ea:	4363      	muls	r3, r4
   167ec:	4a30      	ldr	r2, [pc, #192]	; (168b0 <dma_configs_adding_fsm_batched_complete+0xec>)
    batched_configs_head->scatter_gather_configs = dma_config_controller[ch].configs_fsm.batched_configs_num;
   167ee:	9900      	ldr	r1, [sp, #0]
    dma_config_controller[ch].configs_fsm.batched_configs_num++;
   167f0:	18d3      	adds	r3, r2, r3
   167f2:	7b9a      	ldrb	r2, [r3, #14]
   167f4:	3201      	adds	r2, #1
    batched_configs_head->scatter_gather_configs = dma_config_controller[ch].configs_fsm.batched_configs_num;
   167f6:	740a      	strb	r2, [r1, #16]
    dma_config_controller[ch].configs_fsm.batched_configs_num = 0;
   167f8:	739d      	strb	r5, [r3, #14]
    dma_config_controller[ch].configs_fsm.batched_configs_head = NULL;
   167fa:	611d      	str	r5, [r3, #16]
    non_os_enter_critical();
   167fc:	f001 fcda 	bl	181b4 <non_os_enter_critical>
    if (hal_dma_ch_state_get(ch) != HAL_DMA_CH_STATE_IDLE)
   16800:	0020      	movs	r0, r4
   16802:	f002 fbe1 	bl	18fc8 <hal_dma_ch_state_get>
   16806:	0006      	movs	r6, r0
   16808:	2801      	cmp	r0, #1
   1680a:	d03c      	beq.n	16886 <dma_configs_adding_fsm_batched_complete+0xc2>
        batched_configs_head->ready = true;
   1680c:	2301      	movs	r3, #1
   1680e:	9a00      	ldr	r2, [sp, #0]
   16810:	7453      	strb	r3, [r2, #17]
        non_os_exit_critical();
   16812:	f001 fce3 	bl	181dc <non_os_exit_critical>
    return ret;
   16816:	2000      	movs	r0, #0
   16818:	e010      	b.n	1683c <dma_configs_adding_fsm_batched_complete+0x78>
        uint16 r_power_num = HAL_DMA_R_POWER_TRANSFERS(cfg->r_power);
   1681a:	7bcb      	ldrb	r3, [r1, #15]
   1681c:	2101      	movs	r1, #1
   1681e:	000a      	movs	r2, r1
   16820:	409a      	lsls	r2, r3
   16822:	b293      	uxth	r3, r2
   16824:	9301      	str	r3, [sp, #4]
        if (cfg->transfer_num > r_power_num)
   16826:	89ab      	ldrh	r3, [r5, #12]
   16828:	9a01      	ldr	r2, [sp, #4]
   1682a:	4293      	cmp	r3, r2
   1682c:	d9d8      	bls.n	167e0 <dma_configs_adding_fsm_batched_complete+0x1c>
            hal_dma_ch_configuration *end_cfg = hal_dma_ch_config_buffer_get_free_config(ch, 1);
   1682e:	f002 fc07 	bl	19040 <hal_dma_ch_config_buffer_get_free_config>
   16832:	1e07      	subs	r7, r0, #0
            if (end_cfg == NULL)
   16834:	d103      	bne.n	1683e <dma_configs_adding_fsm_batched_complete+0x7a>
                dma_config_controller[ch].configs_fsm.state = DMA_CH_CONFIGS_ADDING_STATE_BATCHED_RUNNING;
   16836:	2302      	movs	r3, #2
                return DMA_RET_CONFIG_QUEUE_FULL;
   16838:	2009      	movs	r0, #9
                dma_config_controller[ch].configs_fsm.state = DMA_CH_CONFIGS_ADDING_STATE_BATCHED_RUNNING;
   1683a:	7333      	strb	r3, [r6, #12]
}
   1683c:	bdfe      	pop	{r1, r2, r3, r4, r5, r6, r7, pc}
            hal_dma_ch_config_buffer_add_config(ch);
   1683e:	0020      	movs	r0, r4
   16840:	f002 fc62 	bl	19108 <hal_dma_ch_config_buffer_add_config>
            dma_config_controller[ch].configs_fsm.batched_configs_num++;
   16844:	7bb3      	ldrb	r3, [r6, #14]
            memcpy(end_cfg, cfg, sizeof(*cfg));
   16846:	2218      	movs	r2, #24
            dma_config_controller[ch].configs_fsm.batched_configs_num++;
   16848:	3301      	adds	r3, #1
   1684a:	73b3      	strb	r3, [r6, #14]
            memcpy(end_cfg, cfg, sizeof(*cfg));
   1684c:	0029      	movs	r1, r5
   1684e:	0038      	movs	r0, r7
   16850:	f7e9 fcce 	bl	1f0 <memcpy>
            cfg->transfer_num -= r_power_num;
   16854:	89ab      	ldrh	r3, [r5, #12]
   16856:	9a01      	ldr	r2, [sp, #4]
   16858:	1a9b      	subs	r3, r3, r2
   1685a:	81ab      	strh	r3, [r5, #12]
            cfg->cycle_type = HAL_DMA_CH_CYCLE_TYPE_SCATTER_GATHER_MEM_ALT;
   1685c:	2305      	movs	r3, #5
   1685e:	73ab      	strb	r3, [r5, #14]
            end_cfg->transfer_num = r_power_num;
   16860:	466b      	mov	r3, sp
   16862:	889b      	ldrh	r3, [r3, #4]
            end_cfg->src += (uint32)cfg->transfer_num << dma_addr_inc_shift[cfg->src_inc];
   16864:	4a13      	ldr	r2, [pc, #76]	; (168b4 <dma_configs_adding_fsm_batched_complete+0xf0>)
            end_cfg->transfer_num = r_power_num;
   16866:	81bb      	strh	r3, [r7, #12]
            end_cfg->src += (uint32)cfg->transfer_num << dma_addr_inc_shift[cfg->src_inc];
   16868:	7a69      	ldrb	r1, [r5, #9]
   1686a:	89ab      	ldrh	r3, [r5, #12]
   1686c:	5c51      	ldrb	r1, [r2, r1]
   1686e:	408b      	lsls	r3, r1
   16870:	6839      	ldr	r1, [r7, #0]
   16872:	18cb      	adds	r3, r1, r3
   16874:	603b      	str	r3, [r7, #0]
            end_cfg->dst += (uint32)cfg->transfer_num << dma_addr_inc_shift[cfg->dst_inc];
   16876:	7aa9      	ldrb	r1, [r5, #10]
   16878:	89ab      	ldrh	r3, [r5, #12]
   1687a:	5c52      	ldrb	r2, [r2, r1]
   1687c:	4093      	lsls	r3, r2
   1687e:	687a      	ldr	r2, [r7, #4]
   16880:	18d3      	adds	r3, r2, r3
   16882:	607b      	str	r3, [r7, #4]
   16884:	e7ac      	b.n	167e0 <dma_configs_adding_fsm_batched_complete+0x1c>
    non_os_exit_critical();
   16886:	f001 fca9 	bl	181dc <non_os_exit_critical>
    if (!dma_ch_sleep_veto[ch])
   1688a:	4b0b      	ldr	r3, [pc, #44]	; (168b8 <dma_configs_adding_fsm_batched_complete+0xf4>)
   1688c:	5d1a      	ldrb	r2, [r3, r4]
   1688e:	2a00      	cmp	r2, #0
   16890:	d102      	bne.n	16898 <dma_configs_adding_fsm_batched_complete+0xd4>
        dma_ch_sleep_veto[ch] = true;
   16892:	551e      	strb	r6, [r3, r4]
        osAddStopClocksVeto();
   16894:	f7fe f9b6 	bl	14c04 <osAddStopClocksVeto>
    hal_dma_ch_state_set(ch, HAL_DMA_CH_STATE_ACTIVE);
   16898:	0020      	movs	r0, r4
   1689a:	2102      	movs	r1, #2
   1689c:	f002 fb9c 	bl	18fd8 <hal_dma_ch_state_set>
    batched_configs_head->ready = true;
   168a0:	2301      	movs	r3, #1
   168a2:	9a00      	ldr	r2, [sp, #0]
    (void)hal_dma_transfer(ch, batched_configs_head);
   168a4:	0020      	movs	r0, r4
    batched_configs_head->ready = true;
   168a6:	7453      	strb	r3, [r2, #17]
    (void)hal_dma_transfer(ch, batched_configs_head);
   168a8:	0011      	movs	r1, r2
   168aa:	f002 fc83 	bl	191b4 <hal_dma_transfer>
   168ae:	e7b2      	b.n	16816 <dma_configs_adding_fsm_batched_complete+0x52>
   168b0:	010025c4 	.word	0x010025c4
   168b4:	00025543 	.word	0x00025543
   168b8:	010025bd 	.word	0x010025bd

000168bc <dma_configs_adding_fsm_batched_start>:
{
   168bc:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    if (!dma_config_controller[ch].configs_fsm.batched_buffer_allocated)
   168be:	2514      	movs	r5, #20
   168c0:	4345      	muls	r5, r0
   168c2:	4c0d      	ldr	r4, [pc, #52]	; (168f8 <dma_configs_adding_fsm_batched_start+0x3c>)
{
   168c4:	0007      	movs	r7, r0
    if (!dma_config_controller[ch].configs_fsm.batched_buffer_allocated)
   168c6:	1965      	adds	r5, r4, r5
   168c8:	7beb      	ldrb	r3, [r5, #15]
{
   168ca:	000e      	movs	r6, r1
    if (!dma_config_controller[ch].configs_fsm.batched_buffer_allocated)
   168cc:	2b00      	cmp	r3, #0
   168ce:	d103      	bne.n	168d8 <dma_configs_adding_fsm_batched_start+0x1c>
        hal_dma_ch_scatter_gather_alternate_config_buffer_alloc(ch);
   168d0:	f002 fd76 	bl	193c0 <hal_dma_ch_scatter_gather_alternate_config_buffer_alloc>
        dma_config_controller[ch].configs_fsm.batched_buffer_allocated = true;
   168d4:	2301      	movs	r3, #1
   168d6:	73eb      	strb	r3, [r5, #15]
    dma_ch_config_peripheral_preprocess(ch, cfg);
   168d8:	0031      	movs	r1, r6
   168da:	0038      	movs	r0, r7
   168dc:	f7ff fe5a 	bl	16594 <dma_ch_config_peripheral_preprocess>
    hal_dma_ch_config_buffer_add_config(ch);
   168e0:	0038      	movs	r0, r7
   168e2:	f002 fc11 	bl	19108 <hal_dma_ch_config_buffer_add_config>
    dma_config_controller[ch].configs_fsm.batched_configs_num++;
   168e6:	2014      	movs	r0, #20
   168e8:	4378      	muls	r0, r7
   168ea:	1820      	adds	r0, r4, r0
   168ec:	7b83      	ldrb	r3, [r0, #14]
    dma_config_controller[ch].configs_fsm.batched_configs_head = cfg;
   168ee:	6106      	str	r6, [r0, #16]
    dma_config_controller[ch].configs_fsm.batched_configs_num++;
   168f0:	3301      	adds	r3, #1
   168f2:	7383      	strb	r3, [r0, #14]
}
   168f4:	2007      	movs	r0, #7
   168f6:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
   168f8:	010025c4 	.word	0x010025c4

000168fc <dma_init_user_common_config>:
{
   168fc:	b510      	push	{r4, lr}
   168fe:	9c02      	ldr	r4, [sp, #8]
    common_config->transfer_type = transfer_type;
   16900:	7021      	strb	r1, [r4, #0]
    common_config->data_width = data_width;
   16902:	7062      	strb	r2, [r4, #1]
    switch (transfer_type)
   16904:	2901      	cmp	r1, #1
   16906:	d011      	beq.n	1692c <dma_init_user_common_config+0x30>
   16908:	2900      	cmp	r1, #0
   1690a:	d006      	beq.n	1691a <dma_init_user_common_config+0x1e>
   1690c:	2902      	cmp	r1, #2
   1690e:	d019      	beq.n	16944 <dma_init_user_common_config+0x48>
            panic(PANIC_DMA, PANIC_DMA_UNSUPPORTED_TRANSFER_TYPE);
   16910:	2104      	movs	r1, #4
   16912:	2023      	movs	r0, #35	; 0x23
   16914:	f7eb f8fc 	bl	1b10 <panic>
}
   16918:	e007      	b.n	1692a <dma_init_user_common_config+0x2e>
            common_config->src = ((dma_ch_user_memory_config *)config)->src;
   1691a:	681a      	ldr	r2, [r3, #0]
   1691c:	6062      	str	r2, [r4, #4]
            common_config->dst = ((dma_ch_user_memory_config *)config)->dst;
   1691e:	685a      	ldr	r2, [r3, #4]
   16920:	60a2      	str	r2, [r4, #8]
            common_config->transfer_num = ((dma_ch_user_memory_config *)config)->transfer_num;
   16922:	891a      	ldrh	r2, [r3, #8]
   16924:	81a2      	strh	r2, [r4, #12]
            common_config->cycle_type = ((dma_ch_user_memory_config *)config)->cycle_type;
   16926:	7a9b      	ldrb	r3, [r3, #10]
            common_config->cycle_type = ((dma_ch_user_peripheral_config *)config)->cycle_type;
   16928:	73a3      	strb	r3, [r4, #14]
}
   1692a:	bd10      	pop	{r4, pc}
            common_config->src = ((dma_ch_user_peripheral_config *)config)->addr;
   1692c:	681a      	ldr	r2, [r3, #0]
   1692e:	6062      	str	r2, [r4, #4]
            common_config->dst = dma_config_controller[(HAL_DMA_CHANNEL)ch].periph_feature.periph_addr;
   16930:	2214      	movs	r2, #20
   16932:	4342      	muls	r2, r0
   16934:	4807      	ldr	r0, [pc, #28]	; (16954 <dma_init_user_common_config+0x58>)
   16936:	1880      	adds	r0, r0, r2
   16938:	6882      	ldr	r2, [r0, #8]
            common_config->dst = ((dma_ch_user_peripheral_config *)config)->addr;
   1693a:	60a2      	str	r2, [r4, #8]
            common_config->transfer_num = ((dma_ch_user_peripheral_config *)config)->transfer_num;
   1693c:	889a      	ldrh	r2, [r3, #4]
   1693e:	81a2      	strh	r2, [r4, #12]
            common_config->cycle_type = ((dma_ch_user_peripheral_config *)config)->cycle_type;
   16940:	79db      	ldrb	r3, [r3, #7]
   16942:	e7f1      	b.n	16928 <dma_init_user_common_config+0x2c>
            common_config->src = dma_config_controller[(HAL_DMA_CHANNEL)ch].periph_feature.periph_addr;
   16944:	2214      	movs	r2, #20
   16946:	4342      	muls	r2, r0
   16948:	4802      	ldr	r0, [pc, #8]	; (16954 <dma_init_user_common_config+0x58>)
   1694a:	1880      	adds	r0, r0, r2
   1694c:	6882      	ldr	r2, [r0, #8]
   1694e:	6062      	str	r2, [r4, #4]
            common_config->dst = ((dma_ch_user_peripheral_config *)config)->addr;
   16950:	681a      	ldr	r2, [r3, #0]
   16952:	e7f2      	b.n	1693a <dma_init_user_common_config+0x3e>
   16954:	010025c4 	.word	0x010025c4

00016958 <dma_configs_adding_fsm_single>:
{
   16958:	b570      	push	{r4, r5, r6, lr}
   1695a:	0004      	movs	r4, r0
    if (dma_config_controller[ch].configs_fsm.batched_configs_num > 0)
   1695c:	2514      	movs	r5, #20
   1695e:	4365      	muls	r5, r4
{
   16960:	000e      	movs	r6, r1
    dma_ch_config_peripheral_preprocess(ch, cfg);
   16962:	f7ff fe17 	bl	16594 <dma_ch_config_peripheral_preprocess>
    if (dma_config_controller[ch].configs_fsm.batched_configs_num > 0)
   16966:	4b1b      	ldr	r3, [pc, #108]	; (169d4 <dma_configs_adding_fsm_single+0x7c>)
   16968:	195d      	adds	r5, r3, r5
   1696a:	7bab      	ldrb	r3, [r5, #14]
   1696c:	2b00      	cmp	r3, #0
   1696e:	d00b      	beq.n	16988 <dma_configs_adding_fsm_single+0x30>
        cfg->scatter_gather_configs = 2;
   16970:	2302      	movs	r3, #2
   16972:	7433      	strb	r3, [r6, #16]
        dma_config_controller[ch].configs_fsm.batched_configs_num = 0;
   16974:	2300      	movs	r3, #0
   16976:	73ab      	strb	r3, [r5, #14]
        if (!dma_config_controller[ch].configs_fsm.batched_buffer_allocated)
   16978:	7beb      	ldrb	r3, [r5, #15]
   1697a:	2b00      	cmp	r3, #0
   1697c:	d104      	bne.n	16988 <dma_configs_adding_fsm_single+0x30>
            hal_dma_ch_scatter_gather_alternate_config_buffer_alloc(ch);
   1697e:	0020      	movs	r0, r4
   16980:	f002 fd1e 	bl	193c0 <hal_dma_ch_scatter_gather_alternate_config_buffer_alloc>
            dma_config_controller[ch].configs_fsm.batched_buffer_allocated = true;
   16984:	2301      	movs	r3, #1
   16986:	73eb      	strb	r3, [r5, #15]
    hal_dma_ch_config_buffer_add_config(ch);
   16988:	0020      	movs	r0, r4
   1698a:	f002 fbbd 	bl	19108 <hal_dma_ch_config_buffer_add_config>
    non_os_enter_critical();
   1698e:	f001 fc11 	bl	181b4 <non_os_enter_critical>
    if (hal_dma_ch_state_get(ch) != HAL_DMA_CH_STATE_IDLE)
   16992:	0020      	movs	r0, r4
   16994:	f002 fb18 	bl	18fc8 <hal_dma_ch_state_get>
   16998:	0005      	movs	r5, r0
   1699a:	2801      	cmp	r0, #1
   1699c:	d005      	beq.n	169aa <dma_configs_adding_fsm_single+0x52>
        cfg->ready = true;
   1699e:	2301      	movs	r3, #1
   169a0:	7473      	strb	r3, [r6, #17]
        non_os_exit_critical();
   169a2:	f001 fc1b 	bl	181dc <non_os_exit_critical>
}
   169a6:	2000      	movs	r0, #0
   169a8:	bd70      	pop	{r4, r5, r6, pc}
        non_os_exit_critical();
   169aa:	f001 fc17 	bl	181dc <non_os_exit_critical>
    if (!dma_ch_sleep_veto[ch])
   169ae:	4b0a      	ldr	r3, [pc, #40]	; (169d8 <dma_configs_adding_fsm_single+0x80>)
   169b0:	5d1a      	ldrb	r2, [r3, r4]
   169b2:	2a00      	cmp	r2, #0
   169b4:	d102      	bne.n	169bc <dma_configs_adding_fsm_single+0x64>
        dma_ch_sleep_veto[ch] = true;
   169b6:	551d      	strb	r5, [r3, r4]
        osAddStopClocksVeto();
   169b8:	f7fe f924 	bl	14c04 <osAddStopClocksVeto>
        hal_dma_ch_state_set(ch, HAL_DMA_CH_STATE_ACTIVE);
   169bc:	0020      	movs	r0, r4
   169be:	2102      	movs	r1, #2
   169c0:	f002 fb0a 	bl	18fd8 <hal_dma_ch_state_set>
        cfg->ready = true;
   169c4:	2301      	movs	r3, #1
        (void)hal_dma_transfer(ch, cfg);
   169c6:	0031      	movs	r1, r6
        cfg->ready = true;
   169c8:	7473      	strb	r3, [r6, #17]
        (void)hal_dma_transfer(ch, cfg);
   169ca:	0020      	movs	r0, r4
   169cc:	f002 fbf2 	bl	191b4 <hal_dma_transfer>
   169d0:	e7e9      	b.n	169a6 <dma_configs_adding_fsm_single+0x4e>
   169d2:	46c0      	nop			; (mov r8, r8)
   169d4:	010025c4 	.word	0x010025c4
   169d8:	010025bd 	.word	0x010025bd

000169dc <dma_claim_mutexes>:
    if (osMutexAcquire(mutex, blockTime) != osOK)
   169dc:	2101      	movs	r1, #1
{
   169de:	b510      	push	{r4, lr}
    if (osMutexAcquire(mutex, blockTime) != osOK)
   169e0:	4b05      	ldr	r3, [pc, #20]	; (169f8 <dma_claim_mutexes+0x1c>)
   169e2:	4249      	negs	r1, r1
   169e4:	6818      	ldr	r0, [r3, #0]
   169e6:	f7fd ffdd 	bl	149a4 <osMutexAcquire>
   169ea:	2800      	cmp	r0, #0
   169ec:	d003      	beq.n	169f6 <dma_claim_mutexes+0x1a>
        panic(PANIC_DMA, PANIC_DMA_UNABLE_TO_TAKE_MUTEX);
   169ee:	2101      	movs	r1, #1
   169f0:	2023      	movs	r0, #35	; 0x23
   169f2:	f7eb f88d 	bl	1b10 <panic>
}
   169f6:	bd10      	pop	{r4, pc}
   169f8:	01002624 	.word	0x01002624

000169fc <dma_transfer_head_configs>:

/** Transfer head config(s) of the dma configuration logic queue of one specific channel
 * @param ch the Channel ID
 */
static void dma_transfer_head_configs(HAL_DMA_CHANNEL ch)
{
   169fc:	b510      	push	{r4, lr}
   169fe:	0004      	movs	r4, r0
    cfg = hal_dma_ch_config_buffer_get_first_used(ch);
   16a00:	f002 fb60 	bl	190c4 <hal_dma_ch_config_buffer_get_first_used>
    return (cfg != NULL) && cfg->ready;
   16a04:	2800      	cmp	r0, #0
   16a06:	d00e      	beq.n	16a26 <dma_transfer_head_configs+0x2a>
   16a08:	7c43      	ldrb	r3, [r0, #17]
   16a0a:	2b00      	cmp	r3, #0
   16a0c:	d00b      	beq.n	16a26 <dma_transfer_head_configs+0x2a>
    hal_dma_ch_configuration *cfg;

    if (dma_ch_head_configs_unsent(ch))
    {
        hal_dma_ch_state_set(ch, HAL_DMA_CH_STATE_ACTIVE);
   16a0e:	2102      	movs	r1, #2
   16a10:	0020      	movs	r0, r4
   16a12:	f002 fae1 	bl	18fd8 <hal_dma_ch_state_set>

        cfg = hal_dma_ch_config_buffer_get_first_used(ch);
   16a16:	0020      	movs	r0, r4
   16a18:	f002 fb54 	bl	190c4 <hal_dma_ch_config_buffer_get_first_used>
   16a1c:	0001      	movs	r1, r0

        /* It must generate done or error interrupt later after invoked this function
         * since we had checked the cfg previously.
         */
        (void)hal_dma_transfer(ch, cfg);
   16a1e:	0020      	movs	r0, r4
   16a20:	f002 fbc8 	bl	191b4 <hal_dma_transfer>
    {
        hal_dma_ch_state_set(ch, HAL_DMA_CH_STATE_IDLE);

        dma_ch_remove_any_sleep_veto(ch);
    }
}
   16a24:	bd10      	pop	{r4, pc}
        hal_dma_ch_state_set(ch, HAL_DMA_CH_STATE_IDLE);
   16a26:	0020      	movs	r0, r4
   16a28:	2101      	movs	r1, #1
   16a2a:	f002 fad5 	bl	18fd8 <hal_dma_ch_state_set>
        dma_ch_remove_any_sleep_veto(ch);
   16a2e:	0020      	movs	r0, r4
   16a30:	f7ff fe14 	bl	1665c <dma_ch_remove_any_sleep_veto>
}
   16a34:	e7f6      	b.n	16a24 <dma_transfer_head_configs+0x28>
	...

00016a38 <dma_err_isr>:

/** DMA transfer error ISR callback function that invoked at HAL layer
 * @param ch the Channel ID
 */
static void dma_err_isr(HAL_DMA_CHANNEL ch)
{
   16a38:	b570      	push	{r4, r5, r6, lr}
        assert(dma_ch_are_intr_flags_set(ch, DMA_CH_ERR_INTR_FLAG_MASK));
    }
#endif

    /* Now that state has no actual effect */
    hal_dma_ch_state_set(ch, HAL_DMA_CH_STATE_ERROR);
   16a3a:	2104      	movs	r1, #4
{
   16a3c:	0004      	movs	r4, r0
   16a3e:	4675      	mov	r5, lr
    hal_dma_ch_state_set(ch, HAL_DMA_CH_STATE_ERROR);
   16a40:	f002 faca 	bl	18fd8 <hal_dma_ch_state_set>

    dma_config_controller[ch].error_times++;
   16a44:	2214      	movs	r2, #20
   16a46:	4362      	muls	r2, r4
   16a48:	4b0f      	ldr	r3, [pc, #60]	; (16a88 <dma_err_isr+0x50>)

    if (dma_transfer_peripheral_finish[ch] != NULL)
   16a4a:	00a0      	lsls	r0, r4, #2
    dma_config_controller[ch].error_times++;
   16a4c:	5cd1      	ldrb	r1, [r2, r3]
   16a4e:	3101      	adds	r1, #1
   16a50:	54d1      	strb	r1, [r2, r3]
    if (dma_transfer_peripheral_finish[ch] != NULL)
   16a52:	490e      	ldr	r1, [pc, #56]	; (16a8c <dma_err_isr+0x54>)
   16a54:	5841      	ldr	r1, [r0, r1]
   16a56:	2900      	cmp	r1, #0
   16a58:	d002      	beq.n	16a60 <dma_err_isr+0x28>
    {
        dma_transfer_peripheral_finish[ch](dma_config_controller[ch].peripheral);
   16a5a:	189b      	adds	r3, r3, r2
   16a5c:	7858      	ldrb	r0, [r3, #1]
   16a5e:	4788      	blx	r1
    }

    /* Here we still keep the ERROR interrupt been turned on so that ERROR interrupt
     * could be received later, and clear the ERROR intr flag to make the channel to be normal.
     */
    hal_dma_clear_interrupt(ch, HAL_DMA_INTERRUPT_ERR);
   16a60:	0020      	movs	r0, r4
   16a62:	2101      	movs	r1, #1
   16a64:	f002 fd42 	bl	194ec <hal_dma_clear_interrupt>
    cfg = hal_dma_ch_config_buffer_get_first_used(ch);
   16a68:	0020      	movs	r0, r4
   16a6a:	f002 fb2b 	bl	190c4 <hal_dma_ch_config_buffer_get_first_used>
    return (cfg != NULL) && cfg->ready;
   16a6e:	2800      	cmp	r0, #0
   16a70:	d002      	beq.n	16a78 <dma_err_isr+0x40>
   16a72:	7c43      	ldrb	r3, [r0, #17]
   16a74:	2b00      	cmp	r3, #0
   16a76:	d103      	bne.n	16a80 <dma_err_isr+0x48>
    uint32 dma_base = DMA_BASE_ADDR;
    *(volatile uint32 *)(dma_base + HAL_DMA_INTEGRATION_CONFIGURATION_BASE_OFFSET) = 0;
#endif

    /* Now the policy of handling error interrupt is to re-transmit the failed configuration(s) */
    assert(dma_ch_head_configs_unsent(ch));
   16a78:	0029      	movs	r1, r5
   16a7a:	2016      	movs	r0, #22
   16a7c:	f7eb f848 	bl	1b10 <panic>
    dma_transfer_head_configs(ch);
   16a80:	0020      	movs	r0, r4
   16a82:	f7ff ffbb 	bl	169fc <dma_transfer_head_configs>
}
   16a86:	bd70      	pop	{r4, r5, r6, pc}
   16a88:	010025c4 	.word	0x010025c4
   16a8c:	01002614 	.word	0x01002614

00016a90 <dma_done_isr>:
{
   16a90:	b570      	push	{r4, r5, r6, lr}
    if (dma_transfer_peripheral_finish[ch] != NULL)
   16a92:	4b18      	ldr	r3, [pc, #96]	; (16af4 <dma_done_isr+0x64>)
   16a94:	0082      	lsls	r2, r0, #2
   16a96:	58d1      	ldr	r1, [r2, r3]
   16a98:	4675      	mov	r5, lr
{
   16a9a:	0004      	movs	r4, r0
    if (dma_transfer_peripheral_finish[ch] != NULL)
   16a9c:	2900      	cmp	r1, #0
   16a9e:	d005      	beq.n	16aac <dma_done_isr+0x1c>
        dma_transfer_peripheral_finish[ch](dma_config_controller[ch].peripheral);
   16aa0:	2214      	movs	r2, #20
   16aa2:	4342      	muls	r2, r0
   16aa4:	4b14      	ldr	r3, [pc, #80]	; (16af8 <dma_done_isr+0x68>)
   16aa6:	189b      	adds	r3, r3, r2
   16aa8:	7858      	ldrb	r0, [r3, #1]
   16aaa:	4788      	blx	r1
    hal_dma_clear_interrupt(ch, HAL_DMA_INTERRUPT_DONE);
   16aac:	2100      	movs	r1, #0
   16aae:	0020      	movs	r0, r4
   16ab0:	f002 fd1c 	bl	194ec <hal_dma_clear_interrupt>
    cfg = hal_dma_ch_config_buffer_get_first_used(ch);
   16ab4:	0020      	movs	r0, r4
   16ab6:	f002 fb05 	bl	190c4 <hal_dma_ch_config_buffer_get_first_used>
   16aba:	1e06      	subs	r6, r0, #0
    assert(cfg != NULL);
   16abc:	d114      	bne.n	16ae8 <dma_done_isr+0x58>
   16abe:	0029      	movs	r1, r5
   16ac0:	2016      	movs	r0, #22
   16ac2:	f7eb f825 	bl	1b10 <panic>
}
   16ac6:	bd70      	pop	{r4, r5, r6, pc}
            hal_dma_ch_select_primary(ch);
   16ac8:	0020      	movs	r0, r4
   16aca:	f002 fd27 	bl	1951c <hal_dma_ch_select_primary>
        if (cfg->callback != NULL)
   16ace:	6973      	ldr	r3, [r6, #20]
   16ad0:	2b00      	cmp	r3, #0
   16ad2:	d001      	beq.n	16ad8 <dma_done_isr+0x48>
            cfg->callback(HAL_DMA_INTERRUPT_DONE);
   16ad4:	2000      	movs	r0, #0
   16ad6:	4798      	blx	r3
        hal_dma_ch_config_buffer_remove_config(ch, scatter_gather_cfgs);
   16ad8:	0020      	movs	r0, r4
   16ada:	0029      	movs	r1, r5
   16adc:	f002 fb32 	bl	19144 <hal_dma_ch_config_buffer_remove_config>
        dma_transfer_head_configs(ch);
   16ae0:	0020      	movs	r0, r4
   16ae2:	f7ff ff8b 	bl	169fc <dma_transfer_head_configs>
}
   16ae6:	e7ee      	b.n	16ac6 <dma_done_isr+0x36>
        scatter_gather_cfgs = cfg->scatter_gather_configs;
   16ae8:	7c05      	ldrb	r5, [r0, #16]
        if (scatter_gather_cfgs > 0)
   16aea:	2d00      	cmp	r5, #0
   16aec:	d1ec      	bne.n	16ac8 <dma_done_isr+0x38>
            scatter_gather_cfgs = 1;
   16aee:	3501      	adds	r5, #1
   16af0:	e7ed      	b.n	16ace <dma_done_isr+0x3e>
   16af2:	46c0      	nop			; (mov r8, r8)
   16af4:	01002614 	.word	0x01002614
   16af8:	010025c4 	.word	0x010025c4

00016afc <dma_init>:
{
   16afc:	b510      	push	{r4, lr}
    assert(non_os_is_driver_initialised(DRIVER_INIT_DMA) != true);
   16afe:	200d      	movs	r0, #13
   16b00:	4674      	mov	r4, lr
   16b02:	f001 fb7f 	bl	18204 <non_os_is_driver_initialised>
   16b06:	2800      	cmp	r0, #0
   16b08:	d003      	beq.n	16b12 <dma_init+0x16>
   16b0a:	0021      	movs	r1, r4
   16b0c:	2016      	movs	r0, #22
   16b0e:	f7ea ffff 	bl	1b10 <panic>
    hal_dma_init();
   16b12:	f002 f9c3 	bl	18e9c <hal_dma_init>
    dmac_mutex = osMutexNew(NULL);
   16b16:	2000      	movs	r0, #0
   16b18:	f7fd ff2e 	bl	14978 <osMutexNew>
   16b1c:	4c11      	ldr	r4, [pc, #68]	; (16b64 <dma_init+0x68>)
   16b1e:	1e01      	subs	r1, r0, #0
   16b20:	6020      	str	r0, [r4, #0]
    if (dmac_mutex == NULL)
   16b22:	d102      	bne.n	16b2a <dma_init+0x2e>
        panic(PANIC_DMA, PANIC_DMA_UNABLE_TO_CREATE_MUTEX);
   16b24:	2023      	movs	r0, #35	; 0x23
   16b26:	f7ea fff3 	bl	1b10 <panic>
    if (osMutexAcquire(mutex, blockTime) != osOK)
   16b2a:	2100      	movs	r1, #0
   16b2c:	6820      	ldr	r0, [r4, #0]
   16b2e:	f7fd ff39 	bl	149a4 <osMutexAcquire>
   16b32:	2800      	cmp	r0, #0
   16b34:	d003      	beq.n	16b3e <dma_init+0x42>
        panic(PANIC_DMA, PANIC_DMA_UNABLE_TO_TAKE_MUTEX);
   16b36:	2101      	movs	r1, #1
   16b38:	2023      	movs	r0, #35	; 0x23
   16b3a:	f7ea ffe9 	bl	1b10 <panic>
    dma_release_mutexes();
   16b3e:	f7ff fd7f 	bl	16640 <dma_release_mutexes>
        dma_ch_sleep_veto[ch] = false;
   16b42:	2300      	movs	r3, #0
   16b44:	4908      	ldr	r1, [pc, #32]	; (16b68 <dma_init+0x6c>)
        dma_transfer_peripheral_finish[ch] = NULL;
   16b46:	4a09      	ldr	r2, [pc, #36]	; (16b6c <dma_init+0x70>)
        dma_ch_sleep_veto[ch] = false;
   16b48:	700b      	strb	r3, [r1, #0]
   16b4a:	704b      	strb	r3, [r1, #1]
   16b4c:	708b      	strb	r3, [r1, #2]
   16b4e:	70cb      	strb	r3, [r1, #3]
    non_os_set_driver_initalised(DRIVER_INIT_DMA, true);
   16b50:	200d      	movs	r0, #13
   16b52:	2101      	movs	r1, #1
        dma_transfer_peripheral_finish[ch] = NULL;
   16b54:	6013      	str	r3, [r2, #0]
   16b56:	6053      	str	r3, [r2, #4]
   16b58:	6093      	str	r3, [r2, #8]
   16b5a:	60d3      	str	r3, [r2, #12]
    non_os_set_driver_initalised(DRIVER_INIT_DMA, true);
   16b5c:	f001 fb5c 	bl	18218 <non_os_set_driver_initalised>
}
   16b60:	bd10      	pop	{r4, pc}
   16b62:	46c0      	nop			; (mov r8, r8)
   16b64:	01002624 	.word	0x01002624
   16b68:	010025bd 	.word	0x010025bd
   16b6c:	01002614 	.word	0x01002614

00016b70 <dma_ch_open>:
{
   16b70:	b5f0      	push	{r4, r5, r6, r7, lr}
   16b72:	b085      	sub	sp, #20
   16b74:	9000      	str	r0, [sp, #0]
    assert(non_os_is_driver_initialised(DRIVER_INIT_DMA));
   16b76:	200d      	movs	r0, #13
   16b78:	4676      	mov	r6, lr
{
   16b7a:	000c      	movs	r4, r1
   16b7c:	0015      	movs	r5, r2
    assert(non_os_is_driver_initialised(DRIVER_INIT_DMA));
   16b7e:	f001 fb41 	bl	18204 <non_os_is_driver_initialised>
   16b82:	2800      	cmp	r0, #0
   16b84:	d103      	bne.n	16b8e <dma_ch_open+0x1e>
   16b86:	0031      	movs	r1, r6
   16b88:	3016      	adds	r0, #22
   16b8a:	f7ea ffc1 	bl	1b10 <panic>
    assert((ch != NULL) && (pri != DMA_CH_PRIORITY_RESERVED));
   16b8e:	9b00      	ldr	r3, [sp, #0]
   16b90:	2b00      	cmp	r3, #0
   16b92:	d00f      	beq.n	16bb4 <dma_ch_open+0x44>
   16b94:	2cff      	cmp	r4, #255	; 0xff
   16b96:	d00d      	beq.n	16bb4 <dma_ch_open+0x44>
    dma_claim_mutexes();
   16b98:	f7ff ff20 	bl	169dc <dma_claim_mutexes>
    if(!hal_dma_is_claimed())
   16b9c:	f002 f9d4 	bl	18f48 <hal_dma_is_claimed>
   16ba0:	2800      	cmp	r0, #0
   16ba2:	d111      	bne.n	16bc8 <dma_ch_open+0x58>
        hal_ret = hal_dma_claim();
   16ba4:	f002 f9a0 	bl	18ee8 <hal_dma_claim>
        if (hal_ret != HAL_DMA_RET_OK)
   16ba8:	2800      	cmp	r0, #0
   16baa:	d00d      	beq.n	16bc8 <dma_ch_open+0x58>
            dma_release_mutexes();
   16bac:	f7ff fd48 	bl	16640 <dma_release_mutexes>
            return DMA_RET_NOT_INITIALIZED;
   16bb0:	2001      	movs	r0, #1
   16bb2:	e007      	b.n	16bc4 <dma_ch_open+0x54>
    assert((ch != NULL) && (pri != DMA_CH_PRIORITY_RESERVED));
   16bb4:	2016      	movs	r0, #22
   16bb6:	0031      	movs	r1, r6
   16bb8:	f7ea ffaa 	bl	1b10 <panic>
    if (ch == NULL) //lint !e774
   16bbc:	9b00      	ldr	r3, [sp, #0]
        return DMA_RET_INVALID_ARGS;
   16bbe:	200a      	movs	r0, #10
    if (ch == NULL) //lint !e774
   16bc0:	2b00      	cmp	r3, #0
   16bc2:	d1e9      	bne.n	16b98 <dma_ch_open+0x28>
}
   16bc4:	b005      	add	sp, #20
   16bc6:	bdf0      	pop	{r4, r5, r6, r7, pc}
    success = hal_dma_ch_open(&ch_candidate, DMA_CH_PRIORITY_DRIVER_MAP_TO_HAL(pri), (config != NULL) ? config->peripheral : DMA_PERIPHERAL_MEMORY);
   16bc8:	1e2a      	subs	r2, r5, #0
   16bca:	d000      	beq.n	16bce <dma_ch_open+0x5e>
   16bcc:	782a      	ldrb	r2, [r5, #0]
   16bce:	ab02      	add	r3, sp, #8
   16bd0:	1dde      	adds	r6, r3, #7
   16bd2:	0021      	movs	r1, r4
   16bd4:	0030      	movs	r0, r6
   16bd6:	f002 fccb 	bl	19570 <hal_dma_ch_open>
    if (!success)
   16bda:	2800      	cmp	r0, #0
   16bdc:	d103      	bne.n	16be6 <dma_ch_open+0x76>
        dma_release_mutexes();
   16bde:	f7ff fd2f 	bl	16640 <dma_release_mutexes>
        return DMA_RET_NO_AVAIL_CH;
   16be2:	2003      	movs	r0, #3
   16be4:	e7ee      	b.n	16bc4 <dma_ch_open+0x54>
   16be6:	2214      	movs	r2, #20
   16be8:	0013      	movs	r3, r2
    dma_ch_init_config_controller((DMA_CHANNEL)ch_candidate, config);
   16bea:	7834      	ldrb	r4, [r6, #0]
    cfg_ctrl->peripheral = DMA_PERIPHERAL_MEMORY;
   16bec:	2700      	movs	r7, #0
   16bee:	4363      	muls	r3, r4
   16bf0:	9301      	str	r3, [sp, #4]
    dma_ch_config_control *cfg_ctrl = &dma_config_controller[(HAL_DMA_CHANNEL)ch];
   16bf2:	9901      	ldr	r1, [sp, #4]
   16bf4:	4b2c      	ldr	r3, [pc, #176]	; (16ca8 <dma_ch_open+0x138>)
   16bf6:	185e      	adds	r6, r3, r1
    memset(cfg_ctrl, 0, sizeof(*cfg_ctrl));
   16bf8:	0030      	movs	r0, r6
   16bfa:	2100      	movs	r1, #0
   16bfc:	f7e9 fb70 	bl	2e0 <memset>
    cfg_ctrl->periph_feature.power_of_burst = DMA_POWER_OF_BURST_10;
   16c00:	230a      	movs	r3, #10
   16c02:	7133      	strb	r3, [r6, #4]
    dma_ch_open_set_peripheral_feature(ch, &cfg_ctrl->periph_feature);
   16c04:	9b01      	ldr	r3, [sp, #4]
   16c06:	0020      	movs	r0, r4
   16c08:	1d19      	adds	r1, r3, #4
   16c0a:	4b27      	ldr	r3, [pc, #156]	; (16ca8 <dma_ch_open+0x138>)
    cfg_ctrl->peripheral = DMA_PERIPHERAL_MEMORY;
   16c0c:	7077      	strb	r7, [r6, #1]
    dma_ch_open_set_peripheral_feature(ch, &cfg_ctrl->periph_feature);
   16c0e:	1859      	adds	r1, r3, r1
    cfg_ctrl->periph_feature.use_burst = false;
   16c10:	7177      	strb	r7, [r6, #5]
    dma_ch_open_set_peripheral_feature(ch, &cfg_ctrl->periph_feature);
   16c12:	f7ff fd35 	bl	16680 <dma_ch_open_set_peripheral_feature>
    hal_dma_ch_deregister_peripheral_prepare_callback((HAL_DMA_CHANNEL)ch);
   16c16:	0020      	movs	r0, r4
   16c18:	f002 f9ce 	bl	18fb8 <hal_dma_ch_deregister_peripheral_prepare_callback>
    dma_transfer_peripheral_finish[ch] = NULL;
   16c1c:	00a3      	lsls	r3, r4, #2
   16c1e:	9301      	str	r3, [sp, #4]
   16c20:	4b22      	ldr	r3, [pc, #136]	; (16cac <dma_ch_open+0x13c>)
   16c22:	00a2      	lsls	r2, r4, #2
   16c24:	50d7      	str	r7, [r2, r3]
    if (config != NULL)
   16c26:	42bd      	cmp	r5, r7
   16c28:	d00f      	beq.n	16c4a <dma_ch_open+0xda>
        cfg_ctrl->peripheral = config->peripheral;
   16c2a:	782b      	ldrb	r3, [r5, #0]
        dma_ch_open_set_peripheral_feature(ch, &config->feature);
   16c2c:	1d29      	adds	r1, r5, #4
        cfg_ctrl->peripheral = config->peripheral;
   16c2e:	7073      	strb	r3, [r6, #1]
        dma_ch_open_set_peripheral_feature(ch, &config->feature);
   16c30:	0020      	movs	r0, r4
   16c32:	f7ff fd25 	bl	16680 <dma_ch_open_set_peripheral_feature>
    hal_dma_ch_register_peripheral_prepare_callback((HAL_DMA_CHANNEL)ch, (hal_dma_transfer_peripheral_prepare_callback)callback);
   16c36:	68e9      	ldr	r1, [r5, #12]
   16c38:	0020      	movs	r0, r4
   16c3a:	f002 f9b7 	bl	18fac <hal_dma_ch_register_peripheral_prepare_callback>
    dma_transfer_peripheral_finish[ch] = callback;
   16c3e:	692b      	ldr	r3, [r5, #16]
   16c40:	00a2      	lsls	r2, r4, #2
   16c42:	9301      	str	r3, [sp, #4]
   16c44:	9901      	ldr	r1, [sp, #4]
   16c46:	4b19      	ldr	r3, [pc, #100]	; (16cac <dma_ch_open+0x13c>)
   16c48:	50d1      	str	r1, [r2, r3]
    cfg->r_power = DMA_POWER_OF_BURST_MAP_TO_HAL_R_POWER(dma_config_controller[ch].periph_feature.power_of_burst);
   16c4a:	2614      	movs	r6, #20
    hal_dma_ch_config_buffer_init((HAL_DMA_CHANNEL)ch);
   16c4c:	0020      	movs	r0, r4
   16c4e:	f002 f9cb 	bl	18fe8 <hal_dma_ch_config_buffer_init>
    uint8 i = 0;
   16c52:	2500      	movs	r5, #0
    cfg->r_power = DMA_POWER_OF_BURST_MAP_TO_HAL_R_POWER(dma_config_controller[ch].periph_feature.power_of_burst);
   16c54:	4366      	muls	r6, r4
        dma_ch_init_driver_config((HAL_DMA_CHANNEL)ch, hal_dma_ch_config_buffer_get_free_config((HAL_DMA_CHANNEL)ch, i));
   16c56:	0029      	movs	r1, r5
   16c58:	0020      	movs	r0, r4
   16c5a:	f002 f9f1 	bl	19040 <hal_dma_ch_config_buffer_get_free_config>
    cfg->r_power = DMA_POWER_OF_BURST_MAP_TO_HAL_R_POWER(dma_config_controller[ch].periph_feature.power_of_burst);
   16c5e:	4b12      	ldr	r3, [pc, #72]	; (16ca8 <dma_ch_open+0x138>)
    for (; i < HAL_DMA_CH_TRANSFER_QUEUE_MAX_SIZE; i++)
   16c60:	3501      	adds	r5, #1
    cfg->r_power = DMA_POWER_OF_BURST_MAP_TO_HAL_R_POWER(dma_config_controller[ch].periph_feature.power_of_burst);
   16c62:	199b      	adds	r3, r3, r6
   16c64:	791a      	ldrb	r2, [r3, #4]
    for (; i < HAL_DMA_CH_TRANSFER_QUEUE_MAX_SIZE; i++)
   16c66:	b2ed      	uxtb	r5, r5
    cfg->r_power = DMA_POWER_OF_BURST_MAP_TO_HAL_R_POWER(dma_config_controller[ch].periph_feature.power_of_burst);
   16c68:	73c2      	strb	r2, [r0, #15]
    cfg->next_use_burst = dma_config_controller[ch].periph_feature.use_burst ? HAL_DMA_NEXT_USE_BURST_ENABLE : HAL_DMA_NEXT_USE_BURST_DISABLE;
   16c6a:	795b      	ldrb	r3, [r3, #5]
   16c6c:	72c3      	strb	r3, [r0, #11]
    for (; i < HAL_DMA_CH_TRANSFER_QUEUE_MAX_SIZE; i++)
   16c6e:	2d0a      	cmp	r5, #10
   16c70:	d1f1      	bne.n	16c56 <dma_ch_open+0xe6>
    dma_configure_interrupts(ch_candidate, dma_isr_callback);
   16c72:	ab02      	add	r3, sp, #8
   16c74:	79dd      	ldrb	r5, [r3, #7]
   16c76:	1ddc      	adds	r4, r3, #7
    hal_dma_configure_interrupt(ch, HAL_DMA_INTERRUPT_DONE, isr_callback_array[HAL_DMA_INTERRUPT_DONE], INTERRUPT_STATE_DISABLED);
   16c78:	2300      	movs	r3, #0
   16c7a:	4a0d      	ldr	r2, [pc, #52]	; (16cb0 <dma_ch_open+0x140>)
   16c7c:	0019      	movs	r1, r3
   16c7e:	0028      	movs	r0, r5
   16c80:	f002 fbfa 	bl	19478 <hal_dma_configure_interrupt>
    hal_dma_configure_interrupt(ch, HAL_DMA_INTERRUPT_ERR, isr_callback_array[HAL_DMA_INTERRUPT_ERR], INTERRUPT_STATE_DISABLED);
   16c84:	2300      	movs	r3, #0
   16c86:	4a0b      	ldr	r2, [pc, #44]	; (16cb4 <dma_ch_open+0x144>)
   16c88:	2101      	movs	r1, #1
   16c8a:	0028      	movs	r0, r5
   16c8c:	f002 fbf4 	bl	19478 <hal_dma_configure_interrupt>
    hal_dma_enable_interrupt(ch_candidate, HAL_DMA_INTERRUPT_DONE);
   16c90:	7820      	ldrb	r0, [r4, #0]
   16c92:	2100      	movs	r1, #0
   16c94:	f002 fbaa 	bl	193ec <hal_dma_enable_interrupt>
    *ch = (DMA_CHANNEL)ch_candidate;
   16c98:	7823      	ldrb	r3, [r4, #0]
   16c9a:	9a00      	ldr	r2, [sp, #0]
   16c9c:	7013      	strb	r3, [r2, #0]
    dma_release_mutexes();
   16c9e:	f7ff fccf 	bl	16640 <dma_release_mutexes>
    return DMA_RET_OK;
   16ca2:	2000      	movs	r0, #0
   16ca4:	e78e      	b.n	16bc4 <dma_ch_open+0x54>
   16ca6:	46c0      	nop			; (mov r8, r8)
   16ca8:	010025c4 	.word	0x010025c4
   16cac:	01002614 	.word	0x01002614
   16cb0:	00016a91 	.word	0x00016a91
   16cb4:	00016a39 	.word	0x00016a39

00016cb8 <dma_transfer_peripheral_bytes>:
{
   16cb8:	b5f0      	push	{r4, r5, r6, r7, lr}
   16cba:	4677      	mov	r7, lr
   16cbc:	b089      	sub	sp, #36	; 0x24
   16cbe:	0005      	movs	r5, r0
   16cc0:	000c      	movs	r4, r1
   16cc2:	0016      	movs	r6, r2
    assert(user_cfg != NULL);
   16cc4:	2900      	cmp	r1, #0
   16cc6:	d103      	bne.n	16cd0 <dma_transfer_peripheral_bytes+0x18>
   16cc8:	4671      	mov	r1, lr
   16cca:	2016      	movs	r0, #22
   16ccc:	f7ea ff20 	bl	1b10 <panic>
    assert((user_cfg->transfer_type == DMA_CH_TRANSFER_TYPE_MEM_TO_PERIPHERAL) ||
   16cd0:	79a3      	ldrb	r3, [r4, #6]
   16cd2:	3b01      	subs	r3, #1
   16cd4:	2b01      	cmp	r3, #1
   16cd6:	d903      	bls.n	16ce0 <dma_transfer_peripheral_bytes+0x28>
   16cd8:	0039      	movs	r1, r7
   16cda:	2016      	movs	r0, #22
   16cdc:	f7ea ff18 	bl	1b10 <panic>
    dma_init_user_common_config(ch, user_cfg->transfer_type, HAL_DMA_DATA_WIDTH_BYTE, user_cfg, &user_common_config);
   16ce0:	af04      	add	r7, sp, #16
   16ce2:	79a1      	ldrb	r1, [r4, #6]
   16ce4:	0023      	movs	r3, r4
   16ce6:	2200      	movs	r2, #0
   16ce8:	0028      	movs	r0, r5
   16cea:	9700      	str	r7, [sp, #0]
   16cec:	f7ff fe06 	bl	168fc <dma_init_user_common_config>
    ret = dma_fill_driver_ch_config((HAL_DMA_CHANNEL)ch, &drv_cfg, &user_common_config, callback);
   16cf0:	0033      	movs	r3, r6
   16cf2:	003a      	movs	r2, r7
   16cf4:	a903      	add	r1, sp, #12
   16cf6:	0028      	movs	r0, r5
   16cf8:	f7ff fce2 	bl	166c0 <dma_fill_driver_ch_config>
    if (ret != DMA_RET_OK)
   16cfc:	2800      	cmp	r0, #0
   16cfe:	d103      	bne.n	16d08 <dma_transfer_peripheral_bytes+0x50>
    ret = dma_transfer(ch, drv_cfg);
   16d00:	9903      	ldr	r1, [sp, #12]
   16d02:	0028      	movs	r0, r5
   16d04:	f7ff fc76 	bl	165f4 <dma_transfer>
}
   16d08:	b009      	add	sp, #36	; 0x24
   16d0a:	bdf0      	pop	{r4, r5, r6, r7, pc}

00016d0c <uart_common_release_pins>:

/*
 * Releases pins assigned for UART TX, RX, RTS and CTS
 */
static void uart_common_release_pins( const uart_pin_configuration * assigned_pins )
{
   16d0c:	b510      	push	{r4, lr}
   16d0e:	1e04      	subs	r4, r0, #0
    assert( assigned_pins != NULL );
   16d10:	d104      	bne.n	16d1c <uart_common_release_pins+0x10>
   16d12:	4671      	mov	r1, lr
   16d14:	2016      	movs	r0, #22
   16d16:	f7ea fefb 	bl	1b10 <panic>
            {
                (void)pio_release( assigned_pins->cts_pin );
            }
        }
    }
}
   16d1a:	bd10      	pop	{r4, pc}
        if( assigned_pins->rx_pin != PIN_NONE )
   16d1c:	7840      	ldrb	r0, [r0, #1]
   16d1e:	2828      	cmp	r0, #40	; 0x28
   16d20:	d006      	beq.n	16d30 <uart_common_release_pins+0x24>
            (void)pio_release( assigned_pins->rx_pin );
   16d22:	f001 faa4 	bl	1826e <pio_release>
            if( assigned_pins->rts_pin != PIN_NONE )
   16d26:	78e0      	ldrb	r0, [r4, #3]
   16d28:	2828      	cmp	r0, #40	; 0x28
   16d2a:	d001      	beq.n	16d30 <uart_common_release_pins+0x24>
                (void)pio_release( assigned_pins->rts_pin );
   16d2c:	f001 fa9f 	bl	1826e <pio_release>
        if( assigned_pins->tx_pin != PIN_NONE )
   16d30:	7820      	ldrb	r0, [r4, #0]
   16d32:	2828      	cmp	r0, #40	; 0x28
   16d34:	d0f1      	beq.n	16d1a <uart_common_release_pins+0xe>
            (void)pio_release( assigned_pins->tx_pin );
   16d36:	f001 fa9a 	bl	1826e <pio_release>
            if( assigned_pins->cts_pin != PIN_NONE )
   16d3a:	78a0      	ldrb	r0, [r4, #2]
   16d3c:	2828      	cmp	r0, #40	; 0x28
   16d3e:	d0ec      	beq.n	16d1a <uart_common_release_pins+0xe>
                (void)pio_release( assigned_pins->cts_pin );
   16d40:	f001 fa95 	bl	1826e <pio_release>
}
   16d44:	e7e9      	b.n	16d1a <uart_common_release_pins+0xe>

00016d46 <uart_common_release_peripheral>:

/*
 * Releases a UART, freeing it to be claimed by another process or core
 */
static void uart_common_release_peripheral( UART_BUS uart )
{
   16d46:	b510      	push	{r4, lr}
    assert( uart < UART_BUS_MAX_NUMBER );
   16d48:	2802      	cmp	r0, #2
   16d4a:	d904      	bls.n	16d56 <uart_common_release_peripheral+0x10>
   16d4c:	4671      	mov	r1, lr
   16d4e:	2016      	movs	r0, #22
   16d50:	f7ea fede 	bl	1b10 <panic>

    if( uart < UART_BUS_MAX_NUMBER )
    {
        hal_uart_release( uart );
    }
}
   16d54:	bd10      	pop	{r4, pc}
        hal_uart_release( uart );
   16d56:	f002 fd7d 	bl	19854 <hal_uart_release>
   16d5a:	e7fb      	b.n	16d54 <uart_common_release_peripheral+0xe>

00016d5c <uart_common_validate_pin_config>:
{
   16d5c:	b570      	push	{r4, r5, r6, lr}
   16d5e:	4671      	mov	r1, lr
    if( claim_pins == NULL )
   16d60:	2800      	cmp	r0, #0
   16d62:	d104      	bne.n	16d6e <uart_common_validate_pin_config+0x12>
        assert( false );
   16d64:	2016      	movs	r0, #22
   16d66:	f7ea fed3 	bl	1b10 <panic>
        return UART_COMMON_VALIDATE_PINS_INVALID_PARAMS;    //lint !e527 ignore unreachable code warning
   16d6a:	2001      	movs	r0, #1
}
   16d6c:	bd70      	pop	{r4, r5, r6, pc}
    if( (claim_pins->tx_pin == PIN_NONE) && (claim_pins->rx_pin == PIN_NONE) )
   16d6e:	7805      	ldrb	r5, [r0, #0]
   16d70:	2d28      	cmp	r5, #40	; 0x28
   16d72:	d10a      	bne.n	16d8a <uart_common_validate_pin_config+0x2e>
   16d74:	7843      	ldrb	r3, [r0, #1]
   16d76:	2b28      	cmp	r3, #40	; 0x28
   16d78:	d0f4      	beq.n	16d64 <uart_common_validate_pin_config+0x8>
    if( claim_pins->rx_pin > PIN_MAX_NUMBER )
   16d7a:	7844      	ldrb	r4, [r0, #1]
   16d7c:	2c28      	cmp	r4, #40	; 0x28
   16d7e:	d90b      	bls.n	16d98 <uart_common_validate_pin_config+0x3c>
        assert( false );
   16d80:	2016      	movs	r0, #22
   16d82:	f7ea fec5 	bl	1b10 <panic>
        return UART_COMMON_VALIDATE_PINS_INVALID_RX;    //lint !e527 ignore unreachable code warning
   16d86:	2003      	movs	r0, #3
   16d88:	e7f0      	b.n	16d6c <uart_common_validate_pin_config+0x10>
    if( claim_pins->tx_pin > PIN_MAX_NUMBER )
   16d8a:	2d28      	cmp	r5, #40	; 0x28
   16d8c:	d9f5      	bls.n	16d7a <uart_common_validate_pin_config+0x1e>
        assert( false );
   16d8e:	2016      	movs	r0, #22
   16d90:	f7ea febe 	bl	1b10 <panic>
        return UART_COMMON_VALIDATE_PINS_INVALID_TX;    //lint !e527 ignore unreachable code warning
   16d94:	2002      	movs	r0, #2
   16d96:	e7e9      	b.n	16d6c <uart_common_validate_pin_config+0x10>
    if( (claim_pins->rx_pin != PIN_NONE) && (claim_pins->rx_pin == claim_pins->tx_pin) )
   16d98:	2c28      	cmp	r4, #40	; 0x28
   16d9a:	d001      	beq.n	16da0 <uart_common_validate_pin_config+0x44>
   16d9c:	42a5      	cmp	r5, r4
   16d9e:	d0ef      	beq.n	16d80 <uart_common_validate_pin_config+0x24>
    if( claim_pins->rts_pin > PIN_MAX_NUMBER )
   16da0:	78c2      	ldrb	r2, [r0, #3]
   16da2:	2a28      	cmp	r2, #40	; 0x28
   16da4:	d904      	bls.n	16db0 <uart_common_validate_pin_config+0x54>
        assert( false );
   16da6:	2016      	movs	r0, #22
   16da8:	f7ea feb2 	bl	1b10 <panic>
        return UART_COMMON_VALIDATE_PINS_INVALID_RTS;    //lint !e527 ignore unreachable code warning
   16dac:	2004      	movs	r0, #4
   16dae:	e7dd      	b.n	16d6c <uart_common_validate_pin_config+0x10>
    if( (claim_pins->rts_pin != PIN_NONE) && ((claim_pins->rts_pin == claim_pins->tx_pin) || (claim_pins->rts_pin == claim_pins->rx_pin)) )
   16db0:	2a28      	cmp	r2, #40	; 0x28
   16db2:	d003      	beq.n	16dbc <uart_common_validate_pin_config+0x60>
   16db4:	4295      	cmp	r5, r2
   16db6:	d0f6      	beq.n	16da6 <uart_common_validate_pin_config+0x4a>
   16db8:	4294      	cmp	r4, r2
   16dba:	d0f4      	beq.n	16da6 <uart_common_validate_pin_config+0x4a>
    if( claim_pins->cts_pin > PIN_MAX_NUMBER )
   16dbc:	7883      	ldrb	r3, [r0, #2]
   16dbe:	2b28      	cmp	r3, #40	; 0x28
   16dc0:	d904      	bls.n	16dcc <uart_common_validate_pin_config+0x70>
        assert( false );
   16dc2:	2016      	movs	r0, #22
   16dc4:	f7ea fea4 	bl	1b10 <panic>
        return UART_COMMON_VALIDATE_PINS_INVALID_CTS;    //lint !e527 ignore unreachable code warning
   16dc8:	2005      	movs	r0, #5
   16dca:	e7cf      	b.n	16d6c <uart_common_validate_pin_config+0x10>
    return UART_COMMON_VALIDATE_PINS_OK;
   16dcc:	2000      	movs	r0, #0
    if( (claim_pins->cts_pin != PIN_NONE) && ((claim_pins->cts_pin == claim_pins->tx_pin) || (claim_pins->cts_pin == claim_pins->rx_pin)) )
   16dce:	2b28      	cmp	r3, #40	; 0x28
   16dd0:	d0cc      	beq.n	16d6c <uart_common_validate_pin_config+0x10>
   16dd2:	429d      	cmp	r5, r3
   16dd4:	d0f5      	beq.n	16dc2 <uart_common_validate_pin_config+0x66>
   16dd6:	429c      	cmp	r4, r3
   16dd8:	d0f3      	beq.n	16dc2 <uart_common_validate_pin_config+0x66>
    if( (claim_pins->cts_pin != PIN_NONE) && (claim_pins->cts_pin == claim_pins->rts_pin) )
   16dda:	429a      	cmp	r2, r3
   16ddc:	d1c6      	bne.n	16d6c <uart_common_validate_pin_config+0x10>
   16dde:	e7f0      	b.n	16dc2 <uart_common_validate_pin_config+0x66>

00016de0 <uart_common_claim>:
{
   16de0:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
   16de2:	4675      	mov	r5, lr
   16de4:	1e06      	subs	r6, r0, #0
    assert( claim_pins != NULL );
   16de6:	d103      	bne.n	16df0 <uart_common_claim+0x10>
   16de8:	4671      	mov	r1, lr
   16dea:	2016      	movs	r0, #22
   16dec:	f7ea fe90 	bl	1b10 <panic>
{
   16df0:	2400      	movs	r4, #0
        if( !hal_uart_is_claimed( uart ) )
   16df2:	0020      	movs	r0, r4
   16df4:	f002 fd22 	bl	1983c <hal_uart_is_claimed>
   16df8:	2800      	cmp	r0, #0
   16dfa:	d011      	beq.n	16e20 <uart_common_claim+0x40>
    for( UART_BUS uart = UART_BUS_0; uart < UART_BUS_MAX_NUMBER; uart++ )
   16dfc:	3401      	adds	r4, #1
   16dfe:	b2e4      	uxtb	r4, r4
   16e00:	2c03      	cmp	r4, #3
   16e02:	d1f6      	bne.n	16df2 <uart_common_claim+0x12>
    assert( false );
   16e04:	0029      	movs	r1, r5
   16e06:	2016      	movs	r0, #22
   16e08:	f7ea fe82 	bl	1b10 <panic>
    assert(uart < UART_BUS_MAX_NUMBER);
   16e0c:	0029      	movs	r1, r5
   16e0e:	2016      	movs	r0, #22
   16e10:	f7ea fe7e 	bl	1b10 <panic>
    assert(uart != UART_BUS_NONE);
   16e14:	0029      	movs	r1, r5
   16e16:	2016      	movs	r0, #22
   16e18:	f7ea fe7a 	bl	1b10 <panic>
   16e1c:	2403      	movs	r4, #3
    return uart;
   16e1e:	e02e      	b.n	16e7e <uart_common_claim+0x9e>
            if( hal_uart_claim( uart ) )
   16e20:	0020      	movs	r0, r4
   16e22:	f002 fcf3 	bl	1980c <hal_uart_claim>
   16e26:	2800      	cmp	r0, #0
   16e28:	d0e8      	beq.n	16dfc <uart_common_claim+0x1c>
    assert( claim_pins != NULL );
   16e2a:	2e00      	cmp	r6, #0
   16e2c:	d129      	bne.n	16e82 <uart_common_claim+0xa2>
   16e2e:	0029      	movs	r1, r5
   16e30:	2016      	movs	r0, #22
                assert( false );
   16e32:	f7ea fe6d 	bl	1b10 <panic>
            uart_common_release_pins( claim_pins );
   16e36:	0030      	movs	r0, r6
   16e38:	f7ff ff68 	bl	16d0c <uart_common_release_pins>
            uart_common_release_peripheral( uart );
   16e3c:	0020      	movs	r0, r4
   16e3e:	f7ff ff82 	bl	16d46 <uart_common_release_peripheral>
   16e42:	e7e7      	b.n	16e14 <uart_common_claim+0x34>
        if( claim_pins->rts_pin != PIN_NONE )
   16e44:	78f0      	ldrb	r0, [r6, #3]
   16e46:	2828      	cmp	r0, #40	; 0x28
   16e48:	d004      	beq.n	16e54 <uart_common_claim+0x74>
            if( !pio_set_function( claim_pins->rts_pin, pin_functions->rts_pin ) )
   16e4a:	78b9      	ldrb	r1, [r7, #2]
   16e4c:	f001 fa1a 	bl	18284 <pio_set_function>
   16e50:	2800      	cmp	r0, #0
   16e52:	d021      	beq.n	16e98 <uart_common_claim+0xb8>
    if( claim_pins->tx_pin != PIN_NONE )
   16e54:	7830      	ldrb	r0, [r6, #0]
   16e56:	2828      	cmp	r0, #40	; 0x28
   16e58:	d011      	beq.n	16e7e <uart_common_claim+0x9e>
        if( !pio_set_function( claim_pins->tx_pin, pin_functions->tx_pin ) )
   16e5a:	4f11      	ldr	r7, [pc, #68]	; (16ea0 <uart_common_claim+0xc0>)
   16e5c:	00a3      	lsls	r3, r4, #2
   16e5e:	5dd9      	ldrb	r1, [r3, r7]
   16e60:	9301      	str	r3, [sp, #4]
   16e62:	f001 fa0f 	bl	18284 <pio_set_function>
   16e66:	2800      	cmp	r0, #0
   16e68:	d016      	beq.n	16e98 <uart_common_claim+0xb8>
        if( claim_pins->cts_pin != PIN_NONE )
   16e6a:	78b0      	ldrb	r0, [r6, #2]
   16e6c:	2828      	cmp	r0, #40	; 0x28
   16e6e:	d006      	beq.n	16e7e <uart_common_claim+0x9e>
            if( !pio_set_function( claim_pins->cts_pin, pin_functions->cts_pin ) )
   16e70:	00a3      	lsls	r3, r4, #2
   16e72:	18ff      	adds	r7, r7, r3
   16e74:	78f9      	ldrb	r1, [r7, #3]
   16e76:	f001 fa05 	bl	18284 <pio_set_function>
   16e7a:	2800      	cmp	r0, #0
   16e7c:	d00c      	beq.n	16e98 <uart_common_claim+0xb8>
}
   16e7e:	0020      	movs	r0, r4
   16e80:	bdfe      	pop	{r1, r2, r3, r4, r5, r6, r7, pc}
    if( claim_pins->rx_pin != PIN_NONE )
   16e82:	7870      	ldrb	r0, [r6, #1]
   16e84:	2828      	cmp	r0, #40	; 0x28
   16e86:	d0e5      	beq.n	16e54 <uart_common_claim+0x74>
        if( !pio_set_function( claim_pins->rx_pin, pin_functions->rx_pin ) )
   16e88:	4f05      	ldr	r7, [pc, #20]	; (16ea0 <uart_common_claim+0xc0>)
   16e8a:	00a3      	lsls	r3, r4, #2
   16e8c:	18ff      	adds	r7, r7, r3
   16e8e:	7879      	ldrb	r1, [r7, #1]
   16e90:	f001 f9f8 	bl	18284 <pio_set_function>
   16e94:	2800      	cmp	r0, #0
   16e96:	d1d5      	bne.n	16e44 <uart_common_claim+0x64>
                assert( false );
   16e98:	0029      	movs	r1, r5
   16e9a:	3016      	adds	r0, #22
   16e9c:	e7c9      	b.n	16e32 <uart_common_claim+0x52>
   16e9e:	46c0      	nop			; (mov r8, r8)
   16ea0:	00025576 	.word	0x00025576

00016ea4 <uart_common_is_claimed>:
{
   16ea4:	b510      	push	{r4, lr}
    assert( uart < UART_BUS_MAX_NUMBER );
   16ea6:	2802      	cmp	r0, #2
   16ea8:	d905      	bls.n	16eb6 <uart_common_is_claimed+0x12>
   16eaa:	2016      	movs	r0, #22
   16eac:	4671      	mov	r1, lr
   16eae:	f7ea fe2f 	bl	1b10 <panic>
    return false;
   16eb2:	2000      	movs	r0, #0
}
   16eb4:	bd10      	pop	{r4, pc}
        return hal_uart_is_claimed( uart );
   16eb6:	f002 fcc1 	bl	1983c <hal_uart_is_claimed>
   16eba:	e7fb      	b.n	16eb4 <uart_common_is_claimed+0x10>

00016ebc <uart_common_release>:
{
   16ebc:	b570      	push	{r4, r5, r6, lr}
   16ebe:	4676      	mov	r6, lr
   16ec0:	0005      	movs	r5, r0
   16ec2:	000c      	movs	r4, r1
    assert( uart < UART_BUS_MAX_NUMBER );
   16ec4:	2802      	cmp	r0, #2
   16ec6:	d90a      	bls.n	16ede <uart_common_release+0x22>
   16ec8:	4671      	mov	r1, lr
   16eca:	2016      	movs	r0, #22
   16ecc:	f7ea fe20 	bl	1b10 <panic>
    assert( assigned_pins != NULL );
   16ed0:	2c00      	cmp	r4, #0
   16ed2:	d103      	bne.n	16edc <uart_common_release+0x20>
   16ed4:	0031      	movs	r1, r6
   16ed6:	2016      	movs	r0, #22
   16ed8:	f7ea fe1a 	bl	1b10 <panic>
}
   16edc:	bd70      	pop	{r4, r5, r6, pc}
    assert( assigned_pins != NULL );
   16ede:	2900      	cmp	r1, #0
   16ee0:	d0f8      	beq.n	16ed4 <uart_common_release+0x18>
        uart_common_release_pins( assigned_pins );
   16ee2:	0020      	movs	r0, r4
   16ee4:	f7ff ff12 	bl	16d0c <uart_common_release_pins>
        uart_common_release_peripheral( uart );
   16ee8:	0028      	movs	r0, r5
   16eea:	f7ff ff2c 	bl	16d46 <uart_common_release_peripheral>
}
   16eee:	e7f5      	b.n	16edc <uart_common_release+0x20>

00016ef0 <uart_common_configure_rx_interrupts>:
{
   16ef0:	b570      	push	{r4, r5, r6, lr}
   16ef2:	4676      	mov	r6, lr
   16ef4:	0005      	movs	r5, r0
   16ef6:	000c      	movs	r4, r1
    assert( uart < UART_BUS_MAX_NUMBER );
   16ef8:	2802      	cmp	r0, #2
   16efa:	d90a      	bls.n	16f12 <uart_common_configure_rx_interrupts+0x22>
   16efc:	4671      	mov	r1, lr
   16efe:	2016      	movs	r0, #22
   16f00:	f7ea fe06 	bl	1b10 <panic>
    assert( interrupt_handlers != NULL );
   16f04:	2c00      	cmp	r4, #0
   16f06:	d103      	bne.n	16f10 <uart_common_configure_rx_interrupts+0x20>
   16f08:	0031      	movs	r1, r6
   16f0a:	2016      	movs	r0, #22
   16f0c:	f7ea fe00 	bl	1b10 <panic>
}
   16f10:	bd70      	pop	{r4, r5, r6, pc}
    assert( interrupt_handlers != NULL );
   16f12:	2900      	cmp	r1, #0
   16f14:	d0f8      	beq.n	16f08 <uart_common_configure_rx_interrupts+0x18>
        hal_uart_configure_interrupt(uart, HAL_UART_INTERRUPT_RX,    interrupt_handlers->rx_isr,    INTERRUPT_STATE_DISABLED);
   16f16:	2300      	movs	r3, #0
   16f18:	6822      	ldr	r2, [r4, #0]
   16f1a:	0019      	movs	r1, r3
   16f1c:	0028      	movs	r0, r5
   16f1e:	f002 fd9d 	bl	19a5c <hal_uart_configure_interrupt>
        hal_uart_configure_interrupt(uart, HAL_UART_INTERRUPT_IDLE,  interrupt_handlers->idle_isr,  INTERRUPT_STATE_DISABLED);
   16f22:	68a2      	ldr	r2, [r4, #8]
   16f24:	0028      	movs	r0, r5
   16f26:	2300      	movs	r3, #0
   16f28:	2102      	movs	r1, #2
   16f2a:	f002 fd97 	bl	19a5c <hal_uart_configure_interrupt>
        hal_uart_configure_interrupt(uart, HAL_UART_INTERRUPT_ERROR, interrupt_handlers->error_isr, INTERRUPT_STATE_DISABLED);
   16f2e:	2300      	movs	r3, #0
   16f30:	68e2      	ldr	r2, [r4, #12]
   16f32:	2103      	movs	r1, #3
   16f34:	0028      	movs	r0, r5
   16f36:	f002 fd91 	bl	19a5c <hal_uart_configure_interrupt>
}
   16f3a:	e7e9      	b.n	16f10 <uart_common_configure_rx_interrupts+0x20>

00016f3c <uart_common_configure_tx_interrupts>:
{
   16f3c:	b570      	push	{r4, r5, r6, lr}
   16f3e:	4675      	mov	r5, lr
   16f40:	000c      	movs	r4, r1
    assert( uart < UART_BUS_MAX_NUMBER );
   16f42:	2802      	cmp	r0, #2
   16f44:	d90a      	bls.n	16f5c <uart_common_configure_tx_interrupts+0x20>
   16f46:	4671      	mov	r1, lr
   16f48:	2016      	movs	r0, #22
   16f4a:	f7ea fde1 	bl	1b10 <panic>
    assert( interrupt_handlers != NULL );
   16f4e:	2c00      	cmp	r4, #0
   16f50:	d103      	bne.n	16f5a <uart_common_configure_tx_interrupts+0x1e>
   16f52:	0029      	movs	r1, r5
   16f54:	2016      	movs	r0, #22
   16f56:	f7ea fddb 	bl	1b10 <panic>
}
   16f5a:	bd70      	pop	{r4, r5, r6, pc}
    assert( interrupt_handlers != NULL );
   16f5c:	2900      	cmp	r1, #0
   16f5e:	d0f8      	beq.n	16f52 <uart_common_configure_tx_interrupts+0x16>
        hal_uart_configure_interrupt(uart, HAL_UART_INTERRUPT_TX, interrupt_handlers->tx_isr, INTERRUPT_STATE_DISABLED);
   16f60:	2300      	movs	r3, #0
   16f62:	6862      	ldr	r2, [r4, #4]
   16f64:	2101      	movs	r1, #1
   16f66:	f002 fd79 	bl	19a5c <hal_uart_configure_interrupt>
}
   16f6a:	e7f6      	b.n	16f5a <uart_common_configure_tx_interrupts+0x1e>

00016f6c <uart_common_configure_line_settings>:
{
   16f6c:	b570      	push	{r4, r5, r6, lr}
   16f6e:	4676      	mov	r6, lr
   16f70:	0005      	movs	r5, r0
   16f72:	000c      	movs	r4, r1
    assert( uart < UART_BUS_MAX_NUMBER );
   16f74:	2802      	cmp	r0, #2
   16f76:	d90a      	bls.n	16f8e <uart_common_configure_line_settings+0x22>
   16f78:	4671      	mov	r1, lr
   16f7a:	2016      	movs	r0, #22
   16f7c:	f7ea fdc8 	bl	1b10 <panic>
    assert( line_config != NULL );
   16f80:	2c00      	cmp	r4, #0
   16f82:	d103      	bne.n	16f8c <uart_common_configure_line_settings+0x20>
   16f84:	0031      	movs	r1, r6
   16f86:	2016      	movs	r0, #22
   16f88:	f7ea fdc2 	bl	1b10 <panic>
}
   16f8c:	bd70      	pop	{r4, r5, r6, pc}
    assert( line_config != NULL );
   16f8e:	2900      	cmp	r1, #0
   16f90:	d0f8      	beq.n	16f84 <uart_common_configure_line_settings+0x18>
        hal_uart_set_baud_rate(uart, line_config->baud_rate);
   16f92:	6821      	ldr	r1, [r4, #0]
   16f94:	0028      	movs	r0, r5
   16f96:	f002 fcbf 	bl	19918 <hal_uart_set_baud_rate>
        hal_uart_set_data_bits(uart, line_config->data_bits);
   16f9a:	7921      	ldrb	r1, [r4, #4]
   16f9c:	0028      	movs	r0, r5
   16f9e:	f002 fcd7 	bl	19950 <hal_uart_set_data_bits>
        hal_uart_set_parity(uart, line_config->parity);
   16fa2:	7961      	ldrb	r1, [r4, #5]
   16fa4:	0028      	movs	r0, r5
   16fa6:	f002 fcf7 	bl	19998 <hal_uart_set_parity>
        hal_uart_set_stop_bits(uart, line_config->stop_bits);
   16faa:	79a1      	ldrb	r1, [r4, #6]
   16fac:	0028      	movs	r0, r5
   16fae:	f002 fce0 	bl	19972 <hal_uart_set_stop_bits>
}
   16fb2:	e7eb      	b.n	16f8c <uart_common_configure_line_settings+0x20>

00016fb4 <uart_common_disable_uart>:
{
   16fb4:	b510      	push	{r4, lr}
   16fb6:	0004      	movs	r4, r0
    assert( uart < UART_BUS_MAX_NUMBER );
   16fb8:	2802      	cmp	r0, #2
   16fba:	d904      	bls.n	16fc6 <uart_common_disable_uart+0x12>
   16fbc:	4671      	mov	r1, lr
   16fbe:	2016      	movs	r0, #22
   16fc0:	f7ea fda6 	bl	1b10 <panic>
}
   16fc4:	bd10      	pop	{r4, pc}
        hal_uart_disable_uart( uart );
   16fc6:	f002 fda6 	bl	19b16 <hal_uart_disable_uart>
        hal_uart_set_fifo( uart, HAL_UART_FIFO_ENABLED );                                                   // IOT-12145: TODO Not the correct place for this
   16fca:	0020      	movs	r0, r4
   16fcc:	2100      	movs	r1, #0
   16fce:	f002 fc5b 	bl	19888 <hal_uart_set_fifo>
        hal_uart_set_fifo_int_levels( uart, HAL_UART_FIFO_INT_LEVEL_1_2, HAL_UART_FIFO_INT_LEVEL_1_8 );     // IOT-12145: TODO Not the correct place for this
   16fd2:	2200      	movs	r2, #0
   16fd4:	2102      	movs	r1, #2
   16fd6:	0020      	movs	r0, r4
   16fd8:	f002 fc69 	bl	198ae <hal_uart_set_fifo_int_levels>
   16fdc:	e7f2      	b.n	16fc4 <uart_common_disable_uart+0x10>

00016fde <uart_common_enable_uart>:
{
   16fde:	b570      	push	{r4, r5, r6, lr}
   16fe0:	4675      	mov	r5, lr
   16fe2:	000c      	movs	r4, r1
    assert( uart < UART_BUS_MAX_NUMBER );
   16fe4:	2802      	cmp	r0, #2
   16fe6:	d90a      	bls.n	16ffe <uart_common_enable_uart+0x20>
   16fe8:	4671      	mov	r1, lr
   16fea:	2016      	movs	r0, #22
   16fec:	f7ea fd90 	bl	1b10 <panic>
    assert( uart_pin_config != NULL );
   16ff0:	2c00      	cmp	r4, #0
   16ff2:	d103      	bne.n	16ffc <uart_common_enable_uart+0x1e>
   16ff4:	0029      	movs	r1, r5
   16ff6:	2016      	movs	r0, #22
   16ff8:	f7ea fd8a 	bl	1b10 <panic>
}
   16ffc:	bd70      	pop	{r4, r5, r6, pc}
    assert( uart_pin_config != NULL );
   16ffe:	2900      	cmp	r1, #0
   17000:	d0f8      	beq.n	16ff4 <uart_common_enable_uart+0x16>
        uart_enable_flags |= (uart_pin_config->rx_pin != PIN_NONE) ? HAL_UART_ENABLE_FLAG_RX : HAL_UART_ENABLE_FLAG_NONE;
   17002:	7862      	ldrb	r2, [r4, #1]
   17004:	0011      	movs	r1, r2
   17006:	3928      	subs	r1, #40	; 0x28
   17008:	1e4b      	subs	r3, r1, #1
   1700a:	4199      	sbcs	r1, r3
        uart_enable_flags |= ((uart_pin_config->rx_pin != PIN_NONE) && (uart_pin_config->rts_pin != PIN_NONE)) ? HAL_UART_ENABLE_FLAG_RTS : HAL_UART_ENABLE_FLAG_NONE;
   1700c:	2300      	movs	r3, #0
        uart_enable_flags |= (uart_pin_config->rx_pin != PIN_NONE) ? HAL_UART_ENABLE_FLAG_RX : HAL_UART_ENABLE_FLAG_NONE;
   1700e:	b249      	sxtb	r1, r1
        uart_enable_flags |= ((uart_pin_config->rx_pin != PIN_NONE) && (uart_pin_config->rts_pin != PIN_NONE)) ? HAL_UART_ENABLE_FLAG_RTS : HAL_UART_ENABLE_FLAG_NONE;
   17010:	2a28      	cmp	r2, #40	; 0x28
   17012:	d004      	beq.n	1701e <uart_common_enable_uart+0x40>
   17014:	78e3      	ldrb	r3, [r4, #3]
   17016:	3b28      	subs	r3, #40	; 0x28
   17018:	1e5a      	subs	r2, r3, #1
   1701a:	4193      	sbcs	r3, r2
   1701c:	00db      	lsls	r3, r3, #3
        uart_enable_flags |= (uart_pin_config->tx_pin != PIN_NONE) ? HAL_UART_ENABLE_FLAG_TX : HAL_UART_ENABLE_FLAG_NONE;
   1701e:	7822      	ldrb	r2, [r4, #0]
        uart_enable_flags |= ((uart_pin_config->rx_pin != PIN_NONE) && (uart_pin_config->rts_pin != PIN_NONE)) ? HAL_UART_ENABLE_FLAG_RTS : HAL_UART_ENABLE_FLAG_NONE;
   17020:	4319      	orrs	r1, r3
        uart_enable_flags |= (uart_pin_config->tx_pin != PIN_NONE) ? HAL_UART_ENABLE_FLAG_TX : HAL_UART_ENABLE_FLAG_NONE;
   17022:	0013      	movs	r3, r2
   17024:	3b28      	subs	r3, #40	; 0x28
   17026:	1e5d      	subs	r5, r3, #1
   17028:	41ab      	sbcs	r3, r5
   1702a:	005b      	lsls	r3, r3, #1
   1702c:	4319      	orrs	r1, r3
        uart_enable_flags |= ((uart_pin_config->tx_pin != PIN_NONE) && (uart_pin_config->cts_pin != PIN_NONE)) ? HAL_UART_ENABLE_FLAG_CTS : HAL_UART_ENABLE_FLAG_NONE;
   1702e:	2300      	movs	r3, #0
   17030:	2a28      	cmp	r2, #40	; 0x28
   17032:	d004      	beq.n	1703e <uart_common_enable_uart+0x60>
   17034:	78a3      	ldrb	r3, [r4, #2]
   17036:	3b28      	subs	r3, #40	; 0x28
   17038:	1e5a      	subs	r2, r3, #1
   1703a:	4193      	sbcs	r3, r2
   1703c:	009b      	lsls	r3, r3, #2
        hal_uart_set_enable_uart( uart, uart_enable_flags );
   1703e:	4319      	orrs	r1, r3
   17040:	f002 fd7a 	bl	19b38 <hal_uart_set_enable_uart>
}
   17044:	e7da      	b.n	16ffc <uart_common_enable_uart+0x1e>

00017046 <clocks_get_core_clock>:
    return     ( cycles_in_last_period >= hal_clocks_ring_oscillator_get_low_target() )
            && ( cycles_in_last_period <= hal_clocks_ring_oscillator_get_high_target() );
}

uint32 clocks_get_core_clock(void)
{
   17046:	b510      	push	{r4, lr}
    return hal_clocks_get_core_clock_mid_value();
   17048:	f001 fecc 	bl	18de4 <hal_clocks_get_core_clock_mid_value>
}
   1704c:	bd10      	pop	{r4, pc}
	...

00017050 <gpio_any_interrupts_registered>:
 */
static bool gpio_any_interrupts_registered( void )
{
    for( uint16 i = 0; i < GPIO_PIN_FLAG_ARRAY_SIZE; i++ )
    {
        if( gpio_registered_interrupts[i] )
   17050:	4b04      	ldr	r3, [pc, #16]	; (17064 <gpio_any_interrupts_registered+0x14>)
        {
            return true;
   17052:	2001      	movs	r0, #1
        if( gpio_registered_interrupts[i] )
   17054:	681a      	ldr	r2, [r3, #0]
   17056:	2a00      	cmp	r2, #0
   17058:	d103      	bne.n	17062 <gpio_any_interrupts_registered+0x12>
   1705a:	6858      	ldr	r0, [r3, #4]
   1705c:	1e43      	subs	r3, r0, #1
   1705e:	4198      	sbcs	r0, r3
   17060:	b2c0      	uxtb	r0, r0
        }
    }

    return false;
}
   17062:	4770      	bx	lr
   17064:	010026d8 	.word	0x010026d8

00017068 <gpio_any_pins_claimed>:
 */
static bool gpio_any_pins_claimed( void )
{
    for( uint16 i = 0; i < GPIO_PIN_FLAG_ARRAY_SIZE; i++ )
    {
        if( gpio_claimed[i] )
   17068:	4b04      	ldr	r3, [pc, #16]	; (1707c <gpio_any_pins_claimed+0x14>)
        {
            return true;
   1706a:	2001      	movs	r0, #1
        if( gpio_claimed[i] )
   1706c:	681a      	ldr	r2, [r3, #0]
   1706e:	2a00      	cmp	r2, #0
   17070:	d103      	bne.n	1707a <gpio_any_pins_claimed+0x12>
   17072:	6858      	ldr	r0, [r3, #4]
   17074:	1e43      	subs	r3, r0, #1
   17076:	4198      	sbcs	r0, r3
   17078:	b2c0      	uxtb	r0, r0
        }
    }

    return false;
}
   1707a:	4770      	bx	lr
   1707c:	01002628 	.word	0x01002628

00017080 <gpio_bitget>:
/**
 * Obtains bit in a flag array
 * @return True if flag is set, false otherwise
 */
static bool gpio_bitget( const uint32 * loc, uint8 bit )
{
   17080:	b570      	push	{r4, r5, r6, lr}
   17082:	0005      	movs	r5, r0
   17084:	000c      	movs	r4, r1
    assert( (bit/32) < GPIO_PIN_FLAG_ARRAY_SIZE );
   17086:	293f      	cmp	r1, #63	; 0x3f
   17088:	d903      	bls.n	17092 <gpio_bitget+0x12>
   1708a:	4671      	mov	r1, lr
   1708c:	2016      	movs	r0, #22
   1708e:	f7ea fd3f 	bl	1b10 <panic>

    loc += bit / 32;
    bit %= 32;

    return( (*loc & BIT(bit)) != 0 );
   17092:	221f      	movs	r2, #31
    loc += bit / 32;
   17094:	0963      	lsrs	r3, r4, #5
    return( (*loc & BIT(bit)) != 0 );
   17096:	009b      	lsls	r3, r3, #2
   17098:	5958      	ldr	r0, [r3, r5]
   1709a:	4014      	ands	r4, r2
   1709c:	40e0      	lsrs	r0, r4
   1709e:	2301      	movs	r3, #1
   170a0:	4018      	ands	r0, r3
}
   170a2:	bd70      	pop	{r4, r5, r6, pc}

000170a4 <gpio_bitclr>:

/**
 * Clears bit in a flag array
 */
static void gpio_bitclr( uint32 * loc, uint8 bit )
{
   170a4:	b570      	push	{r4, r5, r6, lr}
   170a6:	0006      	movs	r6, r0
   170a8:	000c      	movs	r4, r1
    assert( (bit/32) < GPIO_PIN_FLAG_ARRAY_SIZE );
   170aa:	293f      	cmp	r1, #63	; 0x3f
   170ac:	d903      	bls.n	170b6 <gpio_bitclr+0x12>
   170ae:	4671      	mov	r1, lr
   170b0:	2016      	movs	r0, #22
   170b2:	f7ea fd2d 	bl	1b10 <panic>

    loc += bit / 32;
    bit %= 32;

    non_os_enter_critical();
   170b6:	f001 f87d 	bl	181b4 <non_os_enter_critical>
    *loc &= ~BIT(bit);
   170ba:	231f      	movs	r3, #31
    loc += bit / 32;
   170bc:	0965      	lsrs	r5, r4, #5
    *loc &= ~BIT(bit);
   170be:	401c      	ands	r4, r3
   170c0:	3b1e      	subs	r3, #30
   170c2:	40a3      	lsls	r3, r4
    loc += bit / 32;
   170c4:	00ad      	lsls	r5, r5, #2
   170c6:	1975      	adds	r5, r6, r5
    *loc &= ~BIT(bit);
   170c8:	682a      	ldr	r2, [r5, #0]
   170ca:	439a      	bics	r2, r3
   170cc:	602a      	str	r2, [r5, #0]
    non_os_exit_critical();
   170ce:	f001 f885 	bl	181dc <non_os_exit_critical>
}
   170d2:	bd70      	pop	{r4, r5, r6, pc}

000170d4 <gpio_bitset>:
{
   170d4:	b570      	push	{r4, r5, r6, lr}
   170d6:	0006      	movs	r6, r0
   170d8:	000c      	movs	r4, r1
    assert( (bit/32) < GPIO_PIN_FLAG_ARRAY_SIZE );
   170da:	293f      	cmp	r1, #63	; 0x3f
   170dc:	d903      	bls.n	170e6 <gpio_bitset+0x12>
   170de:	4671      	mov	r1, lr
   170e0:	2016      	movs	r0, #22
   170e2:	f7ea fd15 	bl	1b10 <panic>
    non_os_enter_critical();
   170e6:	f001 f865 	bl	181b4 <non_os_enter_critical>
    *loc |= BIT(bit);
   170ea:	231f      	movs	r3, #31
    loc += bit / 32;
   170ec:	0965      	lsrs	r5, r4, #5
    *loc |= BIT(bit);
   170ee:	401c      	ands	r4, r3
   170f0:	3b1e      	subs	r3, #30
   170f2:	40a3      	lsls	r3, r4
    loc += bit / 32;
   170f4:	00ad      	lsls	r5, r5, #2
   170f6:	1975      	adds	r5, r6, r5
    *loc |= BIT(bit);
   170f8:	682a      	ldr	r2, [r5, #0]
   170fa:	4313      	orrs	r3, r2
   170fc:	602b      	str	r3, [r5, #0]
    non_os_exit_critical();
   170fe:	f001 f86d 	bl	181dc <non_os_exit_critical>
}
   17102:	bd70      	pop	{r4, r5, r6, pc}

00017104 <gpio_init>:
{
    NVIC_DisableIRQ(GPIO_IRQn);
}

void gpio_init(void)
{
   17104:	b510      	push	{r4, lr}
    uint16 i;

    if (non_os_is_driver_initialised(DRIVER_INIT_GPIO) == true)
   17106:	2004      	movs	r0, #4
   17108:	f001 f87c 	bl	18204 <non_os_is_driver_initialised>
   1710c:	2800      	cmp	r0, #0
   1710e:	d11c      	bne.n	1714a <gpio_init+0x46>
    {
        return;
    }

    if (non_os_is_driver_initialised(DRIVER_INIT_PIO) != true)
   17110:	3003      	adds	r0, #3
   17112:	f001 f877 	bl	18204 <non_os_is_driver_initialised>
   17116:	2800      	cmp	r0, #0
   17118:	d101      	bne.n	1711e <gpio_init+0x1a>
    {
        pio_init();
   1711a:	f001 f89b 	bl	18254 <pio_init>
{
   1711e:	2200      	movs	r2, #0
    }

    // Initialise all internal state.
    for ( i = 0; i < PIN_MAX_NUMBER; i++)
    {
        gpio_handlers[i] = NULL;
   17120:	0013      	movs	r3, r2
   17122:	480a      	ldr	r0, [pc, #40]	; (1714c <gpio_init+0x48>)
   17124:	0091      	lsls	r1, r2, #2
   17126:	1809      	adds	r1, r1, r0
   17128:	3201      	adds	r2, #1
   1712a:	600b      	str	r3, [r1, #0]
    for ( i = 0; i < PIN_MAX_NUMBER; i++)
   1712c:	2a28      	cmp	r2, #40	; 0x28
   1712e:	d1f9      	bne.n	17124 <gpio_init+0x20>
    }

    // Mark every GPIO as unclaimed
    for( i = 0; i < GPIO_PIN_FLAG_ARRAY_SIZE; i++ )
    {
        gpio_claimed[i] = 0;
   17130:	4807      	ldr	r0, [pc, #28]	; (17150 <gpio_init+0x4c>)
        gpio_direction[i] = 0;
   17132:	4908      	ldr	r1, [pc, #32]	; (17154 <gpio_init+0x50>)
        gpio_registered_interrupts[i] = 0;
   17134:	4a08      	ldr	r2, [pc, #32]	; (17158 <gpio_init+0x54>)
        gpio_claimed[i] = 0;
   17136:	6003      	str	r3, [r0, #0]
        gpio_direction[i] = 0;
   17138:	600b      	str	r3, [r1, #0]
        gpio_claimed[i] = 0;
   1713a:	6043      	str	r3, [r0, #4]
        gpio_direction[i] = 0;
   1713c:	604b      	str	r3, [r1, #4]
    }

    non_os_set_driver_initalised(DRIVER_INIT_GPIO, true);
   1713e:	2004      	movs	r0, #4
   17140:	2101      	movs	r1, #1
        gpio_registered_interrupts[i] = 0;
   17142:	6013      	str	r3, [r2, #0]
   17144:	6053      	str	r3, [r2, #4]
    non_os_set_driver_initalised(DRIVER_INIT_GPIO, true);
   17146:	f001 f867 	bl	18218 <non_os_set_driver_initalised>
}
   1714a:	bd10      	pop	{r4, pc}
   1714c:	01002638 	.word	0x01002638
   17150:	01002628 	.word	0x01002628
   17154:	01002630 	.word	0x01002630
   17158:	010026d8 	.word	0x010026d8

0001715c <gpio_claim>:
}

//lint -esym(457, gpio_claim)
//lint -esym(457, gpio_release)
bool gpio_claim(PIN pin, GPIO_DIRECTION dir)
{
   1715c:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
   1715e:	0004      	movs	r4, r0
    assert(non_os_is_driver_initialised(DRIVER_INIT_GPIO) == true);
   17160:	2004      	movs	r0, #4
   17162:	4675      	mov	r5, lr
{
   17164:	000e      	movs	r6, r1
    assert(non_os_is_driver_initialised(DRIVER_INIT_GPIO) == true);
   17166:	f001 f84d 	bl	18204 <non_os_is_driver_initialised>
   1716a:	2800      	cmp	r0, #0
   1716c:	d103      	bne.n	17176 <gpio_claim+0x1a>
   1716e:	0029      	movs	r1, r5
   17170:	3016      	adds	r0, #22
   17172:	f7ea fccd 	bl	1b10 <panic>

    if (non_os_is_driver_initialised(DRIVER_INIT_GPIO) == false)
   17176:	2004      	movs	r0, #4
   17178:	f001 f844 	bl	18204 <non_os_is_driver_initialised>
   1717c:	1e05      	subs	r5, r0, #0
   1717e:	d00b      	beq.n	17198 <gpio_claim+0x3c>
    {
        return false;
    }

    non_os_enter_critical();
   17180:	f001 f818 	bl	181b4 <non_os_enter_critical>

    // Claim the PIN as GPIO
    if( gpio_bitget( gpio_claimed, pin ) || !pio_set_function(pin, FUNC_GPIO) )
   17184:	4f1b      	ldr	r7, [pc, #108]	; (171f4 <gpio_claim+0x98>)
   17186:	0021      	movs	r1, r4
   17188:	0038      	movs	r0, r7
   1718a:	f7ff ff79 	bl	17080 <gpio_bitget>
   1718e:	2800      	cmp	r0, #0
   17190:	d004      	beq.n	1719c <gpio_claim+0x40>
    {
        non_os_exit_critical();
   17192:	f001 f823 	bl	181dc <non_os_exit_critical>
        return false;
   17196:	2500      	movs	r5, #0
    // Set the internal state
    gpio_bitset( gpio_claimed, pin );

    non_os_exit_critical();
    return true;
}
   17198:	0028      	movs	r0, r5
   1719a:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    if( gpio_bitget( gpio_claimed, pin ) || !pio_set_function(pin, FUNC_GPIO) )
   1719c:	2101      	movs	r1, #1
   1719e:	0020      	movs	r0, r4
   171a0:	f001 f870 	bl	18284 <pio_set_function>
   171a4:	1e05      	subs	r5, r0, #0
   171a6:	d0f4      	beq.n	17192 <gpio_claim+0x36>
    hal_gpio_disable_all_interrupts(pin);
   171a8:	0020      	movs	r0, r4
   171aa:	f001 fbad 	bl	18908 <hal_gpio_disable_all_interrupts>
    hal_gpio_config_dir(pin, dir);
   171ae:	0031      	movs	r1, r6
   171b0:	0020      	movs	r0, r4
   171b2:	f001 fb97 	bl	188e4 <hal_gpio_config_dir>
    if (dir == GPIO_DIRECTION_INPUT)
   171b6:	2e00      	cmp	r6, #0
   171b8:	d10e      	bne.n	171d8 <gpio_claim+0x7c>
        pio_input_config(pin, &gpio_input_default_config);
   171ba:	490f      	ldr	r1, [pc, #60]	; (171f8 <gpio_claim+0x9c>)
   171bc:	0020      	movs	r0, r4
   171be:	f001 f870 	bl	182a2 <pio_input_config>
        gpio_bitclr( gpio_direction, pin );
   171c2:	0021      	movs	r1, r4
   171c4:	480d      	ldr	r0, [pc, #52]	; (171fc <gpio_claim+0xa0>)
   171c6:	f7ff ff6d 	bl	170a4 <gpio_bitclr>
    gpio_bitset( gpio_claimed, pin );
   171ca:	0021      	movs	r1, r4
   171cc:	0038      	movs	r0, r7
   171ce:	f7ff ff81 	bl	170d4 <gpio_bitset>
    non_os_exit_critical();
   171d2:	f001 f803 	bl	181dc <non_os_exit_critical>
    return true;
   171d6:	e7df      	b.n	17198 <gpio_claim+0x3c>
    else if (dir == GPIO_DIRECTION_OUTPUT)
   171d8:	2e01      	cmp	r6, #1
   171da:	d1f6      	bne.n	171ca <gpio_claim+0x6e>
        hal_gpio_clear(pin);
   171dc:	0020      	movs	r0, r4
   171de:	f001 fb8e 	bl	188fe <hal_gpio_clear>
        pio_output_config(pin, &gpio_output_default_config);
   171e2:	0020      	movs	r0, r4
   171e4:	4906      	ldr	r1, [pc, #24]	; (17200 <gpio_claim+0xa4>)
   171e6:	f001 f851 	bl	1828c <pio_output_config>
        gpio_bitset( gpio_direction, pin );
   171ea:	0021      	movs	r1, r4
   171ec:	4803      	ldr	r0, [pc, #12]	; (171fc <gpio_claim+0xa0>)
   171ee:	f7ff ff71 	bl	170d4 <gpio_bitset>
   171f2:	e7ea      	b.n	171ca <gpio_claim+0x6e>
   171f4:	01002628 	.word	0x01002628
   171f8:	00025582 	.word	0x00025582
   171fc:	01002630 	.word	0x01002630
   17200:	00025583 	.word	0x00025583

00017204 <gpio_release>:

void gpio_release(PIN pin)
{
   17204:	b570      	push	{r4, r5, r6, lr}
   17206:	0004      	movs	r4, r0
    assert(non_os_is_driver_initialised(DRIVER_INIT_GPIO) == true);
   17208:	2004      	movs	r0, #4
   1720a:	4676      	mov	r6, lr
   1720c:	f000 fffa 	bl	18204 <non_os_is_driver_initialised>
   17210:	2800      	cmp	r0, #0
   17212:	d103      	bne.n	1721c <gpio_release+0x18>
   17214:	0031      	movs	r1, r6
   17216:	3016      	adds	r0, #22
   17218:	f7ea fc7a 	bl	1b10 <panic>
    assert( gpio_bitget( gpio_claimed, pin ) );   // pin has been claimed
   1721c:	4d0c      	ldr	r5, [pc, #48]	; (17250 <gpio_release+0x4c>)
   1721e:	0021      	movs	r1, r4
   17220:	0028      	movs	r0, r5
   17222:	f7ff ff2d 	bl	17080 <gpio_bitget>
   17226:	2800      	cmp	r0, #0
   17228:	d103      	bne.n	17232 <gpio_release+0x2e>
   1722a:	0031      	movs	r1, r6
   1722c:	3016      	adds	r0, #22
   1722e:	f7ea fc6f 	bl	1b10 <panic>

    non_os_enter_critical();
   17232:	f000 ffbf 	bl	181b4 <non_os_enter_critical>

    // Disable the interrupts
    hal_gpio_disable_all_interrupts(pin);
   17236:	0020      	movs	r0, r4
   17238:	f001 fb66 	bl	18908 <hal_gpio_disable_all_interrupts>
    // Release the PIN
    (void)pio_release(pin);
   1723c:	0020      	movs	r0, r4
   1723e:	f001 f816 	bl	1826e <pio_release>
    // Set the internal state
    gpio_bitclr( gpio_claimed, pin );
   17242:	0028      	movs	r0, r5
   17244:	0021      	movs	r1, r4
   17246:	f7ff ff2d 	bl	170a4 <gpio_bitclr>

    non_os_exit_critical();
   1724a:	f000 ffc7 	bl	181dc <non_os_exit_critical>
}
   1724e:	bd70      	pop	{r4, r5, r6, pc}
   17250:	01002628 	.word	0x01002628

00017254 <gpio_set>:

void gpio_set(PIN pin)
{
   17254:	b570      	push	{r4, r5, r6, lr}
   17256:	0004      	movs	r4, r0
    assert(non_os_is_driver_initialised(DRIVER_INIT_GPIO) == true);
   17258:	2004      	movs	r0, #4
   1725a:	4675      	mov	r5, lr
   1725c:	f000 ffd2 	bl	18204 <non_os_is_driver_initialised>
   17260:	2800      	cmp	r0, #0
   17262:	d103      	bne.n	1726c <gpio_set+0x18>
   17264:	0029      	movs	r1, r5
   17266:	3016      	adds	r0, #22
   17268:	f7ea fc52 	bl	1b10 <panic>
    assert( gpio_bitget( gpio_claimed, pin ) );                          // pin has been claimed
   1726c:	0021      	movs	r1, r4
   1726e:	480b      	ldr	r0, [pc, #44]	; (1729c <gpio_set+0x48>)
   17270:	f7ff ff06 	bl	17080 <gpio_bitget>
   17274:	2800      	cmp	r0, #0
   17276:	d103      	bne.n	17280 <gpio_set+0x2c>
   17278:	0029      	movs	r1, r5
   1727a:	3016      	adds	r0, #22
   1727c:	f7ea fc48 	bl	1b10 <panic>
    assert( gpio_bitget( gpio_direction, pin ) == GPIO_DIR_FLAG_OUT );   // pin is an output
   17280:	0021      	movs	r1, r4
   17282:	4807      	ldr	r0, [pc, #28]	; (172a0 <gpio_set+0x4c>)
   17284:	f7ff fefc 	bl	17080 <gpio_bitget>
   17288:	2800      	cmp	r0, #0
   1728a:	d103      	bne.n	17294 <gpio_set+0x40>
   1728c:	0029      	movs	r1, r5
   1728e:	3016      	adds	r0, #22
   17290:	f7ea fc3e 	bl	1b10 <panic>
    hal_gpio_set(pin);
   17294:	0020      	movs	r0, r4
   17296:	f001 fb2d 	bl	188f4 <hal_gpio_set>
}
   1729a:	bd70      	pop	{r4, r5, r6, pc}
   1729c:	01002628 	.word	0x01002628
   172a0:	01002630 	.word	0x01002630

000172a4 <gpio_clear>:

void gpio_clear(PIN pin)
{
   172a4:	b570      	push	{r4, r5, r6, lr}
   172a6:	0004      	movs	r4, r0
    assert(non_os_is_driver_initialised(DRIVER_INIT_GPIO) == true);
   172a8:	2004      	movs	r0, #4
   172aa:	4675      	mov	r5, lr
   172ac:	f000 ffaa 	bl	18204 <non_os_is_driver_initialised>
   172b0:	2800      	cmp	r0, #0
   172b2:	d103      	bne.n	172bc <gpio_clear+0x18>
   172b4:	0029      	movs	r1, r5
   172b6:	3016      	adds	r0, #22
   172b8:	f7ea fc2a 	bl	1b10 <panic>
    assert( gpio_bitget( gpio_claimed, pin ) == true );                  // pin has been claimed
   172bc:	0021      	movs	r1, r4
   172be:	480b      	ldr	r0, [pc, #44]	; (172ec <gpio_clear+0x48>)
   172c0:	f7ff fede 	bl	17080 <gpio_bitget>
   172c4:	2800      	cmp	r0, #0
   172c6:	d103      	bne.n	172d0 <gpio_clear+0x2c>
   172c8:	0029      	movs	r1, r5
   172ca:	3016      	adds	r0, #22
   172cc:	f7ea fc20 	bl	1b10 <panic>
    assert( gpio_bitget( gpio_direction, pin ) == GPIO_DIR_FLAG_OUT );   // pin is an output
   172d0:	0021      	movs	r1, r4
   172d2:	4807      	ldr	r0, [pc, #28]	; (172f0 <gpio_clear+0x4c>)
   172d4:	f7ff fed4 	bl	17080 <gpio_bitget>
   172d8:	2800      	cmp	r0, #0
   172da:	d103      	bne.n	172e4 <gpio_clear+0x40>
   172dc:	0029      	movs	r1, r5
   172de:	3016      	adds	r0, #22
   172e0:	f7ea fc16 	bl	1b10 <panic>
    hal_gpio_clear (pin);
   172e4:	0020      	movs	r0, r4
   172e6:	f001 fb0a 	bl	188fe <hal_gpio_clear>
}
   172ea:	bd70      	pop	{r4, r5, r6, pc}
   172ec:	01002628 	.word	0x01002628
   172f0:	01002630 	.word	0x01002630

000172f4 <IRQ_GPIO_Handler>:
    non_os_exit_critical();  /* End of critical section */
}

//lint -esym(459, IRQ_GPIO_Handler)
void IRQ_GPIO_Handler(void)
{
   172f4:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    // This ISR is triggered if any of the GPIOs is triggered by any of the conditions.
    // Iterate through the PINs opened as GPIOs
    PIN pin_i;

    assert( non_os_is_driver_initialised(DRIVER_INIT_GPIO) );
   172f6:	2004      	movs	r0, #4
   172f8:	4675      	mov	r5, lr
   172fa:	f000 ff83 	bl	18204 <non_os_is_driver_initialised>
   172fe:	2800      	cmp	r0, #0
   17300:	d103      	bne.n	1730a <IRQ_GPIO_Handler+0x16>
   17302:	0029      	movs	r1, r5
   17304:	3016      	adds	r0, #22
   17306:	f7ea fc03 	bl	1b10 <panic>
    assert( gpio_any_pins_claimed() );                            // at least one GPIO claimed
   1730a:	f7ff fead 	bl	17068 <gpio_any_pins_claimed>
   1730e:	2800      	cmp	r0, #0
   17310:	d103      	bne.n	1731a <IRQ_GPIO_Handler+0x26>
   17312:	0029      	movs	r1, r5
   17314:	3016      	adds	r0, #22
   17316:	f7ea fbfb 	bl	1b10 <panic>
        if( (dir == GPIO_DIRECTION_INPUT) && ((gpio_claimed[i] & ~gpio_direction[i]) != 0) )
   1731a:	4e27      	ldr	r6, [pc, #156]	; (173b8 <IRQ_GPIO_Handler+0xc4>)
   1731c:	4c27      	ldr	r4, [pc, #156]	; (173bc <IRQ_GPIO_Handler+0xc8>)
   1731e:	6832      	ldr	r2, [r6, #0]
   17320:	6823      	ldr	r3, [r4, #0]
   17322:	4393      	bics	r3, r2
   17324:	d107      	bne.n	17336 <IRQ_GPIO_Handler+0x42>
   17326:	6863      	ldr	r3, [r4, #4]
   17328:	6872      	ldr	r2, [r6, #4]
   1732a:	4393      	bics	r3, r2
   1732c:	d103      	bne.n	17336 <IRQ_GPIO_Handler+0x42>
    assert( gpio_any_pins_claimed_as( GPIO_DIRECTION_INPUT ) );   // at least one GPIO claimed as read
   1732e:	0029      	movs	r1, r5
   17330:	2016      	movs	r0, #22
   17332:	f7ea fbed 	bl	1b10 <panic>
    assert( gpio_any_interrupts_registered() );                   // at least one GPIO has registered interrupts
   17336:	f7ff fe8b 	bl	17050 <gpio_any_interrupts_registered>
   1733a:	2800      	cmp	r0, #0
   1733c:	d103      	bne.n	17346 <IRQ_GPIO_Handler+0x52>
   1733e:	0029      	movs	r1, r5
   17340:	3016      	adds	r0, #22
   17342:	f7ea fbe5 	bl	1b10 <panic>

    if( !non_os_is_driver_initialised(DRIVER_INIT_GPIO) ||
   17346:	2004      	movs	r0, #4
   17348:	f000 ff5c 	bl	18204 <non_os_is_driver_initialised>
   1734c:	2800      	cmp	r0, #0
   1734e:	d032      	beq.n	173b6 <IRQ_GPIO_Handler+0xc2>
        !gpio_any_pins_claimed() ||
   17350:	f7ff fe8a 	bl	17068 <gpio_any_pins_claimed>
    if( !non_os_is_driver_initialised(DRIVER_INIT_GPIO) ||
   17354:	2800      	cmp	r0, #0
   17356:	d02e      	beq.n	173b6 <IRQ_GPIO_Handler+0xc2>
        if( (dir == GPIO_DIRECTION_INPUT) && ((gpio_claimed[i] & ~gpio_direction[i]) != 0) )
   17358:	6823      	ldr	r3, [r4, #0]
   1735a:	6832      	ldr	r2, [r6, #0]
   1735c:	4393      	bics	r3, r2
   1735e:	d103      	bne.n	17368 <IRQ_GPIO_Handler+0x74>
   17360:	6872      	ldr	r2, [r6, #4]
   17362:	6863      	ldr	r3, [r4, #4]
   17364:	4393      	bics	r3, r2
   17366:	d026      	beq.n	173b6 <IRQ_GPIO_Handler+0xc2>
        !gpio_any_pins_claimed_as( GPIO_DIRECTION_INPUT ) ||
        !gpio_any_interrupts_registered() )
   17368:	f7ff fe72 	bl	17050 <gpio_any_interrupts_registered>
        !gpio_any_pins_claimed_as( GPIO_DIRECTION_INPUT ) ||
   1736c:	2800      	cmp	r0, #0
   1736e:	d022      	beq.n	173b6 <IRQ_GPIO_Handler+0xc2>
   17370:	2400      	movs	r4, #0
   17372:	b2e6      	uxtb	r6, r4
        return;
    }

    for( pin_i = PIN_0; pin_i < PIN_MAX_NUMBER; pin_i++ )
    {
        if( hal_gpio_is_interrupt_asserted(pin_i) )
   17374:	0030      	movs	r0, r6
   17376:	f001 fae1 	bl	1893c <hal_gpio_is_interrupt_asserted>
   1737a:	2800      	cmp	r0, #0
   1737c:	d018      	beq.n	173b0 <IRQ_GPIO_Handler+0xbc>
        {
            assert( gpio_bitget( gpio_registered_interrupts, pin_i ) );
   1737e:	4f10      	ldr	r7, [pc, #64]	; (173c0 <IRQ_GPIO_Handler+0xcc>)
   17380:	0031      	movs	r1, r6
   17382:	0038      	movs	r0, r7
   17384:	f7ff fe7c 	bl	17080 <gpio_bitget>
   17388:	2800      	cmp	r0, #0
   1738a:	d103      	bne.n	17394 <IRQ_GPIO_Handler+0xa0>
   1738c:	0029      	movs	r1, r5
   1738e:	3016      	adds	r0, #22
   17390:	f7ea fbbe 	bl	1b10 <panic>
            hal_gpio_clear_interrupt(pin_i);
   17394:	0030      	movs	r0, r6
   17396:	f001 facd 	bl	18934 <hal_gpio_clear_interrupt>

            if( gpio_bitget( gpio_registered_interrupts, pin_i ) )
   1739a:	0031      	movs	r1, r6
   1739c:	0038      	movs	r0, r7
   1739e:	f7ff fe6f 	bl	17080 <gpio_bitget>
   173a2:	2800      	cmp	r0, #0
   173a4:	d004      	beq.n	173b0 <IRQ_GPIO_Handler+0xbc>
            {
                gpio_handlers[pin_i](pin_i);
   173a6:	4a07      	ldr	r2, [pc, #28]	; (173c4 <IRQ_GPIO_Handler+0xd0>)
   173a8:	00a3      	lsls	r3, r4, #2
   173aa:	58d3      	ldr	r3, [r2, r3]
   173ac:	0030      	movs	r0, r6
   173ae:	4798      	blx	r3
   173b0:	3401      	adds	r4, #1
    for( pin_i = PIN_0; pin_i < PIN_MAX_NUMBER; pin_i++ )
   173b2:	2c28      	cmp	r4, #40	; 0x28
   173b4:	d1dd      	bne.n	17372 <IRQ_GPIO_Handler+0x7e>
            }
        }
    }
}
   173b6:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
   173b8:	01002630 	.word	0x01002630
   173bc:	01002628 	.word	0x01002628
   173c0:	010026d8 	.word	0x010026d8
   173c4:	01002638 	.word	0x01002638

000173c8 <ipc_init>:

/*
 * Initialise the internal variables.
 */
void ipc_init (void)
{
   173c8:	b510      	push	{r4, lr}
    if (non_os_is_driver_initialised(DRIVER_INIT_IPC) == true)
   173ca:	2005      	movs	r0, #5
   173cc:	f000 ff1a 	bl	18204 <non_os_is_driver_initialised>
   173d0:	1e01      	subs	r1, r0, #0
   173d2:	d109      	bne.n	173e8 <ipc_init+0x20>

    // First real opportunity to check that the IPC mailboxes fit in the region allocated for them by the linker.
    assert ((sizeof (ipc_mailbox_entry) * (IPC_NUM_MAILBOX)) <= MESSAGE_QUEUE_RESERVE_LENGTH);

    // Clear array of handlers (callbacks).
    memset (ipc_handlers, 0, sizeof (ipc_action_handler) * IPC_ACTION_NUM_ACTIONS);
   173d4:	2224      	movs	r2, #36	; 0x24
   173d6:	4805      	ldr	r0, [pc, #20]	; (173ec <ipc_init+0x24>)
   173d8:	f7e8 ff82 	bl	2e0 <memset>

    // Finally enable IPC related interrupts on this core.
    hal_ipc_init_interrupts ();
   173dc:	f002 fc86 	bl	19cec <hal_ipc_init_interrupts>

    non_os_set_driver_initalised(DRIVER_INIT_IPC, true);
   173e0:	2101      	movs	r1, #1
   173e2:	2005      	movs	r0, #5
   173e4:	f000 ff18 	bl	18218 <non_os_set_driver_initalised>
}
   173e8:	bd10      	pop	{r4, pc}
   173ea:	46c0      	nop			; (mov r8, r8)
   173ec:	010026e4 	.word	0x010026e4

000173f0 <ipc_deinit>:

/*
 * Disable interrupts to turn off IPC
 */
void ipc_deinit (void)
{
   173f0:	b510      	push	{r4, lr}
    non_os_set_driver_initalised(DRIVER_INIT_IPC, false);
   173f2:	2100      	movs	r1, #0
   173f4:	2005      	movs	r0, #5
   173f6:	f000 ff0f 	bl	18218 <non_os_set_driver_initalised>
    hal_ipc_deinit_interrupts ();
   173fa:	f002 fc95 	bl	19d28 <hal_ipc_deinit_interrupts>
}
   173fe:	bd10      	pop	{r4, pc}

00017400 <ipc_register_handler>:

/*
 * Add a callback to the handler array.
 */
IPC_STATUS ipc_register_handler (IPC_ACTION action, ipc_action_handler handler)
{
   17400:	b570      	push	{r4, r5, r6, lr}
   17402:	4675      	mov	r5, lr
   17404:	000c      	movs	r4, r1
    assert (action < IPC_ACTION_NUM_ACTIONS);
   17406:	2808      	cmp	r0, #8
   17408:	d90c      	bls.n	17424 <ipc_register_handler+0x24>
   1740a:	4671      	mov	r1, lr
   1740c:	2016      	movs	r0, #22
   1740e:	f7ea fb7f 	bl	1b10 <panic>
    assert (handler != NULL);
   17412:	2c00      	cmp	r4, #0
   17414:	d00e      	beq.n	17434 <ipc_register_handler+0x34>

    if (action >= IPC_ACTION_NUM_ACTIONS)
    {
        return IPC_STATUS_INVALID_ACTION;
   17416:	2001      	movs	r0, #1
   17418:	e00b      	b.n	17432 <ipc_register_handler+0x32>
    {
        return IPC_STATUS_INVALID_HANDLER;
    }

    // Simply update the entry.
    ipc_handlers [action] = handler;
   1741a:	4b09      	ldr	r3, [pc, #36]	; (17440 <ipc_register_handler+0x40>)
   1741c:	0080      	lsls	r0, r0, #2
   1741e:	50c4      	str	r4, [r0, r3]

    return IPC_STATUS_OK;
   17420:	2000      	movs	r0, #0
   17422:	e006      	b.n	17432 <ipc_register_handler+0x32>
    assert (handler != NULL);
   17424:	2900      	cmp	r1, #0
   17426:	d1f8      	bne.n	1741a <ipc_register_handler+0x1a>
   17428:	2016      	movs	r0, #22
   1742a:	4671      	mov	r1, lr
   1742c:	f7ea fb70 	bl	1b10 <panic>
        return IPC_STATUS_INVALID_HANDLER;
   17430:	2002      	movs	r0, #2
}
   17432:	bd70      	pop	{r4, r5, r6, pc}
    assert (handler != NULL);
   17434:	0029      	movs	r1, r5
   17436:	2016      	movs	r0, #22
   17438:	f7ea fb6a 	bl	1b10 <panic>
   1743c:	e7eb      	b.n	17416 <ipc_register_handler+0x16>
   1743e:	46c0      	nop			; (mov r8, r8)
   17440:	010026e4 	.word	0x010026e4

00017444 <ipc_send_message>:
/*
 * Check the core's outbox, and if available create the IPC message and inform the security core that an IPC message should be forwarded.
 * Expected usage is that the caller will yield/busy-wait if the resource is not available.
 */
IPC_STATUS ipc_send_message (CORES dst, IPC_ACTION action, const ipc_payload * payload_p, IPC_PRIORITY priority, bool request_ack)
{
   17444:	b5f0      	push	{r4, r5, r6, r7, lr}
   17446:	b085      	sub	sp, #20
   17448:	9301      	str	r3, [sp, #4]
   1744a:	ab0a      	add	r3, sp, #40	; 0x28
   1744c:	781b      	ldrb	r3, [r3, #0]
   1744e:	4674      	mov	r4, lr
   17450:	0007      	movs	r7, r0
   17452:	000e      	movs	r6, r1
   17454:	9202      	str	r2, [sp, #8]
   17456:	9303      	str	r3, [sp, #12]
    static uint32 id = 0;

    // Mark as volatile just in case the status field is updated by the security core to IPC_ACTION_STATUS_CLEAR.
    volatile ipc_mailbox_entry * outbox = &(ipc_mailboxes [IPC_OUTBOX]);

    assert (dst < CORES_MAX_NUMBER_PHYSICAL);
   17458:	2802      	cmp	r0, #2
   1745a:	d903      	bls.n	17464 <ipc_send_message+0x20>
   1745c:	4671      	mov	r1, lr
   1745e:	2016      	movs	r0, #22
   17460:	f7ea fb56 	bl	1b10 <panic>
    assert (priority < IPC_PRIORITY_MAX_NUM);
   17464:	9b01      	ldr	r3, [sp, #4]
   17466:	2b01      	cmp	r3, #1
   17468:	d903      	bls.n	17472 <ipc_send_message+0x2e>
   1746a:	0021      	movs	r1, r4
   1746c:	2016      	movs	r0, #22
   1746e:	f7ea fb4f 	bl	1b10 <panic>
    assert (action < IPC_ACTION_NUM_ACTIONS);
   17472:	2e08      	cmp	r6, #8
   17474:	d903      	bls.n	1747e <ipc_send_message+0x3a>
   17476:	0021      	movs	r1, r4
   17478:	2016      	movs	r0, #22
   1747a:	f7ea fb49 	bl	1b10 <panic>

    if (dst >= CORES_MAX_NUMBER_PHYSICAL)
    {
        return IPC_STATUS_INVALID_CORE;
   1747e:	2503      	movs	r5, #3
    if (dst >= CORES_MAX_NUMBER_PHYSICAL)
   17480:	2f02      	cmp	r7, #2
   17482:	d837      	bhi.n	174f4 <ipc_send_message+0xb0>
    }

    if (priority >= IPC_PRIORITY_MAX_NUM)
   17484:	9b01      	ldr	r3, [sp, #4]
    {
        return IPC_STATUS_INVALID_PRIORITY;
   17486:	3501      	adds	r5, #1
    if (priority >= IPC_PRIORITY_MAX_NUM)
   17488:	2b01      	cmp	r3, #1
   1748a:	d833      	bhi.n	174f4 <ipc_send_message+0xb0>
    }

    if (action >= IPC_ACTION_NUM_ACTIONS)
    {
        return IPC_STATUS_INVALID_ACTION;
   1748c:	3d03      	subs	r5, #3
    if (action >= IPC_ACTION_NUM_ACTIONS)
   1748e:	2e08      	cmp	r6, #8
   17490:	d830      	bhi.n	174f4 <ipc_send_message+0xb0>
    }

    non_os_enter_critical();
   17492:	f000 fe8f 	bl	181b4 <non_os_enter_critical>
    // Check if resource is available. Note that potentially the security core is running asynchronously to this call!
    if (outbox->status == IPC_ACTION_STATUS_CLEAR)
   17496:	4c1b      	ldr	r4, [pc, #108]	; (17504 <ipc_send_message+0xc0>)
        hal_ipc_interrupt_security ();
    }
    else
    {
        // Inform caller, so he can retry.
        retVal = IPC_STATUS_MAILBOX_BUSY;
   17498:	3505      	adds	r5, #5
    if (outbox->status == IPC_ACTION_STATUS_CLEAR)
   1749a:	0023      	movs	r3, r4
   1749c:	334e      	adds	r3, #78	; 0x4e
   1749e:	781b      	ldrb	r3, [r3, #0]
   174a0:	2b00      	cmp	r3, #0
   174a2:	d125      	bne.n	174f0 <ipc_send_message+0xac>
        outbox->priority = priority;
   174a4:	466b      	mov	r3, sp
   174a6:	791b      	ldrb	r3, [r3, #4]
        outbox->request_ack = request_ack;
   174a8:	466a      	mov	r2, sp
        outbox->dst = dst;
   174aa:	71a7      	strb	r7, [r4, #6]
        outbox->action = action;
   174ac:	8126      	strh	r6, [r4, #8]
        outbox->priority = priority;
   174ae:	7123      	strb	r3, [r4, #4]
        outbox->request_ack = request_ack;
   174b0:	0023      	movs	r3, r4
   174b2:	0020      	movs	r0, r4
   174b4:	7b12      	ldrb	r2, [r2, #12]
   174b6:	334c      	adds	r3, #76	; 0x4c
   174b8:	701a      	strb	r2, [r3, #0]
        if (payload_p)
   174ba:	9b02      	ldr	r3, [sp, #8]
        outbox->request_ack = request_ack;
   174bc:	300c      	adds	r0, #12
            memcpy ((void *)&(outbox->payload), (void *)payload_p, sizeof (ipc_payload));
   174be:	2240      	movs	r2, #64	; 0x40
        if (payload_p)
   174c0:	2b00      	cmp	r3, #0
   174c2:	d01a      	beq.n	174fa <ipc_send_message+0xb6>
            memcpy ((void *)&(outbox->payload), (void *)payload_p, sizeof (ipc_payload));
   174c4:	0019      	movs	r1, r3
   174c6:	f7e8 fe93 	bl	1f0 <memcpy>
        outbox->src = (CORES)CORE;
   174ca:	2302      	movs	r3, #2
   174cc:	7163      	strb	r3, [r4, #5]
        outbox->id = (id++ & 0x0FFFFFFFF) | (outbox->src << 28);    // Just use incrementing numbers for now. Don't care about wrap.
   174ce:	4b0e      	ldr	r3, [pc, #56]	; (17508 <ipc_send_message+0xc4>)
        outbox->chksum = 0;                                         // Holder for when this will be used (future release)
   174d0:	2500      	movs	r5, #0
        outbox->id = (id++ & 0x0FFFFFFFF) | (outbox->src << 28);    // Just use incrementing numbers for now. Don't care about wrap.
   174d2:	681a      	ldr	r2, [r3, #0]
   174d4:	1c51      	adds	r1, r2, #1
   174d6:	6019      	str	r1, [r3, #0]
   174d8:	7963      	ldrb	r3, [r4, #5]
   174da:	071b      	lsls	r3, r3, #28
   174dc:	4313      	orrs	r3, r2
   174de:	6023      	str	r3, [r4, #0]
        outbox->chksum = 0;                                         // Holder for when this will be used (future release)
   174e0:	0023      	movs	r3, r4
   174e2:	334d      	adds	r3, #77	; 0x4d
   174e4:	701d      	strb	r5, [r3, #0]
        outbox->status = IPC_ACTION_STATUS_PROCESS;
   174e6:	2301      	movs	r3, #1
        hal_ipc_interrupt_security ();
   174e8:	4a08      	ldr	r2, [pc, #32]	; (1750c <ipc_send_message+0xc8>)
        outbox->status = IPC_ACTION_STATUS_PROCESS;
   174ea:	344e      	adds	r4, #78	; 0x4e
   174ec:	7023      	strb	r3, [r4, #0]
        hal_ipc_interrupt_security ();
   174ee:	6013      	str	r3, [r2, #0]
    }
    non_os_exit_critical();
   174f0:	f000 fe74 	bl	181dc <non_os_exit_critical>

    return retVal;
}
   174f4:	0028      	movs	r0, r5
   174f6:	b005      	add	sp, #20
   174f8:	bdf0      	pop	{r4, r5, r6, r7, pc}
            memset ((void *)&(outbox->payload), 0xFF, sizeof (ipc_payload));
   174fa:	21ff      	movs	r1, #255	; 0xff
   174fc:	f7e8 fef0 	bl	2e0 <memset>
   17500:	e7e3      	b.n	174ca <ipc_send_message+0x86>
   17502:	46c0      	nop			; (mov r8, r8)
   17504:	0100ff00 	.word	0x0100ff00
   17508:	010026e0 	.word	0x010026e0
   1750c:	40004010 	.word	0x40004010

00017510 <ipc_receive_message>:

/*
 * Callback from HAL layer IRQ handler.
 */
void ipc_receive_message (void)
{
   17510:	b570      	push	{r4, r5, r6, lr}
    // Mark as volatile just in case the status field is updated by the security core.
    volatile ipc_mailbox_entry * inbox = &(ipc_mailboxes [IPC_INBOX]);

    // Only do anything if there is actually something to do!
    if (inbox->status == IPC_ACTION_STATUS_PROCESS)
   17512:	4c1f      	ldr	r4, [pc, #124]	; (17590 <ipc_receive_message+0x80>)
   17514:	4675      	mov	r5, lr
   17516:	0023      	movs	r3, r4
   17518:	339e      	adds	r3, #158	; 0x9e
   1751a:	781b      	ldrb	r3, [r3, #0]
   1751c:	2b01      	cmp	r3, #1
   1751e:	d11c      	bne.n	1755a <ipc_receive_message+0x4a>
    {
        bool release = true;

        assert (inbox->dst == CORE);
   17520:	0023      	movs	r3, r4
   17522:	3356      	adds	r3, #86	; 0x56
   17524:	781b      	ldrb	r3, [r3, #0]
   17526:	2b02      	cmp	r3, #2
   17528:	d003      	beq.n	17532 <ipc_receive_message+0x22>
   1752a:	4671      	mov	r1, lr
   1752c:	2016      	movs	r0, #22
   1752e:	f7ea faef 	bl	1b10 <panic>
        assert (inbox->action < IPC_ACTION_NUM_ACTIONS);
   17532:	0023      	movs	r3, r4
   17534:	3358      	adds	r3, #88	; 0x58
   17536:	881b      	ldrh	r3, [r3, #0]
   17538:	2b08      	cmp	r3, #8
   1753a:	d903      	bls.n	17544 <ipc_receive_message+0x34>
   1753c:	0029      	movs	r1, r5
   1753e:	2016      	movs	r0, #22
   17540:	f7ea fae6 	bl	1b10 <panic>

        if ((inbox->dst == CORE) && (inbox->action < IPC_ACTION_NUM_ACTIONS))
   17544:	0023      	movs	r3, r4
   17546:	3356      	adds	r3, #86	; 0x56
   17548:	781b      	ldrb	r3, [r3, #0]
   1754a:	2b02      	cmp	r3, #2
   1754c:	d006      	beq.n	1755c <ipc_receive_message+0x4c>
        }

        // Regardless of processing, mark the mailbox as 'free' if handler processed all data.
        if (release)
        {
            inbox->status = IPC_ACTION_STATUS_DONE;
   1754e:	2302      	movs	r3, #2

            // ... and inform the security core so the next message can be posted.
            hal_ipc_interrupt_security ();
   17550:	2201      	movs	r2, #1
            inbox->status = IPC_ACTION_STATUS_DONE;
   17552:	349e      	adds	r4, #158	; 0x9e
   17554:	7023      	strb	r3, [r4, #0]
            hal_ipc_interrupt_security ();
   17556:	4b0f      	ldr	r3, [pc, #60]	; (17594 <ipc_receive_message+0x84>)
   17558:	601a      	str	r2, [r3, #0]
        }
    }
}
   1755a:	bd70      	pop	{r4, r5, r6, pc}
        if ((inbox->dst == CORE) && (inbox->action < IPC_ACTION_NUM_ACTIONS))
   1755c:	0023      	movs	r3, r4
   1755e:	3358      	adds	r3, #88	; 0x58
   17560:	881a      	ldrh	r2, [r3, #0]
   17562:	2a08      	cmp	r2, #8
   17564:	d8f3      	bhi.n	1754e <ipc_receive_message+0x3e>
            if (ipc_handlers [inbox->action] != NULL)
   17566:	881a      	ldrh	r2, [r3, #0]
   17568:	4d0b      	ldr	r5, [pc, #44]	; (17598 <ipc_receive_message+0x88>)
   1756a:	0092      	lsls	r2, r2, #2
   1756c:	5952      	ldr	r2, [r2, r5]
   1756e:	2a00      	cmp	r2, #0
   17570:	d0ed      	beq.n	1754e <ipc_receive_message+0x3e>
                release = (ipc_handlers [inbox->action])(inbox->action, &inbox->payload, inbox->src, inbox->id);
   17572:	8819      	ldrh	r1, [r3, #0]
   17574:	8818      	ldrh	r0, [r3, #0]
   17576:	0023      	movs	r3, r4
   17578:	3355      	adds	r3, #85	; 0x55
   1757a:	781a      	ldrb	r2, [r3, #0]
   1757c:	0089      	lsls	r1, r1, #2
   1757e:	594d      	ldr	r5, [r1, r5]
   17580:	b280      	uxth	r0, r0
   17582:	b2d2      	uxtb	r2, r2
   17584:	6d23      	ldr	r3, [r4, #80]	; 0x50
   17586:	4905      	ldr	r1, [pc, #20]	; (1759c <ipc_receive_message+0x8c>)
   17588:	47a8      	blx	r5
        if (release)
   1758a:	2800      	cmp	r0, #0
   1758c:	d1df      	bne.n	1754e <ipc_receive_message+0x3e>
   1758e:	e7e4      	b.n	1755a <ipc_receive_message+0x4a>
   17590:	0100ff00 	.word	0x0100ff00
   17594:	40004010 	.word	0x40004010
   17598:	010026e4 	.word	0x010026e4
   1759c:	0100ff5c 	.word	0x0100ff5c

000175a0 <ipc_check_outbox_free>:
 */
bool ipc_check_outbox_free(void)
{
    volatile ipc_mailbox_entry * outbox = &(ipc_mailboxes [IPC_OUTBOX]);
    
    return outbox->status == IPC_ACTION_STATUS_CLEAR;
   175a0:	4b03      	ldr	r3, [pc, #12]	; (175b0 <ipc_check_outbox_free+0x10>)
   175a2:	334e      	adds	r3, #78	; 0x4e
   175a4:	7818      	ldrb	r0, [r3, #0]
   175a6:	4243      	negs	r3, r0
   175a8:	4158      	adcs	r0, r3
   175aa:	b2c0      	uxtb	r0, r0
}
   175ac:	4770      	bx	lr
   175ae:	46c0      	nop			; (mov r8, r8)
   175b0:	0100ff00 	.word	0x0100ff00

000175b4 <log_buffer_helper_add>:
 * @param data buffer with the data to store
 * @param data_len data length in bytes
 * @param last_lb_write_index next index to write
 */
static void log_buffer_helper_add (const uint8 * data , const uint16 data_len, uint16 * last_lb_write_index)
{
   175b4:	4673      	mov	r3, lr
   175b6:	b5f0      	push	{r4, r5, r6, r7, lr}
   175b8:	b085      	sub	sp, #20
   175ba:	9303      	str	r3, [sp, #12]

    size_t to_end = log_buffer_size - *last_lb_write_index;
   175bc:	4b15      	ldr	r3, [pc, #84]	; (17614 <log_buffer_helper_add+0x60>)
{
   175be:	0005      	movs	r5, r0
    size_t to_end = log_buffer_size - *last_lb_write_index;
   175c0:	881e      	ldrh	r6, [r3, #0]
   175c2:	4b15      	ldr	r3, [pc, #84]	; (17618 <log_buffer_helper_add+0x64>)
   175c4:	8810      	ldrh	r0, [r2, #0]
   175c6:	681b      	ldr	r3, [r3, #0]
   175c8:	1a37      	subs	r7, r6, r0
{
   175ca:	000c      	movs	r4, r1
   175cc:	9201      	str	r2, [sp, #4]
   175ce:	9302      	str	r3, [sp, #8]
   175d0:	1818      	adds	r0, r3, r0

    if (to_end >= data_len)
   175d2:	42b9      	cmp	r1, r7
   175d4:	d815      	bhi.n	17602 <log_buffer_helper_add+0x4e>
    {
        /* Entire message fits. */
        memcpy( (void *) (log_buffer_start + *last_lb_write_index), data, data_len);
   175d6:	000a      	movs	r2, r1
   175d8:	0029      	movs	r1, r5
    }
    else
    {
        /* Message needs to be segmented. Write to end of buffer and then the remainder from the beginning. */
        memcpy((void *) (log_buffer_start + *last_lb_write_index), data, to_end);
        memcpy((void *) log_buffer_start, &data[to_end],  data_len - to_end);
   175da:	f7e8 fe09 	bl	1f0 <memcpy>
    }

    *last_lb_write_index = circled_index( *last_lb_write_index + data_len );
   175de:	9b01      	ldr	r3, [sp, #4]
   175e0:	881b      	ldrh	r3, [r3, #0]
   175e2:	18e4      	adds	r4, r4, r3
   175e4:	b2a4      	uxth	r4, r4
    if ( index_in < log_buffer_size)
   175e6:	42a6      	cmp	r6, r4
   175e8:	d807      	bhi.n	175fa <log_buffer_helper_add+0x46>
        index_out = index_in - log_buffer_size;
   175ea:	1ba4      	subs	r4, r4, r6
   175ec:	b2a4      	uxth	r4, r4
    assert(INDEX_IN_CBUFF(index_out));
   175ee:	42a6      	cmp	r6, r4
   175f0:	d803      	bhi.n	175fa <log_buffer_helper_add+0x46>
   175f2:	9903      	ldr	r1, [sp, #12]
   175f4:	2016      	movs	r0, #22
   175f6:	f7ea fa8b 	bl	1b10 <panic>
    *last_lb_write_index = circled_index( *last_lb_write_index + data_len );
   175fa:	9b01      	ldr	r3, [sp, #4]
   175fc:	801c      	strh	r4, [r3, #0]
}
   175fe:	b005      	add	sp, #20
   17600:	bdf0      	pop	{r4, r5, r6, r7, pc}
        memcpy((void *) (log_buffer_start + *last_lb_write_index), data, to_end);
   17602:	003a      	movs	r2, r7
   17604:	0029      	movs	r1, r5
   17606:	f7e8 fdf3 	bl	1f0 <memcpy>
        memcpy((void *) log_buffer_start, &data[to_end],  data_len - to_end);
   1760a:	1be2      	subs	r2, r4, r7
   1760c:	19e9      	adds	r1, r5, r7
   1760e:	9802      	ldr	r0, [sp, #8]
   17610:	e7e3      	b.n	175da <log_buffer_helper_add+0x26>
   17612:	46c0      	nop			; (mov r8, r8)
   17614:	01002708 	.word	0x01002708
   17618:	0100270c 	.word	0x0100270c

0001761c <log_buffer_get_available.constprop.0>:
static LOG_RET log_buffer_get_available(uint16 * av)
   1761c:	b510      	push	{r4, lr}
    uint16 l_read_i = log_section_control->read;
   1761e:	4b0c      	ldr	r3, [pc, #48]	; (17650 <log_buffer_get_available.constprop.0+0x34>)
static LOG_RET log_buffer_get_available(uint16 * av)
   17620:	0001      	movs	r1, r0
    uint16 l_read_i = log_section_control->read;
   17622:	681a      	ldr	r2, [r3, #0]
    if( !INDEX_IN_CBUFF(l_read_i) || !INDEX_IN_CBUFF(l_write_i) )
   17624:	480b      	ldr	r0, [pc, #44]	; (17654 <log_buffer_get_available.constprop.0+0x38>)
    uint16 l_read_i = log_section_control->read;
   17626:	8813      	ldrh	r3, [r2, #0]
    if( !INDEX_IN_CBUFF(l_read_i) || !INDEX_IN_CBUFF(l_write_i) )
   17628:	8804      	ldrh	r4, [r0, #0]
    uint16 l_write_i = log_section_control->write;
   1762a:	8892      	ldrh	r2, [r2, #4]
    uint16 l_read_i = log_section_control->read;
   1762c:	b29b      	uxth	r3, r3
    uint16 l_write_i = log_section_control->write;
   1762e:	b292      	uxth	r2, r2
        return LOG_RET_ERROR_CORRUPT_SHARED_MEMORY;
   17630:	2003      	movs	r0, #3
    if( !INDEX_IN_CBUFF(l_read_i) || !INDEX_IN_CBUFF(l_write_i) )
   17632:	42a3      	cmp	r3, r4
   17634:	d208      	bcs.n	17648 <log_buffer_get_available.constprop.0+0x2c>
   17636:	42a2      	cmp	r2, r4
   17638:	d206      	bcs.n	17648 <log_buffer_get_available.constprop.0+0x2c>
    if (l_read_i <= l_write_i)
   1763a:	4293      	cmp	r3, r2
   1763c:	d805      	bhi.n	1764a <log_buffer_get_available.constprop.0+0x2e>
        *av = (log_buffer_size  - 1u) - (l_write_i - l_read_i); //lint !e734 no loss of precision. l_read_i and l_write_i has been checked to be in safe boundaries.
   1763e:	3c01      	subs	r4, #1
   17640:	191b      	adds	r3, r3, r4
    return LOG_RET_OK;
   17642:	2000      	movs	r0, #0
        *av = (l_read_i - l_write_i) - 1u; //lint !e734 no loss of precision. l_read_i and l_write_i has been checked to be in safe boundaries.
   17644:	1a9b      	subs	r3, r3, r2
   17646:	800b      	strh	r3, [r1, #0]
}
   17648:	bd10      	pop	{r4, pc}
        *av = (l_read_i - l_write_i) - 1u; //lint !e734 no loss of precision. l_read_i and l_write_i has been checked to be in safe boundaries.
   1764a:	3b01      	subs	r3, #1
   1764c:	e7f9      	b.n	17642 <log_buffer_get_available.constprop.0+0x26>
   1764e:	46c0      	nop			; (mov r8, r8)
   17650:	01002710 	.word	0x01002710
   17654:	01002708 	.word	0x01002708

00017658 <log_buffer_init>:
/*
 *  Public function definitions
 */

void log_buffer_init(LOG_MEMORY_REGION_SECTION logsec)
{
   17658:	b537      	push	{r0, r1, r2, r4, r5, lr}
    /* Init the buffer limits */

    log_memory_section_params ms_params;
    log_memory_section_get( logsec, &ms_params);
   1765a:	4669      	mov	r1, sp
   1765c:	4675      	mov	r5, lr
{
   1765e:	0004      	movs	r4, r0
    log_memory_section_get( logsec, &ms_params);
   17660:	f000 fad4 	bl	17c0c <log_memory_section_get>

    if ( POINTER_IN_LOG_MEMORY_REGION(ms_params.start) && POINTER_IN_LOG_MEMORY_REGION(ms_params.start + ms_params.length -1) )
   17664:	23c0      	movs	r3, #192	; 0xc0
   17666:	9900      	ldr	r1, [sp, #0]
   17668:	049b      	lsls	r3, r3, #18
   1766a:	0b8a      	lsrs	r2, r1, #14
   1766c:	0392      	lsls	r2, r2, #14
   1766e:	429a      	cmp	r2, r3
   17670:	d111      	bne.n	17696 <log_buffer_init+0x3e>
   17672:	466b      	mov	r3, sp
   17674:	8898      	ldrh	r0, [r3, #4]
   17676:	1e43      	subs	r3, r0, #1
   17678:	18cb      	adds	r3, r1, r3
   1767a:	0b9b      	lsrs	r3, r3, #14
   1767c:	039b      	lsls	r3, r3, #14
   1767e:	4293      	cmp	r3, r2
   17680:	d109      	bne.n	17696 <log_buffer_init+0x3e>
    {
        log_buffer_start = ms_params.start; // first element
   17682:	4b07      	ldr	r3, [pc, #28]	; (176a0 <log_buffer_init+0x48>)
   17684:	6019      	str	r1, [r3, #0]
        log_buffer_size  = ms_params.length; // buffer size
   17686:	4b07      	ldr	r3, [pc, #28]	; (176a4 <log_buffer_init+0x4c>)
   17688:	8018      	strh	r0, [r3, #0]

        log_section_control = log_memory_section_get_control(logsec);
   1768a:	0020      	movs	r0, r4
   1768c:	f000 fad2 	bl	17c34 <log_memory_section_get_control>
   17690:	4b05      	ldr	r3, [pc, #20]	; (176a8 <log_buffer_init+0x50>)
   17692:	6018      	str	r0, [r3, #0]
    else
    {
        assert(false);
    }

}
   17694:	bd37      	pop	{r0, r1, r2, r4, r5, pc}
        assert(false);
   17696:	0029      	movs	r1, r5
   17698:	2016      	movs	r0, #22
   1769a:	f7ea fa39 	bl	1b10 <panic>
}
   1769e:	e7f9      	b.n	17694 <log_buffer_init+0x3c>
   176a0:	0100270c 	.word	0x0100270c
   176a4:	01002708 	.word	0x01002708
   176a8:	01002710 	.word	0x01002710

000176ac <log_buffer_get_available_for_next_message>:

LOG_RET log_buffer_get_available_for_next_message(uint16 * av)
{
   176ac:	b537      	push	{r0, r1, r2, r4, r5, lr}
    LOG_RET ret_val;
    uint16 available = 0;
   176ae:	466b      	mov	r3, sp
   176b0:	1d9d      	adds	r5, r3, #6
   176b2:	2300      	movs	r3, #0
{
   176b4:	0004      	movs	r4, r0

    ret_val = log_buffer_get_available(&available);
   176b6:	0028      	movs	r0, r5
    uint16 available = 0;
   176b8:	802b      	strh	r3, [r5, #0]
    ret_val = log_buffer_get_available(&available);
   176ba:	f7ff ffaf 	bl	1761c <log_buffer_get_available.constprop.0>

    if ( ret_val == LOG_RET_OK)
   176be:	2800      	cmp	r0, #0
   176c0:	d103      	bne.n	176ca <log_buffer_get_available_for_next_message+0x1e>
    {
        if ( available <= sizeof(log_buffer_header))
   176c2:	882b      	ldrh	r3, [r5, #0]
   176c4:	2b0a      	cmp	r3, #10
   176c6:	d801      	bhi.n	176cc <log_buffer_get_available_for_next_message+0x20>
        {
            *av =0;
   176c8:	8020      	strh	r0, [r4, #0]
        {
            *av = available - sizeof(log_buffer_header);
        }
    }
    return ret_val;
}
   176ca:	bd3e      	pop	{r1, r2, r3, r4, r5, pc}
            *av = available - sizeof(log_buffer_header);
   176cc:	3b0a      	subs	r3, #10
   176ce:	8023      	strh	r3, [r4, #0]
   176d0:	e7fb      	b.n	176ca <log_buffer_get_available_for_next_message+0x1e>
	...

000176d4 <log_buffer_message>:


LOG_RET log_buffer_message(const log_message_header_t *log_msg, const uint8 *buffer, uint32 time_us, bool * was_empty)
{
   176d4:	b5f0      	push	{r4, r5, r6, r7, lr}
   176d6:	4674      	mov	r4, lr
   176d8:	b08b      	sub	sp, #44	; 0x2c
   176da:	9403      	str	r4, [sp, #12]
   176dc:	9001      	str	r0, [sp, #4]
   176de:	9104      	str	r1, [sp, #16]
   176e0:	0017      	movs	r7, r2
   176e2:	9305      	str	r3, [sp, #20]
    size_t msg_length;
    uint16 lb_available;

    if (log_msg == NULL || buffer == NULL)
    {
        return LOG_RET_ERROR_IN_PARAMETERS;
   176e4:	2401      	movs	r4, #1
    if (log_msg == NULL || buffer == NULL)
   176e6:	2800      	cmp	r0, #0
   176e8:	d014      	beq.n	17714 <log_buffer_message+0x40>
   176ea:	2900      	cmp	r1, #0
   176ec:	d012      	beq.n	17714 <log_buffer_message+0x40>
    }

    msg_length = log_msg->length;
   176ee:	7945      	ldrb	r5, [r0, #5]
   176f0:	7903      	ldrb	r3, [r0, #4]
   176f2:	022d      	lsls	r5, r5, #8
   176f4:	431d      	orrs	r5, r3

    // Get the space availabe
    lb_available = 0;
   176f6:	ab06      	add	r3, sp, #24
   176f8:	1d9e      	adds	r6, r3, #6
   176fa:	2300      	movs	r3, #0
    l_ret = log_buffer_get_available_for_next_message(&lb_available);
   176fc:	0030      	movs	r0, r6
    lb_available = 0;
   176fe:	8033      	strh	r3, [r6, #0]
    l_ret = log_buffer_get_available_for_next_message(&lb_available);
   17700:	f7ff ffd4 	bl	176ac <log_buffer_get_available_for_next_message>
   17704:	0004      	movs	r4, r0
   17706:	1e02      	subs	r2, r0, #0
    assert( l_ret == LOG_RET_OK);
   17708:	d100      	bne.n	1770c <log_buffer_message+0x38>
   1770a:	e076      	b.n	177fa <log_buffer_message+0x126>
   1770c:	9903      	ldr	r1, [sp, #12]
   1770e:	2016      	movs	r0, #22
   17710:	f7ea f9fe 	bl	1b10 <panic>
        {
            l_ret = LOG_RET_ERROR_NOT_ENOUGH_SPACE;
        }
    }
    return l_ret;
}
   17714:	0020      	movs	r0, r4
   17716:	b00b      	add	sp, #44	; 0x2c
   17718:	bdf0      	pop	{r4, r5, r6, r7, pc}
            *was_empty = false;
   1771a:	9b05      	ldr	r3, [sp, #20]
   1771c:	9709      	str	r7, [sp, #36]	; 0x24
   1771e:	701c      	strb	r4, [r3, #0]
    tx_len = sizeof(log_buffer_header) + log_msg->length;
   17720:	9b01      	ldr	r3, [sp, #4]
        return LOG_RET_ERROR_IN_PARAMETERS;
   17722:	2401      	movs	r4, #1
    tx_len = sizeof(log_buffer_header) + log_msg->length;
   17724:	7919      	ldrb	r1, [r3, #4]
   17726:	795b      	ldrb	r3, [r3, #5]
   17728:	021b      	lsls	r3, r3, #8
   1772a:	430b      	orrs	r3, r1
   1772c:	330a      	adds	r3, #10
   1772e:	b29b      	uxth	r3, r3
   17730:	9302      	str	r3, [sp, #8]
    if ( tx_len > (log_buffer_size - 1) )
   17732:	4b35      	ldr	r3, [pc, #212]	; (17808 <log_buffer_message+0x134>)
   17734:	9902      	ldr	r1, [sp, #8]
   17736:	881b      	ldrh	r3, [r3, #0]
   17738:	4299      	cmp	r1, r3
   1773a:	d2eb      	bcs.n	17714 <log_buffer_message+0x40>
    l_read_i = log_section_control->read;
   1773c:	4933      	ldr	r1, [pc, #204]	; (1780c <log_buffer_message+0x138>)
        return LOG_RET_ERROR_CORRUPT_SHARED_MEMORY;
   1773e:	3402      	adds	r4, #2
    l_read_i = log_section_control->read;
   17740:	6809      	ldr	r1, [r1, #0]
   17742:	880f      	ldrh	r7, [r1, #0]
    l_write_i = log_section_control->write;
   17744:	888e      	ldrh	r6, [r1, #4]
    l_read_i = log_section_control->read;
   17746:	b2bf      	uxth	r7, r7
    l_write_i = log_section_control->write;
   17748:	b2b6      	uxth	r6, r6
    if( !INDEX_IN_CBUFF(l_read_i) || !INDEX_IN_CBUFF(l_write_i))
   1774a:	42bb      	cmp	r3, r7
   1774c:	d9e2      	bls.n	17714 <log_buffer_message+0x40>
   1774e:	42b3      	cmp	r3, r6
   17750:	d9e0      	bls.n	17714 <log_buffer_message+0x40>
    available = 0;
   17752:	ad08      	add	r5, sp, #32
    ret_val = log_buffer_get_available(&available);
   17754:	0028      	movs	r0, r5
    available = 0;
   17756:	802a      	strh	r2, [r5, #0]
    ret_val = log_buffer_get_available(&available);
   17758:	f7ff ff60 	bl	1761c <log_buffer_get_available.constprop.0>
   1775c:	1e04      	subs	r4, r0, #0
    if ( ret_val == LOG_RET_OK)
   1775e:	d1d9      	bne.n	17714 <log_buffer_message+0x40>
        if ( available >= tx_len )
   17760:	882b      	ldrh	r3, [r5, #0]
   17762:	9a02      	ldr	r2, [sp, #8]
   17764:	4293      	cmp	r3, r2
   17766:	d34d      	bcc.n	17804 <log_buffer_message+0x130>
            new_write_index = l_write_i;
   17768:	250a      	movs	r5, #10
   1776a:	ab06      	add	r3, sp, #24
   1776c:	18ed      	adds	r5, r5, r3
            log_buffer_helper_add( (const uint8*) &time_us, sizeof(uint32), &new_write_index );
   1776e:	002a      	movs	r2, r5
   17770:	2104      	movs	r1, #4
   17772:	a809      	add	r0, sp, #36	; 0x24
            new_write_index = l_write_i;
   17774:	802e      	strh	r6, [r5, #0]
            log_buffer_helper_add( (const uint8*) &time_us, sizeof(uint32), &new_write_index );
   17776:	f7ff ff1d 	bl	175b4 <log_buffer_helper_add>
            log_buffer_helper_add( (const uint8*) log_msg, sizeof(log_message_header_t), &new_write_index );
   1777a:	002a      	movs	r2, r5
   1777c:	2106      	movs	r1, #6
   1777e:	9801      	ldr	r0, [sp, #4]
   17780:	f7ff ff18 	bl	175b4 <log_buffer_helper_add>
            log_buffer_helper_add( buffer, log_msg->length, &new_write_index );
   17784:	9a01      	ldr	r2, [sp, #4]
   17786:	9b01      	ldr	r3, [sp, #4]
   17788:	7951      	ldrb	r1, [r2, #5]
   1778a:	791b      	ldrb	r3, [r3, #4]
   1778c:	0209      	lsls	r1, r1, #8
   1778e:	4319      	orrs	r1, r3
   17790:	002a      	movs	r2, r5
   17792:	9804      	ldr	r0, [sp, #16]
   17794:	f7ff ff0e 	bl	175b4 <log_buffer_helper_add>
            assert( INDEX_IN_CBUFF(new_write_index) );
   17798:	4b1b      	ldr	r3, [pc, #108]	; (17808 <log_buffer_message+0x134>)
   1779a:	882a      	ldrh	r2, [r5, #0]
   1779c:	881b      	ldrh	r3, [r3, #0]
   1779e:	429a      	cmp	r2, r3
   177a0:	d303      	bcc.n	177aa <log_buffer_message+0xd6>
   177a2:	9903      	ldr	r1, [sp, #12]
   177a4:	2016      	movs	r0, #22
   177a6:	f7ea f9b3 	bl	1b10 <panic>
   177aa:	882b      	ldrh	r3, [r5, #0]
            assert( (l_write_i < l_read_i) || ( (new_write_index > l_write_i) || (new_write_index < l_read_i) ) );
   177ac:	42b7      	cmp	r7, r6
   177ae:	d801      	bhi.n	177b4 <log_buffer_message+0xe0>
   177b0:	429e      	cmp	r6, r3
   177b2:	d305      	bcc.n	177c0 <log_buffer_message+0xec>
   177b4:	429f      	cmp	r7, r3
   177b6:	d803      	bhi.n	177c0 <log_buffer_message+0xec>
   177b8:	9903      	ldr	r1, [sp, #12]
   177ba:	2016      	movs	r0, #22
   177bc:	f7ea f9a8 	bl	1b10 <panic>
            log_section_control->write = new_write_index;
   177c0:	4b12      	ldr	r3, [pc, #72]	; (1780c <log_buffer_message+0x138>)
   177c2:	681a      	ldr	r2, [r3, #0]
   177c4:	882b      	ldrh	r3, [r5, #0]
   177c6:	8093      	strh	r3, [r2, #4]
                l_read_i = log_section_control->read;
   177c8:	8811      	ldrh	r1, [r2, #0]
                l_write_i = log_section_control->write;
   177ca:	8893      	ldrh	r3, [r2, #4]
                if( !INDEX_IN_CBUFF(l_read_i) || !INDEX_IN_CBUFF(l_write_i))
   177cc:	4a0e      	ldr	r2, [pc, #56]	; (17808 <log_buffer_message+0x134>)
                l_read_i = log_section_control->read;
   177ce:	b289      	uxth	r1, r1
                if( !INDEX_IN_CBUFF(l_read_i) || !INDEX_IN_CBUFF(l_write_i))
   177d0:	8812      	ldrh	r2, [r2, #0]
                l_write_i = log_section_control->write;
   177d2:	b29b      	uxth	r3, r3
                if( !INDEX_IN_CBUFF(l_read_i) || !INDEX_IN_CBUFF(l_write_i))
   177d4:	4291      	cmp	r1, r2
   177d6:	d201      	bcs.n	177dc <log_buffer_message+0x108>
   177d8:	4293      	cmp	r3, r2
   177da:	d301      	bcc.n	177e0 <log_buffer_message+0x10c>
                    return LOG_RET_ERROR_CORRUPT_SHARED_MEMORY;
   177dc:	2403      	movs	r4, #3
   177de:	e799      	b.n	17714 <log_buffer_message+0x40>
    if (read_i <= write_i)
   177e0:	4299      	cmp	r1, r3
   177e2:	d808      	bhi.n	177f6 <log_buffer_message+0x122>
                *was_empty = ( log_buffer_get_used(l_read_i, l_write_i) <= tx_len );
   177e4:	2200      	movs	r2, #0
        in_use = (log_buffer_size - read_i) + write_i;
   177e6:	1a5b      	subs	r3, r3, r1
                *was_empty = ( log_buffer_get_used(l_read_i, l_write_i) <= tx_len );
   177e8:	9902      	ldr	r1, [sp, #8]
        in_use = (log_buffer_size - read_i) + write_i;
   177ea:	b29b      	uxth	r3, r3
                *was_empty = ( log_buffer_get_used(l_read_i, l_write_i) <= tx_len );
   177ec:	4299      	cmp	r1, r3
   177ee:	4152      	adcs	r2, r2
   177f0:	9b05      	ldr	r3, [sp, #20]
   177f2:	701a      	strb	r2, [r3, #0]
   177f4:	e78e      	b.n	17714 <log_buffer_message+0x40>
        in_use = (log_buffer_size - read_i) + write_i;
   177f6:	189b      	adds	r3, r3, r2
   177f8:	e7f4      	b.n	177e4 <log_buffer_message+0x110>
        if (lb_available >  (sizeof(time_us)  + sizeof(log_message_header_t) + msg_length))
   177fa:	8833      	ldrh	r3, [r6, #0]
   177fc:	350a      	adds	r5, #10
   177fe:	42ab      	cmp	r3, r5
   17800:	d900      	bls.n	17804 <log_buffer_message+0x130>
   17802:	e78a      	b.n	1771a <log_buffer_message+0x46>
            l_ret = LOG_RET_ERROR_NOT_ENOUGH_SPACE;
   17804:	2402      	movs	r4, #2
   17806:	e785      	b.n	17714 <log_buffer_message+0x40>
   17808:	01002708 	.word	0x01002708
   1780c:	01002710 	.word	0x01002710

00017810 <circled_index>:
/*
 *  Private function definitions
 */

static uint16 circled_index (const log_buffer_reader_control * lmscontrol, uint16 index_in)
{
   17810:	b510      	push	{r4, lr}
    uint16 index_out;

    if ( index_in < lmscontrol->log_buffer_size)
   17812:	8883      	ldrh	r3, [r0, #4]
{
   17814:	000c      	movs	r4, r1
    if ( index_in < lmscontrol->log_buffer_size)
   17816:	428b      	cmp	r3, r1
   17818:	d807      	bhi.n	1782a <circled_index+0x1a>
    {
        index_out = index_in;
    }
    else
    {
        index_out = index_in - lmscontrol->log_buffer_size;
   1781a:	1acc      	subs	r4, r1, r3
   1781c:	b2a4      	uxth	r4, r4
    }
    assert(index_out < lmscontrol->log_buffer_size);
   1781e:	42a3      	cmp	r3, r4
   17820:	d803      	bhi.n	1782a <circled_index+0x1a>
   17822:	4671      	mov	r1, lr
   17824:	2016      	movs	r0, #22
   17826:	f7ea f973 	bl	1b10 <panic>
    return index_out;
}
   1782a:	0020      	movs	r0, r4
   1782c:	bd10      	pop	{r4, pc}
	...

00017830 <log_buffer_reader_get_msg_header>:
}



static LOG_READER_RET log_buffer_reader_get_msg_header(LOG_MEMORY_REGION_SECTION lmsec, log_buffer_header * lb_header, uint16 m_index)
{
   17830:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
   17832:	000c      	movs	r4, r1
    uint16 in_use;
    uint16 l_write_i;

    if (lb_header == NULL)
    {
        return LOG_READER_RET_ERROR_IN_PARAMS;
   17834:	2106      	movs	r1, #6
    if (lb_header == NULL)
   17836:	2c00      	cmp	r4, #0
   17838:	d022      	beq.n	17880 <log_buffer_reader_get_msg_header+0x50>
    }

    // Get the write index and check if there is at least a header to read
    l_write_i =section_control [lmsec]->write;
   1783a:	4b19      	ldr	r3, [pc, #100]	; (178a0 <log_buffer_reader_get_msg_header+0x70>)
   1783c:	0081      	lsls	r1, r0, #2
   1783e:	58cb      	ldr	r3, [r1, r3]
    if ( l_write_i >= buffer_reader_control[lmsec].log_buffer_size )
   17840:	4e18      	ldr	r6, [pc, #96]	; (178a4 <log_buffer_reader_get_msg_header+0x74>)
   17842:	00c5      	lsls	r5, r0, #3
   17844:	1971      	adds	r1, r6, r5
    l_write_i =section_control [lmsec]->write;
   17846:	889b      	ldrh	r3, [r3, #4]
    if ( l_write_i >= buffer_reader_control[lmsec].log_buffer_size )
   17848:	888f      	ldrh	r7, [r1, #4]
    l_write_i =section_control [lmsec]->write;
   1784a:	b29b      	uxth	r3, r3
    {
        return LOG_READER_RET_ERROR_CORRUPT_SHARED_MEMORY;
   1784c:	2108      	movs	r1, #8
    if ( l_write_i >= buffer_reader_control[lmsec].log_buffer_size )
   1784e:	429f      	cmp	r7, r3
   17850:	d916      	bls.n	17880 <log_buffer_reader_get_msg_header+0x50>
    if (read_i <= write_i)
   17852:	4293      	cmp	r3, r2
   17854:	d316      	bcc.n	17884 <log_buffer_reader_get_msg_header+0x54>
        in_use = write_i - read_i;
   17856:	1a9b      	subs	r3, r3, r2
        in_use = (lmscontrol->log_buffer_size - read_i) + write_i;
   17858:	b29b      	uxth	r3, r3

    in_use = log_buffer_get_used( lmsec_reader_control, m_index, l_write_i); // data between the index and the write

    if ( in_use == 0 )
    {
        return LOG_READER_RET_THERE_IS_NO_NEXT_MESSAGE;
   1785a:	2105      	movs	r1, #5
    if ( in_use == 0 )
   1785c:	2b00      	cmp	r3, #0
   1785e:	d00f      	beq.n	17880 <log_buffer_reader_get_msg_header+0x50>
        return LOG_READER_RET_ERROR_CORRUPT_SHARED_MEMORY;
   17860:	3103      	adds	r1, #3
    }
    else if ( in_use < sizeof(log_buffer_header) || (in_use >= buffer_reader_control[lmsec].log_buffer_size))
   17862:	2b09      	cmp	r3, #9
   17864:	d90c      	bls.n	17880 <log_buffer_reader_get_msg_header+0x50>
   17866:	429f      	cmp	r7, r3
   17868:	d90a      	bls.n	17880 <log_buffer_reader_get_msg_header+0x50>
   1786a:	5973      	ldr	r3, [r6, r5]
   1786c:	1899      	adds	r1, r3, r2
    if ( index_in + len <= lmscontrol->log_buffer_size)
   1786e:	0013      	movs	r3, r2
   17870:	330a      	adds	r3, #10
   17872:	42bb      	cmp	r3, r7
   17874:	dc09      	bgt.n	1788a <log_buffer_reader_get_msg_header+0x5a>
        memcpy((void *) destination_p, (void *) (lmscontrol->log_buffer_start + index_in), len);
   17876:	220a      	movs	r2, #10
   17878:	0020      	movs	r0, r4
        memcpy((void *) (destination_p + l1), (void *) lmscontrol->log_buffer_start, len - l1);
   1787a:	f7e8 fcb9 	bl	1f0 <memcpy>
        return LOG_READER_RET_ERROR_CORRUPT_SHARED_MEMORY;
    }
    else
    {
        log_buffer_copy_consecutive ( lmsec_reader_control, (uint8 *) lb_header, m_index, sizeof(log_buffer_header));
        return LOG_READER_RET_OK;
   1787e:	2100      	movs	r1, #0
    }
}
   17880:	0008      	movs	r0, r1
   17882:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
        in_use = (lmscontrol->log_buffer_size - read_i) + write_i;
   17884:	1ab9      	subs	r1, r7, r2
   17886:	185b      	adds	r3, r3, r1
   17888:	e7e6      	b.n	17858 <log_buffer_reader_get_msg_header+0x28>
        l1 = lmscontrol->log_buffer_size - index_in;
   1788a:	1abf      	subs	r7, r7, r2
   1788c:	b2bf      	uxth	r7, r7
        memcpy(destination_p, (void *) (lmscontrol->log_buffer_start + index_in), l1);
   1788e:	003a      	movs	r2, r7
   17890:	0020      	movs	r0, r4
   17892:	f7e8 fcad 	bl	1f0 <memcpy>
        memcpy((void *) (destination_p + l1), (void *) lmscontrol->log_buffer_start, len - l1);
   17896:	220a      	movs	r2, #10
   17898:	19e0      	adds	r0, r4, r7
   1789a:	1bd2      	subs	r2, r2, r7
   1789c:	5971      	ldr	r1, [r6, r5]
   1789e:	e7ec      	b.n	1787a <log_buffer_reader_get_msg_header+0x4a>
   178a0:	0100272c 	.word	0x0100272c
   178a4:	01002714 	.word	0x01002714

000178a8 <log_buffer_reader_init>:
 *  Public function definitions
 */
 
//lint -esym(714, log_buffer_reader_init)   Only used on core with log_reader
LOG_READER_RET log_buffer_reader_init()
{
   178a8:	b5f0      	push	{r4, r5, r6, r7, lr}
   178aa:	4673      	mov	r3, lr
    {
        uint16 l_read_i;
        log_memory_section_get(lmsec, &ms_params);
        section_control[lmsec] = log_memory_section_get_control(lmsec);

        assert (POINTER_IN_LOG_MEMORY_REGION(ms_params.start));
   178ac:	25c0      	movs	r5, #192	; 0xc0
{
   178ae:	2400      	movs	r4, #0
   178b0:	b085      	sub	sp, #20
   178b2:	9300      	str	r3, [sp, #0]
        assert (POINTER_IN_LOG_MEMORY_REGION(ms_params.start));
   178b4:	04ad      	lsls	r5, r5, #18
   178b6:	b2e6      	uxtb	r6, r4
        log_memory_section_get(lmsec, &ms_params);
   178b8:	0030      	movs	r0, r6
   178ba:	a902      	add	r1, sp, #8
   178bc:	f000 f9a6 	bl	17c0c <log_memory_section_get>
        section_control[lmsec] = log_memory_section_get_control(lmsec);
   178c0:	0030      	movs	r0, r6
   178c2:	f000 f9b7 	bl	17c34 <log_memory_section_get_control>
        assert (POINTER_IN_LOG_MEMORY_REGION(ms_params.start));
   178c6:	9b02      	ldr	r3, [sp, #8]
        section_control[lmsec] = log_memory_section_get_control(lmsec);
   178c8:	4f1c      	ldr	r7, [pc, #112]	; (1793c <log_buffer_reader_init+0x94>)
   178ca:	00a6      	lsls	r6, r4, #2
        assert (POINTER_IN_LOG_MEMORY_REGION(ms_params.start));
   178cc:	0b9b      	lsrs	r3, r3, #14
        section_control[lmsec] = log_memory_section_get_control(lmsec);
   178ce:	51f0      	str	r0, [r6, r7]
        assert (POINTER_IN_LOG_MEMORY_REGION(ms_params.start));
   178d0:	039b      	lsls	r3, r3, #14
   178d2:	42ab      	cmp	r3, r5
   178d4:	d003      	beq.n	178de <log_buffer_reader_init+0x36>
   178d6:	9900      	ldr	r1, [sp, #0]
   178d8:	2016      	movs	r0, #22
   178da:	f7ea f919 	bl	1b10 <panic>
        assert (POINTER_IN_LOG_MEMORY_REGION(ms_params.start + ms_params.length -1));
   178de:	ab02      	add	r3, sp, #8
   178e0:	889b      	ldrh	r3, [r3, #4]
   178e2:	9a02      	ldr	r2, [sp, #8]
   178e4:	3b01      	subs	r3, #1
   178e6:	18d3      	adds	r3, r2, r3
   178e8:	0b9b      	lsrs	r3, r3, #14
   178ea:	9201      	str	r2, [sp, #4]
   178ec:	039b      	lsls	r3, r3, #14
   178ee:	42ab      	cmp	r3, r5
   178f0:	d003      	beq.n	178fa <log_buffer_reader_init+0x52>
   178f2:	9900      	ldr	r1, [sp, #0]
   178f4:	2016      	movs	r0, #22
   178f6:	f7ea f90b 	bl	1b10 <panic>

        if ( ! POINTER_IN_LOG_MEMORY_REGION(ms_params.start) || ! POINTER_IN_LOG_MEMORY_REGION(ms_params.start + ms_params.length -1) )
   178fa:	9902      	ldr	r1, [sp, #8]
   178fc:	0b8b      	lsrs	r3, r1, #14
   178fe:	039b      	lsls	r3, r3, #14
   17900:	42ab      	cmp	r3, r5
   17902:	d118      	bne.n	17936 <log_buffer_reader_init+0x8e>
   17904:	ab02      	add	r3, sp, #8
   17906:	889a      	ldrh	r2, [r3, #4]
   17908:	1e53      	subs	r3, r2, #1
   1790a:	18cb      	adds	r3, r1, r3
   1790c:	0b9b      	lsrs	r3, r3, #14
   1790e:	039b      	lsls	r3, r3, #14
   17910:	42ab      	cmp	r3, r5
   17912:	d110      	bne.n	17936 <log_buffer_reader_init+0x8e>
        {
            return LOG_READER_RET_ERROR_CORRUPT_SHARED_MEMORY;
        }

        buffer_reader_control[lmsec].log_buffer_start = ms_params.start; // first element
   17914:	4b0a      	ldr	r3, [pc, #40]	; (17940 <log_buffer_reader_init+0x98>)
   17916:	00e0      	lsls	r0, r4, #3
   17918:	50c1      	str	r1, [r0, r3]
        buffer_reader_control[lmsec].log_buffer_size  = ms_params.length; // buffer size
   1791a:	181b      	adds	r3, r3, r0


        l_read_i =section_control [lmsec]->read;
   1791c:	59b9      	ldr	r1, [r7, r6]
        buffer_reader_control[lmsec].log_buffer_size  = ms_params.length; // buffer size
   1791e:	809a      	strh	r2, [r3, #4]
        l_read_i =section_control [lmsec]->read;
   17920:	8809      	ldrh	r1, [r1, #0]
   17922:	b289      	uxth	r1, r1

        if ( l_read_i >= buffer_reader_control[lmsec].log_buffer_size )
   17924:	428a      	cmp	r2, r1
   17926:	d906      	bls.n	17936 <log_buffer_reader_init+0x8e>
   17928:	3401      	adds	r4, #1
        {
            return LOG_READER_RET_ERROR_CORRUPT_SHARED_MEMORY;
        }

        buffer_reader_control[lmsec].lb_next_to_consume = l_read_i;
   1792a:	80d9      	strh	r1, [r3, #6]
    for (LOG_MEMORY_REGION_SECTION lmsec = LOG_MEMORY_REGION_SECTION_0; lmsec < LOG_MEMORY_REGION_MAX_NUMBER; lmsec++)
   1792c:	2c03      	cmp	r4, #3
   1792e:	d1c2      	bne.n	178b6 <log_buffer_reader_init+0xe>
        ret_val = LOG_READER_RET_OK;
   17930:	2000      	movs	r0, #0
    }
    return ret_val;
}
   17932:	b005      	add	sp, #20
   17934:	bdf0      	pop	{r4, r5, r6, r7, pc}
            return LOG_READER_RET_ERROR_CORRUPT_SHARED_MEMORY;
   17936:	2008      	movs	r0, #8
   17938:	e7fb      	b.n	17932 <log_buffer_reader_init+0x8a>
   1793a:	46c0      	nop			; (mov r8, r8)
   1793c:	0100272c 	.word	0x0100272c
   17940:	01002714 	.word	0x01002714

00017944 <log_buffer_reader_lock_next>:
LOG_READER_RET log_buffer_reader_lock_next(LOG_MEMORY_REGION_SECTION * lmsec, log_buffer_header * lb_header)
{
    LOG_READER_RET helper_log_ret;
    log_buffer_header c_lb_header; // candidate header

    *lmsec = LOG_MEMORY_REGION_MAX_NUMBER;
   17944:	2303      	movs	r3, #3
{
   17946:	b5f0      	push	{r4, r5, r6, r7, lr}
   17948:	0006      	movs	r6, r0
   1794a:	000d      	movs	r5, r1
    *lmsec = LOG_MEMORY_REGION_MAX_NUMBER;
   1794c:	2400      	movs	r4, #0
{
   1794e:	b085      	sub	sp, #20
    *lmsec = LOG_MEMORY_REGION_MAX_NUMBER;
   17950:	7003      	strb	r3, [r0, #0]

    for (LOG_MEMORY_REGION_SECTION i_lmsec = LOG_MEMORY_REGION_SECTION_0; i_lmsec < LOG_MEMORY_REGION_MAX_NUMBER; i_lmsec++)
    {
        helper_log_ret = log_buffer_reader_get_msg_header(i_lmsec, lb_header, buffer_reader_control[i_lmsec].lb_next_to_consume);
   17952:	4a20      	ldr	r2, [pc, #128]	; (179d4 <log_buffer_reader_lock_next+0x90>)
   17954:	00e3      	lsls	r3, r4, #3
   17956:	18d3      	adds	r3, r2, r3
   17958:	88da      	ldrh	r2, [r3, #6]
   1795a:	b2e7      	uxtb	r7, r4
   1795c:	b292      	uxth	r2, r2
   1795e:	0029      	movs	r1, r5
   17960:	0038      	movs	r0, r7
   17962:	f7ff ff65 	bl	17830 <log_buffer_reader_get_msg_header>
        if ( helper_log_ret == LOG_READER_RET_OK)
   17966:	2800      	cmp	r0, #0
   17968:	d12f      	bne.n	179ca <log_buffer_reader_lock_next+0x86>
        {
            *lmsec = i_lmsec;
   1796a:	7037      	strb	r7, [r6, #0]
            break;
        }
    }

    if ( *lmsec < (LOG_MEMORY_REGION_MAX_NUMBER -1) )
   1796c:	7834      	ldrb	r4, [r6, #0]
   1796e:	2c01      	cmp	r4, #1
   17970:	d824      	bhi.n	179bc <log_buffer_reader_lock_next+0x78>
    {
        // There is already one candidate
        for (LOG_MEMORY_REGION_SECTION i_lmsec = (LOG_MEMORY_REGION_SECTION) (*lmsec +1); i_lmsec < LOG_MEMORY_REGION_MAX_NUMBER; i_lmsec++)
   17972:	3401      	adds	r4, #1
   17974:	b2e4      	uxtb	r4, r4
        {
            helper_log_ret = log_buffer_reader_get_msg_header(i_lmsec, &c_lb_header, buffer_reader_control[i_lmsec].lb_next_to_consume);
   17976:	4a17      	ldr	r2, [pc, #92]	; (179d4 <log_buffer_reader_lock_next+0x90>)
   17978:	00e3      	lsls	r3, r4, #3
   1797a:	18d3      	adds	r3, r2, r3
   1797c:	88da      	ldrh	r2, [r3, #6]
   1797e:	b2e7      	uxtb	r7, r4
   17980:	b292      	uxth	r2, r2
   17982:	a901      	add	r1, sp, #4
   17984:	0038      	movs	r0, r7
   17986:	f7ff ff53 	bl	17830 <log_buffer_reader_get_msg_header>
            if ( helper_log_ret == LOG_READER_RET_OK )
   1798a:	2800      	cmp	r0, #0
   1798c:	d112      	bne.n	179b4 <log_buffer_reader_lock_next+0x70>
            {
                if ((lb_header->time_us - c_lb_header.time_us) > 0 )
   1798e:	786a      	ldrb	r2, [r5, #1]
   17990:	782b      	ldrb	r3, [r5, #0]
   17992:	0212      	lsls	r2, r2, #8
   17994:	431a      	orrs	r2, r3
   17996:	78ab      	ldrb	r3, [r5, #2]
   17998:	041b      	lsls	r3, r3, #16
   1799a:	431a      	orrs	r2, r3
   1799c:	78eb      	ldrb	r3, [r5, #3]
   1799e:	061b      	lsls	r3, r3, #24
   179a0:	4313      	orrs	r3, r2
   179a2:	9a01      	ldr	r2, [sp, #4]
   179a4:	4293      	cmp	r3, r2
   179a6:	d005      	beq.n	179b4 <log_buffer_reader_lock_next+0x70>
                {
                    memcpy( (void*) lb_header, (const void * ) &c_lb_header, sizeof(log_buffer_header));
   179a8:	220a      	movs	r2, #10
   179aa:	a901      	add	r1, sp, #4
   179ac:	0028      	movs	r0, r5
   179ae:	f7e8 fc1f 	bl	1f0 <memcpy>
                    *lmsec = i_lmsec;
   179b2:	7037      	strb	r7, [r6, #0]
   179b4:	3401      	adds	r4, #1
        for (LOG_MEMORY_REGION_SECTION i_lmsec = (LOG_MEMORY_REGION_SECTION) (*lmsec +1); i_lmsec < LOG_MEMORY_REGION_MAX_NUMBER; i_lmsec++)
   179b6:	b2e3      	uxtb	r3, r4
   179b8:	2b03      	cmp	r3, #3
   179ba:	d1dc      	bne.n	17976 <log_buffer_reader_lock_next+0x32>
                }
            }
        }
    }

    if ( *lmsec == LOG_MEMORY_REGION_MAX_NUMBER)
   179bc:	7833      	ldrb	r3, [r6, #0]
    {
        // no new messages found
        return LOG_READER_RET_THERE_IS_NO_NEXT_MESSAGE;
   179be:	2005      	movs	r0, #5
    if ( *lmsec == LOG_MEMORY_REGION_MAX_NUMBER)
   179c0:	2b03      	cmp	r3, #3
   179c2:	d000      	beq.n	179c6 <log_buffer_reader_lock_next+0x82>
    }
    return LOG_READER_RET_OK;
   179c4:	2000      	movs	r0, #0
}
   179c6:	b005      	add	sp, #20
   179c8:	bdf0      	pop	{r4, r5, r6, r7, pc}
   179ca:	3401      	adds	r4, #1
    for (LOG_MEMORY_REGION_SECTION i_lmsec = LOG_MEMORY_REGION_SECTION_0; i_lmsec < LOG_MEMORY_REGION_MAX_NUMBER; i_lmsec++)
   179cc:	2c03      	cmp	r4, #3
   179ce:	d1c0      	bne.n	17952 <log_buffer_reader_lock_next+0xe>
   179d0:	e7cc      	b.n	1796c <log_buffer_reader_lock_next+0x28>
   179d2:	46c0      	nop			; (mov r8, r8)
   179d4:	01002714 	.word	0x01002714

000179d8 <log_buffer_get_used_space>:


//lint -esym(714, log_buffer_get_used_space) -esym(759, log_buffer_get_used_space)
LOG_READER_RET log_buffer_get_used_space(LOG_MEMORY_REGION_SECTION lmsec, uint16 * used_space)
{
   179d8:	b510      	push	{r4, lr}

    ret_value = LOG_READER_RET_OK;

    lmsec_reader_control = &buffer_reader_control[lmsec];

    l_write_i =section_control [lmsec]->write;
   179da:	4b0c      	ldr	r3, [pc, #48]	; (17a0c <log_buffer_get_used_space+0x34>)
   179dc:	0082      	lsls	r2, r0, #2
   179de:	58d3      	ldr	r3, [r2, r3]
    if ( l_write_i >= buffer_reader_control[lmsec].log_buffer_size )
   179e0:	4c0b      	ldr	r4, [pc, #44]	; (17a10 <log_buffer_get_used_space+0x38>)
   179e2:	00c0      	lsls	r0, r0, #3
    l_write_i =section_control [lmsec]->write;
   179e4:	889a      	ldrh	r2, [r3, #4]
    if ( l_write_i >= buffer_reader_control[lmsec].log_buffer_size )
   179e6:	1824      	adds	r4, r4, r0
   179e8:	88a3      	ldrh	r3, [r4, #4]
    l_write_i =section_control [lmsec]->write;
   179ea:	b292      	uxth	r2, r2
    {
        return LOG_READER_RET_ERROR_CORRUPT_SHARED_MEMORY;
   179ec:	2008      	movs	r0, #8
    if ( l_write_i >= buffer_reader_control[lmsec].log_buffer_size )
   179ee:	4293      	cmp	r3, r2
   179f0:	d907      	bls.n	17a02 <log_buffer_get_used_space+0x2a>
    }
    *used_space = log_buffer_get_used( lmsec_reader_control, lmsec_reader_control->lb_next_to_consume, l_write_i); // data between the index and the write
   179f2:	88e0      	ldrh	r0, [r4, #6]
   179f4:	b280      	uxth	r0, r0
   179f6:	1a14      	subs	r4, r2, r0
    if (read_i <= write_i)
   179f8:	4290      	cmp	r0, r2
   179fa:	d803      	bhi.n	17a04 <log_buffer_get_used_space+0x2c>
        in_use = write_i - read_i;
   179fc:	b2a3      	uxth	r3, r4

    return ret_value;
   179fe:	2000      	movs	r0, #0
    *used_space = log_buffer_get_used( lmsec_reader_control, lmsec_reader_control->lb_next_to_consume, l_write_i); // data between the index and the write
   17a00:	800b      	strh	r3, [r1, #0]
}
   17a02:	bd10      	pop	{r4, pc}
        in_use = (lmscontrol->log_buffer_size - read_i) + write_i;
   17a04:	191b      	adds	r3, r3, r4
   17a06:	b29b      	uxth	r3, r3
   17a08:	e7f9      	b.n	179fe <log_buffer_get_used_space+0x26>
   17a0a:	46c0      	nop			; (mov r8, r8)
   17a0c:	0100272c 	.word	0x0100272c
   17a10:	01002714 	.word	0x01002714

00017a14 <log_buffer_reader_claim_next>:

//lint -esym(714, log_buffer_reader_claim_next)   Only used on core with log_reader
LOG_READER_RET log_buffer_reader_claim_next(LOG_MEMORY_REGION_SECTION lmsec, uint8 ** r1, uint16 * len1, uint8 ** r2, uint16 * len2)
{
   17a14:	b5f0      	push	{r4, r5, r6, r7, lr}
   17a16:	4674      	mov	r4, lr
    LOG_READER_RET ret_value;
    uint16 l_write_i;
    uint16 new_next_to_consume;

    // Get the next message header
    ret_value = log_buffer_reader_get_msg_header(lmsec, &lb_header, lmsec_reader_control->lb_next_to_consume);
   17a18:	4e43      	ldr	r6, [pc, #268]	; (17b28 <log_buffer_reader_claim_next+0x114>)
   17a1a:	00c7      	lsls	r7, r0, #3
{
   17a1c:	b08b      	sub	sp, #44	; 0x2c
    ret_value = log_buffer_reader_get_msg_header(lmsec, &lb_header, lmsec_reader_control->lb_next_to_consume);
   17a1e:	19f5      	adds	r5, r6, r7
{
   17a20:	9203      	str	r2, [sp, #12]
    ret_value = log_buffer_reader_get_msg_header(lmsec, &lb_header, lmsec_reader_control->lb_next_to_consume);
   17a22:	88ea      	ldrh	r2, [r5, #6]
{
   17a24:	9105      	str	r1, [sp, #20]
    ret_value = log_buffer_reader_get_msg_header(lmsec, &lb_header, lmsec_reader_control->lb_next_to_consume);
   17a26:	b292      	uxth	r2, r2
   17a28:	a907      	add	r1, sp, #28
   17a2a:	9404      	str	r4, [sp, #16]
{
   17a2c:	9002      	str	r0, [sp, #8]
   17a2e:	001c      	movs	r4, r3
    ret_value = log_buffer_reader_get_msg_header(lmsec, &lb_header, lmsec_reader_control->lb_next_to_consume);
   17a30:	f7ff fefe 	bl	17830 <log_buffer_reader_get_msg_header>
   17a34:	9001      	str	r0, [sp, #4]

    if (ret_value == LOG_READER_RET_OK)
   17a36:	2800      	cmp	r0, #0
   17a38:	d158      	bne.n	17aec <log_buffer_reader_claim_next+0xd8>
    {
        // Get the buffer pointers
        ret_r1 = circled_index ( lmsec_reader_control, lmsec_reader_control->lb_next_to_consume + sizeof(log_buffer_header) );
   17a3a:	88e9      	ldrh	r1, [r5, #6]
   17a3c:	0028      	movs	r0, r5
   17a3e:	310a      	adds	r1, #10
   17a40:	b289      	uxth	r1, r1
   17a42:	f7ff fee5 	bl	17810 <circled_index>
        if ( ret_r1 + lb_header.msg_header.length <= lmsec_reader_control->log_buffer_size )
   17a46:	ab06      	add	r3, sp, #24
   17a48:	899b      	ldrh	r3, [r3, #12]
   17a4a:	88aa      	ldrh	r2, [r5, #4]
   17a4c:	18c1      	adds	r1, r0, r3
   17a4e:	4291      	cmp	r1, r2
   17a50:	dc4f      	bgt.n	17af2 <log_buffer_reader_claim_next+0xde>
        {
            /* 'Normal' case */
            *r1 = lmsec_reader_control->log_buffer_start + ret_r1;
   17a52:	59ba      	ldr	r2, [r7, r6]
   17a54:	1810      	adds	r0, r2, r0
   17a56:	9a05      	ldr	r2, [sp, #20]
   17a58:	6010      	str	r0, [r2, #0]
            *len1 = lb_header.msg_header.length;
   17a5a:	9a03      	ldr	r2, [sp, #12]
   17a5c:	8013      	strh	r3, [r2, #0]
            *r2 = NULL;
            *len2 = 0;
   17a5e:	466a      	mov	r2, sp
            *r2 = NULL;
   17a60:	9b01      	ldr	r3, [sp, #4]
            *len2 = 0;
   17a62:	8892      	ldrh	r2, [r2, #4]
            *r2 = NULL;
   17a64:	6023      	str	r3, [r4, #0]
            *len2 = 0;
   17a66:	9b10      	ldr	r3, [sp, #64]	; 0x40
   17a68:	801a      	strh	r2, [r3, #0]
            *len2 = lb_header.msg_header.length - *len1;
            assert( *len2 <= lmsec_reader_control->log_buffer_size );
        }

        // Assert if log_section_control->read tries to overflow lb_next_to_consume
        l_write_i = section_control[lmsec]->write;
   17a6a:	9b02      	ldr	r3, [sp, #8]
        new_next_to_consume = circled_index ( lmsec_reader_control, lmsec_reader_control->lb_next_to_consume + sizeof(log_buffer_header) + lb_header.msg_header.length);
   17a6c:	0028      	movs	r0, r5
        l_write_i = section_control[lmsec]->write;
   17a6e:	009a      	lsls	r2, r3, #2
   17a70:	4b2e      	ldr	r3, [pc, #184]	; (17b2c <log_buffer_reader_claim_next+0x118>)
   17a72:	58d3      	ldr	r3, [r2, r3]
   17a74:	889c      	ldrh	r4, [r3, #4]
        new_next_to_consume = circled_index ( lmsec_reader_control, lmsec_reader_control->lb_next_to_consume + sizeof(log_buffer_header) + lb_header.msg_header.length);
   17a76:	9b02      	ldr	r3, [sp, #8]
        l_write_i = section_control[lmsec]->write;
   17a78:	b2a4      	uxth	r4, r4
        new_next_to_consume = circled_index ( lmsec_reader_control, lmsec_reader_control->lb_next_to_consume + sizeof(log_buffer_header) + lb_header.msg_header.length);
   17a7a:	00df      	lsls	r7, r3, #3
   17a7c:	ab07      	add	r3, sp, #28
   17a7e:	19f6      	adds	r6, r6, r7
   17a80:	891b      	ldrh	r3, [r3, #8]
   17a82:	88f1      	ldrh	r1, [r6, #6]
   17a84:	330a      	adds	r3, #10
   17a86:	18c9      	adds	r1, r1, r3
   17a88:	b289      	uxth	r1, r1
   17a8a:	f7ff fec1 	bl	17810 <circled_index>
        // equivalent to:  if (write > next_to_consume) { assert ( (new_next_to_consume <= write) && (new_next_to_consume > next_to_consume) ) }
        assert( (lmsec_reader_control->lb_next_to_consume >= l_write_i) || ( (new_next_to_consume <= l_write_i) && (new_next_to_consume > lmsec_reader_control->lb_next_to_consume) ) );
   17a8e:	88f3      	ldrh	r3, [r6, #6]
        new_next_to_consume = circled_index ( lmsec_reader_control, lmsec_reader_control->lb_next_to_consume + sizeof(log_buffer_header) + lb_header.msg_header.length);
   17a90:	0005      	movs	r5, r0
        assert( (lmsec_reader_control->lb_next_to_consume >= l_write_i) || ( (new_next_to_consume <= l_write_i) && (new_next_to_consume > lmsec_reader_control->lb_next_to_consume) ) );
   17a92:	42a3      	cmp	r3, r4
   17a94:	d208      	bcs.n	17aa8 <log_buffer_reader_claim_next+0x94>
   17a96:	4284      	cmp	r4, r0
   17a98:	d302      	bcc.n	17aa0 <log_buffer_reader_claim_next+0x8c>
   17a9a:	88f3      	ldrh	r3, [r6, #6]
   17a9c:	4283      	cmp	r3, r0
   17a9e:	d303      	bcc.n	17aa8 <log_buffer_reader_claim_next+0x94>
   17aa0:	9904      	ldr	r1, [sp, #16]
   17aa2:	2016      	movs	r0, #22
   17aa4:	f7ea f834 	bl	1b10 <panic>
        // equivalent to:  if (next_to_consume > write) { assert ( (new_next_to_consume <= write) && (new_next_to_consume > next_to_consume) ) }
        assert( (lmsec_reader_control->lb_next_to_consume <= l_write_i) || ( (new_next_to_consume <= lmsec_reader_control->lb_next_to_consume) || (new_next_to_consume > l_write_i) ) );
   17aa8:	4e1f      	ldr	r6, [pc, #124]	; (17b28 <log_buffer_reader_claim_next+0x114>)
   17aaa:	19f3      	adds	r3, r6, r7
   17aac:	88da      	ldrh	r2, [r3, #6]
   17aae:	42a2      	cmp	r2, r4
   17ab0:	d908      	bls.n	17ac4 <log_buffer_reader_claim_next+0xb0>
   17ab2:	88db      	ldrh	r3, [r3, #6]
   17ab4:	42ab      	cmp	r3, r5
   17ab6:	d205      	bcs.n	17ac4 <log_buffer_reader_claim_next+0xb0>
   17ab8:	42ac      	cmp	r4, r5
   17aba:	d303      	bcc.n	17ac4 <log_buffer_reader_claim_next+0xb0>
   17abc:	9904      	ldr	r1, [sp, #16]
   17abe:	2016      	movs	r0, #22
   17ac0:	f7ea f826 	bl	1b10 <panic>

        if (  ( (lmsec_reader_control->lb_next_to_consume >= l_write_i) || ( (new_next_to_consume <= l_write_i) && (new_next_to_consume > lmsec_reader_control->lb_next_to_consume) ) )
   17ac4:	19f3      	adds	r3, r6, r7
   17ac6:	88da      	ldrh	r2, [r3, #6]
   17ac8:	42a2      	cmp	r2, r4
   17aca:	d204      	bcs.n	17ad6 <log_buffer_reader_claim_next+0xc2>
   17acc:	42ac      	cmp	r4, r5
   17ace:	d328      	bcc.n	17b22 <log_buffer_reader_claim_next+0x10e>
   17ad0:	88db      	ldrh	r3, [r3, #6]
   17ad2:	42ab      	cmp	r3, r5
   17ad4:	d225      	bcs.n	17b22 <log_buffer_reader_claim_next+0x10e>
                && ( (lmsec_reader_control->lb_next_to_consume <= l_write_i) || ( (new_next_to_consume <= lmsec_reader_control->lb_next_to_consume) || (new_next_to_consume > l_write_i) ) ) )
   17ad6:	19f3      	adds	r3, r6, r7
   17ad8:	88da      	ldrh	r2, [r3, #6]
   17ada:	42a2      	cmp	r2, r4
   17adc:	d904      	bls.n	17ae8 <log_buffer_reader_claim_next+0xd4>
   17ade:	88db      	ldrh	r3, [r3, #6]
   17ae0:	42ab      	cmp	r3, r5
   17ae2:	d201      	bcs.n	17ae8 <log_buffer_reader_claim_next+0xd4>
   17ae4:	42ac      	cmp	r4, r5
   17ae6:	d21c      	bcs.n	17b22 <log_buffer_reader_claim_next+0x10e>
        {
            // Move the lb_next_to_consume data
            log_buffer_reader_control * writable_lmsec_reader_control = &buffer_reader_control[lmsec];
            writable_lmsec_reader_control->lb_next_to_consume = new_next_to_consume;
   17ae8:	19f7      	adds	r7, r6, r7
   17aea:	80fd      	strh	r5, [r7, #6]
        }

    }

    return ret_value;
}
   17aec:	9801      	ldr	r0, [sp, #4]
   17aee:	b00b      	add	sp, #44	; 0x2c
   17af0:	bdf0      	pop	{r4, r5, r6, r7, pc}
            *r1 = lmsec_reader_control->log_buffer_start + ret_r1;
   17af2:	59ba      	ldr	r2, [r7, r6]
   17af4:	9905      	ldr	r1, [sp, #20]
   17af6:	1812      	adds	r2, r2, r0
   17af8:	600a      	str	r2, [r1, #0]
            *len1 = lmsec_reader_control->log_buffer_size - ret_r1;
   17afa:	88aa      	ldrh	r2, [r5, #4]
   17afc:	1a10      	subs	r0, r2, r0
   17afe:	9a03      	ldr	r2, [sp, #12]
   17b00:	8010      	strh	r0, [r2, #0]
            *r2 = lmsec_reader_control->log_buffer_start;
   17b02:	59ba      	ldr	r2, [r7, r6]
   17b04:	6022      	str	r2, [r4, #0]
            *len2 = lb_header.msg_header.length - *len1;
   17b06:	9a03      	ldr	r2, [sp, #12]
   17b08:	8812      	ldrh	r2, [r2, #0]
   17b0a:	1a9b      	subs	r3, r3, r2
   17b0c:	9a10      	ldr	r2, [sp, #64]	; 0x40
   17b0e:	b29b      	uxth	r3, r3
   17b10:	8013      	strh	r3, [r2, #0]
            assert( *len2 <= lmsec_reader_control->log_buffer_size );
   17b12:	88aa      	ldrh	r2, [r5, #4]
   17b14:	429a      	cmp	r2, r3
   17b16:	d2a8      	bcs.n	17a6a <log_buffer_reader_claim_next+0x56>
   17b18:	9904      	ldr	r1, [sp, #16]
   17b1a:	2016      	movs	r0, #22
   17b1c:	f7e9 fff8 	bl	1b10 <panic>
   17b20:	e7a3      	b.n	17a6a <log_buffer_reader_claim_next+0x56>
            ret_value = LOG_READER_RET_ERROR_CORRUPT_SHARED_MEMORY;
   17b22:	2308      	movs	r3, #8
   17b24:	9301      	str	r3, [sp, #4]
   17b26:	e7e1      	b.n	17aec <log_buffer_reader_claim_next+0xd8>
   17b28:	01002714 	.word	0x01002714
   17b2c:	0100272c 	.word	0x0100272c

00017b30 <log_buffer_reader_discard>:

//lint -esym(714, log_buffer_reader_discard)   Only used on core with log_reader
LOG_READER_RET log_buffer_reader_discard (LOG_MEMORY_REGION_SECTION lmsec)
{
   17b30:	4673      	mov	r3, lr
   17b32:	b5f0      	push	{r4, r5, r6, r7, lr}
   17b34:	b089      	sub	sp, #36	; 0x24
   17b36:	9302      	str	r3, [sp, #8]
   17b38:	0005      	movs	r5, r0
    const log_buffer_reader_control * lmscontrol = &buffer_reader_control[lmsec];
    LOG_READER_RET ret_value;
    uint16 l_read_i;
    uint16 new_lb_read;

    assert( lmsec < LOG_MEMORY_REGION_MAX_NUMBER);
   17b3a:	2802      	cmp	r0, #2
   17b3c:	d951      	bls.n	17be2 <log_buffer_reader_discard+0xb2>
   17b3e:	4671      	mov	r1, lr
   17b40:	2016      	movs	r0, #22
   17b42:	f7e9 ffe5 	bl	1b10 <panic>
    if ( lmsec >= LOG_MEMORY_REGION_MAX_NUMBER)
    {
        return LOG_READER_RET_ERROR_IN_PARAMS;
   17b46:	2706      	movs	r7, #6
            return LOG_READER_RET_ERROR_CORRUPT_SHARED_MEMORY; // Trying to overflow
        }
    }

    return LOG_READER_RET_OK;
}
   17b48:	0038      	movs	r0, r7
   17b4a:	b009      	add	sp, #36	; 0x24
   17b4c:	bdf0      	pop	{r4, r5, r6, r7, pc}
        new_lb_read = circled_index ( lmscontrol, l_read_i + sizeof(log_buffer_header) + lb_header.msg_header.length);
   17b4e:	8931      	ldrh	r1, [r6, #8]
    const log_buffer_reader_control * lmscontrol = &buffer_reader_control[lmsec];
   17b50:	4a2c      	ldr	r2, [pc, #176]	; (17c04 <log_buffer_reader_discard+0xd4>)
        new_lb_read = circled_index ( lmscontrol, l_read_i + sizeof(log_buffer_header) + lb_header.msg_header.length);
   17b52:	310a      	adds	r1, #10
    const log_buffer_reader_control * lmscontrol = &buffer_reader_control[lmsec];
   17b54:	00eb      	lsls	r3, r5, #3
   17b56:	18d3      	adds	r3, r2, r3
        new_lb_read = circled_index ( lmscontrol, l_read_i + sizeof(log_buffer_header) + lb_header.msg_header.length);
   17b58:	1861      	adds	r1, r4, r1
   17b5a:	0018      	movs	r0, r3
   17b5c:	b289      	uxth	r1, r1
    const log_buffer_reader_control * lmscontrol = &buffer_reader_control[lmsec];
   17b5e:	9301      	str	r3, [sp, #4]
        new_lb_read = circled_index ( lmscontrol, l_read_i + sizeof(log_buffer_header) + lb_header.msg_header.length);
   17b60:	f7ff fe56 	bl	17810 <circled_index>
        assert( (lmscontrol->lb_next_to_consume <= l_read_i) || ( (new_lb_read <= lmscontrol->lb_next_to_consume) && (new_lb_read > l_read_i) ) );
   17b64:	9b01      	ldr	r3, [sp, #4]
        new_lb_read = circled_index ( lmscontrol, l_read_i + sizeof(log_buffer_header) + lb_header.msg_header.length);
   17b66:	0006      	movs	r6, r0
        assert( (lmscontrol->lb_next_to_consume <= l_read_i) || ( (new_lb_read <= lmscontrol->lb_next_to_consume) && (new_lb_read > l_read_i) ) );
   17b68:	88db      	ldrh	r3, [r3, #6]
   17b6a:	42a3      	cmp	r3, r4
   17b6c:	d909      	bls.n	17b82 <log_buffer_reader_discard+0x52>
   17b6e:	9b01      	ldr	r3, [sp, #4]
   17b70:	88db      	ldrh	r3, [r3, #6]
   17b72:	4283      	cmp	r3, r0
   17b74:	d301      	bcc.n	17b7a <log_buffer_reader_discard+0x4a>
   17b76:	4284      	cmp	r4, r0
   17b78:	d303      	bcc.n	17b82 <log_buffer_reader_discard+0x52>
   17b7a:	9902      	ldr	r1, [sp, #8]
   17b7c:	2016      	movs	r0, #22
   17b7e:	f7e9 ffc7 	bl	1b10 <panic>
        assert( (lmscontrol->lb_next_to_consume >= l_read_i) || ( (new_lb_read <= lmscontrol->lb_next_to_consume) || (new_lb_read > l_read_i) ) );
   17b82:	4a20      	ldr	r2, [pc, #128]	; (17c04 <log_buffer_reader_discard+0xd4>)
   17b84:	00eb      	lsls	r3, r5, #3
   17b86:	18d3      	adds	r3, r2, r3
   17b88:	88da      	ldrh	r2, [r3, #6]
   17b8a:	42a2      	cmp	r2, r4
   17b8c:	d208      	bcs.n	17ba0 <log_buffer_reader_discard+0x70>
   17b8e:	88db      	ldrh	r3, [r3, #6]
   17b90:	42b3      	cmp	r3, r6
   17b92:	d205      	bcs.n	17ba0 <log_buffer_reader_discard+0x70>
   17b94:	42b4      	cmp	r4, r6
   17b96:	d303      	bcc.n	17ba0 <log_buffer_reader_discard+0x70>
   17b98:	9902      	ldr	r1, [sp, #8]
   17b9a:	2016      	movs	r0, #22
   17b9c:	f7e9 ffb8 	bl	1b10 <panic>
        if (  ((lmscontrol->lb_next_to_consume <= l_read_i) || ( (new_lb_read <= lmscontrol->lb_next_to_consume) && (new_lb_read > l_read_i) ) )
   17ba0:	4b18      	ldr	r3, [pc, #96]	; (17c04 <log_buffer_reader_discard+0xd4>)
   17ba2:	00ed      	lsls	r5, r5, #3
   17ba4:	195b      	adds	r3, r3, r5
   17ba6:	88da      	ldrh	r2, [r3, #6]
   17ba8:	42a2      	cmp	r2, r4
   17baa:	d904      	bls.n	17bb6 <log_buffer_reader_discard+0x86>
   17bac:	88db      	ldrh	r3, [r3, #6]
   17bae:	42b3      	cmp	r3, r6
   17bb0:	d315      	bcc.n	17bde <log_buffer_reader_discard+0xae>
   17bb2:	42b4      	cmp	r4, r6
   17bb4:	d213      	bcs.n	17bde <log_buffer_reader_discard+0xae>
                && ( (lmscontrol->lb_next_to_consume >= l_read_i) || ( (new_lb_read <= lmscontrol->lb_next_to_consume) || (new_lb_read > l_read_i) ) )
   17bb6:	4b13      	ldr	r3, [pc, #76]	; (17c04 <log_buffer_reader_discard+0xd4>)
   17bb8:	195b      	adds	r3, r3, r5
   17bba:	88da      	ldrh	r2, [r3, #6]
   17bbc:	42a2      	cmp	r2, r4
   17bbe:	d204      	bcs.n	17bca <log_buffer_reader_discard+0x9a>
   17bc0:	88db      	ldrh	r3, [r3, #6]
   17bc2:	42b3      	cmp	r3, r6
   17bc4:	d201      	bcs.n	17bca <log_buffer_reader_discard+0x9a>
   17bc6:	42b4      	cmp	r4, r6
   17bc8:	d209      	bcs.n	17bde <log_buffer_reader_discard+0xae>
                && ( new_lb_read < lmscontrol->log_buffer_size))
   17bca:	4b0e      	ldr	r3, [pc, #56]	; (17c04 <log_buffer_reader_discard+0xd4>)
   17bcc:	195d      	adds	r5, r3, r5
   17bce:	88ab      	ldrh	r3, [r5, #4]
   17bd0:	42b3      	cmp	r3, r6
   17bd2:	d904      	bls.n	17bde <log_buffer_reader_discard+0xae>
            section_control [lmsec]->read = new_lb_read;
   17bd4:	4b0c      	ldr	r3, [pc, #48]	; (17c08 <log_buffer_reader_discard+0xd8>)
   17bd6:	9a03      	ldr	r2, [sp, #12]
   17bd8:	589b      	ldr	r3, [r3, r2]
   17bda:	801e      	strh	r6, [r3, #0]
   17bdc:	e7b4      	b.n	17b48 <log_buffer_reader_discard+0x18>
            return LOG_READER_RET_ERROR_CORRUPT_SHARED_MEMORY; // Trying to overflow
   17bde:	2708      	movs	r7, #8
   17be0:	e7b2      	b.n	17b48 <log_buffer_reader_discard+0x18>
    l_read_i = section_control[lmsec]->read;
   17be2:	0083      	lsls	r3, r0, #2
   17be4:	9303      	str	r3, [sp, #12]
   17be6:	4b08      	ldr	r3, [pc, #32]	; (17c08 <log_buffer_reader_discard+0xd8>)
   17be8:	0082      	lsls	r2, r0, #2
   17bea:	58d3      	ldr	r3, [r2, r3]
    ret_value = log_buffer_reader_get_msg_header(lmsec, &lb_header, l_read_i );
   17bec:	ae05      	add	r6, sp, #20
    l_read_i = section_control[lmsec]->read;
   17bee:	881c      	ldrh	r4, [r3, #0]
    ret_value = log_buffer_reader_get_msg_header(lmsec, &lb_header, l_read_i );
   17bf0:	0031      	movs	r1, r6
    l_read_i = section_control[lmsec]->read;
   17bf2:	b2a4      	uxth	r4, r4
    ret_value = log_buffer_reader_get_msg_header(lmsec, &lb_header, l_read_i );
   17bf4:	0022      	movs	r2, r4
    l_read_i = section_control[lmsec]->read;
   17bf6:	9301      	str	r3, [sp, #4]
    ret_value = log_buffer_reader_get_msg_header(lmsec, &lb_header, l_read_i );
   17bf8:	f7ff fe1a 	bl	17830 <log_buffer_reader_get_msg_header>
   17bfc:	1e07      	subs	r7, r0, #0
    if (ret_value == LOG_READER_RET_OK)
   17bfe:	d0a6      	beq.n	17b4e <log_buffer_reader_discard+0x1e>
    return LOG_READER_RET_OK;
   17c00:	2700      	movs	r7, #0
   17c02:	e7a1      	b.n	17b48 <log_buffer_reader_discard+0x18>
   17c04:	01002714 	.word	0x01002714
   17c08:	0100272c 	.word	0x0100272c

00017c0c <log_memory_section_get>:
/*
 *  Public function definitions
 */

void log_memory_section_get(LOG_MEMORY_REGION_SECTION section, log_memory_section_params * section_data)
{
   17c0c:	b510      	push	{r4, lr}
   17c0e:	24c0      	movs	r4, #192	; 0xc0
   17c10:	0043      	lsls	r3, r0, #1
   17c12:	04a4      	lsls	r4, r4, #18
   17c14:	191b      	adds	r3, r3, r4
    const log_memory_region_control * log_region_control= (const log_memory_region_control *) LOG_MEMORY_REGION_CONTROL_BLOCK_POINTER;
    section_data->start = (uint8 *) (LOG_REGION_MEMORY_START + log_region_control->offset[section]);
   17c16:	881a      	ldrh	r2, [r3, #0]
   17c18:	1912      	adds	r2, r2, r4
   17c1a:	600a      	str	r2, [r1, #0]
    // section_data has been previously initialized by the security core.
    if (section == LOG_MEMORY_REGION_MAX_NUMBER - 1 ) // If it is the last section use the length in stead
   17c1c:	2802      	cmp	r0, #2
   17c1e:	d104      	bne.n	17c2a <log_memory_section_get+0x1e>
    {
        section_data->length = log_region_control->length - log_region_control->offset[section];
   17c20:	88e3      	ldrh	r3, [r4, #6]
   17c22:	88a2      	ldrh	r2, [r4, #4]
   17c24:	1a9b      	subs	r3, r3, r2
    }
    else
    {
        section_data->length = log_region_control->offset[section+1] - log_region_control->offset[section];
   17c26:	808b      	strh	r3, [r1, #4]
    }
}
   17c28:	bd10      	pop	{r4, pc}
        section_data->length = log_region_control->offset[section+1] - log_region_control->offset[section];
   17c2a:	885a      	ldrh	r2, [r3, #2]
   17c2c:	881b      	ldrh	r3, [r3, #0]
   17c2e:	1ad3      	subs	r3, r2, r3
   17c30:	e7f9      	b.n	17c26 <log_memory_section_get+0x1a>
	...

00017c34 <log_memory_section_get_control>:


log_memory_section_control *  log_memory_section_get_control( LOG_MEMORY_REGION_SECTION section )
{
    log_memory_region_control * log_region_control= (log_memory_region_control *) LOG_MEMORY_REGION_CONTROL_BLOCK_POINTER;
    return &log_region_control->section_control[section];
   17c34:	4b01      	ldr	r3, [pc, #4]	; (17c3c <log_memory_section_get_control+0x8>)
   17c36:	00c0      	lsls	r0, r0, #3
   17c38:	18c0      	adds	r0, r0, r3
}
   17c3a:	4770      	bx	lr
   17c3c:	03000008 	.word	0x03000008

00017c40 <lp_uart_get_buffer_level>:

static uint8 rx_irq_threshold_level;

static uint8 lp_uart_get_buffer_level(void)
{
    int16 buffer_level = lp_uart_buffer_write_pos - lp_uart_buffer_read_pos;
   17c40:	4b06      	ldr	r3, [pc, #24]	; (17c5c <lp_uart_get_buffer_level+0x1c>)
   17c42:	4a07      	ldr	r2, [pc, #28]	; (17c60 <lp_uart_get_buffer_level+0x20>)
   17c44:	781b      	ldrb	r3, [r3, #0]
   17c46:	7810      	ldrb	r0, [r2, #0]
   17c48:	1a1b      	subs	r3, r3, r0
   17c4a:	b29b      	uxth	r3, r3
   17c4c:	b218      	sxth	r0, r3
    if (buffer_level < 0)
   17c4e:	2800      	cmp	r0, #0
   17c50:	da01      	bge.n	17c56 <lp_uart_get_buffer_level+0x16>
    {
        buffer_level = (LP_UART_MAX_BUFFER - lp_uart_buffer_read_pos) + lp_uart_buffer_write_pos;
   17c52:	3340      	adds	r3, #64	; 0x40
   17c54:	b218      	sxth	r0, r3
    }

    return (uint8)(buffer_level);
   17c56:	b2c0      	uxtb	r0, r0
}
   17c58:	4770      	bx	lr
   17c5a:	46c0      	nop			; (mov r8, r8)
   17c5c:	01002755 	.word	0x01002755
   17c60:	01002754 	.word	0x01002754

00017c64 <lp_uart_determine_rx_flow_control>:
        return false;
    }
}

static void lp_uart_determine_rx_flow_control( void )
{
   17c64:	b570      	push	{r4, r5, r6, lr}
    if( lp_uart_rx_flow_control_callback != NULL )
   17c66:	4b0c      	ldr	r3, [pc, #48]	; (17c98 <lp_uart_determine_rx_flow_control+0x34>)
   17c68:	681c      	ldr	r4, [r3, #0]
   17c6a:	2c00      	cmp	r4, #0
   17c6c:	d00c      	beq.n	17c88 <lp_uart_determine_rx_flow_control+0x24>
    {
        if( !lp_uart_rx_flow_control_asserted && (lp_uart_get_buffer_level() >= lp_uart_rx_buffer_upper_water_margin) )
   17c6e:	4d0b      	ldr	r5, [pc, #44]	; (17c9c <lp_uart_determine_rx_flow_control+0x38>)
   17c70:	782e      	ldrb	r6, [r5, #0]
   17c72:	f7ff ffe5 	bl	17c40 <lp_uart_get_buffer_level>
   17c76:	2e00      	cmp	r6, #0
   17c78:	d107      	bne.n	17c8a <lp_uart_determine_rx_flow_control+0x26>
   17c7a:	4b09      	ldr	r3, [pc, #36]	; (17ca0 <lp_uart_determine_rx_flow_control+0x3c>)
   17c7c:	781b      	ldrb	r3, [r3, #0]
   17c7e:	4283      	cmp	r3, r0
   17c80:	d802      	bhi.n	17c88 <lp_uart_determine_rx_flow_control+0x24>
        {
            lp_uart_rx_flow_control_asserted = true;
   17c82:	2001      	movs	r0, #1
            lp_uart_rx_flow_control_callback( lp_uart_rx_flow_control_asserted );
        }
        else if( lp_uart_rx_flow_control_asserted && (lp_uart_get_buffer_level() <= lp_uart_rx_buffer_lower_water_margin) )
        {
            lp_uart_rx_flow_control_asserted = false;
   17c84:	7028      	strb	r0, [r5, #0]
            lp_uart_rx_flow_control_callback( lp_uart_rx_flow_control_asserted );
   17c86:	47a0      	blx	r4
        }
    }
}
   17c88:	bd70      	pop	{r4, r5, r6, pc}
        else if( lp_uart_rx_flow_control_asserted && (lp_uart_get_buffer_level() <= lp_uart_rx_buffer_lower_water_margin) )
   17c8a:	4b06      	ldr	r3, [pc, #24]	; (17ca4 <lp_uart_determine_rx_flow_control+0x40>)
   17c8c:	781b      	ldrb	r3, [r3, #0]
   17c8e:	4283      	cmp	r3, r0
   17c90:	d3fa      	bcc.n	17c88 <lp_uart_determine_rx_flow_control+0x24>
            lp_uart_rx_flow_control_asserted = false;
   17c92:	2000      	movs	r0, #0
   17c94:	e7f6      	b.n	17c84 <lp_uart_determine_rx_flow_control+0x20>
   17c96:	46c0      	nop			; (mov r8, r8)
   17c98:	010027dc 	.word	0x010027dc
   17c9c:	010027db 	.word	0x010027db
   17ca0:	010027d9 	.word	0x010027d9
   17ca4:	010027d8 	.word	0x010027d8

00017ca8 <lp_uart_call_interrupt>:
        assert(false);
    }
}

static inline void lp_uart_call_interrupt(LP_UART_INTERRUPT irq, bool error)
{
   17ca8:	b510      	push	{r4, lr}
    if (lp_callbacks[irq] != NULL)
   17caa:	4a04      	ldr	r2, [pc, #16]	; (17cbc <lp_uart_call_interrupt+0x14>)
   17cac:	0080      	lsls	r0, r0, #2
   17cae:	5883      	ldr	r3, [r0, r2]
   17cb0:	2b00      	cmp	r3, #0
   17cb2:	d001      	beq.n	17cb8 <lp_uart_call_interrupt+0x10>
    {
        lp_callbacks[irq](error);
   17cb4:	0008      	movs	r0, r1
   17cb6:	4798      	blx	r3
    }
}
   17cb8:	bd10      	pop	{r4, pc}
   17cba:	46c0      	nop			; (mov r8, r8)
   17cbc:	0100273c 	.word	0x0100273c

00017cc0 <lp_uart_release_pins>:
{
   17cc0:	b510      	push	{r4, lr}
    if( lp_rx != PIN_NONE )
   17cc2:	4c08      	ldr	r4, [pc, #32]	; (17ce4 <lp_uart_release_pins+0x24>)
   17cc4:	7820      	ldrb	r0, [r4, #0]
   17cc6:	2828      	cmp	r0, #40	; 0x28
   17cc8:	d003      	beq.n	17cd2 <lp_uart_release_pins+0x12>
        (void)pio_release( lp_rx );
   17cca:	f000 fad0 	bl	1826e <pio_release>
        lp_rx = PIN_NONE;
   17cce:	2328      	movs	r3, #40	; 0x28
   17cd0:	7023      	strb	r3, [r4, #0]
    if( lp_rts != PIN_NONE )
   17cd2:	4c05      	ldr	r4, [pc, #20]	; (17ce8 <lp_uart_release_pins+0x28>)
   17cd4:	7820      	ldrb	r0, [r4, #0]
   17cd6:	2828      	cmp	r0, #40	; 0x28
   17cd8:	d003      	beq.n	17ce2 <lp_uart_release_pins+0x22>
        gpio_release( lp_rts );
   17cda:	f7ff fa93 	bl	17204 <gpio_release>
        lp_rts = PIN_NONE;
   17cde:	2328      	movs	r3, #40	; 0x28
   17ce0:	7023      	strb	r3, [r4, #0]
}
   17ce2:	bd10      	pop	{r4, pc}
   17ce4:	010005d1 	.word	0x010005d1
   17ce8:	010005d0 	.word	0x010005d0

00017cec <lp_uart_irq>:

//lint -esym(459, lp_uart_irq)
static void lp_uart_irq(void)
{
   17cec:	b5f0      	push	{r4, r5, r6, r7, lr}
   17cee:	b085      	sub	sp, #20
    uint8 parity_errors;
    uint8 fifo_level;
    uint8 buffer_level;
    bool  add_data_err_flag;

    hal_lpuart_clear_irq();
   17cf0:	f002 f996 	bl	1a020 <hal_lpuart_clear_irq>

    if ((irq_enabled_flags & (1 << LP_UART_INTERRUPT_START_BIT)) > 0)
   17cf4:	4c4b      	ldr	r4, [pc, #300]	; (17e24 <lp_uart_irq+0x138>)
   17cf6:	7823      	ldrb	r3, [r4, #0]
   17cf8:	06db      	lsls	r3, r3, #27
   17cfa:	d503      	bpl.n	17d04 <lp_uart_irq+0x18>
    {
        lp_uart_call_interrupt(LP_UART_INTERRUPT_START_BIT, false);
   17cfc:	2100      	movs	r1, #0
   17cfe:	2004      	movs	r0, #4
   17d00:	f7ff ffd2 	bl	17ca8 <lp_uart_call_interrupt>
    }

    //Time to work out the interrupt reason(s)!
    if ((irq_enabled_flags & (1 << LP_UART_INTERRUPT_FRAME_ERROR)) > 0)
   17d04:	7823      	ldrb	r3, [r4, #0]
   17d06:	075b      	lsls	r3, r3, #29
   17d08:	d50f      	bpl.n	17d2a <lp_uart_irq+0x3e>
    return hal_lpuart_get_frame_errors();
   17d0a:	f002 f981 	bl	1a010 <hal_lpuart_get_frame_errors>
    {
        frame_errors = lp_uart_get_frame_errors();
        if (frame_errors != lp_uart_last_frame_errors)
   17d0e:	4d46      	ldr	r5, [pc, #280]	; (17e28 <lp_uart_irq+0x13c>)
    return hal_lpuart_get_frame_errors();
   17d10:	0006      	movs	r6, r0
        if (frame_errors != lp_uart_last_frame_errors)
   17d12:	782b      	ldrb	r3, [r5, #0]
   17d14:	4283      	cmp	r3, r0
   17d16:	d007      	beq.n	17d28 <lp_uart_irq+0x3c>
        {
            lp_uart_rx_errors |= UART_ERROR_FRAME;   //lint !e655  UART_ERROR enum defined as bit fields
   17d18:	2101      	movs	r1, #1
   17d1a:	4a44      	ldr	r2, [pc, #272]	; (17e2c <lp_uart_irq+0x140>)
            lp_uart_call_interrupt(LP_UART_INTERRUPT_FRAME_ERROR, true);
   17d1c:	2002      	movs	r0, #2
            lp_uart_rx_errors |= UART_ERROR_FRAME;   //lint !e655  UART_ERROR enum defined as bit fields
   17d1e:	7813      	ldrb	r3, [r2, #0]
   17d20:	430b      	orrs	r3, r1
   17d22:	7013      	strb	r3, [r2, #0]
            lp_uart_call_interrupt(LP_UART_INTERRUPT_FRAME_ERROR, true);
   17d24:	f7ff ffc0 	bl	17ca8 <lp_uart_call_interrupt>
        }
        lp_uart_last_frame_errors = frame_errors;
   17d28:	702e      	strb	r6, [r5, #0]
    }

    if ((irq_enabled_flags & (1 << LP_UART_INTERRUPT_PARITY_ERROR)) > 0)
   17d2a:	2502      	movs	r5, #2
   17d2c:	7823      	ldrb	r3, [r4, #0]
   17d2e:	422b      	tst	r3, r5
   17d30:	d00f      	beq.n	17d52 <lp_uart_irq+0x66>
    return hal_lpuart_get_parity_errors();
   17d32:	f002 f965 	bl	1a000 <hal_lpuart_get_parity_errors>
    {
        parity_errors = lp_uart_get_parity_errors();
        if (parity_errors != lp_uart_last_parity_errors)
   17d36:	4e3e      	ldr	r6, [pc, #248]	; (17e30 <lp_uart_irq+0x144>)
    return hal_lpuart_get_parity_errors();
   17d38:	0007      	movs	r7, r0
        if (parity_errors != lp_uart_last_parity_errors)
   17d3a:	7833      	ldrb	r3, [r6, #0]
   17d3c:	4283      	cmp	r3, r0
   17d3e:	d007      	beq.n	17d50 <lp_uart_irq+0x64>
        {
            lp_uart_rx_errors |= UART_ERROR_PARITY;   //lint !e655  UART_ERROR enum defined as bit fields
            lp_uart_call_interrupt(LP_UART_INTERRUPT_PARITY_ERROR, true);
   17d40:	2101      	movs	r1, #1
            lp_uart_rx_errors |= UART_ERROR_PARITY;   //lint !e655  UART_ERROR enum defined as bit fields
   17d42:	4b3a      	ldr	r3, [pc, #232]	; (17e2c <lp_uart_irq+0x140>)
            lp_uart_call_interrupt(LP_UART_INTERRUPT_PARITY_ERROR, true);
   17d44:	0008      	movs	r0, r1
            lp_uart_rx_errors |= UART_ERROR_PARITY;   //lint !e655  UART_ERROR enum defined as bit fields
   17d46:	781a      	ldrb	r2, [r3, #0]
   17d48:	4315      	orrs	r5, r2
   17d4a:	701d      	strb	r5, [r3, #0]
            lp_uart_call_interrupt(LP_UART_INTERRUPT_PARITY_ERROR, true);
   17d4c:	f7ff ffac 	bl	17ca8 <lp_uart_call_interrupt>
        }
        lp_uart_last_parity_errors = parity_errors;
   17d50:	7037      	strb	r7, [r6, #0]
    return hal_lpuart_get_fifo_level();
   17d52:	f002 f8df 	bl	19f14 <hal_lpuart_get_fifo_level>
   17d56:	0005      	movs	r5, r0
    }

    fifo_level = lp_uart_get_fifo_level();
    if( fifo_level >= HAL_LPUART_RX_FIFO_SIZE )
   17d58:	2806      	cmp	r0, #6
   17d5a:	d904      	bls.n	17d66 <lp_uart_irq+0x7a>
    {   // Can't detect a real overrun, so use FIFO full condition instead
        lp_uart_rx_errors |= UART_ERROR_OVERRUN;   //lint !e655  UART_ERROR enum defined as bit fields
   17d5c:	2308      	movs	r3, #8
   17d5e:	4a33      	ldr	r2, [pc, #204]	; (17e2c <lp_uart_irq+0x140>)
   17d60:	7811      	ldrb	r1, [r2, #0]
   17d62:	430b      	orrs	r3, r1
   17d64:	7013      	strb	r3, [r2, #0]
    return hal_lpuart_get_fifo_level();
   17d66:	9501      	str	r5, [sp, #4]
    while (((lp_uart_buffer_write_pos + 1) % LP_UART_MAX_BUFFER != lp_uart_buffer_read_pos) && fifo_level != 0)
   17d68:	223f      	movs	r2, #63	; 0x3f
   17d6a:	4b32      	ldr	r3, [pc, #200]	; (17e34 <lp_uart_irq+0x148>)
   17d6c:	781b      	ldrb	r3, [r3, #0]
   17d6e:	3301      	adds	r3, #1
   17d70:	4013      	ands	r3, r2
   17d72:	4a31      	ldr	r2, [pc, #196]	; (17e38 <lp_uart_irq+0x14c>)
   17d74:	7812      	ldrb	r2, [r2, #0]
   17d76:	4293      	cmp	r3, r2
   17d78:	d002      	beq.n	17d80 <lp_uart_irq+0x94>
   17d7a:	9b01      	ldr	r3, [sp, #4]
   17d7c:	2b00      	cmp	r3, #0
   17d7e:	d117      	bne.n	17db0 <lp_uart_irq+0xc4>
    return true;
   17d80:	2101      	movs	r1, #1
    }
    add_data_err_flag = lp_uart_add_data_to_buffer( fifo_level );

    if (fifo_level > 0)
   17d82:	2d00      	cmp	r5, #0
   17d84:	d012      	beq.n	17dac <lp_uart_irq+0xc0>
    {
        if ((irq_enabled_flags & (1 << LP_UART_INTERRUPT_SUCCESSFUL_WORD)) > 0)
   17d86:	7823      	ldrb	r3, [r4, #0]
   17d88:	071b      	lsls	r3, r3, #28
   17d8a:	d502      	bpl.n	17d92 <lp_uart_irq+0xa6>
        {
            lp_uart_call_interrupt(LP_UART_INTERRUPT_SUCCESSFUL_WORD, add_data_err_flag);
   17d8c:	2003      	movs	r0, #3
   17d8e:	f7ff ff8b 	bl	17ca8 <lp_uart_call_interrupt>
        }

        if ((irq_enabled_flags &  (1 << LP_UART_INTERRUPT_THRESHOLD_AMMOUNT)) > 0)
   17d92:	7823      	ldrb	r3, [r4, #0]
   17d94:	069b      	lsls	r3, r3, #26
   17d96:	d509      	bpl.n	17dac <lp_uart_irq+0xc0>
        {
            buffer_level = lp_uart_get_buffer_level();
   17d98:	f7ff ff52 	bl	17c40 <lp_uart_get_buffer_level>
            if (buffer_level >= rx_irq_threshold_level)
   17d9c:	4b27      	ldr	r3, [pc, #156]	; (17e3c <lp_uart_irq+0x150>)
   17d9e:	781b      	ldrb	r3, [r3, #0]
   17da0:	4283      	cmp	r3, r0
   17da2:	d803      	bhi.n	17dac <lp_uart_irq+0xc0>
            {
                lp_uart_call_interrupt(LP_UART_INTERRUPT_THRESHOLD_AMMOUNT, false);
   17da4:	2100      	movs	r1, #0
   17da6:	2005      	movs	r0, #5
   17da8:	f7ff ff7e 	bl	17ca8 <lp_uart_call_interrupt>
            }
        }
    }
}
   17dac:	b005      	add	sp, #20
   17dae:	bdf0      	pop	{r4, r5, r6, r7, pc}
        uint8 value = 0;
   17db0:	2600      	movs	r6, #0
   17db2:	ab02      	add	r3, sp, #8
   17db4:	1ddf      	adds	r7, r3, #7
        if (!hal_lpuart_get_word(&value))
   17db6:	0038      	movs	r0, r7
        uint8 value = 0;
   17db8:	71de      	strb	r6, [r3, #7]
        if (!hal_lpuart_get_word(&value))
   17dba:	f002 f911 	bl	19fe0 <hal_lpuart_get_word>
   17dbe:	0001      	movs	r1, r0
   17dc0:	42b0      	cmp	r0, r6
   17dc2:	d0de      	beq.n	17d82 <lp_uart_irq+0x96>
    if( lp_uart_tx_flow_control_callback == NULL)
   17dc4:	4b1e      	ldr	r3, [pc, #120]	; (17e40 <lp_uart_irq+0x154>)
            if( !lp_uart_handle_received_control_char( value ) )
   17dc6:	783a      	ldrb	r2, [r7, #0]
    if( lp_uart_tx_flow_control_callback == NULL)
   17dc8:	681b      	ldr	r3, [r3, #0]
   17dca:	4f18      	ldr	r7, [pc, #96]	; (17e2c <lp_uart_irq+0x140>)
   17dcc:	42b3      	cmp	r3, r6
   17dce:	d003      	beq.n	17dd8 <lp_uart_irq+0xec>
    switch( uart_data )
   17dd0:	2a11      	cmp	r2, #17
   17dd2:	d00e      	beq.n	17df2 <lp_uart_irq+0x106>
   17dd4:	2a13      	cmp	r2, #19
   17dd6:	d01c      	beq.n	17e12 <lp_uart_irq+0x126>
                lp_uart_data_buffer[lp_uart_buffer_write_pos] = value;
   17dd8:	4b16      	ldr	r3, [pc, #88]	; (17e34 <lp_uart_irq+0x148>)
   17dda:	491a      	ldr	r1, [pc, #104]	; (17e44 <lp_uart_irq+0x158>)
   17ddc:	781b      	ldrb	r3, [r3, #0]
   17dde:	54ca      	strb	r2, [r1, r3]
                lp_uart_error_buffer[lp_uart_buffer_write_pos] = (uint8)lp_uart_rx_errors;
   17de0:	4a19      	ldr	r2, [pc, #100]	; (17e48 <lp_uart_irq+0x15c>)
   17de2:	7839      	ldrb	r1, [r7, #0]
   17de4:	54d1      	strb	r1, [r2, r3]
                lp_uart_buffer_write_pos %= LP_UART_MAX_BUFFER;
   17de6:	223f      	movs	r2, #63	; 0x3f
                lp_uart_buffer_write_pos++;
   17de8:	3301      	adds	r3, #1
                lp_uart_buffer_write_pos %= LP_UART_MAX_BUFFER;
   17dea:	4013      	ands	r3, r2
   17dec:	4a11      	ldr	r2, [pc, #68]	; (17e34 <lp_uart_irq+0x148>)
   17dee:	7013      	strb	r3, [r2, #0]
   17df0:	e006      	b.n	17e00 <lp_uart_irq+0x114>
        if( lp_uart_tx_flow_control_asserted )
   17df2:	4a16      	ldr	r2, [pc, #88]	; (17e4c <lp_uart_irq+0x160>)
   17df4:	7811      	ldrb	r1, [r2, #0]
   17df6:	2900      	cmp	r1, #0
   17df8:	d002      	beq.n	17e00 <lp_uart_irq+0x114>
            lp_uart_tx_flow_control_callback( lp_uart_tx_flow_control_asserted );
   17dfa:	0030      	movs	r0, r6
            lp_uart_tx_flow_control_asserted = false;
   17dfc:	7016      	strb	r6, [r2, #0]
            lp_uart_tx_flow_control_callback( lp_uart_tx_flow_control_asserted );
   17dfe:	4798      	blx	r3
            fifo_level--;
   17e00:	9b01      	ldr	r3, [sp, #4]
   17e02:	3b01      	subs	r3, #1
   17e04:	b2db      	uxtb	r3, r3
   17e06:	9301      	str	r3, [sp, #4]
            lp_uart_determine_rx_flow_control();
   17e08:	f7ff ff2c 	bl	17c64 <lp_uart_determine_rx_flow_control>
        lp_uart_rx_errors = UART_ERROR_NONE;
   17e0c:	2300      	movs	r3, #0
   17e0e:	703b      	strb	r3, [r7, #0]
   17e10:	e7aa      	b.n	17d68 <lp_uart_irq+0x7c>
        if( !lp_uart_tx_flow_control_asserted )
   17e12:	4a0e      	ldr	r2, [pc, #56]	; (17e4c <lp_uart_irq+0x160>)
   17e14:	7811      	ldrb	r1, [r2, #0]
   17e16:	2900      	cmp	r1, #0
   17e18:	d1f2      	bne.n	17e00 <lp_uart_irq+0x114>
            lp_uart_tx_flow_control_asserted = true;
   17e1a:	3101      	adds	r1, #1
   17e1c:	7011      	strb	r1, [r2, #0]
            lp_uart_tx_flow_control_callback( lp_uart_tx_flow_control_asserted );
   17e1e:	2001      	movs	r0, #1
   17e20:	e7ed      	b.n	17dfe <lp_uart_irq+0x112>
   17e22:	46c0      	nop			; (mov r8, r8)
   17e24:	01002738 	.word	0x01002738
   17e28:	010027d6 	.word	0x010027d6
   17e2c:	010027da 	.word	0x010027da
   17e30:	010027d7 	.word	0x010027d7
   17e34:	01002755 	.word	0x01002755
   17e38:	01002754 	.word	0x01002754
   17e3c:	010027e8 	.word	0x010027e8
   17e40:	010027e4 	.word	0x010027e4
   17e44:	01002756 	.word	0x01002756
   17e48:	01002796 	.word	0x01002796
   17e4c:	010027e0 	.word	0x010027e0

00017e50 <lp_uart_init>:
{
   17e50:	b5f0      	push	{r4, r5, r6, r7, lr}
   17e52:	b085      	sub	sp, #20
   17e54:	4676      	mov	r6, lr
   17e56:	1e05      	subs	r5, r0, #0
   17e58:	9101      	str	r1, [sp, #4]
   17e5a:	9202      	str	r2, [sp, #8]
   17e5c:	9303      	str	r3, [sp, #12]
    assert( pin_config != NULL );
   17e5e:	d103      	bne.n	17e68 <lp_uart_init+0x18>
   17e60:	4671      	mov	r1, lr
   17e62:	2016      	movs	r0, #22
   17e64:	f7e9 fe54 	bl	1b10 <panic>
    assert( lp_rx == PIN_NONE );
   17e68:	4b46      	ldr	r3, [pc, #280]	; (17f84 <lp_uart_init+0x134>)
   17e6a:	781b      	ldrb	r3, [r3, #0]
   17e6c:	2b28      	cmp	r3, #40	; 0x28
   17e6e:	d003      	beq.n	17e78 <lp_uart_init+0x28>
   17e70:	0031      	movs	r1, r6
   17e72:	2016      	movs	r0, #22
   17e74:	f7e9 fe4c 	bl	1b10 <panic>
    assert( lp_rts == PIN_NONE );
   17e78:	4c43      	ldr	r4, [pc, #268]	; (17f88 <lp_uart_init+0x138>)
   17e7a:	7823      	ldrb	r3, [r4, #0]
   17e7c:	2b28      	cmp	r3, #40	; 0x28
   17e7e:	d003      	beq.n	17e88 <lp_uart_init+0x38>
   17e80:	0031      	movs	r1, r6
   17e82:	2016      	movs	r0, #22
   17e84:	f7e9 fe44 	bl	1b10 <panic>
    if( pin_config == NULL )   //lint !e774 Ignore warning of pin_config != NULL being true after assert.
   17e88:	2d00      	cmp	r5, #0
   17e8a:	d103      	bne.n	17e94 <lp_uart_init+0x44>
        return false;
   17e8c:	2400      	movs	r4, #0
}
   17e8e:	0020      	movs	r0, r4
   17e90:	b005      	add	sp, #20
   17e92:	bdf0      	pop	{r4, r5, r6, r7, pc}
    if( (lp_rx != PIN_NONE) || (lp_rts != PIN_NONE) )
   17e94:	4b3b      	ldr	r3, [pc, #236]	; (17f84 <lp_uart_init+0x134>)
   17e96:	781b      	ldrb	r3, [r3, #0]
   17e98:	2b28      	cmp	r3, #40	; 0x28
   17e9a:	d1f7      	bne.n	17e8c <lp_uart_init+0x3c>
   17e9c:	7823      	ldrb	r3, [r4, #0]
   17e9e:	2b28      	cmp	r3, #40	; 0x28
   17ea0:	d1f4      	bne.n	17e8c <lp_uart_init+0x3c>
    if (non_os_is_driver_initialised(DRIVER_INIT_LPUART) == true)
   17ea2:	201d      	movs	r0, #29
   17ea4:	f000 f9ae 	bl	18204 <non_os_is_driver_initialised>
   17ea8:	1e04      	subs	r4, r0, #0
   17eaa:	d1ef      	bne.n	17e8c <lp_uart_init+0x3c>
    if( !lp_uart_claim_rx_pin(pin_config->rx_pin) )
   17eac:	782f      	ldrb	r7, [r5, #0]
    assert( rx_pin < PIN_MAX_NUMBER );
   17eae:	2f27      	cmp	r7, #39	; 0x27
   17eb0:	d93f      	bls.n	17f32 <lp_uart_init+0xe2>
   17eb2:	0031      	movs	r1, r6
   17eb4:	2016      	movs	r0, #22
   17eb6:	f7e9 fe2b 	bl	1b10 <panic>
   17eba:	e7e8      	b.n	17e8e <lp_uart_init+0x3e>
    if( rts_pin == PIN_NONE )
   17ebc:	2d28      	cmp	r5, #40	; 0x28
   17ebe:	d14e      	bne.n	17f5e <lp_uart_init+0x10e>
    if( !hal_lpuart_init() )
   17ec0:	f002 f878 	bl	19fb4 <hal_lpuart_init>
   17ec4:	2800      	cmp	r0, #0
   17ec6:	d031      	beq.n	17f2c <lp_uart_init+0xdc>
    if( !hal_lpuart_specific_set_baud_rate(baudrate) )
   17ec8:	9801      	ldr	r0, [sp, #4]
   17eca:	f000 fe73 	bl	18bb4 <hal_lpuart_specific_set_baud_rate>
   17ece:	1e05      	subs	r5, r0, #0
   17ed0:	d02c      	beq.n	17f2c <lp_uart_init+0xdc>
    irq_enabled_flags = 0;
   17ed2:	2400      	movs	r4, #0
    lp_uart_rx_buffer_upper_water_margin = LP_UART_DEFAULT_UPPER_WATER_LEVEL;
   17ed4:	2230      	movs	r2, #48	; 0x30
    irq_enabled_flags = 0;
   17ed6:	4b2d      	ldr	r3, [pc, #180]	; (17f8c <lp_uart_init+0x13c>)
    hal_lpuart_set_wordlength(HAL_LPUART_WORDLENGTH_8BIT);
   17ed8:	2003      	movs	r0, #3
    irq_enabled_flags = 0;
   17eda:	701c      	strb	r4, [r3, #0]
    lp_uart_last_parity_errors = 0;
   17edc:	4b2c      	ldr	r3, [pc, #176]	; (17f90 <lp_uart_init+0x140>)
   17ede:	701c      	strb	r4, [r3, #0]
    lp_uart_last_frame_errors = 0;
   17ee0:	4b2c      	ldr	r3, [pc, #176]	; (17f94 <lp_uart_init+0x144>)
   17ee2:	701c      	strb	r4, [r3, #0]
    lp_uart_rx_buffer_upper_water_margin = LP_UART_DEFAULT_UPPER_WATER_LEVEL;
   17ee4:	4b2c      	ldr	r3, [pc, #176]	; (17f98 <lp_uart_init+0x148>)
   17ee6:	701a      	strb	r2, [r3, #0]
    lp_uart_rx_buffer_lower_water_margin = LP_UART_DEFAULT_LOWER_WATER_LEVEL;
   17ee8:	4b2c      	ldr	r3, [pc, #176]	; (17f9c <lp_uart_init+0x14c>)
   17eea:	701c      	strb	r4, [r3, #0]
    hal_lpuart_set_wordlength(HAL_LPUART_WORDLENGTH_8BIT);
   17eec:	f001 ff86 	bl	19dfc <hal_lpuart_set_wordlength>
    hal_lpuart_set_parity((HAL_LPUART_PARITY_SET)parity);
   17ef0:	9803      	ldr	r0, [sp, #12]
   17ef2:	f001 ffa9 	bl	19e48 <hal_lpuart_set_parity>
    hal_lpuart_set_stop(HAL_LPUART_STOP_SET_ENABLED);
   17ef6:	0020      	movs	r0, r4
   17ef8:	f001 ffcc 	bl	19e94 <hal_lpuart_set_stop>
    hal_lpuart_set_syncmode((HAL_LPUART_SYNCMODE)sync_mode);
   17efc:	9802      	ldr	r0, [sp, #8]
   17efe:	f001 ffe3 	bl	19ec8 <hal_lpuart_set_syncmode>
    hal_lpuart_set_interrupts(HAL_LPUART_INTERRUPT_SUCCESSFUL_WORD);
   17f02:	2003      	movs	r0, #3
   17f04:	f001 ff2e 	bl	19d64 <hal_lpuart_set_interrupts>
    hal_lpuart_set_callback(lp_uart_irq);
   17f08:	4825      	ldr	r0, [pc, #148]	; (17fa0 <lp_uart_init+0x150>)
   17f0a:	f002 f88d 	bl	1a028 <hal_lpuart_set_callback>
    hal_lpuart_set_interrupts(HAL_LPUART_INTERRUPT_NONE);   //Since this can take us out of deep sleep lets disable all
   17f0e:	0020      	movs	r0, r4
   17f10:	f001 ff28 	bl	19d64 <hal_lpuart_set_interrupts>
    hal_lpuart_enable_interrupts();
   17f14:	f001 ff1a 	bl	19d4c <hal_lpuart_enable_interrupts>
    hal_lpuart_assign_rts_pin( lp_rts );   // Pass control of RTS pin to HAL
   17f18:	4b1b      	ldr	r3, [pc, #108]	; (17f88 <lp_uart_init+0x138>)
    return true;
   17f1a:	002c      	movs	r4, r5
    hal_lpuart_assign_rts_pin( lp_rts );   // Pass control of RTS pin to HAL
   17f1c:	7818      	ldrb	r0, [r3, #0]
   17f1e:	f002 f821 	bl	19f64 <hal_lpuart_assign_rts_pin>
    non_os_set_driver_initalised(DRIVER_INIT_LPUART, true);
   17f22:	2101      	movs	r1, #1
   17f24:	201d      	movs	r0, #29
   17f26:	f000 f977 	bl	18218 <non_os_set_driver_initalised>
    return true;
   17f2a:	e7b0      	b.n	17e8e <lp_uart_init+0x3e>
        lp_uart_release_pins();
   17f2c:	f7ff fec8 	bl	17cc0 <lp_uart_release_pins>
        return false;
   17f30:	e7ad      	b.n	17e8e <lp_uart_init+0x3e>
    if (non_os_is_driver_initialised(DRIVER_INIT_PIO) != true)
   17f32:	2003      	movs	r0, #3
   17f34:	f000 f966 	bl	18204 <non_os_is_driver_initialised>
   17f38:	2800      	cmp	r0, #0
   17f3a:	d101      	bne.n	17f40 <lp_uart_init+0xf0>
        pio_init();
   17f3c:	f000 f98a 	bl	18254 <pio_init>
    if( !pio_set_function(rx_pin, FUNC_LPUART_RXD) )
   17f40:	211a      	movs	r1, #26
   17f42:	0038      	movs	r0, r7
   17f44:	f000 f99e 	bl	18284 <pio_set_function>
   17f48:	2800      	cmp	r0, #0
   17f4a:	d09f      	beq.n	17e8c <lp_uart_init+0x3c>
    lp_rx = rx_pin;
   17f4c:	4b0d      	ldr	r3, [pc, #52]	; (17f84 <lp_uart_init+0x134>)
   17f4e:	701f      	strb	r7, [r3, #0]
    if( !lp_uart_claim_rts_pin(pin_config->rts_pin) )
   17f50:	786d      	ldrb	r5, [r5, #1]
    assert( rts_pin <= PIN_MAX_NUMBER );
   17f52:	2d28      	cmp	r5, #40	; 0x28
   17f54:	d9b2      	bls.n	17ebc <lp_uart_init+0x6c>
   17f56:	0031      	movs	r1, r6
   17f58:	2016      	movs	r0, #22
   17f5a:	f7e9 fdd9 	bl	1b10 <panic>
    if( non_os_is_driver_initialised( DRIVER_INIT_GPIO ) != true )
   17f5e:	2004      	movs	r0, #4
   17f60:	f000 f950 	bl	18204 <non_os_is_driver_initialised>
   17f64:	2800      	cmp	r0, #0
   17f66:	d101      	bne.n	17f6c <lp_uart_init+0x11c>
        gpio_init();
   17f68:	f7ff f8cc 	bl	17104 <gpio_init>
    if( !gpio_claim( rts_pin, GPIO_DIRECTION_OUTPUT ) )
   17f6c:	2101      	movs	r1, #1
   17f6e:	0028      	movs	r0, r5
   17f70:	f7ff f8f4 	bl	1715c <gpio_claim>
   17f74:	2800      	cmp	r0, #0
   17f76:	d0d9      	beq.n	17f2c <lp_uart_init+0xdc>
    lp_rts = rts_pin;
   17f78:	4b03      	ldr	r3, [pc, #12]	; (17f88 <lp_uart_init+0x138>)
    gpio_set( lp_rts );   // De-assert RTS until LP UART setup complete
   17f7a:	0028      	movs	r0, r5
    lp_rts = rts_pin;
   17f7c:	701d      	strb	r5, [r3, #0]
    gpio_set( lp_rts );   // De-assert RTS until LP UART setup complete
   17f7e:	f7ff f969 	bl	17254 <gpio_set>
   17f82:	e79d      	b.n	17ec0 <lp_uart_init+0x70>
   17f84:	010005d1 	.word	0x010005d1
   17f88:	010005d0 	.word	0x010005d0
   17f8c:	01002738 	.word	0x01002738
   17f90:	010027d7 	.word	0x010027d7
   17f94:	010027d6 	.word	0x010027d6
   17f98:	010027d9 	.word	0x010027d9
   17f9c:	010027d8 	.word	0x010027d8
   17fa0:	00017ced 	.word	0x00017ced

00017fa4 <lp_uart_deinit>:
{
   17fa4:	b510      	push	{r4, lr}
    hal_lpuart_disable_interrupts();
   17fa6:	f001 fec9 	bl	19d3c <hal_lpuart_disable_interrupts>
    hal_lpuart_assign_rts_pin( PIN_NONE );   // Remove control of RTS pin from HAL
   17faa:	2028      	movs	r0, #40	; 0x28
   17fac:	f001 ffda 	bl	19f64 <hal_lpuart_assign_rts_pin>
    hal_lpuart_deinit();
   17fb0:	f001 fed4 	bl	19d5c <hal_lpuart_deinit>
    lp_uart_release_pins();
   17fb4:	f7ff fe84 	bl	17cc0 <lp_uart_release_pins>
    non_os_set_driver_initalised(DRIVER_INIT_LPUART, false);
   17fb8:	2100      	movs	r1, #0
   17fba:	201d      	movs	r0, #29
   17fbc:	f000 f92c 	bl	18218 <non_os_set_driver_initalised>
}
   17fc0:	bd10      	pop	{r4, pc}
	...

00017fc4 <lp_uart_enable_software_flow_control>:
    if( lp_uart_rx_flow_control_callback == NULL )
   17fc4:	4b05      	ldr	r3, [pc, #20]	; (17fdc <lp_uart_enable_software_flow_control+0x18>)
   17fc6:	681a      	ldr	r2, [r3, #0]
   17fc8:	2a00      	cmp	r2, #0
   17fca:	d100      	bne.n	17fce <lp_uart_enable_software_flow_control+0xa>
        lp_uart_rx_flow_control_callback = rx_callback;
   17fcc:	6018      	str	r0, [r3, #0]
    if( lp_uart_tx_flow_control_callback == NULL )
   17fce:	4b04      	ldr	r3, [pc, #16]	; (17fe0 <lp_uart_enable_software_flow_control+0x1c>)
   17fd0:	681a      	ldr	r2, [r3, #0]
   17fd2:	2a00      	cmp	r2, #0
   17fd4:	d100      	bne.n	17fd8 <lp_uart_enable_software_flow_control+0x14>
        lp_uart_tx_flow_control_callback = tx_callback;
   17fd6:	6019      	str	r1, [r3, #0]
}
   17fd8:	4770      	bx	lr
   17fda:	46c0      	nop			; (mov r8, r8)
   17fdc:	010027dc 	.word	0x010027dc
   17fe0:	010027e4 	.word	0x010027e4

00017fe4 <lp_uart_disable_software_flow_control>:
    lp_uart_rx_flow_control_callback = NULL;
   17fe4:	2300      	movs	r3, #0
   17fe6:	4a02      	ldr	r2, [pc, #8]	; (17ff0 <lp_uart_disable_software_flow_control+0xc>)
   17fe8:	6013      	str	r3, [r2, #0]
    lp_uart_tx_flow_control_callback = NULL;
   17fea:	4a02      	ldr	r2, [pc, #8]	; (17ff4 <lp_uart_disable_software_flow_control+0x10>)
   17fec:	6013      	str	r3, [r2, #0]
}
   17fee:	4770      	bx	lr
   17ff0:	010027dc 	.word	0x010027dc
   17ff4:	010027e4 	.word	0x010027e4

00017ff8 <lp_uart_flush_data>:
{
   17ff8:	b510      	push	{r4, lr}
    non_os_enter_critical();
   17ffa:	f000 f8db 	bl	181b4 <non_os_enter_critical>
    flushed_bytes = lp_uart_get_buffer_level();
   17ffe:	f7ff fe1f 	bl	17c40 <lp_uart_get_buffer_level>
    lp_uart_buffer_write_pos = 0;
   18002:	2300      	movs	r3, #0
    flushed_bytes = lp_uart_get_buffer_level();
   18004:	0004      	movs	r4, r0
    lp_uart_buffer_write_pos = 0;
   18006:	4a04      	ldr	r2, [pc, #16]	; (18018 <lp_uart_flush_data+0x20>)
   18008:	7013      	strb	r3, [r2, #0]
    lp_uart_buffer_read_pos  = 0;
   1800a:	4a04      	ldr	r2, [pc, #16]	; (1801c <lp_uart_flush_data+0x24>)
   1800c:	7013      	strb	r3, [r2, #0]
    non_os_exit_critical();
   1800e:	f000 f8e5 	bl	181dc <non_os_exit_critical>
}
   18012:	0020      	movs	r0, r4
   18014:	bd10      	pop	{r4, pc}
   18016:	46c0      	nop			; (mov r8, r8)
   18018:	01002755 	.word	0x01002755
   1801c:	01002754 	.word	0x01002754

00018020 <lp_uart_get_data>:
{
   18020:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
   18022:	0005      	movs	r5, r0
   18024:	000c      	movs	r4, r1
   18026:	0016      	movs	r6, r2
    uint8 buffer_length = lp_uart_get_buffer_level();
   18028:	f7ff fe0a 	bl	17c40 <lp_uart_get_buffer_level>
   1802c:	1c03      	adds	r3, r0, #0
   1802e:	b280      	uxth	r0, r0
   18030:	42a0      	cmp	r0, r4
   18032:	d900      	bls.n	18036 <lp_uart_get_data+0x16>
   18034:	1c23      	adds	r3, r4, #0
    for (uint32 i = 0; i < max_amount; i++)
   18036:	002c      	movs	r4, r5
   18038:	b29b      	uxth	r3, r3
   1803a:	9301      	str	r3, [sp, #4]
   1803c:	9a01      	ldr	r2, [sp, #4]
   1803e:	1b63      	subs	r3, r4, r5
   18040:	429a      	cmp	r2, r3
   18042:	d801      	bhi.n	18048 <lp_uart_get_data+0x28>
}
   18044:	0010      	movs	r0, r2
   18046:	bdfe      	pop	{r1, r2, r3, r4, r5, r6, r7, pc}
    if (lp_uart_buffer_read_pos != lp_uart_buffer_write_pos)
   18048:	490b      	ldr	r1, [pc, #44]	; (18078 <lp_uart_get_data+0x58>)
   1804a:	4a0c      	ldr	r2, [pc, #48]	; (1807c <lp_uart_get_data+0x5c>)
   1804c:	780b      	ldrb	r3, [r1, #0]
   1804e:	7812      	ldrb	r2, [r2, #0]
    uint8 data = 0;
   18050:	2700      	movs	r7, #0
    if (lp_uart_buffer_read_pos != lp_uart_buffer_write_pos)
   18052:	429a      	cmp	r2, r3
   18054:	d00c      	beq.n	18070 <lp_uart_get_data+0x50>
        data = lp_uart_data_buffer[lp_uart_buffer_read_pos];
   18056:	4a0a      	ldr	r2, [pc, #40]	; (18080 <lp_uart_get_data+0x60>)
        *errors |= (UART_ERROR)lp_uart_error_buffer[lp_uart_buffer_read_pos];   //lint !e655  UART_ERROR enum defined as bit fields
   18058:	480a      	ldr	r0, [pc, #40]	; (18084 <lp_uart_get_data+0x64>)
        data = lp_uart_data_buffer[lp_uart_buffer_read_pos];
   1805a:	5cd7      	ldrb	r7, [r2, r3]
        *errors |= (UART_ERROR)lp_uart_error_buffer[lp_uart_buffer_read_pos];   //lint !e655  UART_ERROR enum defined as bit fields
   1805c:	5cc0      	ldrb	r0, [r0, r3]
   1805e:	7832      	ldrb	r2, [r6, #0]
        lp_uart_buffer_read_pos++;
   18060:	3301      	adds	r3, #1
        *errors |= (UART_ERROR)lp_uart_error_buffer[lp_uart_buffer_read_pos];   //lint !e655  UART_ERROR enum defined as bit fields
   18062:	4302      	orrs	r2, r0
   18064:	7032      	strb	r2, [r6, #0]
        lp_uart_buffer_read_pos %= LP_UART_MAX_BUFFER;
   18066:	223f      	movs	r2, #63	; 0x3f
   18068:	4013      	ands	r3, r2
   1806a:	700b      	strb	r3, [r1, #0]
        lp_uart_determine_rx_flow_control();
   1806c:	f7ff fdfa 	bl	17c64 <lp_uart_determine_rx_flow_control>
        *buffer++ = lp_uart_get_data_from_buffer( lp_uart_rx_errors_ptr );
   18070:	7027      	strb	r7, [r4, #0]
   18072:	3401      	adds	r4, #1
   18074:	e7e2      	b.n	1803c <lp_uart_get_data+0x1c>
   18076:	46c0      	nop			; (mov r8, r8)
   18078:	01002754 	.word	0x01002754
   1807c:	01002755 	.word	0x01002755
   18080:	01002756 	.word	0x01002756
   18084:	01002796 	.word	0x01002796

00018088 <lp_uart_get_fifo_level>:
{
   18088:	b510      	push	{r4, lr}
    return hal_lpuart_get_fifo_level();
   1808a:	f001 ff43 	bl	19f14 <hal_lpuart_get_fifo_level>
}
   1808e:	bd10      	pop	{r4, pc}

00018090 <lp_uart_enable_irq>:
    switch(IRQN)
   18090:	3801      	subs	r0, #1
{
   18092:	b510      	push	{r4, lr}
    switch(IRQN)
   18094:	2804      	cmp	r0, #4
   18096:	d827      	bhi.n	180e8 <lp_uart_enable_irq+0x58>
   18098:	4c16      	ldr	r4, [pc, #88]	; (180f4 <lp_uart_enable_irq+0x64>)
   1809a:	f7e8 f983 	bl	3a4 <__gnu_thumb1_case_uqi>
   1809e:	0b03      	.short	0x0b03
   180a0:	1711      	.short	0x1711
   180a2:	1d          	.byte	0x1d
   180a3:	00          	.byte	0x00
        hal_lpuart_set_interrupts(HAL_LPUART_INTERRUPT_PARITY_ERROR);
   180a4:	2001      	movs	r0, #1
   180a6:	f001 fe5d 	bl	19d64 <hal_lpuart_set_interrupts>
        irq_enabled_flags |= (1 << LP_UART_INTERRUPT_PARITY_ERROR);
   180aa:	2302      	movs	r3, #2
   180ac:	7822      	ldrb	r2, [r4, #0]
        irq_enabled_flags |= (1 << LP_UART_INTERRUPT_START_BIT);
   180ae:	4313      	orrs	r3, r2
   180b0:	7023      	strb	r3, [r4, #0]
}
   180b2:	bd10      	pop	{r4, pc}
        hal_lpuart_set_interrupts(HAL_LPUART_INTERRUPT_FRAME_ERROR);
   180b4:	2002      	movs	r0, #2
   180b6:	f001 fe55 	bl	19d64 <hal_lpuart_set_interrupts>
        irq_enabled_flags |= (1 << LP_UART_INTERRUPT_FRAME_ERROR);
   180ba:	7822      	ldrb	r2, [r4, #0]
   180bc:	2304      	movs	r3, #4
   180be:	e7f6      	b.n	180ae <lp_uart_enable_irq+0x1e>
        hal_lpuart_set_interrupts(HAL_LPUART_INTERRUPT_SUCCESSFUL_WORD);
   180c0:	2003      	movs	r0, #3
   180c2:	f001 fe4f 	bl	19d64 <hal_lpuart_set_interrupts>
        irq_enabled_flags |= (1 << LP_UART_INTERRUPT_SUCCESSFUL_WORD);
   180c6:	7822      	ldrb	r2, [r4, #0]
   180c8:	2308      	movs	r3, #8
   180ca:	e7f0      	b.n	180ae <lp_uart_enable_irq+0x1e>
        hal_lpuart_set_interrupts(HAL_LPUART_INTERRUPT_START_BIT);
   180cc:	2004      	movs	r0, #4
   180ce:	f001 fe49 	bl	19d64 <hal_lpuart_set_interrupts>
        irq_enabled_flags |= (1 << LP_UART_INTERRUPT_START_BIT);
   180d2:	7822      	ldrb	r2, [r4, #0]
   180d4:	2310      	movs	r3, #16
   180d6:	e7ea      	b.n	180ae <lp_uart_enable_irq+0x1e>
        irq_enabled_flags |= (1 << LP_UART_INTERRUPT_THRESHOLD_AMMOUNT);
   180d8:	2320      	movs	r3, #32
   180da:	7822      	ldrb	r2, [r4, #0]
        hal_lpuart_set_interrupts(HAL_LPUART_INTERRUPT_SUCCESSFUL_WORD);
   180dc:	2003      	movs	r0, #3
        irq_enabled_flags |= (1 << LP_UART_INTERRUPT_THRESHOLD_AMMOUNT);
   180de:	4313      	orrs	r3, r2
   180e0:	7023      	strb	r3, [r4, #0]
        hal_lpuart_set_interrupts(HAL_LPUART_INTERRUPT_SUCCESSFUL_WORD);
   180e2:	f001 fe3f 	bl	19d64 <hal_lpuart_set_interrupts>
        break;
   180e6:	e7e4      	b.n	180b2 <lp_uart_enable_irq+0x22>
        assert(false);
   180e8:	4671      	mov	r1, lr
   180ea:	2016      	movs	r0, #22
   180ec:	f7e9 fd10 	bl	1b10 <panic>
}
   180f0:	e7df      	b.n	180b2 <lp_uart_enable_irq+0x22>
   180f2:	46c0      	nop			; (mov r8, r8)
   180f4:	01002738 	.word	0x01002738

000180f8 <lp_uart_disable_irq>:
    switch(IRQN)
   180f8:	3801      	subs	r0, #1
{
   180fa:	b510      	push	{r4, lr}
    switch(IRQN)
   180fc:	2804      	cmp	r0, #4
   180fe:	d82a      	bhi.n	18156 <lp_uart_disable_irq+0x5e>
   18100:	4c17      	ldr	r4, [pc, #92]	; (18160 <lp_uart_disable_irq+0x68>)
   18102:	f7e8 f94f 	bl	3a4 <__gnu_thumb1_case_uqi>
   18106:	0b03      	.short	0x0b03
   18108:	1711      	.short	0x1711
   1810a:	1d          	.byte	0x1d
   1810b:	00          	.byte	0x00
        hal_lpuart_unset_interrupts(HAL_LPUART_INTERRUPT_PARITY_ERROR);
   1810c:	2001      	movs	r0, #1
   1810e:	f001 fe51 	bl	19db4 <hal_lpuart_unset_interrupts>
        irq_enabled_flags &= ~(1 << LP_UART_INTERRUPT_PARITY_ERROR);
   18112:	2202      	movs	r2, #2
   18114:	7823      	ldrb	r3, [r4, #0]
        irq_enabled_flags &= ~(1 << LP_UART_INTERRUPT_START_BIT);
   18116:	4393      	bics	r3, r2
   18118:	7023      	strb	r3, [r4, #0]
}
   1811a:	bd10      	pop	{r4, pc}
        hal_lpuart_unset_interrupts(HAL_LPUART_INTERRUPT_FRAME_ERROR);
   1811c:	2002      	movs	r0, #2
   1811e:	f001 fe49 	bl	19db4 <hal_lpuart_unset_interrupts>
        irq_enabled_flags &= ~(1 << LP_UART_INTERRUPT_FRAME_ERROR);
   18122:	7823      	ldrb	r3, [r4, #0]
   18124:	2204      	movs	r2, #4
   18126:	e7f6      	b.n	18116 <lp_uart_disable_irq+0x1e>
        hal_lpuart_unset_interrupts(HAL_LPUART_INTERRUPT_SUCCESSFUL_WORD);
   18128:	2003      	movs	r0, #3
   1812a:	f001 fe43 	bl	19db4 <hal_lpuart_unset_interrupts>
        irq_enabled_flags &= ~(1 << LP_UART_INTERRUPT_SUCCESSFUL_WORD);
   1812e:	7823      	ldrb	r3, [r4, #0]
   18130:	2208      	movs	r2, #8
   18132:	e7f0      	b.n	18116 <lp_uart_disable_irq+0x1e>
        hal_lpuart_unset_interrupts(HAL_LPUART_INTERRUPT_START_BIT);
   18134:	2004      	movs	r0, #4
   18136:	f001 fe3d 	bl	19db4 <hal_lpuart_unset_interrupts>
        irq_enabled_flags &= ~(1 << LP_UART_INTERRUPT_START_BIT);
   1813a:	7823      	ldrb	r3, [r4, #0]
   1813c:	2210      	movs	r2, #16
   1813e:	e7ea      	b.n	18116 <lp_uart_disable_irq+0x1e>
        irq_enabled_flags &= ~(1 << LP_UART_INTERRUPT_THRESHOLD_AMMOUNT);
   18140:	7823      	ldrb	r3, [r4, #0]
   18142:	2220      	movs	r2, #32
   18144:	0019      	movs	r1, r3
   18146:	4391      	bics	r1, r2
   18148:	7021      	strb	r1, [r4, #0]
        if ((irq_enabled_flags & (1 << LP_UART_INTERRUPT_SUCCESSFUL_WORD)) == 0)
   1814a:	071b      	lsls	r3, r3, #28
   1814c:	d4e5      	bmi.n	1811a <lp_uart_disable_irq+0x22>
            hal_lpuart_unset_interrupts(HAL_LPUART_INTERRUPT_SUCCESSFUL_WORD);
   1814e:	2003      	movs	r0, #3
   18150:	f001 fe30 	bl	19db4 <hal_lpuart_unset_interrupts>
   18154:	e7e1      	b.n	1811a <lp_uart_disable_irq+0x22>
        assert(false);
   18156:	4671      	mov	r1, lr
   18158:	2016      	movs	r0, #22
   1815a:	f7e9 fcd9 	bl	1b10 <panic>
}
   1815e:	e7dc      	b.n	1811a <lp_uart_disable_irq+0x22>
   18160:	01002738 	.word	0x01002738

00018164 <lp_uart_set_callback>:

void lp_uart_set_callback(LP_UART_INTERRUPT irq, lp_uart_callback callback)
{
   18164:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
   18166:	4677      	mov	r7, lr
   18168:	0004      	movs	r4, r0
   1816a:	000e      	movs	r6, r1
    assert(irq < LP_UART_MAX_INTERRUPTS);
   1816c:	2805      	cmp	r0, #5
   1816e:	d903      	bls.n	18178 <lp_uart_set_callback+0x14>
   18170:	4671      	mov	r1, lr
   18172:	2016      	movs	r0, #22
   18174:	f7e9 fccc 	bl	1b10 <panic>
    assert(lp_callbacks[irq] == NULL);
   18178:	4d05      	ldr	r5, [pc, #20]	; (18190 <lp_uart_set_callback+0x2c>)
   1817a:	00a4      	lsls	r4, r4, #2
   1817c:	5963      	ldr	r3, [r4, r5]
   1817e:	2b00      	cmp	r3, #0
   18180:	d003      	beq.n	1818a <lp_uart_set_callback+0x26>
   18182:	0039      	movs	r1, r7
   18184:	2016      	movs	r0, #22
   18186:	f7e9 fcc3 	bl	1b10 <panic>

    lp_callbacks[irq] = callback;
   1818a:	512e      	str	r6, [r5, r4]
}
   1818c:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
   1818e:	46c0      	nop			; (mov r8, r8)
   18190:	0100273c 	.word	0x0100273c

00018194 <lp_uart_unset_callback>:

void lp_uart_unset_callback(LP_UART_INTERRUPT irq)
{
   18194:	b510      	push	{r4, lr}
   18196:	0004      	movs	r4, r0
    assert(irq < LP_UART_MAX_INTERRUPTS);
   18198:	2805      	cmp	r0, #5
   1819a:	d903      	bls.n	181a4 <lp_uart_unset_callback+0x10>
   1819c:	4671      	mov	r1, lr
   1819e:	2016      	movs	r0, #22
   181a0:	f7e9 fcb6 	bl	1b10 <panic>

    lp_callbacks[irq] = NULL;
   181a4:	2200      	movs	r2, #0
   181a6:	4b02      	ldr	r3, [pc, #8]	; (181b0 <lp_uart_unset_callback+0x1c>)
   181a8:	00a4      	lsls	r4, r4, #2
   181aa:	50e2      	str	r2, [r4, r3]
}
   181ac:	bd10      	pop	{r4, pc}
   181ae:	46c0      	nop			; (mov r8, r8)
   181b0:	0100273c 	.word	0x0100273c

000181b4 <non_os_enter_critical>:
/** Variable used to store the nesting of critical sections.
 * If it reaches 0 interrupts are disabled, when it reaches 0 interrupts are enabled again.  */
static uint16 non_os_critical_nesting = 0;

void non_os_enter_critical( void )
{
   181b4:	b510      	push	{r4, lr}
    NON_OS_ENTER_LOCK();
   181b6:	b672      	cpsid	i
    non_os_critical_nesting++;
   181b8:	4a07      	ldr	r2, [pc, #28]	; (181d8 <non_os_enter_critical+0x24>)
   181ba:	8813      	ldrh	r3, [r2, #0]
   181bc:	3301      	adds	r3, #1
   181be:	b29b      	uxth	r3, r3
   181c0:	8013      	strh	r3, [r2, #0]
    assert(non_os_critical_nesting > 0); // assert we have not overflowed.
   181c2:	2b00      	cmp	r3, #0
   181c4:	d103      	bne.n	181ce <non_os_enter_critical+0x1a>
   181c6:	4671      	mov	r1, lr
   181c8:	2016      	movs	r0, #22
   181ca:	f7e9 fca1 	bl	1b10 <panic>
    __asm volatile( "dsb" );
   181ce:	f3bf 8f4f 	dsb	sy
    __asm volatile( "isb" );
   181d2:	f3bf 8f6f 	isb	sy
}
   181d6:	bd10      	pop	{r4, pc}
   181d8:	010027f0 	.word	0x010027f0

000181dc <non_os_exit_critical>:

void non_os_exit_critical( void )
{
   181dc:	b510      	push	{r4, lr}
    assert(non_os_critical_nesting > 0); // assert if we are trying to exit critical when no enter critical has been called
   181de:	4c08      	ldr	r4, [pc, #32]	; (18200 <non_os_exit_critical+0x24>)
   181e0:	8823      	ldrh	r3, [r4, #0]
   181e2:	2b00      	cmp	r3, #0
   181e4:	d103      	bne.n	181ee <non_os_exit_critical+0x12>
   181e6:	4671      	mov	r1, lr
   181e8:	2016      	movs	r0, #22
   181ea:	f7e9 fc91 	bl	1b10 <panic>
    non_os_critical_nesting--;
   181ee:	8823      	ldrh	r3, [r4, #0]
   181f0:	3b01      	subs	r3, #1
   181f2:	b29b      	uxth	r3, r3
   181f4:	8023      	strh	r3, [r4, #0]
    if( non_os_critical_nesting == 0 )
   181f6:	2b00      	cmp	r3, #0
   181f8:	d100      	bne.n	181fc <non_os_exit_critical+0x20>
    {
        NON_OS_EXIT_LOCK();
   181fa:	b662      	cpsie	i
    }
}
   181fc:	bd10      	pop	{r4, pc}
   181fe:	46c0      	nop			; (mov r8, r8)
   18200:	010027f0 	.word	0x010027f0

00018204 <non_os_is_driver_initialised>:
{
    return non_os_critical_nesting > 0;
}

bool non_os_is_driver_initialised(DRIVER_INIT_BIT driver)
{
   18204:	0003      	movs	r3, r0
    return ((driver_init_bits & (0x01UL << driver)) != 0);
   18206:	4a03      	ldr	r2, [pc, #12]	; (18214 <non_os_is_driver_initialised+0x10>)
   18208:	6810      	ldr	r0, [r2, #0]
   1820a:	40d8      	lsrs	r0, r3
   1820c:	2301      	movs	r3, #1
   1820e:	4018      	ands	r0, r3
}
   18210:	4770      	bx	lr
   18212:	46c0      	nop			; (mov r8, r8)
   18214:	010027ec 	.word	0x010027ec

00018218 <non_os_set_driver_initalised>:

void non_os_set_driver_initalised(DRIVER_INIT_BIT driver, bool value)
{
   18218:	b570      	push	{r4, r5, r6, lr}
   1821a:	0005      	movs	r5, r0
   1821c:	000c      	movs	r4, r1
    non_os_enter_critical();
   1821e:	f7ff ffc9 	bl	181b4 <non_os_enter_critical>
    uint32 mask = 0x01UL << driver;
   18222:	2201      	movs	r2, #1
   18224:	4b06      	ldr	r3, [pc, #24]	; (18240 <non_os_set_driver_initalised+0x28>)
   18226:	40aa      	lsls	r2, r5
    if (value)
    {
        driver_init_bits |= mask;
   18228:	6819      	ldr	r1, [r3, #0]
    if (value)
   1822a:	2c00      	cmp	r4, #0
   1822c:	d004      	beq.n	18238 <non_os_set_driver_initalised+0x20>
        driver_init_bits |= mask;
   1822e:	430a      	orrs	r2, r1
   18230:	601a      	str	r2, [r3, #0]
    }
    else
    {
        driver_init_bits &= (~mask);
    }
    non_os_exit_critical();
   18232:	f7ff ffd3 	bl	181dc <non_os_exit_critical>
}
   18236:	bd70      	pop	{r4, r5, r6, pc}
        driver_init_bits &= (~mask);
   18238:	4391      	bics	r1, r2
   1823a:	6019      	str	r1, [r3, #0]
   1823c:	e7f9      	b.n	18232 <non_os_set_driver_initalised+0x1a>
   1823e:	46c0      	nop			; (mov r8, r8)
   18240:	010027ec 	.word	0x010027ec

00018244 <non_os_is_this_interrupt_context>:
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __get_xPSR(void)
{
  uint32_t result;

  __ASM volatile ("MRS %0, xpsr" : "=r" (result) );
   18244:	f3ef 8003 	mrs	r0, PSR

bool non_os_is_this_interrupt_context()
{
    uint32 ic;
    ic = __get_xPSR();
    return ((ic & 0x0000003f) != 0);
   18248:	233f      	movs	r3, #63	; 0x3f
   1824a:	4018      	ands	r0, r3
   1824c:	1e43      	subs	r3, r0, #1
   1824e:	4198      	sbcs	r0, r3
   18250:	b2c0      	uxtb	r0, r0
}
   18252:	4770      	bx	lr

00018254 <pio_init>:
#include "pio.h"
#include "hal_pio.h"
#include "non_os.h"

void pio_init(void)
{
   18254:	b510      	push	{r4, lr}
    if (non_os_is_driver_initialised(DRIVER_INIT_PIO) == true)
   18256:	2003      	movs	r0, #3
   18258:	f7ff ffd4 	bl	18204 <non_os_is_driver_initialised>
   1825c:	2800      	cmp	r0, #0
   1825e:	d105      	bne.n	1826c <pio_init+0x18>
    {
        return;
    }
    hal_pio_init();
   18260:	f000 fb70 	bl	18944 <hal_pio_init>
    non_os_set_driver_initalised(DRIVER_INIT_PIO, true);
   18264:	2101      	movs	r1, #1
   18266:	2003      	movs	r0, #3
   18268:	f7ff ffd6 	bl	18218 <non_os_set_driver_initalised>
}
   1826c:	bd10      	pop	{r4, pc}

0001826e <pio_release>:

bool pio_release(PIN pin)
{
   1826e:	b510      	push	{r4, lr}
   18270:	0004      	movs	r4, r0
    hal_pio_release(pin);
   18272:	f000 fb75 	bl	18960 <hal_pio_release>
    if (hal_pio_get_function(pin) != FUNC_UNCLAIMED)
   18276:	0020      	movs	r0, r4
   18278:	f000 fb9c 	bl	189b4 <hal_pio_get_function>
   1827c:	4243      	negs	r3, r0
   1827e:	4158      	adcs	r0, r3
    {
        return false;
    }
    return true;
}
   18280:	b2c0      	uxtb	r0, r0
   18282:	bd10      	pop	{r4, pc}

00018284 <pio_set_function>:
{
    return hal_pio_set_function_force(pin, function);
}

bool pio_set_function(PIN pin, FUNC function)
{
   18284:	b510      	push	{r4, lr}
    return (hal_pio_set_function(pin, function));
   18286:	f000 fb75 	bl	18974 <hal_pio_set_function>
}
   1828a:	bd10      	pop	{r4, pc}

0001828c <pio_output_config>:
{
    return hal_pio_get_function( pin );
}

void pio_output_config(PIN pin, const pio_out_config * config)
{
   1828c:	b570      	push	{r4, r5, r6, lr}
   1828e:	000d      	movs	r5, r1
   18290:	0004      	movs	r4, r0
    hal_pio_config_drive( pin, (HAL_PIO_DRIVE) config->drive);
   18292:	7809      	ldrb	r1, [r1, #0]
   18294:	f000 fb9e 	bl	189d4 <hal_pio_config_drive>
    hal_pio_config_pull( pin, (HAL_PIO_PULL) config->pull);
   18298:	7869      	ldrb	r1, [r5, #1]
   1829a:	0020      	movs	r0, r4
   1829c:	f000 fbb0 	bl	18a00 <hal_pio_config_pull>
}
   182a0:	bd70      	pop	{r4, r5, r6, pc}

000182a2 <pio_input_config>:

void pio_input_config(PIN pin, const pio_in_config * config)
{
   182a2:	b510      	push	{r4, lr}
    hal_pio_config_pull( pin, (HAL_PIO_PULL) config->pull);
   182a4:	7809      	ldrb	r1, [r1, #0]
   182a6:	f000 fbab 	bl	18a00 <hal_pio_config_pull>
}
   182aa:	bd10      	pop	{r4, pc}

000182ac <reboot_system>:
    hal_reboot_core();
}

/* Perform a software reboot of the entire system. */
void reboot_system(REBOOT_CAUSE cause)
{
   182ac:	b510      	push	{r4, lr}
   182ae:	b092      	sub	sp, #72	; 0x48
    ipc_payload reboot_reason;

    reboot_reason.request_reboot.requested_reboot_reason = ((uint16)cause);
   182b0:	ac02      	add	r4, sp, #8
   182b2:	8020      	strh	r0, [r4, #0]

    non_os_enter_critical();
   182b4:	f7ff ff7e 	bl	181b4 <non_os_enter_critical>
    // Request the reset ...
    while (ipc_send_message( CORES_SECURITY_CORE, IPC_ACTION_SYS_REBOOT_REQ, &reboot_reason, IPC_PRIORITY_HIGHEST, false) != IPC_STATUS_OK) {}
   182b8:	2000      	movs	r0, #0
   182ba:	0022      	movs	r2, r4
   182bc:	9000      	str	r0, [sp, #0]
   182be:	0003      	movs	r3, r0
   182c0:	2106      	movs	r1, #6
   182c2:	f7ff f8bf 	bl	17444 <ipc_send_message>
   182c6:	2800      	cmp	r0, #0
   182c8:	d1f6      	bne.n	182b8 <reboot_system+0xc>
    non_os_exit_critical();
   182ca:	f7ff ff87 	bl	181dc <non_os_exit_critical>
}
   182ce:	b012      	add	sp, #72	; 0x48
   182d0:	bd10      	pop	{r4, pc}
	...

000182d4 <reboot_get_reset_reason>:

REBOOT_CAUSE reboot_get_reset_reason(void)
{
    return reboot_reset_reason;
   182d4:	4b01      	ldr	r3, [pc, #4]	; (182dc <reboot_get_reset_reason+0x8>)
   182d6:	8818      	ldrh	r0, [r3, #0]
}
   182d8:	4770      	bx	lr
   182da:	46c0      	nop			; (mov r8, r8)
   182dc:	010027f2 	.word	0x010027f2

000182e0 <reboot_notify_security_of_reboot>:
 * but it should never get called outside from that
 */
//lint -esym(714, reboot_notify_security_of_reboot) no referenced
void reboot_notify_security_of_reboot( void );
void reboot_notify_security_of_reboot( void )
{
   182e0:	b500      	push	{lr}
   182e2:	b093      	sub	sp, #76	; 0x4c
    IPC_STATUS status;
    ipc_payload payload;

    ipc_init();
   182e4:	f7ff f870 	bl	173c8 <ipc_init>
    hal_reboot_init();
   182e8:	f001 f9e8 	bl	196bc <hal_reboot_init>

    payload.core_started.reboot_cause = hal_reboot_get_reset_reason();
   182ec:	f001 f9f2 	bl	196d4 <hal_reboot_get_reset_reason>
   182f0:	9002      	str	r0, [sp, #8]

    do
    {
        status = ipc_send_message(CORES_SECURITY_CORE, IPC_ACTION_CORE_STARTED, (ipc_payload *)(&payload), IPC_PRIORITY_HIGHEST, false);
   182f2:	2000      	movs	r0, #0
   182f4:	aa02      	add	r2, sp, #8
   182f6:	9000      	str	r0, [sp, #0]
   182f8:	0003      	movs	r3, r0
   182fa:	0001      	movs	r1, r0
   182fc:	f7ff f8a2 	bl	17444 <ipc_send_message>
    } while (status == IPC_STATUS_MAILBOX_BUSY);
   18300:	2806      	cmp	r0, #6
   18302:	d0f6      	beq.n	182f2 <reboot_notify_security_of_reboot+0x12>

    if (status != IPC_STATUS_OK)
   18304:	2800      	cmp	r0, #0
   18306:	d000      	beq.n	1830a <reboot_notify_security_of_reboot+0x2a>
   18308:	e7fe      	b.n	18308 <reboot_notify_security_of_reboot+0x28>
        {
            // what should we do here?
        }
    }

    reboot_reset_reason = (REBOOT_CAUSE)system_status_system_starting();
   1830a:	f000 fa4d 	bl	187a8 <system_status_system_starting>
   1830e:	4b03      	ldr	r3, [pc, #12]	; (1831c <reboot_notify_security_of_reboot+0x3c>)
   18310:	8018      	strh	r0, [r3, #0]
    ipc_deinit();
   18312:	f7ff f86d 	bl	173f0 <ipc_deinit>
}
   18316:	b013      	add	sp, #76	; 0x4c
   18318:	bd00      	pop	{pc}
   1831a:	46c0      	nop			; (mov r8, r8)
   1831c:	010027f2 	.word	0x010027f2

00018320 <get_free_timer>:
 */
static rtc_timer_info * get_free_timer( void )
{
    rtc_timer_info * rtc_timer;

    if( rtc_free_timers == NULL )
   18320:	4a05      	ldr	r2, [pc, #20]	; (18338 <get_free_timer+0x18>)
   18322:	6810      	ldr	r0, [r2, #0]
   18324:	2800      	cmp	r0, #0
   18326:	d006      	beq.n	18336 <get_free_timer+0x16>

    rtc_timer = rtc_free_timers;   // Take unused timer from the free list
    rtc_timer->timer_key = (rtc_handle)rtc_timer;   // Ensure it has the correct key

    // Update head of free timers list
    rtc_free_timers = (rtc_timer_info  *)rtc_free_timers->next;
   18328:	6943      	ldr	r3, [r0, #20]
    rtc_timer->timer_key = (rtc_handle)rtc_timer;   // Ensure it has the correct key
   1832a:	60c0      	str	r0, [r0, #12]
    rtc_free_timers = (rtc_timer_info  *)rtc_free_timers->next;
   1832c:	6013      	str	r3, [r2, #0]
    if( rtc_free_timers != NULL )
   1832e:	2b00      	cmp	r3, #0
   18330:	d001      	beq.n	18336 <get_free_timer+0x16>
    {   // Head of list has no previous item
        rtc_free_timers->prev = NULL;
   18332:	2200      	movs	r2, #0
   18334:	611a      	str	r2, [r3, #16]
    }

    return rtc_timer;
}
   18336:	4770      	bx	lr
   18338:	010027fc 	.word	0x010027fc

0001833c <set_next_rtc_timer_interrupt>:
{
   1833c:	b510      	push	{r4, lr}
    rtc_timer_info *current_rtc = rtc_active_timers;
   1833e:	4b0e      	ldr	r3, [pc, #56]	; (18378 <set_next_rtc_timer_interrupt+0x3c>)
   18340:	681c      	ldr	r4, [r3, #0]
    if ((current_rtc == NULL) || rtc_in_rtc_irq)
   18342:	2c00      	cmp	r4, #0
   18344:	d017      	beq.n	18376 <set_next_rtc_timer_interrupt+0x3a>
   18346:	4b0d      	ldr	r3, [pc, #52]	; (1837c <set_next_rtc_timer_interrupt+0x40>)
   18348:	781b      	ldrb	r3, [r3, #0]
   1834a:	2b00      	cmp	r3, #0
   1834c:	d113      	bne.n	18376 <set_next_rtc_timer_interrupt+0x3a>
    non_os_enter_critical();
   1834e:	f7ff ff31 	bl	181b4 <non_os_enter_critical>
    current_time = hal_rtc_get_time() + RTC_EXTRA_TIME;  //Another fudge factor...
   18352:	4b0b      	ldr	r3, [pc, #44]	; (18380 <set_next_rtc_timer_interrupt+0x44>)
   18354:	4798      	blx	r3
   18356:	2204      	movs	r2, #4
   18358:	2300      	movs	r3, #0
   1835a:	1812      	adds	r2, r2, r0
   1835c:	414b      	adcs	r3, r1
    if (current_rtc->callback_time <= current_time)
   1835e:	cc03      	ldmia	r4!, {r0, r1}
   18360:	4299      	cmp	r1, r3
   18362:	d804      	bhi.n	1836e <set_next_rtc_timer_interrupt+0x32>
   18364:	d101      	bne.n	1836a <set_next_rtc_timer_interrupt+0x2e>
   18366:	4290      	cmp	r0, r2
   18368:	d801      	bhi.n	1836e <set_next_rtc_timer_interrupt+0x32>
        hal_rtc_set_irq_time(current_time);
   1836a:	0010      	movs	r0, r2
   1836c:	0019      	movs	r1, r3
        hal_rtc_set_irq_time(current_rtc->callback_time);
   1836e:	f001 f9b7 	bl	196e0 <hal_rtc_set_irq_time>
    non_os_exit_critical();
   18372:	f7ff ff33 	bl	181dc <non_os_exit_critical>
}
   18376:	bd10      	pop	{r4, pc}
   18378:	010027f4 	.word	0x010027f4
   1837c:	01002800 	.word	0x01002800
   18380:	010004b1 	.word	0x010004b1

00018384 <rtc_irq_handler>:
{
   18384:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    rtc_in_rtc_irq = true;
   18386:	2301      	movs	r3, #1
   18388:	4a1e      	ldr	r2, [pc, #120]	; (18404 <rtc_irq_handler+0x80>)
    current_time = hal_rtc_get_time() + RTC_EXTRA_TIME; // If we are this close we should probably just call it
   1838a:	2404      	movs	r4, #4
    rtc_in_rtc_irq = true;
   1838c:	7013      	strb	r3, [r2, #0]
    non_os_enter_critical();
   1838e:	f7ff ff11 	bl	181b4 <non_os_enter_critical>
    current_time = hal_rtc_get_time() + RTC_EXTRA_TIME; // If we are this close we should probably just call it
   18392:	4b1d      	ldr	r3, [pc, #116]	; (18408 <rtc_irq_handler+0x84>)
   18394:	4798      	blx	r3
   18396:	2500      	movs	r5, #0
   18398:	1900      	adds	r0, r0, r4
   1839a:	4169      	adcs	r1, r5
    current_rtc = rtc_active_timers;
   1839c:	4e1b      	ldr	r6, [pc, #108]	; (1840c <rtc_irq_handler+0x88>)
        current_rtc = rtc_active_timers;
   1839e:	6833      	ldr	r3, [r6, #0]
    while ((current_rtc != NULL) && (current_rtc->callback_time < current_time))
   183a0:	2b00      	cmp	r3, #0
   183a2:	d006      	beq.n	183b2 <rtc_irq_handler+0x2e>
   183a4:	685a      	ldr	r2, [r3, #4]
   183a6:	428a      	cmp	r2, r1
   183a8:	d30b      	bcc.n	183c2 <rtc_irq_handler+0x3e>
   183aa:	d102      	bne.n	183b2 <rtc_irq_handler+0x2e>
   183ac:	681a      	ldr	r2, [r3, #0]
   183ae:	4282      	cmp	r2, r0
   183b0:	d307      	bcc.n	183c2 <rtc_irq_handler+0x3e>
    non_os_exit_critical();
   183b2:	f7ff ff13 	bl	181dc <non_os_exit_critical>
    rtc_in_rtc_irq = false;
   183b6:	2300      	movs	r3, #0
   183b8:	4a12      	ldr	r2, [pc, #72]	; (18404 <rtc_irq_handler+0x80>)
   183ba:	7013      	strb	r3, [r2, #0]
    set_next_rtc_timer_interrupt();
   183bc:	f7ff ffbe 	bl	1833c <set_next_rtc_timer_interrupt>
}
   183c0:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
        rtc_active_timers = (rtc_timer_info *)current_rtc->next;
   183c2:	695a      	ldr	r2, [r3, #20]
   183c4:	6032      	str	r2, [r6, #0]
        if( rtc_active_timers != NULL )
   183c6:	2a00      	cmp	r2, #0
   183c8:	d001      	beq.n	183ce <rtc_irq_handler+0x4a>
            rtc_active_timers->prev = NULL;
   183ca:	2100      	movs	r1, #0
   183cc:	6111      	str	r1, [r2, #16]
   183ce:	2200      	movs	r2, #0
        if (current_rtc->flag == RTC_FLAG_PERMANENT)
   183d0:	7e19      	ldrb	r1, [r3, #24]
            current_rtc->prev = NULL;
   183d2:	611a      	str	r2, [r3, #16]
        if (current_rtc->flag == RTC_FLAG_PERMANENT)
   183d4:	2901      	cmp	r1, #1
   183d6:	d113      	bne.n	18400 <rtc_irq_handler+0x7c>
            current_rtc->next = (struct rtc_timer_info *)rtc_dormant_timers;
   183d8:	490d      	ldr	r1, [pc, #52]	; (18410 <rtc_irq_handler+0x8c>)
            current_rtc->next = (struct rtc_timer_info *)rtc_free_timers;
   183da:	680a      	ldr	r2, [r1, #0]
   183dc:	615a      	str	r2, [r3, #20]
            if( rtc_free_timers != NULL )
   183de:	2a00      	cmp	r2, #0
   183e0:	d000      	beq.n	183e4 <rtc_irq_handler+0x60>
                rtc_free_timers->prev = (struct rtc_timer_info *)current_rtc;
   183e2:	6113      	str	r3, [r2, #16]
            rtc_free_timers = current_rtc;
   183e4:	600b      	str	r3, [r1, #0]
        if (current_rtc->callback_func != NULL)
   183e6:	689f      	ldr	r7, [r3, #8]
   183e8:	2f00      	cmp	r7, #0
   183ea:	d004      	beq.n	183f6 <rtc_irq_handler+0x72>
            non_os_exit_critical();
   183ec:	f7ff fef6 	bl	181dc <non_os_exit_critical>
            tmp_callback_func();
   183f0:	47b8      	blx	r7
            non_os_enter_critical();
   183f2:	f7ff fedf 	bl	181b4 <non_os_enter_critical>
        current_time = hal_rtc_get_time() + RTC_EXTRA_TIME;
   183f6:	4b04      	ldr	r3, [pc, #16]	; (18408 <rtc_irq_handler+0x84>)
   183f8:	4798      	blx	r3
   183fa:	1900      	adds	r0, r0, r4
   183fc:	4169      	adcs	r1, r5
   183fe:	e7ce      	b.n	1839e <rtc_irq_handler+0x1a>
            current_rtc->next = (struct rtc_timer_info *)rtc_free_timers;
   18400:	4904      	ldr	r1, [pc, #16]	; (18414 <rtc_irq_handler+0x90>)
   18402:	e7ea      	b.n	183da <rtc_irq_handler+0x56>
   18404:	01002800 	.word	0x01002800
   18408:	010004b1 	.word	0x010004b1
   1840c:	010027f4 	.word	0x010027f4
   18410:	010027f8 	.word	0x010027f8
   18414:	010027fc 	.word	0x010027fc

00018418 <add_to_active_list>:
{
   18418:	b570      	push	{r4, r5, r6, lr}
    rtc_timer_info *current_rtc = rtc_active_timers;
   1841a:	4c14      	ldr	r4, [pc, #80]	; (1846c <add_to_active_list+0x54>)
    rtc_timer_info *previous_rtc = NULL;
   1841c:	2200      	movs	r2, #0
    rtc_timer_info *current_rtc = rtc_active_timers;
   1841e:	6821      	ldr	r1, [r4, #0]
   18420:	000b      	movs	r3, r1
    while (current_rtc && (new_rtc_timer->callback_time > current_rtc->callback_time))
   18422:	2b00      	cmp	r3, #0
   18424:	d01c      	beq.n	18460 <add_to_active_list+0x48>
   18426:	6846      	ldr	r6, [r0, #4]
   18428:	685d      	ldr	r5, [r3, #4]
   1842a:	42ae      	cmp	r6, r5
   1842c:	d810      	bhi.n	18450 <add_to_active_list+0x38>
   1842e:	d103      	bne.n	18438 <add_to_active_list+0x20>
   18430:	6805      	ldr	r5, [r0, #0]
   18432:	681e      	ldr	r6, [r3, #0]
   18434:	42b5      	cmp	r5, r6
   18436:	d80b      	bhi.n	18450 <add_to_active_list+0x38>
    if (previous_rtc == NULL)
   18438:	2a00      	cmp	r2, #0
   1843a:	d10c      	bne.n	18456 <add_to_active_list+0x3e>
        new_rtc_timer->prev = (struct rtc_timer_info *)NULL;
   1843c:	2300      	movs	r3, #0
        new_rtc_timer->next = (struct rtc_timer_info *)rtc_active_timers;
   1843e:	6141      	str	r1, [r0, #20]
        new_rtc_timer->prev = (struct rtc_timer_info *)NULL;
   18440:	6103      	str	r3, [r0, #16]
        if( rtc_active_timers != NULL )
   18442:	4299      	cmp	r1, r3
   18444:	d000      	beq.n	18448 <add_to_active_list+0x30>
            rtc_active_timers->prev = (struct rtc_timer_info *)new_rtc_timer;
   18446:	6108      	str	r0, [r1, #16]
        rtc_active_timers = new_rtc_timer;
   18448:	6020      	str	r0, [r4, #0]
        set_next_rtc_timer_interrupt();
   1844a:	f7ff ff77 	bl	1833c <set_next_rtc_timer_interrupt>
}
   1844e:	bd70      	pop	{r4, r5, r6, pc}
        current_rtc = (rtc_timer_info *)current_rtc->next;
   18450:	001a      	movs	r2, r3
   18452:	695b      	ldr	r3, [r3, #20]
   18454:	e7e5      	b.n	18422 <add_to_active_list+0xa>
        previous_rtc->next = (struct rtc_timer_info *)new_rtc_timer;
   18456:	6150      	str	r0, [r2, #20]
        new_rtc_timer->next = (struct rtc_timer_info *)current_rtc;
   18458:	6143      	str	r3, [r0, #20]
        new_rtc_timer->prev = (struct rtc_timer_info *)previous_rtc;
   1845a:	6102      	str	r2, [r0, #16]
            current_rtc->prev = (struct rtc_timer_info *)new_rtc_timer;
   1845c:	6118      	str	r0, [r3, #16]
   1845e:	e7f6      	b.n	1844e <add_to_active_list+0x36>
    if (previous_rtc == NULL)
   18460:	2a00      	cmp	r2, #0
   18462:	d0eb      	beq.n	1843c <add_to_active_list+0x24>
        previous_rtc->next = (struct rtc_timer_info *)new_rtc_timer;
   18464:	6150      	str	r0, [r2, #20]
        new_rtc_timer->next = (struct rtc_timer_info *)current_rtc;
   18466:	6143      	str	r3, [r0, #20]
        new_rtc_timer->prev = (struct rtc_timer_info *)previous_rtc;
   18468:	6102      	str	r2, [r0, #16]
   1846a:	e7f0      	b.n	1844e <add_to_active_list+0x36>
   1846c:	010027f4 	.word	0x010027f4

00018470 <timer_remove>:
{
   18470:	b510      	push	{r4, lr}
    if (current_rtc->timer_key == timer_id)
   18472:	68c3      	ldr	r3, [r0, #12]
   18474:	4672      	mov	r2, lr
{
   18476:	0004      	movs	r4, r0
    if (current_rtc->timer_key == timer_id)
   18478:	4283      	cmp	r3, r0
   1847a:	d106      	bne.n	1848a <timer_remove+0x1a>
        if (current_rtc->flag != type)
   1847c:	7e03      	ldrb	r3, [r0, #24]
   1847e:	428b      	cmp	r3, r1
   18480:	d005      	beq.n	1848e <timer_remove+0x1e>
            assert(false);
   18482:	4671      	mov	r1, lr
   18484:	2016      	movs	r0, #22
   18486:	f7e9 fb43 	bl	1b10 <panic>
    return NULL;
   1848a:	2400      	movs	r4, #0
   1848c:	e00c      	b.n	184a8 <timer_remove+0x38>
        next_rtc = (rtc_timer_info *)current_rtc->next;
   1848e:	6943      	ldr	r3, [r0, #20]
        if( next_rtc != NULL )
   18490:	2b00      	cmp	r3, #0
   18492:	d001      	beq.n	18498 <timer_remove+0x28>
            next_rtc->prev = (struct rtc_timer_info *)current_rtc->prev;
   18494:	6901      	ldr	r1, [r0, #16]
   18496:	6119      	str	r1, [r3, #16]
        prev_rtc = (rtc_timer_info *)current_rtc->prev;
   18498:	6923      	ldr	r3, [r4, #16]
        if( prev_rtc != NULL )
   1849a:	2b00      	cmp	r3, #0
   1849c:	d006      	beq.n	184ac <timer_remove+0x3c>
            prev_rtc->next = (struct rtc_timer_info *)current_rtc->next;
   1849e:	6962      	ldr	r2, [r4, #20]
   184a0:	615a      	str	r2, [r3, #20]
        current_rtc->next = NULL;
   184a2:	2300      	movs	r3, #0
   184a4:	6163      	str	r3, [r4, #20]
        current_rtc->prev = NULL;
   184a6:	6123      	str	r3, [r4, #16]
}
   184a8:	0020      	movs	r0, r4
   184aa:	bd10      	pop	{r4, pc}
            if( rtc_active_timers == current_rtc )
   184ac:	4b0c      	ldr	r3, [pc, #48]	; (184e0 <timer_remove+0x70>)
   184ae:	6819      	ldr	r1, [r3, #0]
   184b0:	42a1      	cmp	r1, r4
   184b2:	d104      	bne.n	184be <timer_remove+0x4e>
                rtc_active_timers = (rtc_timer_info *)current_rtc->next;
   184b4:	6962      	ldr	r2, [r4, #20]
   184b6:	601a      	str	r2, [r3, #0]
                set_next_rtc_timer_interrupt();
   184b8:	f7ff ff40 	bl	1833c <set_next_rtc_timer_interrupt>
   184bc:	e7f1      	b.n	184a2 <timer_remove+0x32>
            else if( rtc_dormant_timers == current_rtc )
   184be:	4b09      	ldr	r3, [pc, #36]	; (184e4 <timer_remove+0x74>)
   184c0:	6819      	ldr	r1, [r3, #0]
   184c2:	42a1      	cmp	r1, r4
   184c4:	d102      	bne.n	184cc <timer_remove+0x5c>
                rtc_free_timers = (rtc_timer_info *)current_rtc->next;
   184c6:	6962      	ldr	r2, [r4, #20]
   184c8:	601a      	str	r2, [r3, #0]
   184ca:	e7ea      	b.n	184a2 <timer_remove+0x32>
            else if( rtc_free_timers == current_rtc )
   184cc:	4b06      	ldr	r3, [pc, #24]	; (184e8 <timer_remove+0x78>)
   184ce:	6819      	ldr	r1, [r3, #0]
   184d0:	42a1      	cmp	r1, r4
   184d2:	d0f8      	beq.n	184c6 <timer_remove+0x56>
                assert( false );
   184d4:	0011      	movs	r1, r2
   184d6:	2016      	movs	r0, #22
   184d8:	f7e9 fb1a 	bl	1b10 <panic>
   184dc:	e7e1      	b.n	184a2 <timer_remove+0x32>
   184de:	46c0      	nop			; (mov r8, r8)
   184e0:	010027f4 	.word	0x010027f4
   184e4:	010027f8 	.word	0x010027f8
   184e8:	010027fc 	.word	0x010027fc

000184ec <rtc_init>:
{
   184ec:	b570      	push	{r4, r5, r6, lr}
    if (non_os_is_driver_initialised(DRIVER_INIT_RTC) == true)
   184ee:	2001      	movs	r0, #1
   184f0:	f7ff fe88 	bl	18204 <non_os_is_driver_initialised>
   184f4:	1e06      	subs	r6, r0, #0
   184f6:	d135      	bne.n	18564 <rtc_init+0x78>
    RTC_CLEAR_INTERRUPTS();
   184f8:	2201      	movs	r2, #1
   184fa:	4b1b      	ldr	r3, [pc, #108]	; (18568 <rtc_init+0x7c>)
   184fc:	4252      	negs	r2, r2
   184fe:	601a      	str	r2, [r3, #0]
    hal_rtc_set_callback(rtc_irq_handler);
   18500:	481a      	ldr	r0, [pc, #104]	; (1856c <rtc_init+0x80>)
   18502:	f001 f907 	bl	19714 <hal_rtc_set_callback>
  if((int32_t)(IRQn) < 0) {
    SCB->SHP[_SHP_IDX(IRQn)] = ((uint32_t)(SCB->SHP[_SHP_IDX(IRQn)] & ~(0xFFUL << _BIT_SHIFT(IRQn))) |
       (((priority << (8 - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL) << _BIT_SHIFT(IRQn)));
  }
  else {
    NVIC->IP[_IP_IDX(IRQn)]  = ((uint32_t)(NVIC->IP[_IP_IDX(IRQn)]  & ~(0xFFUL << _BIT_SHIFT(IRQn))) |
   18506:	21c0      	movs	r1, #192	; 0xc0
   18508:	22ff      	movs	r2, #255	; 0xff
   1850a:	4c19      	ldr	r4, [pc, #100]	; (18570 <rtc_init+0x84>)
   1850c:	0089      	lsls	r1, r1, #2
   1850e:	5863      	ldr	r3, [r4, r1]
    memset( (void *)rtc_timer_store, 0, sizeof(rtc_timer_store) );
   18510:	4d18      	ldr	r5, [pc, #96]	; (18574 <rtc_init+0x88>)
   18512:	4393      	bics	r3, r2
   18514:	001a      	movs	r2, r3
   18516:	23c0      	movs	r3, #192	; 0xc0
   18518:	4313      	orrs	r3, r2
   1851a:	2280      	movs	r2, #128	; 0x80
   1851c:	5063      	str	r3, [r4, r1]
   1851e:	0092      	lsls	r2, r2, #2
   18520:	0031      	movs	r1, r6
   18522:	0028      	movs	r0, r5
   18524:	f7e7 fedc 	bl	2e0 <memset>
   18528:	0029      	movs	r1, r5
   1852a:	4b13      	ldr	r3, [pc, #76]	; (18578 <rtc_init+0x8c>)
   1852c:	31ed      	adds	r1, #237	; 0xed
   1852e:	31ff      	adds	r1, #255	; 0xff
   18530:	001a      	movs	r2, r3
        rtc_timer_store[i].next = (struct rtc_timer_info *)&rtc_timer_store[i + 1];
   18532:	0018      	movs	r0, r3
   18534:	3a0c      	subs	r2, #12
   18536:	3014      	adds	r0, #20
        rtc_timer_store[i].timer_key = (rtc_handle)&rtc_timer_store[i];
   18538:	601a      	str	r2, [r3, #0]
        rtc_timer_store[i].next = (struct rtc_timer_info *)&rtc_timer_store[i + 1];
   1853a:	6098      	str	r0, [r3, #8]
        rtc_timer_store[i+1].prev = (struct rtc_timer_info *)&rtc_timer_store[i];
   1853c:	625a      	str	r2, [r3, #36]	; 0x24
   1853e:	3320      	adds	r3, #32
    for( uint16 i = 0; i < (RTC_TIMER_MAX_TIMERS - 1); i++ )
   18540:	4299      	cmp	r1, r3
   18542:	d1f5      	bne.n	18530 <rtc_init+0x44>
    rtc_timer_store[RTC_TIMER_MAX_TIMERS - 1].timer_key = (rtc_handle)&rtc_timer_store[RTC_TIMER_MAX_TIMERS - 1];
   18544:	23f6      	movs	r3, #246	; 0xf6
   18546:	4a0d      	ldr	r2, [pc, #52]	; (1857c <rtc_init+0x90>)
   18548:	005b      	lsls	r3, r3, #1
   1854a:	50ea      	str	r2, [r5, r3]
    rtc_free_timers = rtc_timer_store;
   1854c:	4b0c      	ldr	r3, [pc, #48]	; (18580 <rtc_init+0x94>)
  NVIC->ISER[0] = (uint32_t)(1UL << (((uint32_t)(int32_t)IRQn) & 0x1FUL));
   1854e:	2001      	movs	r0, #1
   18550:	601d      	str	r5, [r3, #0]
    rtc_dormant_timers = NULL;
   18552:	2300      	movs	r3, #0
   18554:	4a0b      	ldr	r2, [pc, #44]	; (18584 <rtc_init+0x98>)
    non_os_set_driver_initalised(DRIVER_INIT_RTC, true);
   18556:	0001      	movs	r1, r0
    rtc_dormant_timers = NULL;
   18558:	6013      	str	r3, [r2, #0]
    rtc_active_timers = NULL;
   1855a:	4a0b      	ldr	r2, [pc, #44]	; (18588 <rtc_init+0x9c>)
   1855c:	6013      	str	r3, [r2, #0]
   1855e:	6020      	str	r0, [r4, #0]
    non_os_set_driver_initalised(DRIVER_INIT_RTC, true);
   18560:	f7ff fe5a 	bl	18218 <non_os_set_driver_initalised>
}
   18564:	bd70      	pop	{r4, r5, r6, pc}
   18566:	46c0      	nop			; (mov r8, r8)
   18568:	400000bc 	.word	0x400000bc
   1856c:	00018385 	.word	0x00018385
   18570:	e000e100 	.word	0xe000e100
   18574:	01002808 	.word	0x01002808
   18578:	01002814 	.word	0x01002814
   1857c:	010029e8 	.word	0x010029e8
   18580:	010027fc 	.word	0x010027fc
   18584:	010027f8 	.word	0x010027f8
   18588:	010027f4 	.word	0x010027f4

0001858c <rtc_delete>:

    return ret;
}

rtc_status rtc_delete(rtc_handle timer_id)
{
   1858c:	b510      	push	{r4, lr}
   1858e:	0004      	movs	r4, r0
    rtc_timer_info *current_rtc = NULL;
    rtc_status ret = RTC_FAILURE;

    non_os_enter_critical();
   18590:	f7ff fe10 	bl	181b4 <non_os_enter_critical>

    current_rtc = timer_remove(timer_id, RTC_FLAG_NORMAL); //lint !e838
   18594:	0020      	movs	r0, r4
   18596:	2100      	movs	r1, #0
   18598:	f7ff ff6a 	bl	18470 <timer_remove>
    rtc_status ret = RTC_FAILURE;
   1859c:	1e04      	subs	r4, r0, #0
    if (current_rtc != NULL)
   1859e:	d007      	beq.n	185b0 <rtc_delete+0x24>
    {
        // Place removed timer on the free list
        current_rtc->next = (struct rtc_timer_info *)rtc_free_timers;
   185a0:	4a05      	ldr	r2, [pc, #20]	; (185b8 <rtc_delete+0x2c>)
   185a2:	6813      	ldr	r3, [r2, #0]
   185a4:	6143      	str	r3, [r0, #20]
        if( rtc_free_timers != NULL )
   185a6:	2b00      	cmp	r3, #0
   185a8:	d000      	beq.n	185ac <rtc_delete+0x20>
        {
            rtc_free_timers->prev = (struct rtc_timer_info *)current_rtc;
   185aa:	6118      	str	r0, [r3, #16]
        }
        rtc_free_timers = current_rtc;

        ret = RTC_SUCCESS;
   185ac:	2401      	movs	r4, #1
        rtc_free_timers = current_rtc;
   185ae:	6010      	str	r0, [r2, #0]
    }

    non_os_exit_critical();
   185b0:	f7ff fe14 	bl	181dc <non_os_exit_critical>

    return ret;
}
   185b4:	0020      	movs	r0, r4
   185b6:	bd10      	pop	{r4, pc}
   185b8:	010027fc 	.word	0x010027fc

000185bc <rtc_add_at>:

rtc_handle rtc_add_at(uint64 rtc_time, rtc_timer_callback callback_func, RTC_FLAG flag)
{
   185bc:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
   185be:	0006      	movs	r6, r0
   185c0:	000f      	movs	r7, r1
   185c2:	0015      	movs	r5, r2
   185c4:	9301      	str	r3, [sp, #4]
    rtc_timer_info * new_rtc_timer;
    if( callback_func == NULL )
    {
        return NULL;
   185c6:	1e14      	subs	r4, r2, #0
    if( callback_func == NULL )
   185c8:	d00f      	beq.n	185ea <rtc_add_at+0x2e>
    }

    non_os_enter_critical();
   185ca:	f7ff fdf3 	bl	181b4 <non_os_enter_critical>
    new_rtc_timer = get_free_timer();
   185ce:	f7ff fea7 	bl	18320 <get_free_timer>
   185d2:	1e04      	subs	r4, r0, #0
    if( new_rtc_timer != NULL )
   185d4:	d007      	beq.n	185e6 <rtc_add_at+0x2a>
    {
        new_rtc_timer->callback_func = callback_func;
        new_rtc_timer->flag = flag;
   185d6:	466b      	mov	r3, sp
   185d8:	791b      	ldrb	r3, [r3, #4]
        new_rtc_timer->callback_func = callback_func;
   185da:	6085      	str	r5, [r0, #8]
        new_rtc_timer->flag = flag;
   185dc:	7603      	strb	r3, [r0, #24]
        new_rtc_timer->callback_time = rtc_time;
   185de:	6006      	str	r6, [r0, #0]
   185e0:	6047      	str	r7, [r0, #4]
        add_to_active_list( new_rtc_timer );
   185e2:	f7ff ff19 	bl	18418 <add_to_active_list>
    }
    non_os_exit_critical();
   185e6:	f7ff fdf9 	bl	181dc <non_os_exit_critical>

    return new_rtc_timer;
}
   185ea:	0020      	movs	r0, r4
   185ec:	bdfe      	pop	{r1, r2, r3, r4, r5, r6, r7, pc}
	...

000185f0 <rtc_get_time>:
{
    return hal_rtc_get_time_lsbs();
}

uint64 rtc_get_time(void)
{
   185f0:	b510      	push	{r4, lr}
    return hal_rtc_get_time();
   185f2:	4b01      	ldr	r3, [pc, #4]	; (185f8 <rtc_get_time+0x8>)
   185f4:	4798      	blx	r3
}
   185f6:	bd10      	pop	{r4, pc}
   185f8:	010004b1 	.word	0x010004b1

000185fc <rtc_get_time_us>:

uint64 rtc_get_time_us(void)
{
   185fc:	b510      	push	{r4, lr}
    return hal_rtc_get_time_us();
   185fe:	f001 f89f 	bl	19740 <hal_rtc_get_time_us>
}
   18602:	bd10      	pop	{r4, pc}

00018604 <rtc_get_time_ms>:

uint64 rtc_get_time_ms(void)
{
   18604:	b510      	push	{r4, lr}
    return hal_rtc_get_time_ms();
   18606:	f001 f8c3 	bl	19790 <hal_rtc_get_time_ms>
}
   1860a:	bd10      	pop	{r4, pc}

0001860c <rtc_set_current_time>:
{
    return hal_rtc_get_future_time( time_period_in_ticks );
}

void rtc_set_current_time(uint64 current_time, int8 time_zone, uint8 daylight_saving_time, uint8 updated_time_fields)
{
   1860c:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
   1860e:	001e      	movs	r6, r3
   18610:	ab06      	add	r3, sp, #24
   18612:	781d      	ldrb	r5, [r3, #0]
   18614:	0017      	movs	r7, r2
    if ((updated_time_fields & CURRENT_TIME_FIELD_UPDATED) != 0)
   18616:	07eb      	lsls	r3, r5, #31
   18618:	d510      	bpl.n	1863c <rtc_set_current_time+0x30>
    {
        current_time_info.unix_time_of_last_update      = current_time;
   1861a:	4c0d      	ldr	r4, [pc, #52]	; (18650 <rtc_set_current_time+0x44>)
    return hal_rtc_get_time();
   1861c:	4b0d      	ldr	r3, [pc, #52]	; (18654 <rtc_set_current_time+0x48>)
        current_time_info.unix_time_of_last_update      = current_time;
   1861e:	60a0      	str	r0, [r4, #8]
   18620:	60e1      	str	r1, [r4, #12]
    return hal_rtc_get_time();
   18622:	4798      	blx	r3
        current_time_info.rtc_time_ticks_of_last_update = rtc_get_time();
        current_time_info.adjusted_rtc_ticks            = 0;
   18624:	2300      	movs	r3, #0
   18626:	2200      	movs	r2, #0
   18628:	6122      	str	r2, [r4, #16]
   1862a:	6163      	str	r3, [r4, #20]

        if (current_time_info.current_rtc_freq == 0)
   1862c:	69a3      	ldr	r3, [r4, #24]
        current_time_info.rtc_time_ticks_of_last_update = rtc_get_time();
   1862e:	6020      	str	r0, [r4, #0]
   18630:	6061      	str	r1, [r4, #4]
        if (current_time_info.current_rtc_freq == 0)
   18632:	2b00      	cmp	r3, #0
   18634:	d102      	bne.n	1863c <rtc_set_current_time+0x30>
        {
            current_time_info.current_rtc_freq = ((uint32)CLOCKS_REFERENCE_CLOCK_FREQ << 16);
   18636:	2380      	movs	r3, #128	; 0x80
   18638:	061b      	lsls	r3, r3, #24
   1863a:	61a3      	str	r3, [r4, #24]
        }
    }

    if ((updated_time_fields & CURRENT_TIME_ZONE_FIELD_UPDATED) != 0)
   1863c:	07ab      	lsls	r3, r5, #30
   1863e:	d501      	bpl.n	18644 <rtc_set_current_time+0x38>
    {
        current_time_info.current_time_zone     = time_zone;
   18640:	4b03      	ldr	r3, [pc, #12]	; (18650 <rtc_set_current_time+0x44>)
   18642:	771f      	strb	r7, [r3, #28]
    }
    
    if ((updated_time_fields & CURRENT_TIME_SAVING_TIME_FIELD_UPDATED) != 0)
   18644:	076b      	lsls	r3, r5, #29
   18646:	d501      	bpl.n	1864c <rtc_set_current_time+0x40>
    {
        current_time_info.daylight_saving_time  = daylight_saving_time;
   18648:	4b01      	ldr	r3, [pc, #4]	; (18650 <rtc_set_current_time+0x44>)
   1864a:	775e      	strb	r6, [r3, #29]
    }
}
   1864c:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
   1864e:	46c0      	nop			; (mov r8, r8)
   18650:	01002ed8 	.word	0x01002ed8
   18654:	010004b1 	.word	0x010004b1

00018658 <rtc_rf_calibration_rtc>:

void rtc_rf_calibration_rtc(uint32 rtc_freq_calibrated_by_rf)
{
   18658:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
   1865a:	1e07      	subs	r7, r0, #0
    if (rtc_freq_calibrated_by_rf == 0)
   1865c:	d035      	beq.n	186ca <rtc_rf_calibration_rtc+0x72>
    {
        return;
    }

    if (current_time_info.unix_time_of_last_update != 0)
   1865e:	4c1d      	ldr	r4, [pc, #116]	; (186d4 <rtc_rf_calibration_rtc+0x7c>)
   18660:	68a3      	ldr	r3, [r4, #8]
   18662:	68e2      	ldr	r2, [r4, #12]
   18664:	4313      	orrs	r3, r2
   18666:	d02e      	beq.n	186c6 <rtc_rf_calibration_rtc+0x6e>
    return hal_rtc_get_time();
   18668:	4b1b      	ldr	r3, [pc, #108]	; (186d8 <rtc_rf_calibration_rtc+0x80>)
   1866a:	4798      	blx	r3
    {
        uint64 rtc_time_ticks_at_call = rtc_get_time();

        if (rtc_time_ticks_at_call <= current_time_info.rtc_time_ticks_of_last_update)
   1866c:	6822      	ldr	r2, [r4, #0]
   1866e:	6863      	ldr	r3, [r4, #4]
    return hal_rtc_get_time();
   18670:	9000      	str	r0, [sp, #0]
   18672:	9101      	str	r1, [sp, #4]
        if (rtc_time_ticks_at_call <= current_time_info.rtc_time_ticks_of_last_update)
   18674:	9901      	ldr	r1, [sp, #4]
   18676:	4299      	cmp	r1, r3
   18678:	d803      	bhi.n	18682 <rtc_rf_calibration_rtc+0x2a>
   1867a:	d126      	bne.n	186ca <rtc_rf_calibration_rtc+0x72>
   1867c:	9900      	ldr	r1, [sp, #0]
   1867e:	4291      	cmp	r1, r2
   18680:	d923      	bls.n	186ca <rtc_rf_calibration_rtc+0x72>
        {
            return;
        }

        uint8  downshift                = 0;
        uint64 elapsed_rtc_time         = rtc_time_ticks_at_call - current_time_info.rtc_time_ticks_of_last_update;
   18682:	9800      	ldr	r0, [sp, #0]
   18684:	9901      	ldr	r1, [sp, #4]
   18686:	1a80      	subs	r0, r0, r2
   18688:	4199      	sbcs	r1, r3
        uint8  downshift                = 0;
   1868a:	2400      	movs	r4, #0
        uint64 elapsed_rtc_time         = rtc_time_ticks_at_call - current_time_info.rtc_time_ticks_of_last_update;
   1868c:	0002      	movs	r2, r0
   1868e:	000b      	movs	r3, r1
        uint64 elapsed_rtc_time_shifted = elapsed_rtc_time; 
   18690:	000d      	movs	r5, r1
        while(elapsed_rtc_time_shifted >= MAX_RTC_TICKS_SHIFTED_DOWN_TEN)
   18692:	2d00      	cmp	r5, #0
   18694:	d11a      	bne.n	186cc <rtc_rf_calibration_rtc+0x74>
        {
            elapsed_rtc_time_shifted >>= 1U;
            downshift++;
        }

        current_time_info.adjusted_rtc_ticks += ((elapsed_rtc_time * (((uint32)CLOCKS_REFERENCE_CLOCK_FREQ) << (16U - downshift))) / (current_time_info.current_rtc_freq >> downshift)); //lint !e647
   18696:	2110      	movs	r1, #16
   18698:	2080      	movs	r0, #128	; 0x80
   1869a:	4e0e      	ldr	r6, [pc, #56]	; (186d4 <rtc_rf_calibration_rtc+0x7c>)
   1869c:	1b09      	subs	r1, r1, r4
   1869e:	0200      	lsls	r0, r0, #8
   186a0:	4088      	lsls	r0, r1
   186a2:	0029      	movs	r1, r5
   186a4:	f7e8 f81e 	bl	6e4 <__aeabi_lmul>
   186a8:	69b2      	ldr	r2, [r6, #24]
   186aa:	002b      	movs	r3, r5
   186ac:	40e2      	lsrs	r2, r4
   186ae:	f7e7 fff9 	bl	6a4 <__aeabi_uldivmod>
   186b2:	6933      	ldr	r3, [r6, #16]
   186b4:	6974      	ldr	r4, [r6, #20]
   186b6:	18c0      	adds	r0, r0, r3
   186b8:	4161      	adcs	r1, r4

        current_time_info.rtc_time_ticks_of_last_update = rtc_time_ticks_at_call;
   186ba:	9b00      	ldr	r3, [sp, #0]
   186bc:	9c01      	ldr	r4, [sp, #4]
        current_time_info.adjusted_rtc_ticks += ((elapsed_rtc_time * (((uint32)CLOCKS_REFERENCE_CLOCK_FREQ) << (16U - downshift))) / (current_time_info.current_rtc_freq >> downshift)); //lint !e647
   186be:	6130      	str	r0, [r6, #16]
   186c0:	6171      	str	r1, [r6, #20]
        current_time_info.rtc_time_ticks_of_last_update = rtc_time_ticks_at_call;
   186c2:	6033      	str	r3, [r6, #0]
   186c4:	6074      	str	r4, [r6, #4]
    } 

    current_time_info.current_rtc_freq          = rtc_freq_calibrated_by_rf;
   186c6:	4b03      	ldr	r3, [pc, #12]	; (186d4 <rtc_rf_calibration_rtc+0x7c>)
   186c8:	619f      	str	r7, [r3, #24]
}
   186ca:	bdf7      	pop	{r0, r1, r2, r4, r5, r6, r7, pc}
            downshift++;
   186cc:	3401      	adds	r4, #1
            elapsed_rtc_time_shifted >>= 1U;
   186ce:	086d      	lsrs	r5, r5, #1
            downshift++;
   186d0:	b2e4      	uxtb	r4, r4
   186d2:	e7de      	b.n	18692 <rtc_rf_calibration_rtc+0x3a>
   186d4:	01002ed8 	.word	0x01002ed8
   186d8:	010004b1 	.word	0x010004b1

000186dc <get_current_time_ms>:

uint64 get_current_time_ms(void)
{
   186dc:	b570      	push	{r4, r5, r6, lr}
    if(current_time_info.unix_time_of_last_update == 0)
   186de:	4c1a      	ldr	r4, [pc, #104]	; (18748 <get_current_time_ms+0x6c>)
   186e0:	68a0      	ldr	r0, [r4, #8]
   186e2:	68e1      	ldr	r1, [r4, #12]
   186e4:	0003      	movs	r3, r0
   186e6:	430b      	orrs	r3, r1
   186e8:	d029      	beq.n	1873e <get_current_time_ms+0x62>
    return hal_rtc_get_time();
   186ea:	4b18      	ldr	r3, [pc, #96]	; (1874c <get_current_time_ms+0x70>)
   186ec:	4798      	blx	r3
    }

    uint64 rtc_time_ticks_at_call = rtc_get_time();

    uint8  downshift                = 0;
    uint64 elapsed_rtc_time         = rtc_time_ticks_at_call - current_time_info.rtc_time_ticks_of_last_update;
   186ee:	0002      	movs	r2, r0
   186f0:	000b      	movs	r3, r1
   186f2:	6820      	ldr	r0, [r4, #0]
   186f4:	6861      	ldr	r1, [r4, #4]
   186f6:	1a12      	subs	r2, r2, r0
   186f8:	418b      	sbcs	r3, r1
    uint8  downshift                = 0;
   186fa:	2500      	movs	r5, #0
    uint64 elapsed_rtc_time_shifted = elapsed_rtc_time;
   186fc:	001e      	movs	r6, r3

    while(elapsed_rtc_time_shifted >= MAX_RTC_TICKS_SHIFTED_DOWN_TEN)
   186fe:	2e00      	cmp	r6, #0
   18700:	d11e      	bne.n	18740 <get_current_time_ms+0x64>
    {
        elapsed_rtc_time_shifted >>= 1U;
        downshift++;
    }

    uint64 total_adjusted_rtc_tickets = current_time_info.adjusted_rtc_ticks + ((elapsed_rtc_time * (((uint32)CLOCKS_REFERENCE_CLOCK_FREQ) << (16U - downshift))) / (current_time_info.current_rtc_freq >> downshift)); //lint !e647
   18702:	2110      	movs	r1, #16
   18704:	2080      	movs	r0, #128	; 0x80
   18706:	1b49      	subs	r1, r1, r5
   18708:	0200      	lsls	r0, r0, #8
   1870a:	4088      	lsls	r0, r1
   1870c:	0031      	movs	r1, r6
   1870e:	f7e7 ffe9 	bl	6e4 <__aeabi_lmul>
   18712:	69a2      	ldr	r2, [r4, #24]
   18714:	0033      	movs	r3, r6
   18716:	40ea      	lsrs	r2, r5
   18718:	f7e7 ffc4 	bl	6a4 <__aeabi_uldivmod>
   1871c:	6922      	ldr	r2, [r4, #16]
   1871e:	6963      	ldr	r3, [r4, #20]
   18720:	1880      	adds	r0, r0, r2
   18722:	4159      	adcs	r1, r3

    // current time + increase rtc ticks / rtc frequency
    return current_time_info.unix_time_of_last_update + (total_adjusted_rtc_tickets * 1000U) / CLOCKS_REFERENCE_CLOCK_FREQ;
   18724:	22fa      	movs	r2, #250	; 0xfa
   18726:	2300      	movs	r3, #0
   18728:	0092      	lsls	r2, r2, #2
   1872a:	f7e7 ffdb 	bl	6e4 <__aeabi_lmul>
   1872e:	044d      	lsls	r5, r1, #17
   18730:	0bc2      	lsrs	r2, r0, #15
   18732:	0bcb      	lsrs	r3, r1, #15
   18734:	432a      	orrs	r2, r5
   18736:	68a0      	ldr	r0, [r4, #8]
   18738:	68e1      	ldr	r1, [r4, #12]
   1873a:	1880      	adds	r0, r0, r2
   1873c:	4159      	adcs	r1, r3
}
   1873e:	bd70      	pop	{r4, r5, r6, pc}
        downshift++;
   18740:	3501      	adds	r5, #1
        elapsed_rtc_time_shifted >>= 1U;
   18742:	0876      	lsrs	r6, r6, #1
        downshift++;
   18744:	b2ed      	uxtb	r5, r5
   18746:	e7da      	b.n	186fe <get_current_time_ms+0x22>
   18748:	01002ed8 	.word	0x01002ed8
   1874c:	010004b1 	.word	0x010004b1

00018750 <get_current_time>:

time_t get_current_time(void)
{
   18750:	b510      	push	{r4, lr}
    return (time_t)(get_current_time_ms() / RTC_MS_IN_SECOND);
   18752:	f7ff ffc3 	bl	186dc <get_current_time_ms>
   18756:	22fa      	movs	r2, #250	; 0xfa
   18758:	2300      	movs	r3, #0
   1875a:	0092      	lsls	r2, r2, #2
   1875c:	f7e7 ffa2 	bl	6a4 <__aeabi_uldivmod>
}
   18760:	bd10      	pop	{r4, pc}
	...

00018764 <rtc_get_daylight_saving_time>:

uint8 rtc_get_daylight_saving_time(void)
{
    return current_time_info.daylight_saving_time;
   18764:	4b01      	ldr	r3, [pc, #4]	; (1876c <rtc_get_daylight_saving_time+0x8>)
   18766:	7f58      	ldrb	r0, [r3, #29]
}
   18768:	4770      	bx	lr
   1876a:	46c0      	nop			; (mov r8, r8)
   1876c:	01002ed8 	.word	0x01002ed8

00018770 <rtc_get_time_zone>:

int8 rtc_get_time_zone(void)
{
    return current_time_info.current_time_zone;
   18770:	201c      	movs	r0, #28
   18772:	4b01      	ldr	r3, [pc, #4]	; (18778 <rtc_get_time_zone+0x8>)
   18774:	5618      	ldrsb	r0, [r3, r0]
}
   18776:	4770      	bx	lr
   18778:	01002ed8 	.word	0x01002ed8

0001877c <system_status_init>:
/*
 *  Public function definitions
 */

void system_status_init(void)
{
   1877c:	b510      	push	{r4, lr}
    if (non_os_is_driver_initialised(DRIVER_INIT_SYS_STATUS) == true)
   1877e:	2006      	movs	r0, #6
   18780:	f7ff fd40 	bl	18204 <non_os_is_driver_initialised>
   18784:	2800      	cmp	r0, #0
   18786:	d10a      	bne.n	1879e <system_status_init+0x22>
    {
        return;
    }
    system_status_flash_write_vetos = 0;
   18788:	4b05      	ldr	r3, [pc, #20]	; (187a0 <system_status_init+0x24>)
    system_status.core.expected_wake_time = 0;
   1878a:	2100      	movs	r1, #0
    system_status_flash_write_vetos = 0;
   1878c:	7018      	strb	r0, [r3, #0]
    system_status.core.expected_wake_time = 0;
   1878e:	2000      	movs	r0, #0
   18790:	4b04      	ldr	r3, [pc, #16]	; (187a4 <system_status_init+0x28>)
   18792:	6198      	str	r0, [r3, #24]
   18794:	61d9      	str	r1, [r3, #28]
    non_os_set_driver_initalised(DRIVER_INIT_SYS_STATUS, true);
   18796:	2101      	movs	r1, #1
   18798:	3006      	adds	r0, #6
   1879a:	f7ff fd3d 	bl	18218 <non_os_set_driver_initalised>
}
   1879e:	bd10      	pop	{r4, pc}
   187a0:	01002a0c 	.word	0x01002a0c
   187a4:	0100fee0 	.word	0x0100fee0

000187a8 <system_status_system_starting>:
 * This is a special function that gets called before main has started.
 * It either returns because we have passed the locks, or we got ignored.
 * This should only happen if we were talking to a old security core image
 */
uint16 system_status_system_starting( void )
{
   187a8:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    uint64 rtc_time;
    system_status_enter_critical();
   187aa:	4d15      	ldr	r5, [pc, #84]	; (18800 <system_status_system_starting+0x58>)
   187ac:	47a8      	blx	r5
    system_status.core.status_flags |= SYSTEM_STATUS_FLAG_REBOOT_MASK;
   187ae:	2380      	movs	r3, #128	; 0x80
   187b0:	4c14      	ldr	r4, [pc, #80]	; (18804 <system_status_system_starting+0x5c>)
   187b2:	061b      	lsls	r3, r3, #24
   187b4:	6962      	ldr	r2, [r4, #20]
    system_status_exit_critical();

    rtc_time = rtc_get_time_ms() + 0xffffffff;
   187b6:	2601      	movs	r6, #1
    system_status.core.status_flags |= SYSTEM_STATUS_FLAG_REBOOT_MASK;
   187b8:	4313      	orrs	r3, r2
   187ba:	6163      	str	r3, [r4, #20]
    system_status_exit_critical();
   187bc:	4b12      	ldr	r3, [pc, #72]	; (18808 <system_status_system_starting+0x60>)
   187be:	4798      	blx	r3
    rtc_time = rtc_get_time_ms() + 0xffffffff;
   187c0:	2700      	movs	r7, #0
   187c2:	f7ff ff1f 	bl	18604 <rtc_get_time_ms>
   187c6:	4276      	negs	r6, r6
   187c8:	1836      	adds	r6, r6, r0
   187ca:	414f      	adcs	r7, r1
    while ((system_status.security.status_flags & SYSTEM_STATUS_FLAG_REBOOT_MASK) == 0)
   187cc:	68a3      	ldr	r3, [r4, #8]
   187ce:	2b00      	cmp	r3, #0
   187d0:	da0c      	bge.n	187ec <system_status_system_starting+0x44>
        {
            return 0;
        }
    }

    system_status_enter_critical();
   187d2:	47a8      	blx	r5
    system_status.core.status_flags &= (~SYSTEM_STATUS_FLAG_REBOOT_MASK);
   187d4:	6963      	ldr	r3, [r4, #20]
   187d6:	005b      	lsls	r3, r3, #1
   187d8:	085b      	lsrs	r3, r3, #1
   187da:	6163      	str	r3, [r4, #20]
    system_status_exit_critical();
   187dc:	4b0a      	ldr	r3, [pc, #40]	; (18808 <system_status_system_starting+0x60>)
   187de:	4798      	blx	r3
    while ((system_status.security.status_flags & SYSTEM_STATUS_FLAG_REBOOT_MASK) > 0)
   187e0:	68a3      	ldr	r3, [r4, #8]
   187e2:	2b00      	cmp	r3, #0
   187e4:	dbfc      	blt.n	187e0 <system_status_system_starting+0x38>
    {
        //If we got past the first section then we have the attention of the security core,
        //so we can assume that it will respond to us
    }
    return (uint16)system_status.security.reserved_1;
   187e6:	68e0      	ldr	r0, [r4, #12]
   187e8:	b280      	uxth	r0, r0
}
   187ea:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
        if (rtc_get_time_ms() > rtc_time)
   187ec:	f7ff ff0a 	bl	18604 <rtc_get_time_ms>
   187f0:	42b9      	cmp	r1, r7
   187f2:	d802      	bhi.n	187fa <system_status_system_starting+0x52>
   187f4:	d1ea      	bne.n	187cc <system_status_system_starting+0x24>
   187f6:	42b0      	cmp	r0, r6
   187f8:	d9e8      	bls.n	187cc <system_status_system_starting+0x24>
            return 0;
   187fa:	2000      	movs	r0, #0
   187fc:	e7f5      	b.n	187ea <system_status_system_starting+0x42>
   187fe:	46c0      	nop			; (mov r8, r8)
   18800:	01000421 	.word	0x01000421
   18804:	0100fee0 	.word	0x0100fee0
   18808:	0100043d 	.word	0x0100043d

0001880c <system_status_set_expected_wake_time>:
    non_os_exit_critical();
}

void system_status_set_expected_wake_time( uint64 wake_time )
{
    system_status.core.expected_wake_time = wake_time;
   1880c:	4b01      	ldr	r3, [pc, #4]	; (18814 <system_status_set_expected_wake_time+0x8>)
   1880e:	6198      	str	r0, [r3, #24]
   18810:	61d9      	str	r1, [r3, #28]
}
   18812:	4770      	bx	lr
   18814:	0100fee0 	.word	0x0100fee0

00018818 <watchdog_init>:
//lint -esym(714, watchdog_enable)
//lint -esym(714, watchdog_disable)
//lint -esym(714, watchdog_get_time)

void watchdog_init(uint32 interval_clock_cycles, bool monitor_arm_sleep_deep, bool nmi_on_first_fire)
{
   18818:	4b08      	ldr	r3, [pc, #32]	; (1883c <watchdog_init+0x24>)
#ifdef WATCHDOG_MOCKED
    nmi_on_first_fire = true;
#endif

    watchdog_flags = 0;
    if (monitor_arm_sleep_deep)
   1881a:	2900      	cmp	r1, #0
   1881c:	d10c      	bne.n	18838 <watchdog_init+0x20>
    {
        watchdog_flags |= WATCHDOG_MONITOR_SLEEP;
   1881e:	7019      	strb	r1, [r3, #0]
    }

    if (nmi_on_first_fire)
   18820:	2a00      	cmp	r2, #0
   18822:	d003      	beq.n	1882c <watchdog_init+0x14>
    {
        watchdog_flags |= WATHCDOG_NMI_FIRST;
   18824:	2202      	movs	r2, #2
   18826:	7819      	ldrb	r1, [r3, #0]
   18828:	430a      	orrs	r2, r1
   1882a:	701a      	strb	r2, [r3, #0]
    }
    watchdog_interval = interval_clock_cycles;
    watchdog_inited   = true;
   1882c:	2201      	movs	r2, #1
    watchdog_interval = interval_clock_cycles;
   1882e:	4b04      	ldr	r3, [pc, #16]	; (18840 <watchdog_init+0x28>)
   18830:	6018      	str	r0, [r3, #0]
    watchdog_inited   = true;
   18832:	4b04      	ldr	r3, [pc, #16]	; (18844 <watchdog_init+0x2c>)
   18834:	701a      	strb	r2, [r3, #0]
}
   18836:	4770      	bx	lr
        watchdog_flags |= WATCHDOG_MONITOR_SLEEP;
   18838:	2101      	movs	r1, #1
   1883a:	e7f0      	b.n	1881e <watchdog_init+0x6>
   1883c:	01002a0d 	.word	0x01002a0d
   18840:	01002a10 	.word	0x01002a10
   18844:	01002a0e 	.word	0x01002a0e

00018848 <watchdog_enable>:

    watchdog_init(interval_clock_cycles, monitor_arm_sleep_deep, nmi_on_first_fire);
}

void watchdog_enable(void)
{
   18848:	b510      	push	{r4, lr}
    if (!watchdog_inited)
   1884a:	4b0e      	ldr	r3, [pc, #56]	; (18884 <watchdog_enable+0x3c>)
   1884c:	781b      	ldrb	r3, [r3, #0]
   1884e:	2b00      	cmp	r3, #0
   18850:	d017      	beq.n	18882 <watchdog_enable+0x3a>
    {
        return;
    }

    hal_watchdog_stop();
   18852:	2351      	movs	r3, #81	; 0x51
    hal_watchdog_set_interval(watchdog_interval);
    hal_watchdog_enable(WATCHDOG_FLAG_TO_BOOL(watchdog_flags, WATCHDOG_MONITOR_SLEEP),
   18854:	24fc      	movs	r4, #252	; 0xfc
    hal_watchdog_stop();
   18856:	490c      	ldr	r1, [pc, #48]	; (18888 <watchdog_enable+0x40>)
    hal_watchdog_enable(WATCHDOG_FLAG_TO_BOOL(watchdog_flags, WATCHDOG_MONITOR_SLEEP),
   18858:	0224      	lsls	r4, r4, #8
    hal_watchdog_stop();
   1885a:	600b      	str	r3, [r1, #0]
    hal_watchdog_set_interval(watchdog_interval);
   1885c:	4b0b      	ldr	r3, [pc, #44]	; (1888c <watchdog_enable+0x44>)
   1885e:	681a      	ldr	r2, [r3, #0]
   18860:	4b0b      	ldr	r3, [pc, #44]	; (18890 <watchdog_enable+0x48>)
   18862:	601a      	str	r2, [r3, #0]
    hal_watchdog_enable(WATCHDOG_FLAG_TO_BOOL(watchdog_flags, WATCHDOG_MONITOR_SLEEP),
   18864:	4b0b      	ldr	r3, [pc, #44]	; (18894 <watchdog_enable+0x4c>)
   18866:	6808      	ldr	r0, [r1, #0]
   18868:	781a      	ldrb	r2, [r3, #0]
   1886a:	2301      	movs	r3, #1
   1886c:	4004      	ands	r4, r0
   1886e:	20ab      	movs	r0, #171	; 0xab
   18870:	4013      	ands	r3, r2
   18872:	0792      	lsls	r2, r2, #30
   18874:	021b      	lsls	r3, r3, #8
   18876:	4320      	orrs	r0, r4
   18878:	0fd2      	lsrs	r2, r2, #31
   1887a:	0252      	lsls	r2, r2, #9
   1887c:	4303      	orrs	r3, r0
   1887e:	4313      	orrs	r3, r2
   18880:	600b      	str	r3, [r1, #0]
                        WATCHDOG_FLAG_TO_BOOL(watchdog_flags, WATHCDOG_NMI_FIRST));
}
   18882:	bd10      	pop	{r4, pc}
   18884:	01002a0e 	.word	0x01002a0e
   18888:	40004018 	.word	0x40004018
   1888c:	01002a10 	.word	0x01002a10
   18890:	40004014 	.word	0x40004014
   18894:	01002a0d 	.word	0x01002a0d

00018898 <watchdog_kick>:

void watchdog_kick(void)
{
    if (!watchdog_inited)
   18898:	4b06      	ldr	r3, [pc, #24]	; (188b4 <watchdog_kick+0x1c>)
   1889a:	781b      	ldrb	r3, [r3, #0]
   1889c:	2b00      	cmp	r3, #0
   1889e:	d007      	beq.n	188b0 <watchdog_kick+0x18>
    {
        return;
    }

    hal_watchdog_kick();
   188a0:	22ff      	movs	r2, #255	; 0xff
   188a2:	4905      	ldr	r1, [pc, #20]	; (188b8 <watchdog_kick+0x20>)
   188a4:	0212      	lsls	r2, r2, #8
   188a6:	680b      	ldr	r3, [r1, #0]
   188a8:	401a      	ands	r2, r3
   188aa:	23c7      	movs	r3, #199	; 0xc7
   188ac:	4313      	orrs	r3, r2
   188ae:	600b      	str	r3, [r1, #0]
}
   188b0:	4770      	bx	lr
   188b2:	46c0      	nop			; (mov r8, r8)
   188b4:	01002a0e 	.word	0x01002a0e
   188b8:	40004018 	.word	0x40004018

000188bc <watchdog_disable>:

void watchdog_disable(void)
{
    if (!watchdog_inited)
   188bc:	4b03      	ldr	r3, [pc, #12]	; (188cc <watchdog_disable+0x10>)
   188be:	781b      	ldrb	r3, [r3, #0]
   188c0:	2b00      	cmp	r3, #0
   188c2:	d002      	beq.n	188ca <watchdog_disable+0xe>
    {
        return;
    }

    hal_watchdog_stop();
   188c4:	2251      	movs	r2, #81	; 0x51
   188c6:	4b02      	ldr	r3, [pc, #8]	; (188d0 <watchdog_disable+0x14>)
   188c8:	601a      	str	r2, [r3, #0]
}
   188ca:	4770      	bx	lr
   188cc:	01002a0e 	.word	0x01002a0e
   188d0:	40004018 	.word	0x40004018

000188d4 <watchdog_get_time>:
    watchdog_flags = 0;
}

uint32 watchdog_get_time(void)
{
    uint32 watchdog_time = hal_watchdog_get_time();
   188d4:	4b02      	ldr	r3, [pc, #8]	; (188e0 <watchdog_get_time+0xc>)
   188d6:	6818      	ldr	r0, [r3, #0]
    if (watchdog_time == 0)
   188d8:	2800      	cmp	r0, #0
   188da:	d100      	bne.n	188de <watchdog_get_time+0xa>
    {
        //Watchdog must be disabled, return max time
        return UINT32_MAX;
   188dc:	3801      	subs	r0, #1
    }
    return watchdog_time;
}
   188de:	4770      	bx	lr
   188e0:	4000401c 	.word	0x4000401c

000188e4 <hal_gpio_config_dir>:
#include "hal_pio_ex.h"
#include <assert.h>


void hal_gpio_config_dir( PIN pin, GPIO_DIRECTION dir )
{
   188e4:	b510      	push	{r4, lr}
    if( dir == GPIO_DIRECTION_OUTPUT )
   188e6:	2901      	cmp	r1, #1
   188e8:	d102      	bne.n	188f0 <hal_gpio_config_dir+0xc>
    {
        hal_pio_set_gpio_direction( pin, HAL_PIO_GPIO_DIR_OUT );
    }
    else
    {
        hal_pio_set_gpio_direction( pin, HAL_PIO_GPIO_DIR_IN );
   188ea:	f000 f8af 	bl	18a4c <hal_pio_set_gpio_direction>
    }
}
   188ee:	bd10      	pop	{r4, pc}
        hal_pio_set_gpio_direction( pin, HAL_PIO_GPIO_DIR_IN );
   188f0:	2100      	movs	r1, #0
   188f2:	e7fa      	b.n	188ea <hal_gpio_config_dir+0x6>

000188f4 <hal_gpio_set>:

void hal_gpio_set( PIN pin )
{
   188f4:	b510      	push	{r4, lr}
    hal_pio_set_gpio_output( pin, HAL_PIO_GPIO_LVL_HIGH );
   188f6:	2101      	movs	r1, #1
   188f8:	f000 f8c4 	bl	18a84 <hal_pio_set_gpio_output>
}
   188fc:	bd10      	pop	{r4, pc}

000188fe <hal_gpio_clear>:

void hal_gpio_clear( PIN pin )
{
   188fe:	b510      	push	{r4, lr}
    hal_pio_set_gpio_output( pin, HAL_PIO_GPIO_LVL_LOW );
   18900:	2100      	movs	r1, #0
   18902:	f000 f8bf 	bl	18a84 <hal_pio_set_gpio_output>
}
   18906:	bd10      	pop	{r4, pc}

00018908 <hal_gpio_disable_all_interrupts>:
    }
}

void hal_gpio_disable_all_interrupts( PIN pin )
{
    hal_pio_set_interrupt( pin, HAL_PIO_INTERRUPT_RISING, INTERRUPT_STATE_DISABLED );
   18908:	2200      	movs	r2, #0
{
   1890a:	b510      	push	{r4, lr}
   1890c:	0004      	movs	r4, r0
    hal_pio_set_interrupt( pin, HAL_PIO_INTERRUPT_RISING, INTERRUPT_STATE_DISABLED );
   1890e:	0011      	movs	r1, r2
   18910:	f000 f900 	bl	18b14 <hal_pio_set_interrupt>
    hal_pio_set_interrupt( pin, HAL_PIO_INTERRUPT_FALLING, INTERRUPT_STATE_DISABLED );
   18914:	0020      	movs	r0, r4
   18916:	2200      	movs	r2, #0
   18918:	2101      	movs	r1, #1
   1891a:	f000 f8fb 	bl	18b14 <hal_pio_set_interrupt>
    hal_pio_set_interrupt( pin, HAL_PIO_INTERRUPT_HIGH, INTERRUPT_STATE_DISABLED );
   1891e:	0020      	movs	r0, r4
   18920:	2200      	movs	r2, #0
   18922:	2102      	movs	r1, #2
   18924:	f000 f8f6 	bl	18b14 <hal_pio_set_interrupt>
    hal_pio_set_interrupt( pin, HAL_PIO_INTERRUPT_LOW, INTERRUPT_STATE_DISABLED );
   18928:	2200      	movs	r2, #0
   1892a:	2103      	movs	r1, #3
   1892c:	0020      	movs	r0, r4
   1892e:	f000 f8f1 	bl	18b14 <hal_pio_set_interrupt>
}
   18932:	bd10      	pop	{r4, pc}

00018934 <hal_gpio_clear_interrupt>:

void hal_gpio_clear_interrupt( PIN pin )
{
   18934:	b510      	push	{r4, lr}
    hal_pio_clear_interrupt( pin );
   18936:	f000 f8e3 	bl	18b00 <hal_pio_clear_interrupt>
}
   1893a:	bd10      	pop	{r4, pc}

0001893c <hal_gpio_is_interrupt_asserted>:

bool hal_gpio_is_interrupt_asserted( PIN pin )
{
   1893c:	b510      	push	{r4, lr}
    return hal_pio_is_interrupt_asserted( pin );
   1893e:	f000 f8c7 	bl	18ad0 <hal_pio_is_interrupt_asserted>
}
   18942:	bd10      	pop	{r4, pc}

00018944 <hal_pio_init>:
/*
 * Initialisation function for the hal_pio
 */
void hal_pio_init( void )
{ // added for consistency
}
   18944:	4770      	bx	lr
	...

00018948 <hal_pio_release_all>:

/*
 * Release the claims to every owned pio.
 */
void hal_pio_release_all( void )
{
   18948:	2300      	movs	r3, #0
    for( PIN pin = PIN_0; pin < PIN_MAX_NUMBER; pin++ )
    {   // Will only release claim if the calling core actually owns the peripheral
        hal_pio_registers[ pin ].pio_claim = 0;
   1894a:	0018      	movs	r0, r3
   1894c:	4a03      	ldr	r2, [pc, #12]	; (1895c <hal_pio_release_all+0x14>)
   1894e:	0199      	lsls	r1, r3, #6
   18950:	3301      	adds	r3, #1
   18952:	5088      	str	r0, [r1, r2]
    for( PIN pin = PIN_0; pin < PIN_MAX_NUMBER; pin++ )
   18954:	2b28      	cmp	r3, #40	; 0x28
   18956:	d1fa      	bne.n	1894e <hal_pio_release_all+0x6>
    }
}
   18958:	4770      	bx	lr
   1895a:	46c0      	nop			; (mov r8, r8)
   1895c:	40001000 	.word	0x40001000

00018960 <hal_pio_release>:
/*
 * Release a specific pio.
 */
void hal_pio_release( PIN pin )
{
    if( pin < PIN_MAX_NUMBER )
   18960:	2827      	cmp	r0, #39	; 0x27
   18962:	d803      	bhi.n	1896c <hal_pio_release+0xc>
    {   // Will only release claim if the calling core actually owns the peripheral
        hal_pio_registers[ pin ].pio_claim = 0;
   18964:	2200      	movs	r2, #0
   18966:	4b02      	ldr	r3, [pc, #8]	; (18970 <hal_pio_release+0x10>)
   18968:	0180      	lsls	r0, r0, #6
   1896a:	50c2      	str	r2, [r0, r3]
    }
}
   1896c:	4770      	bx	lr
   1896e:	46c0      	nop			; (mov r8, r8)
   18970:	40001000 	.word	0x40001000

00018974 <hal_pio_set_function>:

/*
 * Claim a PIN (if it is unclaimed) and assign a specific function to it.
 */
bool hal_pio_set_function( PIN pin, FUNC function )
{
   18974:	b530      	push	{r4, r5, lr}
            // if the higher priority core ever releases its claim
            hal_pio_registers[ pin ].pio_claim = 0;
        }
    }

    return false;
   18976:	2200      	movs	r2, #0
    if( (pin < PIN_MAX_NUMBER) && (function < FUNC_MAX) )
   18978:	2827      	cmp	r0, #39	; 0x27
   1897a:	d814      	bhi.n	189a6 <hal_pio_set_function+0x32>
   1897c:	29dd      	cmp	r1, #221	; 0xdd
   1897e:	d812      	bhi.n	189a6 <hal_pio_set_function+0x32>
        if( (hal_pio_registers[ pin ].pio_claim & (HAL_PIO_CLAIM_IS_CLAIMED | HAL_PIO_CLAIM_IS_BEING_CLAIMED)) == 0 )
   18980:	0183      	lsls	r3, r0, #6
   18982:	2077      	movs	r0, #119	; 0x77
   18984:	4c0a      	ldr	r4, [pc, #40]	; (189b0 <hal_pio_set_function+0x3c>)
   18986:	591d      	ldr	r5, [r3, r4]
   18988:	4205      	tst	r5, r0
   1898a:	d10c      	bne.n	189a6 <hal_pio_set_function+0x32>
            hal_pio_registers[ pin ].pio_claim = HAL_PIO_CLAIM_REQUEST;
   1898c:	3201      	adds	r2, #1
   1898e:	511a      	str	r2, [r3, r4]
            while( ( hal_pio_registers[ pin ].pio_claim & HAL_PIO_CLAIM_IS_CLAIMED) == 0 )
   18990:	3206      	adds	r2, #6
   18992:	58e0      	ldr	r0, [r4, r3]
   18994:	4210      	tst	r0, r2
   18996:	d0fc      	beq.n	18992 <hal_pio_set_function+0x1e>
            if( hal_pio_registers[ pin ].pio_claim & HAL_PIO_CLAIM_OWNER_APPS )
   18998:	2004      	movs	r0, #4
   1899a:	58e2      	ldr	r2, [r4, r3]
   1899c:	4002      	ands	r2, r0
   1899e:	d004      	beq.n	189aa <hal_pio_set_function+0x36>
                return true;
   189a0:	2201      	movs	r2, #1
                hal_pio_registers[ pin ].pio_ctrl = function;
   189a2:	18e3      	adds	r3, r4, r3
   189a4:	6059      	str	r1, [r3, #4]
}
   189a6:	0010      	movs	r0, r2
   189a8:	bd30      	pop	{r4, r5, pc}
            hal_pio_registers[ pin ].pio_claim = 0;
   189aa:	50e2      	str	r2, [r4, r3]
   189ac:	e7fb      	b.n	189a6 <hal_pio_set_function+0x32>
   189ae:	46c0      	nop			; (mov r8, r8)
   189b0:	40001000 	.word	0x40001000

000189b4 <hal_pio_get_function>:

/*
 * Return the current functions assigned to the PIN pio.
 */
FUNC hal_pio_get_function( PIN pin )
{
   189b4:	0003      	movs	r3, r0
        {   // Owned by the core so obtain current function
            return ( FUNC )(hal_pio_registers[ pin ].pio_ctrl & HAL_PIO_CTRL_FUNC_MASK);
        }
    }

    return FUNC_UNCLAIMED;
   189b6:	2000      	movs	r0, #0
    if( pin < PIN_MAX_NUMBER )
   189b8:	2b27      	cmp	r3, #39	; 0x27
   189ba:	d807      	bhi.n	189cc <hal_pio_get_function+0x18>
        if( hal_pio_registers[ pin ].pio_claim & claim_mask )
   189bc:	4a04      	ldr	r2, [pc, #16]	; (189d0 <hal_pio_get_function+0x1c>)
   189be:	019b      	lsls	r3, r3, #6
   189c0:	5899      	ldr	r1, [r3, r2]
   189c2:	0749      	lsls	r1, r1, #29
   189c4:	d502      	bpl.n	189cc <hal_pio_get_function+0x18>
            return ( FUNC )(hal_pio_registers[ pin ].pio_ctrl & HAL_PIO_CTRL_FUNC_MASK);
   189c6:	18d3      	adds	r3, r2, r3
   189c8:	6858      	ldr	r0, [r3, #4]
   189ca:	b2c0      	uxtb	r0, r0
}
   189cc:	4770      	bx	lr
   189ce:	46c0      	nop			; (mov r8, r8)
   189d0:	40001000 	.word	0x40001000

000189d4 <hal_pio_config_drive>:
/*
 * Set the drive type for the pin.
 */
void hal_pio_config_drive( PIN pin, HAL_PIO_DRIVE drive )
{
    if( pin < PIN_MAX_NUMBER )
   189d4:	2827      	cmp	r0, #39	; 0x27
   189d6:	d809      	bhi.n	189ec <hal_pio_config_drive+0x18>
    {
        switch( drive )
   189d8:	2900      	cmp	r1, #0
   189da:	d008      	beq.n	189ee <hal_pio_config_drive+0x1a>
   189dc:	2901      	cmp	r1, #1
   189de:	d105      	bne.n	189ec <hal_pio_config_drive+0x18>
        {
        case HAL_PIO_DRIVE_HIGH:
            hal_pio_registers[ pin ].pio_ctrl_bitset = HAL_PIO_CTRL_DRIVE_ACTIVE;
   189e0:	4b06      	ldr	r3, [pc, #24]	; (189fc <hal_pio_config_drive+0x28>)
   189e2:	0180      	lsls	r0, r0, #6
   189e4:	1818      	adds	r0, r3, r0
   189e6:	2380      	movs	r3, #128	; 0x80
   189e8:	00db      	lsls	r3, r3, #3
   189ea:	6143      	str	r3, [r0, #20]

        default:
            break;
        }
    }
}
   189ec:	4770      	bx	lr
            hal_pio_registers[ pin ].pio_ctrl_bitclr = HAL_PIO_CTRL_DRIVE_ACTIVE;
   189ee:	4b03      	ldr	r3, [pc, #12]	; (189fc <hal_pio_config_drive+0x28>)
   189f0:	0180      	lsls	r0, r0, #6
   189f2:	1818      	adds	r0, r3, r0
   189f4:	2380      	movs	r3, #128	; 0x80
   189f6:	00db      	lsls	r3, r3, #3
   189f8:	6243      	str	r3, [r0, #36]	; 0x24
}
   189fa:	e7f7      	b.n	189ec <hal_pio_config_drive+0x18>
   189fc:	40001000 	.word	0x40001000

00018a00 <hal_pio_config_pull>:
/*
 * Set a pull down or not for the pio.
 */
void hal_pio_config_pull( PIN pin, HAL_PIO_PULL pull_type )
{
    if( pin < PIN_MAX_NUMBER )
   18a00:	2827      	cmp	r0, #39	; 0x27
   18a02:	d805      	bhi.n	18a10 <hal_pio_config_pull+0x10>
    {
        switch( pull_type )
   18a04:	2901      	cmp	r1, #1
   18a06:	d00e      	beq.n	18a26 <hal_pio_config_pull+0x26>
   18a08:	2900      	cmp	r1, #0
   18a0a:	d002      	beq.n	18a12 <hal_pio_config_pull+0x12>
   18a0c:	2902      	cmp	r1, #2
   18a0e:	d014      	beq.n	18a3a <hal_pio_config_pull+0x3a>

        default:
            break;
        }
    }
}
   18a10:	4770      	bx	lr
            hal_pio_registers[ pin ].pio_ctrl_bitclr = HAL_PIO_CTRL_PULL_ACTIVE;    // Disable pull
   18a12:	4b0d      	ldr	r3, [pc, #52]	; (18a48 <hal_pio_config_pull+0x48>)
   18a14:	0180      	lsls	r0, r0, #6
   18a16:	1818      	adds	r0, r3, r0
   18a18:	2380      	movs	r3, #128	; 0x80
   18a1a:	011b      	lsls	r3, r3, #4
   18a1c:	6243      	str	r3, [r0, #36]	; 0x24
            hal_pio_registers[ pin ].pio_ctrl_bitclr = HAL_PIO_CTRL_PULL_UP;        // Reset pull type
   18a1e:	2380      	movs	r3, #128	; 0x80
   18a20:	015b      	lsls	r3, r3, #5
   18a22:	6243      	str	r3, [r0, #36]	; 0x24
            break;
   18a24:	e7f4      	b.n	18a10 <hal_pio_config_pull+0x10>
            hal_pio_registers[ pin ].pio_ctrl_bitclr = HAL_PIO_CTRL_PULL_UP;        // Set pull type
   18a26:	4b08      	ldr	r3, [pc, #32]	; (18a48 <hal_pio_config_pull+0x48>)
   18a28:	0180      	lsls	r0, r0, #6
   18a2a:	1818      	adds	r0, r3, r0
   18a2c:	2380      	movs	r3, #128	; 0x80
   18a2e:	015b      	lsls	r3, r3, #5
   18a30:	6243      	str	r3, [r0, #36]	; 0x24
            hal_pio_registers[ pin ].pio_ctrl_bitset = HAL_PIO_CTRL_PULL_ACTIVE;    // Enable pull
   18a32:	2380      	movs	r3, #128	; 0x80
   18a34:	011b      	lsls	r3, r3, #4
   18a36:	6143      	str	r3, [r0, #20]
}
   18a38:	e7ea      	b.n	18a10 <hal_pio_config_pull+0x10>
            hal_pio_registers[ pin ].pio_ctrl_bitset = HAL_PIO_CTRL_PULL_UP;        // Set pull type
   18a3a:	4b03      	ldr	r3, [pc, #12]	; (18a48 <hal_pio_config_pull+0x48>)
   18a3c:	0180      	lsls	r0, r0, #6
   18a3e:	1818      	adds	r0, r3, r0
   18a40:	2380      	movs	r3, #128	; 0x80
   18a42:	015b      	lsls	r3, r3, #5
   18a44:	6143      	str	r3, [r0, #20]
   18a46:	e7f4      	b.n	18a32 <hal_pio_config_pull+0x32>
   18a48:	40001000 	.word	0x40001000

00018a4c <hal_pio_set_gpio_direction>:

/*
 * Set GPIO input/output direction
 */
void hal_pio_set_gpio_direction( PIN pin, HAL_PIO_GPIO_DIR dir )
{
   18a4c:	b570      	push	{r4, r5, r6, lr}
   18a4e:	0004      	movs	r4, r0
   18a50:	000d      	movs	r5, r1
    if( hal_pio_get_function( pin ) == FUNC_GPIO )
   18a52:	f7ff ffaf 	bl	189b4 <hal_pio_get_function>
   18a56:	2801      	cmp	r0, #1
   18a58:	d103      	bne.n	18a62 <hal_pio_set_gpio_direction+0x16>
    {
        switch( dir )
   18a5a:	2d00      	cmp	r5, #0
   18a5c:	d002      	beq.n	18a64 <hal_pio_set_gpio_direction+0x18>
   18a5e:	2d01      	cmp	r5, #1
   18a60:	d007      	beq.n	18a72 <hal_pio_set_gpio_direction+0x26>

        default:
            break;
        }
    }
}
   18a62:	bd70      	pop	{r4, r5, r6, pc}
            hal_pio_registers[ pin ].pio_ctrl_bitclr = HAL_PIO_CTRL_GPIO_DIR;
   18a64:	4b06      	ldr	r3, [pc, #24]	; (18a80 <hal_pio_set_gpio_direction+0x34>)
   18a66:	01a4      	lsls	r4, r4, #6
   18a68:	191c      	adds	r4, r3, r4
   18a6a:	2380      	movs	r3, #128	; 0x80
   18a6c:	005b      	lsls	r3, r3, #1
   18a6e:	6263      	str	r3, [r4, #36]	; 0x24
            break;
   18a70:	e7f7      	b.n	18a62 <hal_pio_set_gpio_direction+0x16>
            hal_pio_registers[ pin ].pio_ctrl_bitset = HAL_PIO_CTRL_GPIO_DIR;
   18a72:	4b03      	ldr	r3, [pc, #12]	; (18a80 <hal_pio_set_gpio_direction+0x34>)
   18a74:	01a4      	lsls	r4, r4, #6
   18a76:	191c      	adds	r4, r3, r4
   18a78:	2380      	movs	r3, #128	; 0x80
   18a7a:	005b      	lsls	r3, r3, #1
   18a7c:	6163      	str	r3, [r4, #20]
}
   18a7e:	e7f0      	b.n	18a62 <hal_pio_set_gpio_direction+0x16>
   18a80:	40001000 	.word	0x40001000

00018a84 <hal_pio_set_gpio_output>:

/*
 * Set output level for a GPIO
 */
void hal_pio_set_gpio_output( PIN pin, HAL_PIO_GPIO_LVL level )
{
   18a84:	b570      	push	{r4, r5, r6, lr}
   18a86:	0004      	movs	r4, r0
   18a88:	000d      	movs	r5, r1
    if( hal_pio_get_function( pin ) == FUNC_GPIO )
   18a8a:	f7ff ff93 	bl	189b4 <hal_pio_get_function>
   18a8e:	2801      	cmp	r0, #1
   18a90:	d105      	bne.n	18a9e <hal_pio_set_gpio_output+0x1a>
    {
        switch( level )
   18a92:	2d01      	cmp	r5, #1
   18a94:	d00b      	beq.n	18aae <hal_pio_set_gpio_output+0x2a>
   18a96:	2d00      	cmp	r5, #0
   18a98:	d002      	beq.n	18aa0 <hal_pio_set_gpio_output+0x1c>
   18a9a:	2d02      	cmp	r5, #2
   18a9c:	d00e      	beq.n	18abc <hal_pio_set_gpio_output+0x38>

        default:
            break;
        }
    }
}
   18a9e:	bd70      	pop	{r4, r5, r6, pc}
            hal_pio_registers[ pin ].pio_ctrl_bitclr = HAL_PIO_CTRL_GPIO_OUT;
   18aa0:	4b0a      	ldr	r3, [pc, #40]	; (18acc <hal_pio_set_gpio_output+0x48>)
   18aa2:	01a4      	lsls	r4, r4, #6
   18aa4:	191c      	adds	r4, r3, r4
   18aa6:	2380      	movs	r3, #128	; 0x80
   18aa8:	009b      	lsls	r3, r3, #2
   18aaa:	6263      	str	r3, [r4, #36]	; 0x24
            break;
   18aac:	e7f7      	b.n	18a9e <hal_pio_set_gpio_output+0x1a>
            hal_pio_registers[ pin ].pio_ctrl_bitset = HAL_PIO_CTRL_GPIO_OUT;
   18aae:	4b07      	ldr	r3, [pc, #28]	; (18acc <hal_pio_set_gpio_output+0x48>)
   18ab0:	01a4      	lsls	r4, r4, #6
   18ab2:	191c      	adds	r4, r3, r4
   18ab4:	2380      	movs	r3, #128	; 0x80
   18ab6:	009b      	lsls	r3, r3, #2
   18ab8:	6163      	str	r3, [r4, #20]
            break;
   18aba:	e7f0      	b.n	18a9e <hal_pio_set_gpio_output+0x1a>
            hal_pio_registers[ pin ].pio_ctrl_bittog = HAL_PIO_CTRL_GPIO_OUT;
   18abc:	4b03      	ldr	r3, [pc, #12]	; (18acc <hal_pio_set_gpio_output+0x48>)
   18abe:	01a4      	lsls	r4, r4, #6
   18ac0:	191c      	adds	r4, r3, r4
   18ac2:	2380      	movs	r3, #128	; 0x80
   18ac4:	009b      	lsls	r3, r3, #2
   18ac6:	6363      	str	r3, [r4, #52]	; 0x34
}
   18ac8:	e7e9      	b.n	18a9e <hal_pio_set_gpio_output+0x1a>
   18aca:	46c0      	nop			; (mov r8, r8)
   18acc:	40001000 	.word	0x40001000

00018ad0 <hal_pio_is_interrupt_asserted>:
        {
            return ((GPIO_IRQ_MS & pin_mask) == 0) ? false : true;
        }
    }

    return false;
   18ad0:	2300      	movs	r3, #0
    if( pin < PIN_MAX_NUMBER )
   18ad2:	2827      	cmp	r0, #39	; 0x27
   18ad4:	d80b      	bhi.n	18aee <hal_pio_is_interrupt_asserted+0x1e>
        uint32 pin_mask = 1U << (pin & PIN_31); //lint !e655
   18ad6:	221f      	movs	r2, #31
   18ad8:	3301      	adds	r3, #1
   18ada:	4002      	ands	r2, r0
   18adc:	4093      	lsls	r3, r2
        if( pin < PIN_32 )
   18ade:	281f      	cmp	r0, #31
   18ae0:	d807      	bhi.n	18af2 <hal_pio_is_interrupt_asserted+0x22>
            return ((GPIO_IRQ & pin_mask) == 0) ? false : true;
   18ae2:	4a05      	ldr	r2, [pc, #20]	; (18af8 <hal_pio_is_interrupt_asserted+0x28>)
            return ((GPIO_IRQ_MS & pin_mask) == 0) ? false : true;
   18ae4:	6810      	ldr	r0, [r2, #0]
   18ae6:	4003      	ands	r3, r0
   18ae8:	1e58      	subs	r0, r3, #1
   18aea:	4183      	sbcs	r3, r0
   18aec:	b2db      	uxtb	r3, r3
}
   18aee:	0018      	movs	r0, r3
   18af0:	4770      	bx	lr
            return ((GPIO_IRQ_MS & pin_mask) == 0) ? false : true;
   18af2:	4a02      	ldr	r2, [pc, #8]	; (18afc <hal_pio_is_interrupt_asserted+0x2c>)
   18af4:	e7f6      	b.n	18ae4 <hal_pio_is_interrupt_asserted+0x14>
   18af6:	46c0      	nop			; (mov r8, r8)
   18af8:	40004028 	.word	0x40004028
   18afc:	4000402c 	.word	0x4000402c

00018b00 <hal_pio_clear_interrupt>:
/*
 * Clears the IRQ status for a PIO
 */
void hal_pio_clear_interrupt( PIN pin )
{
    if( pin < PIN_MAX_NUMBER )
   18b00:	2827      	cmp	r0, #39	; 0x27
   18b02:	d804      	bhi.n	18b0e <hal_pio_clear_interrupt+0xe>
    {   // A write of any value to the PIO_IRQ_CLR register will clear the IRQ status
        hal_pio_registers[ pin ].pio_irq_clr = 0x1;
   18b04:	4b02      	ldr	r3, [pc, #8]	; (18b10 <hal_pio_clear_interrupt+0x10>)
   18b06:	0180      	lsls	r0, r0, #6
   18b08:	1818      	adds	r0, r3, r0
   18b0a:	2301      	movs	r3, #1
   18b0c:	6083      	str	r3, [r0, #8]
    }
}
   18b0e:	4770      	bx	lr
   18b10:	40001000 	.word	0x40001000

00018b14 <hal_pio_set_interrupt>:

/*
 * Configure an interrupt trigger type for a pio
 */
void hal_pio_set_interrupt( PIN pin, HAL_PIO_INTERRUPT interrupt_trigger_type, INTERRUPT_STATE state)
{
   18b14:	0003      	movs	r3, r0
   18b16:	b500      	push	{lr}
   18b18:	0008      	movs	r0, r1
    if( pin < PIN_MAX_NUMBER )
   18b1a:	2b27      	cmp	r3, #39	; 0x27
   18b1c:	d803      	bhi.n	18b26 <hal_pio_set_interrupt+0x12>
    {
        switch( state )
   18b1e:	2a00      	cmp	r2, #0
   18b20:	d002      	beq.n	18b28 <hal_pio_set_interrupt+0x14>
   18b22:	2a01      	cmp	r2, #1
   18b24:	d013      	beq.n	18b4e <hal_pio_set_interrupt+0x3a>
            break;
        default:
            break;
        }
    }
}
   18b26:	bd00      	pop	{pc}
 */
static void hal_pio_disable_interrupt( PIN pin, HAL_PIO_INTERRUPT interrupt_trigger_type )
{
    assert( pin < PIN_MAX_NUMBER );    // Expect pin to have been validated beforehand

    switch( interrupt_trigger_type )
   18b28:	2903      	cmp	r1, #3
   18b2a:	d8fc      	bhi.n	18b26 <hal_pio_set_interrupt+0x12>
   18b2c:	4a11      	ldr	r2, [pc, #68]	; (18b74 <hal_pio_set_interrupt+0x60>)
   18b2e:	019b      	lsls	r3, r3, #6
    case HAL_PIO_INTERRUPT_HIGH:
        hal_pio_registers[ pin ].pio_ctrl_bitclr = HAL_PIO_CTRL_IRQ_HIGH_EN;
        break;

    case HAL_PIO_INTERRUPT_LOW:
        hal_pio_registers[ pin ].pio_ctrl_bitclr = HAL_PIO_CTRL_IRQ_LOW_EN;
   18b30:	18d3      	adds	r3, r2, r3
   18b32:	2280      	movs	r2, #128	; 0x80
    switch( interrupt_trigger_type )
   18b34:	f7e7 fc36 	bl	3a4 <__gnu_thumb1_case_uqi>
   18b38:	09070502 	.word	0x09070502
        hal_pio_registers[ pin ].pio_ctrl_bitclr = HAL_PIO_CTRL_IRQ_RISING_EN;
   18b3c:	0192      	lsls	r2, r2, #6
        hal_pio_registers[ pin ].pio_ctrl_bitclr = HAL_PIO_CTRL_IRQ_LOW_EN;
   18b3e:	625a      	str	r2, [r3, #36]	; 0x24
   18b40:	e7f1      	b.n	18b26 <hal_pio_set_interrupt+0x12>
        hal_pio_registers[ pin ].pio_ctrl_bitclr = HAL_PIO_CTRL_IRQ_FALLING_EN;
   18b42:	01d2      	lsls	r2, r2, #7
   18b44:	e7fb      	b.n	18b3e <hal_pio_set_interrupt+0x2a>
        hal_pio_registers[ pin ].pio_ctrl_bitclr = HAL_PIO_CTRL_IRQ_HIGH_EN;
   18b46:	0212      	lsls	r2, r2, #8
   18b48:	e7f9      	b.n	18b3e <hal_pio_set_interrupt+0x2a>
        hal_pio_registers[ pin ].pio_ctrl_bitclr = HAL_PIO_CTRL_IRQ_LOW_EN;
   18b4a:	0252      	lsls	r2, r2, #9
   18b4c:	e7f7      	b.n	18b3e <hal_pio_set_interrupt+0x2a>
 */
static void hal_pio_enable_interrupt( PIN pin, HAL_PIO_INTERRUPT interrupt_trigger_type )
{
    assert( pin < PIN_MAX_NUMBER );    // Expect pin to have been validated beforehand

    switch( interrupt_trigger_type )
   18b4e:	2903      	cmp	r1, #3
   18b50:	d8e9      	bhi.n	18b26 <hal_pio_set_interrupt+0x12>
   18b52:	4a08      	ldr	r2, [pc, #32]	; (18b74 <hal_pio_set_interrupt+0x60>)
   18b54:	019b      	lsls	r3, r3, #6
    case HAL_PIO_INTERRUPT_HIGH:
        hal_pio_registers[ pin ].pio_ctrl_bitset = HAL_PIO_CTRL_IRQ_HIGH_EN;
        break;

    case HAL_PIO_INTERRUPT_LOW:
        hal_pio_registers[ pin ].pio_ctrl_bitset = HAL_PIO_CTRL_IRQ_LOW_EN;
   18b56:	18d3      	adds	r3, r2, r3
   18b58:	2280      	movs	r2, #128	; 0x80
    switch( interrupt_trigger_type )
   18b5a:	f7e7 fc23 	bl	3a4 <__gnu_thumb1_case_uqi>
   18b5e:	0502      	.short	0x0502
   18b60:	0907      	.short	0x0907
        hal_pio_registers[ pin ].pio_ctrl_bitset = HAL_PIO_CTRL_IRQ_RISING_EN;
   18b62:	0192      	lsls	r2, r2, #6
        hal_pio_registers[ pin ].pio_ctrl_bitset = HAL_PIO_CTRL_IRQ_LOW_EN;
   18b64:	615a      	str	r2, [r3, #20]
}
   18b66:	e7de      	b.n	18b26 <hal_pio_set_interrupt+0x12>
        hal_pio_registers[ pin ].pio_ctrl_bitset = HAL_PIO_CTRL_IRQ_FALLING_EN;
   18b68:	01d2      	lsls	r2, r2, #7
   18b6a:	e7fb      	b.n	18b64 <hal_pio_set_interrupt+0x50>
        hal_pio_registers[ pin ].pio_ctrl_bitset = HAL_PIO_CTRL_IRQ_HIGH_EN;
   18b6c:	0212      	lsls	r2, r2, #8
   18b6e:	e7f9      	b.n	18b64 <hal_pio_set_interrupt+0x50>
        hal_pio_registers[ pin ].pio_ctrl_bitset = HAL_PIO_CTRL_IRQ_LOW_EN;
   18b70:	0252      	lsls	r2, r2, #9
   18b72:	e7f7      	b.n	18b64 <hal_pio_set_interrupt+0x50>
   18b74:	40001000 	.word	0x40001000

00018b78 <hal_lpuart_specific_claim>:
/*
 * Attempt to claim the LP UART
 */
bool hal_lpuart_specific_claim( void )
{
    if( (LP_UART_CLAIM & (HAL_LP_UART_CLAIM_IS_CLAIMED | HAL_LP_UART_CLAIM_IS_BEING_CLAIMED)) == 0x0 )
   18b78:	2277      	movs	r2, #119	; 0x77
   18b7a:	4b07      	ldr	r3, [pc, #28]	; (18b98 <hal_lpuart_specific_claim+0x20>)
   18b7c:	6819      	ldr	r1, [r3, #0]
   18b7e:	4211      	tst	r1, r2
   18b80:	d105      	bne.n	18b8e <hal_lpuart_specific_claim+0x16>
    {
        LP_UART_CLAIM = HAL_LP_UART_CLAIM_REQUEST;
   18b82:	3a76      	subs	r2, #118	; 0x76
   18b84:	601a      	str	r2, [r3, #0]
        while( (LP_UART_CLAIM & HAL_LP_UART_CLAIM_IS_CLAIMED) == 0x0 )
   18b86:	3206      	adds	r2, #6
   18b88:	6819      	ldr	r1, [r3, #0]
   18b8a:	4211      	tst	r1, r2
   18b8c:	d0fc      	beq.n	18b88 <hal_lpuart_specific_claim+0x10>

#elif (CORE == APPS)
    uint32 claim_mask = HAL_LP_UART_CLAIM_OWNER_APPS;
#endif

    if( LP_UART_CLAIM & claim_mask )
   18b8e:	6818      	ldr	r0, [r3, #0]
   18b90:	0740      	lsls	r0, r0, #29
   18b92:	0fc0      	lsrs	r0, r0, #31
    {   // Successfully claimed
        return true;
    }

    return false;
}
   18b94:	4770      	bx	lr
   18b96:	46c0      	nop			; (mov r8, r8)
   18b98:	40002000 	.word	0x40002000

00018b9c <hal_lpuart_specific_release>:
/*
 *  Release claim over LP UART
 */
void hal_lpuart_specific_release( void )
{
    LP_UART_CLAIM = 0;
   18b9c:	2200      	movs	r2, #0
   18b9e:	4b01      	ldr	r3, [pc, #4]	; (18ba4 <hal_lpuart_specific_release+0x8>)
   18ba0:	601a      	str	r2, [r3, #0]
}
   18ba2:	4770      	bx	lr
   18ba4:	40002000 	.word	0x40002000

00018ba8 <hal_lpuart_specific_clear_irq>:
/*
 *  Clear LP UART RX interrupt
 */
void hal_lpuart_specific_clear_irq( void )
{
    LP_UART_IRQ_CLR_BITSET = HAL_LP_UART_CLEAR_IRQ_RX;
   18ba8:	2201      	movs	r2, #1
   18baa:	4b01      	ldr	r3, [pc, #4]	; (18bb0 <hal_lpuart_specific_clear_irq+0x8>)
   18bac:	601a      	str	r2, [r3, #0]
}
   18bae:	4770      	bx	lr
   18bb0:	4000202c 	.word	0x4000202c

00018bb4 <hal_lpuart_specific_set_baud_rate>:

/*
 * Set baud rate
 */
bool hal_lpuart_specific_set_baud_rate(uint32 baudrate)
{
   18bb4:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    assert (baudrate <= HAL_LPUART_MAX_BAUD_RATE);
   18bb6:	23e1      	movs	r3, #225	; 0xe1
   18bb8:	4677      	mov	r7, lr
{
   18bba:	0004      	movs	r4, r0
    assert (baudrate <= HAL_LPUART_MAX_BAUD_RATE);
   18bbc:	021b      	lsls	r3, r3, #8
   18bbe:	4298      	cmp	r0, r3
   18bc0:	d91b      	bls.n	18bfa <hal_lpuart_specific_set_baud_rate+0x46>
   18bc2:	4671      	mov	r1, lr
   18bc4:	2016      	movs	r0, #22
   18bc6:	f7e8 ffa3 	bl	1b10 <panic>

    if ((baudrate > HAL_LPUART_MAX_BAUD_RATE_WITH_RTC))
    {
        assert( CLK_FREQ_LP_BACKOFF == 1);
   18bca:	4e46      	ldr	r6, [pc, #280]	; (18ce4 <hal_lpuart_specific_set_baud_rate+0x130>)
   18bcc:	6833      	ldr	r3, [r6, #0]
   18bce:	2b01      	cmp	r3, #1
   18bd0:	d003      	beq.n	18bda <hal_lpuart_specific_set_baud_rate+0x26>
   18bd2:	0039      	movs	r1, r7
   18bd4:	2016      	movs	r0, #22
   18bd6:	f7e8 ff9b 	bl	1b10 <panic>
        assert( (LPC_CTRL & LPC_CTRL_ALLOW_LP_UART_ASYNCHRONOUS_CHIP_WAKE_MASK) == LPC_CTRL_ALLOW_LP_UART_ASYNCHRONOUS_CHIP_WAKE_MASK);
   18bda:	4d43      	ldr	r5, [pc, #268]	; (18ce8 <hal_lpuart_specific_set_baud_rate+0x134>)
   18bdc:	682b      	ldr	r3, [r5, #0]
   18bde:	051b      	lsls	r3, r3, #20
   18be0:	d403      	bmi.n	18bea <hal_lpuart_specific_set_baud_rate+0x36>
   18be2:	0039      	movs	r1, r7
   18be4:	2016      	movs	r0, #22
   18be6:	f7e8 ff93 	bl	1b10 <panic>
        if ( ( CLK_FREQ_LP_BACKOFF != 1)
   18bea:	6833      	ldr	r3, [r6, #0]
                || ( (LPC_CTRL & LPC_CTRL_ALLOW_LP_UART_ASYNCHRONOUS_CHIP_WAKE_MASK) != LPC_CTRL_ALLOW_LP_UART_ASYNCHRONOUS_CHIP_WAKE_MASK))
        {
            return false;
   18bec:	2000      	movs	r0, #0
        if ( ( CLK_FREQ_LP_BACKOFF != 1)
   18bee:	2b01      	cmp	r3, #1
   18bf0:	d102      	bne.n	18bf8 <hal_lpuart_specific_set_baud_rate+0x44>
                || ( (LPC_CTRL & LPC_CTRL_ALLOW_LP_UART_ASYNCHRONOUS_CHIP_WAKE_MASK) != LPC_CTRL_ALLOW_LP_UART_ASYNCHRONOUS_CHIP_WAKE_MASK))
   18bf2:	682b      	ldr	r3, [r5, #0]
   18bf4:	051b      	lsls	r3, r3, #20
   18bf6:	d404      	bmi.n	18c02 <hal_lpuart_specific_set_baud_rate+0x4e>
    }

    LP_UART_CTRL_BITCLR = HAL_LPUART_CTRL_RESET_MASK;
    return true;

}
   18bf8:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    if ((baudrate > HAL_LPUART_MAX_BAUD_RATE_WITH_RTC))
   18bfa:	2396      	movs	r3, #150	; 0x96
   18bfc:	019b      	lsls	r3, r3, #6
   18bfe:	4298      	cmp	r0, r3
   18c00:	d8e3      	bhi.n	18bca <hal_lpuart_specific_set_baud_rate+0x16>
    LP_UART_CTRL_BITSET =  HAL_LPUART_CTRL_RESET_MASK;
   18c02:	2280      	movs	r2, #128	; 0x80
   18c04:	4b39      	ldr	r3, [pc, #228]	; (18cec <hal_lpuart_specific_set_baud_rate+0x138>)
   18c06:	05d2      	lsls	r2, r2, #23
   18c08:	601a      	str	r2, [r3, #0]
    switch (baudrate) {
   18c0a:	2296      	movs	r2, #150	; 0x96
   18c0c:	0192      	lsls	r2, r2, #6
   18c0e:	4294      	cmp	r4, r2
   18c10:	d041      	beq.n	18c96 <hal_lpuart_specific_set_baud_rate+0xe2>
   18c12:	d809      	bhi.n	18c28 <hal_lpuart_specific_set_baud_rate+0x74>
   18c14:	2396      	movs	r3, #150	; 0x96
   18c16:	011b      	lsls	r3, r3, #4
   18c18:	429c      	cmp	r4, r3
   18c1a:	d021      	beq.n	18c60 <hal_lpuart_specific_set_baud_rate+0xac>
   18c1c:	2396      	movs	r3, #150	; 0x96
   18c1e:	015b      	lsls	r3, r3, #5
   18c20:	429c      	cmp	r4, r3
   18c22:	d02e      	beq.n	18c82 <hal_lpuart_specific_set_baud_rate+0xce>
        return false;
   18c24:	2000      	movs	r0, #0
   18c26:	e7e7      	b.n	18bf8 <hal_lpuart_specific_set_baud_rate+0x44>
    switch (baudrate) {
   18c28:	2296      	movs	r2, #150	; 0x96
   18c2a:	0212      	lsls	r2, r2, #8
   18c2c:	4294      	cmp	r4, r2
   18c2e:	d03c      	beq.n	18caa <hal_lpuart_specific_set_baud_rate+0xf6>
   18c30:	22e1      	movs	r2, #225	; 0xe1
   18c32:	0212      	lsls	r2, r2, #8
   18c34:	4294      	cmp	r4, r2
   18c36:	d046      	beq.n	18cc6 <hal_lpuart_specific_set_baud_rate+0x112>
   18c38:	2296      	movs	r2, #150	; 0x96
   18c3a:	01d2      	lsls	r2, r2, #7
   18c3c:	4294      	cmp	r4, r2
   18c3e:	d1f1      	bne.n	18c24 <hal_lpuart_specific_set_baud_rate+0x70>
        LP_UART_CTRL_BITSET = HAL_LPUART_CTRL_SELECT_CLOCK_UART_MASK; // Select UART clock
   18c40:	2280      	movs	r2, #128	; 0x80
   18c42:	0612      	lsls	r2, r2, #24
   18c44:	601a      	str	r2, [r3, #0]
        LP_UART_CTRL = HAL_LPUART_CTRL_SET_CLOCK_DIV(LP_UART_CTRL, HAL_LPUART_CLK_UART_BR_19200);
   18c46:	23c0      	movs	r3, #192	; 0xc0
   18c48:	4a29      	ldr	r2, [pc, #164]	; (18cf0 <hal_lpuart_specific_set_baud_rate+0x13c>)
   18c4a:	055b      	lsls	r3, r3, #21
   18c4c:	6811      	ldr	r1, [r2, #0]
   18c4e:	430b      	orrs	r3, r1
   18c50:	6013      	str	r3, [r2, #0]
        LP_UART_CTRL = HAL_LPUART_CTRL_SET_NUM_DEN(LP_UART_CTRL, HAL_LPUART_NUM_DEN_BR_19200);
   18c52:	6813      	ldr	r3, [r2, #0]
   18c54:	4927      	ldr	r1, [pc, #156]	; (18cf4 <hal_lpuart_specific_set_baud_rate+0x140>)
   18c56:	0c1b      	lsrs	r3, r3, #16
   18c58:	041b      	lsls	r3, r3, #16
        LP_UART_CTRL = HAL_LPUART_CTRL_SET_NUM_DEN(LP_UART_CTRL, HAL_LPUART_NUM_DEN_BR_57600);
   18c5a:	430b      	orrs	r3, r1
   18c5c:	6013      	str	r3, [r2, #0]
        break;
   18c5e:	e00a      	b.n	18c76 <hal_lpuart_specific_set_baud_rate+0xc2>
        LP_UART_CTRL_BITCLR = HAL_LPUART_CTRL_SELECT_CLOCK_UART_MASK; // Select RTC Clock
   18c60:	2280      	movs	r2, #128	; 0x80
   18c62:	4b25      	ldr	r3, [pc, #148]	; (18cf8 <hal_lpuart_specific_set_baud_rate+0x144>)
   18c64:	0612      	lsls	r2, r2, #24
        LP_UART_CTRL = HAL_LPUART_CTRL_SET_NUM_DEN(LP_UART_CTRL, HAL_LPUART_NUM_DEN_BR_2400);
   18c66:	4922      	ldr	r1, [pc, #136]	; (18cf0 <hal_lpuart_specific_set_baud_rate+0x13c>)
        LP_UART_CTRL_BITCLR = HAL_LPUART_CTRL_SELECT_CLOCK_UART_MASK; // Select RTC Clock
   18c68:	601a      	str	r2, [r3, #0]
        LP_UART_CTRL = HAL_LPUART_CTRL_SET_NUM_DEN(LP_UART_CTRL, HAL_LPUART_NUM_DEN_BR_2400);
   18c6a:	680b      	ldr	r3, [r1, #0]
   18c6c:	4a23      	ldr	r2, [pc, #140]	; (18cfc <hal_lpuart_specific_set_baud_rate+0x148>)
   18c6e:	0c1b      	lsrs	r3, r3, #16
   18c70:	041b      	lsls	r3, r3, #16
        LP_UART_CTRL = HAL_LPUART_CTRL_SET_NUM_DEN(LP_UART_CTRL, HAL_LPUART_NUM_DEN_BR_4800);
   18c72:	4313      	orrs	r3, r2
   18c74:	600b      	str	r3, [r1, #0]
    LP_UART_CTRL_BITCLR = HAL_LPUART_CTRL_RESET_MASK;
   18c76:	2280      	movs	r2, #128	; 0x80
   18c78:	4b1f      	ldr	r3, [pc, #124]	; (18cf8 <hal_lpuart_specific_set_baud_rate+0x144>)
   18c7a:	05d2      	lsls	r2, r2, #23
   18c7c:	601a      	str	r2, [r3, #0]
    return true;
   18c7e:	2001      	movs	r0, #1
   18c80:	e7ba      	b.n	18bf8 <hal_lpuart_specific_set_baud_rate+0x44>
        LP_UART_CTRL_BITCLR = HAL_LPUART_CTRL_SELECT_CLOCK_UART_MASK; // Select RTC Clock
   18c82:	2280      	movs	r2, #128	; 0x80
   18c84:	4b1c      	ldr	r3, [pc, #112]	; (18cf8 <hal_lpuart_specific_set_baud_rate+0x144>)
   18c86:	0612      	lsls	r2, r2, #24
        LP_UART_CTRL = HAL_LPUART_CTRL_SET_NUM_DEN(LP_UART_CTRL, HAL_LPUART_NUM_DEN_BR_4800);
   18c88:	4919      	ldr	r1, [pc, #100]	; (18cf0 <hal_lpuart_specific_set_baud_rate+0x13c>)
        LP_UART_CTRL_BITCLR = HAL_LPUART_CTRL_SELECT_CLOCK_UART_MASK; // Select RTC Clock
   18c8a:	601a      	str	r2, [r3, #0]
        LP_UART_CTRL = HAL_LPUART_CTRL_SET_NUM_DEN(LP_UART_CTRL, HAL_LPUART_NUM_DEN_BR_4800);
   18c8c:	680b      	ldr	r3, [r1, #0]
   18c8e:	4a1c      	ldr	r2, [pc, #112]	; (18d00 <hal_lpuart_specific_set_baud_rate+0x14c>)
   18c90:	0c1b      	lsrs	r3, r3, #16
   18c92:	041b      	lsls	r3, r3, #16
   18c94:	e7ed      	b.n	18c72 <hal_lpuart_specific_set_baud_rate+0xbe>
        LP_UART_CTRL_BITCLR = HAL_LPUART_CTRL_SELECT_CLOCK_UART_MASK; // Select RTC Clock
   18c96:	2280      	movs	r2, #128	; 0x80
   18c98:	4b17      	ldr	r3, [pc, #92]	; (18cf8 <hal_lpuart_specific_set_baud_rate+0x144>)
   18c9a:	0612      	lsls	r2, r2, #24
        LP_UART_CTRL = HAL_LPUART_CTRL_SET_NUM_DEN(LP_UART_CTRL, HAL_LPUART_NUM_DEN_BR_9600);
   18c9c:	4914      	ldr	r1, [pc, #80]	; (18cf0 <hal_lpuart_specific_set_baud_rate+0x13c>)
        LP_UART_CTRL_BITCLR = HAL_LPUART_CTRL_SELECT_CLOCK_UART_MASK; // Select RTC Clock
   18c9e:	601a      	str	r2, [r3, #0]
        LP_UART_CTRL = HAL_LPUART_CTRL_SET_NUM_DEN(LP_UART_CTRL, HAL_LPUART_NUM_DEN_BR_9600);
   18ca0:	680b      	ldr	r3, [r1, #0]
   18ca2:	224b      	movs	r2, #75	; 0x4b
   18ca4:	0c1b      	lsrs	r3, r3, #16
   18ca6:	041b      	lsls	r3, r3, #16
   18ca8:	e7e3      	b.n	18c72 <hal_lpuart_specific_set_baud_rate+0xbe>
        LP_UART_CTRL_BITSET = HAL_LPUART_CTRL_SELECT_CLOCK_UART_MASK; // Select UART clock
   18caa:	2280      	movs	r2, #128	; 0x80
   18cac:	0612      	lsls	r2, r2, #24
   18cae:	601a      	str	r2, [r3, #0]
        LP_UART_CTRL = HAL_LPUART_CTRL_SET_CLOCK_DIV(LP_UART_CTRL, HAL_LPUART_CLK_UART_BR_38400);
   18cb0:	23c0      	movs	r3, #192	; 0xc0
   18cb2:	4a0f      	ldr	r2, [pc, #60]	; (18cf0 <hal_lpuart_specific_set_baud_rate+0x13c>)
   18cb4:	055b      	lsls	r3, r3, #21
   18cb6:	6811      	ldr	r1, [r2, #0]
   18cb8:	430b      	orrs	r3, r1
   18cba:	6013      	str	r3, [r2, #0]
        LP_UART_CTRL = HAL_LPUART_CTRL_SET_NUM_DEN(LP_UART_CTRL, HAL_LPUART_NUM_DEN_BR_38400);
   18cbc:	6813      	ldr	r3, [r2, #0]
   18cbe:	4911      	ldr	r1, [pc, #68]	; (18d04 <hal_lpuart_specific_set_baud_rate+0x150>)
   18cc0:	0c1b      	lsrs	r3, r3, #16
   18cc2:	041b      	lsls	r3, r3, #16
   18cc4:	e7c9      	b.n	18c5a <hal_lpuart_specific_set_baud_rate+0xa6>
        LP_UART_CTRL_BITSET = HAL_LPUART_CTRL_SELECT_CLOCK_UART_MASK; // Select UART clock
   18cc6:	2280      	movs	r2, #128	; 0x80
   18cc8:	0612      	lsls	r2, r2, #24
   18cca:	601a      	str	r2, [r3, #0]
        LP_UART_CTRL = HAL_LPUART_CTRL_SET_CLOCK_DIV(LP_UART_CTRL, HAL_LPUART_CLK_UART_BR_57600);
   18ccc:	23c0      	movs	r3, #192	; 0xc0
   18cce:	4a08      	ldr	r2, [pc, #32]	; (18cf0 <hal_lpuart_specific_set_baud_rate+0x13c>)
   18cd0:	055b      	lsls	r3, r3, #21
   18cd2:	6811      	ldr	r1, [r2, #0]
   18cd4:	430b      	orrs	r3, r1
   18cd6:	6013      	str	r3, [r2, #0]
        LP_UART_CTRL = HAL_LPUART_CTRL_SET_NUM_DEN(LP_UART_CTRL, HAL_LPUART_NUM_DEN_BR_57600);
   18cd8:	6813      	ldr	r3, [r2, #0]
   18cda:	490b      	ldr	r1, [pc, #44]	; (18d08 <hal_lpuart_specific_set_baud_rate+0x154>)
   18cdc:	0c1b      	lsrs	r3, r3, #16
   18cde:	041b      	lsls	r3, r3, #16
   18ce0:	e7bb      	b.n	18c5a <hal_lpuart_specific_set_baud_rate+0xa6>
   18ce2:	46c0      	nop			; (mov r8, r8)
   18ce4:	40000020 	.word	0x40000020
   18ce8:	40000038 	.word	0x40000038
   18cec:	40002024 	.word	0x40002024
   18cf0:	40002004 	.word	0x40002004
   18cf4:	0000fd06 	.word	0x0000fd06
   18cf8:	40002044 	.word	0x40002044
   18cfc:	00005206 	.word	0x00005206
   18d00:	00009d17 	.word	0x00009d17
   18d04:	0000fd0c 	.word	0x0000fd0c
   18d08:	0000fd12 	.word	0x0000fd12

00018d0c <NMI_Handler>:
//lint -esym(459, NMI_Handler)
//lint -esym(459, HardFault_Handler)
/*lint -save -e843  Disable 'could be const' info, since lint does not know that this is for a debugger */
void NMI_Handler(void);
void NMI_Handler(void)
{
   18d0c:	b530      	push	{r4, r5, lr}
   18d0e:	b085      	sub	sp, #20
#ifdef WATCHDOG_MOCKED
    hal_watchdog_stop();
#endif
    static volatile uint8 i = 1;             // Could be const Info, disabled above
    SETUP_EXCEPTION_STACK_FRAME_PTR(NMI);    //lint   !e10  ignore __asm
   18d10:	2004      	movs	r0, #4
   18d12:	4671      	mov	r1, lr
   18d14:	4208      	tst	r0, r1
   18d16:	d002      	beq.n	18d1e <NMI_MSP>
   18d18:	f3ef 8009 	mrs	r0, PSP
   18d1c:	e001      	b.n	18d22 <NMI_END>

00018d1e <NMI_MSP>:
   18d1e:	f3ef 8008 	mrs	r0, MSP

00018d22 <NMI_END>:
   18d22:	1c03      	adds	r3, r0, #0
   18d24:	4a0b      	ldr	r2, [pc, #44]	; (18d54 <NMI_END+0x32>)
    set_exception_stack_frame(*exception_stack_frame_ptr);
   18d26:	4669      	mov	r1, sp
    SETUP_EXCEPTION_STACK_FRAME_PTR(NMI);    //lint   !e10  ignore __asm
   18d28:	6013      	str	r3, [r2, #0]
    set_exception_stack_frame(*exception_stack_frame_ptr);
   18d2a:	001a      	movs	r2, r3
   18d2c:	3210      	adds	r2, #16
   18d2e:	ca31      	ldmia	r2!, {r0, r4, r5}
   18d30:	c131      	stmia	r1!, {r0, r4, r5}
   18d32:	6812      	ldr	r2, [r2, #0]
   18d34:	600a      	str	r2, [r1, #0]
   18d36:	689a      	ldr	r2, [r3, #8]
   18d38:	6818      	ldr	r0, [r3, #0]
   18d3a:	6859      	ldr	r1, [r3, #4]
   18d3c:	68db      	ldr	r3, [r3, #12]
   18d3e:	f002 fd01 	bl	1b744 <set_exception_stack_frame>
    set_last_exception(EXCEPTION_TYPE_HARD_FAULT);
   18d42:	2001      	movs	r0, #1
   18d44:	f002 fd14 	bl	1b770 <set_last_exception>
    set_cpu_utils_reset_cause(REBOOT_CAUSE_SECURITY_UPDATER_CHIP_WATCHDOG);
#else
    set_cpu_utils_reset_cause(REBOOT_CAUSE_SECURITY_STANDARD_CHIP_WATCHDOG);
#endif
#endif
    while (i)   //lint !e716
   18d48:	4a03      	ldr	r2, [pc, #12]	; (18d58 <NMI_END+0x36>)
   18d4a:	7813      	ldrb	r3, [r2, #0]
   18d4c:	2b00      	cmp	r3, #0
   18d4e:	d1fc      	bne.n	18d4a <NMI_END+0x28>
    {

    }
}
   18d50:	b005      	add	sp, #20
   18d52:	bd30      	pop	{r4, r5, pc}
   18d54:	01002a14 	.word	0x01002a14
   18d58:	010005d2 	.word	0x010005d2

00018d5c <HardFault_Handler>:

void HardFault_Handler(void)
{
   18d5c:	b530      	push	{r4, r5, lr}
   18d5e:	b085      	sub	sp, #20
    static volatile uint8 i = 1;                   // Could be const Info, disabled above
#ifdef WATCHDOG_MOCKED
    hal_watchdog_stop();
#endif
    SETUP_EXCEPTION_STACK_FRAME_PTR(HardFault);    //lint   !e10  ignore __asm
   18d60:	2004      	movs	r0, #4
   18d62:	4671      	mov	r1, lr
   18d64:	4208      	tst	r0, r1
   18d66:	d002      	beq.n	18d6e <HardFault_MSP>
   18d68:	f3ef 8009 	mrs	r0, PSP
   18d6c:	e001      	b.n	18d72 <HardFault_END>

00018d6e <HardFault_MSP>:
   18d6e:	f3ef 8008 	mrs	r0, MSP

00018d72 <HardFault_END>:
   18d72:	1c03      	adds	r3, r0, #0
   18d74:	4a0b      	ldr	r2, [pc, #44]	; (18da4 <HardFault_END+0x32>)
    set_exception_stack_frame(*exception_stack_frame_ptr);
   18d76:	4669      	mov	r1, sp
    SETUP_EXCEPTION_STACK_FRAME_PTR(HardFault);    //lint   !e10  ignore __asm
   18d78:	6013      	str	r3, [r2, #0]
    set_exception_stack_frame(*exception_stack_frame_ptr);
   18d7a:	001a      	movs	r2, r3
   18d7c:	3210      	adds	r2, #16
   18d7e:	ca31      	ldmia	r2!, {r0, r4, r5}
   18d80:	c131      	stmia	r1!, {r0, r4, r5}
   18d82:	6812      	ldr	r2, [r2, #0]
   18d84:	600a      	str	r2, [r1, #0]
   18d86:	689a      	ldr	r2, [r3, #8]
   18d88:	6818      	ldr	r0, [r3, #0]
   18d8a:	6859      	ldr	r1, [r3, #4]
   18d8c:	68db      	ldr	r3, [r3, #12]
   18d8e:	f002 fcd9 	bl	1b744 <set_exception_stack_frame>
    set_last_exception(EXCEPTION_TYPE_HARD_FAULT);
   18d92:	2001      	movs	r0, #1
   18d94:	f002 fcec 	bl	1b770 <set_last_exception>
    while (i)   //lint !e716
   18d98:	4a03      	ldr	r2, [pc, #12]	; (18da8 <HardFault_END+0x36>)
   18d9a:	7813      	ldrb	r3, [r2, #0]
   18d9c:	2b00      	cmp	r3, #0
   18d9e:	d1fc      	bne.n	18d9a <HardFault_END+0x28>
    {

    }
}
   18da0:	b005      	add	sp, #20
   18da2:	bd30      	pop	{r4, r5, pc}
   18da4:	01002a14 	.word	0x01002a14
   18da8:	010005d3 	.word	0x010005d3

00018dac <hal_cpu_init>:
/*lint -restore */

void hal_cpu_init(void)
{
   18dac:	b510      	push	{r4, lr}
   18dae:	f3ef 8303 	mrs	r3, PSR
    uint32 reg = __get_xPSR();

    // Check for interrupt context and reboot needed.
    if (reg & 0x3f)
   18db2:	069b      	lsls	r3, r3, #26
   18db4:	d005      	beq.n	18dc2 <hal_cpu_init+0x16>
    {
        // Processor is in an interrupt context; reset the core by triggering the reset vector using the SYSRESETREQ bit in the AIRCR register

        reg =  SCB->AIRCR;
   18db6:	4908      	ldr	r1, [pc, #32]	; (18dd8 <hal_cpu_init+0x2c>)
        reg &= 0xffff;            // Mask out the top 16 bits in case any are set
        reg |= 0x05fa0000;        // Must write with this value for the write to take effect
        reg |= 0x04;              // Set the SYSRESETREQ bit
   18db8:	4b08      	ldr	r3, [pc, #32]	; (18ddc <hal_cpu_init+0x30>)
        reg =  SCB->AIRCR;
   18dba:	68ca      	ldr	r2, [r1, #12]
        reg &= 0xffff;            // Mask out the top 16 bits in case any are set
   18dbc:	b292      	uxth	r2, r2
        reg |= 0x04;              // Set the SYSRESETREQ bit
   18dbe:	4313      	orrs	r3, r2
        SCB->AIRCR  = reg;        // Reset the core
   18dc0:	60cb      	str	r3, [r1, #12]
    }

    hal_pio_release_all();
   18dc2:	f7ff fdc1 	bl	18948 <hal_pio_release_all>

    // Disable all IRQ interrupts
    NVIC->ICER[0] = 0xffffffff;
   18dc6:	2201      	movs	r2, #1
   18dc8:	4b05      	ldr	r3, [pc, #20]	; (18de0 <hal_cpu_init+0x34>)
   18dca:	4252      	negs	r2, r2
   18dcc:	67da      	str	r2, [r3, #124]	; 0x7c

    \param [in]    priMask  Priority Mask
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __set_PRIMASK(uint32_t priMask)
{
  __ASM volatile ("MSR primask, %0" : : "r" (priMask) : "memory");
   18dce:	2300      	movs	r3, #0
   18dd0:	f383 8810 	msr	PRIMASK, r3

#if CORE == PROTOCOL
    /* Set the bus contention to prioritise the protocol core. */
    FLASH_PRIORITY_OVERRIDE = (uint32)0x01;
#endif
}
   18dd4:	bd10      	pop	{r4, pc}
   18dd6:	46c0      	nop			; (mov r8, r8)
   18dd8:	e000ed00 	.word	0xe000ed00
   18ddc:	05fa0004 	.word	0x05fa0004
   18de0:	e000e104 	.word	0xe000e104

00018de4 <hal_clocks_get_core_clock_mid_value>:
}


/* Core clock, included to access it from other hal layers. */
uint32 hal_clocks_get_core_clock_mid_value (void)
{
   18de4:	b570      	push	{r4, r5, r6, lr}
    return ( CLK_FREQ_NREFCLKS + 1 ) & CLK_FREQ_NREFCLKS_REFERENCE_MASK;
   18de6:	4d12      	ldr	r5, [pc, #72]	; (18e30 <hal_clocks_get_core_clock_mid_value+0x4c>)
    assert (hal_clocks_ring_oscillator_get_average_period() != 0);
   18de8:	4a12      	ldr	r2, [pc, #72]	; (18e34 <hal_clocks_get_core_clock_mid_value+0x50>)
    return ( CLK_FREQ_NREFCLKS + 1 ) & CLK_FREQ_NREFCLKS_REFERENCE_MASK;
   18dea:	682b      	ldr	r3, [r5, #0]
   18dec:	4676      	mov	r6, lr
    assert (hal_clocks_ring_oscillator_get_average_period() != 0);
   18dee:	b29b      	uxth	r3, r3
   18df0:	4293      	cmp	r3, r2
   18df2:	d103      	bne.n	18dfc <hal_clocks_get_core_clock_mid_value+0x18>
   18df4:	4671      	mov	r1, lr
   18df6:	2016      	movs	r0, #22
   18df8:	f7e8 fe8a 	bl	1b10 <panic>
    return (CLK_GATE_SYS & CLK_GATE_DIVIDE_RATIO_MASK);
   18dfc:	4c0e      	ldr	r4, [pc, #56]	; (18e38 <hal_clocks_get_core_clock_mid_value+0x54>)
   18dfe:	6823      	ldr	r3, [r4, #0]
    assert (hal_clocks_system_get_divide_ratio() != 0);
   18e00:	b2db      	uxtb	r3, r3
   18e02:	2b00      	cmp	r3, #0
   18e04:	d103      	bne.n	18e0e <hal_clocks_get_core_clock_mid_value+0x2a>
   18e06:	0031      	movs	r1, r6
   18e08:	2016      	movs	r0, #22
   18e0a:	f7e8 fe81 	bl	1b10 <panic>
    return CLK_FREQ_HIGHTARGET;
   18e0e:	4b0b      	ldr	r3, [pc, #44]	; (18e3c <hal_clocks_get_core_clock_mid_value+0x58>)
   18e10:	6818      	ldr	r0, [r3, #0]
    return CLK_FREQ_LOWTARGET;
   18e12:	4b0b      	ldr	r3, [pc, #44]	; (18e40 <hal_clocks_get_core_clock_mid_value+0x5c>)

    uint32 mean = ( hal_clocks_ring_oscillator_get_high_target() / 2 ) + (hal_clocks_ring_oscillator_get_low_target() / 2 );
   18e14:	0840      	lsrs	r0, r0, #1
    return CLK_FREQ_LOWTARGET;
   18e16:	681a      	ldr	r2, [r3, #0]
    return ( CLK_FREQ_NREFCLKS + 1 ) & CLK_FREQ_NREFCLKS_REFERENCE_MASK;
   18e18:	6829      	ldr	r1, [r5, #0]
    return (CLK_GATE_SYS & CLK_GATE_DIVIDE_RATIO_MASK);
   18e1a:	6823      	ldr	r3, [r4, #0]
    uint32 mean = ( hal_clocks_ring_oscillator_get_high_target() / 2 ) + (hal_clocks_ring_oscillator_get_low_target() / 2 );
   18e1c:	0852      	lsrs	r2, r2, #1
    return ( CLK_FREQ_NREFCLKS + 1 ) & CLK_FREQ_NREFCLKS_REFERENCE_MASK;
   18e1e:	3101      	adds	r1, #1
    uint32 mean = ( hal_clocks_ring_oscillator_get_high_target() / 2 ) + (hal_clocks_ring_oscillator_get_low_target() / 2 );
   18e20:	1880      	adds	r0, r0, r2
    return ( mean * CLOCKS_REFERENCE_CLOCK_FREQ ) / ( hal_clocks_ring_oscillator_get_average_period() * hal_clocks_system_get_divide_ratio() );
   18e22:	b28a      	uxth	r2, r1
   18e24:	b2d9      	uxtb	r1, r3
   18e26:	4351      	muls	r1, r2
   18e28:	03c0      	lsls	r0, r0, #15
   18e2a:	f7e7 fac5 	bl	3b8 <__udivsi3>
}
   18e2e:	bd70      	pop	{r4, r5, r6, pc}
   18e30:	4000000c 	.word	0x4000000c
   18e34:	0000ffff 	.word	0x0000ffff
   18e38:	40000028 	.word	0x40000028
   18e3c:	40000018 	.word	0x40000018
   18e40:	4000001c 	.word	0x4000001c

00018e44 <hal_dma_ch_ctrl_data_structure_fill>:
 * @param cfg the structured DMAC channel configuration
 * @return filled control data configuration to set to the DMA channel register
 */
static uint32 hal_dma_ch_ctrl_data_config_fill(const hal_dma_ch_configuration *cfg)
{
    return HAL_DMA_DST_INC_BITS((uint32)cfg->dst_inc) | HAL_DMA_DST_SIZE_BITS((uint32)cfg->data_width) | //lint !e701 shifting int left is OK
   18e44:	7a0a      	ldrb	r2, [r1, #8]
   18e46:	7a8b      	ldrb	r3, [r1, #10]
/** Fill the DMA channel control data structure based on the DMA channel configuration of driver
 * @param ch_ctrl DMA channel control data structure
 * @param cfg the structured DMAC channel configuration
 */
static void hal_dma_ch_ctrl_data_structure_fill(dma_ch_ctrl_t *ch_ctrl, const hal_dma_ch_configuration *cfg)
{
   18e48:	b510      	push	{r4, lr}
    return HAL_DMA_DST_INC_BITS((uint32)cfg->dst_inc) | HAL_DMA_DST_SIZE_BITS((uint32)cfg->data_width) | //lint !e701 shifting int left is OK
   18e4a:	079b      	lsls	r3, r3, #30
   18e4c:	0714      	lsls	r4, r2, #28
   18e4e:	4323      	orrs	r3, r4
           HAL_DMA_NEXT_USE_BURST_BITS((uint32)cfg->next_use_burst) | HAL_DMA_CYCLE_TYPE_BITS((uint32)cfg->cycle_type);
   18e50:	7b8c      	ldrb	r4, [r1, #14]
           HAL_DMA_SRC_INC_BITS((uint32)cfg->src_inc) | HAL_DMA_SRC_SIZE_BITS((uint32)cfg->data_width) |
   18e52:	0612      	lsls	r2, r2, #24
           HAL_DMA_NEXT_USE_BURST_BITS((uint32)cfg->next_use_burst) | HAL_DMA_CYCLE_TYPE_BITS((uint32)cfg->cycle_type);
   18e54:	4323      	orrs	r3, r4
           HAL_DMA_SRC_INC_BITS((uint32)cfg->src_inc) | HAL_DMA_SRC_SIZE_BITS((uint32)cfg->data_width) |
   18e56:	7a4c      	ldrb	r4, [r1, #9]
   18e58:	06a4      	lsls	r4, r4, #26
           HAL_DMA_NEXT_USE_BURST_BITS((uint32)cfg->next_use_burst) | HAL_DMA_CYCLE_TYPE_BITS((uint32)cfg->cycle_type);
   18e5a:	4323      	orrs	r3, r4
   18e5c:	4313      	orrs	r3, r2
           HAL_DMA_R_POWER_BITS((uint32)cfg->r_power) | HAL_DMA_N_MINUS_1_BITS((uint32)(cfg->transfer_num - 1)) |
   18e5e:	7bca      	ldrb	r2, [r1, #15]
   18e60:	0392      	lsls	r2, r2, #14
           HAL_DMA_NEXT_USE_BURST_BITS((uint32)cfg->next_use_burst) | HAL_DMA_CYCLE_TYPE_BITS((uint32)cfg->cycle_type);
   18e62:	4313      	orrs	r3, r2
   18e64:	7aca      	ldrb	r2, [r1, #11]
   18e66:	00d2      	lsls	r2, r2, #3
   18e68:	4313      	orrs	r3, r2
           HAL_DMA_R_POWER_BITS((uint32)cfg->r_power) | HAL_DMA_N_MINUS_1_BITS((uint32)(cfg->transfer_num - 1)) |
   18e6a:	898a      	ldrh	r2, [r1, #12]
   18e6c:	3a01      	subs	r2, #1
   18e6e:	0112      	lsls	r2, r2, #4
           HAL_DMA_NEXT_USE_BURST_BITS((uint32)cfg->next_use_burst) | HAL_DMA_CYCLE_TYPE_BITS((uint32)cfg->cycle_type);
   18e70:	4313      	orrs	r3, r2
    ch_ctrl->Ctrl = hal_dma_ch_ctrl_data_config_fill(cfg);
   18e72:	6083      	str	r3, [r0, #8]
    ch_ctrl->SrcEndAddr = cfg->src + ((uint32)(cfg->transfer_num - 1) << hal_dma_addr_inc_shift[cfg->src_inc]);
   18e74:	7a4c      	ldrb	r4, [r1, #9]
   18e76:	4a08      	ldr	r2, [pc, #32]	; (18e98 <hal_dma_ch_ctrl_data_structure_fill+0x54>)
   18e78:	898b      	ldrh	r3, [r1, #12]
   18e7a:	5d14      	ldrb	r4, [r2, r4]
   18e7c:	3b01      	subs	r3, #1
   18e7e:	40a3      	lsls	r3, r4
   18e80:	680c      	ldr	r4, [r1, #0]
   18e82:	191b      	adds	r3, r3, r4
   18e84:	6003      	str	r3, [r0, #0]
    ch_ctrl->DestEndAddr = cfg->dst + ((uint32)(cfg->transfer_num - 1) << hal_dma_addr_inc_shift[cfg->dst_inc]);
   18e86:	7a8c      	ldrb	r4, [r1, #10]
   18e88:	898b      	ldrh	r3, [r1, #12]
   18e8a:	5d12      	ldrb	r2, [r2, r4]
   18e8c:	3b01      	subs	r3, #1
   18e8e:	4093      	lsls	r3, r2
   18e90:	684a      	ldr	r2, [r1, #4]
   18e92:	189b      	adds	r3, r3, r2
   18e94:	6043      	str	r3, [r0, #4]
}
   18e96:	bd10      	pop	{r4, pc}
   18e98:	00025585 	.word	0x00025585

00018e9c <hal_dma_init>:
{
   18e9c:	b510      	push	{r4, lr}
    if( !hal_dma_initialised )
   18e9e:	4c0d      	ldr	r4, [pc, #52]	; (18ed4 <hal_dma_init+0x38>)
   18ea0:	7823      	ldrb	r3, [r4, #0]
   18ea2:	2b00      	cmp	r3, #0
   18ea4:	d10e      	bne.n	18ec4 <hal_dma_init+0x28>
/** Check whether the DMAC clock is enabled
 * @return true if the clock is enabled or false otherwise
 */
static inline bool hal_dma_clock_is_enabled(void)
{
    return (CLKEN_REG & CLKEN_REG_DMA_MASK) != 0;
   18ea6:	4a0c      	ldr	r2, [pc, #48]	; (18ed8 <hal_dma_init+0x3c>)
   18ea8:	3304      	adds	r3, #4
   18eaa:	6811      	ldr	r1, [r2, #0]
        if (hal_dma_clock_is_enabled() || hal_dma_enable_clock())
   18eac:	4219      	tst	r1, r3
   18eae:	d00a      	beq.n	18ec6 <hal_dma_init+0x2a>
    CLKEN_REG_BITCLR = CLKEN_REG_DMA_MASK;
   18eb0:	2204      	movs	r2, #4
   18eb2:	4b0a      	ldr	r3, [pc, #40]	; (18edc <hal_dma_init+0x40>)
   18eb4:	601a      	str	r2, [r3, #0]
        memset(hal_dma_channel, 0, sizeof(hal_dma_channel));
   18eb6:	2250      	movs	r2, #80	; 0x50
   18eb8:	2100      	movs	r1, #0
   18eba:	4809      	ldr	r0, [pc, #36]	; (18ee0 <hal_dma_init+0x44>)
   18ebc:	f7e7 fa10 	bl	2e0 <memset>
        hal_dma_initialised = true;
   18ec0:	2301      	movs	r3, #1
   18ec2:	7023      	strb	r3, [r4, #0]
}
   18ec4:	bd10      	pop	{r4, pc}
    CLKEN_REG_BITSET = CLKEN_REG_DMA_MASK;
   18ec6:	4907      	ldr	r1, [pc, #28]	; (18ee4 <hal_dma_init+0x48>)
   18ec8:	600b      	str	r3, [r1, #0]
    return (CLKEN_REG & CLKEN_REG_DMA_MASK) != 0;
   18eca:	6812      	ldr	r2, [r2, #0]
        if (hal_dma_clock_is_enabled() || hal_dma_enable_clock())
   18ecc:	421a      	tst	r2, r3
   18ece:	d1ef      	bne.n	18eb0 <hal_dma_init+0x14>
   18ed0:	e7f1      	b.n	18eb6 <hal_dma_init+0x1a>
   18ed2:	46c0      	nop			; (mov r8, r8)
   18ed4:	01002b74 	.word	0x01002b74
   18ed8:	40004048 	.word	0x40004048
   18edc:	40004848 	.word	0x40004848
   18ee0:	01002b24 	.word	0x01002b24
   18ee4:	40004448 	.word	0x40004448

00018ee8 <hal_dma_claim>:
{
   18ee8:	b510      	push	{r4, lr}
    assert(hal_dma_initialised);
   18eea:	4c11      	ldr	r4, [pc, #68]	; (18f30 <hal_dma_claim+0x48>)
   18eec:	7823      	ldrb	r3, [r4, #0]
   18eee:	2b00      	cmp	r3, #0
   18ef0:	d103      	bne.n	18efa <hal_dma_claim+0x12>
   18ef2:	4671      	mov	r1, lr
   18ef4:	2016      	movs	r0, #22
   18ef6:	f7e8 fe0b 	bl	1b10 <panic>
    if (!hal_dma_initialised)
   18efa:	7823      	ldrb	r3, [r4, #0]
   18efc:	2b00      	cmp	r3, #0
   18efe:	d015      	beq.n	18f2c <hal_dma_claim+0x44>
    CLKEN_REG_BITSET = CLKEN_REG_DMA_MASK;
   18f00:	2304      	movs	r3, #4
   18f02:	4a0c      	ldr	r2, [pc, #48]	; (18f34 <hal_dma_claim+0x4c>)
   18f04:	6013      	str	r3, [r2, #0]
    return (CLKEN_REG & CLKEN_REG_DMA_MASK) != 0;
   18f06:	4a0c      	ldr	r2, [pc, #48]	; (18f38 <hal_dma_claim+0x50>)
   18f08:	6812      	ldr	r2, [r2, #0]
    if (hal_dma_enable_clock())
   18f0a:	421a      	tst	r2, r3
   18f0c:	d00e      	beq.n	18f2c <hal_dma_claim+0x44>
 */
static void hal_dma_enable_controller(void)
{
    volatile dma_ctrl_t *dmac_regs = hal_dma_get_dmac();

    dmac_regs->DMA_CFG = DMA_CONTROLLER_ENABLE_MASK;
   18f0e:	2201      	movs	r2, #1
   18f10:	4b0a      	ldr	r3, [pc, #40]	; (18f3c <hal_dma_claim+0x54>)
            hal_dma_channel[ch].state = HAL_DMA_CH_STATE_CLOSED;
   18f12:	2000      	movs	r0, #0
    dmac_regs->DMA_CFG = DMA_CONTROLLER_ENABLE_MASK;
   18f14:	605a      	str	r2, [r3, #4]
    dmac_regs->CTRL_BASE_PTR = (uint32)hal_dma_ch_ctrl;
   18f16:	4a0a      	ldr	r2, [pc, #40]	; (18f40 <hal_dma_claim+0x58>)
   18f18:	609a      	str	r2, [r3, #8]
            hal_dma_channel[ch].state = HAL_DMA_CH_STATE_CLOSED;
   18f1a:	4b0a      	ldr	r3, [pc, #40]	; (18f44 <hal_dma_claim+0x5c>)
   18f1c:	001a      	movs	r2, r3
   18f1e:	7098      	strb	r0, [r3, #2]
   18f20:	7598      	strb	r0, [r3, #22]
   18f22:	322a      	adds	r2, #42	; 0x2a
   18f24:	333e      	adds	r3, #62	; 0x3e
   18f26:	7010      	strb	r0, [r2, #0]
   18f28:	7018      	strb	r0, [r3, #0]
}
   18f2a:	bd10      	pop	{r4, pc}
        return HAL_DMA_RET_NOT_INITIALIZED;
   18f2c:	2001      	movs	r0, #1
   18f2e:	e7fc      	b.n	18f2a <hal_dma_claim+0x42>
   18f30:	01002b74 	.word	0x01002b74
   18f34:	40004448 	.word	0x40004448
   18f38:	40004048 	.word	0x40004048
   18f3c:	40005000 	.word	0x40005000
   18f40:	01002a80 	.word	0x01002a80
   18f44:	01002b24 	.word	0x01002b24

00018f48 <hal_dma_is_claimed>:
{
   18f48:	b510      	push	{r4, lr}
    assert(hal_dma_initialised);
   18f4a:	4c08      	ldr	r4, [pc, #32]	; (18f6c <hal_dma_is_claimed+0x24>)
   18f4c:	7823      	ldrb	r3, [r4, #0]
   18f4e:	2b00      	cmp	r3, #0
   18f50:	d103      	bne.n	18f5a <hal_dma_is_claimed+0x12>
   18f52:	4671      	mov	r1, lr
   18f54:	2016      	movs	r0, #22
   18f56:	f7e8 fddb 	bl	1b10 <panic>
    return (hal_dma_initialised && hal_dma_clock_is_enabled());
   18f5a:	2000      	movs	r0, #0
   18f5c:	7823      	ldrb	r3, [r4, #0]
   18f5e:	4283      	cmp	r3, r0
   18f60:	d003      	beq.n	18f6a <hal_dma_is_claimed+0x22>
    return (CLKEN_REG & CLKEN_REG_DMA_MASK) != 0;
   18f62:	4b03      	ldr	r3, [pc, #12]	; (18f70 <hal_dma_is_claimed+0x28>)
   18f64:	6818      	ldr	r0, [r3, #0]
    return (hal_dma_initialised && hal_dma_clock_is_enabled());
   18f66:	0740      	lsls	r0, r0, #29
   18f68:	0fc0      	lsrs	r0, r0, #31
}
   18f6a:	bd10      	pop	{r4, pc}
   18f6c:	01002b74 	.word	0x01002b74
   18f70:	40004048 	.word	0x40004048

00018f74 <hal_dma_ch_configure_peripheral_feature>:
    switch (hal_dma_channel[ch].periph)
   18f74:	2314      	movs	r3, #20
{
   18f76:	b570      	push	{r4, r5, r6, lr}
    switch (hal_dma_channel[ch].periph)
   18f78:	4343      	muls	r3, r0
   18f7a:	4c0b      	ldr	r4, [pc, #44]	; (18fa8 <hal_dma_ch_configure_peripheral_feature+0x34>)
{
   18f7c:	0006      	movs	r6, r0
    switch (hal_dma_channel[ch].periph)
   18f7e:	18e3      	adds	r3, r4, r3
   18f80:	785a      	ldrb	r2, [r3, #1]
{
   18f82:	000d      	movs	r5, r1
    switch (hal_dma_channel[ch].periph)
   18f84:	2a00      	cmp	r2, #0
   18f86:	d103      	bne.n	18f90 <hal_dma_ch_configure_peripheral_feature+0x1c>
            if (feature == NULL)
   18f88:	2900      	cmp	r1, #0
   18f8a:	d107      	bne.n	18f9c <hal_dma_ch_configure_peripheral_feature+0x28>
                hal_dma_channel[ch].periph_feature.use_burst = false;
   18f8c:	70d9      	strb	r1, [r3, #3]
}
   18f8e:	bd70      	pop	{r4, r5, r6, pc}
            assert(feature != NULL);
   18f90:	2900      	cmp	r1, #0
   18f92:	d103      	bne.n	18f9c <hal_dma_ch_configure_peripheral_feature+0x28>
   18f94:	4671      	mov	r1, lr
   18f96:	2016      	movs	r0, #22
   18f98:	f7e8 fdba 	bl	1b10 <panic>
    memcpy(&hal_dma_channel[ch].periph_feature, feature, sizeof(*feature));
   18f9c:	2314      	movs	r3, #20
   18f9e:	435e      	muls	r6, r3
   18fa0:	782a      	ldrb	r2, [r5, #0]
   18fa2:	19a4      	adds	r4, r4, r6
   18fa4:	70e2      	strb	r2, [r4, #3]
   18fa6:	e7f2      	b.n	18f8e <hal_dma_ch_configure_peripheral_feature+0x1a>
   18fa8:	01002b24 	.word	0x01002b24

00018fac <hal_dma_ch_register_peripheral_prepare_callback>:
    hal_dma_ch_peripheral_prepare_callback[ch] = callback;
   18fac:	4b01      	ldr	r3, [pc, #4]	; (18fb4 <hal_dma_ch_register_peripheral_prepare_callback+0x8>)
   18fae:	0080      	lsls	r0, r0, #2
   18fb0:	50c1      	str	r1, [r0, r3]
}
   18fb2:	4770      	bx	lr
   18fb4:	01002b14 	.word	0x01002b14

00018fb8 <hal_dma_ch_deregister_peripheral_prepare_callback>:
    hal_dma_ch_peripheral_prepare_callback[ch] = NULL;
   18fb8:	2200      	movs	r2, #0
   18fba:	4b02      	ldr	r3, [pc, #8]	; (18fc4 <hal_dma_ch_deregister_peripheral_prepare_callback+0xc>)
   18fbc:	0080      	lsls	r0, r0, #2
   18fbe:	50c2      	str	r2, [r0, r3]
}
   18fc0:	4770      	bx	lr
   18fc2:	46c0      	nop			; (mov r8, r8)
   18fc4:	01002b14 	.word	0x01002b14

00018fc8 <hal_dma_ch_state_get>:
    state = hal_dma_channel[ch].state;
   18fc8:	2314      	movs	r3, #20
   18fca:	4343      	muls	r3, r0
   18fcc:	4801      	ldr	r0, [pc, #4]	; (18fd4 <hal_dma_ch_state_get+0xc>)
   18fce:	18c0      	adds	r0, r0, r3
    return state;
   18fd0:	7880      	ldrb	r0, [r0, #2]
}
   18fd2:	4770      	bx	lr
   18fd4:	01002b24 	.word	0x01002b24

00018fd8 <hal_dma_ch_state_set>:
    hal_dma_channel[ch].state = state;
   18fd8:	2314      	movs	r3, #20
   18fda:	4343      	muls	r3, r0
   18fdc:	4801      	ldr	r0, [pc, #4]	; (18fe4 <hal_dma_ch_state_set+0xc>)
   18fde:	18c0      	adds	r0, r0, r3
   18fe0:	7081      	strb	r1, [r0, #2]
}
   18fe2:	4770      	bx	lr
   18fe4:	01002b24 	.word	0x01002b24

00018fe8 <hal_dma_ch_config_buffer_init>:
{
   18fe8:	b570      	push	{r4, r5, r6, lr}
   18fea:	0005      	movs	r5, r0
    assert(ch < HAL_DMA_CHANNEL_MAX_NUM);
   18fec:	2803      	cmp	r0, #3
   18fee:	d903      	bls.n	18ff8 <hal_dma_ch_config_buffer_init+0x10>
   18ff0:	4671      	mov	r1, lr
   18ff2:	2016      	movs	r0, #22
   18ff4:	f7e8 fd8c 	bl	1b10 <panic>
    cfg_ctrl->config_buffer = irmalloc(HAL_DMA_CH_TRANSFER_QUEUE_MAX_SIZE * sizeof(hal_dma_ch_configuration));
   18ff8:	20f0      	movs	r0, #240	; 0xf0
   18ffa:	f7f9 fd01 	bl	12a00 <irmalloc>
   18ffe:	2314      	movs	r3, #20
   19000:	436b      	muls	r3, r5
   19002:	4c0e      	ldr	r4, [pc, #56]	; (1903c <hal_dma_ch_config_buffer_init+0x54>)
   19004:	18e3      	adds	r3, r4, r3
   19006:	60d8      	str	r0, [r3, #12]
    if (cfg_ctrl->config_buffer == NULL)
   19008:	2800      	cmp	r0, #0
   1900a:	d103      	bne.n	19014 <hal_dma_ch_config_buffer_init+0x2c>
        panic(PANIC_DMA, PANIC_HAL_DMA_MEMORY_ALLOCATION_FAILED);
   1900c:	2180      	movs	r1, #128	; 0x80
   1900e:	3023      	adds	r0, #35	; 0x23
   19010:	f7e8 fd7e 	bl	1b10 <panic>
    memset(cfg_ctrl->config_buffer, 0, HAL_DMA_CH_TRANSFER_QUEUE_MAX_SIZE * sizeof(hal_dma_ch_configuration));
   19014:	2314      	movs	r3, #20
   19016:	435d      	muls	r5, r3
   19018:	1964      	adds	r4, r4, r5
   1901a:	2100      	movs	r1, #0
   1901c:	22f0      	movs	r2, #240	; 0xf0
   1901e:	68e0      	ldr	r0, [r4, #12]
   19020:	f7e7 f95e 	bl	2e0 <memset>
   19024:	2300      	movs	r3, #0
        cfg_ctrl->config_buffer[i].index = i;
   19026:	2118      	movs	r1, #24
   19028:	000a      	movs	r2, r1
   1902a:	435a      	muls	r2, r3
   1902c:	68e0      	ldr	r0, [r4, #12]
   1902e:	1882      	adds	r2, r0, r2
   19030:	7493      	strb	r3, [r2, #18]
   19032:	3301      	adds	r3, #1
    for (uint8 i = 0; i < HAL_DMA_CH_TRANSFER_QUEUE_MAX_SIZE; i++)
   19034:	2b0a      	cmp	r3, #10
   19036:	d1f7      	bne.n	19028 <hal_dma_ch_config_buffer_init+0x40>
}
   19038:	bd70      	pop	{r4, r5, r6, pc}
   1903a:	46c0      	nop			; (mov r8, r8)
   1903c:	01002b24 	.word	0x01002b24

00019040 <hal_dma_ch_config_buffer_get_free_config>:
{
   19040:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
   19042:	4676      	mov	r6, lr
   19044:	0007      	movs	r7, r0
   19046:	000c      	movs	r4, r1
    assert(ch < HAL_DMA_CHANNEL_MAX_NUM);
   19048:	2803      	cmp	r0, #3
   1904a:	d903      	bls.n	19054 <hal_dma_ch_config_buffer_get_free_config+0x14>
   1904c:	4671      	mov	r1, lr
   1904e:	2016      	movs	r0, #22
   19050:	f7e8 fd5e 	bl	1b10 <panic>
    assert(index < HAL_DMA_CH_TRANSFER_QUEUE_MAX_SIZE);
   19054:	2c09      	cmp	r4, #9
   19056:	d903      	bls.n	19060 <hal_dma_ch_config_buffer_get_free_config+0x20>
   19058:	0031      	movs	r1, r6
   1905a:	2016      	movs	r0, #22
   1905c:	f7e8 fd58 	bl	1b10 <panic>
    state = hal_dma_channel[ch].state;
   19060:	2314      	movs	r3, #20
   19062:	437b      	muls	r3, r7
   19064:	4d16      	ldr	r5, [pc, #88]	; (190c0 <hal_dma_ch_config_buffer_get_free_config+0x80>)
   19066:	18eb      	adds	r3, r5, r3
   19068:	789a      	ldrb	r2, [r3, #2]
    assert(config_buffer_info->config_buffer != NULL);
   1906a:	68db      	ldr	r3, [r3, #12]
    state = hal_dma_channel[ch].state;
   1906c:	9201      	str	r2, [sp, #4]
    assert(config_buffer_info->config_buffer != NULL);
   1906e:	2b00      	cmp	r3, #0
   19070:	d103      	bne.n	1907a <hal_dma_ch_config_buffer_get_free_config+0x3a>
   19072:	0031      	movs	r1, r6
   19074:	2016      	movs	r0, #22
   19076:	f7e8 fd4b 	bl	1b10 <panic>
    if (ch_state != HAL_DMA_CH_STATE_IDLE)
   1907a:	9b01      	ldr	r3, [sp, #4]
   1907c:	2b01      	cmp	r3, #1
   1907e:	d001      	beq.n	19084 <hal_dma_ch_config_buffer_get_free_config+0x44>
        non_os_enter_critical();
   19080:	f7ff f898 	bl	181b4 <non_os_enter_critical>
    if ((uint16)config_buffer_info->used_configs + (uint16)index >= HAL_DMA_CH_TRANSFER_QUEUE_MAX_SIZE) //lint !e456
   19084:	2314      	movs	r3, #20
   19086:	437b      	muls	r3, r7
   19088:	18eb      	adds	r3, r5, r3
   1908a:	7c5a      	ldrb	r2, [r3, #17]
        config = NULL;
   1908c:	2600      	movs	r6, #0
    if ((uint16)config_buffer_info->used_configs + (uint16)index >= HAL_DMA_CH_TRANSFER_QUEUE_MAX_SIZE) //lint !e456
   1908e:	1911      	adds	r1, r2, r4
   19090:	2909      	cmp	r1, #9
   19092:	dc0e      	bgt.n	190b2 <hal_dma_ch_config_buffer_get_free_config+0x72>
    uint8 aim_index = start_index + increment;
   19094:	7c1e      	ldrb	r6, [r3, #16]
   19096:	1992      	adds	r2, r2, r6
   19098:	18a4      	adds	r4, r4, r2
   1909a:	b2e4      	uxtb	r4, r4
    return (aim_index >= HAL_DMA_CH_TRANSFER_QUEUE_MAX_SIZE) ? (aim_index - HAL_DMA_CH_TRANSFER_QUEUE_MAX_SIZE) : aim_index;
   1909c:	2c09      	cmp	r4, #9
   1909e:	d901      	bls.n	190a4 <hal_dma_ch_config_buffer_get_free_config+0x64>
   190a0:	3c0a      	subs	r4, #10
   190a2:	b2e4      	uxtb	r4, r4
        config = &config_buffer_info->config_buffer[free_config_index];
   190a4:	2314      	movs	r3, #20
   190a6:	2618      	movs	r6, #24
   190a8:	435f      	muls	r7, r3
   190aa:	4374      	muls	r4, r6
   190ac:	19ed      	adds	r5, r5, r7
   190ae:	68ee      	ldr	r6, [r5, #12]
   190b0:	1936      	adds	r6, r6, r4
    if (ch_state != HAL_DMA_CH_STATE_IDLE)
   190b2:	9b01      	ldr	r3, [sp, #4]
   190b4:	2b01      	cmp	r3, #1
   190b6:	d001      	beq.n	190bc <hal_dma_ch_config_buffer_get_free_config+0x7c>
        non_os_exit_critical();
   190b8:	f7ff f890 	bl	181dc <non_os_exit_critical>
}
   190bc:	0030      	movs	r0, r6
   190be:	bdfe      	pop	{r1, r2, r3, r4, r5, r6, r7, pc}
   190c0:	01002b24 	.word	0x01002b24

000190c4 <hal_dma_ch_config_buffer_get_first_used>:
{
   190c4:	b570      	push	{r4, r5, r6, lr}
   190c6:	4676      	mov	r6, lr
   190c8:	0005      	movs	r5, r0
    assert(ch < HAL_DMA_CHANNEL_MAX_NUM);
   190ca:	2803      	cmp	r0, #3
   190cc:	d903      	bls.n	190d6 <hal_dma_ch_config_buffer_get_first_used+0x12>
   190ce:	4671      	mov	r1, lr
   190d0:	2016      	movs	r0, #22
   190d2:	f7e8 fd1d 	bl	1b10 <panic>
    assert(config_buffer_info->config_buffer != NULL);
   190d6:	2214      	movs	r2, #20
   190d8:	436a      	muls	r2, r5
   190da:	4c0a      	ldr	r4, [pc, #40]	; (19104 <hal_dma_ch_config_buffer_get_first_used+0x40>)
   190dc:	18a2      	adds	r2, r4, r2
   190de:	68d3      	ldr	r3, [r2, #12]
   190e0:	2b00      	cmp	r3, #0
   190e2:	d103      	bne.n	190ec <hal_dma_ch_config_buffer_get_first_used+0x28>
   190e4:	0031      	movs	r1, r6
   190e6:	2016      	movs	r0, #22
   190e8:	f7e8 fd12 	bl	1b10 <panic>
    if (config_buffer_info->used_configs != 0)
   190ec:	2314      	movs	r3, #20
   190ee:	436b      	muls	r3, r5
   190f0:	18e3      	adds	r3, r4, r3
   190f2:	7c5a      	ldrb	r2, [r3, #17]
    return NULL;
   190f4:	1e10      	subs	r0, r2, #0
    if (config_buffer_info->used_configs != 0)
   190f6:	d004      	beq.n	19102 <hal_dma_ch_config_buffer_get_first_used+0x3e>
        return &config_buffer_info->config_buffer[config_buffer_info->config_buffer_head_index];
   190f8:	2018      	movs	r0, #24
   190fa:	7c1a      	ldrb	r2, [r3, #16]
   190fc:	4342      	muls	r2, r0
   190fe:	68d8      	ldr	r0, [r3, #12]
   19100:	1880      	adds	r0, r0, r2
}
   19102:	bd70      	pop	{r4, r5, r6, pc}
   19104:	01002b24 	.word	0x01002b24

00019108 <hal_dma_ch_config_buffer_add_config>:
{
   19108:	b510      	push	{r4, lr}
   1910a:	0004      	movs	r4, r0
    assert(ch < HAL_DMA_CHANNEL_MAX_NUM);
   1910c:	2803      	cmp	r0, #3
   1910e:	d903      	bls.n	19118 <hal_dma_ch_config_buffer_add_config+0x10>
   19110:	4671      	mov	r1, lr
   19112:	2016      	movs	r0, #22
   19114:	f7e8 fcfc 	bl	1b10 <panic>
    state = hal_dma_channel[ch].state;
   19118:	2014      	movs	r0, #20
   1911a:	4360      	muls	r0, r4
   1911c:	4c08      	ldr	r4, [pc, #32]	; (19140 <hal_dma_ch_config_buffer_add_config+0x38>)
   1911e:	1824      	adds	r4, r4, r0
    if (ch_state != HAL_DMA_CH_STATE_IDLE)
   19120:	78a3      	ldrb	r3, [r4, #2]
   19122:	2b01      	cmp	r3, #1
   19124:	d007      	beq.n	19136 <hal_dma_ch_config_buffer_add_config+0x2e>
        non_os_enter_critical();
   19126:	f7ff f845 	bl	181b4 <non_os_enter_critical>
        ++config_buffer_info->used_configs;
   1912a:	7c63      	ldrb	r3, [r4, #17]
   1912c:	3301      	adds	r3, #1
   1912e:	7463      	strb	r3, [r4, #17]
        non_os_exit_critical();
   19130:	f7ff f854 	bl	181dc <non_os_exit_critical>
}
   19134:	bd10      	pop	{r4, pc}
    ++config_buffer_info->used_configs;
   19136:	7c63      	ldrb	r3, [r4, #17]
   19138:	3301      	adds	r3, #1
   1913a:	7463      	strb	r3, [r4, #17]
   1913c:	e7fa      	b.n	19134 <hal_dma_ch_config_buffer_add_config+0x2c>
   1913e:	46c0      	nop			; (mov r8, r8)
   19140:	01002b24 	.word	0x01002b24

00019144 <hal_dma_ch_config_buffer_remove_config>:
{
   19144:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
   19146:	4677      	mov	r7, lr
   19148:	0006      	movs	r6, r0
   1914a:	000d      	movs	r5, r1
    assert(ch < HAL_DMA_CHANNEL_MAX_NUM);
   1914c:	2803      	cmp	r0, #3
   1914e:	d903      	bls.n	19158 <hal_dma_ch_config_buffer_remove_config+0x14>
   19150:	4671      	mov	r1, lr
   19152:	2016      	movs	r0, #22
   19154:	f7e8 fcdc 	bl	1b10 <panic>
   19158:	4c0f      	ldr	r4, [pc, #60]	; (19198 <hal_dma_ch_config_buffer_remove_config+0x54>)
    assert((dropped_count > 0) && (config_buffer_info->used_configs >= dropped_count));
   1915a:	2d00      	cmp	r5, #0
   1915c:	d005      	beq.n	1916a <hal_dma_ch_config_buffer_remove_config+0x26>
   1915e:	2314      	movs	r3, #20
   19160:	4373      	muls	r3, r6
   19162:	18e3      	adds	r3, r4, r3
   19164:	7c5b      	ldrb	r3, [r3, #17]
   19166:	42ab      	cmp	r3, r5
   19168:	d203      	bcs.n	19172 <hal_dma_ch_config_buffer_remove_config+0x2e>
   1916a:	0039      	movs	r1, r7
   1916c:	2016      	movs	r0, #22
   1916e:	f7e8 fccf 	bl	1b10 <panic>
    config_buffer_info->config_buffer_head_index = hal_dma_ch_config_buffer_calculate_index(config_buffer_info->config_buffer_head_index, dropped_count);
   19172:	2214      	movs	r2, #20
   19174:	0013      	movs	r3, r2
   19176:	4373      	muls	r3, r6
   19178:	18e3      	adds	r3, r4, r3
    uint8 aim_index = start_index + increment;
   1917a:	7c1b      	ldrb	r3, [r3, #16]
   1917c:	18eb      	adds	r3, r5, r3
   1917e:	b2db      	uxtb	r3, r3
    return (aim_index >= HAL_DMA_CH_TRANSFER_QUEUE_MAX_SIZE) ? (aim_index - HAL_DMA_CH_TRANSFER_QUEUE_MAX_SIZE) : aim_index;
   19180:	2b09      	cmp	r3, #9
   19182:	d901      	bls.n	19188 <hal_dma_ch_config_buffer_remove_config+0x44>
   19184:	3b0a      	subs	r3, #10
   19186:	b2db      	uxtb	r3, r3
    config_buffer_info->config_buffer_head_index = hal_dma_ch_config_buffer_calculate_index(config_buffer_info->config_buffer_head_index, dropped_count);
   19188:	4356      	muls	r6, r2
   1918a:	19a4      	adds	r4, r4, r6
   1918c:	7423      	strb	r3, [r4, #16]
    config_buffer_info->used_configs -= dropped_count;
   1918e:	7c63      	ldrb	r3, [r4, #17]
   19190:	1b5d      	subs	r5, r3, r5
   19192:	7465      	strb	r5, [r4, #17]
}
   19194:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
   19196:	46c0      	nop			; (mov r8, r8)
   19198:	01002b24 	.word	0x01002b24

0001919c <hal_dma_check_ch_transfer_config>:
    if ((config->transfer_num > HAL_DMA_CH_MAX_TRANSFER_NUM) || (config->transfer_num == 0))
   1919c:	8983      	ldrh	r3, [r0, #12]
   1919e:	2000      	movs	r0, #0
   191a0:	4a03      	ldr	r2, [pc, #12]	; (191b0 <hal_dma_check_ch_transfer_config+0x14>)
   191a2:	3b01      	subs	r3, #1
   191a4:	b29b      	uxth	r3, r3
   191a6:	429a      	cmp	r2, r3
   191a8:	4140      	adcs	r0, r0
}
   191aa:	b2c0      	uxtb	r0, r0
   191ac:	4770      	bx	lr
   191ae:	46c0      	nop			; (mov r8, r8)
   191b0:	000003ff 	.word	0x000003ff

000191b4 <hal_dma_transfer>:
{
   191b4:	b5f0      	push	{r4, r5, r6, r7, lr}
   191b6:	b08f      	sub	sp, #60	; 0x3c
   191b8:	4677      	mov	r7, lr
   191ba:	9002      	str	r0, [sp, #8]
   191bc:	9101      	str	r1, [sp, #4]
    assert(cfg != NULL);
   191be:	2900      	cmp	r1, #0
   191c0:	d103      	bne.n	191ca <hal_dma_transfer+0x16>
   191c2:	4671      	mov	r1, lr
   191c4:	2016      	movs	r0, #22
   191c6:	f7e8 fca3 	bl	1b10 <panic>
   191ca:	9b02      	ldr	r3, [sp, #8]
    dma_ch_ctrl_t *ch_ctrl = &hal_dma_ch_ctrl[ch];
   191cc:	4c76      	ldr	r4, [pc, #472]	; (193a8 <hal_dma_transfer+0x1f4>)
   191ce:	011b      	lsls	r3, r3, #4
   191d0:	9304      	str	r3, [sp, #16]
   191d2:	191c      	adds	r4, r3, r4
    switch (cfg->cycle_type)
   191d4:	9b01      	ldr	r3, [sp, #4]
   191d6:	7b98      	ldrb	r0, [r3, #14]
   191d8:	2807      	cmp	r0, #7
   191da:	d805      	bhi.n	191e8 <hal_dma_transfer+0x34>
   191dc:	f7e7 f8e2 	bl	3a4 <__gnu_thumb1_case_uqi>
   191e0:	04292907 	.word	0x04292907
   191e4:	2e042e04 	.word	0x2e042e04
        return false;
   191e8:	2000      	movs	r0, #0
}
   191ea:	b00f      	add	sp, #60	; 0x3c
   191ec:	bdf0      	pop	{r4, r5, r6, r7, pc}
        assert(false);
   191ee:	0039      	movs	r1, r7
   191f0:	2016      	movs	r0, #22
   191f2:	f7e8 fc8d 	bl	1b10 <panic>
   191f6:	2201      	movs	r2, #1
   191f8:	9b02      	ldr	r3, [sp, #8]
    if (hal_dma_channel[ch].periph_feature.use_burst)
   191fa:	9802      	ldr	r0, [sp, #8]
   191fc:	409a      	lsls	r2, r3
   191fe:	2314      	movs	r3, #20
   19200:	4343      	muls	r3, r0
   19202:	496a      	ldr	r1, [pc, #424]	; (193ac <hal_dma_transfer+0x1f8>)
   19204:	4d6a      	ldr	r5, [pc, #424]	; (193b0 <hal_dma_transfer+0x1fc>)
   19206:	18cb      	adds	r3, r1, r3
   19208:	78db      	ldrb	r3, [r3, #3]
   1920a:	2b00      	cmp	r3, #0
   1920c:	d100      	bne.n	19210 <hal_dma_transfer+0x5c>
   1920e:	e0be      	b.n	1938e <hal_dma_transfer+0x1da>
        dmac_regs->CHNL_USEBURST_SET = BIT(ch);
   19210:	61aa      	str	r2, [r5, #24]
 */
void hal_dma_enable_ch(HAL_DMA_CHANNEL ch)
{
    volatile dma_ctrl_t *dmac_regs = hal_dma_get_dmac();

    dmac_regs->CHNL_ENABLE_SET = BIT(ch);
   19212:	62aa      	str	r2, [r5, #40]	; 0x28
        if (hal_dma_ch_peripheral_prepare_callback[ch] != NULL)
   19214:	9b02      	ldr	r3, [sp, #8]
   19216:	0098      	lsls	r0, r3, #2
   19218:	4b66      	ldr	r3, [pc, #408]	; (193b4 <hal_dma_transfer+0x200>)
   1921a:	58c4      	ldr	r4, [r0, r3]
   1921c:	2314      	movs	r3, #20
   1921e:	2c00      	cmp	r4, #0
   19220:	d100      	bne.n	19224 <hal_dma_transfer+0x70>
   19222:	e0b6      	b.n	19392 <hal_dma_transfer+0x1de>
            hal_dma_ch_peripheral_prepare_callback[ch](hal_dma_channel[ch].periph);
   19224:	9a02      	ldr	r2, [sp, #8]
   19226:	4353      	muls	r3, r2
   19228:	18cb      	adds	r3, r1, r3
   1922a:	7858      	ldrb	r0, [r3, #1]
   1922c:	47a0      	blx	r4
   1922e:	2001      	movs	r0, #1
   19230:	e7db      	b.n	191ea <hal_dma_transfer+0x36>
        hal_dma_ch_ctrl_data_structure_fill(ch_ctrl, cfg);
   19232:	9901      	ldr	r1, [sp, #4]
   19234:	0020      	movs	r0, r4
   19236:	f7ff fe05 	bl	18e44 <hal_dma_ch_ctrl_data_structure_fill>
   1923a:	e7dc      	b.n	191f6 <hal_dma_transfer+0x42>
    uint8 cfg_index = cfg->index;
   1923c:	9b01      	ldr	r3, [sp, #4]
        assert(hal_dma_ch_incontinuous_config[ch] != NULL);
   1923e:	4e5e      	ldr	r6, [pc, #376]	; (193b8 <hal_dma_transfer+0x204>)
    uint8 cfg_index = cfg->index;
   19240:	7c9b      	ldrb	r3, [r3, #18]
   19242:	9303      	str	r3, [sp, #12]
        assert(hal_dma_ch_incontinuous_config[ch] != NULL);
   19244:	9b02      	ldr	r3, [sp, #8]
   19246:	009d      	lsls	r5, r3, #2
   19248:	59ab      	ldr	r3, [r5, r6]
   1924a:	2b00      	cmp	r3, #0
   1924c:	d103      	bne.n	19256 <hal_dma_transfer+0xa2>
   1924e:	0039      	movs	r1, r7
   19250:	2016      	movs	r0, #22
   19252:	f7e8 fc5d 	bl	1b10 <panic>
        alter_cfgs_num = cfg->scatter_gather_configs;
   19256:	9b01      	ldr	r3, [sp, #4]
        primary_cfg.src = (uint32)hal_dma_ch_incontinuous_config[ch];
   19258:	5975      	ldr	r5, [r6, r5]
        alter_cfgs_num = cfg->scatter_gather_configs;
   1925a:	7c1b      	ldrb	r3, [r3, #16]
        primary_cfg.dst = (uint32)&hal_dma_ch_ctrl[DMA_CHANS + ch];
   1925c:	4e52      	ldr	r6, [pc, #328]	; (193a8 <hal_dma_transfer+0x1f4>)
        alter_cfgs_num = cfg->scatter_gather_configs;
   1925e:	9305      	str	r3, [sp, #20]
        primary_cfg.dst = (uint32)&hal_dma_ch_ctrl[DMA_CHANS + ch];
   19260:	9b04      	ldr	r3, [sp, #16]
        primary_cfg.transfer_num = (alter_cfgs_num << HAL_DMA_CH_CTRL_DATA_WORDS_POWER_OF_2);
   19262:	aa08      	add	r2, sp, #32
        primary_cfg.dst = (uint32)&hal_dma_ch_ctrl[DMA_CHANS + ch];
   19264:	3340      	adds	r3, #64	; 0x40
   19266:	199b      	adds	r3, r3, r6
   19268:	9309      	str	r3, [sp, #36]	; 0x24
        primary_cfg.transfer_num = (alter_cfgs_num << HAL_DMA_CH_CTRL_DATA_WORDS_POWER_OF_2);
   1926a:	9b05      	ldr	r3, [sp, #20]
        primary_cfg.next_use_burst = HAL_DMA_NEXT_USE_BURST_DISABLE;
   1926c:	2700      	movs	r7, #0
        primary_cfg.transfer_num = (alter_cfgs_num << HAL_DMA_CH_CTRL_DATA_WORDS_POWER_OF_2);
   1926e:	009b      	lsls	r3, r3, #2
   19270:	8193      	strh	r3, [r2, #12]
        primary_cfg.data_width = HAL_DMA_DATA_WIDTH_WORD;
   19272:	2302      	movs	r3, #2
   19274:	7213      	strb	r3, [r2, #8]
        primary_cfg.r_power = HAL_DMA_R_POWER_2;
   19276:	73d3      	strb	r3, [r2, #15]
        primary_cfg.src_inc = HAL_DMA_ADDRESS_INC_WORD;
   19278:	7253      	strb	r3, [r2, #9]
        primary_cfg.dst_inc = HAL_DMA_ADDRESS_INC_WORD;
   1927a:	7293      	strb	r3, [r2, #10]
        primary_cfg.cycle_type = HAL_DMA_CH_CYCLE_TYPE_SCATTER_GATHER_ALTERNATE_TO_PRIMARY(cfg->cycle_type);
   1927c:	9b01      	ldr	r3, [sp, #4]
        primary_cfg.src = (uint32)hal_dma_ch_incontinuous_config[ch];
   1927e:	9508      	str	r5, [sp, #32]
        primary_cfg.cycle_type = HAL_DMA_CH_CYCLE_TYPE_SCATTER_GATHER_ALTERNATE_TO_PRIMARY(cfg->cycle_type);
   19280:	7b9b      	ldrb	r3, [r3, #14]
        hal_dma_ch_ctrl_data_structure_fill(ch_ctrl, &primary_cfg);
   19282:	0011      	movs	r1, r2
        primary_cfg.cycle_type = HAL_DMA_CH_CYCLE_TYPE_SCATTER_GATHER_ALTERNATE_TO_PRIMARY(cfg->cycle_type);
   19284:	3b01      	subs	r3, #1
        hal_dma_ch_ctrl_data_structure_fill(ch_ctrl, &primary_cfg);
   19286:	0020      	movs	r0, r4
        primary_cfg.cycle_type = HAL_DMA_CH_CYCLE_TYPE_SCATTER_GATHER_ALTERNATE_TO_PRIMARY(cfg->cycle_type);
   19288:	7393      	strb	r3, [r2, #14]
        primary_cfg.next_use_burst = HAL_DMA_NEXT_USE_BURST_DISABLE;
   1928a:	72d7      	strb	r7, [r2, #11]
        hal_dma_ch_ctrl_data_structure_fill(ch_ctrl, &primary_cfg);
   1928c:	f7ff fdda 	bl	18e44 <hal_dma_ch_ctrl_data_structure_fill>
        if (hal_dma_channel[ch].periph_feature.use_burst)
   19290:	2214      	movs	r2, #20
        ch_ctrl->DestEndAddr = primary_cfg.dst + ((sizeof(dma_ch_ctrl_t) / sizeof(uint32) - 1) << HAL_DMA_ADDRESS_INC_WORD);
   19292:	9b02      	ldr	r3, [sp, #8]
   19294:	011b      	lsls	r3, r3, #4
   19296:	18f6      	adds	r6, r6, r3
   19298:	9b09      	ldr	r3, [sp, #36]	; 0x24
   1929a:	330c      	adds	r3, #12
   1929c:	6073      	str	r3, [r6, #4]
        if (hal_dma_channel[ch].periph_feature.use_burst)
   1929e:	9b02      	ldr	r3, [sp, #8]
   192a0:	435a      	muls	r2, r3
   192a2:	4b42      	ldr	r3, [pc, #264]	; (193ac <hal_dma_transfer+0x1f8>)
   192a4:	189b      	adds	r3, r3, r2
   192a6:	78db      	ldrb	r3, [r3, #3]
   192a8:	42bb      	cmp	r3, r7
   192aa:	d112      	bne.n	192d2 <hal_dma_transfer+0x11e>
   192ac:	9b05      	ldr	r3, [sp, #20]
   192ae:	011c      	lsls	r4, r3, #4
   192b0:	192c      	adds	r4, r5, r4
            for (alter_cfg_idx = 0, alternate_cfg = cfg, ch_ctrl = hal_dma_ch_incontinuous_config[ch];
   192b2:	42a5      	cmp	r5, r4
   192b4:	d09f      	beq.n	191f6 <hal_dma_transfer+0x42>
                hal_dma_ch_ctrl_data_structure_fill(ch_ctrl, alternate_cfg);
   192b6:	9901      	ldr	r1, [sp, #4]
   192b8:	0028      	movs	r0, r5
   192ba:	f7ff fdc3 	bl	18e44 <hal_dma_ch_ctrl_data_structure_fill>
                if (cfg_index == HAL_DMA_CH_TRANSFER_QUEUE_MAX_SIZE - 1)
   192be:	9b03      	ldr	r3, [sp, #12]
   192c0:	2b09      	cmp	r3, #9
   192c2:	d15c      	bne.n	1937e <hal_dma_transfer+0x1ca>
                    alternate_cfg -= HAL_DMA_CH_TRANSFER_QUEUE_MAX_SIZE - 1;
   192c4:	9b01      	ldr	r3, [sp, #4]
   192c6:	3bd8      	subs	r3, #216	; 0xd8
   192c8:	9301      	str	r3, [sp, #4]
                    cfg_index = 0;
   192ca:	2300      	movs	r3, #0
   192cc:	9303      	str	r3, [sp, #12]
                    alter_cfg_idx < alter_cfgs_num; alter_cfg_idx++, ch_ctrl++)
   192ce:	3510      	adds	r5, #16
   192d0:	e7ef      	b.n	192b2 <hal_dma_transfer+0xfe>
            uint16 r_power_transfers = HAL_DMA_R_POWER_TRANSFERS(cfg->r_power);
   192d2:	9b01      	ldr	r3, [sp, #4]
   192d4:	9c01      	ldr	r4, [sp, #4]
   192d6:	7bda      	ldrb	r2, [r3, #15]
   192d8:	2301      	movs	r3, #1
   192da:	4093      	lsls	r3, r2
   192dc:	b29b      	uxth	r3, r3
   192de:	9306      	str	r3, [sp, #24]
            uint8 actual_alter_cfgs = 0;
   192e0:	9704      	str	r7, [sp, #16]
            for (alter_cfg_idx = 0, alternate_cfg = cfg, ch_ctrl = hal_dma_ch_incontinuous_config[ch];
   192e2:	9b05      	ldr	r3, [sp, #20]
   192e4:	42bb      	cmp	r3, r7
   192e6:	d80d      	bhi.n	19304 <hal_dma_transfer+0x150>
            ch_ctrl->Ctrl &= ~HAL_DMA_CYCLE_TYPE_MASK;
   192e8:	2207      	movs	r2, #7
   192ea:	3d10      	subs	r5, #16
   192ec:	68ab      	ldr	r3, [r5, #8]
   192ee:	4393      	bics	r3, r2
   192f0:	60ab      	str	r3, [r5, #8]
            ch_ctrl->Ctrl |= HAL_DMA_CYCLE_TYPE_BITS(HAL_DMA_CH_CYCLE_TYPE_BASIC);
   192f2:	2301      	movs	r3, #1
   192f4:	68aa      	ldr	r2, [r5, #8]
   192f6:	4313      	orrs	r3, r2
            cfg->scatter_gather_configs = actual_alter_cfgs;
   192f8:	466a      	mov	r2, sp
            ch_ctrl->Ctrl |= HAL_DMA_CYCLE_TYPE_BITS(HAL_DMA_CH_CYCLE_TYPE_BASIC);
   192fa:	60ab      	str	r3, [r5, #8]
            cfg->scatter_gather_configs = actual_alter_cfgs;
   192fc:	7c12      	ldrb	r2, [r2, #16]
   192fe:	9b01      	ldr	r3, [sp, #4]
   19300:	741a      	strb	r2, [r3, #16]
   19302:	e778      	b.n	191f6 <hal_dma_transfer+0x42>
                hal_dma_ch_ctrl_data_structure_fill(ch_ctrl, alternate_cfg);
   19304:	0021      	movs	r1, r4
   19306:	0028      	movs	r0, r5
   19308:	f7ff fd9c 	bl	18e44 <hal_dma_ch_ctrl_data_structure_fill>
                remaining_transfers = alternate_cfg->transfer_num & (r_power_transfers - 1);
   1930c:	89a6      	ldrh	r6, [r4, #12]
                if ((alternate_cfg->transfer_num > r_power_transfers) && (remaining_transfers != 0))
   1930e:	9b06      	ldr	r3, [sp, #24]
   19310:	42b3      	cmp	r3, r6
   19312:	d220      	bcs.n	19356 <hal_dma_transfer+0x1a2>
                remaining_transfers = alternate_cfg->transfer_num & (r_power_transfers - 1);
   19314:	3b01      	subs	r3, #1
   19316:	401e      	ands	r6, r3
                if ((alternate_cfg->transfer_num > r_power_transfers) && (remaining_transfers != 0))
   19318:	d01d      	beq.n	19356 <hal_dma_transfer+0x1a2>
   1931a:	002b      	movs	r3, r5
   1931c:	3310      	adds	r3, #16
   1931e:	9307      	str	r3, [sp, #28]
                    ch_ctrl->Ctrl &= ~HAL_DMA_N_MINUS_1_MASK;
   19320:	4a26      	ldr	r2, [pc, #152]	; (193bc <hal_dma_transfer+0x208>)
   19322:	68ab      	ldr	r3, [r5, #8]
                    memcpy(ch_ctrl, pre_ch_ctrl, sizeof(*ch_ctrl));
   19324:	0029      	movs	r1, r5
                    ch_ctrl->Ctrl &= ~HAL_DMA_N_MINUS_1_MASK;
   19326:	4013      	ands	r3, r2
   19328:	60ab      	str	r3, [r5, #8]
                    memcpy(ch_ctrl, pre_ch_ctrl, sizeof(*ch_ctrl));
   1932a:	2210      	movs	r2, #16
   1932c:	9807      	ldr	r0, [sp, #28]
   1932e:	f7e6 ff5f 	bl	1f0 <memcpy>
                    pre_ch_ctrl->SrcEndAddr -= remaining_transfers;
   19332:	682b      	ldr	r3, [r5, #0]
                    pre_ch_ctrl->Ctrl |= HAL_DMA_N_MINUS_1_BITS((uint32)((alternate_cfg->transfer_num - remaining_transfers) - 1));
   19334:	68aa      	ldr	r2, [r5, #8]
                    pre_ch_ctrl->SrcEndAddr -= remaining_transfers;
   19336:	1b9b      	subs	r3, r3, r6
   19338:	602b      	str	r3, [r5, #0]
                    pre_ch_ctrl->Ctrl |= HAL_DMA_N_MINUS_1_BITS((uint32)((alternate_cfg->transfer_num - remaining_transfers) - 1));
   1933a:	89a3      	ldrh	r3, [r4, #12]
   1933c:	3701      	adds	r7, #1
   1933e:	1b9b      	subs	r3, r3, r6
   19340:	3b01      	subs	r3, #1
   19342:	011b      	lsls	r3, r3, #4
   19344:	4313      	orrs	r3, r2
   19346:	60ab      	str	r3, [r5, #8]
                    ch_ctrl->Ctrl |= HAL_DMA_N_MINUS_1_BITS((uint32)(remaining_transfers - 1));
   19348:	69ab      	ldr	r3, [r5, #24]
   1934a:	3e01      	subs	r6, #1
   1934c:	0136      	lsls	r6, r6, #4
   1934e:	431e      	orrs	r6, r3
   19350:	61ae      	str	r6, [r5, #24]
   19352:	9d07      	ldr	r5, [sp, #28]
   19354:	b2ff      	uxtb	r7, r7
                if (cfg_index == HAL_DMA_CH_TRANSFER_QUEUE_MAX_SIZE - 1)
   19356:	9b03      	ldr	r3, [sp, #12]
   19358:	2b09      	cmp	r3, #9
   1935a:	d10a      	bne.n	19372 <hal_dma_transfer+0x1be>
                    cfg_index = 0;
   1935c:	2300      	movs	r3, #0
                    alternate_cfg -= HAL_DMA_CH_TRANSFER_QUEUE_MAX_SIZE - 1;
   1935e:	3cd8      	subs	r4, #216	; 0xd8
                    cfg_index = 0;
   19360:	9303      	str	r3, [sp, #12]
                    alter_cfg_idx < alter_cfgs_num; alter_cfg_idx++, actual_alter_cfgs++, ch_ctrl++)
   19362:	9b04      	ldr	r3, [sp, #16]
   19364:	3701      	adds	r7, #1
   19366:	3301      	adds	r3, #1
   19368:	b2db      	uxtb	r3, r3
   1936a:	b2ff      	uxtb	r7, r7
   1936c:	9304      	str	r3, [sp, #16]
   1936e:	3510      	adds	r5, #16
   19370:	e7b7      	b.n	192e2 <hal_dma_transfer+0x12e>
                    cfg_index++;
   19372:	9b03      	ldr	r3, [sp, #12]
                    alternate_cfg++;
   19374:	3418      	adds	r4, #24
                    cfg_index++;
   19376:	3301      	adds	r3, #1
   19378:	b2db      	uxtb	r3, r3
   1937a:	9303      	str	r3, [sp, #12]
   1937c:	e7f1      	b.n	19362 <hal_dma_transfer+0x1ae>
                    cfg_index++;
   1937e:	9b03      	ldr	r3, [sp, #12]
   19380:	3301      	adds	r3, #1
   19382:	b2db      	uxtb	r3, r3
   19384:	9303      	str	r3, [sp, #12]
                    alternate_cfg++;
   19386:	9b01      	ldr	r3, [sp, #4]
   19388:	3318      	adds	r3, #24
   1938a:	9301      	str	r3, [sp, #4]
   1938c:	e79f      	b.n	192ce <hal_dma_transfer+0x11a>
    dmac_regs->CHNL_USEBURST_CLR = BIT(ch);
   1938e:	61ea      	str	r2, [r5, #28]
   19390:	e73f      	b.n	19212 <hal_dma_transfer+0x5e>
        else if (hal_dma_channel[ch].periph == DMA_PERIPHERAL_MEMORY)
   19392:	9802      	ldr	r0, [sp, #8]
   19394:	4343      	muls	r3, r0
   19396:	18cb      	adds	r3, r1, r3
   19398:	785b      	ldrb	r3, [r3, #1]
   1939a:	2001      	movs	r0, #1
   1939c:	2b00      	cmp	r3, #0
   1939e:	d000      	beq.n	193a2 <hal_dma_transfer+0x1ee>
   193a0:	e723      	b.n	191ea <hal_dma_transfer+0x36>
            hal_dma_get_dmac()->CHNL_SW_REQEST = BIT(ch);
   193a2:	616a      	str	r2, [r5, #20]
   193a4:	e721      	b.n	191ea <hal_dma_transfer+0x36>
   193a6:	46c0      	nop			; (mov r8, r8)
   193a8:	01002a80 	.word	0x01002a80
   193ac:	01002b24 	.word	0x01002b24
   193b0:	40005000 	.word	0x40005000
   193b4:	01002b14 	.word	0x01002b14
   193b8:	01002b00 	.word	0x01002b00
   193bc:	ffffc00f 	.word	0xffffc00f

000193c0 <hal_dma_ch_scatter_gather_alternate_config_buffer_alloc>:
{
   193c0:	b570      	push	{r4, r5, r6, lr}
   193c2:	0004      	movs	r4, r0
    hal_dma_ch_incontinuous_config[ch] = (dma_ch_ctrl_t *)irmalloc(
   193c4:	2090      	movs	r0, #144	; 0x90
   193c6:	f7f9 fb1b 	bl	12a00 <irmalloc>
   193ca:	4d07      	ldr	r5, [pc, #28]	; (193e8 <hal_dma_ch_scatter_gather_alternate_config_buffer_alloc+0x28>)
   193cc:	00a4      	lsls	r4, r4, #2
   193ce:	5160      	str	r0, [r4, r5]
    if (hal_dma_ch_incontinuous_config[ch] == NULL)
   193d0:	2800      	cmp	r0, #0
   193d2:	d103      	bne.n	193dc <hal_dma_ch_scatter_gather_alternate_config_buffer_alloc+0x1c>
        panic(PANIC_DMA, PANIC_HAL_DMA_MEMORY_ALLOCATION_FAILED);
   193d4:	2180      	movs	r1, #128	; 0x80
   193d6:	3023      	adds	r0, #35	; 0x23
   193d8:	f7e8 fb9a 	bl	1b10 <panic>
    memset(hal_dma_ch_incontinuous_config[ch], 0, sizeof(dma_ch_ctrl_t) * HAL_DMA_MAX_SUPPORTED_SCATTER_GATHER_CONFIGS);
   193dc:	5928      	ldr	r0, [r5, r4]
   193de:	2290      	movs	r2, #144	; 0x90
   193e0:	2100      	movs	r1, #0
   193e2:	f7e6 ff7d 	bl	2e0 <memset>
}
   193e6:	bd70      	pop	{r4, r5, r6, pc}
   193e8:	01002b00 	.word	0x01002b00

000193ec <hal_dma_enable_interrupt>:
{
   193ec:	b570      	push	{r4, r5, r6, lr}
   193ee:	0004      	movs	r4, r0
    switch (interrupt_type)
   193f0:	2901      	cmp	r1, #1
   193f2:	d903      	bls.n	193fc <hal_dma_enable_interrupt+0x10>
        assert(false); /* it should never get here */
   193f4:	4671      	mov	r1, lr
   193f6:	2016      	movs	r0, #22
   193f8:	f7e8 fb8a 	bl	1b10 <panic>
    non_os_enter_critical();
   193fc:	f7fe feda 	bl	181b4 <non_os_enter_critical>
    if (hal_dma_ch_intr_enabled_flags == 0)
   19400:	4a09      	ldr	r2, [pc, #36]	; (19428 <hal_dma_enable_interrupt+0x3c>)
   19402:	7813      	ldrb	r3, [r2, #0]
   19404:	2b00      	cmp	r3, #0
   19406:	d107      	bne.n	19418 <hal_dma_enable_interrupt+0x2c>
  NVIC->ICPR[0] = (uint32_t)(1UL << (((uint32_t)(int32_t)IRQn) & 0x1FUL));
   19408:	25c0      	movs	r5, #192	; 0xc0
   1940a:	2040      	movs	r0, #64	; 0x40
   1940c:	4907      	ldr	r1, [pc, #28]	; (1942c <hal_dma_enable_interrupt+0x40>)
   1940e:	006d      	lsls	r5, r5, #1
   19410:	5148      	str	r0, [r1, r5]
  NVIC->ISER[0] = (uint32_t)(1UL << (((uint32_t)(int32_t)IRQn) & 0x1FUL));
   19412:	6008      	str	r0, [r1, #0]
    *((volatile unsigned long *)(DMA_BASE_ADDR + HAL_DMA_INTEGRATION_CONFIGURATION_BASE_OFFSET)) = 0;
   19414:	4906      	ldr	r1, [pc, #24]	; (19430 <hal_dma_enable_interrupt+0x44>)
   19416:	600b      	str	r3, [r1, #0]
    hal_dma_ch_intr_enabled_flags |= BIT(ch);
   19418:	2301      	movs	r3, #1
   1941a:	40a3      	lsls	r3, r4
   1941c:	7811      	ldrb	r1, [r2, #0]
   1941e:	430b      	orrs	r3, r1
   19420:	7013      	strb	r3, [r2, #0]
    non_os_exit_critical();
   19422:	f7fe fedb 	bl	181dc <non_os_exit_critical>
}
   19426:	bd70      	pop	{r4, r5, r6, pc}
   19428:	01002b10 	.word	0x01002b10
   1942c:	e000e100 	.word	0xe000e100
   19430:	40005e00 	.word	0x40005e00

00019434 <hal_dma_disable_interrupt>:
{
   19434:	b510      	push	{r4, lr}
   19436:	0004      	movs	r4, r0
    switch (interrupt_type)
   19438:	2901      	cmp	r1, #1
   1943a:	d903      	bls.n	19444 <hal_dma_disable_interrupt+0x10>
        assert(false); /* it should never get here */
   1943c:	4671      	mov	r1, lr
   1943e:	2016      	movs	r0, #22
   19440:	f7e8 fb66 	bl	1b10 <panic>
    non_os_enter_critical();
   19444:	f7fe feb6 	bl	181b4 <non_os_enter_critical>
    hal_dma_ch_intr_enabled_flags &= ~(BIT(ch));
   19448:	2201      	movs	r2, #1
   1944a:	40a2      	lsls	r2, r4
   1944c:	4907      	ldr	r1, [pc, #28]	; (1946c <hal_dma_disable_interrupt+0x38>)
   1944e:	780b      	ldrb	r3, [r1, #0]
   19450:	4393      	bics	r3, r2
   19452:	700b      	strb	r3, [r1, #0]
    if (hal_dma_ch_intr_enabled_flags == 0)
   19454:	d106      	bne.n	19464 <hal_dma_disable_interrupt+0x30>
  NVIC->ICPR[0] = (uint32_t)(1UL << (((uint32_t)(int32_t)IRQn) & 0x1FUL));
   19456:	22c0      	movs	r2, #192	; 0xc0
   19458:	4905      	ldr	r1, [pc, #20]	; (19470 <hal_dma_disable_interrupt+0x3c>)
   1945a:	3340      	adds	r3, #64	; 0x40
   1945c:	0052      	lsls	r2, r2, #1
   1945e:	508b      	str	r3, [r1, r2]
  NVIC->ICER[0] = (uint32_t)(1UL << (((uint32_t)(int32_t)IRQn) & 0x1FUL));
   19460:	4a04      	ldr	r2, [pc, #16]	; (19474 <hal_dma_disable_interrupt+0x40>)
   19462:	67d3      	str	r3, [r2, #124]	; 0x7c
    non_os_exit_critical();
   19464:	f7fe feba 	bl	181dc <non_os_exit_critical>
}
   19468:	bd10      	pop	{r4, pc}
   1946a:	46c0      	nop			; (mov r8, r8)
   1946c:	01002b10 	.word	0x01002b10
   19470:	e000e100 	.word	0xe000e100
   19474:	e000e104 	.word	0xe000e104

00019478 <hal_dma_configure_interrupt>:
{
   19478:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
   1947a:	4677      	mov	r7, lr
   1947c:	0004      	movs	r4, r0
   1947e:	000d      	movs	r5, r1
   19480:	9200      	str	r2, [sp, #0]
   19482:	9301      	str	r3, [sp, #4]
    assert((ch < HAL_DMA_CHANNEL_MAX_NUM) && (interrupt_type < HAL_DMA_INTERRUPT_MAX));
   19484:	2803      	cmp	r0, #3
   19486:	d801      	bhi.n	1948c <hal_dma_configure_interrupt+0x14>
   19488:	2901      	cmp	r1, #1
   1948a:	d903      	bls.n	19494 <hal_dma_configure_interrupt+0x1c>
   1948c:	0039      	movs	r1, r7
   1948e:	2016      	movs	r0, #22
   19490:	f7e8 fb3e 	bl	1b10 <panic>
    assert(hal_dma_initialised);
   19494:	4e13      	ldr	r6, [pc, #76]	; (194e4 <hal_dma_configure_interrupt+0x6c>)
   19496:	7833      	ldrb	r3, [r6, #0]
   19498:	2b00      	cmp	r3, #0
   1949a:	d103      	bne.n	194a4 <hal_dma_configure_interrupt+0x2c>
   1949c:	0039      	movs	r1, r7
   1949e:	2016      	movs	r0, #22
   194a0:	f7e8 fb36 	bl	1b10 <panic>
    non_os_enter_critical();
   194a4:	f7fe fe86 	bl	181b4 <non_os_enter_critical>
    if(hal_dma_initialised && (ch < HAL_DMA_CHANNEL_MAX_NUM) && (interrupt_type < HAL_DMA_INTERRUPT_MAX))
   194a8:	7833      	ldrb	r3, [r6, #0]
   194aa:	2b00      	cmp	r3, #0
   194ac:	d012      	beq.n	194d4 <hal_dma_configure_interrupt+0x5c>
   194ae:	2c03      	cmp	r4, #3
   194b0:	d810      	bhi.n	194d4 <hal_dma_configure_interrupt+0x5c>
   194b2:	2d01      	cmp	r5, #1
   194b4:	d80e      	bhi.n	194d4 <hal_dma_configure_interrupt+0x5c>
   194b6:	2214      	movs	r2, #20
            hal_dma_channel[ch].isr_callbacks.err_isr = callback;
   194b8:	4362      	muls	r2, r4
   194ba:	4b0b      	ldr	r3, [pc, #44]	; (194e8 <hal_dma_configure_interrupt+0x70>)
   194bc:	189b      	adds	r3, r3, r2
   194be:	9a00      	ldr	r2, [sp, #0]
        switch (interrupt_type)
   194c0:	2d01      	cmp	r5, #1
   194c2:	d00a      	beq.n	194da <hal_dma_configure_interrupt+0x62>
            hal_dma_channel[ch].isr_callbacks.done_isr = callback;
   194c4:	605a      	str	r2, [r3, #4]
        if (initial_state == INTERRUPT_STATE_ENABLED)
   194c6:	9b01      	ldr	r3, [sp, #4]
            hal_dma_enable_interrupt(ch, interrupt_type);
   194c8:	0029      	movs	r1, r5
   194ca:	0020      	movs	r0, r4
        if (initial_state == INTERRUPT_STATE_ENABLED)
   194cc:	2b01      	cmp	r3, #1
   194ce:	d106      	bne.n	194de <hal_dma_configure_interrupt+0x66>
            hal_dma_enable_interrupt(ch, interrupt_type);
   194d0:	f7ff ff8c 	bl	193ec <hal_dma_enable_interrupt>
    non_os_exit_critical();
   194d4:	f7fe fe82 	bl	181dc <non_os_exit_critical>
}
   194d8:	bdf7      	pop	{r0, r1, r2, r4, r5, r6, r7, pc}
            hal_dma_channel[ch].isr_callbacks.err_isr = callback;
   194da:	609a      	str	r2, [r3, #8]
            break;
   194dc:	e7f3      	b.n	194c6 <hal_dma_configure_interrupt+0x4e>
            hal_dma_disable_interrupt(ch, interrupt_type);
   194de:	f7ff ffa9 	bl	19434 <hal_dma_disable_interrupt>
   194e2:	e7f7      	b.n	194d4 <hal_dma_configure_interrupt+0x5c>
   194e4:	01002b74 	.word	0x01002b74
   194e8:	01002b24 	.word	0x01002b24

000194ec <hal_dma_clear_interrupt>:
{
   194ec:	b510      	push	{r4, lr}
   194ee:	4674      	mov	r4, lr
    assert(interrupt_type < HAL_DMA_INTERRUPT_MAX);
   194f0:	2901      	cmp	r1, #1
   194f2:	d908      	bls.n	19506 <hal_dma_clear_interrupt+0x1a>
   194f4:	4671      	mov	r1, lr
   194f6:	2016      	movs	r0, #22
   194f8:	f7e8 fb0a 	bl	1b10 <panic>
        assert(false); /* it should never get here */
   194fc:	0021      	movs	r1, r4
   194fe:	2016      	movs	r0, #22
   19500:	f7e8 fb06 	bl	1b10 <panic>
}
   19504:	bd10      	pop	{r4, pc}
    switch (interrupt_type)
   19506:	2901      	cmp	r1, #1
   19508:	d1fc      	bne.n	19504 <hal_dma_clear_interrupt+0x18>
        if (dmac_regs->ERR_CLR & HAL_DMA_ERR_CLEAR_MASK)
   1950a:	4b03      	ldr	r3, [pc, #12]	; (19518 <hal_dma_clear_interrupt+0x2c>)
   1950c:	6cda      	ldr	r2, [r3, #76]	; 0x4c
   1950e:	420a      	tst	r2, r1
   19510:	d0f8      	beq.n	19504 <hal_dma_clear_interrupt+0x18>
            dmac_regs->ERR_CLR = HAL_DMA_ERR_CLEAR_MASK;
   19512:	64d9      	str	r1, [r3, #76]	; 0x4c
}
   19514:	e7f6      	b.n	19504 <hal_dma_clear_interrupt+0x18>
   19516:	46c0      	nop			; (mov r8, r8)
   19518:	40005000 	.word	0x40005000

0001951c <hal_dma_ch_select_primary>:
    dmac_regs->CHNL_PRI_ALT_CLR = BIT(ch);
   1951c:	2301      	movs	r3, #1
   1951e:	4083      	lsls	r3, r0
   19520:	4a01      	ldr	r2, [pc, #4]	; (19528 <hal_dma_ch_select_primary+0xc>)
   19522:	6353      	str	r3, [r2, #52]	; 0x34
}
   19524:	4770      	bx	lr
   19526:	46c0      	nop			; (mov r8, r8)
   19528:	40005000 	.word	0x40005000

0001952c <hal_dma_ch_is_enabled>:
/** Check whether a specific DMA channel is enabled
 * @param ch DMA channel ID
 * @return true if the DMA channel is enabled or false otherwise
 */
bool hal_dma_ch_is_enabled(HAL_DMA_CHANNEL ch)
{
   1952c:	b510      	push	{r4, lr}
   1952e:	0004      	movs	r4, r0
    assert(ch < HAL_DMA_CHANNEL_MAX_NUM);
   19530:	2803      	cmp	r0, #3
   19532:	d903      	bls.n	1953c <hal_dma_ch_is_enabled+0x10>
   19534:	4671      	mov	r1, lr
   19536:	2016      	movs	r0, #22
   19538:	f7e8 faea 	bl	1b10 <panic>

    volatile dma_ctrl_t *dmac_regs = hal_dma_get_dmac();

    return ((dmac_regs->CHNL_ENABLE_SET & BIT(ch)) != 0);
   1953c:	4b02      	ldr	r3, [pc, #8]	; (19548 <hal_dma_ch_is_enabled+0x1c>)
   1953e:	6a98      	ldr	r0, [r3, #40]	; 0x28
   19540:	2301      	movs	r3, #1
   19542:	40e0      	lsrs	r0, r4
   19544:	4018      	ands	r0, r3
}
   19546:	bd10      	pop	{r4, pc}
   19548:	40005000 	.word	0x40005000

0001954c <hal_dma_ch_is_closed>:
    state = hal_dma_channel[ch].state;
   1954c:	2214      	movs	r2, #20
{
   1954e:	b510      	push	{r4, lr}
    state = hal_dma_channel[ch].state;
   19550:	4342      	muls	r2, r0
   19552:	4b06      	ldr	r3, [pc, #24]	; (1956c <hal_dma_ch_is_closed+0x20>)
   19554:	189b      	adds	r3, r3, r2
    if ((hal_dma_ch_state_get(ch) == HAL_DMA_CH_STATE_CLOSED) && !hal_dma_ch_is_enabled(ch))
   19556:	789a      	ldrb	r2, [r3, #2]
    return false;
   19558:	2300      	movs	r3, #0
    if ((hal_dma_ch_state_get(ch) == HAL_DMA_CH_STATE_CLOSED) && !hal_dma_ch_is_enabled(ch))
   1955a:	429a      	cmp	r2, r3
   1955c:	d104      	bne.n	19568 <hal_dma_ch_is_closed+0x1c>
   1955e:	f7ff ffe5 	bl	1952c <hal_dma_ch_is_enabled>
   19562:	2301      	movs	r3, #1
   19564:	4043      	eors	r3, r0
   19566:	b2db      	uxtb	r3, r3
}
   19568:	0018      	movs	r0, r3
   1956a:	bd10      	pop	{r4, pc}
   1956c:	01002b24 	.word	0x01002b24

00019570 <hal_dma_ch_open>:
{
   19570:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
   19572:	4674      	mov	r4, lr
   19574:	0006      	movs	r6, r0
   19576:	000f      	movs	r7, r1
   19578:	0015      	movs	r5, r2
    assert((ch != NULL) && (pri <= HAL_DMA_CH_REAL_PRIORITY_LOWEST));
   1957a:	2800      	cmp	r0, #0
   1957c:	d001      	beq.n	19582 <hal_dma_ch_open+0x12>
   1957e:	2907      	cmp	r1, #7
   19580:	d903      	bls.n	1958a <hal_dma_ch_open+0x1a>
   19582:	0021      	movs	r1, r4
   19584:	2016      	movs	r0, #22
   19586:	f7e8 fac3 	bl	1b10 <panic>
    assert(periph < DMA_PERIPHERAL_MAX_NUM);
   1958a:	2d0f      	cmp	r5, #15
   1958c:	d903      	bls.n	19596 <hal_dma_ch_open+0x26>
   1958e:	0021      	movs	r1, r4
   19590:	2016      	movs	r0, #22
   19592:	f7e8 fabd 	bl	1b10 <panic>
    HAL_DMA_CHANNEL           ch_scan = HAL_DMA_CHANNEL_3;
   19596:	2403      	movs	r4, #3
    if (ch == NULL) //lint !e774
   19598:	2e00      	cmp	r6, #0
   1959a:	d101      	bne.n	195a0 <hal_dma_ch_open+0x30>
        return false;
   1959c:	2000      	movs	r0, #0
}
   1959e:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
        if (hal_dma_ch_is_closed(ch_scan))
   195a0:	0020      	movs	r0, r4
   195a2:	f7ff ffd3 	bl	1954c <hal_dma_ch_is_closed>
   195a6:	2800      	cmp	r0, #0
   195a8:	d004      	beq.n	195b4 <hal_dma_ch_open+0x44>
            if (HAL_DMA_CH_REAL_PRIORITY(ch_scan, HAL_DMA_CH_PRIORITY_LEVEL_DEFAULT) <= pri)
   195aa:	1ce3      	adds	r3, r4, #3
   195ac:	42bb      	cmp	r3, r7
   195ae:	db08      	blt.n	195c2 <hal_dma_ch_open+0x52>
            else if (HAL_DMA_CH_REAL_PRIORITY(ch_scan, HAL_DMA_CH_PRIORITY_LEVEL_HIGH) <= pri)
   195b0:	42bc      	cmp	r4, r7
   195b2:	d925      	bls.n	19600 <hal_dma_ch_open+0x90>
    } while (ch_scan-- > HAL_DMA_CHANNEL_0);
   195b4:	3c01      	subs	r4, #1
   195b6:	b2e4      	uxtb	r4, r4
   195b8:	2cff      	cmp	r4, #255	; 0xff
   195ba:	d1f1      	bne.n	195a0 <hal_dma_ch_open+0x30>
   195bc:	e7ee      	b.n	1959c <hal_dma_ch_open+0x2c>
            dmac_regs->CHNL_PRIORITY_CLR = BIT(ch_candidate);
   195be:	63ca      	str	r2, [r1, #60]	; 0x3c
   195c0:	e013      	b.n	195ea <hal_dma_ch_open+0x7a>
                priority_level = HAL_DMA_CH_PRIORITY_LEVEL_DEFAULT;
   195c2:	2301      	movs	r3, #1
    DMA_MUX_BITCLR = (HAL_DMA_PERIPHERAL_MASK << (ch * HAL_DMA_PERIPHERAL_OFFSET));
   195c4:	220f      	movs	r2, #15
   195c6:	00a1      	lsls	r1, r4, #2
   195c8:	408a      	lsls	r2, r1
        *ch = ch_candidate;
   195ca:	7034      	strb	r4, [r6, #0]
    DMA_MUX_BITCLR = (HAL_DMA_PERIPHERAL_MASK << (ch * HAL_DMA_PERIPHERAL_OFFSET));
   195cc:	4e0d      	ldr	r6, [pc, #52]	; (19604 <hal_dma_ch_open+0x94>)
   195ce:	6032      	str	r2, [r6, #0]
        if (periph != DMA_PERIPHERAL_MEMORY)
   195d0:	2d00      	cmp	r5, #0
   195d2:	d004      	beq.n	195de <hal_dma_ch_open+0x6e>
    DMA_MUX_BITSET = ((uint32)periph << (ch * HAL_DMA_PERIPHERAL_OFFSET));
   195d4:	002a      	movs	r2, r5
   195d6:	408a      	lsls	r2, r1
   195d8:	0011      	movs	r1, r2
   195da:	4a0b      	ldr	r2, [pc, #44]	; (19608 <hal_dma_ch_open+0x98>)
   195dc:	6011      	str	r1, [r2, #0]
   195de:	2201      	movs	r2, #1
   195e0:	490a      	ldr	r1, [pc, #40]	; (1960c <hal_dma_ch_open+0x9c>)
   195e2:	40a2      	lsls	r2, r4
        if (priority_level == HAL_DMA_CH_PRIORITY_LEVEL_HIGH) //lint !e644 It must have been assigned value in the branch
   195e4:	2b00      	cmp	r3, #0
   195e6:	d1ea      	bne.n	195be <hal_dma_ch_open+0x4e>
            dmac_regs->CHNL_PRIORITY_SET = BIT(ch_candidate);
   195e8:	638a      	str	r2, [r1, #56]	; 0x38
        hal_dma_channel[ch_candidate].periph = periph;
   195ea:	2214      	movs	r2, #20
   195ec:	4362      	muls	r2, r4
   195ee:	4908      	ldr	r1, [pc, #32]	; (19610 <hal_dma_ch_open+0xa0>)
        hal_dma_channel[ch_candidate].priority = HAL_DMA_CH_REAL_PRIORITY(ch_scan, priority_level);
   195f0:	009b      	lsls	r3, r3, #2
        hal_dma_channel[ch_candidate].periph = periph;
   195f2:	188e      	adds	r6, r1, r2
   195f4:	7075      	strb	r5, [r6, #1]
        hal_dma_channel[ch_candidate].state = HAL_DMA_CH_STATE_IDLE;
   195f6:	2501      	movs	r5, #1
        hal_dma_channel[ch_candidate].priority = HAL_DMA_CH_REAL_PRIORITY(ch_scan, priority_level);
   195f8:	18e4      	adds	r4, r4, r3
        hal_dma_channel[ch_candidate].state = HAL_DMA_CH_STATE_IDLE;
   195fa:	70b5      	strb	r5, [r6, #2]
        hal_dma_channel[ch_candidate].priority = HAL_DMA_CH_REAL_PRIORITY(ch_scan, priority_level);
   195fc:	5454      	strb	r4, [r2, r1]
        return true;
   195fe:	e7ce      	b.n	1959e <hal_dma_ch_open+0x2e>
                priority_level = HAL_DMA_CH_PRIORITY_LEVEL_HIGH;
   19600:	2300      	movs	r3, #0
   19602:	e7df      	b.n	195c4 <hal_dma_ch_open+0x54>
   19604:	40004904 	.word	0x40004904
   19608:	40004504 	.word	0x40004504
   1960c:	40005000 	.word	0x40005000
   19610:	01002b24 	.word	0x01002b24

00019614 <IRQ_DMA_Handler>:

/** The DMA interrupt ISR entry
 */
extern void IRQ_DMA_Handler(void);
void IRQ_DMA_Handler(void)
{
   19614:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
   19616:	4676      	mov	r6, lr
   19618:	2400      	movs	r4, #0
   1961a:	2714      	movs	r7, #20
        {
#if !defined(DMA_ERR_DEBUG)
            /* When we simulate the dma_err HIGH status through integration test logic,
             * the Channel would NOT be disabled when the dma_err is set to HIGH
             */
            if ((dmac_regs->CHNL_ENABLE_SET & BIT(ch)) == 0)
   1961c:	2501      	movs	r5, #1
   1961e:	003b      	movs	r3, r7
   19620:	4363      	muls	r3, r4
   19622:	4a12      	ldr	r2, [pc, #72]	; (1966c <IRQ_DMA_Handler+0x58>)
   19624:	b2e0      	uxtb	r0, r4
   19626:	18d3      	adds	r3, r2, r3
        if (hal_dma_channel[ch].state == HAL_DMA_CH_STATE_ACTIVE)
   19628:	789a      	ldrb	r2, [r3, #2]
   1962a:	2a02      	cmp	r2, #2
   1962c:	d110      	bne.n	19650 <IRQ_DMA_Handler+0x3c>
            if ((dmac_regs->CHNL_ENABLE_SET & BIT(ch)) == 0)
   1962e:	4910      	ldr	r1, [pc, #64]	; (19670 <IRQ_DMA_Handler+0x5c>)
   19630:	6a8a      	ldr	r2, [r1, #40]	; 0x28
   19632:	40e2      	lsrs	r2, r4
   19634:	422a      	tst	r2, r5
   19636:	d10b      	bne.n	19650 <IRQ_DMA_Handler+0x3c>
 * @param ch DMA Channel ID
 * @return true if it is HIGH or false otherwise
 */
static inline bool hal_dma_ch_done_signal_is_high(HAL_DMA_CHANNEL ch)
{
    return (DMA_CTRL_STAT & DMA_CTRL_STAT_DONE_MASK(ch)) != 0;
   19638:	4a0e      	ldr	r2, [pc, #56]	; (19674 <IRQ_DMA_Handler+0x60>)
   1963a:	6812      	ldr	r2, [r2, #0]
   1963c:	40e2      	lsrs	r2, r4
                if (hal_dma_ch_done_signal_is_high(ch) || ((dmac_regs->ERR_CLR & HAL_DMA_ERR_CLEAR_MASK) == 0))
   1963e:	422a      	tst	r2, r5
   19640:	d102      	bne.n	19648 <IRQ_DMA_Handler+0x34>
   19642:	6cca      	ldr	r2, [r1, #76]	; 0x4c
   19644:	422a      	tst	r2, r5
   19646:	d10f      	bne.n	19668 <IRQ_DMA_Handler+0x54>
                    if (hal_dma_channel[ch].isr_callbacks.done_isr != NULL)
   19648:	685b      	ldr	r3, [r3, #4]
                    if (hal_dma_channel[ch].isr_callbacks.err_isr != NULL)
   1964a:	2b00      	cmp	r3, #0
   1964c:	d000      	beq.n	19650 <IRQ_DMA_Handler+0x3c>
                        hal_dma_channel[ch].isr_callbacks.err_isr(ch);
   1964e:	4798      	blx	r3
   19650:	3401      	adds	r4, #1
    for (HAL_DMA_CHANNEL ch = HAL_DMA_CHANNEL_0; ch < HAL_DMA_CHANNEL_MAX_NUM; ch++)
   19652:	2c04      	cmp	r4, #4
   19654:	d1e3      	bne.n	1961e <IRQ_DMA_Handler+0xa>
    if ((dmac_regs->ERR_CLR & HAL_DMA_ERR_CLEAR_MASK) != 0)
   19656:	4b06      	ldr	r3, [pc, #24]	; (19670 <IRQ_DMA_Handler+0x5c>)
   19658:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
   1965a:	07db      	lsls	r3, r3, #31
   1965c:	d503      	bpl.n	19666 <IRQ_DMA_Handler+0x52>
        assert(false);
   1965e:	0031      	movs	r1, r6
   19660:	2016      	movs	r0, #22
   19662:	f7e8 fa55 	bl	1b10 <panic>
}
   19666:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
                    if (hal_dma_channel[ch].isr_callbacks.err_isr != NULL)
   19668:	689b      	ldr	r3, [r3, #8]
   1966a:	e7ee      	b.n	1964a <IRQ_DMA_Handler+0x36>
   1966c:	01002b24 	.word	0x01002b24
   19670:	40005000 	.word	0x40005000
   19674:	40004108 	.word	0x40004108

00019678 <hal_lpc_set_sleep_mode>:
    __ISB();
}

/* Set a type of sleep mode */
void hal_lpc_set_sleep_mode( HAL_LPC_SLEEP_MODE mode )
{
   19678:	4b05      	ldr	r3, [pc, #20]	; (19690 <hal_lpc_set_sleep_mode+0x18>)
   1967a:	2204      	movs	r2, #4
    if(mode == HAL_LPC_SLEEP_MODE_LIGHT)
    {
        SCB->SCR &= ~SCB_SCR_SLEEPDEEP_Msk;
   1967c:	6919      	ldr	r1, [r3, #16]
    if(mode == HAL_LPC_SLEEP_MODE_LIGHT)
   1967e:	2800      	cmp	r0, #0
   19680:	d102      	bne.n	19688 <hal_lpc_set_sleep_mode+0x10>
        SCB->SCR &= ~SCB_SCR_SLEEPDEEP_Msk;
   19682:	4391      	bics	r1, r2
   19684:	6119      	str	r1, [r3, #16]
    }
    else
    { // sleep deep
        SCB->SCR |= SCB_SCR_SLEEPDEEP_Msk;
    }
}
   19686:	4770      	bx	lr
        SCB->SCR |= SCB_SCR_SLEEPDEEP_Msk;
   19688:	430a      	orrs	r2, r1
   1968a:	611a      	str	r2, [r3, #16]
}
   1968c:	e7fb      	b.n	19686 <hal_lpc_set_sleep_mode+0xe>
   1968e:	46c0      	nop			; (mov r8, r8)
   19690:	e000ed00 	.word	0xe000ed00

00019694 <hal_lpc_set_sleep_on_exit>:

/* Set the sleep on exit mode */
void hal_lpc_set_sleep_on_exit( bool sleep_on_exit )
{
   19694:	4b05      	ldr	r3, [pc, #20]	; (196ac <hal_lpc_set_sleep_on_exit+0x18>)
   19696:	2202      	movs	r2, #2
    if(sleep_on_exit)
    {
        SCB->SCR |= SCB_SCR_SLEEPONEXIT_Msk;
   19698:	6919      	ldr	r1, [r3, #16]
    if(sleep_on_exit)
   1969a:	2800      	cmp	r0, #0
   1969c:	d002      	beq.n	196a4 <hal_lpc_set_sleep_on_exit+0x10>
        SCB->SCR |= SCB_SCR_SLEEPONEXIT_Msk;
   1969e:	430a      	orrs	r2, r1
   196a0:	611a      	str	r2, [r3, #16]
    }
    else
    {
        SCB->SCR &= ~SCB_SCR_SLEEPONEXIT_Msk;
    }
}
   196a2:	4770      	bx	lr
        SCB->SCR &= ~SCB_SCR_SLEEPONEXIT_Msk;
   196a4:	4391      	bics	r1, r2
   196a6:	6119      	str	r1, [r3, #16]
}
   196a8:	e7fb      	b.n	196a2 <hal_lpc_set_sleep_on_exit+0xe>
   196aa:	46c0      	nop			; (mov r8, r8)
   196ac:	e000ed00 	.word	0xe000ed00

000196b0 <hal_lpc_get_status_register>:

uint32 hal_lpc_get_status_register( )
{
    //Found in the reg_map_<core>.h file
    return LPC_STATUS;
   196b0:	4b01      	ldr	r3, [pc, #4]	; (196b8 <hal_lpc_get_status_register+0x8>)
   196b2:	6818      	ldr	r0, [r3, #0]
}
   196b4:	4770      	bx	lr
   196b6:	46c0      	nop			; (mov r8, r8)
   196b8:	4000006c 	.word	0x4000006c

000196bc <hal_reboot_init>:
/**
 * Initialise the reboot subsystem
 */
void hal_reboot_init(void)
{
    if (reset_cause == 0)
   196bc:	4b03      	ldr	r3, [pc, #12]	; (196cc <hal_reboot_init+0x10>)
   196be:	881a      	ldrh	r2, [r3, #0]
   196c0:	2a00      	cmp	r2, #0
   196c2:	d102      	bne.n	196ca <hal_reboot_init+0xe>
    {
        reset_cause = (uint16)RESET_CAUSE;
   196c4:	4a02      	ldr	r2, [pc, #8]	; (196d0 <hal_reboot_init+0x14>)
   196c6:	6812      	ldr	r2, [r2, #0]
   196c8:	801a      	strh	r2, [r3, #0]
    }
}
   196ca:	4770      	bx	lr
   196cc:	01002b76 	.word	0x01002b76
   196d0:	40004030 	.word	0x40004030

000196d4 <hal_reboot_get_reset_reason>:
/**
 * Return reset code for the last time this core was rebooted
 */
uint16 hal_reboot_get_reset_reason(void)
{
    return reset_cause;
   196d4:	4b01      	ldr	r3, [pc, #4]	; (196dc <hal_reboot_get_reset_reason+0x8>)
   196d6:	8818      	ldrh	r0, [r3, #0]
}
   196d8:	4770      	bx	lr
   196da:	46c0      	nop			; (mov r8, r8)
   196dc:	01002b76 	.word	0x01002b76

000196e0 <hal_rtc_set_irq_time>:
}

// Note, this function should be called just from critical sections.
// Note, it can take up to one RTC cycle to complete, which is currently ~30.52us
void hal_rtc_set_irq_time(uint64 time)
{
   196e0:	b570      	push	{r4, r5, r6, lr}
    // Can't set rtc expire timer more than once in same rtc clock cycle, otherwise digits will not assert IRQ
    while( RTC_TIME_LSBS == (uint32)hal_rtc_last_clock_timer )
   196e2:	4c07      	ldr	r4, [pc, #28]	; (19700 <hal_rtc_set_irq_time+0x20>)
   196e4:	4d07      	ldr	r5, [pc, #28]	; (19704 <hal_rtc_set_irq_time+0x24>)
   196e6:	6823      	ldr	r3, [r4, #0]
   196e8:	682a      	ldr	r2, [r5, #0]
   196ea:	429a      	cmp	r2, r3
   196ec:	d0fc      	beq.n	196e8 <hal_rtc_set_irq_time+0x8>
    {
    }

    // Write the values MSB first as the H/W will latch when the LSB is written
    RTC_IRQ_TIME_MSBS = (uint32)(time >> 32);
   196ee:	4b06      	ldr	r3, [pc, #24]	; (19708 <hal_rtc_set_irq_time+0x28>)
   196f0:	6019      	str	r1, [r3, #0]
    RTC_IRQ_TIME_LSBS = (uint32)time;
   196f2:	4b06      	ldr	r3, [pc, #24]	; (1970c <hal_rtc_set_irq_time+0x2c>)
   196f4:	6018      	str	r0, [r3, #0]

    hal_rtc_last_clock_timer = hal_rtc_get_time();
   196f6:	4b06      	ldr	r3, [pc, #24]	; (19710 <hal_rtc_set_irq_time+0x30>)
   196f8:	4798      	blx	r3
   196fa:	6020      	str	r0, [r4, #0]
   196fc:	6061      	str	r1, [r4, #4]
}
   196fe:	bd70      	pop	{r4, r5, r6, pc}
   19700:	01002b80 	.word	0x01002b80
   19704:	40000080 	.word	0x40000080
   19708:	400000b8 	.word	0x400000b8
   1970c:	400000b4 	.word	0x400000b4
   19710:	010004b1 	.word	0x010004b1

00019714 <hal_rtc_set_callback>:
}

//lint -esym(459, hal_rtc_set_callback)
void hal_rtc_set_callback( hal_rtc_callback func )
{
    hal_rtc_irq_callback = func;
   19714:	4b01      	ldr	r3, [pc, #4]	; (1971c <hal_rtc_set_callback+0x8>)
   19716:	6018      	str	r0, [r3, #0]
}
   19718:	4770      	bx	lr
   1971a:	46c0      	nop			; (mov r8, r8)
   1971c:	01002b78 	.word	0x01002b78

00019720 <IRQ_RTC_Handler>:

//lint -esym(459, IRQ_RTC_Handler)
extern void IRQ_RTC_Handler(void);
void IRQ_RTC_Handler(void)
{
    RTC_IRQ_CLR = 0xffffffff;
   19720:	2201      	movs	r2, #1
{
   19722:	b510      	push	{r4, lr}
    RTC_IRQ_CLR = 0xffffffff;
   19724:	4b04      	ldr	r3, [pc, #16]	; (19738 <IRQ_RTC_Handler+0x18>)
   19726:	4252      	negs	r2, r2
   19728:	601a      	str	r2, [r3, #0]
    if (hal_rtc_irq_callback != 0)
   1972a:	4b04      	ldr	r3, [pc, #16]	; (1973c <IRQ_RTC_Handler+0x1c>)
   1972c:	681b      	ldr	r3, [r3, #0]
   1972e:	2b00      	cmp	r3, #0
   19730:	d000      	beq.n	19734 <IRQ_RTC_Handler+0x14>
    {
        hal_rtc_irq_callback();
   19732:	4798      	blx	r3
    }
}
   19734:	bd10      	pop	{r4, pc}
   19736:	46c0      	nop			; (mov r8, r8)
   19738:	400000bc 	.word	0x400000bc
   1973c:	01002b78 	.word	0x01002b78

00019740 <hal_rtc_get_time_us>:

uint64 hal_rtc_get_time_us(void)
{
   19740:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
    uint64 current_time = hal_rtc_get_time();
   19742:	4b12      	ldr	r3, [pc, #72]	; (1978c <hal_rtc_get_time_us+0x4c>)
   19744:	4798      	blx	r3
    //Maths process:  (RTC * 1000000) / 32768
    //If we multiply by 1000000 then we can overflow the 64bit number,
    //so I have reduced both the numerator and denominator by x>>6
    // current_time=current_time*15625; Use shift/add/subtract below for speed
    // 15625 = 0011 1101 0000 1001 = 16384-512-256+8+1
    current_time = (((current_time << 14) - (current_time << 9)) - (current_time << 8)) + ((current_time << 3) + current_time);
   19746:	0e03      	lsrs	r3, r0, #24
   19748:	020a      	lsls	r2, r1, #8
   1974a:	431a      	orrs	r2, r3
   1974c:	0203      	lsls	r3, r0, #8
   1974e:	9300      	str	r3, [sp, #0]
   19750:	0c84      	lsrs	r4, r0, #18
   19752:	038b      	lsls	r3, r1, #14
   19754:	4323      	orrs	r3, r4
   19756:	00cd      	lsls	r5, r1, #3
   19758:	0f44      	lsrs	r4, r0, #29
   1975a:	9201      	str	r2, [sp, #4]
   1975c:	4325      	orrs	r5, r4
   1975e:	0382      	lsls	r2, r0, #14
   19760:	00c4      	lsls	r4, r0, #3
   19762:	1912      	adds	r2, r2, r4
   19764:	416b      	adcs	r3, r5
   19766:	1812      	adds	r2, r2, r0
   19768:	414b      	adcs	r3, r1
   1976a:	0dc4      	lsrs	r4, r0, #23
   1976c:	024d      	lsls	r5, r1, #9
   1976e:	4325      	orrs	r5, r4
   19770:	0244      	lsls	r4, r0, #9
   19772:	1b12      	subs	r2, r2, r4
   19774:	41ab      	sbcs	r3, r5
   19776:	9800      	ldr	r0, [sp, #0]
   19778:	9901      	ldr	r1, [sp, #4]
   1977a:	1a12      	subs	r2, r2, r0
   1977c:	418b      	sbcs	r3, r1

    current_time = current_time >> 9;
   1977e:	05d9      	lsls	r1, r3, #23
   19780:	0a50      	lsrs	r0, r2, #9
   19782:	4308      	orrs	r0, r1
   19784:	0a59      	lsrs	r1, r3, #9
    return current_time;
}
   19786:	b003      	add	sp, #12
   19788:	bdf0      	pop	{r4, r5, r6, r7, pc}
   1978a:	46c0      	nop			; (mov r8, r8)
   1978c:	010004b1 	.word	0x010004b1

00019790 <hal_rtc_get_time_ms>:


uint64 hal_rtc_get_time_ms(void)
{
   19790:	b570      	push	{r4, r5, r6, lr}
    // hal_rtc_get_time() returns a 48-bit value in a 64-bit uint.
    // When converted to ms, it returns approximately 43-bits of range, after
    // which it will wrap. The largest RTC value that can be represented prior
    // to wrapping is 272.199 years (around 272 years 72 days)
    uint64 current_time = hal_rtc_get_time();
   19792:	4b0b      	ldr	r3, [pc, #44]	; (197c0 <hal_rtc_get_time_ms+0x30>)
   19794:	4798      	blx	r3
    // current_time = current_time * 1000;        //Safe because hal_rtc_get_time returns a 48 bit number
    // Replaced multiply by 1024-16-8
    current_time = ((current_time << 10) - (current_time << 4)) - (current_time << 3);
   19796:	0d84      	lsrs	r4, r0, #22
   19798:	0f06      	lsrs	r6, r0, #28
   1979a:	028b      	lsls	r3, r1, #10
   1979c:	010d      	lsls	r5, r1, #4
   1979e:	4335      	orrs	r5, r6
   197a0:	4323      	orrs	r3, r4
   197a2:	0282      	lsls	r2, r0, #10
   197a4:	0104      	lsls	r4, r0, #4
   197a6:	1b12      	subs	r2, r2, r4
   197a8:	41ab      	sbcs	r3, r5
   197aa:	0f46      	lsrs	r6, r0, #29
   197ac:	00cd      	lsls	r5, r1, #3
   197ae:	4335      	orrs	r5, r6
   197b0:	00c4      	lsls	r4, r0, #3
   197b2:	1b12      	subs	r2, r2, r4
   197b4:	41ab      	sbcs	r3, r5
    return (current_time >> 15);
   197b6:	0459      	lsls	r1, r3, #17
   197b8:	0bd0      	lsrs	r0, r2, #15
   197ba:	4308      	orrs	r0, r1
   197bc:	0bd9      	lsrs	r1, r3, #15
}
   197be:	bd70      	pop	{r4, r5, r6, pc}
   197c0:	010004b1 	.word	0x010004b1

000197c4 <hal_uart_init>:
/** hal uart module status */
static bool hal_uart_initialised = false;


void hal_uart_init( void )
{
   197c4:	b570      	push	{r4, r5, r6, lr}
    if( !hal_uart_initialised )
   197c6:	4e0f      	ldr	r6, [pc, #60]	; (19804 <hal_uart_init+0x40>)
   197c8:	7834      	ldrb	r4, [r6, #0]
   197ca:	2c00      	cmp	r4, #0
   197cc:	d113      	bne.n	197f6 <hal_uart_init+0x32>
   197ce:	b2e5      	uxtb	r5, r4
    {
        for( UART_BUS uart = UART_BUS_0; uart < UART_BUS_MAX_NUMBER; uart++ )
        {   // Ensure UARTS are not initially enabled
            if( hal_uart_specific_is_clock_enabled( uart ) || hal_uart_specific_enable_clock( uart ) )
   197d0:	0028      	movs	r0, r5
   197d2:	f000 fc8d 	bl	1a0f0 <hal_uart_specific_is_clock_enabled>
   197d6:	2800      	cmp	r0, #0
   197d8:	d00e      	beq.n	197f8 <hal_uart_init+0x34>
            {   // Only reset UARTs that we've claimed ownership of
                hal_uart_force_isr_flags[uart] = 0;
   197da:	2200      	movs	r2, #0
   197dc:	4b0a      	ldr	r3, [pc, #40]	; (19808 <hal_uart_init+0x44>)
                hal_uart_specific_reset_uart( uart );
   197de:	0028      	movs	r0, r5
                hal_uart_force_isr_flags[uart] = 0;
   197e0:	54e2      	strb	r2, [r4, r3]
                hal_uart_specific_reset_uart( uart );
   197e2:	f000 fc3d 	bl	1a060 <hal_uart_specific_reset_uart>
                hal_uart_specific_disable_clock( uart );
   197e6:	0028      	movs	r0, r5
   197e8:	f000 fc9e 	bl	1a128 <hal_uart_specific_disable_clock>
   197ec:	3401      	adds	r4, #1
        for( UART_BUS uart = UART_BUS_0; uart < UART_BUS_MAX_NUMBER; uart++ )
   197ee:	2c03      	cmp	r4, #3
   197f0:	d1ed      	bne.n	197ce <hal_uart_init+0xa>
            }
        }

        hal_uart_initialised = true;
   197f2:	2301      	movs	r3, #1
   197f4:	7033      	strb	r3, [r6, #0]
    }
}
   197f6:	bd70      	pop	{r4, r5, r6, pc}
            if( hal_uart_specific_is_clock_enabled( uart ) || hal_uart_specific_enable_clock( uart ) )
   197f8:	0028      	movs	r0, r5
   197fa:	f000 fc4f 	bl	1a09c <hal_uart_specific_enable_clock>
   197fe:	2800      	cmp	r0, #0
   19800:	d1eb      	bne.n	197da <hal_uart_init+0x16>
   19802:	e7f3      	b.n	197ec <hal_uart_init+0x28>
   19804:	01002b8b 	.word	0x01002b8b
   19808:	01002b88 	.word	0x01002b88

0001980c <hal_uart_claim>:
        hal_uart_initialised = false;
    }
}

bool hal_uart_claim( UART_BUS uart )
{
   1980c:	b570      	push	{r4, r5, r6, lr}
   1980e:	0004      	movs	r4, r0
    assert( uart < UART_BUS_MAX_NUMBER );
   19810:	2802      	cmp	r0, #2
   19812:	d903      	bls.n	1981c <hal_uart_claim+0x10>
   19814:	4671      	mov	r1, lr
   19816:	2016      	movs	r0, #22
   19818:	f7e8 f97a 	bl	1b10 <panic>
    if( hal_uart_specific_enable_clock( uart ) )
   1981c:	0020      	movs	r0, r4
   1981e:	f000 fc3d 	bl	1a09c <hal_uart_specific_enable_clock>
   19822:	1e05      	subs	r5, r0, #0
   19824:	d005      	beq.n	19832 <hal_uart_claim+0x26>
    {
        hal_uart_force_isr_flags[uart] = 0;
   19826:	2200      	movs	r2, #0
   19828:	4b03      	ldr	r3, [pc, #12]	; (19838 <hal_uart_claim+0x2c>)
        hal_uart_specific_reset_uart( uart );
   1982a:	0020      	movs	r0, r4
        hal_uart_force_isr_flags[uart] = 0;
   1982c:	551a      	strb	r2, [r3, r4]
        hal_uart_specific_reset_uart( uart );
   1982e:	f000 fc17 	bl	1a060 <hal_uart_specific_reset_uart>
        return true;
    }

    return false;
}
   19832:	0028      	movs	r0, r5
   19834:	bd70      	pop	{r4, r5, r6, pc}
   19836:	46c0      	nop			; (mov r8, r8)
   19838:	01002b88 	.word	0x01002b88

0001983c <hal_uart_is_claimed>:

bool hal_uart_is_claimed( UART_BUS uart )
{
   1983c:	b510      	push	{r4, lr}
   1983e:	0004      	movs	r4, r0
    assert( uart < UART_BUS_MAX_NUMBER );
   19840:	2802      	cmp	r0, #2
   19842:	d903      	bls.n	1984c <hal_uart_is_claimed+0x10>
   19844:	4671      	mov	r1, lr
   19846:	2016      	movs	r0, #22
   19848:	f7e8 f962 	bl	1b10 <panic>
    return hal_uart_specific_is_clock_enabled( uart );
   1984c:	0020      	movs	r0, r4
   1984e:	f000 fc4f 	bl	1a0f0 <hal_uart_specific_is_clock_enabled>
}
   19852:	bd10      	pop	{r4, pc}

00019854 <hal_uart_release>:

void hal_uart_release( UART_BUS uart )
{
   19854:	b510      	push	{r4, lr}
   19856:	0004      	movs	r4, r0
    assert( uart < UART_BUS_MAX_NUMBER );
   19858:	2802      	cmp	r0, #2
   1985a:	d903      	bls.n	19864 <hal_uart_release+0x10>
   1985c:	4671      	mov	r1, lr
   1985e:	2016      	movs	r0, #22
   19860:	f7e8 f956 	bl	1b10 <panic>
    if( hal_uart_specific_is_clock_enabled( uart ) )
   19864:	0020      	movs	r0, r4
   19866:	f000 fc43 	bl	1a0f0 <hal_uart_specific_is_clock_enabled>
   1986a:	2800      	cmp	r0, #0
   1986c:	d008      	beq.n	19880 <hal_uart_release+0x2c>
    {
        hal_uart_force_isr_flags[uart] = 0;
   1986e:	2200      	movs	r2, #0
   19870:	4b04      	ldr	r3, [pc, #16]	; (19884 <hal_uart_release+0x30>)
        hal_uart_specific_reset_uart( uart );
   19872:	0020      	movs	r0, r4
        hal_uart_force_isr_flags[uart] = 0;
   19874:	551a      	strb	r2, [r3, r4]
        hal_uart_specific_reset_uart( uart );
   19876:	f000 fbf3 	bl	1a060 <hal_uart_specific_reset_uart>
        hal_uart_specific_disable_clock( uart );
   1987a:	0020      	movs	r0, r4
   1987c:	f000 fc54 	bl	1a128 <hal_uart_specific_disable_clock>
    }
}
   19880:	bd10      	pop	{r4, pc}
   19882:	46c0      	nop			; (mov r8, r8)
   19884:	01002b88 	.word	0x01002b88

00019888 <hal_uart_set_fifo>:

void hal_uart_set_fifo( UART_BUS uart, HAL_UART_FIFO fifo )
{
   19888:	b570      	push	{r4, r5, r6, lr}
   1988a:	000d      	movs	r5, r1
    volatile uart_ctrl_t * hal_uart = hal_uart_specific_get_uart( uart );
   1988c:	f000 fbd2 	bl	1a034 <hal_uart_specific_get_uart>
   19890:	0004      	movs	r4, r0

    non_os_enter_critical();
   19892:	f7fe fc8f 	bl	181b4 <non_os_enter_critical>
   19896:	2310      	movs	r3, #16
    if( fifo == HAL_UART_FIFO_ENABLED )
    {
        hal_uart->UARTLCR_H |= UARTLCR_H_FEN_MASK;
   19898:	6ae2      	ldr	r2, [r4, #44]	; 0x2c
    if( fifo == HAL_UART_FIFO_ENABLED )
   1989a:	2d00      	cmp	r5, #0
   1989c:	d104      	bne.n	198a8 <hal_uart_set_fifo+0x20>
        hal_uart->UARTLCR_H |= UARTLCR_H_FEN_MASK;
   1989e:	4313      	orrs	r3, r2
   198a0:	62e3      	str	r3, [r4, #44]	; 0x2c
    }
    else
    {
        hal_uart->UARTLCR_H &= ~UARTLCR_H_FEN_MASK;
    }
    non_os_exit_critical();
   198a2:	f7fe fc9b 	bl	181dc <non_os_exit_critical>
}
   198a6:	bd70      	pop	{r4, r5, r6, pc}
        hal_uart->UARTLCR_H &= ~UARTLCR_H_FEN_MASK;
   198a8:	439a      	bics	r2, r3
   198aa:	62e2      	str	r2, [r4, #44]	; 0x2c
   198ac:	e7f9      	b.n	198a2 <hal_uart_set_fifo+0x1a>

000198ae <hal_uart_set_fifo_int_levels>:

void hal_uart_set_fifo_int_levels( UART_BUS uart, HAL_UART_FIFO_INT_LEVEL rx_level, HAL_UART_FIFO_INT_LEVEL tx_level )
{
   198ae:	b570      	push	{r4, r5, r6, lr}
   198b0:	000c      	movs	r4, r1
   198b2:	0016      	movs	r6, r2
    volatile uart_ctrl_t * hal_uart = hal_uart_specific_get_uart( uart );
   198b4:	f000 fbbe 	bl	1a034 <hal_uart_specific_get_uart>
   198b8:	0005      	movs	r5, r0
    non_os_enter_critical();
   198ba:	f7fe fc7b 	bl	181b4 <non_os_enter_critical>

    hal_uart->UARTIFLS = (hal_uart->UARTIFLS & ~UARTIFLS_RXIFLSEL_MASK) | UARTIFLS_RXIFLSEL(rx_level);
   198be:	2238      	movs	r2, #56	; 0x38
   198c0:	6b6b      	ldr	r3, [r5, #52]	; 0x34
   198c2:	00e4      	lsls	r4, r4, #3
   198c4:	4393      	bics	r3, r2
   198c6:	4014      	ands	r4, r2
   198c8:	431c      	orrs	r4, r3
   198ca:	636c      	str	r4, [r5, #52]	; 0x34
    hal_uart->UARTIFLS = (hal_uart->UARTIFLS & ~UARTIFLS_TXIFLSEL_MASK) | UARTIFLS_TXIFLSEL(tx_level);
   198cc:	6b6b      	ldr	r3, [r5, #52]	; 0x34
   198ce:	3a31      	subs	r2, #49	; 0x31
   198d0:	4393      	bics	r3, r2
   198d2:	4016      	ands	r6, r2
   198d4:	431e      	orrs	r6, r3
   198d6:	636e      	str	r6, [r5, #52]	; 0x34
    non_os_exit_critical();
   198d8:	f7fe fc80 	bl	181dc <non_os_exit_critical>
}
   198dc:	bd70      	pop	{r4, r5, r6, pc}
	...

000198e0 <hal_uart_get_rx_fifo_level>:

/*
 * Obtains the RX FIFO trigger level in bytes, as configured by hal_uart_set_fifo_int_levels
 */
uint8 hal_uart_get_rx_fifo_level( UART_BUS uart )
{
   198e0:	b510      	push	{r4, lr}
    static const uint8 rx_level_bytes[HAL_UART_FIFO_INT_LEVEL_7_8 + 1] = { 4, 8, 16, 24, 28 };
    volatile uart_ctrl_t * hal_uart = hal_uart_specific_get_uart( uart );
   198e2:	f000 fba7 	bl	1a034 <hal_uart_specific_get_uart>

    uint8 rx_level = (hal_uart->UARTIFLS & UARTIFLS_RXIFLSEL_MASK) >> 3;
   198e6:	6b43      	ldr	r3, [r0, #52]	; 0x34
    {
        return rx_level_bytes[rx_level];
    }
    else
    {
        return 0;
   198e8:	2000      	movs	r0, #0
    uint8 rx_level = (hal_uart->UARTIFLS & UARTIFLS_RXIFLSEL_MASK) >> 3;
   198ea:	069b      	lsls	r3, r3, #26
   198ec:	0f5b      	lsrs	r3, r3, #29
    if( rx_level <= HAL_UART_FIFO_INT_LEVEL_7_8 )
   198ee:	2b04      	cmp	r3, #4
   198f0:	d801      	bhi.n	198f6 <hal_uart_get_rx_fifo_level+0x16>
        return rx_level_bytes[rx_level];
   198f2:	4a01      	ldr	r2, [pc, #4]	; (198f8 <hal_uart_get_rx_fifo_level+0x18>)
   198f4:	5cd0      	ldrb	r0, [r2, r3]
    }
}
   198f6:	bd10      	pop	{r4, pc}
   198f8:	00025590 	.word	0x00025590

000198fc <hal_uart_get_data_register>:

volatile uint32 * hal_uart_get_data_register( UART_BUS uart )
{
   198fc:	b510      	push	{r4, lr}
    volatile uart_ctrl_t * hal_uart = hal_uart_specific_get_uart( uart );
   198fe:	f000 fb99 	bl	1a034 <hal_uart_specific_get_uart>
    return (volatile uint32 *) &(hal_uart->UARTDR);
}
   19902:	bd10      	pop	{r4, pc}

00019904 <hal_uart_get_error_register>:

volatile uint32 * hal_uart_get_error_register( UART_BUS uart )
{
   19904:	b510      	push	{r4, lr}
    volatile uart_ctrl_t * hal_uart = hal_uart_specific_get_uart( uart );
   19906:	f000 fb95 	bl	1a034 <hal_uart_specific_get_uart>
    return (volatile uint32 *) &(hal_uart->UARTMIS);
   1990a:	3040      	adds	r0, #64	; 0x40
}
   1990c:	bd10      	pop	{r4, pc}

0001990e <hal_uart_get_flag_register>:

volatile uint32 * hal_uart_get_flag_register( UART_BUS uart )
{
   1990e:	b510      	push	{r4, lr}
    volatile uart_ctrl_t * hal_uart = hal_uart_specific_get_uart( uart );
   19910:	f000 fb90 	bl	1a034 <hal_uart_specific_get_uart>
    return (volatile uint32 *)&hal_uart->UARTFR;
   19914:	3018      	adds	r0, #24
}
   19916:	bd10      	pop	{r4, pc}

00019918 <hal_uart_set_baud_rate>:

void hal_uart_set_baud_rate( UART_BUS uart, uint32 baud )
{
   19918:	b570      	push	{r4, r5, r6, lr}
   1991a:	000c      	movs	r4, r1
    volatile uart_ctrl_t * hal_uart = hal_uart_specific_get_uart( uart );
   1991c:	f000 fb8a 	bl	1a034 <hal_uart_specific_get_uart>
   19920:	0005      	movs	r5, r0
     * This decimal part could be expressed as
     * remainder/(16*baud) , being reminder = core_clock % (baud * 16)
     * Then
     * round (decimal_part * 64) = round ( remainder * 64 / (16 * baud) ) = round ( remainder * 4 / ( * baud) )
     */
    uint32 core_clock = hal_clocks_get_core_clock_mid_value();
   19922:	f7ff fa5f 	bl	18de4 <hal_clocks_get_core_clock_mid_value>
    uint32 brd_i = core_clock / (baud << 4);
   19926:	0121      	lsls	r1, r4, #4
   19928:	f7e6 fdcc 	bl	4c4 <__aeabi_uidivmod>
   1992c:	0006      	movs	r6, r0
    uint32 remainder = core_clock % (baud << 4);
    uint32 brd_f = ((remainder << 3) / baud) >> 1;
   1992e:	00c8      	lsls	r0, r1, #3
   19930:	0021      	movs	r1, r4
   19932:	f7e6 fd41 	bl	3b8 <__udivsi3>

    brd_f += ((remainder << 3) / baud) & 1;
   19936:	2301      	movs	r3, #1
    uint32 brd_f = ((remainder << 3) / baud) >> 1;
   19938:	0844      	lsrs	r4, r0, #1
    brd_f += ((remainder << 3) / baud) & 1;
   1993a:	4018      	ands	r0, r3
   1993c:	1904      	adds	r4, r0, r4

    non_os_enter_critical();
   1993e:	f7fe fc39 	bl	181b4 <non_os_enter_critical>
    hal_uart->UARTIBRD = brd_i;
   19942:	626e      	str	r6, [r5, #36]	; 0x24
    hal_uart->UARTFBRD = brd_f;
   19944:	62ac      	str	r4, [r5, #40]	; 0x28

    hal_uart->UARTLCR_H = hal_uart->UARTLCR_H; // in order to make IBRD and FBRD update (ARM DDI 0183F,3-13)
   19946:	6aeb      	ldr	r3, [r5, #44]	; 0x2c
   19948:	62eb      	str	r3, [r5, #44]	; 0x2c
    non_os_exit_critical();
   1994a:	f7fe fc47 	bl	181dc <non_os_exit_critical>
}
   1994e:	bd70      	pop	{r4, r5, r6, pc}

00019950 <hal_uart_set_data_bits>:
    baud = ((core_clock * 64) / divider);
    return baud;
}

void hal_uart_set_data_bits( UART_BUS uart, UART_DATA_BITS bits )
{
   19950:	b570      	push	{r4, r5, r6, lr}
   19952:	000c      	movs	r4, r1
    volatile uart_ctrl_t * hal_uart = hal_uart_specific_get_uart( uart );
   19954:	f000 fb6e 	bl	1a034 <hal_uart_specific_get_uart>
   19958:	0005      	movs	r5, r0

    non_os_enter_critical();
   1995a:	f7fe fc2b 	bl	181b4 <non_os_enter_critical>
    hal_uart->UARTLCR_H = (hal_uart->UARTLCR_H & ~UARTLCR_H_WLEN_MASK) | UARTLCR_H_WLEN(bits);
   1995e:	2260      	movs	r2, #96	; 0x60
   19960:	6aeb      	ldr	r3, [r5, #44]	; 0x2c
   19962:	0164      	lsls	r4, r4, #5
   19964:	4014      	ands	r4, r2
   19966:	4393      	bics	r3, r2
   19968:	431c      	orrs	r4, r3
   1996a:	62ec      	str	r4, [r5, #44]	; 0x2c
    non_os_exit_critical();
   1996c:	f7fe fc36 	bl	181dc <non_os_exit_critical>
}
   19970:	bd70      	pop	{r4, r5, r6, pc}

00019972 <hal_uart_set_stop_bits>:

void hal_uart_set_stop_bits( UART_BUS uart, UART_STOP_BITS bits )
{
   19972:	b570      	push	{r4, r5, r6, lr}
   19974:	000d      	movs	r5, r1
    volatile uart_ctrl_t * hal_uart = hal_uart_specific_get_uart( uart );
   19976:	f000 fb5d 	bl	1a034 <hal_uart_specific_get_uart>
   1997a:	0004      	movs	r4, r0
    non_os_enter_critical();
   1997c:	f7fe fc1a 	bl	181b4 <non_os_enter_critical>
   19980:	2308      	movs	r3, #8

    if (bits == UART_STOP_BITS_1)
    {
        hal_uart->UARTLCR_H &= ~UARTLCR_H_STP2_MASK;
   19982:	6ae2      	ldr	r2, [r4, #44]	; 0x2c
    if (bits == UART_STOP_BITS_1)
   19984:	2d00      	cmp	r5, #0
   19986:	d104      	bne.n	19992 <hal_uart_set_stop_bits+0x20>
        hal_uart->UARTLCR_H &= ~UARTLCR_H_STP2_MASK;
   19988:	439a      	bics	r2, r3
   1998a:	62e2      	str	r2, [r4, #44]	; 0x2c
    }
    else
    {
        hal_uart->UARTLCR_H |= UARTLCR_H_STP2_MASK;
    }
    non_os_exit_critical();
   1998c:	f7fe fc26 	bl	181dc <non_os_exit_critical>
}
   19990:	bd70      	pop	{r4, r5, r6, pc}
        hal_uart->UARTLCR_H |= UARTLCR_H_STP2_MASK;
   19992:	4313      	orrs	r3, r2
   19994:	62e3      	str	r3, [r4, #44]	; 0x2c
   19996:	e7f9      	b.n	1998c <hal_uart_set_stop_bits+0x1a>

00019998 <hal_uart_set_parity>:

void hal_uart_set_parity( UART_BUS uart, UART_PARITY parity )
{
   19998:	b570      	push	{r4, r5, r6, lr}
   1999a:	000d      	movs	r5, r1
    volatile uart_ctrl_t * hal_uart = hal_uart_specific_get_uart( uart );
   1999c:	f000 fb4a 	bl	1a034 <hal_uart_specific_get_uart>
   199a0:	0004      	movs	r4, r0

    non_os_enter_critical();
   199a2:	f7fe fc07 	bl	181b4 <non_os_enter_critical>
    switch (parity)
   199a6:	2d01      	cmp	r5, #1
   199a8:	d00f      	beq.n	199ca <hal_uart_set_parity+0x32>
   199aa:	2d00      	cmp	r5, #0
   199ac:	d004      	beq.n	199b8 <hal_uart_set_parity+0x20>
   199ae:	2d02      	cmp	r5, #2
   199b0:	d007      	beq.n	199c2 <hal_uart_set_parity+0x2a>

    case UART_PARITY_ODD:
        hal_uart->UARTLCR_H = (hal_uart->UARTLCR_H & ~UARTLCR_H_EPS_MASK) | (UARTLCR_H_PEN_MASK); // Set parity Enable and clear Parity Even
        break;
    }
    non_os_exit_critical();
   199b2:	f7fe fc13 	bl	181dc <non_os_exit_critical>
}
   199b6:	bd70      	pop	{r4, r5, r6, pc}
        hal_uart->UARTLCR_H &= ~UARTLCR_H_PEN_MASK;
   199b8:	2202      	movs	r2, #2
   199ba:	6ae3      	ldr	r3, [r4, #44]	; 0x2c
   199bc:	4393      	bics	r3, r2
        hal_uart->UARTLCR_H = (hal_uart->UARTLCR_H & ~UARTLCR_H_EPS_MASK) | (UARTLCR_H_PEN_MASK); // Set parity Enable and clear Parity Even
   199be:	62e3      	str	r3, [r4, #44]	; 0x2c
        break;
   199c0:	e7f7      	b.n	199b2 <hal_uart_set_parity+0x1a>
        hal_uart->UARTLCR_H = (hal_uart->UARTLCR_H | (UARTLCR_H_PEN_MASK | UARTLCR_H_EPS_MASK)); // Set parity Enable and Parity Even
   199c2:	2306      	movs	r3, #6
   199c4:	6ae2      	ldr	r2, [r4, #44]	; 0x2c
        hal_uart->UARTLCR_H = (hal_uart->UARTLCR_H & ~UARTLCR_H_EPS_MASK) | (UARTLCR_H_PEN_MASK); // Set parity Enable and clear Parity Even
   199c6:	4313      	orrs	r3, r2
   199c8:	e7f9      	b.n	199be <hal_uart_set_parity+0x26>
   199ca:	2206      	movs	r2, #6
   199cc:	6ae3      	ldr	r3, [r4, #44]	; 0x2c
   199ce:	4393      	bics	r3, r2
   199d0:	001a      	movs	r2, r3
   199d2:	2302      	movs	r3, #2
   199d4:	e7f7      	b.n	199c6 <hal_uart_set_parity+0x2e>

000199d6 <hal_uart_enable_interrupt>:
    }
    non_os_exit_critical();
}

void hal_uart_enable_interrupt( UART_BUS uart, HAL_UART_INTERRUPT interrupt_type )
{
   199d6:	b570      	push	{r4, r5, r6, lr}
   199d8:	4676      	mov	r6, lr
   199da:	0004      	movs	r4, r0
   199dc:	000d      	movs	r5, r1
    volatile uart_ctrl_t * hal_uart = hal_uart_specific_get_uart( uart );
   199de:	f000 fb29 	bl	1a034 <hal_uart_specific_get_uart>
   199e2:	0003      	movs	r3, r0

    // Perform configuration
    switch (interrupt_type)
   199e4:	2d03      	cmp	r5, #3
   199e6:	d813      	bhi.n	19a10 <hal_uart_enable_interrupt+0x3a>
   199e8:	0028      	movs	r0, r5
    case HAL_UART_INTERRUPT_IDLE:
        hal_uart->UARTIMSC |= UARTIMSC_RTIM_MASK;
        break;

    case HAL_UART_INTERRUPT_ERROR:
        hal_uart->UARTIMSC |= (UARTIMSC_OEIM_MASK | UARTIMSC_BEIM_MASK | UARTIMSC_PEIM_MASK | UARTIMSC_FEIM_MASK);
   199ea:	6b99      	ldr	r1, [r3, #56]	; 0x38
    switch (interrupt_type)
   199ec:	f7e6 fcda 	bl	3a4 <__gnu_thumb1_case_uqi>
   199f0:	0d0b0209 	.word	0x0d0b0209
        hal_uart->UARTIMSC |= UARTIMSC_TXIM_MASK;
   199f4:	2220      	movs	r2, #32
        hal_uart->UARTIMSC |= UARTIMSC_RXIM_MASK;
   199f6:	430a      	orrs	r2, r1
   199f8:	639a      	str	r2, [r3, #56]	; 0x38

    default:
        assert(false); // it should never get here
    }

    hal_uart_specific_enable_irq( uart );
   199fa:	0020      	movs	r0, r4
   199fc:	f000 fbb0 	bl	1a160 <hal_uart_specific_enable_irq>
}
   19a00:	bd70      	pop	{r4, r5, r6, pc}
        hal_uart->UARTIMSC |= UARTIMSC_RXIM_MASK;
   19a02:	2210      	movs	r2, #16
   19a04:	e7f7      	b.n	199f6 <hal_uart_enable_interrupt+0x20>
        hal_uart->UARTIMSC |= UARTIMSC_RTIM_MASK;
   19a06:	2240      	movs	r2, #64	; 0x40
   19a08:	e7f5      	b.n	199f6 <hal_uart_enable_interrupt+0x20>
        hal_uart->UARTIMSC |= (UARTIMSC_OEIM_MASK | UARTIMSC_BEIM_MASK | UARTIMSC_PEIM_MASK | UARTIMSC_FEIM_MASK);
   19a0a:	22f0      	movs	r2, #240	; 0xf0
   19a0c:	00d2      	lsls	r2, r2, #3
   19a0e:	e7f2      	b.n	199f6 <hal_uart_enable_interrupt+0x20>
        assert(false); // it should never get here
   19a10:	0031      	movs	r1, r6
   19a12:	2016      	movs	r0, #22
   19a14:	f7e8 f87c 	bl	1b10 <panic>
   19a18:	e7ef      	b.n	199fa <hal_uart_enable_interrupt+0x24>
	...

00019a1c <hal_uart_disable_interrupt>:

void hal_uart_disable_interrupt( UART_BUS uart, HAL_UART_INTERRUPT interrupt_type )
{
   19a1c:	b570      	push	{r4, r5, r6, lr}
   19a1e:	4675      	mov	r5, lr
   19a20:	000c      	movs	r4, r1
    volatile uart_ctrl_t * hal_uart = hal_uart_specific_get_uart( uart );
   19a22:	f000 fb07 	bl	1a034 <hal_uart_specific_get_uart>
   19a26:	0003      	movs	r3, r0

    switch (interrupt_type)
   19a28:	2c03      	cmp	r4, #3
   19a2a:	d810      	bhi.n	19a4e <hal_uart_disable_interrupt+0x32>
   19a2c:	0020      	movs	r0, r4
    case HAL_UART_INTERRUPT_IDLE:
        hal_uart->UARTIMSC &= ~UARTIMSC_RTIM_MASK;
        break;

    case HAL_UART_INTERRUPT_ERROR:
        hal_uart->UARTIMSC &= ~(UARTIMSC_OEIM_MASK | UARTIMSC_BEIM_MASK | UARTIMSC_PEIM_MASK | UARTIMSC_FEIM_MASK);
   19a2e:	6b9a      	ldr	r2, [r3, #56]	; 0x38
    switch (interrupt_type)
   19a30:	f7e6 fcb8 	bl	3a4 <__gnu_thumb1_case_uqi>
   19a34:	0a080206 	.word	0x0a080206
        hal_uart->UARTIMSC &= ~UARTIMSC_TXIM_MASK;
   19a38:	2120      	movs	r1, #32
        hal_uart->UARTIMSC &= ~UARTIMSC_RTIM_MASK;
   19a3a:	438a      	bics	r2, r1
        hal_uart->UARTIMSC &= ~(UARTIMSC_OEIM_MASK | UARTIMSC_BEIM_MASK | UARTIMSC_PEIM_MASK | UARTIMSC_FEIM_MASK);
   19a3c:	639a      	str	r2, [r3, #56]	; 0x38
        break;

    default:
        assert(false); // it should never get here
    }
}
   19a3e:	bd70      	pop	{r4, r5, r6, pc}
        hal_uart->UARTIMSC &= ~UARTIMSC_RXIM_MASK;
   19a40:	2110      	movs	r1, #16
   19a42:	e7fa      	b.n	19a3a <hal_uart_disable_interrupt+0x1e>
        hal_uart->UARTIMSC &= ~UARTIMSC_RTIM_MASK;
   19a44:	2140      	movs	r1, #64	; 0x40
   19a46:	e7f8      	b.n	19a3a <hal_uart_disable_interrupt+0x1e>
        hal_uart->UARTIMSC &= ~(UARTIMSC_OEIM_MASK | UARTIMSC_BEIM_MASK | UARTIMSC_PEIM_MASK | UARTIMSC_FEIM_MASK);
   19a48:	4903      	ldr	r1, [pc, #12]	; (19a58 <hal_uart_disable_interrupt+0x3c>)
   19a4a:	400a      	ands	r2, r1
   19a4c:	e7f6      	b.n	19a3c <hal_uart_disable_interrupt+0x20>
        assert(false); // it should never get here
   19a4e:	0029      	movs	r1, r5
   19a50:	2016      	movs	r0, #22
   19a52:	f7e8 f85d 	bl	1b10 <panic>
}
   19a56:	e7f2      	b.n	19a3e <hal_uart_disable_interrupt+0x22>
   19a58:	fffff87f 	.word	0xfffff87f

00019a5c <hal_uart_configure_interrupt>:
{
   19a5c:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
   19a5e:	4677      	mov	r7, lr
   19a60:	0004      	movs	r4, r0
   19a62:	000d      	movs	r5, r1
   19a64:	0016      	movs	r6, r2
   19a66:	9301      	str	r3, [sp, #4]
    assert( uart < UART_BUS_MAX_NUMBER );
   19a68:	2802      	cmp	r0, #2
   19a6a:	d903      	bls.n	19a74 <hal_uart_configure_interrupt+0x18>
   19a6c:	4671      	mov	r1, lr
   19a6e:	2016      	movs	r0, #22
   19a70:	f7e8 f84e 	bl	1b10 <panic>
    non_os_enter_critical();
   19a74:	f7fe fb9e 	bl	181b4 <non_os_enter_critical>
    if( hal_uart_initialised && (uart < UART_BUS_MAX_NUMBER) )
   19a78:	4b15      	ldr	r3, [pc, #84]	; (19ad0 <hal_uart_configure_interrupt+0x74>)
   19a7a:	781b      	ldrb	r3, [r3, #0]
   19a7c:	2b00      	cmp	r3, #0
   19a7e:	d013      	beq.n	19aa8 <hal_uart_configure_interrupt+0x4c>
   19a80:	2c02      	cmp	r4, #2
   19a82:	d811      	bhi.n	19aa8 <hal_uart_configure_interrupt+0x4c>
        switch( interrupt_type )
   19a84:	2d03      	cmp	r5, #3
   19a86:	d81a      	bhi.n	19abe <hal_uart_configure_interrupt+0x62>
   19a88:	0028      	movs	r0, r5
   19a8a:	4b12      	ldr	r3, [pc, #72]	; (19ad4 <hal_uart_configure_interrupt+0x78>)
   19a8c:	0122      	lsls	r2, r4, #4
   19a8e:	f7e6 fc89 	bl	3a4 <__gnu_thumb1_case_uqi>
   19a92:	020e      	.short	0x020e
   19a94:	1310      	.short	0x1310
            hal_uart_interrupt_handler[uart].tx_isr = callback;
   19a96:	189b      	adds	r3, r3, r2
   19a98:	605e      	str	r6, [r3, #4]
        if( initial_state == INTERRUPT_STATE_ENABLED )
   19a9a:	9b01      	ldr	r3, [sp, #4]
            hal_uart_enable_interrupt( uart, interrupt_type );
   19a9c:	0029      	movs	r1, r5
   19a9e:	0020      	movs	r0, r4
        if( initial_state == INTERRUPT_STATE_ENABLED )
   19aa0:	2b01      	cmp	r3, #1
   19aa2:	d111      	bne.n	19ac8 <hal_uart_configure_interrupt+0x6c>
            hal_uart_enable_interrupt( uart, interrupt_type );
   19aa4:	f7ff ff97 	bl	199d6 <hal_uart_enable_interrupt>
    non_os_exit_critical();
   19aa8:	f7fe fb98 	bl	181dc <non_os_exit_critical>
}
   19aac:	bdf7      	pop	{r0, r1, r2, r4, r5, r6, r7, pc}
            hal_uart_interrupt_handler[uart].rx_isr = callback;
   19aae:	509e      	str	r6, [r3, r2]
            break;
   19ab0:	e7f3      	b.n	19a9a <hal_uart_configure_interrupt+0x3e>
            hal_uart_interrupt_handler[uart].idle_isr = callback;
   19ab2:	189b      	adds	r3, r3, r2
   19ab4:	609e      	str	r6, [r3, #8]
            break;
   19ab6:	e7f0      	b.n	19a9a <hal_uart_configure_interrupt+0x3e>
            hal_uart_interrupt_handler[uart].error_isr = callback;
   19ab8:	189b      	adds	r3, r3, r2
   19aba:	60de      	str	r6, [r3, #12]
            break;
   19abc:	e7ed      	b.n	19a9a <hal_uart_configure_interrupt+0x3e>
            assert(false); // it should never get here
   19abe:	0039      	movs	r1, r7
   19ac0:	2016      	movs	r0, #22
   19ac2:	f7e8 f825 	bl	1b10 <panic>
   19ac6:	e7e8      	b.n	19a9a <hal_uart_configure_interrupt+0x3e>
            hal_uart_disable_interrupt( uart, interrupt_type );
   19ac8:	f7ff ffa8 	bl	19a1c <hal_uart_disable_interrupt>
   19acc:	e7ec      	b.n	19aa8 <hal_uart_configure_interrupt+0x4c>
   19ace:	46c0      	nop			; (mov r8, r8)
   19ad0:	01002b8b 	.word	0x01002b8b
   19ad4:	01002b8c 	.word	0x01002b8c

00019ad8 <hal_uart_clear_interrupt>:

void hal_uart_clear_interrupt( UART_BUS uart, HAL_UART_INTERRUPT interrupt_type )
{
   19ad8:	b570      	push	{r4, r5, r6, lr}
   19ada:	4675      	mov	r5, lr
   19adc:	000c      	movs	r4, r1
    volatile uart_ctrl_t * hal_uart = hal_uart_specific_get_uart( uart );
   19ade:	f000 faa9 	bl	1a034 <hal_uart_specific_get_uart>
   19ae2:	0003      	movs	r3, r0

    switch (interrupt_type)
   19ae4:	2c03      	cmp	r4, #3
   19ae6:	d811      	bhi.n	19b0c <hal_uart_clear_interrupt+0x34>
   19ae8:	0020      	movs	r0, r4
   19aea:	f7e6 fc5b 	bl	3a4 <__gnu_thumb1_case_uqi>
   19aee:	0205      	.short	0x0205
   19af0:	0907      	.short	0x0907
    {
    case HAL_UART_INTERRUPT_TX:
        hal_uart->UARTICR = UARTIMSC_TXIM_MASK;
   19af2:	2220      	movs	r2, #32
    case HAL_UART_INTERRUPT_RX:
        hal_uart->UARTICR = UARTIMSC_RXIM_MASK;
        break;

    case HAL_UART_INTERRUPT_IDLE:
        hal_uart->UARTICR = UARTIMSC_RTIM_MASK;
   19af4:	645a      	str	r2, [r3, #68]	; 0x44
        break;

    default:
        assert(false); // it should never get here
    }
}
   19af6:	bd70      	pop	{r4, r5, r6, pc}
        hal_uart->UARTICR = UARTIMSC_RXIM_MASK;
   19af8:	2210      	movs	r2, #16
   19afa:	e7fb      	b.n	19af4 <hal_uart_clear_interrupt+0x1c>
        hal_uart->UARTICR = UARTIMSC_RTIM_MASK;
   19afc:	2240      	movs	r2, #64	; 0x40
   19afe:	e7f9      	b.n	19af4 <hal_uart_clear_interrupt+0x1c>
        hal_uart->UARTICR = (UARTIMSC_OEIM_MASK | UARTIMSC_BEIM_MASK | UARTIMSC_PEIM_MASK | UARTIMSC_FEIM_MASK);
   19b00:	22f0      	movs	r2, #240	; 0xf0
   19b02:	00d2      	lsls	r2, r2, #3
   19b04:	645a      	str	r2, [r3, #68]	; 0x44
        hal_uart->UARTRSR = 0;   // Need to clear source of the error interrupt too, otherwise it will never re-trigger
   19b06:	2200      	movs	r2, #0
   19b08:	605a      	str	r2, [r3, #4]
        break;
   19b0a:	e7f4      	b.n	19af6 <hal_uart_clear_interrupt+0x1e>
        assert(false); // it should never get here
   19b0c:	0029      	movs	r1, r5
   19b0e:	2016      	movs	r0, #22
   19b10:	f7e7 fffe 	bl	1b10 <panic>
}
   19b14:	e7ef      	b.n	19af6 <hal_uart_clear_interrupt+0x1e>

00019b16 <hal_uart_disable_uart>:

void hal_uart_disable_uart( UART_BUS uart )
{
   19b16:	b570      	push	{r4, r5, r6, lr}
   19b18:	0005      	movs	r5, r0
    volatile uart_ctrl_t * hal_uart = hal_uart_specific_get_uart( uart );
   19b1a:	f000 fa8b 	bl	1a034 <hal_uart_specific_get_uart>
   19b1e:	0004      	movs	r4, r0

    hal_uart_specific_disable_irq( uart );
   19b20:	0028      	movs	r0, r5
   19b22:	f000 fb2b 	bl	1a17c <hal_uart_specific_disable_irq>

    hal_uart->UARTCR &= ~UARTCR_UARTEN_MASK;
   19b26:	2201      	movs	r2, #1
   19b28:	6b23      	ldr	r3, [r4, #48]	; 0x30
   19b2a:	4393      	bics	r3, r2
   19b2c:	6323      	str	r3, [r4, #48]	; 0x30
    hal_uart->UARTLCR_H = 0;     // Flush the transmit FIFO by disabling bit 4 (FEN) in the line control register and reset parameters
   19b2e:	2300      	movs	r3, #0
   19b30:	62e3      	str	r3, [r4, #44]	; 0x2c
    hal_uart->UARTCR = 0;        // Disable everything
   19b32:	6323      	str	r3, [r4, #48]	; 0x30
}
   19b34:	bd70      	pop	{r4, r5, r6, pc}
	...

00019b38 <hal_uart_set_enable_uart>:

void hal_uart_set_enable_uart( UART_BUS uart, HAL_UART_ENABLE_FLAGS uart_enable_flags )
{
   19b38:	b570      	push	{r4, r5, r6, lr}
   19b3a:	000d      	movs	r5, r1
    volatile uart_ctrl_t * hal_uart = hal_uart_specific_get_uart( uart );
   19b3c:	f000 fa7a 	bl	1a034 <hal_uart_specific_get_uart>
   19b40:	0004      	movs	r4, r0

    non_os_enter_critical();
   19b42:	f7fe fb37 	bl	181b4 <non_os_enter_critical>
    hal_uart->UARTLCR_H = hal_uart->UARTLCR_H; // ensure it is updated before enabling it.(ARM DDI 0183F 3-13)
   19b46:	6ae3      	ldr	r3, [r4, #44]	; 0x2c
   19b48:	62e3      	str	r3, [r4, #44]	; 0x2c

    if( (uart_enable_flags & HAL_UART_ENABLE_FLAG_RX) == 0 )
   19b4a:	07eb      	lsls	r3, r5, #31
   19b4c:	d41c      	bmi.n	19b88 <hal_uart_set_enable_uart+0x50>
    {
        hal_uart->UARTCR &= ~UARTCR_RXE_MASK;
   19b4e:	6b23      	ldr	r3, [r4, #48]	; 0x30
   19b50:	4a17      	ldr	r2, [pc, #92]	; (19bb0 <hal_uart_set_enable_uart+0x78>)
   19b52:	4013      	ands	r3, r2
    }
    else
    {
        hal_uart->UARTCR |= UARTCR_RXE_MASK;
   19b54:	6323      	str	r3, [r4, #48]	; 0x30
    }

    if( (uart_enable_flags & HAL_UART_ENABLE_FLAG_TX) == 0 )
   19b56:	07ab      	lsls	r3, r5, #30
   19b58:	d41b      	bmi.n	19b92 <hal_uart_set_enable_uart+0x5a>
    {
        hal_uart->UARTCR &= ~UARTCR_TXE_MASK;
   19b5a:	6b23      	ldr	r3, [r4, #48]	; 0x30
   19b5c:	4a15      	ldr	r2, [pc, #84]	; (19bb4 <hal_uart_set_enable_uart+0x7c>)
   19b5e:	4013      	ands	r3, r2
    }
    else
    {
        hal_uart->UARTCR |= UARTCR_TXE_MASK;
   19b60:	6323      	str	r3, [r4, #48]	; 0x30
    }

    if( (uart_enable_flags & HAL_UART_ENABLE_FLAG_CTS) == 0 )
   19b62:	076b      	lsls	r3, r5, #29
   19b64:	d41a      	bmi.n	19b9c <hal_uart_set_enable_uart+0x64>
    {
        hal_uart->UARTCR &= ~UARTCR_CTSEN_MASK;
   19b66:	6b23      	ldr	r3, [r4, #48]	; 0x30
   19b68:	4a13      	ldr	r2, [pc, #76]	; (19bb8 <hal_uart_set_enable_uart+0x80>)
   19b6a:	4013      	ands	r3, r2
    }
    else
    {
        hal_uart->UARTCR |= UARTCR_CTSEN_MASK;
   19b6c:	6323      	str	r3, [r4, #48]	; 0x30
    }

    if( (uart_enable_flags & HAL_UART_ENABLE_FLAG_RTS) == 0 )
   19b6e:	072b      	lsls	r3, r5, #28
   19b70:	d419      	bmi.n	19ba6 <hal_uart_set_enable_uart+0x6e>
    {
        hal_uart->UARTCR &= ~UARTCR_RTSEN_MASK;
   19b72:	6b23      	ldr	r3, [r4, #48]	; 0x30
   19b74:	4a11      	ldr	r2, [pc, #68]	; (19bbc <hal_uart_set_enable_uart+0x84>)
   19b76:	4013      	ands	r3, r2
    }
    else
    {
        hal_uart->UARTCR |= UARTCR_RTSEN_MASK;
   19b78:	6323      	str	r3, [r4, #48]	; 0x30
    }

    hal_uart->UARTCR |= UARTCR_UARTEN_MASK;
   19b7a:	2301      	movs	r3, #1
   19b7c:	6b22      	ldr	r2, [r4, #48]	; 0x30
   19b7e:	4313      	orrs	r3, r2
   19b80:	6323      	str	r3, [r4, #48]	; 0x30
    non_os_exit_critical();
   19b82:	f7fe fb2b 	bl	181dc <non_os_exit_critical>
}
   19b86:	bd70      	pop	{r4, r5, r6, pc}
        hal_uart->UARTCR |= UARTCR_RXE_MASK;
   19b88:	2380      	movs	r3, #128	; 0x80
   19b8a:	6b22      	ldr	r2, [r4, #48]	; 0x30
   19b8c:	009b      	lsls	r3, r3, #2
   19b8e:	4313      	orrs	r3, r2
   19b90:	e7e0      	b.n	19b54 <hal_uart_set_enable_uart+0x1c>
        hal_uart->UARTCR |= UARTCR_TXE_MASK;
   19b92:	2380      	movs	r3, #128	; 0x80
   19b94:	6b22      	ldr	r2, [r4, #48]	; 0x30
   19b96:	005b      	lsls	r3, r3, #1
   19b98:	4313      	orrs	r3, r2
   19b9a:	e7e1      	b.n	19b60 <hal_uart_set_enable_uart+0x28>
        hal_uart->UARTCR |= UARTCR_CTSEN_MASK;
   19b9c:	2380      	movs	r3, #128	; 0x80
   19b9e:	6b22      	ldr	r2, [r4, #48]	; 0x30
   19ba0:	021b      	lsls	r3, r3, #8
   19ba2:	4313      	orrs	r3, r2
   19ba4:	e7e2      	b.n	19b6c <hal_uart_set_enable_uart+0x34>
        hal_uart->UARTCR |= UARTCR_RTSEN_MASK;
   19ba6:	2380      	movs	r3, #128	; 0x80
   19ba8:	6b22      	ldr	r2, [r4, #48]	; 0x30
   19baa:	01db      	lsls	r3, r3, #7
   19bac:	4313      	orrs	r3, r2
   19bae:	e7e3      	b.n	19b78 <hal_uart_set_enable_uart+0x40>
   19bb0:	fffffdff 	.word	0xfffffdff
   19bb4:	fffffeff 	.word	0xfffffeff
   19bb8:	ffff7fff 	.word	0xffff7fff
   19bbc:	ffffbfff 	.word	0xffffbfff

00019bc0 <hal_uart_is_tx_fifo_full>:

bool hal_uart_is_tx_fifo_full( UART_BUS uart )
{
   19bc0:	b510      	push	{r4, lr}
    volatile uart_ctrl_t * hal_uart = hal_uart_specific_get_uart( uart );
   19bc2:	f000 fa37 	bl	1a034 <hal_uart_specific_get_uart>
    return ((hal_uart->UARTFR & HAL_UARTFR_TXFF_FLAG) != 0);
   19bc6:	6980      	ldr	r0, [r0, #24]
   19bc8:	0680      	lsls	r0, r0, #26
   19bca:	0fc0      	lsrs	r0, r0, #31
}
   19bcc:	bd10      	pop	{r4, pc}

00019bce <hal_uart_is_busy>:
    volatile uart_ctrl_t * hal_uart = hal_uart_specific_get_uart( uart );
    return ((hal_uart->UARTFR & HAL_UARTFR_TXFE_FLAG) != 0);
}

bool hal_uart_is_busy( UART_BUS uart )
{
   19bce:	b510      	push	{r4, lr}
    volatile uart_ctrl_t * hal_uart = hal_uart_specific_get_uart( uart );
   19bd0:	f000 fa30 	bl	1a034 <hal_uart_specific_get_uart>
    return ((hal_uart->UARTFR & HAL_UARTFR_BUSY_FLAG) != 0);
   19bd4:	6980      	ldr	r0, [r0, #24]
   19bd6:	0700      	lsls	r0, r0, #28
   19bd8:	0fc0      	lsrs	r0, r0, #31
}
   19bda:	bd10      	pop	{r4, pc}

00019bdc <hal_uart_is_rx_fifo_empty>:
    volatile uart_ctrl_t * hal_uart = hal_uart_specific_get_uart( uart );
    return ((hal_uart->UARTFR & HAL_UARTFR_RXFF_FLAG) != 0);
}

bool hal_uart_is_rx_fifo_empty( UART_BUS uart )
{
   19bdc:	b510      	push	{r4, lr}
    volatile uart_ctrl_t * hal_uart = hal_uart_specific_get_uart( uart );
   19bde:	f000 fa29 	bl	1a034 <hal_uart_specific_get_uart>
    return ((hal_uart->UARTFR & HAL_UARTFR_RXFE_FLAG) != 0);
   19be2:	6980      	ldr	r0, [r0, #24]
   19be4:	06c0      	lsls	r0, r0, #27
   19be6:	0fc0      	lsrs	r0, r0, #31
}
   19be8:	bd10      	pop	{r4, pc}
	...

00019bec <hal_uart_force_tx_isr>:

void hal_uart_force_tx_isr( UART_BUS uart )
{
   19bec:	b510      	push	{r4, lr}
   19bee:	0004      	movs	r4, r0
    assert( uart < UART_BUS_MAX_NUMBER );
   19bf0:	2802      	cmp	r0, #2
   19bf2:	d903      	bls.n	19bfc <hal_uart_force_tx_isr+0x10>
   19bf4:	4671      	mov	r1, lr
   19bf6:	2016      	movs	r0, #22
   19bf8:	f7e7 ff8a 	bl	1b10 <panic>

    if( hal_uart_initialised && (uart < UART_BUS_MAX_NUMBER) )
   19bfc:	4b07      	ldr	r3, [pc, #28]	; (19c1c <hal_uart_force_tx_isr+0x30>)
   19bfe:	781b      	ldrb	r3, [r3, #0]
   19c00:	2b00      	cmp	r3, #0
   19c02:	d009      	beq.n	19c18 <hal_uart_force_tx_isr+0x2c>
   19c04:	2c02      	cmp	r4, #2
   19c06:	d807      	bhi.n	19c18 <hal_uart_force_tx_isr+0x2c>
    {
        hal_uart_force_isr_flags[uart] |= HAL_UART_FORCE_TX_ISR_FLAG;
   19c08:	2301      	movs	r3, #1
   19c0a:	4a05      	ldr	r2, [pc, #20]	; (19c20 <hal_uart_force_tx_isr+0x34>)
        hal_uart_specific_set_pending_irq( uart );
   19c0c:	0020      	movs	r0, r4
        hal_uart_force_isr_flags[uart] |= HAL_UART_FORCE_TX_ISR_FLAG;
   19c0e:	5d11      	ldrb	r1, [r2, r4]
   19c10:	430b      	orrs	r3, r1
   19c12:	5513      	strb	r3, [r2, r4]
        hal_uart_specific_set_pending_irq( uart );
   19c14:	f000 fac0 	bl	1a198 <hal_uart_specific_set_pending_irq>
    }
}
   19c18:	bd10      	pop	{r4, pc}
   19c1a:	46c0      	nop			; (mov r8, r8)
   19c1c:	01002b8b 	.word	0x01002b8b
   19c20:	01002b88 	.word	0x01002b88

00019c24 <hal_uart_get_dmac_register>:
        hal_uart_specific_set_pending_irq( uart );
    }
}

volatile uint32 *hal_uart_get_dmac_register( UART_BUS uart )
{
   19c24:	b510      	push	{r4, lr}
    volatile uart_ctrl_t *hal_uart = hal_uart_specific_get_uart( uart );
   19c26:	f000 fa05 	bl	1a034 <hal_uart_specific_get_uart>
    return (volatile uint32 *)&(hal_uart->UARTDMACR);
   19c2a:	3048      	adds	r0, #72	; 0x48
}
   19c2c:	bd10      	pop	{r4, pc}
	...

00019c30 <hal_uart_isr>:

void hal_uart_isr( UART_BUS uart )
{
   19c30:	b570      	push	{r4, r5, r6, lr}
   19c32:	0004      	movs	r4, r0
    volatile uart_ctrl_t * hal_uart = hal_uart_specific_get_uart( uart );
   19c34:	f000 f9fe 	bl	1a034 <hal_uart_specific_get_uart>

    // Get the current register values
    uint32 uart_int_reg = hal_uart->UARTMIS;

    // Detect the interrupt cause and trigger the right callback
    if( (uart_int_reg & (UARTMIS_OEMIS_MASK | UARTMIS_BEMIS_MASK | UARTMIS_PEMIS_MASK | UARTMIS_FEMIS_MASK)) )
   19c38:	23f0      	movs	r3, #240	; 0xf0
    uint32 uart_int_reg = hal_uart->UARTMIS;
   19c3a:	6c06      	ldr	r6, [r0, #64]	; 0x40
    if( (uart_int_reg & (UARTMIS_OEMIS_MASK | UARTMIS_BEMIS_MASK | UARTMIS_PEMIS_MASK | UARTMIS_FEMIS_MASK)) )
   19c3c:	00db      	lsls	r3, r3, #3
   19c3e:	421e      	tst	r6, r3
   19c40:	d006      	beq.n	19c50 <hal_uart_isr+0x20>
    {
        if( hal_uart_interrupt_handler[uart].error_isr )
   19c42:	4b18      	ldr	r3, [pc, #96]	; (19ca4 <hal_uart_isr+0x74>)
   19c44:	0122      	lsls	r2, r4, #4
   19c46:	189b      	adds	r3, r3, r2
   19c48:	68db      	ldr	r3, [r3, #12]
   19c4a:	2b00      	cmp	r3, #0
   19c4c:	d000      	beq.n	19c50 <hal_uart_isr+0x20>
        {
            hal_uart_interrupt_handler[uart].error_isr();
   19c4e:	4798      	blx	r3
        }
    }

    if( uart_int_reg & UARTMIS_RXMIS_MASK )
   19c50:	06f3      	lsls	r3, r6, #27
   19c52:	d505      	bpl.n	19c60 <hal_uart_isr+0x30>
    {
        if( hal_uart_interrupt_handler[uart].rx_isr )
   19c54:	4b13      	ldr	r3, [pc, #76]	; (19ca4 <hal_uart_isr+0x74>)
   19c56:	0122      	lsls	r2, r4, #4
   19c58:	58d3      	ldr	r3, [r2, r3]
   19c5a:	2b00      	cmp	r3, #0
   19c5c:	d000      	beq.n	19c60 <hal_uart_isr+0x30>
        {
            hal_uart_interrupt_handler[uart].rx_isr();
   19c5e:	4798      	blx	r3
   19c60:	4d11      	ldr	r5, [pc, #68]	; (19ca8 <hal_uart_isr+0x78>)
        }
    }

    if( (uart_int_reg & UARTMIS_RTMIS_MASK) || (hal_uart_force_isr_flags[uart] & HAL_UART_FORCE_IDLE_ISR_FLAG) )
   19c62:	0673      	lsls	r3, r6, #25
   19c64:	d402      	bmi.n	19c6c <hal_uart_isr+0x3c>
   19c66:	5d2b      	ldrb	r3, [r5, r4]
   19c68:	079b      	lsls	r3, r3, #30
   19c6a:	d50a      	bpl.n	19c82 <hal_uart_isr+0x52>
    {
        if( hal_uart_interrupt_handler[uart].idle_isr )
   19c6c:	4b0d      	ldr	r3, [pc, #52]	; (19ca4 <hal_uart_isr+0x74>)
   19c6e:	0122      	lsls	r2, r4, #4
   19c70:	189b      	adds	r3, r3, r2
   19c72:	689b      	ldr	r3, [r3, #8]
   19c74:	2b00      	cmp	r3, #0
   19c76:	d000      	beq.n	19c7a <hal_uart_isr+0x4a>
        {
            hal_uart_interrupt_handler[uart].idle_isr();
   19c78:	4798      	blx	r3
        }

        hal_uart_force_isr_flags[uart] &= ~HAL_UART_FORCE_IDLE_ISR_FLAG;
   19c7a:	2202      	movs	r2, #2
   19c7c:	5d2b      	ldrb	r3, [r5, r4]
   19c7e:	4393      	bics	r3, r2
   19c80:	552b      	strb	r3, [r5, r4]
    }

    if( (uart_int_reg & UARTMIS_TXMIS_MASK) || (hal_uart_force_isr_flags[uart] & HAL_UART_FORCE_TX_ISR_FLAG) )
   19c82:	06b3      	lsls	r3, r6, #26
   19c84:	d402      	bmi.n	19c8c <hal_uart_isr+0x5c>
   19c86:	5d2b      	ldrb	r3, [r5, r4]
   19c88:	07db      	lsls	r3, r3, #31
   19c8a:	d50a      	bpl.n	19ca2 <hal_uart_isr+0x72>
    {
        // TX Interrupt
        if( hal_uart_interrupt_handler[uart].tx_isr )
   19c8c:	4b05      	ldr	r3, [pc, #20]	; (19ca4 <hal_uart_isr+0x74>)
   19c8e:	0122      	lsls	r2, r4, #4
   19c90:	189b      	adds	r3, r3, r2
   19c92:	685b      	ldr	r3, [r3, #4]
   19c94:	2b00      	cmp	r3, #0
   19c96:	d000      	beq.n	19c9a <hal_uart_isr+0x6a>
        {
            hal_uart_interrupt_handler[uart].tx_isr();
   19c98:	4798      	blx	r3
        }

        hal_uart_force_isr_flags[uart] &= ~HAL_UART_FORCE_TX_ISR_FLAG;
   19c9a:	2201      	movs	r2, #1
   19c9c:	5d2b      	ldrb	r3, [r5, r4]
   19c9e:	4393      	bics	r3, r2
   19ca0:	552b      	strb	r3, [r5, r4]
    }
}
   19ca2:	bd70      	pop	{r4, r5, r6, pc}
   19ca4:	01002b8c 	.word	0x01002b8c
   19ca8:	01002b88 	.word	0x01002b88

00019cac <IRQ_UART0_Handler>:

//lint -esym(459, IRQ_UART0_Handler)
//lint -esym(459, IRQ_UART1_Handler)
extern void IRQ_UART0_Handler(void);
void IRQ_UART0_Handler(void)
{
   19cac:	b510      	push	{r4, lr}
    hal_uart_isr( UART_BUS_0 );
   19cae:	2000      	movs	r0, #0
   19cb0:	f7ff ffbe 	bl	19c30 <hal_uart_isr>
}
   19cb4:	bd10      	pop	{r4, pc}

00019cb6 <IRQ_UART1_Handler>:

#if UART_BUS_MAX_NUMBER > 1
extern void IRQ_UART1_Handler(void);
void IRQ_UART1_Handler(void)
{
   19cb6:	b510      	push	{r4, lr}
    hal_uart_isr( UART_BUS_1 );
   19cb8:	2001      	movs	r0, #1
   19cba:	f7ff ffb9 	bl	19c30 <hal_uart_isr>
}
   19cbe:	bd10      	pop	{r4, pc}

00019cc0 <IRQ_UART2_Handler>:
#endif /* UART_BUS_MAX_NUMBER > 1 */

#if UART_BUS_MAX_NUMBER > 2
extern void IRQ_UART2_Handler(void);
void IRQ_UART2_Handler(void)
{
   19cc0:	b510      	push	{r4, lr}
    hal_uart_isr( UART_BUS_2 );
   19cc2:	2002      	movs	r0, #2
   19cc4:	f7ff ffb4 	bl	19c30 <hal_uart_isr>
}
   19cc8:	bd10      	pop	{r4, pc}

00019cca <IRQ_SECURITY0_Handler>:
/*
 * Lowest level interrupt handler for IPC mechanism: IPC from SECURITY CORE. Dispatch to driver.
 */
//lint -esym(459, IRQ_SECURITY0_Handler)
void IRQ_SECURITY0_Handler (void)
{
   19cca:	b510      	push	{r4, lr}
#if defined(IPC_DEBUG_INTERRUPTS)
    numInts++;
#endif
    ipc_receive_message ();
   19ccc:	f7fd fc20 	bl	17510 <ipc_receive_message>
}
   19cd0:	bd10      	pop	{r4, pc}
	...

00019cd4 <IRQ_PROTOCOL0_Handler>:
   19cd4:	2208      	movs	r2, #8
   19cd6:	4b01      	ldr	r3, [pc, #4]	; (19cdc <IRQ_PROTOCOL0_Handler+0x8>)
   19cd8:	67da      	str	r2, [r3, #124]	; 0x7c
 */
void IRQ_PROTOCOL0_Handler (void)
{
    // Turn off these interrupts, as should only receive IPC from SECURITY CORE via IRQ_SECURITY0_Handler.
    NVIC_DisableIRQ (Protocol_IRQn);
}
   19cda:	4770      	bx	lr
   19cdc:	e000e104 	.word	0xe000e104

00019ce0 <IRQ_APPS0_Handler>:
   19ce0:	2210      	movs	r2, #16
   19ce2:	4b01      	ldr	r3, [pc, #4]	; (19ce8 <IRQ_APPS0_Handler+0x8>)
   19ce4:	67da      	str	r2, [r3, #124]	; 0x7c
 */
void IRQ_APPS0_Handler (void)
{
    // Turn off these interrupts, as should only receive IPC from SECURITY CORE via IRQ_SECURITY0_Handler.
    NVIC_DisableIRQ (Apps_IRQn);
}
   19ce6:	4770      	bx	lr
   19ce8:	e000e104 	.word	0xe000e104

00019cec <hal_ipc_init_interrupts>:

  if((int32_t)(IRQn) < 0) {
    return((uint32_t)(((SCB->SHP[_SHP_IDX(IRQn)] >> _BIT_SHIFT(IRQn) ) & (uint32_t)0xFFUL) >> (8 - __NVIC_PRIO_BITS)));
  }
  else {
    return((uint32_t)(((NVIC->IP[ _IP_IDX(IRQn)] >> _BIT_SHIFT(IRQn) ) & (uint32_t)0xFFUL) >> (8 - __NVIC_PRIO_BITS)));
   19cec:	20c0      	movs	r0, #192	; 0xc0

/*
 * Turn on SECURITY CORE interrupts only.
 */
void hal_ipc_init_interrupts (void)
{
   19cee:	b530      	push	{r4, r5, lr}
    NVIC->IP[_IP_IDX(IRQn)]  = ((uint32_t)(NVIC->IP[_IP_IDX(IRQn)]  & ~(0xFFUL << _BIT_SHIFT(IRQn))) |
   19cf0:	24c1      	movs	r4, #193	; 0xc1
   19cf2:	25ff      	movs	r5, #255	; 0xff
    return((uint32_t)(((NVIC->IP[ _IP_IDX(IRQn)] >> _BIT_SHIFT(IRQn) ) & (uint32_t)0xFFUL) >> (8 - __NVIC_PRIO_BITS)));
   19cf4:	4b0b      	ldr	r3, [pc, #44]	; (19d24 <hal_ipc_init_interrupts+0x38>)
   19cf6:	0080      	lsls	r0, r0, #2
   19cf8:	581a      	ldr	r2, [r3, r0]
    NVIC->IP[_IP_IDX(IRQn)]  = ((uint32_t)(NVIC->IP[_IP_IDX(IRQn)]  & ~(0xFFUL << _BIT_SHIFT(IRQn))) |
   19cfa:	00a4      	lsls	r4, r4, #2
   19cfc:	5919      	ldr	r1, [r3, r4]
    return((uint32_t)(((NVIC->IP[ _IP_IDX(IRQn)] >> _BIT_SHIFT(IRQn) ) & (uint32_t)0xFFUL) >> (8 - __NVIC_PRIO_BITS)));
   19cfe:	0212      	lsls	r2, r2, #8
   19d00:	0f92      	lsrs	r2, r2, #30
    NVIC->IP[_IP_IDX(IRQn)]  = ((uint32_t)(NVIC->IP[_IP_IDX(IRQn)]  & ~(0xFFUL << _BIT_SHIFT(IRQn))) |
   19d02:	43a9      	bics	r1, r5
       (((priority << (8 - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL) << _BIT_SHIFT(IRQn)));
   19d04:	0195      	lsls	r5, r2, #6
    NVIC->IP[_IP_IDX(IRQn)]  = ((uint32_t)(NVIC->IP[_IP_IDX(IRQn)]  & ~(0xFFUL << _BIT_SHIFT(IRQn))) |
   19d06:	4329      	orrs	r1, r5
   19d08:	5119      	str	r1, [r3, r4]
   19d0a:	5819      	ldr	r1, [r3, r0]
   19d0c:	0792      	lsls	r2, r2, #30
   19d0e:	0209      	lsls	r1, r1, #8
   19d10:	0a09      	lsrs	r1, r1, #8
   19d12:	430a      	orrs	r2, r1
   19d14:	501a      	str	r2, [r3, r0]
  NVIC->ISER[0] = (uint32_t)(1UL << (((uint32_t)(int32_t)IRQn) & 0x1FUL));
   19d16:	2204      	movs	r2, #4
   19d18:	c304      	stmia	r3!, {r2}
  NVIC->ICER[0] = (uint32_t)(1UL << (((uint32_t)(int32_t)IRQn) & 0x1FUL));
   19d1a:	320c      	adds	r2, #12
   19d1c:	67da      	str	r2, [r3, #124]	; 0x7c
   19d1e:	3a08      	subs	r2, #8
   19d20:	67da      	str	r2, [r3, #124]	; 0x7c
    NVIC_EnableIRQ (Security_IRQn);

    // No direct communication from PROTOCOL or APPS.
    NVIC_DisableIRQ (Apps_IRQn);
    NVIC_DisableIRQ (Protocol_IRQn);
}
   19d22:	bd30      	pop	{r4, r5, pc}
   19d24:	e000e100 	.word	0xe000e100

00019d28 <hal_ipc_deinit_interrupts>:
   19d28:	2204      	movs	r2, #4
   19d2a:	4b03      	ldr	r3, [pc, #12]	; (19d38 <hal_ipc_deinit_interrupts+0x10>)
   19d2c:	67da      	str	r2, [r3, #124]	; 0x7c
   19d2e:	320c      	adds	r2, #12
   19d30:	67da      	str	r2, [r3, #124]	; 0x7c
   19d32:	3a08      	subs	r2, #8
   19d34:	67da      	str	r2, [r3, #124]	; 0x7c
void hal_ipc_deinit_interrupts (void)
{
    NVIC_DisableIRQ (Security_IRQn);
    NVIC_DisableIRQ (Apps_IRQn);
    NVIC_DisableIRQ (Protocol_IRQn);
}
   19d36:	4770      	bx	lr
   19d38:	e000e104 	.word	0xe000e104

00019d3c <hal_lpuart_disable_interrupts>:
   19d3c:	2280      	movs	r2, #128	; 0x80
   19d3e:	4b02      	ldr	r3, [pc, #8]	; (19d48 <hal_lpuart_disable_interrupts+0xc>)
   19d40:	0252      	lsls	r2, r2, #9
   19d42:	67da      	str	r2, [r3, #124]	; 0x7c
}

void hal_lpuart_disable_interrupts()
{
    NVIC_DisableIRQ(LPUART_IRQn);
}
   19d44:	4770      	bx	lr
   19d46:	46c0      	nop			; (mov r8, r8)
   19d48:	e000e104 	.word	0xe000e104

00019d4c <hal_lpuart_enable_interrupts>:
  NVIC->ISER[0] = (uint32_t)(1UL << (((uint32_t)(int32_t)IRQn) & 0x1FUL));
   19d4c:	2280      	movs	r2, #128	; 0x80
   19d4e:	4b02      	ldr	r3, [pc, #8]	; (19d58 <hal_lpuart_enable_interrupts+0xc>)
   19d50:	0252      	lsls	r2, r2, #9
   19d52:	601a      	str	r2, [r3, #0]

void hal_lpuart_enable_interrupts()
{
    NVIC_EnableIRQ(LPUART_IRQn);
}
   19d54:	4770      	bx	lr
   19d56:	46c0      	nop			; (mov r8, r8)
   19d58:	e000e100 	.word	0xe000e100

00019d5c <hal_lpuart_deinit>:
    }
    return false;
}

void hal_lpuart_deinit(void)
{
   19d5c:	b510      	push	{r4, lr}
    hal_lpuart_specific_release();
   19d5e:	f7fe ff1d 	bl	18b9c <hal_lpuart_specific_release>
}
   19d62:	bd10      	pop	{r4, pc}

00019d64 <hal_lpuart_set_interrupts>:
        }
    }
}

void hal_lpuart_set_interrupts(HAL_LPUART_INTERRUPT interrupt_cause)
{
   19d64:	b510      	push	{r4, lr}
    switch (interrupt_cause)
   19d66:	2804      	cmp	r0, #4
   19d68:	d81b      	bhi.n	19da2 <hal_lpuart_set_interrupts+0x3e>
   19d6a:	4b10      	ldr	r3, [pc, #64]	; (19dac <hal_lpuart_set_interrupts+0x48>)
   19d6c:	f7e6 fb1a 	bl	3a4 <__gnu_thumb1_case_uqi>
   19d70:	150d1103 	.word	0x150d1103
   19d74:	08          	.byte	0x08
   19d75:	00          	.byte	0x00
    {
    case     HAL_LPUART_INTERRUPT_NONE:
        LP_UART_CTRL = (LP_UART_CTRL & ~HAL_LPUART_CTRL_INTERRUPT_MASK);
   19d76:	681a      	ldr	r2, [r3, #0]
   19d78:	490d      	ldr	r1, [pc, #52]	; (19db0 <hal_lpuart_set_interrupts+0x4c>)
   19d7a:	400a      	ands	r2, r1
        break;
    case     HAL_LPUART_INTERRUPT_PARITY_ERROR:
        LP_UART_CTRL = (LP_UART_CTRL | HAL_LPUART_CTRL_INT_PARITY_ERROR_MASK);
        break;
    case     HAL_LPUART_INTERRUPT_SUCCESSFUL_WORD:
        LP_UART_CTRL = (LP_UART_CTRL | HAL_LPUART_CTRL_INT_SUCCESSFUL_RX_WORD_MASK);
   19d7c:	601a      	str	r2, [r3, #0]
        break;
    default:
        assert(false);
        break;
    }
}
   19d7e:	bd10      	pop	{r4, pc}
        LP_UART_CTRL = (LP_UART_CTRL | HAL_LPUART_CTRL_INT_START_BIT_MASK);
   19d80:	2280      	movs	r2, #128	; 0x80
   19d82:	6819      	ldr	r1, [r3, #0]
   19d84:	0352      	lsls	r2, r2, #13
        LP_UART_CTRL = (LP_UART_CTRL | HAL_LPUART_CTRL_INT_SUCCESSFUL_RX_WORD_MASK);
   19d86:	430a      	orrs	r2, r1
   19d88:	e7f8      	b.n	19d7c <hal_lpuart_set_interrupts+0x18>
        LP_UART_CTRL = (LP_UART_CTRL | HAL_LPUART_CTRL_INT_FRAME_ERROR_MASK);
   19d8a:	2280      	movs	r2, #128	; 0x80
   19d8c:	6819      	ldr	r1, [r3, #0]
   19d8e:	0392      	lsls	r2, r2, #14
   19d90:	e7f9      	b.n	19d86 <hal_lpuart_set_interrupts+0x22>
        LP_UART_CTRL = (LP_UART_CTRL | HAL_LPUART_CTRL_INT_PARITY_ERROR_MASK);
   19d92:	2280      	movs	r2, #128	; 0x80
   19d94:	6819      	ldr	r1, [r3, #0]
   19d96:	03d2      	lsls	r2, r2, #15
   19d98:	e7f5      	b.n	19d86 <hal_lpuart_set_interrupts+0x22>
        LP_UART_CTRL = (LP_UART_CTRL | HAL_LPUART_CTRL_INT_SUCCESSFUL_RX_WORD_MASK);
   19d9a:	2280      	movs	r2, #128	; 0x80
   19d9c:	6819      	ldr	r1, [r3, #0]
   19d9e:	0412      	lsls	r2, r2, #16
   19da0:	e7f1      	b.n	19d86 <hal_lpuart_set_interrupts+0x22>
        assert(false);
   19da2:	4671      	mov	r1, lr
   19da4:	2016      	movs	r0, #22
   19da6:	f7e7 feb3 	bl	1b10 <panic>
}
   19daa:	e7e8      	b.n	19d7e <hal_lpuart_set_interrupts+0x1a>
   19dac:	40002004 	.word	0x40002004
   19db0:	ff0fffff 	.word	0xff0fffff

00019db4 <hal_lpuart_unset_interrupts>:

void hal_lpuart_unset_interrupts(HAL_LPUART_INTERRUPT interrupt_cause)
{
    switch (interrupt_cause)
   19db4:	3801      	subs	r0, #1
{
   19db6:	b510      	push	{r4, lr}
    switch (interrupt_cause)
   19db8:	2803      	cmp	r0, #3
   19dba:	d80f      	bhi.n	19ddc <hal_lpuart_unset_interrupts+0x28>
   19dbc:	4b0a      	ldr	r3, [pc, #40]	; (19de8 <hal_lpuart_unset_interrupts+0x34>)
    {
    case     HAL_LPUART_INTERRUPT_START_BIT:
        LP_UART_CTRL = (LP_UART_CTRL & ~HAL_LPUART_CTRL_INT_START_BIT_MASK);
   19dbe:	681a      	ldr	r2, [r3, #0]
    switch (interrupt_cause)
   19dc0:	f7e6 faf0 	bl	3a4 <__gnu_thumb1_case_uqi>
   19dc4:	020a0608 	.word	0x020a0608
        LP_UART_CTRL = (LP_UART_CTRL & ~HAL_LPUART_CTRL_INT_START_BIT_MASK);
   19dc8:	4908      	ldr	r1, [pc, #32]	; (19dec <hal_lpuart_unset_interrupts+0x38>)
        break;
    case     HAL_LPUART_INTERRUPT_PARITY_ERROR:
        LP_UART_CTRL = (LP_UART_CTRL & ~HAL_LPUART_CTRL_INT_PARITY_ERROR_MASK);
        break;
    case     HAL_LPUART_INTERRUPT_SUCCESSFUL_WORD:
        LP_UART_CTRL = (LP_UART_CTRL & ~HAL_LPUART_CTRL_INT_SUCCESSFUL_RX_WORD_MASK);
   19dca:	400a      	ands	r2, r1
   19dcc:	601a      	str	r2, [r3, #0]
        break;
    default:
        assert(false);
        break;
    }
}
   19dce:	bd10      	pop	{r4, pc}
        LP_UART_CTRL = (LP_UART_CTRL & ~HAL_LPUART_CTRL_INT_FRAME_ERROR_MASK);
   19dd0:	4907      	ldr	r1, [pc, #28]	; (19df0 <hal_lpuart_unset_interrupts+0x3c>)
   19dd2:	e7fa      	b.n	19dca <hal_lpuart_unset_interrupts+0x16>
        LP_UART_CTRL = (LP_UART_CTRL & ~HAL_LPUART_CTRL_INT_PARITY_ERROR_MASK);
   19dd4:	4907      	ldr	r1, [pc, #28]	; (19df4 <hal_lpuart_unset_interrupts+0x40>)
   19dd6:	e7f8      	b.n	19dca <hal_lpuart_unset_interrupts+0x16>
        LP_UART_CTRL = (LP_UART_CTRL & ~HAL_LPUART_CTRL_INT_SUCCESSFUL_RX_WORD_MASK);
   19dd8:	4907      	ldr	r1, [pc, #28]	; (19df8 <hal_lpuart_unset_interrupts+0x44>)
   19dda:	e7f6      	b.n	19dca <hal_lpuart_unset_interrupts+0x16>
        assert(false);
   19ddc:	4671      	mov	r1, lr
   19dde:	2016      	movs	r0, #22
   19de0:	f7e7 fe96 	bl	1b10 <panic>
}
   19de4:	e7f3      	b.n	19dce <hal_lpuart_unset_interrupts+0x1a>
   19de6:	46c0      	nop			; (mov r8, r8)
   19de8:	40002004 	.word	0x40002004
   19dec:	ffefffff 	.word	0xffefffff
   19df0:	ffdfffff 	.word	0xffdfffff
   19df4:	ffbfffff 	.word	0xffbfffff
   19df8:	ff7fffff 	.word	0xff7fffff

00019dfc <hal_lpuart_set_wordlength>:

void hal_lpuart_set_wordlength(HAL_LPUART_WORDLENGTH wordlength)
{
   19dfc:	b510      	push	{r4, lr}
    switch (wordlength) {
   19dfe:	2803      	cmp	r0, #3
   19e00:	d819      	bhi.n	19e36 <hal_lpuart_set_wordlength+0x3a>
   19e02:	4b0f      	ldr	r3, [pc, #60]	; (19e40 <hal_lpuart_set_wordlength+0x44>)
   19e04:	f7e6 face 	bl	3a4 <__gnu_thumb1_case_uqi>
   19e08:	140e0702 	.word	0x140e0702
    case HAL_LPUART_WORDLENGTH_5BIT:
        LP_UART_CTRL = (LP_UART_CTRL & ~HAL_LPUART_CTRL_WORDLENGTH_MASK) | ( 0u << HAL_LPUART_CTRL_WORDLENGTH_SHIFT);   //lint !e845
   19e0c:	681a      	ldr	r2, [r3, #0]
   19e0e:	490d      	ldr	r1, [pc, #52]	; (19e44 <hal_lpuart_set_wordlength+0x48>)
   19e10:	400a      	ands	r2, r1
        break;
    case HAL_LPUART_WORDLENGTH_7BIT:
        LP_UART_CTRL = (LP_UART_CTRL & ~HAL_LPUART_CTRL_WORDLENGTH_MASK) | ( 2u << HAL_LPUART_CTRL_WORDLENGTH_SHIFT);
        break;
    case HAL_LPUART_WORDLENGTH_8BIT:
        LP_UART_CTRL = (LP_UART_CTRL & ~HAL_LPUART_CTRL_WORDLENGTH_MASK) | ( 3u << HAL_LPUART_CTRL_WORDLENGTH_SHIFT);
   19e12:	601a      	str	r2, [r3, #0]
        break;
    default:
        assert(false);
        break;
    }
}
   19e14:	bd10      	pop	{r4, pc}
        LP_UART_CTRL = (LP_UART_CTRL & ~HAL_LPUART_CTRL_WORDLENGTH_MASK) | ( 1u << HAL_LPUART_CTRL_WORDLENGTH_SHIFT);
   19e16:	681a      	ldr	r2, [r3, #0]
   19e18:	490a      	ldr	r1, [pc, #40]	; (19e44 <hal_lpuart_set_wordlength+0x48>)
   19e1a:	4011      	ands	r1, r2
   19e1c:	2280      	movs	r2, #128	; 0x80
   19e1e:	02d2      	lsls	r2, r2, #11
        LP_UART_CTRL = (LP_UART_CTRL & ~HAL_LPUART_CTRL_WORDLENGTH_MASK) | ( 3u << HAL_LPUART_CTRL_WORDLENGTH_SHIFT);
   19e20:	430a      	orrs	r2, r1
   19e22:	e7f6      	b.n	19e12 <hal_lpuart_set_wordlength+0x16>
        LP_UART_CTRL = (LP_UART_CTRL & ~HAL_LPUART_CTRL_WORDLENGTH_MASK) | ( 2u << HAL_LPUART_CTRL_WORDLENGTH_SHIFT);
   19e24:	681a      	ldr	r2, [r3, #0]
   19e26:	4907      	ldr	r1, [pc, #28]	; (19e44 <hal_lpuart_set_wordlength+0x48>)
   19e28:	4011      	ands	r1, r2
   19e2a:	2280      	movs	r2, #128	; 0x80
        LP_UART_CTRL = (LP_UART_CTRL & ~HAL_LPUART_CTRL_WORDLENGTH_MASK) | ( 3u << HAL_LPUART_CTRL_WORDLENGTH_SHIFT);
   19e2c:	0312      	lsls	r2, r2, #12
   19e2e:	e7f7      	b.n	19e20 <hal_lpuart_set_wordlength+0x24>
   19e30:	6819      	ldr	r1, [r3, #0]
   19e32:	22c0      	movs	r2, #192	; 0xc0
   19e34:	e7fa      	b.n	19e2c <hal_lpuart_set_wordlength+0x30>
        assert(false);
   19e36:	4671      	mov	r1, lr
   19e38:	2016      	movs	r0, #22
   19e3a:	f7e7 fe69 	bl	1b10 <panic>
}
   19e3e:	e7e9      	b.n	19e14 <hal_lpuart_set_wordlength+0x18>
   19e40:	40002004 	.word	0x40002004
   19e44:	fff3ffff 	.word	0xfff3ffff

00019e48 <hal_lpuart_set_parity>:

//lint -esym(759, hal_lpuart_set_parity)
void hal_lpuart_set_parity(HAL_LPUART_PARITY_SET parity_set)
{
   19e48:	b510      	push	{r4, lr}
    switch (parity_set) {
   19e4a:	2801      	cmp	r0, #1
   19e4c:	d008      	beq.n	19e60 <hal_lpuart_set_parity+0x18>
   19e4e:	2800      	cmp	r0, #0
   19e50:	d016      	beq.n	19e80 <hal_lpuart_set_parity+0x38>
   19e52:	2802      	cmp	r0, #2
   19e54:	d00b      	beq.n	19e6e <hal_lpuart_set_parity+0x26>
        break;
    case HAL_LPUART_PARITY_SET_DISABLED:
        LP_UART_CTRL = (LP_UART_CTRL & ~HAL_LPUART_CTRL_PARITY_SET_MASK);
        break;
    default:
        assert(false);
   19e56:	4671      	mov	r1, lr
   19e58:	2016      	movs	r0, #22
   19e5a:	f7e7 fe59 	bl	1b10 <panic>
        break;
    }
}
   19e5e:	e00e      	b.n	19e7e <hal_lpuart_set_parity+0x36>
        LP_UART_CTRL = (LP_UART_CTRL & ~HAL_LPUART_CTRL_PARITY_SET_MASK) | ( 3u << HAL_LPUART_CTRL_PARITY_SET_SHIFT);
   19e60:	23c0      	movs	r3, #192	; 0xc0
   19e62:	4a0a      	ldr	r2, [pc, #40]	; (19e8c <hal_lpuart_set_parity+0x44>)
   19e64:	049b      	lsls	r3, r3, #18
   19e66:	6811      	ldr	r1, [r2, #0]
   19e68:	430b      	orrs	r3, r1
        LP_UART_CTRL = (LP_UART_CTRL & ~HAL_LPUART_CTRL_PARITY_SET_MASK);
   19e6a:	6013      	str	r3, [r2, #0]
        break;
   19e6c:	e007      	b.n	19e7e <hal_lpuart_set_parity+0x36>
        LP_UART_CTRL = (LP_UART_CTRL & ~HAL_LPUART_CTRL_PARITY_SET_MASK) | ( 1u << HAL_LPUART_CTRL_PARITY_SET_SHIFT);
   19e6e:	4907      	ldr	r1, [pc, #28]	; (19e8c <hal_lpuart_set_parity+0x44>)
   19e70:	4a07      	ldr	r2, [pc, #28]	; (19e90 <hal_lpuart_set_parity+0x48>)
   19e72:	680b      	ldr	r3, [r1, #0]
   19e74:	401a      	ands	r2, r3
   19e76:	2380      	movs	r3, #128	; 0x80
   19e78:	045b      	lsls	r3, r3, #17
   19e7a:	4313      	orrs	r3, r2
   19e7c:	600b      	str	r3, [r1, #0]
}
   19e7e:	bd10      	pop	{r4, pc}
        LP_UART_CTRL = (LP_UART_CTRL & ~HAL_LPUART_CTRL_PARITY_SET_MASK);
   19e80:	4a02      	ldr	r2, [pc, #8]	; (19e8c <hal_lpuart_set_parity+0x44>)
   19e82:	4903      	ldr	r1, [pc, #12]	; (19e90 <hal_lpuart_set_parity+0x48>)
   19e84:	6813      	ldr	r3, [r2, #0]
   19e86:	400b      	ands	r3, r1
   19e88:	e7ef      	b.n	19e6a <hal_lpuart_set_parity+0x22>
   19e8a:	46c0      	nop			; (mov r8, r8)
   19e8c:	40002004 	.word	0x40002004
   19e90:	fcffffff 	.word	0xfcffffff

00019e94 <hal_lpuart_set_stop>:

void hal_lpuart_set_stop(HAL_LPUART_STOP_SET stop_set)
{
   19e94:	b510      	push	{r4, lr}
    switch (stop_set) {
   19e96:	2800      	cmp	r0, #0
   19e98:	d006      	beq.n	19ea8 <hal_lpuart_set_stop+0x14>
   19e9a:	2801      	cmp	r0, #1
   19e9c:	d00b      	beq.n	19eb6 <hal_lpuart_set_stop+0x22>
        break;
    case HAL_LPUART_STOP_SET_DISABLED:
        LP_UART_CTRL = (LP_UART_CTRL & ~HAL_LPUART_CTRL_STOP_SET_MASK);
        break;
    default:
        assert(false);
   19e9e:	4671      	mov	r1, lr
   19ea0:	2016      	movs	r0, #22
   19ea2:	f7e7 fe35 	bl	1b10 <panic>
        break;
    }
}
   19ea6:	e005      	b.n	19eb4 <hal_lpuart_set_stop+0x20>
        LP_UART_CTRL = (LP_UART_CTRL & ~HAL_LPUART_CTRL_STOP_SET_MASK) | ( 1u << HAL_LPUART_CTRL_STOP_SET_SHIFT);
   19ea8:	2380      	movs	r3, #128	; 0x80
   19eaa:	4a05      	ldr	r2, [pc, #20]	; (19ec0 <hal_lpuart_set_stop+0x2c>)
   19eac:	04db      	lsls	r3, r3, #19
   19eae:	6811      	ldr	r1, [r2, #0]
   19eb0:	430b      	orrs	r3, r1
        LP_UART_CTRL = (LP_UART_CTRL & ~HAL_LPUART_CTRL_STOP_SET_MASK);
   19eb2:	6013      	str	r3, [r2, #0]
}
   19eb4:	bd10      	pop	{r4, pc}
        LP_UART_CTRL = (LP_UART_CTRL & ~HAL_LPUART_CTRL_STOP_SET_MASK);
   19eb6:	4a02      	ldr	r2, [pc, #8]	; (19ec0 <hal_lpuart_set_stop+0x2c>)
   19eb8:	4902      	ldr	r1, [pc, #8]	; (19ec4 <hal_lpuart_set_stop+0x30>)
   19eba:	6813      	ldr	r3, [r2, #0]
   19ebc:	400b      	ands	r3, r1
   19ebe:	e7f8      	b.n	19eb2 <hal_lpuart_set_stop+0x1e>
   19ec0:	40002004 	.word	0x40002004
   19ec4:	fbffffff 	.word	0xfbffffff

00019ec8 <hal_lpuart_set_syncmode>:

//lint -esym(759, hal_lpuart_set_syncmode)
void hal_lpuart_set_syncmode(HAL_LPUART_SYNCMODE syncmode)
{
   19ec8:	b510      	push	{r4, lr}
    switch (syncmode) {
   19eca:	2803      	cmp	r0, #3
   19ecc:	d819      	bhi.n	19f02 <hal_lpuart_set_syncmode+0x3a>
   19ece:	4b0f      	ldr	r3, [pc, #60]	; (19f0c <hal_lpuart_set_syncmode+0x44>)
   19ed0:	f7e6 fa68 	bl	3a4 <__gnu_thumb1_case_uqi>
   19ed4:	140e0702 	.word	0x140e0702
    case HAL_LPUART_SYNCMODE_DEFAULT:
        LP_UART_CTRL = (LP_UART_CTRL & ~HAL_LPUART_CTRL_SYNC_MODE_MASK) | ( 0u << HAL_LPUART_CTRL_SYNC_MODE_BIT_SHIFT);     //lint !e845
   19ed8:	681a      	ldr	r2, [r3, #0]
   19eda:	490d      	ldr	r1, [pc, #52]	; (19f10 <hal_lpuart_set_syncmode+0x48>)
   19edc:	400a      	ands	r2, r1
        break;
    case HAL_LPUART_SYNCMODE_EARLIER:
        LP_UART_CTRL = (LP_UART_CTRL & ~HAL_LPUART_CTRL_SYNC_MODE_MASK) | ( 2u << HAL_LPUART_CTRL_SYNC_MODE_BIT_SHIFT);
        break;
    case HAL_LPUART_SYNCMODE_EVEN_EARLIER:
        LP_UART_CTRL = (LP_UART_CTRL & ~HAL_LPUART_CTRL_SYNC_MODE_MASK) | ( 3u << HAL_LPUART_CTRL_SYNC_MODE_BIT_SHIFT);
   19ede:	601a      	str	r2, [r3, #0]
        break;
    default:
        assert(false);
        break;
    }
}
   19ee0:	bd10      	pop	{r4, pc}
        LP_UART_CTRL = (LP_UART_CTRL & ~HAL_LPUART_CTRL_SYNC_MODE_MASK) | ( 1u << HAL_LPUART_CTRL_SYNC_MODE_BIT_SHIFT);
   19ee2:	681a      	ldr	r2, [r3, #0]
   19ee4:	490a      	ldr	r1, [pc, #40]	; (19f10 <hal_lpuart_set_syncmode+0x48>)
   19ee6:	4011      	ands	r1, r2
   19ee8:	2280      	movs	r2, #128	; 0x80
   19eea:	0252      	lsls	r2, r2, #9
        LP_UART_CTRL = (LP_UART_CTRL & ~HAL_LPUART_CTRL_SYNC_MODE_MASK) | ( 3u << HAL_LPUART_CTRL_SYNC_MODE_BIT_SHIFT);
   19eec:	430a      	orrs	r2, r1
   19eee:	e7f6      	b.n	19ede <hal_lpuart_set_syncmode+0x16>
        LP_UART_CTRL = (LP_UART_CTRL & ~HAL_LPUART_CTRL_SYNC_MODE_MASK) | ( 2u << HAL_LPUART_CTRL_SYNC_MODE_BIT_SHIFT);
   19ef0:	681a      	ldr	r2, [r3, #0]
   19ef2:	4907      	ldr	r1, [pc, #28]	; (19f10 <hal_lpuart_set_syncmode+0x48>)
   19ef4:	4011      	ands	r1, r2
   19ef6:	2280      	movs	r2, #128	; 0x80
        LP_UART_CTRL = (LP_UART_CTRL & ~HAL_LPUART_CTRL_SYNC_MODE_MASK) | ( 3u << HAL_LPUART_CTRL_SYNC_MODE_BIT_SHIFT);
   19ef8:	0292      	lsls	r2, r2, #10
   19efa:	e7f7      	b.n	19eec <hal_lpuart_set_syncmode+0x24>
   19efc:	6819      	ldr	r1, [r3, #0]
   19efe:	22c0      	movs	r2, #192	; 0xc0
   19f00:	e7fa      	b.n	19ef8 <hal_lpuart_set_syncmode+0x30>
        assert(false);
   19f02:	4671      	mov	r1, lr
   19f04:	2016      	movs	r0, #22
   19f06:	f7e7 fe03 	bl	1b10 <panic>
}
   19f0a:	e7e9      	b.n	19ee0 <hal_lpuart_set_syncmode+0x18>
   19f0c:	40002004 	.word	0x40002004
   19f10:	fffcffff 	.word	0xfffcffff

00019f14 <hal_lpuart_get_fifo_level>:

uint8 hal_lpuart_get_fifo_level(void)
{
    return (LP_UART_STATUS & HAL_LPUART_STATUS_FIFO_LEVEL_MASK)>>HAL_LPUART_STATUS_FIFO_LEVEL_SHIFT;
   19f14:	4b02      	ldr	r3, [pc, #8]	; (19f20 <hal_lpuart_get_fifo_level+0xc>)
   19f16:	6818      	ldr	r0, [r3, #0]
   19f18:	0540      	lsls	r0, r0, #21
   19f1a:	0f40      	lsrs	r0, r0, #29
}
   19f1c:	4770      	bx	lr
   19f1e:	46c0      	nop			; (mov r8, r8)
   19f20:	40002008 	.word	0x40002008

00019f24 <hal_lpuart_update_rts_signal_state>:
{
   19f24:	b510      	push	{r4, lr}
    if( hal_lpuart_rts_pin != PIN_NONE )
   19f26:	4b0d      	ldr	r3, [pc, #52]	; (19f5c <hal_lpuart_update_rts_signal_state+0x38>)
   19f28:	781c      	ldrb	r4, [r3, #0]
   19f2a:	2c28      	cmp	r4, #40	; 0x28
   19f2c:	d00c      	beq.n	19f48 <hal_lpuart_update_rts_signal_state+0x24>
        if( hal_lpuart_get_fifo_level() >= HAL_LPUART_RTS_FIFO_THRESHOLD )
   19f2e:	f7ff fff1 	bl	19f14 <hal_lpuart_get_fifo_level>
   19f32:	4b0b      	ldr	r3, [pc, #44]	; (19f60 <hal_lpuart_update_rts_signal_state+0x3c>)
   19f34:	781a      	ldrb	r2, [r3, #0]
   19f36:	2805      	cmp	r0, #5
   19f38:	d907      	bls.n	19f4a <hal_lpuart_update_rts_signal_state+0x26>
            if( hal_lpuart_rts_state != HAL_LPUART_RTS_STATE_DEASSERTED )
   19f3a:	2a01      	cmp	r2, #1
   19f3c:	d004      	beq.n	19f48 <hal_lpuart_update_rts_signal_state+0x24>
                hal_lpuart_rts_state = HAL_LPUART_RTS_STATE_DEASSERTED;
   19f3e:	2201      	movs	r2, #1
                hal_gpio_set( hal_lpuart_rts_pin );   // Actual RTS signal is active low
   19f40:	0020      	movs	r0, r4
                hal_lpuart_rts_state = HAL_LPUART_RTS_STATE_DEASSERTED;
   19f42:	701a      	strb	r2, [r3, #0]
                hal_gpio_set( hal_lpuart_rts_pin );   // Actual RTS signal is active low
   19f44:	f7fe fcd6 	bl	188f4 <hal_gpio_set>
}
   19f48:	bd10      	pop	{r4, pc}
            if( hal_lpuart_rts_state != HAL_LPUART_RTS_STATE_ASSERTED )
   19f4a:	2a02      	cmp	r2, #2
   19f4c:	d0fc      	beq.n	19f48 <hal_lpuart_update_rts_signal_state+0x24>
                hal_lpuart_rts_state = HAL_LPUART_RTS_STATE_ASSERTED;
   19f4e:	2202      	movs	r2, #2
                hal_gpio_clear( hal_lpuart_rts_pin );   // Actual RTS signal is active low
   19f50:	0020      	movs	r0, r4
                hal_lpuart_rts_state = HAL_LPUART_RTS_STATE_ASSERTED;
   19f52:	701a      	strb	r2, [r3, #0]
                hal_gpio_clear( hal_lpuart_rts_pin );   // Actual RTS signal is active low
   19f54:	f7fe fcd3 	bl	188fe <hal_gpio_clear>
}
   19f58:	e7f6      	b.n	19f48 <hal_lpuart_update_rts_signal_state+0x24>
   19f5a:	46c0      	nop			; (mov r8, r8)
   19f5c:	010005d8 	.word	0x010005d8
   19f60:	01002bbc 	.word	0x01002bbc

00019f64 <hal_lpuart_assign_rts_pin>:
{
   19f64:	b510      	push	{r4, lr}
    if( hal_lpuart_rts_pin != rts_pin )
   19f66:	4c0a      	ldr	r4, [pc, #40]	; (19f90 <hal_lpuart_assign_rts_pin+0x2c>)
{
   19f68:	0003      	movs	r3, r0
    if( hal_lpuart_rts_pin != rts_pin )
   19f6a:	7820      	ldrb	r0, [r4, #0]
   19f6c:	4298      	cmp	r0, r3
   19f6e:	d00a      	beq.n	19f86 <hal_lpuart_assign_rts_pin+0x22>
        hal_lpuart_rts_state = HAL_LPUART_RTS_STATE_NOT_DETERMINED;
   19f70:	2100      	movs	r1, #0
   19f72:	4a08      	ldr	r2, [pc, #32]	; (19f94 <hal_lpuart_assign_rts_pin+0x30>)
   19f74:	7011      	strb	r1, [r2, #0]
        if( rts_pin == PIN_NONE )
   19f76:	2b28      	cmp	r3, #40	; 0x28
   19f78:	d106      	bne.n	19f88 <hal_lpuart_assign_rts_pin+0x24>
            if( hal_lpuart_rts_pin != PIN_NONE )
   19f7a:	2828      	cmp	r0, #40	; 0x28
   19f7c:	d001      	beq.n	19f82 <hal_lpuart_assign_rts_pin+0x1e>
                hal_gpio_clear( hal_lpuart_rts_pin );   // Actual RTS signal is active low
   19f7e:	f7fe fcbe 	bl	188fe <hal_gpio_clear>
            hal_lpuart_rts_pin = PIN_NONE;
   19f82:	2328      	movs	r3, #40	; 0x28
   19f84:	7023      	strb	r3, [r4, #0]
}
   19f86:	bd10      	pop	{r4, pc}
            hal_lpuart_rts_pin = rts_pin;
   19f88:	7023      	strb	r3, [r4, #0]
            hal_lpuart_update_rts_signal_state();
   19f8a:	f7ff ffcb 	bl	19f24 <hal_lpuart_update_rts_signal_state>
}
   19f8e:	e7fa      	b.n	19f86 <hal_lpuart_assign_rts_pin+0x22>
   19f90:	010005d8 	.word	0x010005d8
   19f94:	01002bbc 	.word	0x01002bbc

00019f98 <IRQ_LPUART_Handler>:
{
   19f98:	b510      	push	{r4, lr}
    hal_lpuart_update_rts_signal_state();
   19f9a:	f7ff ffc3 	bl	19f24 <hal_lpuart_update_rts_signal_state>
    if (lpuart_irq_callback != 0)
   19f9e:	4b04      	ldr	r3, [pc, #16]	; (19fb0 <IRQ_LPUART_Handler+0x18>)
   19fa0:	681b      	ldr	r3, [r3, #0]
   19fa2:	2b00      	cmp	r3, #0
   19fa4:	d001      	beq.n	19faa <IRQ_LPUART_Handler+0x12>
        lpuart_irq_callback();
   19fa6:	4798      	blx	r3
}
   19fa8:	bd10      	pop	{r4, pc}
    return (LP_UART_STATUS & HAL_LPUART_STATUS_FRAME_ERRORS_MASK)>>HAL_LPUART_STATUS_FRAME_ERRORS_SHIFT;
}

void hal_lpuart_clear_irq()
{
    hal_lpuart_specific_clear_irq();
   19faa:	f7fe fdfd 	bl	18ba8 <hal_lpuart_specific_clear_irq>
}
   19fae:	e7fb      	b.n	19fa8 <IRQ_LPUART_Handler+0x10>
   19fb0:	01002bc0 	.word	0x01002bc0

00019fb4 <hal_lpuart_init>:
{
   19fb4:	b510      	push	{r4, lr}
    if( hal_lpuart_specific_claim() )
   19fb6:	f7fe fddf 	bl	18b78 <hal_lpuart_specific_claim>
   19fba:	1e04      	subs	r4, r0, #0
   19fbc:	d006      	beq.n	19fcc <hal_lpuart_init+0x18>
        LP_UART_CTRL = 0;
   19fbe:	2200      	movs	r2, #0
   19fc0:	4b05      	ldr	r3, [pc, #20]	; (19fd8 <hal_lpuart_init+0x24>)
   19fc2:	601a      	str	r2, [r3, #0]
        while ( hal_lpuart_get_fifo_level() != 0)
   19fc4:	f7ff ffa6 	bl	19f14 <hal_lpuart_get_fifo_level>
   19fc8:	2800      	cmp	r0, #0
   19fca:	d101      	bne.n	19fd0 <hal_lpuart_init+0x1c>
}
   19fcc:	0020      	movs	r0, r4
   19fce:	bd10      	pop	{r4, pc}
            num = LP_UART_RX_DATA;
   19fd0:	4b02      	ldr	r3, [pc, #8]	; (19fdc <hal_lpuart_init+0x28>)
   19fd2:	681b      	ldr	r3, [r3, #0]
   19fd4:	e7f6      	b.n	19fc4 <hal_lpuart_init+0x10>
   19fd6:	46c0      	nop			; (mov r8, r8)
   19fd8:	40002004 	.word	0x40002004
   19fdc:	40002014 	.word	0x40002014

00019fe0 <hal_lpuart_get_word>:
{
   19fe0:	b570      	push	{r4, r5, r6, lr}
    uint16 value = (uint16)LP_UART_RX_DATA;
   19fe2:	4b06      	ldr	r3, [pc, #24]	; (19ffc <hal_lpuart_get_word+0x1c>)
{
   19fe4:	0005      	movs	r5, r0
    uint16 value = (uint16)LP_UART_RX_DATA;
   19fe6:	681c      	ldr	r4, [r3, #0]
    hal_lpuart_update_rts_signal_state();
   19fe8:	f7ff ff9c 	bl	19f24 <hal_lpuart_update_rts_signal_state>
    if ((value & HAL_LPUART_FIFO_MASK) == 0)
   19fec:	23e0      	movs	r3, #224	; 0xe0
   19fee:	00db      	lsls	r3, r3, #3
        return false;
   19ff0:	2000      	movs	r0, #0
    if ((value & HAL_LPUART_FIFO_MASK) == 0)
   19ff2:	421c      	tst	r4, r3
   19ff4:	d001      	beq.n	19ffa <hal_lpuart_get_word+0x1a>
    *data = (uint8)(value & 0xff);
   19ff6:	702c      	strb	r4, [r5, #0]
    return true;
   19ff8:	3001      	adds	r0, #1
}
   19ffa:	bd70      	pop	{r4, r5, r6, pc}
   19ffc:	40002014 	.word	0x40002014

0001a000 <hal_lpuart_get_parity_errors>:
    return (LP_UART_STATUS & HAL_LPUART_STATUS_PARITY_ERRORS_MASK)>>HAL_LPUART_STATUS_PARITY_ERRORS_SHIFT;
   1a000:	4b02      	ldr	r3, [pc, #8]	; (1a00c <hal_lpuart_get_parity_errors+0xc>)
   1a002:	6818      	ldr	r0, [r3, #0]
   1a004:	0600      	lsls	r0, r0, #24
   1a006:	0f00      	lsrs	r0, r0, #28
}
   1a008:	4770      	bx	lr
   1a00a:	46c0      	nop			; (mov r8, r8)
   1a00c:	40002008 	.word	0x40002008

0001a010 <hal_lpuart_get_frame_errors>:
    return (LP_UART_STATUS & HAL_LPUART_STATUS_FRAME_ERRORS_MASK)>>HAL_LPUART_STATUS_FRAME_ERRORS_SHIFT;
   1a010:	4b02      	ldr	r3, [pc, #8]	; (1a01c <hal_lpuart_get_frame_errors+0xc>)
   1a012:	6818      	ldr	r0, [r3, #0]
   1a014:	230f      	movs	r3, #15
   1a016:	4018      	ands	r0, r3
}
   1a018:	4770      	bx	lr
   1a01a:	46c0      	nop			; (mov r8, r8)
   1a01c:	40002008 	.word	0x40002008

0001a020 <hal_lpuart_clear_irq>:
{
   1a020:	b510      	push	{r4, lr}
    hal_lpuart_specific_clear_irq();
   1a022:	f7fe fdc1 	bl	18ba8 <hal_lpuart_specific_clear_irq>
}
   1a026:	bd10      	pop	{r4, pc}

0001a028 <hal_lpuart_set_callback>:

void hal_lpuart_set_callback( void (*func)(void) ){
    lpuart_irq_callback = func;
   1a028:	4b01      	ldr	r3, [pc, #4]	; (1a030 <hal_lpuart_set_callback+0x8>)
   1a02a:	6018      	str	r0, [r3, #0]
}
   1a02c:	4770      	bx	lr
   1a02e:	46c0      	nop			; (mov r8, r8)
   1a030:	01002bc0 	.word	0x01002bc0

0001a034 <hal_uart_specific_get_uart>:
#error "The specified number of UARTS exceeds the available UART peripherals"
#endif /* (UART_BUS_MAX_NUMBER > 3) */


volatile uart_ctrl_t * hal_uart_specific_get_uart( uint8 uart )
{
   1a034:	b570      	push	{r4, r5, r6, lr}
   1a036:	4675      	mov	r5, lr
   1a038:	0004      	movs	r4, r0
    assert( uart < UART_BUS_MAX_NUMBER );
   1a03a:	2802      	cmp	r0, #2
   1a03c:	d903      	bls.n	1a046 <hal_uart_specific_get_uart+0x12>
   1a03e:	4671      	mov	r1, lr
   1a040:	2016      	movs	r0, #22
   1a042:	f7e7 fd65 	bl	1b10 <panic>
    assert( hal_uart_bases[uart] != NULL );
   1a046:	4b05      	ldr	r3, [pc, #20]	; (1a05c <hal_uart_specific_get_uart+0x28>)
   1a048:	00a4      	lsls	r4, r4, #2
   1a04a:	58e4      	ldr	r4, [r4, r3]
   1a04c:	2c00      	cmp	r4, #0
   1a04e:	d103      	bne.n	1a058 <hal_uart_specific_get_uart+0x24>
   1a050:	0029      	movs	r1, r5
   1a052:	2016      	movs	r0, #22
   1a054:	f7e7 fd5c 	bl	1b10 <panic>

    return hal_uart_bases[uart];
}
   1a058:	0020      	movs	r0, r4
   1a05a:	bd70      	pop	{r4, r5, r6, pc}
   1a05c:	00025598 	.word	0x00025598

0001a060 <hal_uart_specific_reset_uart>:
 * Resets the uarts on the protocol and apps cores using the RESET_REG register
 * The security core does not have that register, this function does nothing on
 * the security core
 */
void hal_uart_specific_reset_uart( uint8 uart )
{
   1a060:	b570      	push	{r4, r5, r6, lr}
   1a062:	4675      	mov	r5, lr
   1a064:	0004      	movs	r4, r0
    assert( uart < UART_BUS_MAX_NUMBER );
   1a066:	2802      	cmp	r0, #2
   1a068:	d903      	bls.n	1a072 <hal_uart_specific_reset_uart+0x12>
   1a06a:	4671      	mov	r1, lr
   1a06c:	2016      	movs	r0, #22
   1a06e:	f7e7 fd4f 	bl	1b10 <panic>
    assert( hal_uart_bases[uart] != NULL );
   1a072:	4b08      	ldr	r3, [pc, #32]	; (1a094 <hal_uart_specific_reset_uart+0x34>)
   1a074:	00a4      	lsls	r4, r4, #2
   1a076:	58e4      	ldr	r4, [r4, r3]
   1a078:	2c00      	cmp	r4, #0
   1a07a:	d103      	bne.n	1a084 <hal_uart_specific_reset_uart+0x24>
   1a07c:	0029      	movs	r1, r5
   1a07e:	2016      	movs	r0, #22
   1a080:	f7e7 fd46 	bl	1b10 <panic>

    volatile unsigned long * uart_claim_reg = (volatile unsigned long *)((uint32)hal_uart_bases[uart] + HAL_UART_CLAIM_REGISTER_OFFSET);
   1a084:	4b04      	ldr	r3, [pc, #16]	; (1a098 <hal_uart_specific_reset_uart+0x38>)
   1a086:	18e4      	adds	r4, r4, r3

    *uart_claim_reg = (HAL_UART_CLAIM_HOLD_RESET + HAL_UART_CLAIM_REQUEST);
   1a088:	2305      	movs	r3, #5
   1a08a:	6023      	str	r3, [r4, #0]
    *uart_claim_reg = HAL_UART_CLAIM_REQUEST;
   1a08c:	3b04      	subs	r3, #4
   1a08e:	6023      	str	r3, [r4, #0]
}
   1a090:	bd70      	pop	{r4, r5, r6, pc}
   1a092:	46c0      	nop			; (mov r8, r8)
   1a094:	00025598 	.word	0x00025598
   1a098:	00000fdc 	.word	0x00000fdc

0001a09c <hal_uart_specific_enable_clock>:

// Actually claiming the uart
bool hal_uart_specific_enable_clock( uint8 uart )
{
   1a09c:	b570      	push	{r4, r5, r6, lr}
   1a09e:	4675      	mov	r5, lr
   1a0a0:	0004      	movs	r4, r0
    assert( uart < UART_BUS_MAX_NUMBER );
   1a0a2:	2802      	cmp	r0, #2
   1a0a4:	d903      	bls.n	1a0ae <hal_uart_specific_enable_clock+0x12>
   1a0a6:	4671      	mov	r1, lr
   1a0a8:	2016      	movs	r0, #22
   1a0aa:	f7e7 fd31 	bl	1b10 <panic>
    assert( hal_uart_bases[uart] != NULL );
   1a0ae:	4b0e      	ldr	r3, [pc, #56]	; (1a0e8 <hal_uart_specific_enable_clock+0x4c>)
   1a0b0:	00a4      	lsls	r4, r4, #2
   1a0b2:	58e4      	ldr	r4, [r4, r3]
   1a0b4:	2c00      	cmp	r4, #0
   1a0b6:	d103      	bne.n	1a0c0 <hal_uart_specific_enable_clock+0x24>
   1a0b8:	0029      	movs	r1, r5
   1a0ba:	2016      	movs	r0, #22
   1a0bc:	f7e7 fd28 	bl	1b10 <panic>

    volatile unsigned long * uart_claim_reg = (volatile unsigned long *)((uint32)hal_uart_bases[uart] + HAL_UART_CLAIM_REGISTER_OFFSET);

    if( (*uart_claim_reg & (HAL_UART_CLAIM_IS_CLAIMED | HAL_UART_CLAIM_IS_BEING_CLAIMED)) == 0x0 )
   1a0c0:	2277      	movs	r2, #119	; 0x77
    volatile unsigned long * uart_claim_reg = (volatile unsigned long *)((uint32)hal_uart_bases[uart] + HAL_UART_CLAIM_REGISTER_OFFSET);
   1a0c2:	4b0a      	ldr	r3, [pc, #40]	; (1a0ec <hal_uart_specific_enable_clock+0x50>)
   1a0c4:	18e4      	adds	r4, r4, r3
    if( (*uart_claim_reg & (HAL_UART_CLAIM_IS_CLAIMED | HAL_UART_CLAIM_IS_BEING_CLAIMED)) == 0x0 )
   1a0c6:	6821      	ldr	r1, [r4, #0]
   1a0c8:	4211      	tst	r1, r2
   1a0ca:	d105      	bne.n	1a0d8 <hal_uart_specific_enable_clock+0x3c>
    {
        *uart_claim_reg = HAL_UART_CLAIM_REQUEST;
   1a0cc:	3a76      	subs	r2, #118	; 0x76
   1a0ce:	6022      	str	r2, [r4, #0]
        while( (*uart_claim_reg & HAL_UART_CLAIM_IS_CLAIMED) == 0x0 )
   1a0d0:	3206      	adds	r2, #6
   1a0d2:	6821      	ldr	r1, [r4, #0]
   1a0d4:	4211      	tst	r1, r2
   1a0d6:	d0fc      	beq.n	1a0d2 <hal_uart_specific_enable_clock+0x36>

#elif (CORE == APPS)
    uint32 claim_mask = HAL_UART_CLAIM_OWNER_APPS;
#endif

    if( *uart_claim_reg & claim_mask )
   1a0d8:	2104      	movs	r1, #4
   1a0da:	6822      	ldr	r2, [r4, #0]
    {   // Successfully claimed
        return true;
   1a0dc:	2001      	movs	r0, #1
    if( *uart_claim_reg & claim_mask )
   1a0de:	400a      	ands	r2, r1
   1a0e0:	d101      	bne.n	1a0e6 <hal_uart_specific_enable_clock+0x4a>
    // Our claim has failed
    // Ensure we revert our claim request otherwise we might end up owning the UART, without realising it,
    // if the higher priority core ever releases its claim
    *uart_claim_reg = 0;

    return false;
   1a0e2:	0010      	movs	r0, r2
    *uart_claim_reg = 0;
   1a0e4:	6022      	str	r2, [r4, #0]
}
   1a0e6:	bd70      	pop	{r4, r5, r6, pc}
   1a0e8:	00025598 	.word	0x00025598
   1a0ec:	00000fdc 	.word	0x00000fdc

0001a0f0 <hal_uart_specific_is_clock_enabled>:

bool hal_uart_specific_is_clock_enabled( uint8 uart )
{
   1a0f0:	b570      	push	{r4, r5, r6, lr}
   1a0f2:	4675      	mov	r5, lr
   1a0f4:	0004      	movs	r4, r0
    assert( uart < UART_BUS_MAX_NUMBER );
   1a0f6:	2802      	cmp	r0, #2
   1a0f8:	d903      	bls.n	1a102 <hal_uart_specific_is_clock_enabled+0x12>
   1a0fa:	4671      	mov	r1, lr
   1a0fc:	2016      	movs	r0, #22
   1a0fe:	f7e7 fd07 	bl	1b10 <panic>
    assert( hal_uart_bases[uart] != NULL );
   1a102:	4b07      	ldr	r3, [pc, #28]	; (1a120 <hal_uart_specific_is_clock_enabled+0x30>)
   1a104:	00a4      	lsls	r4, r4, #2
   1a106:	58e4      	ldr	r4, [r4, r3]
   1a108:	2c00      	cmp	r4, #0
   1a10a:	d103      	bne.n	1a114 <hal_uart_specific_is_clock_enabled+0x24>
   1a10c:	0029      	movs	r1, r5
   1a10e:	2016      	movs	r0, #22
   1a110:	f7e7 fcfe 	bl	1b10 <panic>

    volatile unsigned long * uart_claim_reg = (volatile unsigned long *)((uint32)hal_uart_bases[uart] + HAL_UART_CLAIM_REGISTER_OFFSET);
   1a114:	4b03      	ldr	r3, [pc, #12]	; (1a124 <hal_uart_specific_is_clock_enabled+0x34>)
   1a116:	18e4      	adds	r4, r4, r3

#elif (CORE == APPS)
    uint32 claim_mask = HAL_UART_CLAIM_OWNER_APPS;
#endif

    if( *uart_claim_reg & claim_mask )
   1a118:	6820      	ldr	r0, [r4, #0]
   1a11a:	0740      	lsls	r0, r0, #29
   1a11c:	0fc0      	lsrs	r0, r0, #31
    {   // Successfully claimed
        return true;
    }

    return false;
}
   1a11e:	bd70      	pop	{r4, r5, r6, pc}
   1a120:	00025598 	.word	0x00025598
   1a124:	00000fdc 	.word	0x00000fdc

0001a128 <hal_uart_specific_disable_clock>:

// Actually releases the uart
void hal_uart_specific_disable_clock( uint8 uart )
{
   1a128:	b570      	push	{r4, r5, r6, lr}
   1a12a:	4675      	mov	r5, lr
   1a12c:	0004      	movs	r4, r0
    assert( uart < UART_BUS_MAX_NUMBER );
   1a12e:	2802      	cmp	r0, #2
   1a130:	d903      	bls.n	1a13a <hal_uart_specific_disable_clock+0x12>
   1a132:	4671      	mov	r1, lr
   1a134:	2016      	movs	r0, #22
   1a136:	f7e7 fceb 	bl	1b10 <panic>
    assert( hal_uart_bases[uart] != NULL );
   1a13a:	4b07      	ldr	r3, [pc, #28]	; (1a158 <hal_uart_specific_disable_clock+0x30>)
   1a13c:	00a4      	lsls	r4, r4, #2
   1a13e:	58e4      	ldr	r4, [r4, r3]
   1a140:	2c00      	cmp	r4, #0
   1a142:	d103      	bne.n	1a14c <hal_uart_specific_disable_clock+0x24>
   1a144:	0029      	movs	r1, r5
   1a146:	2016      	movs	r0, #22
   1a148:	f7e7 fce2 	bl	1b10 <panic>

    volatile unsigned long * uart_claim_reg = (volatile unsigned long *)((uint32)hal_uart_bases[uart] + HAL_UART_CLAIM_REGISTER_OFFSET);
   1a14c:	4b03      	ldr	r3, [pc, #12]	; (1a15c <hal_uart_specific_disable_clock+0x34>)
   1a14e:	18e4      	adds	r4, r4, r3
    *uart_claim_reg = 0;
   1a150:	2300      	movs	r3, #0
   1a152:	6023      	str	r3, [r4, #0]
}
   1a154:	bd70      	pop	{r4, r5, r6, pc}
   1a156:	46c0      	nop			; (mov r8, r8)
   1a158:	00025598 	.word	0x00025598
   1a15c:	00000fdc 	.word	0x00000fdc

0001a160 <hal_uart_specific_enable_irq>:

void hal_uart_specific_enable_irq( uint8 uart )
{
    NVIC_EnableIRQ( uart_interrupt_lines[uart] );
   1a160:	4b04      	ldr	r3, [pc, #16]	; (1a174 <hal_uart_specific_enable_irq+0x14>)
   1a162:	5c1a      	ldrb	r2, [r3, r0]
   1a164:	231f      	movs	r3, #31
   1a166:	401a      	ands	r2, r3
   1a168:	3b1e      	subs	r3, #30
   1a16a:	4093      	lsls	r3, r2
   1a16c:	4a02      	ldr	r2, [pc, #8]	; (1a178 <hal_uart_specific_enable_irq+0x18>)
   1a16e:	6013      	str	r3, [r2, #0]
}
   1a170:	4770      	bx	lr
   1a172:	46c0      	nop			; (mov r8, r8)
   1a174:	000255a4 	.word	0x000255a4
   1a178:	e000e100 	.word	0xe000e100

0001a17c <hal_uart_specific_disable_irq>:

void hal_uart_specific_disable_irq( uint8 uart )
{
    NVIC_DisableIRQ( uart_interrupt_lines[uart] );
   1a17c:	4b04      	ldr	r3, [pc, #16]	; (1a190 <hal_uart_specific_disable_irq+0x14>)
  NVIC->ICER[0] = (uint32_t)(1UL << (((uint32_t)(int32_t)IRQn) & 0x1FUL));
   1a17e:	5c1a      	ldrb	r2, [r3, r0]
   1a180:	231f      	movs	r3, #31
   1a182:	401a      	ands	r2, r3
   1a184:	3b1e      	subs	r3, #30
   1a186:	4093      	lsls	r3, r2
   1a188:	4a02      	ldr	r2, [pc, #8]	; (1a194 <hal_uart_specific_disable_irq+0x18>)
   1a18a:	67d3      	str	r3, [r2, #124]	; 0x7c
}
   1a18c:	4770      	bx	lr
   1a18e:	46c0      	nop			; (mov r8, r8)
   1a190:	000255a4 	.word	0x000255a4
   1a194:	e000e104 	.word	0xe000e104

0001a198 <hal_uart_specific_set_pending_irq>:

void hal_uart_specific_set_pending_irq( uint8 uart )
{
    NVIC_SetPendingIRQ( uart_interrupt_lines[uart] );
   1a198:	4b04      	ldr	r3, [pc, #16]	; (1a1ac <hal_uart_specific_set_pending_irq+0x14>)
  NVIC->ISPR[0] = (uint32_t)(1UL << (((uint32_t)(int32_t)IRQn) & 0x1FUL));
   1a19a:	5c1a      	ldrb	r2, [r3, r0]
   1a19c:	231f      	movs	r3, #31
   1a19e:	401a      	ands	r2, r3
   1a1a0:	3b1e      	subs	r3, #30
   1a1a2:	4093      	lsls	r3, r2
   1a1a4:	4a02      	ldr	r2, [pc, #8]	; (1a1b0 <hal_uart_specific_set_pending_irq+0x18>)
   1a1a6:	6053      	str	r3, [r2, #4]
}
   1a1a8:	4770      	bx	lr
   1a1aa:	46c0      	nop			; (mov r8, r8)
   1a1ac:	000255a4 	.word	0x000255a4
   1a1b0:	e000e1fc 	.word	0xe000e1fc

0001a1b4 <eflash_exec_common_callback>:
}

//lint -esym(459, eflash_exec_common_callback)
static void eflash_exec_common_callback(SPI_RET ret)
{
    if (ret != SPI_RET_OK)
   1a1b4:	2800      	cmp	r0, #0
   1a1b6:	d002      	beq.n	1a1be <eflash_exec_common_callback+0xa>
    {
        eflash_cmd_exec_error = true;
   1a1b8:	2201      	movs	r2, #1
   1a1ba:	4b01      	ldr	r3, [pc, #4]	; (1a1c0 <eflash_exec_common_callback+0xc>)
   1a1bc:	701a      	strb	r2, [r3, #0]
    }
}
   1a1be:	4770      	bx	lr
   1a1c0:	01002bc5 	.word	0x01002bc5

0001a1c4 <eflash_generic_cmd_send>:
{
   1a1c4:	b507      	push	{r0, r1, r2, lr}
    if (spi_send_data(eflash_spi_bus, NULL, 0, cmd, (uint16)cmd_length, eflash_exec_common_callback) != SPI_RET_OK)
   1a1c6:	4a0b      	ldr	r2, [pc, #44]	; (1a1f4 <eflash_generic_cmd_send+0x30>)
{
   1a1c8:	0003      	movs	r3, r0
    if (spi_send_data(eflash_spi_bus, NULL, 0, cmd, (uint16)cmd_length, eflash_exec_common_callback) != SPI_RET_OK)
   1a1ca:	7810      	ldrb	r0, [r2, #0]
   1a1cc:	4a0a      	ldr	r2, [pc, #40]	; (1a1f8 <eflash_generic_cmd_send+0x34>)
   1a1ce:	9100      	str	r1, [sp, #0]
   1a1d0:	9201      	str	r2, [sp, #4]
   1a1d2:	2200      	movs	r2, #0
   1a1d4:	0011      	movs	r1, r2
   1a1d6:	f007 fc79 	bl	21acc <spi_send_data>
   1a1da:	4b08      	ldr	r3, [pc, #32]	; (1a1fc <eflash_generic_cmd_send+0x38>)
   1a1dc:	2800      	cmp	r0, #0
   1a1de:	d001      	beq.n	1a1e4 <eflash_generic_cmd_send+0x20>
        eflash_cmd_exec_error = true;
   1a1e0:	2201      	movs	r2, #1
   1a1e2:	701a      	strb	r2, [r3, #0]
   1a1e4:	2000      	movs	r0, #0
    if (eflash_cmd_exec_error)
   1a1e6:	781a      	ldrb	r2, [r3, #0]
   1a1e8:	4282      	cmp	r2, r0
   1a1ea:	d001      	beq.n	1a1f0 <eflash_generic_cmd_send+0x2c>
        eflash_cmd_exec_error = false;
   1a1ec:	7018      	strb	r0, [r3, #0]
        return EFLASH_RET_ERROR;
   1a1ee:	3003      	adds	r0, #3
}
   1a1f0:	bd0e      	pop	{r1, r2, r3, pc}
   1a1f2:	46c0      	nop			; (mov r8, r8)
   1a1f4:	01002bcd 	.word	0x01002bcd
   1a1f8:	0001a1b5 	.word	0x0001a1b5
   1a1fc:	01002bc5 	.word	0x01002bc5

0001a200 <eflash_exec_write_enable_cmd>:
    uint8 cmd[] = {EFLASH_WREN_CMD};
   1a200:	2306      	movs	r3, #6
{
   1a202:	b507      	push	{r0, r1, r2, lr}
    return eflash_generic_cmd_send(cmd, sizeof(cmd));
   1a204:	2101      	movs	r1, #1
    uint8 cmd[] = {EFLASH_WREN_CMD};
   1a206:	a801      	add	r0, sp, #4
   1a208:	7003      	strb	r3, [r0, #0]
    return eflash_generic_cmd_send(cmd, sizeof(cmd));
   1a20a:	f7ff ffdb 	bl	1a1c4 <eflash_generic_cmd_send>
}
   1a20e:	bd0e      	pop	{r1, r2, r3, pc}

0001a210 <eflash_wake>:
{
   1a210:	b570      	push	{r4, r5, r6, lr}
    pio_out_config spi_mosi_pin_config_release = {PIO_DRIVE_LOW, PIO_PULL_NONE};
   1a212:	2400      	movs	r4, #0
{
   1a214:	b086      	sub	sp, #24
    pio_out_config spi_mosi_pin_config_release = {PIO_DRIVE_LOW, PIO_PULL_NONE};
   1a216:	ad05      	add	r5, sp, #20
    pio_in_config spi_miso_pin_config_release = {PIO_PULL_NONE};
   1a218:	a903      	add	r1, sp, #12
    pio_input_config(eflash_spi_pin.miso_pin, &spi_miso_pin_config_release);
   1a21a:	4e12      	ldr	r6, [pc, #72]	; (1a264 <eflash_wake+0x54>)
    pio_in_config spi_miso_pin_config_release = {PIO_PULL_NONE};
   1a21c:	700c      	strb	r4, [r1, #0]
    pio_out_config spi_mosi_pin_config_release = {PIO_DRIVE_LOW, PIO_PULL_NONE};
   1a21e:	702c      	strb	r4, [r5, #0]
   1a220:	706c      	strb	r4, [r5, #1]
    pio_input_config(eflash_spi_pin.miso_pin, &spi_miso_pin_config_release);
   1a222:	7930      	ldrb	r0, [r6, #4]
   1a224:	f7fe f83d 	bl	182a2 <pio_input_config>
    pio_output_config(eflash_spi_pin.mosi_pin, &spi_mosi_pin_config_release);
   1a228:	78f0      	ldrb	r0, [r6, #3]
   1a22a:	0029      	movs	r1, r5
   1a22c:	f7fe f82e 	bl	1828c <pio_output_config>
    uint8 cmd[] = {EFLASH_RP_CMD};
   1a230:	23ab      	movs	r3, #171	; 0xab
   1a232:	a904      	add	r1, sp, #16
   1a234:	700b      	strb	r3, [r1, #0]
    if (spi_send_data(eflash_spi_bus, cmd, sizeof(cmd), NULL, 0, eflash_exec_common_callback) != SPI_RET_OK)
   1a236:	4b0c      	ldr	r3, [pc, #48]	; (1a268 <eflash_wake+0x58>)
   1a238:	2201      	movs	r2, #1
   1a23a:	7818      	ldrb	r0, [r3, #0]
   1a23c:	4b0b      	ldr	r3, [pc, #44]	; (1a26c <eflash_wake+0x5c>)
   1a23e:	9400      	str	r4, [sp, #0]
   1a240:	9301      	str	r3, [sp, #4]
   1a242:	0023      	movs	r3, r4
   1a244:	f007 fc42 	bl	21acc <spi_send_data>
   1a248:	4b09      	ldr	r3, [pc, #36]	; (1a270 <eflash_wake+0x60>)
   1a24a:	42a0      	cmp	r0, r4
   1a24c:	d001      	beq.n	1a252 <eflash_wake+0x42>
        eflash_cmd_exec_error = true;
   1a24e:	2201      	movs	r2, #1
   1a250:	701a      	strb	r2, [r3, #0]
    if (eflash_cmd_exec_error)
   1a252:	7818      	ldrb	r0, [r3, #0]
   1a254:	2800      	cmp	r0, #0
   1a256:	d002      	beq.n	1a25e <eflash_wake+0x4e>
        eflash_cmd_exec_error = false;
   1a258:	2200      	movs	r2, #0
        return EFLASH_RET_ERROR;
   1a25a:	2003      	movs	r0, #3
        eflash_cmd_exec_error = false;
   1a25c:	701a      	strb	r2, [r3, #0]
}
   1a25e:	b006      	add	sp, #24
   1a260:	bd70      	pop	{r4, r5, r6, pc}
   1a262:	46c0      	nop			; (mov r8, r8)
   1a264:	01002bce 	.word	0x01002bce
   1a268:	01002bcd 	.word	0x01002bcd
   1a26c:	0001a1b5 	.word	0x0001a1b5
   1a270:	01002bc5 	.word	0x01002bc5

0001a274 <eflash_delete_mutex>:

    return EFLASH_RET_OK;
}

static void eflash_delete_mutex(void)
{
   1a274:	b570      	push	{r4, r5, r6, lr}
    if (eflash_mutex)
   1a276:	4c08      	ldr	r4, [pc, #32]	; (1a298 <eflash_delete_mutex+0x24>)
   1a278:	4675      	mov	r5, lr
   1a27a:	6820      	ldr	r0, [r4, #0]
   1a27c:	2800      	cmp	r0, #0
   1a27e:	d009      	beq.n	1a294 <eflash_delete_mutex+0x20>
    {
        if(osMutexDelete(eflash_mutex) != osOK)
   1a280:	f7fa fbc4 	bl	14a0c <osMutexDelete>
   1a284:	2800      	cmp	r0, #0
   1a286:	d003      	beq.n	1a290 <eflash_delete_mutex+0x1c>
        {
            assert(false);
   1a288:	0029      	movs	r1, r5
   1a28a:	2016      	movs	r0, #22
   1a28c:	f7e7 fc40 	bl	1b10 <panic>
        }
        eflash_mutex = NULL;
   1a290:	2300      	movs	r3, #0
   1a292:	6023      	str	r3, [r4, #0]
    }
}
   1a294:	bd70      	pop	{r4, r5, r6, pc}
   1a296:	46c0      	nop			; (mov r8, r8)
   1a298:	01002bc8 	.word	0x01002bc8

0001a29c <eflash_remove_any_sleep_veto>:
{
   1a29c:	b510      	push	{r4, lr}
    non_os_enter_critical();
   1a29e:	f7fd ff89 	bl	181b4 <non_os_enter_critical>
        if (eflash_sleep_vetoed)
   1a2a2:	4b05      	ldr	r3, [pc, #20]	; (1a2b8 <eflash_remove_any_sleep_veto+0x1c>)
   1a2a4:	781a      	ldrb	r2, [r3, #0]
   1a2a6:	2a00      	cmp	r2, #0
   1a2a8:	d003      	beq.n	1a2b2 <eflash_remove_any_sleep_veto+0x16>
            eflash_sleep_vetoed = false;
   1a2aa:	2200      	movs	r2, #0
   1a2ac:	701a      	strb	r2, [r3, #0]
            osRemoveStopClocksVeto();
   1a2ae:	f7fa fcad 	bl	14c0c <osRemoveStopClocksVeto>
    non_os_exit_critical();
   1a2b2:	f7fd ff93 	bl	181dc <non_os_exit_critical>
}
   1a2b6:	bd10      	pop	{r4, pc}
   1a2b8:	01002bcc 	.word	0x01002bcc

0001a2bc <eflash_ensure_sleep_vetoed>:
{
   1a2bc:	b510      	push	{r4, lr}
    non_os_enter_critical();
   1a2be:	f7fd ff79 	bl	181b4 <non_os_enter_critical>
        if (!eflash_sleep_vetoed)
   1a2c2:	4b05      	ldr	r3, [pc, #20]	; (1a2d8 <eflash_ensure_sleep_vetoed+0x1c>)
   1a2c4:	781a      	ldrb	r2, [r3, #0]
   1a2c6:	2a00      	cmp	r2, #0
   1a2c8:	d103      	bne.n	1a2d2 <eflash_ensure_sleep_vetoed+0x16>
            eflash_sleep_vetoed = true;
   1a2ca:	3201      	adds	r2, #1
   1a2cc:	701a      	strb	r2, [r3, #0]
            osAddStopClocksVeto();
   1a2ce:	f7fa fc99 	bl	14c04 <osAddStopClocksVeto>
    non_os_exit_critical();
   1a2d2:	f7fd ff83 	bl	181dc <non_os_exit_critical>
}
   1a2d6:	bd10      	pop	{r4, pc}
   1a2d8:	01002bcc 	.word	0x01002bcc

0001a2dc <eflash_is_processing>:
    uint8 cmd[]   = {EFLASH_RDSR_CMD};
   1a2dc:	2305      	movs	r3, #5
{
   1a2de:	b530      	push	{r4, r5, lr}
    if (spi_recv_data(eflash_spi_bus, cmd, sizeof(cmd), state, sizeof(uint8), eflash_exec_common_callback, true) != SPI_RET_OK)
   1a2e0:	2517      	movs	r5, #23
   1a2e2:	2401      	movs	r4, #1
{
   1a2e4:	b087      	sub	sp, #28
    uint8 cmd[]   = {EFLASH_RDSR_CMD};
   1a2e6:	a905      	add	r1, sp, #20
   1a2e8:	700b      	strb	r3, [r1, #0]
    if (spi_recv_data(eflash_spi_bus, cmd, sizeof(cmd), state, sizeof(uint8), eflash_exec_common_callback, true) != SPI_RET_OK)
   1a2ea:	4b0d      	ldr	r3, [pc, #52]	; (1a320 <eflash_is_processing+0x44>)
   1a2ec:	446d      	add	r5, sp
   1a2ee:	7818      	ldrb	r0, [r3, #0]
   1a2f0:	4b0c      	ldr	r3, [pc, #48]	; (1a324 <eflash_is_processing+0x48>)
   1a2f2:	9402      	str	r4, [sp, #8]
   1a2f4:	9301      	str	r3, [sp, #4]
   1a2f6:	9400      	str	r4, [sp, #0]
   1a2f8:	002b      	movs	r3, r5
   1a2fa:	0022      	movs	r2, r4
   1a2fc:	f007 fcbc 	bl	21c78 <spi_recv_data>
   1a300:	4b09      	ldr	r3, [pc, #36]	; (1a328 <eflash_is_processing+0x4c>)
   1a302:	2800      	cmp	r0, #0
   1a304:	d000      	beq.n	1a308 <eflash_is_processing+0x2c>
        eflash_cmd_exec_error = true;
   1a306:	701c      	strb	r4, [r3, #0]
    if (eflash_cmd_exec_error)
   1a308:	7818      	ldrb	r0, [r3, #0]
   1a30a:	2800      	cmp	r0, #0
   1a30c:	d003      	beq.n	1a316 <eflash_is_processing+0x3a>
        eflash_cmd_exec_error = false;
   1a30e:	2200      	movs	r2, #0
   1a310:	701a      	strb	r2, [r3, #0]
}
   1a312:	b007      	add	sp, #28
   1a314:	bd30      	pop	{r4, r5, pc}
    if (state & EFLASH_WIP_BIT)
   1a316:	2301      	movs	r3, #1
   1a318:	7828      	ldrb	r0, [r5, #0]
   1a31a:	4018      	ands	r0, r3
   1a31c:	e7f9      	b.n	1a312 <eflash_is_processing+0x36>
   1a31e:	46c0      	nop			; (mov r8, r8)
   1a320:	01002bcd 	.word	0x01002bcd
   1a324:	0001a1b5 	.word	0x0001a1b5
   1a328:	01002bc5 	.word	0x01002bc5

0001a32c <eflash_helper_erase>:
{
   1a32c:	b573      	push	{r0, r1, r4, r5, r6, lr}
   1a32e:	0004      	movs	r4, r0
   1a330:	000e      	movs	r6, r1
    if (eflash_is_processing() \
   1a332:	f7ff ffd3 	bl	1a2dc <eflash_is_processing>
   1a336:	2800      	cmp	r0, #0
   1a338:	d002      	beq.n	1a340 <eflash_helper_erase+0x14>
        return EFLASH_RET_ERROR;
   1a33a:	2503      	movs	r5, #3
}
   1a33c:	0028      	movs	r0, r5
   1a33e:	bd76      	pop	{r1, r2, r4, r5, r6, pc}
        || (eflash_exec_write_enable_cmd() != EFLASH_RET_OK))
   1a340:	f7ff ff5e 	bl	1a200 <eflash_exec_write_enable_cmd>
   1a344:	1e05      	subs	r5, r0, #0
   1a346:	d1f8      	bne.n	1a33a <eflash_helper_erase+0xe>
   1a348:	a801      	add	r0, sp, #4
    switch(erase_type)
   1a34a:	2e02      	cmp	r6, #2
   1a34c:	d038      	beq.n	1a3c0 <eflash_helper_erase+0x94>
   1a34e:	2e03      	cmp	r6, #3
   1a350:	d047      	beq.n	1a3e2 <eflash_helper_erase+0xb6>
   1a352:	2e01      	cmp	r6, #1
   1a354:	d01f      	beq.n	1a396 <eflash_helper_erase+0x6a>
    uint8 cmd[] = {EFLASH_SE_CMD, (uint8)(addr >> 16), (uint8)(addr >> 8), (uint8)addr};
   1a356:	2320      	movs	r3, #32
    uint32 addr = (sector_id << EFLASH_SECTOR_SHIFT) & EFLASH_ADDR_MASK;
   1a358:	0524      	lsls	r4, r4, #20
    uint8 cmd[] = {EFLASH_SE_CMD, (uint8)(addr >> 16), (uint8)(addr >> 8), (uint8)addr};
   1a35a:	7003      	strb	r3, [r0, #0]
    return eflash_generic_cmd_send(cmd, sizeof(cmd));
   1a35c:	2104      	movs	r1, #4
    uint8 cmd[] = {EFLASH_SE_CMD, (uint8)(addr >> 16), (uint8)(addr >> 8), (uint8)addr};
   1a35e:	0e23      	lsrs	r3, r4, #24
   1a360:	0c24      	lsrs	r4, r4, #16
   1a362:	7043      	strb	r3, [r0, #1]
   1a364:	7084      	strb	r4, [r0, #2]
   1a366:	70c5      	strb	r5, [r0, #3]
    return eflash_generic_cmd_send(cmd, sizeof(cmd));
   1a368:	f7ff ff2c 	bl	1a1c4 <eflash_generic_cmd_send>
            if (eflash_exec_sector_erase_cmd(erase_id) != EFLASH_RET_OK)
   1a36c:	2800      	cmp	r0, #0
   1a36e:	d1e4      	bne.n	1a33a <eflash_helper_erase+0xe>
            program_time      = (uint32_t)EFLASH_SE_TIME;
   1a370:	208c      	movs	r0, #140	; 0x8c
   1a372:	2100      	movs	r1, #0
   1a374:	f7fa fa36 	bl	147e4 <osMs2Tick>
   1a378:	0006      	movs	r6, r0
            program_wait_time = (uint32_t)EFLASH_SE_WAIT_TIME;
   1a37a:	200e      	movs	r0, #14
            program_wait_time = (uint32_t)EFLASH_CE_WAIT_TIME;
   1a37c:	2100      	movs	r1, #0
   1a37e:	f7fa fa31 	bl	147e4 <osMs2Tick>
   1a382:	0004      	movs	r4, r0
    (void)osDelay(program_time);
   1a384:	0030      	movs	r0, r6
        (void)osDelay(program_wait_time);
   1a386:	f7fa fa70 	bl	1486a <osDelay>
    while(eflash_is_processing())
   1a38a:	f7ff ffa7 	bl	1a2dc <eflash_is_processing>
   1a38e:	2800      	cmp	r0, #0
   1a390:	d0d4      	beq.n	1a33c <eflash_helper_erase+0x10>
        (void)osDelay(program_wait_time);
   1a392:	0020      	movs	r0, r4
   1a394:	e7f7      	b.n	1a386 <eflash_helper_erase+0x5a>
    uint8 cmd[] = {EFLASH_BE32K_CMD, (uint8)(addr >> 16), (uint8)(addr >> 8), (uint8)addr};
   1a396:	2352      	movs	r3, #82	; 0x52
    uint32 addr     = (sector_id << EFLASH_32KBLOCK_SHIFT) & EFLASH_ADDR_MASK;
   1a398:	05e4      	lsls	r4, r4, #23
    uint8 cmd[] = {EFLASH_BE32K_CMD, (uint8)(addr >> 16), (uint8)(addr >> 8), (uint8)addr};
   1a39a:	7003      	strb	r3, [r0, #0]
    return eflash_generic_cmd_send(cmd, sizeof(cmd));
   1a39c:	2104      	movs	r1, #4
    uint8 cmd[] = {EFLASH_BE32K_CMD, (uint8)(addr >> 16), (uint8)(addr >> 8), (uint8)addr};
   1a39e:	0e23      	lsrs	r3, r4, #24
   1a3a0:	0c24      	lsrs	r4, r4, #16
   1a3a2:	7043      	strb	r3, [r0, #1]
   1a3a4:	7084      	strb	r4, [r0, #2]
   1a3a6:	70c5      	strb	r5, [r0, #3]
    return eflash_generic_cmd_send(cmd, sizeof(cmd));
   1a3a8:	f7ff ff0c 	bl	1a1c4 <eflash_generic_cmd_send>
            if (eflash_exec_32K_block_erase_cmd(erase_id) != EFLASH_RET_OK)
   1a3ac:	2800      	cmp	r0, #0
   1a3ae:	d1c4      	bne.n	1a33a <eflash_helper_erase+0xe>
            program_time      = (uint32_t)EFLASH_BE32K_TIME;
   1a3b0:	20fa      	movs	r0, #250	; 0xfa
   1a3b2:	2100      	movs	r1, #0
   1a3b4:	0040      	lsls	r0, r0, #1
   1a3b6:	f7fa fa15 	bl	147e4 <osMs2Tick>
   1a3ba:	0006      	movs	r6, r0
            program_wait_time = (uint32_t)EFLASH_BE32K_WAIT_TIME;
   1a3bc:	2032      	movs	r0, #50	; 0x32
   1a3be:	e7dd      	b.n	1a37c <eflash_helper_erase+0x50>
    uint8 cmd[] = {EFLASH_BE_CMD, (uint8)(addr >> 16), (uint8)(addr >> 8), (uint8)addr};
   1a3c0:	23d8      	movs	r3, #216	; 0xd8
   1a3c2:	8045      	strh	r5, [r0, #2]
    return eflash_generic_cmd_send(cmd, sizeof(cmd));
   1a3c4:	2104      	movs	r1, #4
    uint8 cmd[] = {EFLASH_BE_CMD, (uint8)(addr >> 16), (uint8)(addr >> 8), (uint8)addr};
   1a3c6:	7003      	strb	r3, [r0, #0]
   1a3c8:	7044      	strb	r4, [r0, #1]
    return eflash_generic_cmd_send(cmd, sizeof(cmd));
   1a3ca:	f7ff fefb 	bl	1a1c4 <eflash_generic_cmd_send>
            if (eflash_exec_block_erase_cmd(erase_id) != EFLASH_RET_OK)
   1a3ce:	2800      	cmp	r0, #0
   1a3d0:	d1b3      	bne.n	1a33a <eflash_helper_erase+0xe>
            program_time      = (uint32_t)EFLASH_BE64K_TIME;
   1a3d2:	20fa      	movs	r0, #250	; 0xfa
   1a3d4:	2100      	movs	r1, #0
   1a3d6:	0080      	lsls	r0, r0, #2
   1a3d8:	f7fa fa04 	bl	147e4 <osMs2Tick>
   1a3dc:	0006      	movs	r6, r0
            program_wait_time = (uint32_t)EFLASH_BE64K_WAIT_TIME;
   1a3de:	2064      	movs	r0, #100	; 0x64
   1a3e0:	e7cc      	b.n	1a37c <eflash_helper_erase+0x50>
    uint8  cmd[] = {EFLASH_CE_CMD};
   1a3e2:	2360      	movs	r3, #96	; 0x60
    return eflash_generic_cmd_send(cmd, sizeof(cmd));
   1a3e4:	2101      	movs	r1, #1
    uint8  cmd[] = {EFLASH_CE_CMD};
   1a3e6:	7003      	strb	r3, [r0, #0]
    return eflash_generic_cmd_send(cmd, sizeof(cmd));
   1a3e8:	f7ff feec 	bl	1a1c4 <eflash_generic_cmd_send>
            if (eflash_exec_chip_erase_cmd() != EFLASH_RET_OK)
   1a3ec:	2800      	cmp	r0, #0
   1a3ee:	d1a4      	bne.n	1a33a <eflash_helper_erase+0xe>
            program_time      = (uint32_t)EFLASH_CE_TIME;
   1a3f0:	4803      	ldr	r0, [pc, #12]	; (1a400 <eflash_helper_erase+0xd4>)
   1a3f2:	2100      	movs	r1, #0
   1a3f4:	f7fa f9f6 	bl	147e4 <osMs2Tick>
   1a3f8:	0006      	movs	r6, r0
            program_wait_time = (uint32_t)EFLASH_CE_WAIT_TIME;
   1a3fa:	20fa      	movs	r0, #250	; 0xfa
   1a3fc:	00c0      	lsls	r0, r0, #3
   1a3fe:	e7bd      	b.n	1a37c <eflash_helper_erase+0x50>
   1a400:	00004e20 	.word	0x00004e20

0001a404 <eflash_helper_take_mutex.constprop.4>:
    if(osMutexAcquire(semaphore, blockTime) != osOK)
   1a404:	2101      	movs	r1, #1
inline static void eflash_helper_take_mutex(osMutexId_t semaphore, uint32_t blockTime)
   1a406:	b510      	push	{r4, lr}
    if(osMutexAcquire(semaphore, blockTime) != osOK)
   1a408:	4249      	negs	r1, r1
   1a40a:	4674      	mov	r4, lr
   1a40c:	f7fa faca 	bl	149a4 <osMutexAcquire>
   1a410:	2800      	cmp	r0, #0
   1a412:	d003      	beq.n	1a41c <eflash_helper_take_mutex.constprop.4+0x18>
        assert(false);
   1a414:	0021      	movs	r1, r4
   1a416:	2016      	movs	r0, #22
   1a418:	f7e7 fb7a 	bl	1b10 <panic>
} //lint !e454 semphore is gived in eflash_helper_give_mutex
   1a41c:	bd10      	pop	{r4, pc}

0001a41e <eflash_helper_give_mutex>:
{
   1a41e:	b510      	push	{r4, lr}
   1a420:	4674      	mov	r4, lr
    if (osMutexRelease(semaphore) != osOK)//lint !e455
   1a422:	f7fa fae3 	bl	149ec <osMutexRelease>
   1a426:	2800      	cmp	r0, #0
   1a428:	d003      	beq.n	1a432 <eflash_helper_give_mutex+0x14>
        assert(false);
   1a42a:	0021      	movs	r1, r4
   1a42c:	2016      	movs	r0, #22
   1a42e:	f7e7 fb6f 	bl	1b10 <panic>
}
   1a432:	bd10      	pop	{r4, pc}

0001a434 <eflash_sleep>:
    uint8 cmd[] = {EFLASH_DP_CMD};
   1a434:	23b9      	movs	r3, #185	; 0xb9
{
   1a436:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
    uint8 cmd[] = {EFLASH_DP_CMD};
   1a438:	ac01      	add	r4, sp, #4
    return eflash_generic_cmd_send(cmd, sizeof(cmd));
   1a43a:	2101      	movs	r1, #1
   1a43c:	0020      	movs	r0, r4
    uint8 cmd[] = {EFLASH_DP_CMD};
   1a43e:	7023      	strb	r3, [r4, #0]
    return eflash_generic_cmd_send(cmd, sizeof(cmd));
   1a440:	f7ff fec0 	bl	1a1c4 <eflash_generic_cmd_send>
   1a444:	4e0f      	ldr	r6, [pc, #60]	; (1a484 <eflash_sleep+0x50>)
   1a446:	1e05      	subs	r5, r0, #0
    if (eflash_exec_deep_power_cmd() != EFLASH_RET_OK)
   1a448:	d007      	beq.n	1a45a <eflash_sleep+0x26>
        eflash_remove_any_sleep_veto();
   1a44a:	f7ff ff27 	bl	1a29c <eflash_remove_any_sleep_veto>
        eflash_helper_give_mutex(eflash_mutex);
   1a44e:	6830      	ldr	r0, [r6, #0]
   1a450:	f7ff ffe5 	bl	1a41e <eflash_helper_give_mutex>
   1a454:	2503      	movs	r5, #3
}
   1a456:	0028      	movs	r0, r5
   1a458:	bdfe      	pop	{r1, r2, r3, r4, r5, r6, r7, pc}
    pio_out_config spi_mosi_pin_config_pull_down = {PIO_DRIVE_LOW, PIO_PULL_DOWN};
   1a45a:	2301      	movs	r3, #1
    pio_in_config spi_miso_pin_config_pull_down = {PIO_PULL_DOWN};
   1a45c:	466a      	mov	r2, sp
    pio_input_config(eflash_spi_pin.miso_pin, &spi_miso_pin_config_pull_down);
   1a45e:	4f0a      	ldr	r7, [pc, #40]	; (1a488 <eflash_sleep+0x54>)
    pio_out_config spi_mosi_pin_config_pull_down = {PIO_DRIVE_LOW, PIO_PULL_DOWN};
   1a460:	7063      	strb	r3, [r4, #1]
    pio_in_config spi_miso_pin_config_pull_down = {PIO_PULL_DOWN};
   1a462:	7013      	strb	r3, [r2, #0]
    pio_out_config spi_mosi_pin_config_pull_down = {PIO_DRIVE_LOW, PIO_PULL_DOWN};
   1a464:	7020      	strb	r0, [r4, #0]
    pio_input_config(eflash_spi_pin.miso_pin, &spi_miso_pin_config_pull_down);
   1a466:	7938      	ldrb	r0, [r7, #4]
   1a468:	4669      	mov	r1, sp
   1a46a:	f7fd ff1a 	bl	182a2 <pio_input_config>
    pio_output_config(eflash_spi_pin.mosi_pin, &spi_mosi_pin_config_pull_down);
   1a46e:	78f8      	ldrb	r0, [r7, #3]
   1a470:	0021      	movs	r1, r4
   1a472:	f7fd ff0b 	bl	1828c <pio_output_config>
    eflash_remove_any_sleep_veto();
   1a476:	f7ff ff11 	bl	1a29c <eflash_remove_any_sleep_veto>
    eflash_helper_give_mutex(eflash_mutex);
   1a47a:	6830      	ldr	r0, [r6, #0]
   1a47c:	f7ff ffcf 	bl	1a41e <eflash_helper_give_mutex>
    return EFLASH_RET_OK;
   1a480:	e7e9      	b.n	1a456 <eflash_sleep+0x22>
   1a482:	46c0      	nop			; (mov r8, r8)
   1a484:	01002bc8 	.word	0x01002bc8
   1a488:	01002bce 	.word	0x01002bce

0001a48c <eflash_init>:
{
   1a48c:	b5f0      	push	{r4, r5, r6, r7, lr}
    if (non_os_is_driver_initialised(DRIVER_INIT_EFLASH) == true)
   1a48e:	2019      	movs	r0, #25
{
   1a490:	b085      	sub	sp, #20
    if (non_os_is_driver_initialised(DRIVER_INIT_EFLASH) == true)
   1a492:	f7fd feb7 	bl	18204 <non_os_is_driver_initialised>
   1a496:	1e05      	subs	r5, r0, #0
   1a498:	d173      	bne.n	1a582 <eflash_init+0xf6>
    if ((neul_kv_get( BASE_KEYID_SPI_CLK_PIN, sizeof(uint8), &kvalue_length, (uint8 *)&(eflash_spi_pin.clk_pin)) == NEUL_RET_OK)      \
   1a49a:	2101      	movs	r1, #1
    eflash_available = false;
   1a49c:	4e4e      	ldr	r6, [pc, #312]	; (1a5d8 <eflash_init+0x14c>)
    if ((neul_kv_get( BASE_KEYID_SPI_CLK_PIN, sizeof(uint8), &kvalue_length, (uint8 *)&(eflash_spi_pin.clk_pin)) == NEUL_RET_OK)      \
   1a49e:	4c4f      	ldr	r4, [pc, #316]	; (1a5dc <eflash_init+0x150>)
   1a4a0:	aa02      	add	r2, sp, #8
    eflash_available = false;
   1a4a2:	7030      	strb	r0, [r6, #0]
    if ((neul_kv_get( BASE_KEYID_SPI_CLK_PIN, sizeof(uint8), &kvalue_length, (uint8 *)&(eflash_spi_pin.clk_pin)) == NEUL_RET_OK)      \
   1a4a4:	1c63      	adds	r3, r4, #1
   1a4a6:	3202      	adds	r2, #2
   1a4a8:	0008      	movs	r0, r1
   1a4aa:	f7ed f882 	bl	75b2 <neul_kv_get>
   1a4ae:	2800      	cmp	r0, #0
   1a4b0:	d128      	bne.n	1a504 <eflash_init+0x78>
        && (neul_kv_get( BASE_KEYID_SPI_MOSI_PIN, sizeof(uint8), &kvalue_length, (uint8 *)&(eflash_spi_pin.mosi_pin)) == NEUL_RET_OK) \
   1a4b2:	aa02      	add	r2, sp, #8
   1a4b4:	1ce3      	adds	r3, r4, #3
   1a4b6:	3202      	adds	r2, #2
   1a4b8:	2101      	movs	r1, #1
   1a4ba:	3003      	adds	r0, #3
   1a4bc:	f7ed f879 	bl	75b2 <neul_kv_get>
   1a4c0:	2800      	cmp	r0, #0
   1a4c2:	d11f      	bne.n	1a504 <eflash_init+0x78>
        && (neul_kv_get( BASE_KEYID_SPI_MISO_PIN, sizeof(uint8), &kvalue_length, (uint8 *)&(eflash_spi_pin.miso_pin)) == NEUL_RET_OK) \
   1a4c4:	aa02      	add	r2, sp, #8
   1a4c6:	1d23      	adds	r3, r4, #4
   1a4c8:	3202      	adds	r2, #2
   1a4ca:	2101      	movs	r1, #1
   1a4cc:	3002      	adds	r0, #2
   1a4ce:	f7ed f870 	bl	75b2 <neul_kv_get>
   1a4d2:	2800      	cmp	r0, #0
   1a4d4:	d116      	bne.n	1a504 <eflash_init+0x78>
        && (neul_kv_get( BASE_KEYID_SPI_MEM_CS_PIN, sizeof(uint8), &kvalue_length, (uint8 *)&(eflash_spi_pin.csb_pin))== NEUL_RET_OK) \
   1a4d6:	aa02      	add	r2, sp, #8
   1a4d8:	1ca3      	adds	r3, r4, #2
   1a4da:	3202      	adds	r2, #2
   1a4dc:	2101      	movs	r1, #1
   1a4de:	3004      	adds	r0, #4
   1a4e0:	f7ed f867 	bl	75b2 <neul_kv_get>
   1a4e4:	2800      	cmp	r0, #0
   1a4e6:	d10d      	bne.n	1a504 <eflash_init+0x78>
        && (eflash_spi_pin.clk_pin != PIN_NONE) && (eflash_spi_pin.mosi_pin != PIN_NONE) && (eflash_spi_pin.miso_pin != PIN_NONE) && (eflash_spi_pin.csb_pin != PIN_NONE))
   1a4e8:	7863      	ldrb	r3, [r4, #1]
   1a4ea:	2b28      	cmp	r3, #40	; 0x28
   1a4ec:	d00a      	beq.n	1a504 <eflash_init+0x78>
   1a4ee:	78e3      	ldrb	r3, [r4, #3]
   1a4f0:	2b28      	cmp	r3, #40	; 0x28
   1a4f2:	d007      	beq.n	1a504 <eflash_init+0x78>
   1a4f4:	7923      	ldrb	r3, [r4, #4]
   1a4f6:	2b28      	cmp	r3, #40	; 0x28
   1a4f8:	d004      	beq.n	1a504 <eflash_init+0x78>
   1a4fa:	78a3      	ldrb	r3, [r4, #2]
   1a4fc:	2b28      	cmp	r3, #40	; 0x28
   1a4fe:	d001      	beq.n	1a504 <eflash_init+0x78>
        eflash_available = true;
   1a500:	2301      	movs	r3, #1
   1a502:	7033      	strb	r3, [r6, #0]
    eflash_spi_pin.interface = SPI_INTERFACE_SINGLE_UNIDIR;
   1a504:	2203      	movs	r2, #3
    if (spi_claim(&eflash_spi_bus, eflash_spi_pin) != SPI_RET_OK)
   1a506:	7863      	ldrb	r3, [r4, #1]
   1a508:	78a1      	ldrb	r1, [r4, #2]
   1a50a:	021b      	lsls	r3, r3, #8
   1a50c:	4313      	orrs	r3, r2
   1a50e:	0409      	lsls	r1, r1, #16
   1a510:	430b      	orrs	r3, r1
   1a512:	78e1      	ldrb	r1, [r4, #3]
    eflash_spi_pin.interface = SPI_INTERFACE_SINGLE_UNIDIR;
   1a514:	7022      	strb	r2, [r4, #0]
    if (spi_claim(&eflash_spi_bus, eflash_spi_pin) != SPI_RET_OK)
   1a516:	0609      	lsls	r1, r1, #24
   1a518:	4319      	orrs	r1, r3
   1a51a:	7922      	ldrb	r2, [r4, #4]
   1a51c:	4830      	ldr	r0, [pc, #192]	; (1a5e0 <eflash_init+0x154>)
   1a51e:	f007 f9c9 	bl	218b4 <spi_claim>
   1a522:	2800      	cmp	r0, #0
   1a524:	d12d      	bne.n	1a582 <eflash_init+0xf6>
    if (eflash_mutex != NULL)
   1a526:	4f2f      	ldr	r7, [pc, #188]	; (1a5e4 <eflash_init+0x158>)
   1a528:	6838      	ldr	r0, [r7, #0]
   1a52a:	2800      	cmp	r0, #0
   1a52c:	d125      	bne.n	1a57a <eflash_init+0xee>
    eflash_mutex = osMutexNew(NULL);
   1a52e:	f7fa fa23 	bl	14978 <osMutexNew>
   1a532:	6038      	str	r0, [r7, #0]
    if(eflash_mutex == NULL)
   1a534:	2800      	cmp	r0, #0
   1a536:	d020      	beq.n	1a57a <eflash_init+0xee>
    eflash_helper_take_mutex(eflash_mutex, osWaitForever);
   1a538:	f7ff ff64 	bl	1a404 <eflash_helper_take_mutex.constprop.4>
    spi_config.data_size     = EFLASH_DATA_SIZE;
   1a53c:	2381      	movs	r3, #129	; 0x81
   1a53e:	ae03      	add	r6, sp, #12
   1a540:	00db      	lsls	r3, r3, #3
   1a542:	8033      	strh	r3, [r6, #0]
    spi_config.clk_mode      = EFLASH_SPI_CLK_MODE;
   1a544:	2303      	movs	r3, #3
   1a546:	70b3      	strb	r3, [r6, #2]
    if (eflash_spi_bus >= SPI_BUS_MAX_NUM)
   1a548:	4b25      	ldr	r3, [pc, #148]	; (1a5e0 <eflash_init+0x154>)
   1a54a:	7818      	ldrb	r0, [r3, #0]
   1a54c:	2801      	cmp	r0, #1
   1a54e:	d80f      	bhi.n	1a570 <eflash_init+0xe4>
    ret = spi_activate(eflash_spi_bus, spi_config);
   1a550:	9903      	ldr	r1, [sp, #12]
   1a552:	f007 fa71 	bl	21a38 <spi_activate>
    if (ret != SPI_RET_OK)
   1a556:	2800      	cmp	r0, #0
   1a558:	d016      	beq.n	1a588 <eflash_init+0xfc>
        if (eflash_spi_pin.csb_pin != PIN_NONE)
   1a55a:	78a0      	ldrb	r0, [r4, #2]
   1a55c:	2828      	cmp	r0, #40	; 0x28
   1a55e:	d007      	beq.n	1a570 <eflash_init+0xe4>
            if (!gpio_claim(eflash_spi_pin.csb_pin, GPIO_DIRECTION_OUTPUT))
   1a560:	2101      	movs	r1, #1
   1a562:	f7fc fdfb 	bl	1715c <gpio_claim>
   1a566:	2800      	cmp	r0, #0
   1a568:	d002      	beq.n	1a570 <eflash_init+0xe4>
            gpio_set(eflash_spi_pin.csb_pin);
   1a56a:	78a0      	ldrb	r0, [r4, #2]
   1a56c:	f7fc fe72 	bl	17254 <gpio_set>
        eflash_helper_give_mutex(eflash_mutex);
   1a570:	6838      	ldr	r0, [r7, #0]
   1a572:	f7ff ff54 	bl	1a41e <eflash_helper_give_mutex>
        eflash_delete_mutex();
   1a576:	f7ff fe7d 	bl	1a274 <eflash_delete_mutex>
        (void)spi_release(eflash_spi_bus);
   1a57a:	4b19      	ldr	r3, [pc, #100]	; (1a5e0 <eflash_init+0x154>)
   1a57c:	7818      	ldrb	r0, [r3, #0]
   1a57e:	f007 f95d 	bl	2183c <spi_release>
}
   1a582:	0028      	movs	r0, r5
   1a584:	b005      	add	sp, #20
   1a586:	bdf0      	pop	{r4, r5, r6, r7, pc}
    uint8 cmd[] = {EFLASH_DP_CMD};
   1a588:	23b9      	movs	r3, #185	; 0xb9
    return eflash_generic_cmd_send(cmd, sizeof(cmd));
   1a58a:	2101      	movs	r1, #1
   1a58c:	0030      	movs	r0, r6
    uint8 cmd[] = {EFLASH_DP_CMD};
   1a58e:	7033      	strb	r3, [r6, #0]
    return eflash_generic_cmd_send(cmd, sizeof(cmd));
   1a590:	f7ff fe18 	bl	1a1c4 <eflash_generic_cmd_send>
   1a594:	9001      	str	r0, [sp, #4]
    if ((eflash_spi_activate() != EFLASH_RET_OK) || (eflash_exec_deep_power_cmd() != EFLASH_RET_OK))
   1a596:	2800      	cmp	r0, #0
   1a598:	d1ea      	bne.n	1a570 <eflash_init+0xe4>
    pio_out_config spi_mosi_pin_config_pull_down = {PIO_DRIVE_LOW, PIO_PULL_DOWN};
   1a59a:	466b      	mov	r3, sp
   1a59c:	2501      	movs	r5, #1
   1a59e:	791b      	ldrb	r3, [r3, #4]
   1a5a0:	7075      	strb	r5, [r6, #1]
   1a5a2:	7033      	strb	r3, [r6, #0]
    pio_in_config spi_miso_pin_config_pull_down = {PIO_PULL_DOWN};
   1a5a4:	ab02      	add	r3, sp, #8
   1a5a6:	701d      	strb	r5, [r3, #0]
    pio_input_config(eflash_spi_pin.miso_pin, &spi_miso_pin_config_pull_down);
   1a5a8:	0019      	movs	r1, r3
   1a5aa:	7920      	ldrb	r0, [r4, #4]
   1a5ac:	f7fd fe79 	bl	182a2 <pio_input_config>
    pio_output_config(eflash_spi_pin.mosi_pin, &spi_mosi_pin_config_pull_down);
   1a5b0:	0031      	movs	r1, r6
   1a5b2:	78e0      	ldrb	r0, [r4, #3]
   1a5b4:	f7fd fe6a 	bl	1828c <pio_output_config>
    eflash_sleep_vetoed   = false;
   1a5b8:	466a      	mov	r2, sp
   1a5ba:	4b0b      	ldr	r3, [pc, #44]	; (1a5e8 <eflash_init+0x15c>)
   1a5bc:	7912      	ldrb	r2, [r2, #4]
    eflash_helper_give_mutex(eflash_mutex);
   1a5be:	6838      	ldr	r0, [r7, #0]
    eflash_sleep_vetoed   = false;
   1a5c0:	701a      	strb	r2, [r3, #0]
    eflash_cmd_exec_error = false;
   1a5c2:	466a      	mov	r2, sp
   1a5c4:	4b09      	ldr	r3, [pc, #36]	; (1a5ec <eflash_init+0x160>)
   1a5c6:	7912      	ldrb	r2, [r2, #4]
   1a5c8:	701a      	strb	r2, [r3, #0]
    eflash_helper_give_mutex(eflash_mutex);
   1a5ca:	f7ff ff28 	bl	1a41e <eflash_helper_give_mutex>
    non_os_set_driver_initalised(DRIVER_INIT_EFLASH, true);
   1a5ce:	0029      	movs	r1, r5
   1a5d0:	2019      	movs	r0, #25
   1a5d2:	f7fd fe21 	bl	18218 <non_os_set_driver_initalised>
    return true;
   1a5d6:	e7d4      	b.n	1a582 <eflash_init+0xf6>
   1a5d8:	01002bc4 	.word	0x01002bc4
   1a5dc:	01002bce 	.word	0x01002bce
   1a5e0:	01002bcd 	.word	0x01002bcd
   1a5e4:	01002bc8 	.word	0x01002bc8
   1a5e8:	01002bcc 	.word	0x01002bcc
   1a5ec:	01002bc5 	.word	0x01002bc5

0001a5f0 <eflash_write_data>:
{
   1a5f0:	b5f0      	push	{r4, r5, r6, r7, lr}
   1a5f2:	b089      	sub	sp, #36	; 0x24
   1a5f4:	9004      	str	r0, [sp, #16]
    if (non_os_is_driver_initialised(DRIVER_INIT_EFLASH) == false)
   1a5f6:	2019      	movs	r0, #25
{
   1a5f8:	9105      	str	r1, [sp, #20]
   1a5fa:	9203      	str	r2, [sp, #12]
    if (non_os_is_driver_initialised(DRIVER_INIT_EFLASH) == false)
   1a5fc:	f7fd fe02 	bl	18204 <non_os_is_driver_initialised>
   1a600:	2800      	cmp	r0, #0
   1a602:	d103      	bne.n	1a60c <eflash_write_data+0x1c>
        return 0;
   1a604:	2500      	movs	r5, #0
}
   1a606:	0028      	movs	r0, r5
   1a608:	b009      	add	sp, #36	; 0x24
   1a60a:	bdf0      	pop	{r4, r5, r6, r7, pc}
    if ((buff == NULL) || (length == 0) || (addr >= EFLASH_MAX_ADDR) || ((addr + length) > EFLASH_MAX_ADDR))
   1a60c:	9b05      	ldr	r3, [sp, #20]
   1a60e:	2b00      	cmp	r3, #0
   1a610:	d0f8      	beq.n	1a604 <eflash_write_data+0x14>
   1a612:	9b03      	ldr	r3, [sp, #12]
   1a614:	2b00      	cmp	r3, #0
   1a616:	d0f5      	beq.n	1a604 <eflash_write_data+0x14>
   1a618:	4b3c      	ldr	r3, [pc, #240]	; (1a70c <eflash_write_data+0x11c>)
   1a61a:	9a04      	ldr	r2, [sp, #16]
   1a61c:	429a      	cmp	r2, r3
   1a61e:	d8f1      	bhi.n	1a604 <eflash_write_data+0x14>
   1a620:	9b03      	ldr	r3, [sp, #12]
   1a622:	189b      	adds	r3, r3, r2
   1a624:	2280      	movs	r2, #128	; 0x80
   1a626:	0392      	lsls	r2, r2, #14
   1a628:	4293      	cmp	r3, r2
   1a62a:	d8eb      	bhi.n	1a604 <eflash_write_data+0x14>
    eflash_helper_take_mutex(eflash_mutex, osWaitForever);
   1a62c:	4b38      	ldr	r3, [pc, #224]	; (1a710 <eflash_write_data+0x120>)
   1a62e:	6818      	ldr	r0, [r3, #0]
   1a630:	f7ff fee8 	bl	1a404 <eflash_helper_take_mutex.constprop.4>
    eflash_ensure_sleep_vetoed();
   1a634:	f7ff fe42 	bl	1a2bc <eflash_ensure_sleep_vetoed>
    if (eflash_wake() != EFLASH_RET_OK)
   1a638:	f7ff fdea 	bl	1a210 <eflash_wake>
   1a63c:	1e05      	subs	r5, r0, #0
   1a63e:	d1e1      	bne.n	1a604 <eflash_write_data+0x14>
    if (eflash_is_processing())
   1a640:	f7ff fe4c 	bl	1a2dc <eflash_is_processing>
   1a644:	2800      	cmp	r0, #0
   1a646:	d030      	beq.n	1a6aa <eflash_write_data+0xba>
            (void)eflash_sleep();
   1a648:	f7ff fef4 	bl	1a434 <eflash_sleep>
            return write_len;
   1a64c:	e7db      	b.n	1a606 <eflash_write_data+0x16>
        uint16 block_count = (uint16)((((addr + write_len) | 0xFF) + 1) - (addr + write_len));
   1a64e:	24ff      	movs	r4, #255	; 0xff
   1a650:	9b04      	ldr	r3, [sp, #16]
   1a652:	18ef      	adds	r7, r5, r3
   1a654:	b2bb      	uxth	r3, r7
   1a656:	431c      	orrs	r4, r3
   1a658:	1ae4      	subs	r4, r4, r3
   1a65a:	3401      	adds	r4, #1
        if (block_count > (length - write_len))
   1a65c:	9b03      	ldr	r3, [sp, #12]
        uint16 block_count = (uint16)((((addr + write_len) | 0xFF) + 1) - (addr + write_len));
   1a65e:	b2a4      	uxth	r4, r4
        if (block_count > (length - write_len))
   1a660:	1b5b      	subs	r3, r3, r5
   1a662:	429c      	cmp	r4, r3
   1a664:	dd00      	ble.n	1a668 <eflash_write_data+0x78>
            block_count = length - write_len;
   1a666:	b29c      	uxth	r4, r3
        if ((eflash_exec_write_enable_cmd() != EFLASH_RET_OK) \
   1a668:	f7ff fdca 	bl	1a200 <eflash_exec_write_enable_cmd>
   1a66c:	2800      	cmp	r0, #0
   1a66e:	d1eb      	bne.n	1a648 <eflash_write_data+0x58>
    for (uint16 count = 0; count < length; )
   1a670:	0006      	movs	r6, r0
            || (eflash_exec_page_program_cmd(addr + write_len, buff + write_len, block_count) != EFLASH_RET_OK))
   1a672:	9702      	str	r7, [sp, #8]
    for (uint16 count = 0; count < length; )
   1a674:	42b4      	cmp	r4, r6
   1a676:	d912      	bls.n	1a69e <eflash_write_data+0xae>
        uint8 cmd[] = {EFLASH_PP_CMD, (uint8)(addr >> 16), (uint8)(addr >> 8), (uint8)addr};
   1a678:	2302      	movs	r3, #2
   1a67a:	af07      	add	r7, sp, #28
   1a67c:	703b      	strb	r3, [r7, #0]
   1a67e:	9b02      	ldr	r3, [sp, #8]
   1a680:	0c1b      	lsrs	r3, r3, #16
   1a682:	707b      	strb	r3, [r7, #1]
   1a684:	9b02      	ldr	r3, [sp, #8]
   1a686:	0a1b      	lsrs	r3, r3, #8
   1a688:	70bb      	strb	r3, [r7, #2]
   1a68a:	466b      	mov	r3, sp
   1a68c:	7a1b      	ldrb	r3, [r3, #8]
   1a68e:	70fb      	strb	r3, [r7, #3]
        if (eflash_exec_write_enable_cmd() != EFLASH_RET_OK)
   1a690:	f7ff fdb6 	bl	1a200 <eflash_exec_write_enable_cmd>
   1a694:	1e01      	subs	r1, r0, #0
   1a696:	d00f      	beq.n	1a6b8 <eflash_write_data+0xc8>
        eflash_cmd_exec_error = true;
   1a698:	2201      	movs	r2, #1
   1a69a:	4b1e      	ldr	r3, [pc, #120]	; (1a714 <eflash_write_data+0x124>)
   1a69c:	701a      	strb	r2, [r3, #0]
    if (eflash_cmd_exec_error)
   1a69e:	4b1d      	ldr	r3, [pc, #116]	; (1a714 <eflash_write_data+0x124>)
   1a6a0:	781a      	ldrb	r2, [r3, #0]
   1a6a2:	2a00      	cmp	r2, #0
   1a6a4:	d12f      	bne.n	1a706 <eflash_write_data+0x116>
        write_len += block_count;
   1a6a6:	192d      	adds	r5, r5, r4
   1a6a8:	b2ad      	uxth	r5, r5
    for (; write_len < length; )
   1a6aa:	9b03      	ldr	r3, [sp, #12]
   1a6ac:	429d      	cmp	r5, r3
   1a6ae:	d3ce      	bcc.n	1a64e <eflash_write_data+0x5e>
    (void)eflash_sleep();
   1a6b0:	f7ff fec0 	bl	1a434 <eflash_sleep>
    return length;
   1a6b4:	9d03      	ldr	r5, [sp, #12]
   1a6b6:	e7a6      	b.n	1a606 <eflash_write_data+0x16>
   1a6b8:	9a05      	ldr	r2, [sp, #20]
   1a6ba:	1973      	adds	r3, r6, r5
   1a6bc:	18d3      	adds	r3, r2, r3
   1a6be:	4a16      	ldr	r2, [pc, #88]	; (1a718 <eflash_write_data+0x128>)
   1a6c0:	7810      	ldrb	r0, [r2, #0]
        if ((length - count) > SPI_W_MAX_LEN)
   1a6c2:	1ba2      	subs	r2, r4, r6
   1a6c4:	2a80      	cmp	r2, #128	; 0x80
   1a6c6:	dd12      	ble.n	1a6ee <eflash_write_data+0xfe>
            if (spi_send_data(eflash_spi_bus, cmd, sizeof(cmd), buff + count, SPI_W_MAX_LEN, NULL) != SPI_RET_OK)
   1a6c8:	2280      	movs	r2, #128	; 0x80
   1a6ca:	9101      	str	r1, [sp, #4]
   1a6cc:	9200      	str	r2, [sp, #0]
   1a6ce:	0039      	movs	r1, r7
   1a6d0:	3a7c      	subs	r2, #124	; 0x7c
   1a6d2:	f007 f9fb 	bl	21acc <spi_send_data>
   1a6d6:	2800      	cmp	r0, #0
   1a6d8:	d1de      	bne.n	1a698 <eflash_write_data+0xa8>
            addr  += SPI_W_MAX_LEN;
   1a6da:	9b02      	ldr	r3, [sp, #8]
            count += SPI_W_MAX_LEN;
   1a6dc:	3680      	adds	r6, #128	; 0x80
            addr  += SPI_W_MAX_LEN;
   1a6de:	3380      	adds	r3, #128	; 0x80
   1a6e0:	9302      	str	r3, [sp, #8]
            count += SPI_W_MAX_LEN;
   1a6e2:	b2b6      	uxth	r6, r6
        while (eflash_is_processing())
   1a6e4:	f7ff fdfa 	bl	1a2dc <eflash_is_processing>
   1a6e8:	2800      	cmp	r0, #0
   1a6ea:	d1fb      	bne.n	1a6e4 <eflash_write_data+0xf4>
   1a6ec:	e7c2      	b.n	1a674 <eflash_write_data+0x84>
            if (spi_send_data(eflash_spi_bus, cmd, sizeof(cmd), buff + count, length - count, (SPI_CALLBACK)eflash_exec_common_callback) != SPI_RET_OK)
   1a6ee:	490b      	ldr	r1, [pc, #44]	; (1a71c <eflash_write_data+0x12c>)
   1a6f0:	b292      	uxth	r2, r2
   1a6f2:	9101      	str	r1, [sp, #4]
   1a6f4:	9200      	str	r2, [sp, #0]
   1a6f6:	0039      	movs	r1, r7
   1a6f8:	2204      	movs	r2, #4
   1a6fa:	f007 f9e7 	bl	21acc <spi_send_data>
   1a6fe:	2800      	cmp	r0, #0
   1a700:	d1ca      	bne.n	1a698 <eflash_write_data+0xa8>
   1a702:	0026      	movs	r6, r4
   1a704:	e7ee      	b.n	1a6e4 <eflash_write_data+0xf4>
        eflash_cmd_exec_error = false;
   1a706:	2200      	movs	r2, #0
   1a708:	701a      	strb	r2, [r3, #0]
   1a70a:	e79d      	b.n	1a648 <eflash_write_data+0x58>
   1a70c:	001fffff 	.word	0x001fffff
   1a710:	01002bc8 	.word	0x01002bc8
   1a714:	01002bc5 	.word	0x01002bc5
   1a718:	01002bcd 	.word	0x01002bcd
   1a71c:	0001a1b5 	.word	0x0001a1b5

0001a720 <eflash_read_data>:
{
   1a720:	b5f0      	push	{r4, r5, r6, r7, lr}
   1a722:	0006      	movs	r6, r0
   1a724:	b087      	sub	sp, #28
    if (non_os_is_driver_initialised(DRIVER_INIT_EFLASH) == false)
   1a726:	2019      	movs	r0, #25
{
   1a728:	000f      	movs	r7, r1
   1a72a:	0015      	movs	r5, r2
    if (non_os_is_driver_initialised(DRIVER_INIT_EFLASH) == false)
   1a72c:	f7fd fd6a 	bl	18204 <non_os_is_driver_initialised>
   1a730:	2800      	cmp	r0, #0
   1a732:	d101      	bne.n	1a738 <eflash_read_data+0x18>
        return 0;
   1a734:	2000      	movs	r0, #0
   1a736:	e044      	b.n	1a7c2 <eflash_read_data+0xa2>
    if ((buff == NULL) || (length == 0) || (addr >= EFLASH_MAX_ADDR) || ((addr + length) > EFLASH_MAX_ADDR))
   1a738:	2f00      	cmp	r7, #0
   1a73a:	d0fb      	beq.n	1a734 <eflash_read_data+0x14>
   1a73c:	2d00      	cmp	r5, #0
   1a73e:	d0f9      	beq.n	1a734 <eflash_read_data+0x14>
   1a740:	4b29      	ldr	r3, [pc, #164]	; (1a7e8 <eflash_read_data+0xc8>)
   1a742:	429e      	cmp	r6, r3
   1a744:	d8f6      	bhi.n	1a734 <eflash_read_data+0x14>
   1a746:	2280      	movs	r2, #128	; 0x80
   1a748:	19ab      	adds	r3, r5, r6
   1a74a:	0392      	lsls	r2, r2, #14
   1a74c:	4293      	cmp	r3, r2
   1a74e:	d8f1      	bhi.n	1a734 <eflash_read_data+0x14>
    eflash_helper_take_mutex(eflash_mutex, osWaitForever);
   1a750:	4b26      	ldr	r3, [pc, #152]	; (1a7ec <eflash_read_data+0xcc>)
   1a752:	6818      	ldr	r0, [r3, #0]
   1a754:	f7ff fe56 	bl	1a404 <eflash_helper_take_mutex.constprop.4>
    eflash_ensure_sleep_vetoed();
   1a758:	f7ff fdb0 	bl	1a2bc <eflash_ensure_sleep_vetoed>
    if (eflash_wake() != EFLASH_RET_OK)
   1a75c:	f7ff fd58 	bl	1a210 <eflash_wake>
   1a760:	2800      	cmp	r0, #0
   1a762:	d1e7      	bne.n	1a734 <eflash_read_data+0x14>
    if (eflash_is_processing() \
   1a764:	f7ff fdba 	bl	1a2dc <eflash_is_processing>
    for (uint16 count = 0; count < length; )
   1a768:	1e04      	subs	r4, r0, #0
    if (eflash_is_processing() \
   1a76a:	d005      	beq.n	1a778 <eflash_read_data+0x58>
        (void)eflash_sleep();
   1a76c:	f7ff fe62 	bl	1a434 <eflash_sleep>
   1a770:	e7e0      	b.n	1a734 <eflash_read_data+0x14>
            count += SPI_R_MAX_LEN;
   1a772:	3480      	adds	r4, #128	; 0x80
            addr  += SPI_R_MAX_LEN;
   1a774:	3680      	adds	r6, #128	; 0x80
            count += SPI_R_MAX_LEN;
   1a776:	b2a4      	uxth	r4, r4
    for (uint16 count = 0; count < length; )
   1a778:	42a5      	cmp	r5, r4
   1a77a:	d91b      	bls.n	1a7b4 <eflash_read_data+0x94>
        uint8 cmd[] = {EFLASH_READ_CMD, (uint8)(addr >> 16), (uint8)(addr >> 8), (uint8)addr};
   1a77c:	2303      	movs	r3, #3
   1a77e:	a905      	add	r1, sp, #20
   1a780:	4a1b      	ldr	r2, [pc, #108]	; (1a7f0 <eflash_read_data+0xd0>)
   1a782:	700b      	strb	r3, [r1, #0]
   1a784:	0c33      	lsrs	r3, r6, #16
   1a786:	704b      	strb	r3, [r1, #1]
   1a788:	0a33      	lsrs	r3, r6, #8
   1a78a:	708b      	strb	r3, [r1, #2]
   1a78c:	7810      	ldrb	r0, [r2, #0]
   1a78e:	70ce      	strb	r6, [r1, #3]
   1a790:	193b      	adds	r3, r7, r4
        if ((uint32)(length - count) > SPI_R_MAX_LEN)
   1a792:	1b2a      	subs	r2, r5, r4
   1a794:	2a80      	cmp	r2, #128	; 0x80
   1a796:	d916      	bls.n	1a7c6 <eflash_read_data+0xa6>
            if (spi_recv_data(eflash_spi_bus, cmd, sizeof(cmd), buff + count, SPI_R_MAX_LEN, NULL, true) != SPI_RET_OK)
   1a798:	2201      	movs	r2, #1
   1a79a:	9202      	str	r2, [sp, #8]
   1a79c:	2200      	movs	r2, #0
   1a79e:	9201      	str	r2, [sp, #4]
   1a7a0:	3280      	adds	r2, #128	; 0x80
   1a7a2:	9200      	str	r2, [sp, #0]
   1a7a4:	3a7c      	subs	r2, #124	; 0x7c
   1a7a6:	f007 fa67 	bl	21c78 <spi_recv_data>
   1a7aa:	2800      	cmp	r0, #0
   1a7ac:	d0e1      	beq.n	1a772 <eflash_read_data+0x52>
        eflash_cmd_exec_error = true;
   1a7ae:	2201      	movs	r2, #1
   1a7b0:	4b10      	ldr	r3, [pc, #64]	; (1a7f4 <eflash_read_data+0xd4>)
   1a7b2:	701a      	strb	r2, [r3, #0]
    if (eflash_cmd_exec_error)
   1a7b4:	4b0f      	ldr	r3, [pc, #60]	; (1a7f4 <eflash_read_data+0xd4>)
   1a7b6:	781a      	ldrb	r2, [r3, #0]
   1a7b8:	2a00      	cmp	r2, #0
   1a7ba:	d111      	bne.n	1a7e0 <eflash_read_data+0xc0>
    (void)eflash_sleep();
   1a7bc:	f7ff fe3a 	bl	1a434 <eflash_sleep>
    return length;
   1a7c0:	0028      	movs	r0, r5
} //lint !e429 !e593
   1a7c2:	b007      	add	sp, #28
   1a7c4:	bdf0      	pop	{r4, r5, r6, r7, pc}
            if (spi_recv_data(eflash_spi_bus, cmd, sizeof(cmd), buff + count, length - count, (SPI_CALLBACK)eflash_exec_common_callback, true) != SPI_RET_OK)
   1a7c6:	2401      	movs	r4, #1
   1a7c8:	9402      	str	r4, [sp, #8]
   1a7ca:	4c0b      	ldr	r4, [pc, #44]	; (1a7f8 <eflash_read_data+0xd8>)
   1a7cc:	b292      	uxth	r2, r2
   1a7ce:	9200      	str	r2, [sp, #0]
   1a7d0:	9401      	str	r4, [sp, #4]
   1a7d2:	2204      	movs	r2, #4
   1a7d4:	f007 fa50 	bl	21c78 <spi_recv_data>
   1a7d8:	2800      	cmp	r0, #0
   1a7da:	d1e8      	bne.n	1a7ae <eflash_read_data+0x8e>
   1a7dc:	002c      	movs	r4, r5
   1a7de:	e7cb      	b.n	1a778 <eflash_read_data+0x58>
        eflash_cmd_exec_error = false;
   1a7e0:	2200      	movs	r2, #0
   1a7e2:	701a      	strb	r2, [r3, #0]
   1a7e4:	e7c2      	b.n	1a76c <eflash_read_data+0x4c>
   1a7e6:	46c0      	nop			; (mov r8, r8)
   1a7e8:	001fffff 	.word	0x001fffff
   1a7ec:	01002bc8 	.word	0x01002bc8
   1a7f0:	01002bcd 	.word	0x01002bcd
   1a7f4:	01002bc5 	.word	0x01002bc5
   1a7f8:	0001a1b5 	.word	0x0001a1b5

0001a7fc <eflash_32kblock_erase>:
{
   1a7fc:	b510      	push	{r4, lr}
   1a7fe:	0004      	movs	r4, r0
    if (non_os_is_driver_initialised(DRIVER_INIT_EFLASH) == false)
   1a800:	2019      	movs	r0, #25
   1a802:	f7fd fcff 	bl	18204 <non_os_is_driver_initialised>
   1a806:	2800      	cmp	r0, #0
   1a808:	d102      	bne.n	1a810 <eflash_32kblock_erase+0x14>
        return EFLASH_RET_ERROR;
   1a80a:	2403      	movs	r4, #3
}
   1a80c:	0020      	movs	r0, r4
   1a80e:	bd10      	pop	{r4, pc}
    if (block_id >= EFLASH_32KBLOCK_MAX_ID)
   1a810:	2c3f      	cmp	r4, #63	; 0x3f
   1a812:	d8fa      	bhi.n	1a80a <eflash_32kblock_erase+0xe>
    eflash_helper_take_mutex(eflash_mutex, osWaitForever);
   1a814:	4b0a      	ldr	r3, [pc, #40]	; (1a840 <eflash_32kblock_erase+0x44>)
   1a816:	6818      	ldr	r0, [r3, #0]
   1a818:	f7ff fdf4 	bl	1a404 <eflash_helper_take_mutex.constprop.4>
    eflash_ensure_sleep_vetoed();
   1a81c:	f7ff fd4e 	bl	1a2bc <eflash_ensure_sleep_vetoed>
    if (eflash_wake() != EFLASH_RET_OK)
   1a820:	f7ff fcf6 	bl	1a210 <eflash_wake>
   1a824:	2800      	cmp	r0, #0
   1a826:	d1f0      	bne.n	1a80a <eflash_32kblock_erase+0xe>
    if (eflash_helper_erase(block_id, EFLASH_ERASE_32KBLOCK) != EFLASH_RET_OK)
   1a828:	0020      	movs	r0, r4
   1a82a:	2101      	movs	r1, #1
   1a82c:	f7ff fd7e 	bl	1a32c <eflash_helper_erase>
   1a830:	1e04      	subs	r4, r0, #0
   1a832:	d002      	beq.n	1a83a <eflash_32kblock_erase+0x3e>
        (void)eflash_sleep();
   1a834:	f7ff fdfe 	bl	1a434 <eflash_sleep>
   1a838:	e7e7      	b.n	1a80a <eflash_32kblock_erase+0xe>
    (void)eflash_sleep();
   1a83a:	f7ff fdfb 	bl	1a434 <eflash_sleep>
    return EFLASH_RET_OK;
   1a83e:	e7e5      	b.n	1a80c <eflash_32kblock_erase+0x10>
   1a840:	01002bc8 	.word	0x01002bc8

0001a844 <eflash_get_32kblock_id>:
    if ((addr >= EFLASH_MAX_ADDR) || (id == NULL))
   1a844:	4a05      	ldr	r2, [pc, #20]	; (1a85c <eflash_get_32kblock_id+0x18>)
        return EFLASH_RET_ERROR;
   1a846:	2303      	movs	r3, #3
    if ((addr >= EFLASH_MAX_ADDR) || (id == NULL))
   1a848:	4290      	cmp	r0, r2
   1a84a:	d804      	bhi.n	1a856 <eflash_get_32kblock_id+0x12>
   1a84c:	2900      	cmp	r1, #0
   1a84e:	d002      	beq.n	1a856 <eflash_get_32kblock_id+0x12>
    return EFLASH_RET_OK;
   1a850:	2300      	movs	r3, #0
    *id = (uint16)(addr >> EFLASH_32KBLOCK_SHIFT);
   1a852:	0bc0      	lsrs	r0, r0, #15
   1a854:	8008      	strh	r0, [r1, #0]
}
   1a856:	0018      	movs	r0, r3
   1a858:	4770      	bx	lr
   1a85a:	46c0      	nop			; (mov r8, r8)
   1a85c:	001fffff 	.word	0x001fffff

0001a860 <eflash_is_available>:
    return eflash_available;
   1a860:	4b01      	ldr	r3, [pc, #4]	; (1a868 <eflash_is_available+0x8>)
   1a862:	7818      	ldrb	r0, [r3, #0]
}
   1a864:	4770      	bx	lr
   1a866:	46c0      	nop			; (mov r8, r8)
   1a868:	01002bc4 	.word	0x01002bc4

0001a86c <snprintf>:
 */
 
#include "stdio_private.h"

int snprintf(char *s, size_t size, const char * format, ...)
{
   1a86c:	b40c      	push	{r2, r3}
   1a86e:	b500      	push	{lr}
   1a870:	b083      	sub	sp, #12
   1a872:	ab04      	add	r3, sp, #16
   1a874:	cb04      	ldmia	r3!, {r2}
    va_list arg;
    int ret;

    va_start(arg, format);
   1a876:	9301      	str	r3, [sp, #4]
    ret = vsnprintf(s, size, format, arg);
   1a878:	f000 f804 	bl	1a884 <vsnprintf>
    va_end(arg);
    return (ret);
   1a87c:	b003      	add	sp, #12
   1a87e:	bc08      	pop	{r3}
   1a880:	b002      	add	sp, #8
   1a882:	4718      	bx	r3

0001a884 <vsnprintf>:
 */
 
#include "stdio_private.h"

int vsnprintf(char *s, size_t size, const char *format, va_list arg)
{
   1a884:	b570      	push	{r4, r5, r6, lr}
   1a886:	0005      	movs	r5, r0
   1a888:	000c      	movs	r4, r1
   1a88a:	0010      	movs	r0, r2
   1a88c:	0019      	movs	r1, r3
    int ret;

    ret = vvprintf(format, arg, s, size);
   1a88e:	0023      	movs	r3, r4
   1a890:	002a      	movs	r2, r5
   1a892:	f000 f81f 	bl	1a8d4 <vvprintf>
    if (ret >= 0)
   1a896:	2800      	cmp	r0, #0
   1a898:	db08      	blt.n	1a8ac <vsnprintf+0x28>
    {
        if (size != 0)
   1a89a:	2c00      	cmp	r4, #0
   1a89c:	d006      	beq.n	1a8ac <vsnprintf+0x28>
        {
            size--;
   1a89e:	3c01      	subs	r4, #1
            size = min((size_t)ret, size);
   1a8a0:	0003      	movs	r3, r0
   1a8a2:	42a0      	cmp	r0, r4
   1a8a4:	d900      	bls.n	1a8a8 <vsnprintf+0x24>
   1a8a6:	0023      	movs	r3, r4
            *(s + size) = '\0';
   1a8a8:	2200      	movs	r2, #0
   1a8aa:	54ea      	strb	r2, [r5, r3]
        }
    }
    return (ret);
}
   1a8ac:	bd70      	pop	{r4, r5, r6, pc}

0001a8ae <vsprintf>:
 */

#include "stdio_private.h"

__PDPCLIB_API__ int vsprintf(char *s, const char *format, va_list arg)
{
   1a8ae:	b510      	push	{r4, lr}
   1a8b0:	0004      	movs	r4, r0
   1a8b2:	0008      	movs	r0, r1
   1a8b4:	0011      	movs	r1, r2
    int ret;
    
    if (s == NULL)
   1a8b6:	2c00      	cmp	r4, #0
   1a8b8:	d009      	beq.n	1a8ce <vsprintf+0x20>
        return -1;

    ret = vvprintf(format, arg, s, STDIO_STRING_UNLIMITED);
   1a8ba:	2301      	movs	r3, #1
   1a8bc:	425b      	negs	r3, r3
   1a8be:	0022      	movs	r2, r4
   1a8c0:	f000 f808 	bl	1a8d4 <vvprintf>
    if (ret >= 0)
   1a8c4:	2800      	cmp	r0, #0
   1a8c6:	db01      	blt.n	1a8cc <vsprintf+0x1e>
    {
        *(s + ret) = '\0';
   1a8c8:	2300      	movs	r3, #0
   1a8ca:	5423      	strb	r3, [r4, r0]
    }
    return (ret);
}
   1a8cc:	bd10      	pop	{r4, pc}
        return -1;
   1a8ce:	2001      	movs	r0, #1
   1a8d0:	4240      	negs	r0, r0
   1a8d2:	e7fb      	b.n	1a8cc <vsprintf+0x1e>

0001a8d4 <vvprintf>:
    *formt = format;
    return (extraCh);
}

int vvprintf(const char *format, va_list arg, char *s, size_t maxlen)
{
   1a8d4:	b5f0      	push	{r4, r5, r6, r7, lr}
   1a8d6:	46de      	mov	lr, fp
   1a8d8:	4657      	mov	r7, sl
   1a8da:	464e      	mov	r6, r9
   1a8dc:	4645      	mov	r5, r8
   1a8de:	b5e0      	push	{r5, r6, r7, lr}
   1a8e0:	b0a7      	sub	sp, #156	; 0x9c
   1a8e2:	0005      	movs	r5, r0
   1a8e4:	9200      	str	r2, [sp, #0]
   1a8e6:	001e      	movs	r6, r3
   1a8e8:	468a      	mov	sl, r1
    int fin = 0;
    int vint;
    unsigned int uvint;
    const char *vcptr;
    int chcount = 0;
   1a8ea:	2300      	movs	r3, #0
    if (isdigit((unsigned char)*format))
   1a8ec:	001c      	movs	r4, r3
   1a8ee:	f000 fc07 	bl	1b100 <vvprintf+0x82c>
        {
            fin = 1;
        }
        else if (*format == '%')
        {
            format++;
   1a8f2:	1c6b      	adds	r3, r5, #1
   1a8f4:	4699      	mov	r9, r3
            if (*format == 'd')
   1a8f6:	786b      	ldrb	r3, [r5, #1]
   1a8f8:	2b64      	cmp	r3, #100	; 0x64
   1a8fa:	d019      	beq.n	1a930 <vvprintf+0x5c>
                {
                    nptr--;
                    outch(*nptr, chcount);
                } while (nptr != numbuf);
            }
            else if (*format == 's')
   1a8fc:	2b73      	cmp	r3, #115	; 0x73
   1a8fe:	d056      	beq.n	1a9ae <vvprintf+0xda>
                s += len;
                chcount += len;
                if (maxlen != STDIO_STRING_UNLIMITED)
                    maxlen -= copy_len;
            }
            else if (*format == 'c')
   1a900:	2b63      	cmp	r3, #99	; 0x63
   1a902:	d100      	bne.n	1a906 <vvprintf+0x32>
   1a904:	e081      	b.n	1aa0a <vvprintf+0x136>
            {
                vint = va_arg(arg, int);
                outch(vint, chcount);
            }
            else if (*format == 'n')
   1a906:	2b6e      	cmp	r3, #110	; 0x6e
   1a908:	d100      	bne.n	1a90c <vvprintf+0x38>
   1a90a:	e092      	b.n	1aa32 <vvprintf+0x15e>
            {
                viptr = va_arg(arg, int *);
                *viptr = chcount;
            }
            else if (*format == '%')
   1a90c:	2b25      	cmp	r3, #37	; 0x25
   1a90e:	d000      	beq.n	1a912 <vvprintf+0x3e>
   1a910:	e097      	b.n	1aa42 <vvprintf+0x16e>
            {
                outch('%', chcount);
   1a912:	2e00      	cmp	r6, #0
   1a914:	d100      	bne.n	1a918 <vvprintf+0x44>
   1a916:	e3c2      	b.n	1b09e <vvprintf+0x7ca>
   1a918:	9900      	ldr	r1, [sp, #0]
   1a91a:	1c4a      	adds	r2, r1, #1
   1a91c:	700b      	strb	r3, [r1, #0]
   1a91e:	3401      	adds	r4, #1
   1a920:	1e73      	subs	r3, r6, #1
   1a922:	1cd9      	adds	r1, r3, #3
   1a924:	d900      	bls.n	1a928 <vvprintf+0x54>
   1a926:	e3a8      	b.n	1b07a <vvprintf+0x7a6>
            format++;
   1a928:	464d      	mov	r5, r9
                outch('%', chcount);
   1a92a:	001e      	movs	r6, r3
   1a92c:	9200      	str	r2, [sp, #0]
   1a92e:	e3e6      	b.n	1b0fe <vvprintf+0x82a>
                vint = va_arg(arg, int);
   1a930:	3b60      	subs	r3, #96	; 0x60
   1a932:	4453      	add	r3, sl
   1a934:	469b      	mov	fp, r3
   1a936:	4653      	mov	r3, sl
   1a938:	681b      	ldr	r3, [r3, #0]
   1a93a:	469a      	mov	sl, r3
                    uvint = -vint;
   1a93c:	17da      	asrs	r2, r3, #31
   1a93e:	189d      	adds	r5, r3, r2
   1a940:	4055      	eors	r5, r2
    int chcount = 0;
   1a942:	af19      	add	r7, sp, #100	; 0x64
   1a944:	46a0      	mov	r8, r4
   1a946:	e000      	b.n	1a94a <vvprintf+0x76>
                    *nptr++ = (char)('0' + uvint % 10);
   1a948:	0027      	movs	r7, r4
   1a94a:	1c7c      	adds	r4, r7, #1
   1a94c:	210a      	movs	r1, #10
   1a94e:	0028      	movs	r0, r5
   1a950:	f7e5 fdb8 	bl	4c4 <__aeabi_uidivmod>
   1a954:	3130      	adds	r1, #48	; 0x30
   1a956:	7039      	strb	r1, [r7, #0]
                    uvint /= 10;
   1a958:	210a      	movs	r1, #10
   1a95a:	0028      	movs	r0, r5
   1a95c:	f7e5 fd2c 	bl	3b8 <__udivsi3>
   1a960:	1e05      	subs	r5, r0, #0
                } while (uvint > 0);
   1a962:	d1f1      	bne.n	1a948 <vvprintf+0x74>
   1a964:	4643      	mov	r3, r8
   1a966:	46a0      	mov	r8, r4
   1a968:	001c      	movs	r4, r3
                if (vint < 0)
   1a96a:	4653      	mov	r3, sl
   1a96c:	2b00      	cmp	r3, #0
   1a96e:	db03      	blt.n	1a978 <vvprintf+0xa4>
                    *nptr++ = (char)('0' + uvint % 10);
   1a970:	4643      	mov	r3, r8
                } while (nptr != numbuf);
   1a972:	a819      	add	r0, sp, #100	; 0x64
   1a974:	9a00      	ldr	r2, [sp, #0]
   1a976:	e006      	b.n	1a986 <vvprintf+0xb2>
                    *nptr++ = '-';
   1a978:	1cbb      	adds	r3, r7, #2
   1a97a:	4698      	mov	r8, r3
   1a97c:	232d      	movs	r3, #45	; 0x2d
   1a97e:	707b      	strb	r3, [r7, #1]
   1a980:	e7f6      	b.n	1a970 <vvprintf+0x9c>
                } while (nptr != numbuf);
   1a982:	4283      	cmp	r3, r0
   1a984:	d00b      	beq.n	1a99e <vvprintf+0xca>
                    nptr--;
   1a986:	3b01      	subs	r3, #1
                    outch(*nptr, chcount);
   1a988:	2e00      	cmp	r6, #0
   1a98a:	d0fa      	beq.n	1a982 <vvprintf+0xae>
   1a98c:	1c55      	adds	r5, r2, #1
   1a98e:	7819      	ldrb	r1, [r3, #0]
   1a990:	7011      	strb	r1, [r2, #0]
   1a992:	1e71      	subs	r1, r6, #1
   1a994:	002a      	movs	r2, r5
   1a996:	1ccf      	adds	r7, r1, #3
   1a998:	d8f3      	bhi.n	1a982 <vvprintf+0xae>
   1a99a:	000e      	movs	r6, r1
   1a99c:	e7f1      	b.n	1a982 <vvprintf+0xae>
   1a99e:	9200      	str	r2, [sp, #0]
   1a9a0:	ab26      	add	r3, sp, #152	; 0x98
   1a9a2:	1ae4      	subs	r4, r4, r3
   1a9a4:	4444      	add	r4, r8
   1a9a6:	3434      	adds	r4, #52	; 0x34
                vint = va_arg(arg, int);
   1a9a8:	46da      	mov	sl, fp
            format++;
   1a9aa:	464d      	mov	r5, r9
   1a9ac:	e3a7      	b.n	1b0fe <vvprintf+0x82a>
                vcptr = va_arg(arg, const char *);
   1a9ae:	3b6f      	subs	r3, #111	; 0x6f
   1a9b0:	4453      	add	r3, sl
   1a9b2:	4698      	mov	r8, r3
   1a9b4:	4653      	mov	r3, sl
   1a9b6:	681f      	ldr	r7, [r3, #0]
                if (vcptr == NULL)
   1a9b8:	2f00      	cmp	r7, #0
   1a9ba:	d018      	beq.n	1a9ee <vvprintf+0x11a>
                len = strlen(vcptr);
   1a9bc:	0038      	movs	r0, r7
   1a9be:	f000 fcee 	bl	1b39e <strlen>
   1a9c2:	0005      	movs	r5, r0
                if (maxlen != STDIO_STRING_UNLIMITED)
   1a9c4:	1c73      	adds	r3, r6, #1
   1a9c6:	d014      	beq.n	1a9f2 <vvprintf+0x11e>
                    copy_len = min(len, maxlen);
   1a9c8:	0002      	movs	r2, r0
   1a9ca:	42b0      	cmp	r0, r6
   1a9cc:	d900      	bls.n	1a9d0 <vvprintf+0xfc>
   1a9ce:	0032      	movs	r2, r6
   1a9d0:	4692      	mov	sl, r2
                if (copy_len)
   1a9d2:	2a00      	cmp	r2, #0
   1a9d4:	d100      	bne.n	1a9d8 <vvprintf+0x104>
   1a9d6:	e353      	b.n	1b080 <vvprintf+0x7ac>
                    memcpy(s, vcptr, copy_len);
   1a9d8:	0039      	movs	r1, r7
   1a9da:	9f00      	ldr	r7, [sp, #0]
   1a9dc:	0038      	movs	r0, r7
   1a9de:	f7e5 fc07 	bl	1f0 <memcpy>
                s += len;
   1a9e2:	46bc      	mov	ip, r7
   1a9e4:	44ac      	add	ip, r5
   1a9e6:	4663      	mov	r3, ip
   1a9e8:	9300      	str	r3, [sp, #0]
                chcount += len;
   1a9ea:	1964      	adds	r4, r4, r5
   1a9ec:	e34e      	b.n	1b08c <vvprintf+0x7b8>
                    vcptr = "(null)";
   1a9ee:	4fb9      	ldr	r7, [pc, #740]	; (1acd4 <vvprintf+0x400>)
   1a9f0:	e7e4      	b.n	1a9bc <vvprintf+0xe8>
                if (copy_len)
   1a9f2:	2800      	cmp	r0, #0
   1a9f4:	d000      	beq.n	1a9f8 <vvprintf+0x124>
   1a9f6:	e396      	b.n	1b126 <vvprintf+0x852>
                s += len;
   1a9f8:	9b00      	ldr	r3, [sp, #0]
   1a9fa:	469c      	mov	ip, r3
   1a9fc:	4484      	add	ip, r0
   1a9fe:	4663      	mov	r3, ip
   1aa00:	9300      	str	r3, [sp, #0]
                chcount += len;
   1aa02:	1824      	adds	r4, r4, r0
                vcptr = va_arg(arg, const char *);
   1aa04:	46c2      	mov	sl, r8
            format++;
   1aa06:	464d      	mov	r5, r9
   1aa08:	e379      	b.n	1b0fe <vvprintf+0x82a>
                vint = va_arg(arg, int);
   1aa0a:	4653      	mov	r3, sl
   1aa0c:	3304      	adds	r3, #4
                outch(vint, chcount);
   1aa0e:	2e00      	cmp	r6, #0
   1aa10:	d100      	bne.n	1aa14 <vvprintf+0x140>
   1aa12:	e340      	b.n	1b096 <vvprintf+0x7c2>
   1aa14:	9800      	ldr	r0, [sp, #0]
   1aa16:	1c41      	adds	r1, r0, #1
   1aa18:	4652      	mov	r2, sl
   1aa1a:	6812      	ldr	r2, [r2, #0]
   1aa1c:	7002      	strb	r2, [r0, #0]
   1aa1e:	3401      	adds	r4, #1
   1aa20:	1e72      	subs	r2, r6, #1
   1aa22:	1cd0      	adds	r0, r2, #3
   1aa24:	d900      	bls.n	1aa28 <vvprintf+0x154>
   1aa26:	e324      	b.n	1b072 <vvprintf+0x79e>
                vint = va_arg(arg, int);
   1aa28:	469a      	mov	sl, r3
            format++;
   1aa2a:	464d      	mov	r5, r9
                outch(vint, chcount);
   1aa2c:	0016      	movs	r6, r2
   1aa2e:	9100      	str	r1, [sp, #0]
   1aa30:	e365      	b.n	1b0fe <vvprintf+0x82a>
                viptr = va_arg(arg, int *);
   1aa32:	4653      	mov	r3, sl
   1aa34:	681b      	ldr	r3, [r3, #0]
                *viptr = chcount;
   1aa36:	601c      	str	r4, [r3, #0]
                viptr = va_arg(arg, int *);
   1aa38:	2304      	movs	r3, #4
   1aa3a:	469c      	mov	ip, r3
   1aa3c:	44e2      	add	sl, ip
            format++;
   1aa3e:	464d      	mov	r5, r9
   1aa40:	e35d      	b.n	1b0fe <vvprintf+0x82a>
    int width = 0;
   1aa42:	2700      	movs	r7, #0
    int flagHash = 0;
   1aa44:	2300      	movs	r3, #0
   1aa46:	9304      	str	r3, [sp, #16]
    int flagMinus = 0;
   1aa48:	9302      	str	r3, [sp, #8]
    int flagZero = 0;
   1aa4a:	9301      	str	r3, [sp, #4]
    int flagPlus = 0;
   1aa4c:	9305      	str	r3, [sp, #20]
            case '-': flagMinus = 1;
   1aa4e:	2201      	movs	r2, #1
   1aa50:	4655      	mov	r5, sl
   1aa52:	4648      	mov	r0, r9
   1aa54:	e010      	b.n	1aa78 <vvprintf+0x1a4>
            case '+': flagPlus = 1;
   1aa56:	9205      	str	r2, [sp, #20]
   1aa58:	e00d      	b.n	1aa76 <vvprintf+0x1a2>
            case '#': flagHash = 1;
   1aa5a:	9204      	str	r2, [sp, #16]
   1aa5c:	e00b      	b.n	1aa76 <vvprintf+0x1a2>
            case '0': flagZero = 1;
   1aa5e:	2301      	movs	r3, #1
   1aa60:	9301      	str	r3, [sp, #4]
   1aa62:	e008      	b.n	1aa76 <vvprintf+0x1a2>
            case '*': width = va_arg(*arg, int);
   1aa64:	1d2b      	adds	r3, r5, #4
   1aa66:	682f      	ldr	r7, [r5, #0]
   1aa68:	001d      	movs	r5, r3
                      if (width < 0)
   1aa6a:	2f00      	cmp	r7, #0
   1aa6c:	da03      	bge.n	1aa76 <vvprintf+0x1a2>
                          width = -width;
   1aa6e:	427f      	negs	r7, r7
                          flagMinus = 1;
   1aa70:	9202      	str	r2, [sp, #8]
   1aa72:	e000      	b.n	1aa76 <vvprintf+0x1a2>
            case '-': flagMinus = 1;
   1aa74:	9202      	str	r2, [sp, #8]
            format++;
   1aa76:	3001      	adds	r0, #1
        switch (*format)
   1aa78:	7803      	ldrb	r3, [r0, #0]
   1aa7a:	3b20      	subs	r3, #32
   1aa7c:	b2d9      	uxtb	r1, r3
   1aa7e:	2910      	cmp	r1, #16
   1aa80:	d803      	bhi.n	1aa8a <vvprintf+0x1b6>
   1aa82:	008b      	lsls	r3, r1, #2
   1aa84:	4994      	ldr	r1, [pc, #592]	; (1acd8 <vvprintf+0x404>)
   1aa86:	58cb      	ldr	r3, [r1, r3]
   1aa88:	469f      	mov	pc, r3
   1aa8a:	46aa      	mov	sl, r5
   1aa8c:	4681      	mov	r9, r0
                flagZero = 0;
   1aa8e:	9b02      	ldr	r3, [sp, #8]
   1aa90:	425a      	negs	r2, r3
   1aa92:	4153      	adcs	r3, r2
   1aa94:	425b      	negs	r3, r3
   1aa96:	9a01      	ldr	r2, [sp, #4]
   1aa98:	401a      	ands	r2, r3
   1aa9a:	9201      	str	r2, [sp, #4]
    if (isdigit((unsigned char)*format))
   1aa9c:	4b8f      	ldr	r3, [pc, #572]	; (1acdc <vvprintf+0x408>)
   1aa9e:	681a      	ldr	r2, [r3, #0]
   1aaa0:	7803      	ldrb	r3, [r0, #0]
   1aaa2:	18d1      	adds	r1, r2, r3
   1aaa4:	7849      	ldrb	r1, [r1, #1]
   1aaa6:	0749      	lsls	r1, r1, #29
   1aaa8:	d50f      	bpl.n	1aaca <vvprintf+0x1f6>
        while (isdigit((unsigned char)*format))
   1aaaa:	2104      	movs	r1, #4
   1aaac:	0005      	movs	r5, r0
   1aaae:	0038      	movs	r0, r7
            width = width * 10 + (*format - '0');
   1aab0:	0087      	lsls	r7, r0, #2
   1aab2:	183f      	adds	r7, r7, r0
   1aab4:	007f      	lsls	r7, r7, #1
   1aab6:	3b30      	subs	r3, #48	; 0x30
   1aab8:	19d8      	adds	r0, r3, r7
            format++;
   1aaba:	3501      	adds	r5, #1
        while (isdigit((unsigned char)*format))
   1aabc:	782b      	ldrb	r3, [r5, #0]
   1aabe:	18d7      	adds	r7, r2, r3
   1aac0:	787f      	ldrb	r7, [r7, #1]
   1aac2:	4239      	tst	r1, r7
   1aac4:	d1f4      	bne.n	1aab0 <vvprintf+0x1dc>
   1aac6:	46a9      	mov	r9, r5
   1aac8:	0007      	movs	r7, r0
    if (*format == '.')
   1aaca:	464b      	mov	r3, r9
   1aacc:	781b      	ldrb	r3, [r3, #0]
   1aace:	2b2e      	cmp	r3, #46	; 0x2e
   1aad0:	d046      	beq.n	1ab60 <vvprintf+0x28c>
    int precision = -1;
   1aad2:	2301      	movs	r3, #1
   1aad4:	425b      	negs	r3, r3
   1aad6:	4698      	mov	r8, r3
    switch (*format++) {
   1aad8:	464b      	mov	r3, r9
   1aada:	1c5d      	adds	r5, r3, #1
   1aadc:	781b      	ldrb	r3, [r3, #0]
   1aade:	2b68      	cmp	r3, #104	; 0x68
   1aae0:	d076      	beq.n	1abd0 <vvprintf+0x2fc>
   1aae2:	2b6c      	cmp	r3, #108	; 0x6c
   1aae4:	d067      	beq.n	1abb6 <vvprintf+0x2e2>
   1aae6:	2b4c      	cmp	r3, #76	; 0x4c
   1aae8:	d065      	beq.n	1abb6 <vvprintf+0x2e2>
        format--;
   1aaea:	464d      	mov	r5, r9
    int lng = 0;
   1aaec:	2300      	movs	r3, #0
   1aaee:	9303      	str	r3, [sp, #12]
    specifier = *format;
   1aaf0:	7829      	ldrb	r1, [r5, #0]
   1aaf2:	9108      	str	r1, [sp, #32]
   1aaf4:	468b      	mov	fp, r1
    if (strchr("dxXuiop", specifier) != NULL && specifier != 0)
   1aaf6:	487a      	ldr	r0, [pc, #488]	; (1ace0 <vvprintf+0x40c>)
   1aaf8:	f000 fc20 	bl	1b33c <strchr>
   1aafc:	2800      	cmp	r0, #0
   1aafe:	d100      	bne.n	1ab02 <vvprintf+0x22e>
   1ab00:	e20e      	b.n	1af20 <vvprintf+0x64c>
   1ab02:	465b      	mov	r3, fp
   1ab04:	2b00      	cmp	r3, #0
   1ab06:	d100      	bne.n	1ab0a <vvprintf+0x236>
   1ab08:	e1fb      	b.n	1af02 <vvprintf+0x62e>
        if (precision < 0)
   1ab0a:	4643      	mov	r3, r8
   1ab0c:	2b00      	cmp	r3, #0
   1ab0e:	db62      	blt.n	1abd6 <vvprintf+0x302>
        if (lng == 1)
   1ab10:	9b03      	ldr	r3, [sp, #12]
   1ab12:	2b01      	cmp	r3, #1
   1ab14:	d062      	beq.n	1abdc <vvprintf+0x308>
        else if (lng == 2)
   1ab16:	9b03      	ldr	r3, [sp, #12]
   1ab18:	2b02      	cmp	r3, #2
   1ab1a:	d065      	beq.n	1abe8 <vvprintf+0x314>
            ivalue = va_arg(*arg, int);
   1ab1c:	4653      	mov	r3, sl
   1ab1e:	681b      	ldr	r3, [r3, #0]
   1ab20:	2204      	movs	r2, #4
   1ab22:	4694      	mov	ip, r2
   1ab24:	44e2      	add	sl, ip
            ulvalue = (unsigned long)lvalue;
   1ab26:	1e19      	subs	r1, r3, #0
            if ((lvalue < 0) && ((specifier == 'd') || (specifier == 'i')))
   1ab28:	db6f      	blt.n	1ac0a <vvprintf+0x336>
                neg = 0;
   1ab2a:	2300      	movs	r3, #0
   1ab2c:	9309      	str	r3, [sp, #36]	; 0x24
    unsigned long long ullvalue = 0;
   1ab2e:	2200      	movs	r2, #0
   1ab30:	2300      	movs	r3, #0
   1ab32:	9206      	str	r2, [sp, #24]
   1ab34:	9307      	str	r3, [sp, #28]
        if ((specifier == 'X') || (specifier == 'x') || (specifier == 'p'))
   1ab36:	2320      	movs	r3, #32
   1ab38:	9a08      	ldr	r2, [sp, #32]
   1ab3a:	439a      	bics	r2, r3
   1ab3c:	2a58      	cmp	r2, #88	; 0x58
   1ab3e:	d100      	bne.n	1ab42 <vvprintf+0x26e>
   1ab40:	e2b0      	b.n	1b0a4 <vvprintf+0x7d0>
   1ab42:	465b      	mov	r3, fp
   1ab44:	2b70      	cmp	r3, #112	; 0x70
   1ab46:	d100      	bne.n	1ab4a <vvprintf+0x276>
   1ab48:	e087      	b.n	1ac5a <vvprintf+0x386>
            base = 10;
   1ab4a:	3b6f      	subs	r3, #111	; 0x6f
   1ab4c:	425a      	negs	r2, r3
   1ab4e:	4153      	adcs	r3, r2
   1ab50:	425b      	negs	r3, r3
   1ab52:	2201      	movs	r2, #1
   1ab54:	4393      	bics	r3, r2
   1ab56:	469c      	mov	ip, r3
   1ab58:	230a      	movs	r3, #10
   1ab5a:	4699      	mov	r9, r3
   1ab5c:	44cc      	add	ip, r9
   1ab5e:	e2a3      	b.n	1b0a8 <vvprintf+0x7d4>
        if (*format == '*')
   1ab60:	464b      	mov	r3, r9
   1ab62:	7859      	ldrb	r1, [r3, #1]
   1ab64:	292a      	cmp	r1, #42	; 0x2a
   1ab66:	d01c      	beq.n	1aba2 <vvprintf+0x2ce>
        format++;
   1ab68:	2301      	movs	r3, #1
   1ab6a:	469c      	mov	ip, r3
   1ab6c:	44e1      	add	r9, ip
            while (isdigit((unsigned char)*format))
   1ab6e:	1853      	adds	r3, r2, r1
   1ab70:	785b      	ldrb	r3, [r3, #1]
            precision = 0;
   1ab72:	2000      	movs	r0, #0
   1ab74:	4680      	mov	r8, r0
            while (isdigit((unsigned char)*format))
   1ab76:	3004      	adds	r0, #4
   1ab78:	075b      	lsls	r3, r3, #29
   1ab7a:	d5ad      	bpl.n	1aad8 <vvprintf+0x204>
   1ab7c:	4645      	mov	r5, r8
   1ab7e:	46a4      	mov	ip, r4
   1ab80:	0014      	movs	r4, r2
   1ab82:	464a      	mov	r2, r9
                precision = precision * 10 + (*format - '0');
   1ab84:	00ab      	lsls	r3, r5, #2
   1ab86:	195b      	adds	r3, r3, r5
   1ab88:	005b      	lsls	r3, r3, #1
   1ab8a:	3930      	subs	r1, #48	; 0x30
   1ab8c:	18cd      	adds	r5, r1, r3
                format++;
   1ab8e:	3201      	adds	r2, #1
            while (isdigit((unsigned char)*format))
   1ab90:	7811      	ldrb	r1, [r2, #0]
   1ab92:	1863      	adds	r3, r4, r1
   1ab94:	785b      	ldrb	r3, [r3, #1]
   1ab96:	4218      	tst	r0, r3
   1ab98:	d1f4      	bne.n	1ab84 <vvprintf+0x2b0>
   1ab9a:	4691      	mov	r9, r2
   1ab9c:	46a8      	mov	r8, r5
   1ab9e:	4664      	mov	r4, ip
   1aba0:	e79a      	b.n	1aad8 <vvprintf+0x204>
            precision = va_arg(*arg, int);
   1aba2:	4653      	mov	r3, sl
   1aba4:	681b      	ldr	r3, [r3, #0]
   1aba6:	4698      	mov	r8, r3
            format++;
   1aba8:	2302      	movs	r3, #2
   1abaa:	469c      	mov	ip, r3
   1abac:	44e1      	add	r9, ip
            precision = va_arg(*arg, int);
   1abae:	3302      	adds	r3, #2
   1abb0:	469c      	mov	ip, r3
   1abb2:	44e2      	add	sl, ip
   1abb4:	e790      	b.n	1aad8 <vvprintf+0x204>
        if (*format == 'l' || *format == 'L') {
   1abb6:	464b      	mov	r3, r9
   1abb8:	785b      	ldrb	r3, [r3, #1]
   1abba:	2220      	movs	r2, #32
   1abbc:	4393      	bics	r3, r2
            lng = 1;
   1abbe:	3a1f      	subs	r2, #31
   1abc0:	9203      	str	r2, [sp, #12]
        if (*format == 'l' || *format == 'L') {
   1abc2:	2b4c      	cmp	r3, #76	; 0x4c
   1abc4:	d194      	bne.n	1aaf0 <vvprintf+0x21c>
            format++;
   1abc6:	464d      	mov	r5, r9
   1abc8:	3502      	adds	r5, #2
            lng = 2;
   1abca:	3b4a      	subs	r3, #74	; 0x4a
   1abcc:	9303      	str	r3, [sp, #12]
   1abce:	e78f      	b.n	1aaf0 <vvprintf+0x21c>
    int lng = 0;
   1abd0:	2300      	movs	r3, #0
   1abd2:	9303      	str	r3, [sp, #12]
   1abd4:	e78c      	b.n	1aaf0 <vvprintf+0x21c>
            precision = 1;
   1abd6:	2301      	movs	r3, #1
   1abd8:	4698      	mov	r8, r3
   1abda:	e799      	b.n	1ab10 <vvprintf+0x23c>
            lvalue = va_arg(*arg, long);
   1abdc:	4653      	mov	r3, sl
   1abde:	681b      	ldr	r3, [r3, #0]
   1abe0:	2204      	movs	r2, #4
   1abe2:	4694      	mov	ip, r2
   1abe4:	44e2      	add	sl, ip
   1abe6:	e79e      	b.n	1ab26 <vvprintf+0x252>
            llvalue = va_arg(*arg, long long);
   1abe8:	4653      	mov	r3, sl
   1abea:	3307      	adds	r3, #7
   1abec:	2207      	movs	r2, #7
   1abee:	4393      	bics	r3, r2
   1abf0:	3201      	adds	r2, #1
   1abf2:	4692      	mov	sl, r2
   1abf4:	449a      	add	sl, r3
   1abf6:	681a      	ldr	r2, [r3, #0]
   1abf8:	685b      	ldr	r3, [r3, #4]
            ullvalue = (unsigned long long)llvalue;
   1abfa:	9206      	str	r2, [sp, #24]
   1abfc:	9307      	str	r3, [sp, #28]
            if ((llvalue < 0) && ((specifier == 'd') || (specifier == 'i')))
   1abfe:	2b00      	cmp	r3, #0
   1ac00:	db18      	blt.n	1ac34 <vvprintf+0x360>
                neg = 0;
   1ac02:	2300      	movs	r3, #0
   1ac04:	9309      	str	r3, [sp, #36]	; 0x24
    unsigned long ulvalue = 0;
   1ac06:	0019      	movs	r1, r3
   1ac08:	e795      	b.n	1ab36 <vvprintf+0x262>
            if ((lvalue < 0) && ((specifier == 'd') || (specifier == 'i')))
   1ac0a:	465a      	mov	r2, fp
   1ac0c:	2a64      	cmp	r2, #100	; 0x64
   1ac0e:	d008      	beq.n	1ac22 <vvprintf+0x34e>
   1ac10:	2a69      	cmp	r2, #105	; 0x69
   1ac12:	d006      	beq.n	1ac22 <vvprintf+0x34e>
                neg = 0;
   1ac14:	2300      	movs	r3, #0
   1ac16:	9309      	str	r3, [sp, #36]	; 0x24
    unsigned long long ullvalue = 0;
   1ac18:	2200      	movs	r2, #0
   1ac1a:	2300      	movs	r3, #0
   1ac1c:	9206      	str	r2, [sp, #24]
   1ac1e:	9307      	str	r3, [sp, #28]
   1ac20:	e789      	b.n	1ab36 <vvprintf+0x262>
                ulvalue = -lvalue;
   1ac22:	425b      	negs	r3, r3
   1ac24:	0019      	movs	r1, r3
                neg = 1;
   1ac26:	2301      	movs	r3, #1
   1ac28:	9309      	str	r3, [sp, #36]	; 0x24
    unsigned long long ullvalue = 0;
   1ac2a:	2200      	movs	r2, #0
   1ac2c:	2300      	movs	r3, #0
   1ac2e:	9206      	str	r2, [sp, #24]
   1ac30:	9307      	str	r3, [sp, #28]
   1ac32:	e780      	b.n	1ab36 <vvprintf+0x262>
            if ((llvalue < 0) && ((specifier == 'd') || (specifier == 'i')))
   1ac34:	4659      	mov	r1, fp
   1ac36:	2964      	cmp	r1, #100	; 0x64
   1ac38:	d005      	beq.n	1ac46 <vvprintf+0x372>
   1ac3a:	2969      	cmp	r1, #105	; 0x69
   1ac3c:	d003      	beq.n	1ac46 <vvprintf+0x372>
                neg = 0;
   1ac3e:	2300      	movs	r3, #0
   1ac40:	9309      	str	r3, [sp, #36]	; 0x24
    unsigned long ulvalue = 0;
   1ac42:	0019      	movs	r1, r3
   1ac44:	e777      	b.n	1ab36 <vvprintf+0x262>
                ullvalue = -llvalue;
   1ac46:	2100      	movs	r1, #0
   1ac48:	4250      	negs	r0, r2
   1ac4a:	4199      	sbcs	r1, r3
   1ac4c:	9006      	str	r0, [sp, #24]
   1ac4e:	9107      	str	r1, [sp, #28]
                neg = 1;
   1ac50:	2301      	movs	r3, #1
   1ac52:	9309      	str	r3, [sp, #36]	; 0x24
    unsigned long ulvalue = 0;
   1ac54:	2300      	movs	r3, #0
   1ac56:	0019      	movs	r1, r3
   1ac58:	e76d      	b.n	1ab36 <vvprintf+0x262>
            base = 16;
   1ac5a:	2310      	movs	r3, #16
   1ac5c:	469c      	mov	ip, r3
            precision = 8;
   1ac5e:	2208      	movs	r2, #8
   1ac60:	4690      	mov	r8, r2
   1ac62:	e221      	b.n	1b0a8 <vvprintf+0x7d4>
        x = 0;
   1ac64:	2200      	movs	r2, #0
   1ac66:	4691      	mov	r9, r2
            while (ullvalue > 0)
   1ac68:	9806      	ldr	r0, [sp, #24]
   1ac6a:	9907      	ldr	r1, [sp, #28]
   1ac6c:	0002      	movs	r2, r0
   1ac6e:	430a      	orrs	r2, r1
   1ac70:	d010      	beq.n	1ac94 <vvprintf+0x3c0>
                rem = (int)(ullvalue % base);
   1ac72:	4663      	mov	r3, ip
   1ac74:	9303      	str	r3, [sp, #12]
   1ac76:	17db      	asrs	r3, r3, #31
   1ac78:	9306      	str	r3, [sp, #24]
   1ac7a:	4653      	mov	r3, sl
   1ac7c:	930a      	str	r3, [sp, #40]	; 0x28
   1ac7e:	4643      	mov	r3, r8
   1ac80:	930b      	str	r3, [sp, #44]	; 0x2c
   1ac82:	46b8      	mov	r8, r7
   1ac84:	465f      	mov	r7, fp
   1ac86:	46aa      	mov	sl, r5
   1ac88:	46b3      	mov	fp, r6
   1ac8a:	464e      	mov	r6, r9
   1ac8c:	46a1      	mov	r9, r4
   1ac8e:	0004      	movs	r4, r0
   1ac90:	000d      	movs	r5, r1
   1ac92:	e072      	b.n	1ad7a <vvprintf+0x4a6>
        x = 0;
   1ac94:	2300      	movs	r3, #0
   1ac96:	4699      	mov	r9, r3
   1ac98:	e02c      	b.n	1acf4 <vvprintf+0x420>
                    if ((specifier == 'X') || (specifier == 'p'))
   1ac9a:	2e58      	cmp	r6, #88	; 0x58
   1ac9c:	d005      	beq.n	1acaa <vvprintf+0x3d6>
   1ac9e:	2e70      	cmp	r6, #112	; 0x70
   1aca0:	d003      	beq.n	1acaa <vvprintf+0x3d6>
                        work[x] = (char)('a' + (rem - 10));
   1aca2:	3157      	adds	r1, #87	; 0x57
   1aca4:	ab0c      	add	r3, sp, #48	; 0x30
   1aca6:	54e9      	strb	r1, [r5, r3]
   1aca8:	e002      	b.n	1acb0 <vvprintf+0x3dc>
                        work[x] = (char)('A' + (rem - 10));
   1acaa:	3137      	adds	r1, #55	; 0x37
   1acac:	ab0c      	add	r3, sp, #48	; 0x30
   1acae:	54e9      	strb	r1, [r5, r3]
                x++;
   1acb0:	3501      	adds	r5, #1
                ulvalue = ulvalue / base;
   1acb2:	9903      	ldr	r1, [sp, #12]
   1acb4:	0020      	movs	r0, r4
   1acb6:	f7e5 fb7f 	bl	3b8 <__udivsi3>
   1acba:	1e04      	subs	r4, r0, #0
            while (ulvalue > 0)
   1acbc:	d012      	beq.n	1ace4 <vvprintf+0x410>
                rem = (int)(ulvalue % base);
   1acbe:	9903      	ldr	r1, [sp, #12]
   1acc0:	0020      	movs	r0, r4
   1acc2:	f7e5 fbff 	bl	4c4 <__aeabi_uidivmod>
                if (rem < 10)
   1acc6:	2909      	cmp	r1, #9
   1acc8:	dce7      	bgt.n	1ac9a <vvprintf+0x3c6>
                    work[x] = (char)('0' + rem);
   1acca:	3130      	adds	r1, #48	; 0x30
   1accc:	ab0c      	add	r3, sp, #48	; 0x30
   1acce:	54e9      	strb	r1, [r5, r3]
   1acd0:	e7ee      	b.n	1acb0 <vvprintf+0x3dc>
   1acd2:	46c0      	nop			; (mov r8, r8)
   1acd4:	000256f0 	.word	0x000256f0
   1acd8:	000256ac 	.word	0x000256ac
   1acdc:	010005dc 	.word	0x010005dc
   1ace0:	000256f8 	.word	0x000256f8
   1ace4:	464c      	mov	r4, r9
   1ace6:	46a9      	mov	r9, r5
   1ace8:	4655      	mov	r5, sl
   1acea:	9b06      	ldr	r3, [sp, #24]
   1acec:	469a      	mov	sl, r3
   1acee:	465b      	mov	r3, fp
   1acf0:	46b3      	mov	fp, r6
   1acf2:	001e      	movs	r6, r3
        while (x < precision)
   1acf4:	45c1      	cmp	r9, r8
   1acf6:	da08      	bge.n	1ad0a <vvprintf+0x436>
            work[x] = '0';
   1acf8:	2330      	movs	r3, #48	; 0x30
   1acfa:	4641      	mov	r1, r8
   1acfc:	464a      	mov	r2, r9
   1acfe:	a80c      	add	r0, sp, #48	; 0x30
   1ad00:	5413      	strb	r3, [r2, r0]
            x++;
   1ad02:	3201      	adds	r2, #1
        while (x < precision)
   1ad04:	428a      	cmp	r2, r1
   1ad06:	d1fa      	bne.n	1acfe <vvprintf+0x42a>
   1ad08:	4691      	mov	r9, r2
        if (neg)
   1ad0a:	9b09      	ldr	r3, [sp, #36]	; 0x24
   1ad0c:	2b00      	cmp	r3, #0
   1ad0e:	d04e      	beq.n	1adae <vvprintf+0x4da>
            work[x++] = '-';
   1ad10:	464b      	mov	r3, r9
   1ad12:	3301      	adds	r3, #1
   1ad14:	9303      	str	r3, [sp, #12]
   1ad16:	232d      	movs	r3, #45	; 0x2d
   1ad18:	aa0c      	add	r2, sp, #48	; 0x30
   1ad1a:	4649      	mov	r1, r9
   1ad1c:	5453      	strb	r3, [r2, r1]
            fillCh = ' ';
   1ad1e:	9b01      	ldr	r3, [sp, #4]
   1ad20:	1e5a      	subs	r2, r3, #1
   1ad22:	4193      	sbcs	r3, r2
   1ad24:	425b      	negs	r3, r3
   1ad26:	2210      	movs	r2, #16
   1ad28:	401a      	ands	r2, r3
   1ad2a:	4694      	mov	ip, r2
   1ad2c:	2320      	movs	r3, #32
   1ad2e:	4698      	mov	r8, r3
   1ad30:	44c4      	add	ip, r8
        if (!flagMinus)
   1ad32:	9b02      	ldr	r3, [sp, #8]
   1ad34:	2b00      	cmp	r3, #0
   1ad36:	d15d      	bne.n	1adf4 <vvprintf+0x520>
            while (y < width)
   1ad38:	9903      	ldr	r1, [sp, #12]
   1ad3a:	428f      	cmp	r7, r1
   1ad3c:	dd79      	ble.n	1ae32 <vvprintf+0x55e>
   1ad3e:	9a00      	ldr	r2, [sp, #0]
   1ad40:	0033      	movs	r3, r6
   1ad42:	46a8      	mov	r8, r5
   1ad44:	4665      	mov	r5, ip
   1ad46:	46a4      	mov	ip, r4
   1ad48:	46b1      	mov	r9, r6
   1ad4a:	e040      	b.n	1adce <vvprintf+0x4fa>
                    if ((specifier == 'X') || (specifier == 'p'))
   1ad4c:	2f58      	cmp	r7, #88	; 0x58
   1ad4e:	d005      	beq.n	1ad5c <vvprintf+0x488>
   1ad50:	2f70      	cmp	r7, #112	; 0x70
   1ad52:	d003      	beq.n	1ad5c <vvprintf+0x488>
                        work[x] = (char)('a' + (rem - 10));
   1ad54:	3257      	adds	r2, #87	; 0x57
   1ad56:	ab0c      	add	r3, sp, #48	; 0x30
   1ad58:	54f2      	strb	r2, [r6, r3]
   1ad5a:	e002      	b.n	1ad62 <vvprintf+0x48e>
                        work[x] = (char)('A' + (rem - 10));
   1ad5c:	3237      	adds	r2, #55	; 0x37
   1ad5e:	ab0c      	add	r3, sp, #48	; 0x30
   1ad60:	54f2      	strb	r2, [r6, r3]
                x++;
   1ad62:	3601      	adds	r6, #1
                ullvalue = ullvalue / base;
   1ad64:	9a03      	ldr	r2, [sp, #12]
   1ad66:	9b06      	ldr	r3, [sp, #24]
   1ad68:	0020      	movs	r0, r4
   1ad6a:	0029      	movs	r1, r5
   1ad6c:	f7e5 fc9a 	bl	6a4 <__aeabi_uldivmod>
   1ad70:	0004      	movs	r4, r0
   1ad72:	000d      	movs	r5, r1
            while (ullvalue > 0)
   1ad74:	0003      	movs	r3, r0
   1ad76:	430b      	orrs	r3, r1
   1ad78:	d00b      	beq.n	1ad92 <vvprintf+0x4be>
                rem = (int)(ullvalue % base);
   1ad7a:	9a03      	ldr	r2, [sp, #12]
   1ad7c:	9b06      	ldr	r3, [sp, #24]
   1ad7e:	0020      	movs	r0, r4
   1ad80:	0029      	movs	r1, r5
   1ad82:	f7e5 fc8f 	bl	6a4 <__aeabi_uldivmod>
                if (rem < 10)
   1ad86:	2a09      	cmp	r2, #9
   1ad88:	dce0      	bgt.n	1ad4c <vvprintf+0x478>
                    work[x] = (char)('0' + rem);
   1ad8a:	3230      	adds	r2, #48	; 0x30
   1ad8c:	ab0c      	add	r3, sp, #48	; 0x30
   1ad8e:	54f2      	strb	r2, [r6, r3]
   1ad90:	e7e7      	b.n	1ad62 <vvprintf+0x48e>
   1ad92:	464c      	mov	r4, r9
   1ad94:	46b1      	mov	r9, r6
   1ad96:	4655      	mov	r5, sl
   1ad98:	9b0a      	ldr	r3, [sp, #40]	; 0x28
   1ad9a:	469a      	mov	sl, r3
   1ad9c:	465e      	mov	r6, fp
   1ad9e:	46bb      	mov	fp, r7
   1ada0:	4647      	mov	r7, r8
   1ada2:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
   1ada4:	4698      	mov	r8, r3
   1ada6:	e7a5      	b.n	1acf4 <vvprintf+0x420>
        x = 0;
   1ada8:	2300      	movs	r3, #0
   1adaa:	4699      	mov	r9, r3
   1adac:	e7a2      	b.n	1acf4 <vvprintf+0x420>
        else if (flagPlus)
   1adae:	464b      	mov	r3, r9
   1adb0:	9303      	str	r3, [sp, #12]
   1adb2:	9b05      	ldr	r3, [sp, #20]
   1adb4:	2b00      	cmp	r3, #0
   1adb6:	d0b2      	beq.n	1ad1e <vvprintf+0x44a>
            work[x++] = '+';
   1adb8:	464b      	mov	r3, r9
   1adba:	3301      	adds	r3, #1
   1adbc:	9303      	str	r3, [sp, #12]
   1adbe:	232b      	movs	r3, #43	; 0x2b
   1adc0:	aa0c      	add	r2, sp, #48	; 0x30
   1adc2:	4649      	mov	r1, r9
   1adc4:	5453      	strb	r3, [r2, r1]
   1adc6:	e7aa      	b.n	1ad1e <vvprintf+0x44a>
                y++;
   1adc8:	3101      	adds	r1, #1
            while (y < width)
   1adca:	42b9      	cmp	r1, r7
   1adcc:	d009      	beq.n	1ade2 <vvprintf+0x50e>
                outch(fillCh, extraCh);
   1adce:	2b00      	cmp	r3, #0
   1add0:	d0fa      	beq.n	1adc8 <vvprintf+0x4f4>
   1add2:	1c54      	adds	r4, r2, #1
   1add4:	7015      	strb	r5, [r2, #0]
   1add6:	1e58      	subs	r0, r3, #1
   1add8:	0022      	movs	r2, r4
   1adda:	1cc6      	adds	r6, r0, #3
   1addc:	d8f4      	bhi.n	1adc8 <vvprintf+0x4f4>
   1adde:	0003      	movs	r3, r0
   1ade0:	e7f2      	b.n	1adc8 <vvprintf+0x4f4>
   1ade2:	9301      	str	r3, [sp, #4]
   1ade4:	4664      	mov	r4, ip
   1ade6:	46ac      	mov	ip, r5
   1ade8:	4645      	mov	r5, r8
   1adea:	464e      	mov	r6, r9
   1adec:	9803      	ldr	r0, [sp, #12]
   1adee:	1a08      	subs	r0, r1, r0
   1adf0:	9005      	str	r0, [sp, #20]
   1adf2:	e004      	b.n	1adfe <vvprintf+0x52a>
        y = x;
   1adf4:	9903      	ldr	r1, [sp, #12]
        if (!flagMinus)
   1adf6:	9601      	str	r6, [sp, #4]
   1adf8:	9a00      	ldr	r2, [sp, #0]
    int extraCh = 0;
   1adfa:	2000      	movs	r0, #0
   1adfc:	9005      	str	r0, [sp, #20]
        if (flagHash && (toupper((unsigned char)specifier) == 'X'))
   1adfe:	9804      	ldr	r0, [sp, #16]
   1ae00:	2800      	cmp	r0, #0
   1ae02:	d00e      	beq.n	1ae22 <vvprintf+0x54e>
   1ae04:	48bc      	ldr	r0, [pc, #752]	; (1b0f8 <vvprintf+0x824>)
   1ae06:	6803      	ldr	r3, [r0, #0]
   1ae08:	9808      	ldr	r0, [sp, #32]
   1ae0a:	4680      	mov	r8, r0
   1ae0c:	4443      	add	r3, r8
   1ae0e:	7858      	ldrb	r0, [r3, #1]
   1ae10:	4680      	mov	r8, r0
   1ae12:	2003      	movs	r0, #3
   1ae14:	4643      	mov	r3, r8
   1ae16:	4018      	ands	r0, r3
   1ae18:	2802      	cmp	r0, #2
   1ae1a:	d010      	beq.n	1ae3e <vvprintf+0x56a>
   1ae1c:	465b      	mov	r3, fp
   1ae1e:	2b58      	cmp	r3, #88	; 0x58
   1ae20:	d013      	beq.n	1ae4a <vvprintf+0x576>
        while (x >= 0)
   1ae22:	9803      	ldr	r0, [sp, #12]
   1ae24:	3801      	subs	r0, #1
   1ae26:	d456      	bmi.n	1aed6 <vvprintf+0x602>
            outch(work[x], extraCh);
   1ae28:	4688      	mov	r8, r1
   1ae2a:	9b01      	ldr	r3, [sp, #4]
   1ae2c:	46a1      	mov	r9, r4
   1ae2e:	46ab      	mov	fp, r5
   1ae30:	e02e      	b.n	1ae90 <vvprintf+0x5bc>
        y = x;
   1ae32:	9903      	ldr	r1, [sp, #12]
    int extraCh = 0;
   1ae34:	9b02      	ldr	r3, [sp, #8]
   1ae36:	9305      	str	r3, [sp, #20]
            while (y < width)
   1ae38:	9601      	str	r6, [sp, #4]
   1ae3a:	9a00      	ldr	r2, [sp, #0]
   1ae3c:	e7df      	b.n	1adfe <vvprintf+0x52a>
        if (flagHash && (toupper((unsigned char)specifier) == 'X'))
   1ae3e:	9b08      	ldr	r3, [sp, #32]
   1ae40:	3822      	subs	r0, #34	; 0x22
   1ae42:	4680      	mov	r8, r0
   1ae44:	4443      	add	r3, r8
   1ae46:	469b      	mov	fp, r3
   1ae48:	e7e8      	b.n	1ae1c <vvprintf+0x548>
            outch('0', extraCh);
   1ae4a:	9b01      	ldr	r3, [sp, #4]
   1ae4c:	2b00      	cmp	r3, #0
   1ae4e:	d100      	bne.n	1ae52 <vvprintf+0x57e>
   1ae50:	e13f      	b.n	1b0d2 <vvprintf+0x7fe>
   1ae52:	1c53      	adds	r3, r2, #1
   1ae54:	4699      	mov	r9, r3
   1ae56:	2030      	movs	r0, #48	; 0x30
   1ae58:	7010      	strb	r0, [r2, #0]
   1ae5a:	9b01      	ldr	r3, [sp, #4]
   1ae5c:	1e58      	subs	r0, r3, #1
   1ae5e:	1cc3      	adds	r3, r0, #3
   1ae60:	d80f      	bhi.n	1ae82 <vvprintf+0x5ae>
            outch('x', extraCh);
   1ae62:	2800      	cmp	r0, #0
   1ae64:	d100      	bne.n	1ae68 <vvprintf+0x594>
   1ae66:	e133      	b.n	1b0d0 <vvprintf+0x7fc>
   1ae68:	1c93      	adds	r3, r2, #2
   1ae6a:	9304      	str	r3, [sp, #16]
   1ae6c:	2378      	movs	r3, #120	; 0x78
   1ae6e:	7053      	strb	r3, [r2, #1]
   1ae70:	9b05      	ldr	r3, [sp, #20]
   1ae72:	3302      	adds	r3, #2
   1ae74:	9305      	str	r3, [sp, #20]
   1ae76:	1e43      	subs	r3, r0, #1
   1ae78:	9301      	str	r3, [sp, #4]
   1ae7a:	3303      	adds	r3, #3
   1ae7c:	d803      	bhi.n	1ae86 <vvprintf+0x5b2>
   1ae7e:	9a04      	ldr	r2, [sp, #16]
   1ae80:	e7cf      	b.n	1ae22 <vvprintf+0x54e>
            outch('0', extraCh);
   1ae82:	9801      	ldr	r0, [sp, #4]
   1ae84:	e7f0      	b.n	1ae68 <vvprintf+0x594>
            outch('x', extraCh);
   1ae86:	9001      	str	r0, [sp, #4]
   1ae88:	9a04      	ldr	r2, [sp, #16]
   1ae8a:	e7ca      	b.n	1ae22 <vvprintf+0x54e>
        while (x >= 0)
   1ae8c:	3801      	subs	r0, #1
   1ae8e:	d30b      	bcc.n	1aea8 <vvprintf+0x5d4>
            outch(work[x], extraCh);
   1ae90:	2b00      	cmp	r3, #0
   1ae92:	d0fb      	beq.n	1ae8c <vvprintf+0x5b8>
   1ae94:	1c54      	adds	r4, r2, #1
   1ae96:	a90c      	add	r1, sp, #48	; 0x30
   1ae98:	5c41      	ldrb	r1, [r0, r1]
   1ae9a:	7011      	strb	r1, [r2, #0]
   1ae9c:	1e59      	subs	r1, r3, #1
   1ae9e:	0022      	movs	r2, r4
   1aea0:	1ccd      	adds	r5, r1, #3
   1aea2:	d8f3      	bhi.n	1ae8c <vvprintf+0x5b8>
   1aea4:	000b      	movs	r3, r1
   1aea6:	e7f1      	b.n	1ae8c <vvprintf+0x5b8>
   1aea8:	4641      	mov	r1, r8
   1aeaa:	9301      	str	r3, [sp, #4]
   1aeac:	464c      	mov	r4, r9
   1aeae:	465d      	mov	r5, fp
   1aeb0:	9803      	ldr	r0, [sp, #12]
   1aeb2:	4683      	mov	fp, r0
   1aeb4:	9805      	ldr	r0, [sp, #20]
   1aeb6:	4680      	mov	r8, r0
   1aeb8:	44c3      	add	fp, r8
        if (flagMinus)
   1aeba:	9802      	ldr	r0, [sp, #8]
   1aebc:	2800      	cmp	r0, #0
   1aebe:	d020      	beq.n	1af02 <vvprintf+0x62e>
            while (y < width)
   1aec0:	428f      	cmp	r7, r1
   1aec2:	dd1e      	ble.n	1af02 <vvprintf+0x62e>
   1aec4:	0008      	movs	r0, r1
   1aec6:	9b01      	ldr	r3, [sp, #4]
   1aec8:	46a0      	mov	r8, r4
   1aeca:	003c      	movs	r4, r7
   1aecc:	46a9      	mov	r9, r5
   1aece:	4665      	mov	r5, ip
   1aed0:	468c      	mov	ip, r1
   1aed2:	9601      	str	r6, [sp, #4]
   1aed4:	e005      	b.n	1aee2 <vvprintf+0x60e>
        while (x >= 0)
   1aed6:	9b05      	ldr	r3, [sp, #20]
   1aed8:	469b      	mov	fp, r3
   1aeda:	e7ee      	b.n	1aeba <vvprintf+0x5e6>
                y++;
   1aedc:	3001      	adds	r0, #1
            while (y < width)
   1aede:	4284      	cmp	r4, r0
   1aee0:	d009      	beq.n	1aef6 <vvprintf+0x622>
                outch(fillCh, extraCh);
   1aee2:	2b00      	cmp	r3, #0
   1aee4:	d0fa      	beq.n	1aedc <vvprintf+0x608>
   1aee6:	1c51      	adds	r1, r2, #1
   1aee8:	7015      	strb	r5, [r2, #0]
   1aeea:	1e5f      	subs	r7, r3, #1
   1aeec:	000a      	movs	r2, r1
   1aeee:	1cfe      	adds	r6, r7, #3
   1aef0:	d8f4      	bhi.n	1aedc <vvprintf+0x608>
   1aef2:	003b      	movs	r3, r7
   1aef4:	e7f2      	b.n	1aedc <vvprintf+0x608>
   1aef6:	4661      	mov	r1, ip
   1aef8:	4644      	mov	r4, r8
   1aefa:	464d      	mov	r5, r9
   1aefc:	9e01      	ldr	r6, [sp, #4]
   1aefe:	1a41      	subs	r1, r0, r1
   1af00:	448b      	add	fp, r1
            {
                int extraCh;

                extraCh = examine(&format, s, &arg, maxlen);

                chcount += extraCh;
   1af02:	445c      	add	r4, fp
                if (maxlen != STDIO_STRING_UNLIMITED)
   1af04:	1c73      	adds	r3, r6, #1
   1af06:	d004      	beq.n	1af12 <vvprintf+0x63e>
                    maxlen -= min((size_t)extraCh, maxlen);
   1af08:	465b      	mov	r3, fp
   1af0a:	45b3      	cmp	fp, r6
   1af0c:	d900      	bls.n	1af10 <vvprintf+0x63c>
   1af0e:	0033      	movs	r3, r6
   1af10:	1af6      	subs	r6, r6, r3

                if (s != NULL)
   1af12:	9b00      	ldr	r3, [sp, #0]
   1af14:	2b00      	cmp	r3, #0
   1af16:	d100      	bne.n	1af1a <vvprintf+0x646>
   1af18:	e0f1      	b.n	1b0fe <vvprintf+0x82a>
                {
                    s += extraCh;
   1af1a:	445b      	add	r3, fp
   1af1c:	9300      	str	r3, [sp, #0]
   1af1e:	e0ee      	b.n	1b0fe <vvprintf+0x82a>
    else if (specifier == 's')
   1af20:	465b      	mov	r3, fp
   1af22:	2b73      	cmp	r3, #115	; 0x73
   1af24:	d000      	beq.n	1af28 <vvprintf+0x654>
   1af26:	e09b      	b.n	1b060 <vvprintf+0x78c>
        svalue = va_arg(*arg, char *);
   1af28:	4653      	mov	r3, sl
   1af2a:	3304      	adds	r3, #4
   1af2c:	9303      	str	r3, [sp, #12]
   1af2e:	4653      	mov	r3, sl
   1af30:	681b      	ldr	r3, [r3, #0]
   1af32:	4699      	mov	r9, r3
        if (precision > 0)
   1af34:	4643      	mov	r3, r8
   1af36:	2b00      	cmp	r3, #0
   1af38:	dc11      	bgt.n	1af5e <vvprintf+0x68a>
        else if (precision < 0)
   1af3a:	db2e      	blt.n	1af9a <vvprintf+0x6c6>
            length = 0;
   1af3c:	9b02      	ldr	r3, [sp, #8]
   1af3e:	4698      	mov	r8, r3
        if (!flagMinus)
   1af40:	2b00      	cmp	r3, #0
   1af42:	d000      	beq.n	1af46 <vvprintf+0x672>
   1af44:	e0fd      	b.n	1b142 <vvprintf+0x86e>
            if (length < width)
   1af46:	4547      	cmp	r7, r8
   1af48:	dc3b      	bgt.n	1afc2 <vvprintf+0x6ee>
   1af4a:	0032      	movs	r2, r6
   1af4c:	9900      	ldr	r1, [sp, #0]
    int extraCh = 0;
   1af4e:	2000      	movs	r0, #0
        for (x = 0; x < length; x++)
   1af50:	4643      	mov	r3, r8
   1af52:	2b00      	cmp	r3, #0
   1af54:	dc18      	bgt.n	1af88 <vvprintf+0x6b4>
        svalue = va_arg(*arg, char *);
   1af56:	9b03      	ldr	r3, [sp, #12]
   1af58:	469a      	mov	sl, r3
        for (x = 0; x < length; x++)
   1af5a:	4683      	mov	fp, r0
   1af5c:	e7d1      	b.n	1af02 <vvprintf+0x62e>
            p = memchr(svalue, '\0', precision);
   1af5e:	4642      	mov	r2, r8
   1af60:	2100      	movs	r1, #0
   1af62:	4648      	mov	r0, r9
   1af64:	f000 f9a0 	bl	1b2a8 <memchr>
            if (p != NULL)
   1af68:	2800      	cmp	r0, #0
   1af6a:	d100      	bne.n	1af6e <vvprintf+0x69a>
   1af6c:	e0ef      	b.n	1b14e <vvprintf+0x87a>
                length = (int)(p - svalue);
   1af6e:	464b      	mov	r3, r9
   1af70:	1ac3      	subs	r3, r0, r3
   1af72:	4698      	mov	r8, r3
        if (!flagMinus)
   1af74:	9b02      	ldr	r3, [sp, #8]
   1af76:	2b00      	cmp	r3, #0
   1af78:	d0e5      	beq.n	1af46 <vvprintf+0x672>
        for (x = 0; x < length; x++)
   1af7a:	4643      	mov	r3, r8
   1af7c:	2b00      	cmp	r3, #0
   1af7e:	dc00      	bgt.n	1af82 <vvprintf+0x6ae>
   1af80:	e0ad      	b.n	1b0de <vvprintf+0x80a>
   1af82:	9900      	ldr	r1, [sp, #0]
   1af84:	0032      	movs	r2, r6
    int extraCh = 0;
   1af86:	2000      	movs	r0, #0
   1af88:	2300      	movs	r3, #0
   1af8a:	3001      	adds	r0, #1
   1af8c:	46bc      	mov	ip, r7
   1af8e:	4647      	mov	r7, r8
   1af90:	9701      	str	r7, [sp, #4]
   1af92:	46a0      	mov	r8, r4
   1af94:	46aa      	mov	sl, r5
   1af96:	46b3      	mov	fp, r6
   1af98:	e024      	b.n	1afe4 <vvprintf+0x710>
            length = strlen(svalue);
   1af9a:	4648      	mov	r0, r9
   1af9c:	f000 f9ff 	bl	1b39e <strlen>
   1afa0:	4680      	mov	r8, r0
   1afa2:	e7e7      	b.n	1af74 <vvprintf+0x6a0>
   1afa4:	3301      	adds	r3, #1
                for (x = 0; x < (width - length); x++)
   1afa6:	4283      	cmp	r3, r0
   1afa8:	db00      	blt.n	1afac <vvprintf+0x6d8>
   1afaa:	e09d      	b.n	1b0e8 <vvprintf+0x814>
                    outch(fillCh, extraCh);
   1afac:	2a00      	cmp	r2, #0
   1afae:	d0f9      	beq.n	1afa4 <vvprintf+0x6d0>
   1afb0:	1c4d      	adds	r5, r1, #1
   1afb2:	4654      	mov	r4, sl
   1afb4:	700c      	strb	r4, [r1, #0]
   1afb6:	1e54      	subs	r4, r2, #1
   1afb8:	0029      	movs	r1, r5
   1afba:	1ce6      	adds	r6, r4, #3
   1afbc:	d8f2      	bhi.n	1afa4 <vvprintf+0x6d0>
   1afbe:	0022      	movs	r2, r4
   1afc0:	e7f0      	b.n	1afa4 <vvprintf+0x6d0>
            if (length < width)
   1afc2:	0032      	movs	r2, r6
   1afc4:	9900      	ldr	r1, [sp, #0]
   1afc6:	2300      	movs	r3, #0
   1afc8:	469c      	mov	ip, r3
                for (x = 0; x < (width - length); x++)
   1afca:	4640      	mov	r0, r8
   1afcc:	1a38      	subs	r0, r7, r0
                    outch(fillCh, extraCh);
   1afce:	3320      	adds	r3, #32
   1afd0:	469a      	mov	sl, r3
   1afd2:	4663      	mov	r3, ip
   1afd4:	46a4      	mov	ip, r4
   1afd6:	46ab      	mov	fp, r5
   1afd8:	9601      	str	r6, [sp, #4]
   1afda:	e7e4      	b.n	1afa6 <vvprintf+0x6d2>
        for (x = 0; x < length; x++)
   1afdc:	3301      	adds	r3, #1
   1afde:	9d01      	ldr	r5, [sp, #4]
   1afe0:	42ab      	cmp	r3, r5
   1afe2:	da0d      	bge.n	1b000 <vvprintf+0x72c>
   1afe4:	18c4      	adds	r4, r0, r3
            outch(svalue[x], extraCh);
   1afe6:	2a00      	cmp	r2, #0
   1afe8:	d0f8      	beq.n	1afdc <vvprintf+0x708>
   1afea:	1c4e      	adds	r6, r1, #1
   1afec:	464c      	mov	r4, r9
   1afee:	5ce4      	ldrb	r4, [r4, r3]
   1aff0:	700c      	strb	r4, [r1, #0]
   1aff2:	18c4      	adds	r4, r0, r3
   1aff4:	1e55      	subs	r5, r2, #1
   1aff6:	0031      	movs	r1, r6
   1aff8:	1cef      	adds	r7, r5, #3
   1affa:	d8ef      	bhi.n	1afdc <vvprintf+0x708>
   1affc:	002a      	movs	r2, r5
   1affe:	e7ed      	b.n	1afdc <vvprintf+0x708>
   1b000:	4655      	mov	r5, sl
   1b002:	465e      	mov	r6, fp
   1b004:	46a3      	mov	fp, r4
   1b006:	4644      	mov	r4, r8
   1b008:	9b01      	ldr	r3, [sp, #4]
   1b00a:	4698      	mov	r8, r3
   1b00c:	4667      	mov	r7, ip
        if (flagMinus)
   1b00e:	9b02      	ldr	r3, [sp, #8]
   1b010:	2b00      	cmp	r3, #0
   1b012:	d028      	beq.n	1b066 <vvprintf+0x792>
        svalue = va_arg(*arg, char *);
   1b014:	9b03      	ldr	r3, [sp, #12]
   1b016:	469a      	mov	sl, r3
            if (length < width)
   1b018:	4547      	cmp	r7, r8
   1b01a:	dc00      	bgt.n	1b01e <vvprintf+0x74a>
   1b01c:	e771      	b.n	1af02 <vvprintf+0x62e>
                for (x = 0; x < (width - length); x++)
   1b01e:	4643      	mov	r3, r8
   1b020:	1afb      	subs	r3, r7, r3
   1b022:	4698      	mov	r8, r3
   1b024:	2b00      	cmp	r3, #0
   1b026:	dd21      	ble.n	1b06c <vvprintf+0x798>
   1b028:	2300      	movs	r3, #0
                    outch(fillCh, extraCh);
   1b02a:	2020      	movs	r0, #32
   1b02c:	4684      	mov	ip, r0
   1b02e:	0020      	movs	r0, r4
   1b030:	4644      	mov	r4, r8
   1b032:	46a9      	mov	r9, r5
   1b034:	4680      	mov	r8, r0
   1b036:	e002      	b.n	1b03e <vvprintf+0x76a>
                for (x = 0; x < (width - length); x++)
   1b038:	3301      	adds	r3, #1
   1b03a:	42a3      	cmp	r3, r4
   1b03c:	d00a      	beq.n	1b054 <vvprintf+0x780>
                    outch(fillCh, extraCh);
   1b03e:	2a00      	cmp	r2, #0
   1b040:	d0fa      	beq.n	1b038 <vvprintf+0x764>
   1b042:	1c4f      	adds	r7, r1, #1
   1b044:	4660      	mov	r0, ip
   1b046:	7008      	strb	r0, [r1, #0]
   1b048:	1e50      	subs	r0, r2, #1
   1b04a:	0039      	movs	r1, r7
   1b04c:	1cc5      	adds	r5, r0, #3
   1b04e:	d8f3      	bhi.n	1b038 <vvprintf+0x764>
   1b050:	0002      	movs	r2, r0
   1b052:	e7f1      	b.n	1b038 <vvprintf+0x764>
   1b054:	4644      	mov	r4, r8
   1b056:	464d      	mov	r5, r9
   1b058:	449b      	add	fp, r3
        svalue = va_arg(*arg, char *);
   1b05a:	9b03      	ldr	r3, [sp, #12]
   1b05c:	469a      	mov	sl, r3
   1b05e:	e750      	b.n	1af02 <vvprintf+0x62e>
    int extraCh = 0;
   1b060:	2300      	movs	r3, #0
   1b062:	469b      	mov	fp, r3
   1b064:	e74d      	b.n	1af02 <vvprintf+0x62e>
        svalue = va_arg(*arg, char *);
   1b066:	9b03      	ldr	r3, [sp, #12]
   1b068:	469a      	mov	sl, r3
   1b06a:	e74a      	b.n	1af02 <vvprintf+0x62e>
   1b06c:	9b03      	ldr	r3, [sp, #12]
   1b06e:	469a      	mov	sl, r3
   1b070:	e747      	b.n	1af02 <vvprintf+0x62e>
                vint = va_arg(arg, int);
   1b072:	469a      	mov	sl, r3
            format++;
   1b074:	464d      	mov	r5, r9
                outch(vint, chcount);
   1b076:	9100      	str	r1, [sp, #0]
   1b078:	e041      	b.n	1b0fe <vvprintf+0x82a>
            format++;
   1b07a:	464d      	mov	r5, r9
                outch('%', chcount);
   1b07c:	9200      	str	r2, [sp, #0]
   1b07e:	e03e      	b.n	1b0fe <vvprintf+0x82a>
                s += len;
   1b080:	9b00      	ldr	r3, [sp, #0]
   1b082:	469c      	mov	ip, r3
   1b084:	44ac      	add	ip, r5
   1b086:	4663      	mov	r3, ip
   1b088:	9300      	str	r3, [sp, #0]
                chcount += len;
   1b08a:	1964      	adds	r4, r4, r5
                    maxlen -= copy_len;
   1b08c:	4653      	mov	r3, sl
   1b08e:	1af6      	subs	r6, r6, r3
                vcptr = va_arg(arg, const char *);
   1b090:	46c2      	mov	sl, r8
            format++;
   1b092:	464d      	mov	r5, r9
   1b094:	e033      	b.n	1b0fe <vvprintf+0x82a>
                outch(vint, chcount);
   1b096:	3401      	adds	r4, #1
                vint = va_arg(arg, int);
   1b098:	469a      	mov	sl, r3
            format++;
   1b09a:	464d      	mov	r5, r9
   1b09c:	e02f      	b.n	1b0fe <vvprintf+0x82a>
                outch('%', chcount);
   1b09e:	3401      	adds	r4, #1
            format++;
   1b0a0:	464d      	mov	r5, r9
   1b0a2:	e02c      	b.n	1b0fe <vvprintf+0x82a>
            base = 16;
   1b0a4:	2310      	movs	r3, #16
   1b0a6:	469c      	mov	ip, r3
        if (lng != 2) {
   1b0a8:	9a03      	ldr	r2, [sp, #12]
   1b0aa:	2a02      	cmp	r2, #2
   1b0ac:	d100      	bne.n	1b0b0 <vvprintf+0x7dc>
   1b0ae:	e5d9      	b.n	1ac64 <vvprintf+0x390>
            while (ulvalue > 0)
   1b0b0:	1e0a      	subs	r2, r1, #0
   1b0b2:	d100      	bne.n	1b0b6 <vvprintf+0x7e2>
   1b0b4:	e678      	b.n	1ada8 <vvprintf+0x4d4>
        x = 0;
   1b0b6:	2100      	movs	r1, #0
                rem = (int)(ulvalue % base);
   1b0b8:	4663      	mov	r3, ip
   1b0ba:	9303      	str	r3, [sp, #12]
                        work[x] = (char)('A' + (rem - 10));
   1b0bc:	4653      	mov	r3, sl
   1b0be:	9306      	str	r3, [sp, #24]
   1b0c0:	46aa      	mov	sl, r5
   1b0c2:	000d      	movs	r5, r1
   1b0c4:	46a1      	mov	r9, r4
   1b0c6:	0014      	movs	r4, r2
   1b0c8:	0033      	movs	r3, r6
   1b0ca:	465e      	mov	r6, fp
   1b0cc:	469b      	mov	fp, r3
   1b0ce:	e5f6      	b.n	1acbe <vvprintf+0x3ea>
            outch('0', extraCh);
   1b0d0:	464a      	mov	r2, r9
            outch('x', extraCh);
   1b0d2:	9b05      	ldr	r3, [sp, #20]
   1b0d4:	3302      	adds	r3, #2
   1b0d6:	9305      	str	r3, [sp, #20]
   1b0d8:	2300      	movs	r3, #0
   1b0da:	9301      	str	r3, [sp, #4]
   1b0dc:	e6a1      	b.n	1ae22 <vvprintf+0x54e>
        for (x = 0; x < length; x++)
   1b0de:	9900      	ldr	r1, [sp, #0]
   1b0e0:	0032      	movs	r2, r6
    int extraCh = 0;
   1b0e2:	2300      	movs	r3, #0
   1b0e4:	469b      	mov	fp, r3
   1b0e6:	e795      	b.n	1b014 <vvprintf+0x740>
   1b0e8:	4664      	mov	r4, ip
   1b0ea:	465d      	mov	r5, fp
   1b0ec:	9e01      	ldr	r6, [sp, #4]
   1b0ee:	43c3      	mvns	r3, r0
   1b0f0:	17db      	asrs	r3, r3, #31
   1b0f2:	4018      	ands	r0, r3
   1b0f4:	e72c      	b.n	1af50 <vvprintf+0x67c>
   1b0f6:	46c0      	nop			; (mov r8, r8)
   1b0f8:	010005dc 	.word	0x010005dc
                }
            }
        }
        else
        {
            outch(*format, chcount);
   1b0fc:	3401      	adds	r4, #1
        }
        format++;
   1b0fe:	3501      	adds	r5, #1
        if (*format == '\0')
   1b100:	782b      	ldrb	r3, [r5, #0]
   1b102:	2b00      	cmp	r3, #0
   1b104:	d02b      	beq.n	1b15e <vvprintf+0x88a>
        else if (*format == '%')
   1b106:	2b25      	cmp	r3, #37	; 0x25
   1b108:	d101      	bne.n	1b10e <vvprintf+0x83a>
   1b10a:	f7ff fbf2 	bl	1a8f2 <vvprintf+0x1e>
            outch(*format, chcount);
   1b10e:	2e00      	cmp	r6, #0
   1b110:	d0f4      	beq.n	1b0fc <vvprintf+0x828>
   1b112:	9900      	ldr	r1, [sp, #0]
   1b114:	1c4a      	adds	r2, r1, #1
   1b116:	700b      	strb	r3, [r1, #0]
   1b118:	3401      	adds	r4, #1
   1b11a:	1e73      	subs	r3, r6, #1
   1b11c:	9200      	str	r2, [sp, #0]
   1b11e:	1cd9      	adds	r1, r3, #3
   1b120:	d8ed      	bhi.n	1b0fe <vvprintf+0x82a>
   1b122:	001e      	movs	r6, r3
   1b124:	e7eb      	b.n	1b0fe <vvprintf+0x82a>
                    memcpy(s, vcptr, copy_len);
   1b126:	0002      	movs	r2, r0
   1b128:	0039      	movs	r1, r7
   1b12a:	9f00      	ldr	r7, [sp, #0]
   1b12c:	0038      	movs	r0, r7
   1b12e:	f7e5 f85f 	bl	1f0 <memcpy>
                s += len;
   1b132:	46bc      	mov	ip, r7
   1b134:	44ac      	add	ip, r5
   1b136:	4663      	mov	r3, ip
   1b138:	9300      	str	r3, [sp, #0]
                chcount += len;
   1b13a:	1964      	adds	r4, r4, r5
                vcptr = va_arg(arg, const char *);
   1b13c:	46c2      	mov	sl, r8
            format++;
   1b13e:	464d      	mov	r5, r9
   1b140:	e7dd      	b.n	1b0fe <vvprintf+0x82a>
        if (!flagMinus)
   1b142:	9900      	ldr	r1, [sp, #0]
   1b144:	0032      	movs	r2, r6
            length = 0;
   1b146:	2300      	movs	r3, #0
   1b148:	4698      	mov	r8, r3
    int extraCh = 0;
   1b14a:	469b      	mov	fp, r3
   1b14c:	e762      	b.n	1b014 <vvprintf+0x740>
        if (!flagMinus)
   1b14e:	9b02      	ldr	r3, [sp, #8]
   1b150:	2b00      	cmp	r3, #0
   1b152:	d100      	bne.n	1b156 <vvprintf+0x882>
   1b154:	e6f7      	b.n	1af46 <vvprintf+0x672>
   1b156:	9900      	ldr	r1, [sp, #0]
   1b158:	0032      	movs	r2, r6
    int extraCh = 0;
   1b15a:	2000      	movs	r0, #0
   1b15c:	e714      	b.n	1af88 <vvprintf+0x6b4>
    }
    return (chcount);
}
   1b15e:	0020      	movs	r0, r4
   1b160:	b027      	add	sp, #156	; 0x9c
   1b162:	bc3c      	pop	{r2, r3, r4, r5}
   1b164:	4690      	mov	r8, r2
   1b166:	4699      	mov	r9, r3
   1b168:	46a2      	mov	sl, r4
   1b16a:	46ab      	mov	fp, r5
   1b16c:	bdf0      	pop	{r4, r5, r6, r7, pc}
   1b16e:	46c0      	nop			; (mov r8, r8)

0001b170 <abs>:
{
    if (j < 0)
    {
        j = -j;
    }
    return (j);
   1b170:	17c3      	asrs	r3, r0, #31
   1b172:	18c0      	adds	r0, r0, r3
   1b174:	4058      	eors	r0, r3
}
   1b176:	4770      	bx	lr

0001b178 <atoi>:
 */

#include "stdlib_private.h"

__PDPCLIB_API__ int atoi(const char *nptr)
{
   1b178:	b510      	push	{r4, lr}
    return ((int)strtol(nptr, (char **)NULL, 10));
   1b17a:	220a      	movs	r2, #10
   1b17c:	2100      	movs	r1, #0
   1b17e:	f000 f80b 	bl	1b198 <strtol>
   1b182:	bd10      	pop	{r4, pc}

0001b184 <__exit>:
 * nlibc requires that __exit be defined.  As this is is really a call to
 * panic, but by a different name.
 * @param status Exit status. Gets converted to panic aaargh.
 */
void __exit(int status)
{
   1b184:	b510      	push	{r4, lr}
    UNUSED( status );
    panic(PANIC_EXIT, (uint16)status);
   1b186:	0401      	lsls	r1, r0, #16
   1b188:	0c09      	lsrs	r1, r1, #16
   1b18a:	2024      	movs	r0, #36	; 0x24
   1b18c:	f7e6 fcc0 	bl	1b10 <panic>
   1b190:	e7fe      	b.n	1b190 <__exit+0xc>

0001b192 <exit>:
{
   1b192:	b510      	push	{r4, lr}
    __exit(status);
   1b194:	f7ff fff6 	bl	1b184 <__exit>

0001b198 <strtol>:
 */

#include "stdlib_private.h"

__PDPCLIB_API__ long int strtol(const char *nptr, char **endptr, int base)
{
   1b198:	b570      	push	{r4, r5, r6, lr}
    unsigned long y;
    long x;
    int neg = 0;

    while (isspace((unsigned char)*nptr))
   1b19a:	4b0e      	ldr	r3, [pc, #56]	; (1b1d4 <strtol+0x3c>)
   1b19c:	681d      	ldr	r5, [r3, #0]
   1b19e:	7803      	ldrb	r3, [r0, #0]
   1b1a0:	18ec      	adds	r4, r5, r3
   1b1a2:	7864      	ldrb	r4, [r4, #1]
   1b1a4:	0724      	lsls	r4, r4, #28
   1b1a6:	d506      	bpl.n	1b1b6 <strtol+0x1e>
   1b1a8:	2608      	movs	r6, #8
    {
        nptr++;
   1b1aa:	3001      	adds	r0, #1
    while (isspace((unsigned char)*nptr))
   1b1ac:	7803      	ldrb	r3, [r0, #0]
   1b1ae:	18ec      	adds	r4, r5, r3
   1b1b0:	7864      	ldrb	r4, [r4, #1]
   1b1b2:	4226      	tst	r6, r4
   1b1b4:	d1f9      	bne.n	1b1aa <strtol+0x12>
    }
    if (*nptr == '-')
   1b1b6:	2b2d      	cmp	r3, #45	; 0x2d
   1b1b8:	d006      	beq.n	1b1c8 <strtol+0x30>
        neg = 1;
        nptr++;
    }
    else if (*nptr == '+')
    {
        nptr++;
   1b1ba:	3b2b      	subs	r3, #43	; 0x2b
   1b1bc:	425c      	negs	r4, r3
   1b1be:	4163      	adcs	r3, r4
   1b1c0:	18c0      	adds	r0, r0, r3
    }
    y = strtoul(nptr, endptr, base);
   1b1c2:	f000 f809 	bl	1b1d8 <strtoul>
    else
    {
        x = (long)y;
    }
    return (x);
}
   1b1c6:	bd70      	pop	{r4, r5, r6, pc}
        nptr++;
   1b1c8:	3001      	adds	r0, #1
    y = strtoul(nptr, endptr, base);
   1b1ca:	f000 f805 	bl	1b1d8 <strtoul>
        x = (long)-y;
   1b1ce:	4240      	negs	r0, r0
   1b1d0:	e7f9      	b.n	1b1c6 <strtol+0x2e>
   1b1d2:	46c0      	nop			; (mov r8, r8)
   1b1d4:	010005dc 	.word	0x010005dc

0001b1d8 <strtoul>:

/* this logic is also in vvscanf - if you update this, update
   that one too */

__PDPCLIB_API__ unsigned long int strtoul(const char *nptr, char **endptr, int base)
{
   1b1d8:	b5f0      	push	{r4, r5, r6, r7, lr}
   1b1da:	46de      	mov	lr, fp
   1b1dc:	4657      	mov	r7, sl
   1b1de:	464e      	mov	r6, r9
   1b1e0:	4645      	mov	r5, r8
   1b1e2:	b5e0      	push	{r5, r6, r7, lr}
   1b1e4:	b083      	sub	sp, #12
   1b1e6:	468a      	mov	sl, r1
    unsigned long x = 0;
    int undecided = 0;

    if (base == 0)
    {
        undecided = 1;
   1b1e8:	4251      	negs	r1, r2
   1b1ea:	4151      	adcs	r1, r2
   1b1ec:	9101      	str	r1, [sp, #4]
    }
    while (isspace((unsigned char)*nptr))
   1b1ee:	4b2d      	ldr	r3, [pc, #180]	; (1b2a4 <strtoul+0xcc>)
   1b1f0:	681e      	ldr	r6, [r3, #0]
   1b1f2:	7803      	ldrb	r3, [r0, #0]
   1b1f4:	18f3      	adds	r3, r6, r3
   1b1f6:	785b      	ldrb	r3, [r3, #1]
   1b1f8:	071b      	lsls	r3, r3, #28
   1b1fa:	d506      	bpl.n	1b20a <strtoul+0x32>
   1b1fc:	2408      	movs	r4, #8
    {
        nptr++;
   1b1fe:	3001      	adds	r0, #1
    while (isspace((unsigned char)*nptr))
   1b200:	7803      	ldrb	r3, [r0, #0]
   1b202:	18f3      	adds	r3, r6, r3
   1b204:	785b      	ldrb	r3, [r3, #1]
   1b206:	421c      	tst	r4, r3
   1b208:	d1f9      	bne.n	1b1fe <strtoul+0x26>
   1b20a:	0004      	movs	r4, r0
    unsigned long x = 0;
   1b20c:	2000      	movs	r0, #0
    }
    while (1)
    {
        if (isdigit((unsigned char)*nptr))
   1b20e:	2304      	movs	r3, #4
   1b210:	4698      	mov	r8, r3
   1b212:	3b01      	subs	r3, #1
   1b214:	4699      	mov	r9, r3
            x = x * base + (*nptr - '0');
            nptr++;
        }
        else if (isalpha((unsigned char)*nptr))
        {
            if ((*nptr == 'X') || (*nptr == 'x'))
   1b216:	2120      	movs	r1, #32
   1b218:	e00b      	b.n	1b232 <strtoul+0x5a>
            {
                if ((base == 0) || ((base == 8) && undecided))
                {
                    base = 16;
                    undecided = 0;
   1b21a:	9201      	str	r2, [sp, #4]
                    base = 16;
   1b21c:	2210      	movs	r2, #16
   1b21e:	e007      	b.n	1b230 <strtoul+0x58>
                    undecided = 0;
   1b220:	2300      	movs	r3, #0
   1b222:	9301      	str	r3, [sp, #4]
                    base = 16;
   1b224:	2210      	movs	r2, #16
   1b226:	e003      	b.n	1b230 <strtoul+0x58>
                    base = 8;
   1b228:	2208      	movs	r2, #8
            x = x * base + (*nptr - '0');
   1b22a:	4350      	muls	r0, r2
   1b22c:	3b30      	subs	r3, #48	; 0x30
   1b22e:	1818      	adds	r0, r3, r0
   1b230:	3401      	adds	r4, #1
   1b232:	9400      	str	r4, [sp, #0]
        if (isdigit((unsigned char)*nptr))
   1b234:	7823      	ldrb	r3, [r4, #0]
   1b236:	18f5      	adds	r5, r6, r3
   1b238:	786d      	ldrb	r5, [r5, #1]
   1b23a:	4647      	mov	r7, r8
   1b23c:	422f      	tst	r7, r5
   1b23e:	d006      	beq.n	1b24e <strtoul+0x76>
            if (base == 0)
   1b240:	2a00      	cmp	r2, #0
   1b242:	d1f2      	bne.n	1b22a <strtoul+0x52>
                if (*nptr == '0')
   1b244:	2b30      	cmp	r3, #48	; 0x30
   1b246:	d0ef      	beq.n	1b228 <strtoul+0x50>
                    undecided = 0;
   1b248:	9201      	str	r2, [sp, #4]
                    base = 10;
   1b24a:	320a      	adds	r2, #10
   1b24c:	e7ed      	b.n	1b22a <strtoul+0x52>
   1b24e:	464f      	mov	r7, r9
   1b250:	403d      	ands	r5, r7
        else if (isalpha((unsigned char)*nptr))
   1b252:	d016      	beq.n	1b282 <strtoul+0xaa>
            if ((*nptr == 'X') || (*nptr == 'x'))
   1b254:	001f      	movs	r7, r3
   1b256:	438f      	bics	r7, r1
   1b258:	2f58      	cmp	r7, #88	; 0x58
   1b25a:	d008      	beq.n	1b26e <strtoul+0x96>
                else
                {
                    break;
                }
            }
            else if (base <= 10)
   1b25c:	2a0a      	cmp	r2, #10
   1b25e:	dd10      	ble.n	1b282 <strtoul+0xaa>
            {
                break;
            }
            else
            {
                x = x * base + (toupper((unsigned char)*nptr) - 'A') + 10;
   1b260:	4350      	muls	r0, r2
   1b262:	469c      	mov	ip, r3
   1b264:	2d02      	cmp	r5, #2
   1b266:	d018      	beq.n	1b29a <strtoul+0xc2>
   1b268:	3837      	subs	r0, #55	; 0x37
   1b26a:	4460      	add	r0, ip
   1b26c:	e7e0      	b.n	1b230 <strtoul+0x58>
                if ((base == 0) || ((base == 8) && undecided))
   1b26e:	2a00      	cmp	r2, #0
   1b270:	d0d3      	beq.n	1b21a <strtoul+0x42>
   1b272:	2a08      	cmp	r2, #8
   1b274:	d002      	beq.n	1b27c <strtoul+0xa4>
                else if (base == 16)
   1b276:	2a10      	cmp	r2, #16
   1b278:	d0da      	beq.n	1b230 <strtoul+0x58>
   1b27a:	e002      	b.n	1b282 <strtoul+0xaa>
                if ((base == 0) || ((base == 8) && undecided))
   1b27c:	9b01      	ldr	r3, [sp, #4]
   1b27e:	2b00      	cmp	r3, #0
   1b280:	d1ce      	bne.n	1b220 <strtoul+0x48>
        else
        {
            break;
        }
    }
    if (endptr != NULL)
   1b282:	4653      	mov	r3, sl
   1b284:	2b00      	cmp	r3, #0
   1b286:	d001      	beq.n	1b28c <strtoul+0xb4>
    {
        *endptr = (char *)nptr;
   1b288:	9a00      	ldr	r2, [sp, #0]
   1b28a:	601a      	str	r2, [r3, #0]
    }
    return (x);
}
   1b28c:	b003      	add	sp, #12
   1b28e:	bc3c      	pop	{r2, r3, r4, r5}
   1b290:	4690      	mov	r8, r2
   1b292:	4699      	mov	r9, r3
   1b294:	46a2      	mov	sl, r4
   1b296:	46ab      	mov	fp, r5
   1b298:	bdf0      	pop	{r4, r5, r6, r7, pc}
                x = x * base + (toupper((unsigned char)*nptr) - 'A') + 10;
   1b29a:	3d22      	subs	r5, #34	; 0x22
   1b29c:	46ac      	mov	ip, r5
   1b29e:	449c      	add	ip, r3
   1b2a0:	e7e2      	b.n	1b268 <strtoul+0x90>
   1b2a2:	46c0      	nop			; (mov r8, r8)
   1b2a4:	010005dc 	.word	0x010005dc

0001b2a8 <memchr>:
{
    const unsigned char *p;
    size_t x = 0;

    p = (const unsigned char *)s;
    while (x < n)
   1b2a8:	2a00      	cmp	r2, #0
   1b2aa:	d00d      	beq.n	1b2c8 <memchr+0x20>
    {
        if (*p == (unsigned char)c) return ((void *)p);
   1b2ac:	b2c9      	uxtb	r1, r1
   1b2ae:	7803      	ldrb	r3, [r0, #0]
   1b2b0:	428b      	cmp	r3, r1
   1b2b2:	d008      	beq.n	1b2c6 <memchr+0x1e>
   1b2b4:	1882      	adds	r2, r0, r2
        p++;
   1b2b6:	3001      	adds	r0, #1
    while (x < n)
   1b2b8:	4282      	cmp	r2, r0
   1b2ba:	d003      	beq.n	1b2c4 <memchr+0x1c>
        if (*p == (unsigned char)c) return ((void *)p);
   1b2bc:	7803      	ldrb	r3, [r0, #0]
   1b2be:	428b      	cmp	r3, r1
   1b2c0:	d1f9      	bne.n	1b2b6 <memchr+0xe>
   1b2c2:	e000      	b.n	1b2c6 <memchr+0x1e>
        x++;
    }
    return (NULL);
   1b2c4:	2000      	movs	r0, #0
   1b2c6:	4770      	bx	lr
    return (NULL);
   1b2c8:	2000      	movs	r0, #0
   1b2ca:	e7fc      	b.n	1b2c6 <memchr+0x1e>

0001b2cc <memcmp>:

#ifdef memcmp
#undef memcmp
#endif
__PDPCLIB_API__ int memcmp(const void *s1, const void *s2, size_t n)
{
   1b2cc:	b530      	push	{r4, r5, lr}
    const unsigned char *p2;
    size_t x = 0;

    p1 = (const unsigned char *)s1;
    p2 = (const unsigned char *)s2;
    while (x < n)
   1b2ce:	2a00      	cmp	r2, #0
   1b2d0:	d011      	beq.n	1b2f6 <memcmp+0x2a>
    {
        if (p1[x] < p2[x])
   1b2d2:	7804      	ldrb	r4, [r0, #0]
   1b2d4:	780b      	ldrb	r3, [r1, #0]
   1b2d6:	429c      	cmp	r4, r3
   1b2d8:	d30f      	bcc.n	1b2fa <memcmp+0x2e>
            return (-1);
        else if (p1[x] > p2[x])
   1b2da:	d811      	bhi.n	1b300 <memcmp+0x34>
    size_t x = 0;
   1b2dc:	2300      	movs	r3, #0
            return (1);
        x++;
   1b2de:	3301      	adds	r3, #1
    while (x < n)
   1b2e0:	429a      	cmp	r2, r3
   1b2e2:	d006      	beq.n	1b2f2 <memcmp+0x26>
        if (p1[x] < p2[x])
   1b2e4:	5cc5      	ldrb	r5, [r0, r3]
   1b2e6:	5ccc      	ldrb	r4, [r1, r3]
   1b2e8:	42a5      	cmp	r5, r4
   1b2ea:	d30b      	bcc.n	1b304 <memcmp+0x38>
        else if (p1[x] > p2[x])
   1b2ec:	d9f7      	bls.n	1b2de <memcmp+0x12>
            return (1);
   1b2ee:	2001      	movs	r0, #1
   1b2f0:	e000      	b.n	1b2f4 <memcmp+0x28>
    }
    return (0);
   1b2f2:	2000      	movs	r0, #0
}
   1b2f4:	bd30      	pop	{r4, r5, pc}
    return (0);
   1b2f6:	2000      	movs	r0, #0
   1b2f8:	e7fc      	b.n	1b2f4 <memcmp+0x28>
            return (-1);
   1b2fa:	2001      	movs	r0, #1
   1b2fc:	4240      	negs	r0, r0
   1b2fe:	e7f9      	b.n	1b2f4 <memcmp+0x28>
            return (1);
   1b300:	2001      	movs	r0, #1
   1b302:	e7f7      	b.n	1b2f4 <memcmp+0x28>
            return (-1);
   1b304:	2001      	movs	r0, #1
   1b306:	4240      	negs	r0, r0
   1b308:	e7f4      	b.n	1b2f4 <memcmp+0x28>

0001b30a <memmove>:
 */

#include "string_private.h"

__PDPCLIB_API__ void *memmove(void *s1, const void *s2, size_t n)
{
   1b30a:	b510      	push	{r4, lr}
    char *p = s1;
    const char *cs2 = s2;
    size_t x;

    if (p <= cs2)
   1b30c:	4288      	cmp	r0, r1
   1b30e:	d808      	bhi.n	1b322 <memmove+0x18>
    {
        for (x=0; x < n; x++)
   1b310:	2a00      	cmp	r2, #0
   1b312:	d005      	beq.n	1b320 <memmove+0x16>
   1b314:	2300      	movs	r3, #0
        {
            *p = *cs2;
   1b316:	5ccc      	ldrb	r4, [r1, r3]
   1b318:	54c4      	strb	r4, [r0, r3]
        for (x=0; x < n; x++)
   1b31a:	3301      	adds	r3, #1
   1b31c:	429a      	cmp	r2, r3
   1b31e:	d1fa      	bne.n	1b316 <memmove+0xc>
            }
            *(p+x) = *(cs2+x);
        }
    }
    return (s1);
}
   1b320:	bd10      	pop	{r4, pc}
        if (n != 0)
   1b322:	2a00      	cmp	r2, #0
   1b324:	d0fc      	beq.n	1b320 <memmove+0x16>
            for (x=n-1; x > 0; x--)
   1b326:	3a01      	subs	r2, #1
   1b328:	2a00      	cmp	r2, #0
   1b32a:	d004      	beq.n	1b336 <memmove+0x2c>
                *(p+x) = *(cs2+x);
   1b32c:	5c8b      	ldrb	r3, [r1, r2]
   1b32e:	5483      	strb	r3, [r0, r2]
            for (x=n-1; x > 0; x--)
   1b330:	3a01      	subs	r2, #1
   1b332:	2a00      	cmp	r2, #0
   1b334:	d1fa      	bne.n	1b32c <memmove+0x22>
            *(p+x) = *(cs2+x);
   1b336:	780b      	ldrb	r3, [r1, #0]
   1b338:	7003      	strb	r3, [r0, #0]
   1b33a:	e7f1      	b.n	1b320 <memmove+0x16>

0001b33c <strchr>:

#include "string_private.h"

__PDPCLIB_API__ char *strchr(const char *s, int c)
{
    while (*s != '\0')
   1b33c:	7803      	ldrb	r3, [r0, #0]
   1b33e:	2b00      	cmp	r3, #0
   1b340:	d009      	beq.n	1b356 <strchr+0x1a>
    {
        if (*s == (char)c) return ((char *)s);
   1b342:	b2ca      	uxtb	r2, r1
   1b344:	4293      	cmp	r3, r2
   1b346:	d008      	beq.n	1b35a <strchr+0x1e>
        s++;
   1b348:	3001      	adds	r0, #1
    while (*s != '\0')
   1b34a:	7803      	ldrb	r3, [r0, #0]
   1b34c:	2b00      	cmp	r3, #0
   1b34e:	d002      	beq.n	1b356 <strchr+0x1a>
        if (*s == (char)c) return ((char *)s);
   1b350:	4293      	cmp	r3, r2
   1b352:	d1f9      	bne.n	1b348 <strchr+0xc>
   1b354:	e001      	b.n	1b35a <strchr+0x1e>
    }
    if (c == '\0') return ((char *)s);
   1b356:	2900      	cmp	r1, #0
   1b358:	d100      	bne.n	1b35c <strchr+0x20>
    return (NULL);
}
   1b35a:	4770      	bx	lr
    return (NULL);
   1b35c:	2000      	movs	r0, #0
   1b35e:	e7fc      	b.n	1b35a <strchr+0x1e>

0001b360 <strcmp>:
    const unsigned char *p2;

    p1 = (const unsigned char *)s1;
    p2 = (const unsigned char *)s2;

    while (*p1 != '\0')
   1b360:	7803      	ldrb	r3, [r0, #0]
   1b362:	2b00      	cmp	r3, #0
   1b364:	d00e      	beq.n	1b384 <strcmp+0x24>
    {
        if (*p1 < *p2)
   1b366:	780a      	ldrb	r2, [r1, #0]
   1b368:	4293      	cmp	r3, r2
   1b36a:	d310      	bcc.n	1b38e <strcmp+0x2e>
            return (-1);
        else if (*p1 > *p2)
   1b36c:	d812      	bhi.n	1b394 <strcmp+0x34>
            return (1);
        p1++;
   1b36e:	3001      	adds	r0, #1
        p2++;
   1b370:	3101      	adds	r1, #1
    while (*p1 != '\0')
   1b372:	7803      	ldrb	r3, [r0, #0]
   1b374:	2b00      	cmp	r3, #0
   1b376:	d005      	beq.n	1b384 <strcmp+0x24>
        if (*p1 < *p2)
   1b378:	780a      	ldrb	r2, [r1, #0]
   1b37a:	429a      	cmp	r2, r3
   1b37c:	d80c      	bhi.n	1b398 <strcmp+0x38>
        else if (*p1 > *p2)
   1b37e:	d2f6      	bcs.n	1b36e <strcmp+0xe>
            return (1);
   1b380:	2001      	movs	r0, #1
   1b382:	e003      	b.n	1b38c <strcmp+0x2c>
    }

    if (*p2 == '\0')
   1b384:	7808      	ldrb	r0, [r1, #0]
   1b386:	1e43      	subs	r3, r0, #1
   1b388:	4198      	sbcs	r0, r3
   1b38a:	4240      	negs	r0, r0
        return (0);
    else
        return (-1);
}
   1b38c:	4770      	bx	lr
            return (-1);
   1b38e:	2001      	movs	r0, #1
   1b390:	4240      	negs	r0, r0
   1b392:	e7fb      	b.n	1b38c <strcmp+0x2c>
            return (1);
   1b394:	2001      	movs	r0, #1
   1b396:	e7f9      	b.n	1b38c <strcmp+0x2c>
            return (-1);
   1b398:	2001      	movs	r0, #1
   1b39a:	4240      	negs	r0, r0
   1b39c:	e7f6      	b.n	1b38c <strcmp+0x2c>

0001b39e <strlen>:
__PDPCLIB_API__ size_t strlen(const char *s)
{
    const char *p;

    p = s;
    while (*p != '\0')
   1b39e:	7803      	ldrb	r3, [r0, #0]
   1b3a0:	2b00      	cmp	r3, #0
   1b3a2:	d006      	beq.n	1b3b2 <strlen+0x14>
    p = s;
   1b3a4:	0003      	movs	r3, r0
        p++;
   1b3a6:	3301      	adds	r3, #1
    while (*p != '\0')
   1b3a8:	781a      	ldrb	r2, [r3, #0]
   1b3aa:	2a00      	cmp	r2, #0
   1b3ac:	d1fb      	bne.n	1b3a6 <strlen+0x8>

    return ((size_t)(p - s));
   1b3ae:	1a18      	subs	r0, r3, r0
}
   1b3b0:	4770      	bx	lr
    p = s;
   1b3b2:	0003      	movs	r3, r0
   1b3b4:	e7fb      	b.n	1b3ae <strlen+0x10>

0001b3b6 <strncmp>:
 */

#include "string_private.h"

__PDPCLIB_API__ int strncmp(const char *s1, const char *s2, size_t n)
{
   1b3b6:	b530      	push	{r4, r5, lr}
    const unsigned char *p2;
    size_t x = 0;

    p1 = (const unsigned char *)s1;
    p2 = (const unsigned char *)s2;
    while (x < n)
   1b3b8:	2a00      	cmp	r2, #0
   1b3ba:	d015      	beq.n	1b3e8 <strncmp+0x32>
    {
        if (p1[x] < p2[x])
   1b3bc:	7803      	ldrb	r3, [r0, #0]
   1b3be:	780c      	ldrb	r4, [r1, #0]
   1b3c0:	42a3      	cmp	r3, r4
   1b3c2:	d313      	bcc.n	1b3ec <strncmp+0x36>
            return (-1);
        else if (p1[x] > p2[x])
   1b3c4:	d815      	bhi.n	1b3f2 <strncmp+0x3c>
            return (1);
        else if (p1[x] == '\0')
   1b3c6:	2b00      	cmp	r3, #0
   1b3c8:	d015      	beq.n	1b3f6 <strncmp+0x40>
    size_t x = 0;
   1b3ca:	2300      	movs	r3, #0
            return (0);
        x++;
   1b3cc:	3301      	adds	r3, #1
    while (x < n)
   1b3ce:	429a      	cmp	r2, r3
   1b3d0:	d008      	beq.n	1b3e4 <strncmp+0x2e>
        if (p1[x] < p2[x])
   1b3d2:	5cc4      	ldrb	r4, [r0, r3]
   1b3d4:	5ccd      	ldrb	r5, [r1, r3]
   1b3d6:	42ac      	cmp	r4, r5
   1b3d8:	d30f      	bcc.n	1b3fa <strncmp+0x44>
        else if (p1[x] > p2[x])
   1b3da:	d811      	bhi.n	1b400 <strncmp+0x4a>
        else if (p1[x] == '\0')
   1b3dc:	2c00      	cmp	r4, #0
   1b3de:	d1f5      	bne.n	1b3cc <strncmp+0x16>
            return (0);
   1b3e0:	2000      	movs	r0, #0
   1b3e2:	e000      	b.n	1b3e6 <strncmp+0x30>
    }
    return (0);
   1b3e4:	2000      	movs	r0, #0
}
   1b3e6:	bd30      	pop	{r4, r5, pc}
    return (0);
   1b3e8:	2000      	movs	r0, #0
   1b3ea:	e7fc      	b.n	1b3e6 <strncmp+0x30>
            return (-1);
   1b3ec:	2001      	movs	r0, #1
   1b3ee:	4240      	negs	r0, r0
   1b3f0:	e7f9      	b.n	1b3e6 <strncmp+0x30>
            return (1);
   1b3f2:	2001      	movs	r0, #1
   1b3f4:	e7f7      	b.n	1b3e6 <strncmp+0x30>
            return (0);
   1b3f6:	2000      	movs	r0, #0
   1b3f8:	e7f5      	b.n	1b3e6 <strncmp+0x30>
            return (-1);
   1b3fa:	2001      	movs	r0, #1
   1b3fc:	4240      	negs	r0, r0
   1b3fe:	e7f2      	b.n	1b3e6 <strncmp+0x30>
            return (1);
   1b400:	2001      	movs	r0, #1
   1b402:	e7f0      	b.n	1b3e6 <strncmp+0x30>

0001b404 <strncpy>:
 */

#include "string_private.h"

__PDPCLIB_API__ char *strncpy(char *s1, const char *s2, size_t n)
{
   1b404:	b530      	push	{r4, r5, lr}
    char *p = s1;
    size_t x;

    for (x=0; x < n; x++)
   1b406:	2a00      	cmp	r2, #0
   1b408:	d016      	beq.n	1b438 <strncpy+0x34>
    {
        *p = *s2;
   1b40a:	780b      	ldrb	r3, [r1, #0]
   1b40c:	7003      	strb	r3, [r0, #0]
        if (*s2 == '\0') break;
   1b40e:	780b      	ldrb	r3, [r1, #0]
   1b410:	2b00      	cmp	r3, #0
   1b412:	d012      	beq.n	1b43a <strncpy+0x36>
    char *p = s1;
   1b414:	0004      	movs	r4, r0
    for (x=0; x < n; x++)
   1b416:	2300      	movs	r3, #0
        p++;
   1b418:	3401      	adds	r4, #1
    for (x=0; x < n; x++)
   1b41a:	3301      	adds	r3, #1
   1b41c:	429a      	cmp	r2, r3
   1b41e:	d00b      	beq.n	1b438 <strncpy+0x34>
        *p = *s2;
   1b420:	5ccd      	ldrb	r5, [r1, r3]
   1b422:	7025      	strb	r5, [r4, #0]
        if (*s2 == '\0') break;
   1b424:	5ccd      	ldrb	r5, [r1, r3]
   1b426:	2d00      	cmp	r5, #0
   1b428:	d1f6      	bne.n	1b418 <strncpy+0x14>
    for (x=0; x < n; x++)
   1b42a:	0019      	movs	r1, r3
        s2++;
    }
    for (; x < n; x++)
    {
        *p++ = '\0';
   1b42c:	1ae3      	subs	r3, r4, r3
   1b42e:	2400      	movs	r4, #0
   1b430:	545c      	strb	r4, [r3, r1]
    for (; x < n; x++)
   1b432:	3101      	adds	r1, #1
   1b434:	428a      	cmp	r2, r1
   1b436:	d8fb      	bhi.n	1b430 <strncpy+0x2c>
    }
    return (s1);
}
   1b438:	bd30      	pop	{r4, r5, pc}
    char *p = s1;
   1b43a:	0004      	movs	r4, r0
    for (x=0; x < n; x++)
   1b43c:	2300      	movs	r3, #0
   1b43e:	e7f4      	b.n	1b42a <strncpy+0x26>

0001b440 <years_to_days>:
{
   return (month * 3057 - 3007) / 100;
}

static long years_to_days (unsigned yr)
{
   1b440:	b570      	push	{r4, r5, r6, lr}
   1b442:	0005      	movs	r5, r0
   return yr * 365L + yr / 4 - yr / 100 + yr / 400;
   1b444:	00c0      	lsls	r0, r0, #3
   1b446:	1940      	adds	r0, r0, r5
   1b448:	00c0      	lsls	r0, r0, #3
   1b44a:	1940      	adds	r0, r0, r5
   1b44c:	0084      	lsls	r4, r0, #2
   1b44e:	1904      	adds	r4, r0, r4
   1b450:	08a8      	lsrs	r0, r5, #2
   1b452:	1824      	adds	r4, r4, r0
   1b454:	21c8      	movs	r1, #200	; 0xc8
   1b456:	0049      	lsls	r1, r1, #1
   1b458:	0028      	movs	r0, r5
   1b45a:	f7e4 ffad 	bl	3b8 <__udivsi3>
   1b45e:	1824      	adds	r4, r4, r0
   1b460:	2164      	movs	r1, #100	; 0x64
   1b462:	0028      	movs	r0, r5
   1b464:	f7e4 ffa8 	bl	3b8 <__udivsi3>
   1b468:	1a20      	subs	r0, r4, r0
}
   1b46a:	bd70      	pop	{r4, r5, r6, pc}

0001b46c <ymd_to_scalar>:

static long ymd_to_scalar(unsigned yr, unsigned mo, unsigned day)
{
   1b46c:	b570      	push	{r4, r5, r6, lr}
   1b46e:	0006      	movs	r6, r0
   1b470:	000d      	movs	r5, r1
   1b472:	0014      	movs	r4, r2
   return (month * 3057 - 3007) / 100;
   1b474:	020b      	lsls	r3, r1, #8
   1b476:	1a5b      	subs	r3, r3, r1
   1b478:	009b      	lsls	r3, r3, #2
   1b47a:	1a5b      	subs	r3, r3, r1
   1b47c:	0098      	lsls	r0, r3, #2
   1b47e:	1ac0      	subs	r0, r0, r3
   1b480:	4b10      	ldr	r3, [pc, #64]	; (1b4c4 <ymd_to_scalar+0x58>)
   1b482:	469c      	mov	ip, r3
   1b484:	4460      	add	r0, ip
   1b486:	2164      	movs	r1, #100	; 0x64
   1b488:	f7e4 ff96 	bl	3b8 <__udivsi3>
   long scalar;

   scalar = day + months_to_days(mo);
   1b48c:	1904      	adds	r4, r0, r4
   if ( mo > 2 )                         /* adjust if past February */
   1b48e:	2d02      	cmp	r5, #2
   1b490:	d912      	bls.n	1b4b8 <ymd_to_scalar+0x4c>
   return yr % 400 == 0 || (yr % 4 == 0 && yr % 100 != 0);
   1b492:	21c8      	movs	r1, #200	; 0xc8
   1b494:	0049      	lsls	r1, r1, #1
   1b496:	0030      	movs	r0, r6
   1b498:	f7e5 f814 	bl	4c4 <__aeabi_uidivmod>
      scalar -= isleap(yr) ? 1 : 2;
   1b49c:	2301      	movs	r3, #1
   return yr % 400 == 0 || (yr % 4 == 0 && yr % 100 != 0);
   1b49e:	2900      	cmp	r1, #0
   1b4a0:	d009      	beq.n	1b4b6 <ymd_to_scalar+0x4a>
      scalar -= isleap(yr) ? 1 : 2;
   1b4a2:	3301      	adds	r3, #1
   return yr % 400 == 0 || (yr % 4 == 0 && yr % 100 != 0);
   1b4a4:	07b2      	lsls	r2, r6, #30
   1b4a6:	d106      	bne.n	1b4b6 <ymd_to_scalar+0x4a>
   1b4a8:	2164      	movs	r1, #100	; 0x64
   1b4aa:	0030      	movs	r0, r6
   1b4ac:	f7e5 f80a 	bl	4c4 <__aeabi_uidivmod>
      scalar -= isleap(yr) ? 1 : 2;
   1b4b0:	424b      	negs	r3, r1
   1b4b2:	414b      	adcs	r3, r1
   1b4b4:	3301      	adds	r3, #1
   1b4b6:	1ae4      	subs	r4, r4, r3
   yr--;
   1b4b8:	1e70      	subs	r0, r6, #1
   scalar += years_to_days(yr);
   1b4ba:	f7ff ffc1 	bl	1b440 <years_to_days>
   1b4be:	1820      	adds	r0, r4, r0
   return (scalar);
}
   1b4c0:	bd70      	pop	{r4, r5, r6, pc}
   1b4c2:	46c0      	nop			; (mov r8, r8)
   1b4c4:	fffff441 	.word	0xfffff441

0001b4c8 <gmtime>:
  ? 5 : 6) : 0)) % 7)

static struct tm tms;

__PDPCLIB_API__ struct tm *gmtime(const time_t *timer)
{
   1b4c8:	b5f0      	push	{r4, r5, r6, r7, lr}
   1b4ca:	46de      	mov	lr, fp
   1b4cc:	4657      	mov	r7, sl
   1b4ce:	4646      	mov	r6, r8
   1b4d0:	b5c0      	push	{r6, r7, lr}
   1b4d2:	b082      	sub	sp, #8
    unsigned yr, mo, da;
    unsigned long secs;
    unsigned long days;

    days = *timer / (60L*60*24);
   1b4d4:	6804      	ldr	r4, [r0, #0]
    secs = *timer % (60L*60*24);
   1b4d6:	4965      	ldr	r1, [pc, #404]	; (1b66c <gmtime+0x1a4>)
   1b4d8:	0020      	movs	r0, r4
   1b4da:	f7e4 fff3 	bl	4c4 <__aeabi_uidivmod>
   1b4de:	9100      	str	r1, [sp, #0]
    scalar_to_ymd(days + ymd_to_scalar(1970, 1, 1), &yr, &mo, &da);
   1b4e0:	2201      	movs	r2, #1
   1b4e2:	2101      	movs	r1, #1
   1b4e4:	4862      	ldr	r0, [pc, #392]	; (1b670 <gmtime+0x1a8>)
   1b4e6:	f7ff ffc1 	bl	1b46c <ymd_to_scalar>
   1b4ea:	0005      	movs	r5, r0
    days = *timer / (60L*60*24);
   1b4ec:	495f      	ldr	r1, [pc, #380]	; (1b66c <gmtime+0x1a4>)
   1b4ee:	0020      	movs	r0, r4
   1b4f0:	f7e4 ff62 	bl	3b8 <__udivsi3>
    scalar_to_ymd(days + ymd_to_scalar(1970, 1, 1), &yr, &mo, &da);
   1b4f4:	1945      	adds	r5, r0, r5
   n = (unsigned)((scalar * 400L) / 146097L);
   1b4f6:	00a8      	lsls	r0, r5, #2
   1b4f8:	1940      	adds	r0, r0, r5
   1b4fa:	0083      	lsls	r3, r0, #2
   1b4fc:	18c0      	adds	r0, r0, r3
   1b4fe:	0100      	lsls	r0, r0, #4
   1b500:	495c      	ldr	r1, [pc, #368]	; (1b674 <gmtime+0x1ac>)
   1b502:	f7e4 ffe3 	bl	4cc <__divsi3>
   1b506:	0004      	movs	r4, r0
   1b508:	0006      	movs	r6, r0
   1b50a:	e000      	b.n	1b50e <gmtime+0x46>
      n++;
   1b50c:	3601      	adds	r6, #1
   while (years_to_days(n) < scalar)
   1b50e:	0030      	movs	r0, r6
   1b510:	f7ff ff96 	bl	1b440 <years_to_days>
   1b514:	4285      	cmp	r5, r0
   1b516:	dcf9      	bgt.n	1b50c <gmtime+0x44>
   1b518:	e000      	b.n	1b51c <gmtime+0x54>
      n++;                          /* 146097 == years_to_days(400) */
   1b51a:	3401      	adds	r4, #1
   for ( n = (unsigned)((scalar * 400L) / 146097L); years_to_days(n) < scalar; )
   1b51c:	0020      	movs	r0, r4
   1b51e:	f7ff ff8f 	bl	1b440 <years_to_days>
   1b522:	4285      	cmp	r5, r0
   1b524:	dcf9      	bgt.n	1b51a <gmtime+0x52>
   n = (unsigned)(scalar - years_to_days(n-1));
   1b526:	1e60      	subs	r0, r4, #1
   1b528:	f7ff ff8a 	bl	1b440 <years_to_days>
   1b52c:	1a2d      	subs	r5, r5, r0
   if ( n > 59 ) {                       /* adjust if past February */
   1b52e:	2d3b      	cmp	r5, #59	; 0x3b
   1b530:	d915      	bls.n	1b55e <gmtime+0x96>
      n += 2;
   1b532:	3502      	adds	r5, #2
   return yr % 400 == 0 || (yr % 4 == 0 && yr % 100 != 0);
   1b534:	21c8      	movs	r1, #200	; 0xc8
   1b536:	0049      	lsls	r1, r1, #1
   1b538:	0020      	movs	r0, r4
   1b53a:	f7e4 ffc3 	bl	4c4 <__aeabi_uidivmod>
   1b53e:	2900      	cmp	r1, #0
   1b540:	d007      	beq.n	1b552 <gmtime+0x8a>
   1b542:	07a3      	lsls	r3, r4, #30
   1b544:	d10b      	bne.n	1b55e <gmtime+0x96>
   1b546:	2164      	movs	r1, #100	; 0x64
   1b548:	0020      	movs	r0, r4
   1b54a:	f7e4 ffbb 	bl	4c4 <__aeabi_uidivmod>
   1b54e:	2900      	cmp	r1, #0
   1b550:	d005      	beq.n	1b55e <gmtime+0x96>
         n -= n > 62 ? 1 : 2;
   1b552:	2300      	movs	r3, #0
   1b554:	223e      	movs	r2, #62	; 0x3e
   1b556:	42aa      	cmp	r2, r5
   1b558:	415b      	adcs	r3, r3
   1b55a:	3301      	adds	r3, #1
   1b55c:	1aed      	subs	r5, r5, r3
   *pmo = (n * 100 + 3007) / 3057;  /* inverse of months_to_days() */
   1b55e:	2064      	movs	r0, #100	; 0x64
   1b560:	4368      	muls	r0, r5
   1b562:	4b45      	ldr	r3, [pc, #276]	; (1b678 <gmtime+0x1b0>)
   1b564:	469c      	mov	ip, r3
   1b566:	4460      	add	r0, ip
   1b568:	4944      	ldr	r1, [pc, #272]	; (1b67c <gmtime+0x1b4>)
   1b56a:	f7e4 ff25 	bl	3b8 <__udivsi3>
   1b56e:	0007      	movs	r7, r0
   return (month * 3057 - 3007) / 100;
   1b570:	0203      	lsls	r3, r0, #8
   1b572:	1a1b      	subs	r3, r3, r0
   1b574:	009b      	lsls	r3, r3, #2
   1b576:	1a1b      	subs	r3, r3, r0
   1b578:	0098      	lsls	r0, r3, #2
   1b57a:	1ac0      	subs	r0, r0, r3
   1b57c:	4b40      	ldr	r3, [pc, #256]	; (1b680 <gmtime+0x1b8>)
   1b57e:	469c      	mov	ip, r3
   1b580:	4460      	add	r0, ip
   1b582:	2164      	movs	r1, #100	; 0x64
   1b584:	f7e4 ff18 	bl	3b8 <__udivsi3>
   *pday = n - months_to_days(*pmo);
   1b588:	1a2d      	subs	r5, r5, r0
    tms.tm_year = yr - 1900;
   1b58a:	4b3e      	ldr	r3, [pc, #248]	; (1b684 <gmtime+0x1bc>)
   1b58c:	18e6      	adds	r6, r4, r3
   1b58e:	4b3e      	ldr	r3, [pc, #248]	; (1b688 <gmtime+0x1c0>)
   1b590:	469a      	mov	sl, r3
   1b592:	615e      	str	r6, [r3, #20]
    tms.tm_mon = mo - 1;
   1b594:	1e7b      	subs	r3, r7, #1
   1b596:	4652      	mov	r2, sl
   1b598:	6113      	str	r3, [r2, #16]
    tms.tm_mday = da;
   1b59a:	60d5      	str	r5, [r2, #12]
    tms.tm_yday = (int)(ymd_to_scalar(tms.tm_year + 1900, mo, da)
   1b59c:	9401      	str	r4, [sp, #4]
   1b59e:	002a      	movs	r2, r5
   1b5a0:	0039      	movs	r1, r7
   1b5a2:	0020      	movs	r0, r4
   1b5a4:	f7ff ff62 	bl	1b46c <ymd_to_scalar>
   1b5a8:	4683      	mov	fp, r0
                  - ymd_to_scalar(tms.tm_year + 1900, 1, 1));
   1b5aa:	2201      	movs	r2, #1
   1b5ac:	2101      	movs	r1, #1
   1b5ae:	0020      	movs	r0, r4
   1b5b0:	f7ff ff5c 	bl	1b46c <ymd_to_scalar>
   1b5b4:	465b      	mov	r3, fp
   1b5b6:	1a18      	subs	r0, r3, r0
    tms.tm_yday = (int)(ymd_to_scalar(tms.tm_year + 1900, mo, da)
   1b5b8:	4653      	mov	r3, sl
   1b5ba:	61d8      	str	r0, [r3, #28]
    tms.tm_wday = dow(tms.tm_year + 1900, mo, da);
   1b5bc:	0038      	movs	r0, r7
   1b5be:	3009      	adds	r0, #9
   1b5c0:	210c      	movs	r1, #12
   1b5c2:	f7e4 ff7f 	bl	4c4 <__aeabi_uidivmod>
   1b5c6:	1c48      	adds	r0, r1, #1
   1b5c8:	0100      	lsls	r0, r0, #4
   1b5ca:	211b      	movs	r1, #27
   1b5cc:	f7e4 ff7a 	bl	4c4 <__aeabi_uidivmod>
   1b5d0:	4688      	mov	r8, r1
   1b5d2:	21c8      	movs	r1, #200	; 0xc8
   1b5d4:	0049      	lsls	r1, r1, #1
   1b5d6:	0020      	movs	r0, r4
   1b5d8:	f7e5 f85e 	bl	698 <__aeabi_idivmod>
   1b5dc:	000c      	movs	r4, r1
   1b5de:	0008      	movs	r0, r1
   1b5e0:	3091      	adds	r0, #145	; 0x91
   1b5e2:	30ff      	adds	r0, #255	; 0xff
   1b5e4:	17c2      	asrs	r2, r0, #31
   1b5e6:	2303      	movs	r3, #3
   1b5e8:	4013      	ands	r3, r2
   1b5ea:	181b      	adds	r3, r3, r0
   1b5ec:	109b      	asrs	r3, r3, #2
   1b5ee:	000a      	movs	r2, r1
   1b5f0:	3292      	adds	r2, #146	; 0x92
   1b5f2:	32ff      	adds	r2, #255	; 0xff
   1b5f4:	469b      	mov	fp, r3
   1b5f6:	4493      	add	fp, r2
   1b5f8:	2164      	movs	r1, #100	; 0x64
   1b5fa:	f7e4 ff67 	bl	4cc <__divsi3>
   1b5fe:	465b      	mov	r3, fp
   1b600:	1a18      	subs	r0, r3, r0
   1b602:	1945      	adds	r5, r0, r5
   1b604:	2000      	movs	r0, #0
   1b606:	2f02      	cmp	r7, #2
   1b608:	d80b      	bhi.n	1b622 <gmtime+0x15a>
   1b60a:	07b3      	lsls	r3, r6, #30
   1b60c:	d106      	bne.n	1b61c <gmtime+0x154>
   1b60e:	2164      	movs	r1, #100	; 0x64
   1b610:	9801      	ldr	r0, [sp, #4]
   1b612:	f7e5 f841 	bl	698 <__aeabi_idivmod>
   1b616:	2005      	movs	r0, #5
   1b618:	2900      	cmp	r1, #0
   1b61a:	d102      	bne.n	1b622 <gmtime+0x15a>
   1b61c:	1e63      	subs	r3, r4, #1
   1b61e:	419c      	sbcs	r4, r3
   1b620:	1d60      	adds	r0, r4, #5
   1b622:	4e19      	ldr	r6, [pc, #100]	; (1b688 <gmtime+0x1c0>)
   1b624:	4445      	add	r5, r8
   1b626:	1828      	adds	r0, r5, r0
   1b628:	2107      	movs	r1, #7
   1b62a:	f7e4 ff4b 	bl	4c4 <__aeabi_uidivmod>
   1b62e:	61b1      	str	r1, [r6, #24]
    tms.tm_isdst = -1;
   1b630:	2301      	movs	r3, #1
   1b632:	425b      	negs	r3, r3
   1b634:	6233      	str	r3, [r6, #32]
    tms.tm_sec = (int)(secs % 60);
   1b636:	213c      	movs	r1, #60	; 0x3c
   1b638:	9c00      	ldr	r4, [sp, #0]
   1b63a:	0020      	movs	r0, r4
   1b63c:	f7e4 ff42 	bl	4c4 <__aeabi_uidivmod>
   1b640:	6031      	str	r1, [r6, #0]
    secs /= 60;
   1b642:	213c      	movs	r1, #60	; 0x3c
   1b644:	0020      	movs	r0, r4
   1b646:	f7e4 feb7 	bl	3b8 <__udivsi3>
    tms.tm_min = (int)(secs % 60);
   1b64a:	213c      	movs	r1, #60	; 0x3c
   1b64c:	f7e4 ff3a 	bl	4c4 <__aeabi_uidivmod>
   1b650:	6071      	str	r1, [r6, #4]
    secs /= 60;
   1b652:	21e1      	movs	r1, #225	; 0xe1
   1b654:	0109      	lsls	r1, r1, #4
   1b656:	0020      	movs	r0, r4
   1b658:	f7e4 feae 	bl	3b8 <__udivsi3>
    tms.tm_hour = (int)secs;
   1b65c:	60b0      	str	r0, [r6, #8]
    return (&tms);
}
   1b65e:	0030      	movs	r0, r6
   1b660:	b002      	add	sp, #8
   1b662:	bc1c      	pop	{r2, r3, r4}
   1b664:	4690      	mov	r8, r2
   1b666:	469a      	mov	sl, r3
   1b668:	46a3      	mov	fp, r4
   1b66a:	bdf0      	pop	{r4, r5, r6, r7, pc}
   1b66c:	00015180 	.word	0x00015180
   1b670:	000007b2 	.word	0x000007b2
   1b674:	00023ab1 	.word	0x00023ab1
   1b678:	00000bbf 	.word	0x00000bbf
   1b67c:	00000bf1 	.word	0x00000bf1
   1b680:	fffff441 	.word	0xfffff441
   1b684:	fffff894 	.word	0xfffff894
   1b688:	01002bd4 	.word	0x01002bd4

0001b68c <mktime>:
{
   1b68c:	b530      	push	{r4, r5, lr}
   1b68e:	b083      	sub	sp, #12
   1b690:	0004      	movs	r4, r0
    if ((timeptr->tm_year < 70) || (timeptr->tm_year > 170)) /* unsigned long (int32) can hold 130+ years worth of seconds */
   1b692:	6940      	ldr	r0, [r0, #20]
   1b694:	0003      	movs	r3, r0
   1b696:	3b46      	subs	r3, #70	; 0x46
   1b698:	2b64      	cmp	r3, #100	; 0x64
   1b69a:	d82d      	bhi.n	1b6f8 <mktime+0x6c>
                           timeptr->tm_mon + 1,
   1b69c:	6923      	ldr	r3, [r4, #16]
   1b69e:	1c59      	adds	r1, r3, #1
        tt = ymd_to_scalar(timeptr->tm_year + 1900,
   1b6a0:	4b17      	ldr	r3, [pc, #92]	; (1b700 <mktime+0x74>)
   1b6a2:	469c      	mov	ip, r3
   1b6a4:	4460      	add	r0, ip
   1b6a6:	68e2      	ldr	r2, [r4, #12]
   1b6a8:	f7ff fee0 	bl	1b46c <ymd_to_scalar>
   1b6ac:	0005      	movs	r5, r0
             - ymd_to_scalar(1970, 1, 1);
   1b6ae:	2201      	movs	r2, #1
   1b6b0:	2101      	movs	r1, #1
   1b6b2:	4814      	ldr	r0, [pc, #80]	; (1b704 <mktime+0x78>)
   1b6b4:	f7ff feda 	bl	1b46c <ymd_to_scalar>
   1b6b8:	1a28      	subs	r0, r5, r0
        tt = tt * 24 + timeptr->tm_hour;
   1b6ba:	0043      	lsls	r3, r0, #1
   1b6bc:	181b      	adds	r3, r3, r0
   1b6be:	00db      	lsls	r3, r3, #3
   1b6c0:	68a2      	ldr	r2, [r4, #8]
   1b6c2:	1898      	adds	r0, r3, r2
        tt = tt * 60 + timeptr->tm_min;
   1b6c4:	0103      	lsls	r3, r0, #4
   1b6c6:	1a1b      	subs	r3, r3, r0
   1b6c8:	009b      	lsls	r3, r3, #2
   1b6ca:	6862      	ldr	r2, [r4, #4]
   1b6cc:	4694      	mov	ip, r2
   1b6ce:	4463      	add	r3, ip
        tt = tt * 60 + timeptr->tm_sec;
   1b6d0:	011a      	lsls	r2, r3, #4
   1b6d2:	1ad3      	subs	r3, r2, r3
   1b6d4:	009b      	lsls	r3, r3, #2
   1b6d6:	6822      	ldr	r2, [r4, #0]
   1b6d8:	4694      	mov	ip, r2
   1b6da:	4463      	add	r3, ip
   1b6dc:	9301      	str	r3, [sp, #4]
    *timeptr = *gmtime(&tt);
   1b6de:	a801      	add	r0, sp, #4
   1b6e0:	f7ff fef2 	bl	1b4c8 <gmtime>
   1b6e4:	0023      	movs	r3, r4
   1b6e6:	c816      	ldmia	r0!, {r1, r2, r4}
   1b6e8:	c316      	stmia	r3!, {r1, r2, r4}
   1b6ea:	c816      	ldmia	r0!, {r1, r2, r4}
   1b6ec:	c316      	stmia	r3!, {r1, r2, r4}
   1b6ee:	c816      	ldmia	r0!, {r1, r2, r4}
   1b6f0:	c316      	stmia	r3!, {r1, r2, r4}
}
   1b6f2:	9801      	ldr	r0, [sp, #4]
   1b6f4:	b003      	add	sp, #12
   1b6f6:	bd30      	pop	{r4, r5, pc}
        tt = (time_t)-1;
   1b6f8:	2301      	movs	r3, #1
   1b6fa:	425b      	negs	r3, r3
   1b6fc:	9301      	str	r3, [sp, #4]
   1b6fe:	e7ee      	b.n	1b6de <mktime+0x52>
   1b700:	0000076c 	.word	0x0000076c
   1b704:	000007b2 	.word	0x000007b2

0001b708 <__asm_memcpy_assert>:

    return (0);
}

void __asm_memcpy_assert(uint32 lr)
{
   1b708:	b510      	push	{r4, lr}
   1b70a:	0001      	movs	r1, r0
    panic(PANIC_MEMCPY_BUFFER_OVERLAP, lr);
   1b70c:	202c      	movs	r0, #44	; 0x2c
   1b70e:	f7e6 f9ff 	bl	1b10 <panic>
}
   1b712:	bd10      	pop	{r4, pc}

0001b714 <sprintf>:
 */

#include "stdio_private.h"

__PDPCLIB_API__ int sprintf(char *s, const char *format, ...)
{
   1b714:	b40e      	push	{r1, r2, r3}
   1b716:	b500      	push	{lr}
   1b718:	b082      	sub	sp, #8
   1b71a:	aa03      	add	r2, sp, #12
   1b71c:	ca02      	ldmia	r2!, {r1}
    va_list arg;
    int ret;

    va_start(arg, format);
   1b71e:	9201      	str	r2, [sp, #4]
    ret = vsprintf(s, format, arg);
   1b720:	f7ff f8c5 	bl	1a8ae <vsprintf>
    va_end(arg);
    return (ret);
}
   1b724:	b002      	add	sp, #8
   1b726:	bc08      	pop	{r3}
   1b728:	b003      	add	sp, #12
   1b72a:	4718      	bx	r3

0001b72c <set_last_panic>:
{
    return &preserve_data_lib.last_panic;
}

void set_last_panic(PANIC_DESC last_panic)
{
   1b72c:	b51f      	push	{r0, r1, r2, r3, r4, lr}
    memcpy((void*)&preserve_data_lib.last_panic, (void*)&last_panic, sizeof(PANIC_DESC));
   1b72e:	4b04      	ldr	r3, [pc, #16]	; (1b740 <set_last_panic+0x14>)
{
   1b730:	ac01      	add	r4, sp, #4
   1b732:	9001      	str	r0, [sp, #4]
   1b734:	9102      	str	r1, [sp, #8]
   1b736:	9203      	str	r2, [sp, #12]
    memcpy((void*)&preserve_data_lib.last_panic, (void*)&last_panic, sizeof(PANIC_DESC));
   1b738:	3330      	adds	r3, #48	; 0x30
   1b73a:	cc07      	ldmia	r4!, {r0, r1, r2}
   1b73c:	c307      	stmia	r3!, {r0, r1, r2}
}
   1b73e:	bd1f      	pop	{r0, r1, r2, r3, r4, pc}
   1b740:	01002f60 	.word	0x01002f60

0001b744 <set_exception_stack_frame>:
{
    return &preserve_data_lib.exception_stack_frame;
}

void set_exception_stack_frame(exception_stack_frame_t exception_stack_frame_src)
{
   1b744:	b084      	sub	sp, #16
   1b746:	b510      	push	{r4, lr}
   1b748:	9305      	str	r3, [sp, #20]
    memcpy((void*)&preserve_data_lib.exception_stack_frame, (void*)&exception_stack_frame_src, sizeof(exception_stack_frame_t));
   1b74a:	4b08      	ldr	r3, [pc, #32]	; (1b76c <set_exception_stack_frame+0x28>)
{
   1b74c:	9204      	str	r2, [sp, #16]
   1b74e:	9002      	str	r0, [sp, #8]
   1b750:	9103      	str	r1, [sp, #12]
    memcpy((void*)&preserve_data_lib.exception_stack_frame, (void*)&exception_stack_frame_src, sizeof(exception_stack_frame_t));
   1b752:	aa02      	add	r2, sp, #8
   1b754:	330c      	adds	r3, #12
   1b756:	ca13      	ldmia	r2!, {r0, r1, r4}
   1b758:	c313      	stmia	r3!, {r0, r1, r4}
   1b75a:	ca13      	ldmia	r2!, {r0, r1, r4}
   1b75c:	c313      	stmia	r3!, {r0, r1, r4}
   1b75e:	ca03      	ldmia	r2!, {r0, r1}
   1b760:	c303      	stmia	r3!, {r0, r1}
}
   1b762:	bc10      	pop	{r4}
   1b764:	bc08      	pop	{r3}
   1b766:	b004      	add	sp, #16
   1b768:	4718      	bx	r3
   1b76a:	46c0      	nop			; (mov r8, r8)
   1b76c:	01002f60 	.word	0x01002f60

0001b770 <set_last_exception>:
    return preserve_data_lib.last_exception;
}

void set_last_exception(exception_type_t last_exception_src)
{
    preserve_data_lib.last_exception = last_exception_src;
   1b770:	4b01      	ldr	r3, [pc, #4]	; (1b778 <set_last_exception+0x8>)
   1b772:	332c      	adds	r3, #44	; 0x2c
   1b774:	7018      	strb	r0, [r3, #0]
}
   1b776:	4770      	bx	lr
   1b778:	01002f60 	.word	0x01002f60

0001b77c <preserve_init>:

void preserve_init(void)
{
    // Remember whether it was valid.
    valid = (preserve_data_lib.preserve_magic == PRESERVE_MAGIC);
   1b77c:	4810      	ldr	r0, [pc, #64]	; (1b7c0 <preserve_init+0x44>)
   1b77e:	4a11      	ldr	r2, [pc, #68]	; (1b7c4 <preserve_init+0x48>)
{
   1b780:	b570      	push	{r4, r5, r6, lr}
    valid = (preserve_data_lib.preserve_magic == PRESERVE_MAGIC);
   1b782:	0003      	movs	r3, r0
   1b784:	0016      	movs	r6, r2
   1b786:	4c10      	ldr	r4, [pc, #64]	; (1b7c8 <preserve_init+0x4c>)
   1b788:	6825      	ldr	r5, [r4, #0]
   1b78a:	6861      	ldr	r1, [r4, #4]
   1b78c:	406b      	eors	r3, r5
   1b78e:	404e      	eors	r6, r1
   1b790:	4333      	orrs	r3, r6
   1b792:	425e      	negs	r6, r3
   1b794:	4173      	adcs	r3, r6
   1b796:	4e0d      	ldr	r6, [pc, #52]	; (1b7cc <preserve_init+0x50>)
   1b798:	7033      	strb	r3, [r6, #0]

    if (valid)
   1b79a:	4285      	cmp	r5, r0
   1b79c:	d109      	bne.n	1b7b2 <preserve_init+0x36>
   1b79e:	4291      	cmp	r1, r2
   1b7a0:	d107      	bne.n	1b7b2 <preserve_init+0x36>
    {
        preserve_data_lib.reboot_counter++;
   1b7a2:	68a3      	ldr	r3, [r4, #8]
   1b7a4:	3301      	adds	r3, #1
   1b7a6:	60a3      	str	r3, [r4, #8]
        //Since this is not cleared by the CRT0 we need to clear it here if we are not valid
        memset(&preserve_data_lib, 0, sizeof(preserve_data));
    }

    // Say it will be on the next boot, if the RAM remains powered.
    preserve_data_lib.preserve_magic = PRESERVE_MAGIC;
   1b7a8:	4a05      	ldr	r2, [pc, #20]	; (1b7c0 <preserve_init+0x44>)
   1b7aa:	4b06      	ldr	r3, [pc, #24]	; (1b7c4 <preserve_init+0x48>)
   1b7ac:	6022      	str	r2, [r4, #0]
   1b7ae:	6063      	str	r3, [r4, #4]
}
   1b7b0:	bd70      	pop	{r4, r5, r6, pc}
        memset(&preserve_data_lib, 0, sizeof(preserve_data));
   1b7b2:	2240      	movs	r2, #64	; 0x40
   1b7b4:	2100      	movs	r1, #0
   1b7b6:	0020      	movs	r0, r4
   1b7b8:	f7e4 fd92 	bl	2e0 <memset>
   1b7bc:	e7f4      	b.n	1b7a8 <preserve_init+0x2c>
   1b7be:	46c0      	nop			; (mov r8, r8)
   1b7c0:	deadd00d 	.word	0xdeadd00d
   1b7c4:	adefaced 	.word	0xadefaced
   1b7c8:	01002f60 	.word	0x01002f60
   1b7cc:	01002bf8 	.word	0x01002bf8

0001b7d0 <preserve_valid>:
    preserve_data_lib.preserve_magic = ~PRESERVE_MAGIC;
}

bool preserve_valid(void)
{
    return valid;
   1b7d0:	4b01      	ldr	r3, [pc, #4]	; (1b7d8 <preserve_valid+0x8>)
   1b7d2:	7818      	ldrb	r0, [r3, #0]
}
   1b7d4:	4770      	bx	lr
   1b7d6:	46c0      	nop			; (mov r8, r8)
   1b7d8:	01002bf8 	.word	0x01002bf8

0001b7dc <remote_command_driver_adc_read_response>:
}

void remote_command_driver_adc_read_response(CORES core, uint32 reading, uint8 ret_value)
{
    UNUSED(core);
    protocol_core_ret_val = (ADC_RET) ret_value;
   1b7dc:	4b04      	ldr	r3, [pc, #16]	; (1b7f0 <remote_command_driver_adc_read_response+0x14>)
{
   1b7de:	b510      	push	{r4, lr}
    protocol_core_ret_val = (ADC_RET) ret_value;
   1b7e0:	701a      	strb	r2, [r3, #0]
    protocol_core_reading = reading;
   1b7e2:	4b04      	ldr	r3, [pc, #16]	; (1b7f4 <remote_command_driver_adc_read_response+0x18>)
   1b7e4:	6019      	str	r1, [r3, #0]
    (void) osSemaphoreRelease(app_adc_semaphore);
   1b7e6:	4b04      	ldr	r3, [pc, #16]	; (1b7f8 <remote_command_driver_adc_read_response+0x1c>)
   1b7e8:	6818      	ldr	r0, [r3, #0]
   1b7ea:	f7f9 f973 	bl	14ad4 <osSemaphoreRelease>
}
   1b7ee:	bd10      	pop	{r4, pc}
   1b7f0:	01002c04 	.word	0x01002c04
   1b7f4:	01002c00 	.word	0x01002c00
   1b7f8:	01002bfc 	.word	0x01002bfc

0001b7fc <remote_command_driver_adc_action_response>:

void remote_command_driver_adc_action_response(CORES core, uint8 ret_value)
{
   1b7fc:	b510      	push	{r4, lr}
    UNUSED(core);
    protocol_core_ret_val = (ADC_RET) ret_value;
   1b7fe:	4b03      	ldr	r3, [pc, #12]	; (1b80c <remote_command_driver_adc_action_response+0x10>)
   1b800:	7019      	strb	r1, [r3, #0]
    (void) osSemaphoreRelease(app_adc_semaphore);
   1b802:	4b03      	ldr	r3, [pc, #12]	; (1b810 <remote_command_driver_adc_action_response+0x14>)
   1b804:	6818      	ldr	r0, [r3, #0]
   1b806:	f7f9 f965 	bl	14ad4 <osSemaphoreRelease>
}
   1b80a:	bd10      	pop	{r4, pc}
   1b80c:	01002c04 	.word	0x01002c04
   1b810:	01002bfc 	.word	0x01002bfc

0001b814 <flash_log_register>:
 * Register flash logging buffer
 * @param log_address pointer to address of log header
 * @return NEUL_RET_OK or error code
 */
NEUL_RET flash_log_register(void *log_address)
{
   1b814:	b513      	push	{r0, r1, r4, lr}
    NEUL_RET result;

    if (command_iflog_cache_register((uint32) log_address, (uint8 *) &result) != RPC_ERR_OK)
   1b816:	466b      	mov	r3, sp
   1b818:	1ddc      	adds	r4, r3, #7
   1b81a:	0021      	movs	r1, r4
   1b81c:	f7ea f886 	bl	592c <command_iflog_cache_register>
   1b820:	2800      	cmp	r0, #0
   1b822:	d001      	beq.n	1b828 <flash_log_register+0x14>
    {
         result = NEUL_RET_ERROR;
   1b824:	2301      	movs	r3, #1
   1b826:	7023      	strb	r3, [r4, #0]
    }
    return result;
   1b828:	7820      	ldrb	r0, [r4, #0]
}
   1b82a:	bd16      	pop	{r1, r2, r4, pc}

0001b82c <flash_log_write>:
 * @param index Start address to write from (word aligned)
 * @param length to write in bytes
 * @return NEUL_RET_OK or error code
 */
NEUL_RET flash_log_write(uint16 index, uint16 len)
{
   1b82c:	b513      	push	{r0, r1, r4, lr}
    NEUL_RET result;

    if (command_iflog_iflash_write(index, len, (uint8 *) &result) != RPC_ERR_OK)
   1b82e:	466b      	mov	r3, sp
   1b830:	1ddc      	adds	r4, r3, #7
   1b832:	0022      	movs	r2, r4
   1b834:	f7ea f8a4 	bl	5980 <command_iflog_iflash_write>
   1b838:	2800      	cmp	r0, #0
   1b83a:	d001      	beq.n	1b840 <flash_log_write+0x14>
    {
         result = NEUL_RET_ERROR;
   1b83c:	2301      	movs	r3, #1
   1b83e:	7023      	strb	r3, [r4, #0]
    }
    return result;
   1b840:	7820      	ldrb	r0, [r4, #0]
}
   1b842:	bd16      	pop	{r1, r2, r4, pc}

0001b844 <flash_log_read>:
 * @param buffer_size size of buffer passed in
 * @param length amount of data returned
 * @return NEUL_RET_OK or error code
 */
NEUL_RET flash_log_read(uint32 buffer, uint16 buffer_size, uint16 *length)
{
   1b844:	b513      	push	{r0, r1, r4, lr}
   1b846:	0013      	movs	r3, r2
    NEUL_RET result;

    if (command_iflog_iflash_read(buffer, buffer_size, (uint8*)&result, length)  != RPC_ERR_OK)
   1b848:	466a      	mov	r2, sp
   1b84a:	1dd4      	adds	r4, r2, #7
   1b84c:	0022      	movs	r2, r4
   1b84e:	f7ea f8c8 	bl	59e2 <command_iflog_iflash_read>
   1b852:	2800      	cmp	r0, #0
   1b854:	d001      	beq.n	1b85a <flash_log_read+0x16>
    {
         result = NEUL_RET_ERROR;
   1b856:	2301      	movs	r3, #1
   1b858:	7023      	strb	r3, [r4, #0]
    }
    return result;
   1b85a:	7820      	ldrb	r0, [r4, #0]
}
   1b85c:	bd16      	pop	{r1, r2, r4, pc}

0001b85e <set_imei>:
#define MANUFACTURER_STRING ("Neul")
#define MAX_DIEID_LENGTH          64

/* Set the IMEI from imei */
NEUL_RET set_imei (uint8 *imei)
{
   1b85e:	b513      	push	{r0, r1, r4, lr}
    uint8 command_ret_code = (uint8) NEUL_RET_OK;
   1b860:	466b      	mov	r3, sp
   1b862:	1ddc      	adds	r4, r3, #7
   1b864:	2300      	movs	r3, #0
{
   1b866:	0001      	movs	r1, r0
    uint8 command_ret_code = (uint8) NEUL_RET_OK;
   1b868:	7023      	strb	r3, [r4, #0]
    RPC_ERR ret_val;
    if (!imei)
   1b86a:	4298      	cmp	r0, r3
   1b86c:	d101      	bne.n	1b872 <set_imei+0x14>
    {
        return NEUL_RET_ERROR;
   1b86e:	2001      	movs	r0, #1
    if (ret_val != RPC_ERR_OK || command_ret_code != NEUL_RET_OK)
    {
        return NEUL_RET_ERROR;
    }
    return NEUL_RET_OK;
}
   1b870:	bd16      	pop	{r1, r2, r4, pc}
    ret_val = command_set_id(IMEI_PACKED_LENGTH, imei, ID_TYPE_IMEI, &command_ret_code);
   1b872:	0023      	movs	r3, r4
   1b874:	2201      	movs	r2, #1
   1b876:	2008      	movs	r0, #8
   1b878:	f7e7 fd70 	bl	335c <command_set_id>
    if (ret_val != RPC_ERR_OK || command_ret_code != NEUL_RET_OK)
   1b87c:	2800      	cmp	r0, #0
   1b87e:	d1f6      	bne.n	1b86e <set_imei+0x10>
   1b880:	7820      	ldrb	r0, [r4, #0]
   1b882:	1e43      	subs	r3, r0, #1
   1b884:	4198      	sbcs	r0, r3
        return NEUL_RET_ERROR;
   1b886:	b2c0      	uxtb	r0, r0
   1b888:	e7f2      	b.n	1b870 <set_imei+0x12>

0001b88a <set_serial_number>:

/* Save the the SERIAL_NUMBER in the location pointed by serialnumber.
 * SERIAL_NUMBER is SERIALNUMBER_LENGTH bytes long.
 */
NEUL_RET set_serial_number (uint8 *serialnumber)
{
   1b88a:	b513      	push	{r0, r1, r4, lr}
    uint8 command_ret_code = (uint8) NEUL_RET_OK;
   1b88c:	466b      	mov	r3, sp
   1b88e:	2200      	movs	r2, #0
   1b890:	1ddc      	adds	r4, r3, #7
{
   1b892:	0001      	movs	r1, r0
    uint8 command_ret_code = (uint8) NEUL_RET_OK;
   1b894:	7022      	strb	r2, [r4, #0]
    RPC_ERR ret_val;
    if (!serialnumber)
   1b896:	4290      	cmp	r0, r2
   1b898:	d101      	bne.n	1b89e <set_serial_number+0x14>
    {
        return NEUL_RET_ERROR;
   1b89a:	2001      	movs	r0, #1
    if ((ret_val != RPC_ERR_OK) || (command_ret_code != NEUL_RET_OK))
    {
        return NEUL_RET_ERROR;
    }
    return NEUL_RET_OK;
}
   1b89c:	bd16      	pop	{r1, r2, r4, pc}
    ret_val = command_set_id(SERIALNUMBER_LENGTH, serialnumber, ID_TYPE_SERIALNUMBER, &command_ret_code);
   1b89e:	0023      	movs	r3, r4
   1b8a0:	2010      	movs	r0, #16
   1b8a2:	f7e7 fd5b 	bl	335c <command_set_id>
    if ((ret_val != RPC_ERR_OK) || (command_ret_code != NEUL_RET_OK))
   1b8a6:	2800      	cmp	r0, #0
   1b8a8:	d1f7      	bne.n	1b89a <set_serial_number+0x10>
   1b8aa:	7820      	ldrb	r0, [r4, #0]
   1b8ac:	1e43      	subs	r3, r0, #1
   1b8ae:	4198      	sbcs	r0, r3
        return NEUL_RET_ERROR;
   1b8b0:	b2c0      	uxtb	r0, r0
   1b8b2:	e7f3      	b.n	1b89c <set_serial_number+0x12>

0001b8b4 <get_man_identifier>:

NEUL_RET get_man_identifier (char *mident, uint16 mident_max_len, uint16 *mident_len)
{
   1b8b4:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
   1b8b6:	0005      	movs	r5, r0
   1b8b8:	000e      	movs	r6, r1
   1b8ba:	0014      	movs	r4, r2
    int str_length;

    NEUL_RET ret_value = NEUL_RET_OK;

    if ((mident == NULL) || (mident_len == NULL))
   1b8bc:	2800      	cmp	r0, #0
   1b8be:	d101      	bne.n	1b8c4 <get_man_identifier+0x10>
    {
        ret_value = NEUL_RET_ERROR;
   1b8c0:	2001      	movs	r0, #1
                *mident_len = (uint16) str_length;
            }
        }
    }
    return ret_value;
}
   1b8c2:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    if ((mident == NULL) || (mident_len == NULL))
   1b8c4:	2a00      	cmp	r2, #0
   1b8c6:	d0fb      	beq.n	1b8c0 <get_man_identifier+0xc>
        if (neul_kv_get( BASE_KEYID_MANUFACTURER_IDENTIFIER, mident_max_len, mident_len, (uint8 *)mident) != NEUL_RET_OK)
   1b8c8:	0003      	movs	r3, r0
   1b8ca:	2006      	movs	r0, #6
   1b8cc:	f7eb fe71 	bl	75b2 <neul_kv_get>
   1b8d0:	2800      	cmp	r0, #0
   1b8d2:	d0f6      	beq.n	1b8c2 <get_man_identifier+0xe>
            *mident_len = 0;       
   1b8d4:	2700      	movs	r7, #0
            str_length = snprintf((char *)mident, mident_max_len, "%s", MANUFACTURER_STRING);
   1b8d6:	4b06      	ldr	r3, [pc, #24]	; (1b8f0 <get_man_identifier+0x3c>)
            *mident_len = 0;       
   1b8d8:	8027      	strh	r7, [r4, #0]
            str_length = snprintf((char *)mident, mident_max_len, "%s", MANUFACTURER_STRING);
   1b8da:	4a06      	ldr	r2, [pc, #24]	; (1b8f4 <get_man_identifier+0x40>)
   1b8dc:	0031      	movs	r1, r6
   1b8de:	0028      	movs	r0, r5
   1b8e0:	f7fe ffc4 	bl	1a86c <snprintf>
            if (str_length <= 0) 
   1b8e4:	42b8      	cmp	r0, r7
   1b8e6:	ddeb      	ble.n	1b8c0 <get_man_identifier+0xc>
                *mident_len = (uint16) str_length;
   1b8e8:	8020      	strh	r0, [r4, #0]
    NEUL_RET ret_value = NEUL_RET_OK;
   1b8ea:	0038      	movs	r0, r7
   1b8ec:	e7e9      	b.n	1b8c2 <get_man_identifier+0xe>
   1b8ee:	46c0      	nop			; (mov r8, r8)
   1b8f0:	00025700 	.word	0x00025700
   1b8f4:	000237d7 	.word	0x000237d7

0001b8f8 <get_man_model>:

NEUL_RET get_man_model (char *mmodel, uint16 mmodel_max_len, uint16 *mmodel_len)
{
   1b8f8:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
   1b8fa:	0005      	movs	r5, r0
   1b8fc:	000e      	movs	r6, r1
   1b8fe:	0014      	movs	r4, r2
    int str_length;

    NEUL_RET ret_value = NEUL_RET_OK;

    if ((mmodel == NULL) || (mmodel_len == NULL))
   1b900:	2800      	cmp	r0, #0
   1b902:	d101      	bne.n	1b908 <get_man_model+0x10>
    {
        ret_value = NEUL_RET_ERROR;
   1b904:	2001      	movs	r0, #1
                *mmodel_len = (uint16) str_length;
            }
        }
    }
    return ret_value;
}
   1b906:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    if ((mmodel == NULL) || (mmodel_len == NULL))
   1b908:	2a00      	cmp	r2, #0
   1b90a:	d0fb      	beq.n	1b904 <get_man_model+0xc>
        if (neul_kv_get( BASE_KEYID_MANUFACTURER_MODEL_IDENTIFIER, mmodel_max_len, mmodel_len, (uint8 *)mmodel) != NEUL_RET_OK)
   1b90c:	0003      	movs	r3, r0
   1b90e:	2007      	movs	r0, #7
   1b910:	f7eb fe4f 	bl	75b2 <neul_kv_get>
   1b914:	2800      	cmp	r0, #0
   1b916:	d0f6      	beq.n	1b906 <get_man_model+0xe>
            *mmodel_len = 0;       
   1b918:	2700      	movs	r7, #0
            str_length = snprintf((char *)mmodel, mmodel_max_len, "%s", MANUFACTURER_MODEL_STRING);
   1b91a:	4b06      	ldr	r3, [pc, #24]	; (1b934 <get_man_model+0x3c>)
            *mmodel_len = 0;       
   1b91c:	8027      	strh	r7, [r4, #0]
            str_length = snprintf((char *)mmodel, mmodel_max_len, "%s", MANUFACTURER_MODEL_STRING);
   1b91e:	4a06      	ldr	r2, [pc, #24]	; (1b938 <get_man_model+0x40>)
   1b920:	0031      	movs	r1, r6
   1b922:	0028      	movs	r0, r5
   1b924:	f7fe ffa2 	bl	1a86c <snprintf>
            if (str_length <= 0) 
   1b928:	42b8      	cmp	r0, r7
   1b92a:	ddeb      	ble.n	1b904 <get_man_model+0xc>
                *mmodel_len = (uint16) str_length;
   1b92c:	8020      	strh	r0, [r4, #0]
    NEUL_RET ret_value = NEUL_RET_OK;
   1b92e:	0038      	movs	r0, r7
   1b930:	e7e9      	b.n	1b906 <get_man_model+0xe>
   1b932:	46c0      	nop			; (mov r8, r8)
   1b934:	00025705 	.word	0x00025705
   1b938:	000237d7 	.word	0x000237d7

0001b93c <set_imei_permanence>:

NEUL_RET set_imei_permanence(NTPERMID_TYPE dest)
{
   1b93c:	b513      	push	{r0, r1, r4, lr}
    uint8 command_ret_code = (uint8) NEUL_RET_OK;
   1b93e:	466b      	mov	r3, sp
   1b940:	1ddc      	adds	r4, r3, #7
   1b942:	2300      	movs	r3, #0
{
   1b944:	0001      	movs	r1, r0
    RPC_ERR ret_val;

    ret_val = command_set_id_permanence(ID_TYPE_IMEI, dest, &command_ret_code);
   1b946:	0022      	movs	r2, r4
   1b948:	2001      	movs	r0, #1
    uint8 command_ret_code = (uint8) NEUL_RET_OK;
   1b94a:	7023      	strb	r3, [r4, #0]
    ret_val = command_set_id_permanence(ID_TYPE_IMEI, dest, &command_ret_code);
   1b94c:	f7e7 fd3d 	bl	33ca <command_set_id_permanence>
    if ((ret_val != RPC_ERR_OK) || (command_ret_code != NEUL_RET_OK))
    {
        return NEUL_RET_ERROR;
   1b950:	2301      	movs	r3, #1
    if ((ret_val != RPC_ERR_OK) || (command_ret_code != NEUL_RET_OK))
   1b952:	2800      	cmp	r0, #0
   1b954:	d103      	bne.n	1b95e <set_imei_permanence+0x22>
   1b956:	7823      	ldrb	r3, [r4, #0]
   1b958:	1e58      	subs	r0, r3, #1
   1b95a:	4183      	sbcs	r3, r0
        return NEUL_RET_ERROR;
   1b95c:	b2db      	uxtb	r3, r3
    }
    return NEUL_RET_OK;

}
   1b95e:	0018      	movs	r0, r3
   1b960:	bd16      	pop	{r1, r2, r4, pc}

0001b962 <set_serialnumber_permanence>:

NEUL_RET set_serialnumber_permanence(NTPERMID_TYPE dest)
{
   1b962:	b513      	push	{r0, r1, r4, lr}
    uint8 command_ret_code = (uint8) NEUL_RET_OK;
   1b964:	466b      	mov	r3, sp
{
   1b966:	0001      	movs	r1, r0
    uint8 command_ret_code = (uint8) NEUL_RET_OK;
   1b968:	2000      	movs	r0, #0
   1b96a:	1ddc      	adds	r4, r3, #7
    RPC_ERR ret_val;

    ret_val = command_set_id_permanence(ID_TYPE_SERIALNUMBER, dest, &command_ret_code);
   1b96c:	0022      	movs	r2, r4
    uint8 command_ret_code = (uint8) NEUL_RET_OK;
   1b96e:	71d8      	strb	r0, [r3, #7]
    ret_val = command_set_id_permanence(ID_TYPE_SERIALNUMBER, dest, &command_ret_code);
   1b970:	f7e7 fd2b 	bl	33ca <command_set_id_permanence>
    if ((ret_val != RPC_ERR_OK) || (command_ret_code != NEUL_RET_OK))
    {
        return NEUL_RET_ERROR;
   1b974:	2301      	movs	r3, #1
    if ((ret_val != RPC_ERR_OK) || (command_ret_code != NEUL_RET_OK))
   1b976:	2800      	cmp	r0, #0
   1b978:	d103      	bne.n	1b982 <set_serialnumber_permanence+0x20>
   1b97a:	7823      	ldrb	r3, [r4, #0]
   1b97c:	1e58      	subs	r0, r3, #1
   1b97e:	4183      	sbcs	r3, r0
        return NEUL_RET_ERROR;
   1b980:	b2db      	uxtb	r3, r3
    }
    return NEUL_RET_OK;

}
   1b982:	0018      	movs	r0, r3
   1b984:	bd16      	pop	{r1, r2, r4, pc}

0001b986 <get_ssb_version>:
 * @param version_string 48-byte buffer to hold ssb version information
 * @param buff_length the length of version_string buff(minimum 48 bytes).
 * @return NEUL_RET_OK or error value.
 */
NEUL_RET get_ssb_version(uint16 *version_string_length, char *version_string, uint16 buff_length)
{
   1b986:	b513      	push	{r0, r1, r4, lr}
    NEUL_RET neul_result = NEUL_RET_OK;
   1b988:	466b      	mov	r3, sp
   1b98a:	1ddc      	adds	r4, r3, #7
   1b98c:	2300      	movs	r3, #0
   1b98e:	7023      	strb	r3, [r4, #0]

    if ((version_string_length == NULL) || (version_string == NULL) || (buff_length < MAX_VERSION_STRING))
    {
        return NEUL_RET_ERROR;
   1b990:	3301      	adds	r3, #1
    if ((version_string_length == NULL) || (version_string == NULL) || (buff_length < MAX_VERSION_STRING))
   1b992:	2800      	cmp	r0, #0
   1b994:	d00c      	beq.n	1b9b0 <get_ssb_version+0x2a>
   1b996:	2900      	cmp	r1, #0
   1b998:	d00a      	beq.n	1b9b0 <get_ssb_version+0x2a>
   1b99a:	2a2f      	cmp	r2, #47	; 0x2f
   1b99c:	d908      	bls.n	1b9b0 <get_ssb_version+0x2a>
    }

    if (command_get_ssb_version((uint8 *)&neul_result, version_string_length, version_string) != RPC_ERR_OK)
   1b99e:	000a      	movs	r2, r1
   1b9a0:	0001      	movs	r1, r0
   1b9a2:	0020      	movs	r0, r4
   1b9a4:	f7e9 fc1f 	bl	51e6 <command_get_ssb_version>
    {
        return NEUL_RET_ERROR_RPC;
   1b9a8:	2302      	movs	r3, #2
    if (command_get_ssb_version((uint8 *)&neul_result, version_string_length, version_string) != RPC_ERR_OK)
   1b9aa:	2800      	cmp	r0, #0
   1b9ac:	d100      	bne.n	1b9b0 <get_ssb_version+0x2a>
    }

    return neul_result;
   1b9ae:	7823      	ldrb	r3, [r4, #0]
}
   1b9b0:	0018      	movs	r0, r3
   1b9b2:	bd16      	pop	{r1, r2, r4, pc}

0001b9b4 <get_firmware_version>:
 * @param version_string SW version information(minimum size of 48 bytes).
 * @param buff_length the length of version_string buff(minimum 48 bytes).
 * @return NEUL_RET_OK or error value.
 */
NEUL_RET get_firmware_version(CORE_IMAGES cimage, uint16 *version_string_length, char *version_string, uint16 buff_length)
{
   1b9b4:	b573      	push	{r0, r1, r4, r5, r6, lr}
    NEUL_RET    neul_result  = NEUL_RET_OK;
   1b9b6:	2600      	movs	r6, #0
   1b9b8:	466c      	mov	r4, sp
   1b9ba:	1de5      	adds	r5, r4, #7
   1b9bc:	71e6      	strb	r6, [r4, #7]

    if ((version_string_length == NULL) || (version_string == NULL))
    {
        return NEUL_RET_ERROR;
   1b9be:	2401      	movs	r4, #1
    if ((version_string_length == NULL) || (version_string == NULL))
   1b9c0:	42b1      	cmp	r1, r6
   1b9c2:	d00d      	beq.n	1b9e0 <get_firmware_version+0x2c>
   1b9c4:	42b2      	cmp	r2, r6
   1b9c6:	d00b      	beq.n	1b9e0 <get_firmware_version+0x2c>
    }

    if (buff_length < MAX_VERSION_STRING)
   1b9c8:	2b2f      	cmp	r3, #47	; 0x2f
   1b9ca:	d909      	bls.n	1b9e0 <get_firmware_version+0x2c>
    {
        return NEUL_RET_ERROR;
    }

    *version_string_length = 0;
   1b9cc:	800e      	strh	r6, [r1, #0]

    if (command_get_firmware_version((uint8)cimage, (uint8 *)&neul_result, version_string_length, version_string) != RPC_ERR_OK)
   1b9ce:	0013      	movs	r3, r2
   1b9d0:	000a      	movs	r2, r1
   1b9d2:	0029      	movs	r1, r5
   1b9d4:	f7e9 fbce 	bl	5174 <command_get_firmware_version>
    {
        return NEUL_RET_ERROR_RPC;
   1b9d8:	1924      	adds	r4, r4, r4
    if (command_get_firmware_version((uint8)cimage, (uint8 *)&neul_result, version_string_length, version_string) != RPC_ERR_OK)
   1b9da:	42b0      	cmp	r0, r6
   1b9dc:	d100      	bne.n	1b9e0 <get_firmware_version+0x2c>
    }

    return neul_result;
   1b9de:	782c      	ldrb	r4, [r5, #0]
}
   1b9e0:	0020      	movs	r0, r4
   1b9e2:	bd76      	pop	{r1, r2, r4, r5, r6, pc}

0001b9e4 <get_rfconfig_version>:
/* @brief get the rf configuration version.
 * @param version_string 48-byte buffer to hold rf configuration version information
 * @return NEUL_RET_OK or error value.
 */
NEUL_RET get_rfconfig_version(char *version_string)
{
   1b9e4:	b513      	push	{r0, r1, r4, lr}
    NEUL_RET    neul_result  = NEUL_RET_OK;
   1b9e6:	466b      	mov	r3, sp
   1b9e8:	1ddc      	adds	r4, r3, #7
   1b9ea:	2300      	movs	r3, #0
{
   1b9ec:	0001      	movs	r1, r0
    NEUL_RET    neul_result  = NEUL_RET_OK;
   1b9ee:	7023      	strb	r3, [r4, #0]

    if (version_string== NULL)
    {
        return NEUL_RET_ERROR;
   1b9f0:	3301      	adds	r3, #1
    if (version_string== NULL)
   1b9f2:	2800      	cmp	r0, #0
   1b9f4:	d006      	beq.n	1ba04 <get_rfconfig_version+0x20>
    }

    if (command_get_rfconfig_version((uint8 *)&neul_result, version_string) != RPC_ERR_OK)
   1b9f6:	0020      	movs	r0, r4
   1b9f8:	f7e9 fc29 	bl	524e <command_get_rfconfig_version>
    {
        return NEUL_RET_ERROR_RPC;
   1b9fc:	2302      	movs	r3, #2
    if (command_get_rfconfig_version((uint8 *)&neul_result, version_string) != RPC_ERR_OK)
   1b9fe:	2800      	cmp	r0, #0
   1ba00:	d100      	bne.n	1ba04 <get_rfconfig_version+0x20>
    }

    return neul_result;
   1ba02:	7823      	ldrb	r3, [r4, #0]
}
   1ba04:	0018      	movs	r0, r3
   1ba06:	bd16      	pop	{r1, r2, r4, pc}

0001ba08 <get_imsi>:

/*
 * Return the IMSI number of the installed SIM (+CIMI?)
 */
NEUL_RET get_imsi( char *imsi, uint16 *imsi_len)
{
   1ba08:	b513      	push	{r0, r1, r4, lr}
    NEUL_RET rc = NEUL_RET_OK;
   1ba0a:	466b      	mov	r3, sp
   1ba0c:	1ddc      	adds	r4, r3, #7
   1ba0e:	2300      	movs	r3, #0
{
   1ba10:	0002      	movs	r2, r0
    NEUL_RET rc = NEUL_RET_OK;
   1ba12:	7023      	strb	r3, [r4, #0]

    if ((imsi_len != NULL) && (imsi != NULL))
   1ba14:	4299      	cmp	r1, r3
   1ba16:	d009      	beq.n	1ba2c <get_imsi+0x24>
   1ba18:	4298      	cmp	r0, r3
   1ba1a:	d007      	beq.n	1ba2c <get_imsi+0x24>
    {
        if (command_get_imsi(MAX_IMSI_LEN, imsi_len, imsi, (uint8*)&rc) != RPC_ERR_OK)
   1ba1c:	0023      	movs	r3, r4
   1ba1e:	2010      	movs	r0, #16
   1ba20:	f7e7 ff37 	bl	3892 <command_get_imsi>
   1ba24:	2800      	cmp	r0, #0
   1ba26:	d001      	beq.n	1ba2c <get_imsi+0x24>
        {
            rc = NEUL_RET_RETRY_LATER;
   1ba28:	2305      	movs	r3, #5
   1ba2a:	7023      	strb	r3, [r4, #0]
        }
    }

    return rc;
   1ba2c:	7820      	ldrb	r0, [r4, #0]
}
   1ba2e:	bd16      	pop	{r1, r2, r4, pc}

0001ba30 <get_iccid>:
 * @biref Return card identification of the installed SIM (+NCCID?/+NCCID)
 * @param iccid card identification to get, iccid len is CCID_PACKED_LENGTH
 * @param iccid_len iccid len
 */
NEUL_RET get_iccid( char *iccid , uint16 *iccid_len)
{
   1ba30:	b513      	push	{r0, r1, r4, lr}
    NEUL_RET rc = NEUL_RET_OK;
   1ba32:	466b      	mov	r3, sp
   1ba34:	1ddc      	adds	r4, r3, #7
   1ba36:	2300      	movs	r3, #0
{
   1ba38:	0002      	movs	r2, r0
    NEUL_RET rc = NEUL_RET_OK;
   1ba3a:	7023      	strb	r3, [r4, #0]
    
    if ((iccid != NULL) && (iccid_len != NULL))
   1ba3c:	4298      	cmp	r0, r3
   1ba3e:	d009      	beq.n	1ba54 <get_iccid+0x24>
   1ba40:	4299      	cmp	r1, r3
   1ba42:	d007      	beq.n	1ba54 <get_iccid+0x24>
    {
        if (command_get_iccid(CCID_PACKED_LENGTH, iccid_len, iccid, (uint8*)&rc) != RPC_ERR_OK)
   1ba44:	0023      	movs	r3, r4
   1ba46:	2014      	movs	r0, #20
   1ba48:	f7e9 f9cc 	bl	4de4 <command_get_iccid>
   1ba4c:	2800      	cmp	r0, #0
   1ba4e:	d001      	beq.n	1ba54 <get_iccid+0x24>
        {
            rc = NEUL_RET_ERROR;
   1ba50:	2301      	movs	r3, #1
   1ba52:	7023      	strb	r3, [r4, #0]
        }
    }

    return rc;
   1ba54:	7820      	ldrb	r0, [r4, #0]
}
   1ba56:	bd16      	pop	{r1, r2, r4, pc}

0001ba58 <get_dieid>:
 * @param dieid_length length of dieid data items returned
 * @param dieid a pointer to the pointer of a buffer of dieid
 * @return error or success
 */
NEUL_RET get_dieid(uint16 *dieid_length, uint8 **dieid)
{
   1ba58:	b573      	push	{r0, r1, r4, r5, r6, lr}
    uint8 get_dieid_result = NEUL_RET_ERROR;
   1ba5a:	466b      	mov	r3, sp
   1ba5c:	1dde      	adds	r6, r3, #7
   1ba5e:	2301      	movs	r3, #1
{
   1ba60:	0004      	movs	r4, r0
   1ba62:	000d      	movs	r5, r1
    uint8 get_dieid_result = NEUL_RET_ERROR;
   1ba64:	7033      	strb	r3, [r6, #0]
    RPC_ERR rpc_return_code;
    uint16 max_dieid_size = MAX_DIEID_LENGTH;

    if ((dieid_length == NULL) || (dieid == NULL))
    {
         return NEUL_RET_ERROR_IN_PARAMETERS;
   1ba66:	2203      	movs	r2, #3
    if ((dieid_length == NULL) || (dieid == NULL))
   1ba68:	2800      	cmp	r0, #0
   1ba6a:	d01b      	beq.n	1baa4 <get_dieid+0x4c>
   1ba6c:	2900      	cmp	r1, #0
   1ba6e:	d019      	beq.n	1baa4 <get_dieid+0x4c>
    }

    *dieid = (uint8*)irmalloc(MAX_DIEID_LENGTH);
   1ba70:	2040      	movs	r0, #64	; 0x40
   1ba72:	f7f6 ffc5 	bl	12a00 <irmalloc>
    if (*dieid == NULL)
    {
        return NEUL_RET_MEMORY_ERROR;
   1ba76:	220d      	movs	r2, #13
    *dieid = (uint8*)irmalloc(MAX_DIEID_LENGTH);
   1ba78:	1e03      	subs	r3, r0, #0
   1ba7a:	6028      	str	r0, [r5, #0]
    if (*dieid == NULL)
   1ba7c:	d012      	beq.n	1baa4 <get_dieid+0x4c>
    }

    rpc_return_code = command_get_dieid(&get_dieid_result, max_dieid_size, dieid_length, *dieid);
   1ba7e:	0022      	movs	r2, r4
   1ba80:	2140      	movs	r1, #64	; 0x40
   1ba82:	0030      	movs	r0, r6
   1ba84:	f7e7 fb32 	bl	30ec <command_get_dieid>
    if (*dieid_length > max_dieid_size)
   1ba88:	8823      	ldrh	r3, [r4, #0]
   1ba8a:	2b40      	cmp	r3, #64	; 0x40
   1ba8c:	d901      	bls.n	1ba92 <get_dieid+0x3a>
    {
        *dieid_length = max_dieid_size;
   1ba8e:	2340      	movs	r3, #64	; 0x40
   1ba90:	8023      	strh	r3, [r4, #0]
    }

    if (((NEUL_RET)get_dieid_result == NEUL_RET_OK) && (rpc_return_code == RPC_ERR_OK ))
   1ba92:	7832      	ldrb	r2, [r6, #0]
   1ba94:	2a00      	cmp	r2, #0
   1ba96:	d101      	bne.n	1ba9c <get_dieid+0x44>
   1ba98:	2800      	cmp	r0, #0
   1ba9a:	d003      	beq.n	1baa4 <get_dieid+0x4c>
    {
        return NEUL_RET_OK;//lint !e429
    }

    irfree(*dieid);
   1ba9c:	6828      	ldr	r0, [r5, #0]
   1ba9e:	f7f6 ffcb 	bl	12a38 <irfree>
    return NEUL_RET_ERROR;
   1baa2:	2201      	movs	r2, #1
}
   1baa4:	0010      	movs	r0, r2
   1baa6:	bd76      	pop	{r1, r2, r4, r5, r6, pc}

0001baa8 <free_dieid>:
 * @brief Free dieid buffer
 * @param dieid the pointer to a buffer of dieid
 * @return null
 */
void free_dieid(uint8 *dieid)
{
   1baa8:	b510      	push	{r4, lr}
    irfree(dieid);
   1baaa:	f7f6 ffc5 	bl	12a38 <irfree>
}
   1baae:	bd10      	pop	{r4, pc}

0001bab0 <neul_log_set_log_level>:
 * @param core  pointer to which core to set, security protocol ...
 * @param level pointer to which level to set
 * @return NEUL_RET_OK or error code
 */
NEUL_RET neul_log_set_log_level(CORES core, NEUL_LOG_LEVEL level)
{
   1bab0:	b513      	push	{r0, r1, r4, lr}
   1bab2:	0003      	movs	r3, r0
   1bab4:	0008      	movs	r0, r1
    NEUL_RET ret_value;
    if (core == CORES_APPS_CORE)
   1bab6:	2b02      	cmp	r3, #2
   1bab8:	d102      	bne.n	1bac0 <neul_log_set_log_level+0x10>
    {
#ifdef LIBLOG
        return log_set_local_log_level(level);
   1baba:	f7ea fe91 	bl	67e0 <log_set_local_log_level>
            }
        }

        return NEUL_RET_OK;
    }
}
   1babe:	bd16      	pop	{r1, r2, r4, pc}
   1bac0:	466a      	mov	r2, sp
   1bac2:	1dd4      	adds	r4, r2, #7
            if ((command_set_security_log_level((uint8)level, (uint8 *)&ret_value) != RPC_ERR_OK) || (ret_value != NEUL_RET_OK))
   1bac4:	0021      	movs	r1, r4
        if (core == CORES_SECURITY_CORE)
   1bac6:	2b00      	cmp	r3, #0
   1bac8:	d105      	bne.n	1bad6 <neul_log_set_log_level+0x26>
            if ((command_set_security_log_level((uint8)level, (uint8 *)&ret_value) != RPC_ERR_OK) || (ret_value != NEUL_RET_OK))
   1baca:	f7e7 fb99 	bl	3200 <command_set_security_log_level>
   1bace:	2800      	cmp	r0, #0
   1bad0:	d004      	beq.n	1badc <neul_log_set_log_level+0x2c>
                return NEUL_RET_ERROR;
   1bad2:	2001      	movs	r0, #1
   1bad4:	e7f3      	b.n	1babe <neul_log_set_log_level+0xe>
            if ((command_set_protocol_log_level((uint8)level, (uint8 *)&ret_value) != RPC_ERR_OK) || (ret_value != NEUL_RET_OK))
   1bad6:	f7e7 fb38 	bl	314a <command_set_protocol_log_level>
   1bada:	e7f8      	b.n	1bace <neul_log_set_log_level+0x1e>
   1badc:	7820      	ldrb	r0, [r4, #0]
   1bade:	1e43      	subs	r3, r0, #1
   1bae0:	4198      	sbcs	r0, r3
        return log_set_local_log_level(level);
   1bae2:	b2c0      	uxtb	r0, r0
   1bae4:	e7eb      	b.n	1babe <neul_log_set_log_level+0xe>

0001bae6 <neul_log_get_log_level>:
 * @param core  set the core ,which can be security protocol ...
 * @param level get the level
 * @return NEUL_RET_OK or error code
 */
NEUL_RET neul_log_get_log_level(CORES core, NEUL_LOG_LEVEL *level)
{
   1bae6:	b510      	push	{r4, lr}
   1bae8:	0003      	movs	r3, r0
   1baea:	000c      	movs	r4, r1
    if (level == NULL)
    {
        return NEUL_RET_ERROR;
   1baec:	2001      	movs	r0, #1
    if (level == NULL)
   1baee:	2900      	cmp	r1, #0
   1baf0:	d005      	beq.n	1bafe <neul_log_get_log_level+0x18>
    }

    if (core == CORES_APPS_CORE)
   1baf2:	2b02      	cmp	r3, #2
   1baf4:	d104      	bne.n	1bb00 <neul_log_get_log_level+0x1a>
    {
#ifdef LIBLOG
        *level = log_get_local_log_level();
   1baf6:	f7ea fe9d 	bl	6834 <log_get_local_log_level>
   1bafa:	7020      	strb	r0, [r4, #0]
            {
                return NEUL_RET_ERROR;
            }
        }
    }
    return NEUL_RET_OK;
   1bafc:	2000      	movs	r0, #0
}
   1bafe:	bd10      	pop	{r4, pc}
            if (command_get_security_log_level((uint8 *)level) != RPC_ERR_OK)
   1bb00:	0008      	movs	r0, r1
        if (core == CORES_SECURITY_CORE)
   1bb02:	2b00      	cmp	r3, #0
   1bb04:	d105      	bne.n	1bb12 <neul_log_get_log_level+0x2c>
            if (command_get_security_log_level((uint8 *)level) != RPC_ERR_OK)
   1bb06:	f7e7 fbcb 	bl	32a0 <command_get_security_log_level>
            if (command_get_protocol_log_level((uint8 *)level) != RPC_ERR_OK)
   1bb0a:	1e43      	subs	r3, r0, #1
   1bb0c:	4198      	sbcs	r0, r3
        return NEUL_RET_ERROR;
   1bb0e:	b2c0      	uxtb	r0, r0
   1bb10:	e7f5      	b.n	1bafe <neul_log_get_log_level+0x18>
            if (command_get_protocol_log_level((uint8 *)level) != RPC_ERR_OK)
   1bb12:	f7e7 fb9f 	bl	3254 <command_get_protocol_log_level>
   1bb16:	e7f8      	b.n	1bb0a <neul_log_get_log_level+0x24>

0001bb18 <set_time_zone_reporting>:
 * @brief Set time zone reporting when time zone changed.
 * @param reporting_set_callback callback for reporting
 */
void set_time_zone_reporting(neul_set_time_zone_reporting reporting_set_callback)
{
    time_zone_reporting_callback = reporting_set_callback;
   1bb18:	4b01      	ldr	r3, [pc, #4]	; (1bb20 <set_time_zone_reporting+0x8>)
   1bb1a:	6018      	str	r0, [r3, #0]
}
   1bb1c:	4770      	bx	lr
   1bb1e:	46c0      	nop			; (mov r8, r8)
   1bb20:	01002c08 	.word	0x01002c08

0001bb24 <remote_command_current_time_ind>:
 * @param current_time current time to save
 * @param time_zone expressed in quarters of an hour, between the local time and GMT; range -96...+96
 * @param daylight_saving_time uint is 1 hour
 */
void remote_command_current_time_ind(CORES core, uint64 current_time, int8 time_zone, uint8 daylight_saving_time, uint8 updated_time_fields)
{
   1bb24:	b5f0      	push	{r4, r5, r6, r7, lr}
   1bb26:	b087      	sub	sp, #28
   1bb28:	001f      	movs	r7, r3
   1bb2a:	ab0c      	add	r3, sp, #48	; 0x30
   1bb2c:	781b      	ldrb	r3, [r3, #0]
   1bb2e:	0016      	movs	r6, r2
   1bb30:	b25b      	sxtb	r3, r3
   1bb32:	9302      	str	r3, [sp, #8]
   1bb34:	ab0d      	add	r3, sp, #52	; 0x34
   1bb36:	781b      	ldrb	r3, [r3, #0]
   1bb38:	9303      	str	r3, [sp, #12]
   1bb3a:	ab0e      	add	r3, sp, #56	; 0x38
   1bb3c:	781b      	ldrb	r3, [r3, #0]
   1bb3e:	9304      	str	r3, [sp, #16]
    UNUSED(core);

    uint8                           origin_daylight_saving_time;
    int8                            origin_time_zone;
    neul_set_time_zone_reporting    callback = time_zone_reporting_callback;
   1bb40:	4b11      	ldr	r3, [pc, #68]	; (1bb88 <remote_command_current_time_ind+0x64>)
   1bb42:	681c      	ldr	r4, [r3, #0]

    origin_daylight_saving_time = rtc_get_daylight_saving_time();
   1bb44:	f7fc fe0e 	bl	18764 <rtc_get_daylight_saving_time>
   1bb48:	9005      	str	r0, [sp, #20]
    origin_time_zone            = rtc_get_time_zone();   
   1bb4a:	f7fc fe11 	bl	18770 <rtc_get_time_zone>

    rtc_set_current_time(current_time,  time_zone, daylight_saving_time, updated_time_fields);
   1bb4e:	9b04      	ldr	r3, [sp, #16]
    origin_time_zone            = rtc_get_time_zone();   
   1bb50:	0005      	movs	r5, r0
    rtc_set_current_time(current_time,  time_zone, daylight_saving_time, updated_time_fields);
   1bb52:	9300      	str	r3, [sp, #0]
   1bb54:	9a02      	ldr	r2, [sp, #8]
   1bb56:	9b03      	ldr	r3, [sp, #12]
   1bb58:	0030      	movs	r0, r6
   1bb5a:	0039      	movs	r1, r7
   1bb5c:	f7fc fd56 	bl	1860c <rtc_set_current_time>

    if (get_current_time() != 0)
   1bb60:	f7fc fdf6 	bl	18750 <get_current_time>
   1bb64:	2800      	cmp	r0, #0
   1bb66:	d005      	beq.n	1bb74 <remote_command_current_time_ind+0x50>
    {
        if ((origin_time_zone != rtc_get_time_zone() || origin_daylight_saving_time != rtc_get_daylight_saving_time())
   1bb68:	f7fc fe02 	bl	18770 <rtc_get_time_zone>
   1bb6c:	42a8      	cmp	r0, r5
   1bb6e:	d003      	beq.n	1bb78 <remote_command_current_time_ind+0x54>
        && callback != NULL)
   1bb70:	2c00      	cmp	r4, #0
   1bb72:	d107      	bne.n	1bb84 <remote_command_current_time_ind+0x60>
        {
            callback();
        }
    }
}
   1bb74:	b007      	add	sp, #28
   1bb76:	bdf0      	pop	{r4, r5, r6, r7, pc}
        if ((origin_time_zone != rtc_get_time_zone() || origin_daylight_saving_time != rtc_get_daylight_saving_time())
   1bb78:	f7fc fdf4 	bl	18764 <rtc_get_daylight_saving_time>
   1bb7c:	9b05      	ldr	r3, [sp, #20]
   1bb7e:	4298      	cmp	r0, r3
   1bb80:	d1f6      	bne.n	1bb70 <remote_command_current_time_ind+0x4c>
   1bb82:	e7f7      	b.n	1bb74 <remote_command_current_time_ind+0x50>
            callback();
   1bb84:	47a0      	blx	r4
}
   1bb86:	e7f5      	b.n	1bb74 <remote_command_current_time_ind+0x50>
   1bb88:	01002c08 	.word	0x01002c08

0001bb8c <remote_command_rf_calibration_rtc_ind>:
/**
 * indicates the rtc frequency value calibrated by rf
 * @param rtc_freq_calibrated_by_rf (calibrated RTC frequency in Hz) << 16
 */
void remote_command_rf_calibration_rtc_ind(CORES core, uint32 rtc_freq_calibrated_by_rf)
{
   1bb8c:	b510      	push	{r4, lr}
    UNUSED(core);
    rtc_rf_calibration_rtc(rtc_freq_calibrated_by_rf);
   1bb8e:	0008      	movs	r0, r1
   1bb90:	f7fc fd62 	bl	18658 <rtc_rf_calibration_rtc>
}
   1bb94:	bd10      	pop	{r4, pc}

0001bb96 <set_system_time_from_apps>:
 * @param daylight_saving_time daylight saving time, uint is 1 hour
 * @param updated_time_fields updated time field flags for current_time, time_zone, daylight_saving_time
 * @return NEUL_RET
 */
NEUL_RET set_system_time_from_apps(uint64 current_time, int8 time_zone, uint8 daylight_saving_time, uint8 updated_time_fields)
{
   1bb96:	b5f0      	push	{r4, r5, r6, r7, lr}
    NEUL_RET  result;

    if (command_set_system_time_from_apps(current_time, time_zone, daylight_saving_time, updated_time_fields, (uint8*)&result) != RPC_ERR_OK)
   1bb98:	270f      	movs	r7, #15
{
   1bb9a:	0015      	movs	r5, r2
   1bb9c:	b087      	sub	sp, #28
   1bb9e:	aa0c      	add	r2, sp, #48	; 0x30
   1bba0:	7816      	ldrb	r6, [r2, #0]
    if (command_set_system_time_from_apps(current_time, time_zone, daylight_saving_time, updated_time_fields, (uint8*)&result) != RPC_ERR_OK)
   1bba2:	aa02      	add	r2, sp, #8
   1bba4:	18bf      	adds	r7, r7, r2
   1bba6:	9701      	str	r7, [sp, #4]
   1bba8:	9600      	str	r6, [sp, #0]
   1bbaa:	002a      	movs	r2, r5
{
   1bbac:	9002      	str	r0, [sp, #8]
   1bbae:	9103      	str	r1, [sp, #12]
    if (command_set_system_time_from_apps(current_time, time_zone, daylight_saving_time, updated_time_fields, (uint8*)&result) != RPC_ERR_OK)
   1bbb0:	f7e8 fb2b 	bl	420a <command_set_system_time_from_apps>
    {
        return NEUL_RET_ERROR_RPC;
   1bbb4:	2402      	movs	r4, #2
    if (command_set_system_time_from_apps(current_time, time_zone, daylight_saving_time, updated_time_fields, (uint8*)&result) != RPC_ERR_OK)
   1bbb6:	2800      	cmp	r0, #0
   1bbb8:	d109      	bne.n	1bbce <set_system_time_from_apps+0x38>
    }

    if (result != NEUL_RET_OK)
   1bbba:	783c      	ldrb	r4, [r7, #0]
   1bbbc:	2c00      	cmp	r4, #0
   1bbbe:	d106      	bne.n	1bbce <set_system_time_from_apps+0x38>
    {
        return result;
    }

    rtc_set_current_time(current_time, time_zone, 0, updated_time_fields);
   1bbc0:	9802      	ldr	r0, [sp, #8]
   1bbc2:	9903      	ldr	r1, [sp, #12]
   1bbc4:	9600      	str	r6, [sp, #0]
   1bbc6:	0023      	movs	r3, r4
   1bbc8:	002a      	movs	r2, r5
   1bbca:	f7fc fd1f 	bl	1860c <rtc_set_current_time>

    return NEUL_RET_OK;
}
   1bbce:	0020      	movs	r0, r4
   1bbd0:	b007      	add	sp, #28
   1bbd2:	bdf0      	pop	{r4, r5, r6, r7, pc}

0001bbd4 <set_time_update_mode>:
 * @brief set time update mode
 * @param time_update_mode time update mode to set
 * @return NEUL_RET_ERROR_RPC or NEUL_RET_OK
 */
NEUL_RET set_time_update_mode(TIME_UPDATE_MODE time_update_mode)
{
   1bbd4:	b510      	push	{r4, lr}
    if (command_set_time_update_mode((uint8)time_update_mode) != RPC_ERR_OK)
   1bbd6:	f7e8 fb51 	bl	427c <command_set_time_update_mode>
    {
        return NEUL_RET_ERROR_RPC;
    }

    return NEUL_RET_OK;
   1bbda:	1e43      	subs	r3, r0, #1
   1bbdc:	4198      	sbcs	r0, r3
   1bbde:	0040      	lsls	r0, r0, #1
}
   1bbe0:	bd10      	pop	{r4, pc}

0001bbe2 <get_time_update_mode>:
 * @brief get time update mode
 * @param network_time_update_mode time update mode to get
 * @return NEUL_RET_ERROR_RPC or NEUL_RET_OK
 */
NEUL_RET get_time_update_mode(TIME_UPDATE_MODE *time_update_mode)
{
   1bbe2:	b510      	push	{r4, lr}
    if (command_get_time_update_mode((uint8*)time_update_mode) != RPC_ERR_OK)
   1bbe4:	f7e8 fb67 	bl	42b6 <command_get_time_update_mode>
    {
        return NEUL_RET_ERROR_RPC;
    }

    return NEUL_RET_OK;
   1bbe8:	1e43      	subs	r3, r0, #1
   1bbea:	4198      	sbcs	r0, r3
   1bbec:	0040      	lsls	r0, r0, #1
}
   1bbee:	bd10      	pop	{r4, pc}

0001bbf0 <nonip_set_cp_only_message_received_callback>:
 * @brief Sets a callback that will be triggered when new NonIP message via cp arrives
 * @param callback The callback function
 */
void nonip_set_cp_only_message_received_callback(neul_nonip_received_callback callback)
{
    nonip_cp_only_callback = callback;
   1bbf0:	4b01      	ldr	r3, [pc, #4]	; (1bbf8 <nonip_set_cp_only_message_received_callback+0x8>)
   1bbf2:	6018      	str	r0, [r3, #0]
}
   1bbf4:	4770      	bx	lr
   1bbf6:	46c0      	nop			; (mov r8, r8)
   1bbf8:	01002c0c 	.word	0x01002c0c

0001bbfc <nonip_set_message_received_callback>:
 * @brief Sets a callback that will be triggered when new NonIP message arrives
 * @param callback The callback function
 */
void nonip_set_message_received_callback(neul_nonip_received_callback callback)
{
    nonip_received_callback = callback;
   1bbfc:	4b01      	ldr	r3, [pc, #4]	; (1bc04 <nonip_set_message_received_callback+0x8>)
   1bbfe:	6018      	str	r0, [r3, #0]
}
   1bc00:	4770      	bx	lr
   1bc02:	46c0      	nop			; (mov r8, r8)
   1bc04:	01002c10 	.word	0x01002c10

0001bc08 <remote_command_nonip_recvfrom>:

void remote_command_nonip_recvfrom(CORES core, uint8 cid, uint16 length, uint8 *message, bool cplane_pdu)
{
   1bc08:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
   1bc0a:	001e      	movs	r6, r3
   1bc0c:	ab06      	add	r3, sp, #24
   1bc0e:	0015      	movs	r5, r2
   1bc10:	000c      	movs	r4, r1
   1bc12:	781a      	ldrb	r2, [r3, #0]

    /* safely call callback */
    neul_nonip_received_callback  cp_only_callback = nonip_cp_only_callback;
    neul_nonip_received_callback  callback = nonip_received_callback;

    if(message == NULL || cid > NEUL_MAX_CID || length == 0 || length > NEUL_NONIP_MTU_SIZE)
   1bc14:	2e00      	cmp	r6, #0
   1bc16:	d018      	beq.n	1bc4a <remote_command_nonip_recvfrom+0x42>
   1bc18:	290a      	cmp	r1, #10
   1bc1a:	d816      	bhi.n	1bc4a <remote_command_nonip_recvfrom+0x42>
   1bc1c:	1e6b      	subs	r3, r5, #1
   1bc1e:	490b      	ldr	r1, [pc, #44]	; (1bc4c <remote_command_nonip_recvfrom+0x44>)
   1bc20:	b29b      	uxth	r3, r3
   1bc22:	428b      	cmp	r3, r1
   1bc24:	d811      	bhi.n	1bc4a <remote_command_nonip_recvfrom+0x42>
    neul_nonip_received_callback  cp_only_callback = nonip_cp_only_callback;
   1bc26:	4b0a      	ldr	r3, [pc, #40]	; (1bc50 <remote_command_nonip_recvfrom+0x48>)
    neul_nonip_received_callback  callback = nonip_received_callback;
   1bc28:	490a      	ldr	r1, [pc, #40]	; (1bc54 <remote_command_nonip_recvfrom+0x4c>)
    neul_nonip_received_callback  cp_only_callback = nonip_cp_only_callback;
   1bc2a:	681b      	ldr	r3, [r3, #0]
    neul_nonip_received_callback  callback = nonip_received_callback;
   1bc2c:	680f      	ldr	r7, [r1, #0]
    {
        return;
    }

    if (cp_only_callback != NULL && cplane_pdu)
   1bc2e:	2b00      	cmp	r3, #0
   1bc30:	d005      	beq.n	1bc3e <remote_command_nonip_recvfrom+0x36>
   1bc32:	2a00      	cmp	r2, #0
   1bc34:	d003      	beq.n	1bc3e <remote_command_nonip_recvfrom+0x36>
    {
        cp_only_callback(cid, length, message);
   1bc36:	0032      	movs	r2, r6
   1bc38:	0029      	movs	r1, r5
   1bc3a:	0020      	movs	r0, r4
   1bc3c:	4798      	blx	r3
    }

    if (callback != NULL)
   1bc3e:	2f00      	cmp	r7, #0
   1bc40:	d003      	beq.n	1bc4a <remote_command_nonip_recvfrom+0x42>
    {
        callback(cid, length, message);
   1bc42:	0032      	movs	r2, r6
   1bc44:	0029      	movs	r1, r5
   1bc46:	0020      	movs	r0, r4
   1bc48:	47b8      	blx	r7
    }

}//lint !e818
   1bc4a:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
   1bc4c:	0000054d 	.word	0x0000054d
   1bc50:	01002c0c 	.word	0x01002c0c
   1bc54:	01002c10 	.word	0x01002c10

0001bc58 <nonip_sendto>:
 * @param length Message length
 * @param flags Socket type
 * @return error or success
 */
NEUL_RET nonip_sendto(uint8 cid, const void *message, uint16 length, uint32 flags)
{
   1bc58:	b57f      	push	{r0, r1, r2, r3, r4, r5, r6, lr}
   1bc5a:	0016      	movs	r6, r2
    NEUL_RET ret;
    if(NULL == message)
    {
        return NEUL_RET_ERROR;
   1bc5c:	2401      	movs	r4, #1
    if(NULL == message)
   1bc5e:	2900      	cmp	r1, #0
   1bc60:	d00a      	beq.n	1bc78 <nonip_sendto+0x20>
    }
    if(command_nonip_sendto(cid, (uint16) length, (uint8 *) message, flags,  (uint8 *) &ret) != RPC_ERR_OK)
   1bc62:	250f      	movs	r5, #15
   1bc64:	446d      	add	r5, sp
   1bc66:	000a      	movs	r2, r1
   1bc68:	9500      	str	r5, [sp, #0]
   1bc6a:	0031      	movs	r1, r6
   1bc6c:	f7e9 fc06 	bl	547c <command_nonip_sendto>
   1bc70:	2800      	cmp	r0, #0
   1bc72:	d000      	beq.n	1bc76 <nonip_sendto+0x1e>
    {
        ret = NEUL_RET_ERROR;
   1bc74:	702c      	strb	r4, [r5, #0]
    }
   
    return ret;
   1bc76:	782c      	ldrb	r4, [r5, #0]
}
   1bc78:	0020      	movs	r0, r4
   1bc7a:	b004      	add	sp, #16
   1bc7c:	bd70      	pop	{r4, r5, r6, pc}
	...

0001bc80 <set_non_ip_sent_callback>:
 * set callbacks for non ip data sent
 * @param non-ip sent_notify_callback non-ip data sent result callback
 */
void set_non_ip_sent_callback(non_ip_sent_notify non_ip_sent_notify_callback)
{
    nonip_sent_data_result_callback = non_ip_sent_notify_callback;
   1bc80:	4b01      	ldr	r3, [pc, #4]	; (1bc88 <set_non_ip_sent_callback+0x8>)
   1bc82:	6018      	str	r0, [r3, #0]
}
   1bc84:	4770      	bx	lr
   1bc86:	46c0      	nop			; (mov r8, r8)
   1bc88:	01002c14 	.word	0x01002c14

0001bc8c <remote_command_non_ip_data_sent>:

void remote_command_non_ip_data_sent(CORES core, uint16 data_seq, bool status)
{
   1bc8c:	b510      	push	{r4, lr}
    UNUSED(core);

    non_ip_sent_notify nonip_data_status_callback = nonip_sent_data_result_callback;
   1bc8e:	4b04      	ldr	r3, [pc, #16]	; (1bca0 <remote_command_non_ip_data_sent+0x14>)
{
   1bc90:	0008      	movs	r0, r1
    non_ip_sent_notify nonip_data_status_callback = nonip_sent_data_result_callback;
   1bc92:	681b      	ldr	r3, [r3, #0]

    // data_seq composition:
    // 0 - 7 bit  : sequence number.
    // 8 - 16 bit : index (0xFF means non-ip cp only data sent result ,0xEF means non-ip data via cp or up sent result)
    if (nonip_data_status_callback != NULL)
   1bc94:	2b00      	cmp	r3, #0
   1bc96:	d001      	beq.n	1bc9c <remote_command_non_ip_data_sent+0x10>
    {
        nonip_data_status_callback(data_seq, status);
   1bc98:	0011      	movs	r1, r2
   1bc9a:	4798      	blx	r3
    }
}
   1bc9c:	bd10      	pop	{r4, pc}
   1bc9e:	46c0      	nop			; (mov r8, r8)
   1bca0:	01002c14 	.word	0x01002c14

0001bca4 <production_execute_radiotest>:
* @param test_data radiotest command
* @param callback radio test result callback
* @return error or success
*/
NEUL_RET production_execute_radiotest(uint16 length, uint8 *test_data, radio_test_callback callback)
{
   1bca4:	b573      	push	{r0, r1, r4, r5, r6, lr}
   1bca6:	0015      	movs	r5, r2
    NEUL_RET radio_test_result;

    if ((test_data == NULL) || (callback == NULL))
   1bca8:	2900      	cmp	r1, #0
   1bcaa:	d102      	bne.n	1bcb2 <production_execute_radiotest+0xe>
    {
        return NEUL_RET_ERROR;
   1bcac:	2301      	movs	r3, #1

        return NEUL_RET_IN_PROGRESS;
    }

    return radio_test_result;
}
   1bcae:	0018      	movs	r0, r3
   1bcb0:	bd76      	pop	{r1, r2, r4, r5, r6, pc}
    if ((test_data == NULL) || (callback == NULL))
   1bcb2:	2a00      	cmp	r2, #0
   1bcb4:	d0fa      	beq.n	1bcac <production_execute_radiotest+0x8>
    if (rdtest_callback != NULL)
   1bcb6:	4c08      	ldr	r4, [pc, #32]	; (1bcd8 <production_execute_radiotest+0x34>)
        return NEUL_RET_IN_PROGRESS;
   1bcb8:	2309      	movs	r3, #9
    if (rdtest_callback != NULL)
   1bcba:	6822      	ldr	r2, [r4, #0]
   1bcbc:	2a00      	cmp	r2, #0
   1bcbe:	d1f6      	bne.n	1bcae <production_execute_radiotest+0xa>
    if (command_execute_radiotest(length, test_data, (uint8 *)&radio_test_result) != RPC_ERR_OK)
   1bcc0:	466b      	mov	r3, sp
   1bcc2:	1dde      	adds	r6, r3, #7
   1bcc4:	0032      	movs	r2, r6
   1bcc6:	f7e7 fd06 	bl	36d6 <command_execute_radiotest>
   1bcca:	2800      	cmp	r0, #0
   1bccc:	d1ee      	bne.n	1bcac <production_execute_radiotest+0x8>
    if (radio_test_result == NEUL_RET_IN_PROGRESS)
   1bcce:	7833      	ldrb	r3, [r6, #0]
   1bcd0:	2b09      	cmp	r3, #9
   1bcd2:	d1ec      	bne.n	1bcae <production_execute_radiotest+0xa>
        rdtest_callback = callback;
   1bcd4:	6025      	str	r5, [r4, #0]
        return NEUL_RET_IN_PROGRESS;
   1bcd6:	e7ea      	b.n	1bcae <production_execute_radiotest+0xa>
   1bcd8:	01002c1c 	.word	0x01002c1c

0001bcdc <remote_command_radiotest_response>:

void remote_command_radiotest_response(CORES core, uint8 retcode, uint16 retdata_length, uint8 *retdata)
{
   1bcdc:	b570      	push	{r4, r5, r6, lr}
    UNUSED(core);

    /* safely call callback */
    radio_test_callback callback = rdtest_callback;
   1bcde:	4c07      	ldr	r4, [pc, #28]	; (1bcfc <remote_command_radiotest_response+0x20>)
{
   1bce0:	000d      	movs	r5, r1
    radio_test_callback callback = rdtest_callback;
   1bce2:	6826      	ldr	r6, [r4, #0]
{
   1bce4:	0011      	movs	r1, r2

    if(callback == NULL)
   1bce6:	2e00      	cmp	r6, #0
   1bce8:	d006      	beq.n	1bcf8 <remote_command_radiotest_response+0x1c>
    {
        return;
    }

    callback(retcode, retdata_length, retdata);
   1bcea:	001a      	movs	r2, r3
   1bcec:	0028      	movs	r0, r5
   1bcee:	47b0      	blx	r6
    if ((RADIO_TEST_RET)retcode != RADIO_TEST_RET_NOT_COMPLETE)
   1bcf0:	2d04      	cmp	r5, #4
   1bcf2:	d001      	beq.n	1bcf8 <remote_command_radiotest_response+0x1c>
    {
        rdtest_callback = NULL;
   1bcf4:	2300      	movs	r3, #0
   1bcf6:	6023      	str	r3, [r4, #0]
    }
}//lint !e818
   1bcf8:	bd70      	pop	{r4, r5, r6, pc}
   1bcfa:	46c0      	nop			; (mov r8, r8)
   1bcfc:	01002c1c 	.word	0x01002c1c

0001bd00 <production_radio_config_ctrl>:
 * @brief rf config control command
 * @param cmd control command
 * @return success or failure
 */
NEUL_RET production_radio_config_ctrl(RF_CONFIG_CTRL_CMD cmd)
{
   1bd00:	b513      	push	{r0, r1, r4, lr}
    NEUL_RET result;

    if (command_rf_config_ctrl(cmd, (uint8 *)&result) != RPC_ERR_OK)
   1bd02:	466b      	mov	r3, sp
   1bd04:	1ddc      	adds	r4, r3, #7
   1bd06:	0021      	movs	r1, r4
   1bd08:	f7e8 fbef 	bl	44ea <command_rf_config_ctrl>
    {
        return NEUL_RET_ERROR;
   1bd0c:	2301      	movs	r3, #1
    if (command_rf_config_ctrl(cmd, (uint8 *)&result) != RPC_ERR_OK)
   1bd0e:	2800      	cmp	r0, #0
   1bd10:	d100      	bne.n	1bd14 <production_radio_config_ctrl+0x14>
    }

    return result;
   1bd12:	7823      	ldrb	r3, [r4, #0]
}
   1bd14:	0018      	movs	r0, r3
   1bd16:	bd16      	pop	{r1, r2, r4, pc}

0001bd18 <production_radio_config_meas_rssi>:
 * @param rssi Gain of the receiver in centibels at the input of the DSP
 * @param snr Signal to noise ratio in dB
 * @param port corresponding to the RX port
 */
NEUL_RET production_radio_config_meas_rssi(uint32 frequency, uint8 gain_index, int16 *rssi, int16 *snr, uint8 port)
{
   1bd18:	b57f      	push	{r0, r1, r2, r3, r4, r5, r6, lr}
   1bd1a:	ac08      	add	r4, sp, #32
   1bd1c:	7825      	ldrb	r5, [r4, #0]
    NEUL_RET result = NEUL_RET_OK;
   1bd1e:	240f      	movs	r4, #15
   1bd20:	2600      	movs	r6, #0
   1bd22:	446c      	add	r4, sp
   1bd24:	7026      	strb	r6, [r4, #0]

    if ((rssi == NULL) || (snr == NULL))
   1bd26:	42b2      	cmp	r2, r6
   1bd28:	d001      	beq.n	1bd2e <production_radio_config_meas_rssi+0x16>
   1bd2a:	42b3      	cmp	r3, r6
   1bd2c:	d104      	bne.n	1bd38 <production_radio_config_meas_rssi+0x20>
    {
        result = NEUL_RET_ERROR;
   1bd2e:	2301      	movs	r3, #1
   1bd30:	7023      	strb	r3, [r4, #0]
        {
            result =  NEUL_RET_ERROR;
        }
    }

    return result;
   1bd32:	7820      	ldrb	r0, [r4, #0]
}
   1bd34:	b004      	add	sp, #16
   1bd36:	bd70      	pop	{r4, r5, r6, pc}
        if (command_radio_config_meas_rssi(frequency, gain_index, port, (uint8 *)&result, rssi, snr) != RPC_ERR_OK)
   1bd38:	9301      	str	r3, [sp, #4]
   1bd3a:	9200      	str	r2, [sp, #0]
   1bd3c:	0023      	movs	r3, r4
   1bd3e:	002a      	movs	r2, r5
   1bd40:	f7e8 fbfc 	bl	453c <command_radio_config_meas_rssi>
   1bd44:	2800      	cmp	r0, #0
   1bd46:	d1f2      	bne.n	1bd2e <production_radio_config_meas_rssi+0x16>
   1bd48:	e7f3      	b.n	1bd32 <production_radio_config_meas_rssi+0x1a>

0001bd4a <production_radio_config_read_mipi_word>:
 * @param data_addr  mipi slave register data address
 * @param data       mipi slave register data to read/write
 * @return success or failure
 */
NEUL_RET production_radio_config_read_mipi_word(uint8 slave_addr, uint8 data_addr, uint8* data)
{
   1bd4a:	b513      	push	{r0, r1, r4, lr}
   1bd4c:	0013      	movs	r3, r2
    NEUL_RET result = NEUL_RET_OK;
   1bd4e:	466a      	mov	r2, sp
   1bd50:	1dd4      	adds	r4, r2, #7
   1bd52:	2200      	movs	r2, #0
   1bd54:	7022      	strb	r2, [r4, #0]

    if (data == NULL)
   1bd56:	4293      	cmp	r3, r2
   1bd58:	d103      	bne.n	1bd62 <production_radio_config_read_mipi_word+0x18>
    {
        result = NEUL_RET_ERROR;
   1bd5a:	2301      	movs	r3, #1
   1bd5c:	7023      	strb	r3, [r4, #0]
        {
            result =  NEUL_RET_ERROR;
        }
    }

    return result;
   1bd5e:	7820      	ldrb	r0, [r4, #0]
}
   1bd60:	bd16      	pop	{r1, r2, r4, pc}
        if (command_radio_config_read_mipi_word(slave_addr, data_addr, (uint8 *)&result, data) != RPC_ERR_OK)
   1bd62:	0022      	movs	r2, r4
   1bd64:	f7e8 fc2d 	bl	45c2 <command_radio_config_read_mipi_word>
   1bd68:	2800      	cmp	r0, #0
   1bd6a:	d1f6      	bne.n	1bd5a <production_radio_config_read_mipi_word+0x10>
   1bd6c:	e7f7      	b.n	1bd5e <production_radio_config_read_mipi_word+0x14>

0001bd6e <production_radio_config_write_mipi_word>:
 * @param data_addr  mipi slave register data address
 * @param data       mipi slave register data to read/write
 * @return success or failure
 */
NEUL_RET production_radio_config_write_mipi_word(uint8 slave_addr, uint8 data_addr, uint8 data)
{
   1bd6e:	b513      	push	{r0, r1, r4, lr}
    NEUL_RET result = NEUL_RET_OK;
   1bd70:	466b      	mov	r3, sp
   1bd72:	1ddc      	adds	r4, r3, #7
   1bd74:	2300      	movs	r3, #0
   1bd76:	7023      	strb	r3, [r4, #0]

    if (command_radio_config_write_mipi_word(slave_addr, data_addr, data, (uint8 *)&result) != RPC_ERR_OK)
   1bd78:	0023      	movs	r3, r4
   1bd7a:	f7e8 fc5b 	bl	4634 <command_radio_config_write_mipi_word>
   1bd7e:	2800      	cmp	r0, #0
   1bd80:	d001      	beq.n	1bd86 <production_radio_config_write_mipi_word+0x18>
    {
        result =  NEUL_RET_ERROR;
   1bd82:	2301      	movs	r3, #1
   1bd84:	7023      	strb	r3, [r4, #0]
    }

    return result;
   1bd86:	7820      	ldrb	r0, [r4, #0]
}
   1bd88:	bd16      	pop	{r1, r2, r4, pc}

0001bd8a <production_radio_config_tx_tone>:
 * @param frequency Frequency of the carrier to transmit (Hz)
 * @param level RF level (units TBD)
 * @return the result of the set frequency.
 */
NEUL_RET production_radio_config_tx_tone(uint32 frequency)
{
   1bd8a:	b513      	push	{r0, r1, r4, lr}
    NEUL_RET result = NEUL_RET_OK;
   1bd8c:	466b      	mov	r3, sp
   1bd8e:	1ddc      	adds	r4, r3, #7
   1bd90:	2300      	movs	r3, #0

    if (command_radio_config_tx_tone(frequency, (uint8 *)&result) != RPC_ERR_OK)
   1bd92:	0021      	movs	r1, r4
    NEUL_RET result = NEUL_RET_OK;
   1bd94:	7023      	strb	r3, [r4, #0]
    if (command_radio_config_tx_tone(frequency, (uint8 *)&result) != RPC_ERR_OK)
   1bd96:	f7e8 fc83 	bl	46a0 <command_radio_config_tx_tone>
   1bd9a:	2800      	cmp	r0, #0
   1bd9c:	d001      	beq.n	1bda2 <production_radio_config_tx_tone+0x18>
    {
        result =  NEUL_RET_ERROR;
   1bd9e:	2301      	movs	r3, #1
   1bda0:	7023      	strb	r3, [r4, #0]
    }

    return result;
   1bda2:	7820      	ldrb	r0, [r4, #0]
}
   1bda4:	bd16      	pop	{r1, r2, r4, pc}

0001bda6 <production_radio_config_set_tx_gains>:
 * @param rf_gain RF gain setting, 0:63
 * @param mv voltage in mv
 *  to control an external SMPS for external Power Amplifier, 0:123
 */
NEUL_RET production_radio_config_set_tx_gains(uint16 tx_drive_level, uint8 tx_coarse_gain, uint8 rf_gain, uint16 mv)
{
   1bda6:	b530      	push	{r4, r5, lr}
    NEUL_RET result = NEUL_RET_OK;
   1bda8:	240f      	movs	r4, #15
   1bdaa:	2500      	movs	r5, #0
{
   1bdac:	b085      	sub	sp, #20
    NEUL_RET result = NEUL_RET_OK;
   1bdae:	446c      	add	r4, sp
   1bdb0:	7025      	strb	r5, [r4, #0]
    if (command_radio_config_set_tx_gains(tx_drive_level, tx_coarse_gain, rf_gain, mv, (uint8 *)&result) != RPC_ERR_OK)
   1bdb2:	9400      	str	r4, [sp, #0]
   1bdb4:	f7e8 fc9d 	bl	46f2 <command_radio_config_set_tx_gains>
   1bdb8:	42a8      	cmp	r0, r5
   1bdba:	d001      	beq.n	1bdc0 <production_radio_config_set_tx_gains+0x1a>
    {
        result = NEUL_RET_ERROR;
   1bdbc:	2301      	movs	r3, #1
   1bdbe:	7023      	strb	r3, [r4, #0]
    }
    return result;
   1bdc0:	7820      	ldrb	r0, [r4, #0]
}
   1bdc2:	b005      	add	sp, #20
   1bdc4:	bd30      	pop	{r4, r5, pc}

0001bdc6 <production_radio_config_get_tx_gains>:
 * @brief get current RF TX configuration of gain levels
 * @param max_size_tx_gains max buffer size
 * @param tx_gains gain levels for RF TX configuration to get
 */
NEUL_RET production_radio_config_get_tx_gains(uint16 *tx_drive_level, uint8 *tx_coarse_gain, uint8 *rf_gain, uint16 *ext_pa_gain)
{
   1bdc6:	b530      	push	{r4, r5, lr}
    NEUL_RET result = NEUL_RET_OK;
   1bdc8:	240f      	movs	r4, #15
   1bdca:	2500      	movs	r5, #0
{
   1bdcc:	b085      	sub	sp, #20
    NEUL_RET result = NEUL_RET_OK;
   1bdce:	446c      	add	r4, sp
   1bdd0:	7025      	strb	r5, [r4, #0]

    if ((tx_drive_level == NULL) || (tx_coarse_gain == NULL) || (rf_gain == NULL) || (ext_pa_gain == NULL))
   1bdd2:	42a8      	cmp	r0, r5
   1bdd4:	d005      	beq.n	1bde2 <production_radio_config_get_tx_gains+0x1c>
   1bdd6:	42a9      	cmp	r1, r5
   1bdd8:	d003      	beq.n	1bde2 <production_radio_config_get_tx_gains+0x1c>
   1bdda:	42aa      	cmp	r2, r5
   1bddc:	d001      	beq.n	1bde2 <production_radio_config_get_tx_gains+0x1c>
   1bdde:	42ab      	cmp	r3, r5
   1bde0:	d104      	bne.n	1bdec <production_radio_config_get_tx_gains+0x26>
    {
        result = NEUL_RET_ERROR;
   1bde2:	2301      	movs	r3, #1
   1bde4:	7023      	strb	r3, [r4, #0]
        {
            result = NEUL_RET_ERROR;
        }
    }

    return result;
   1bde6:	7820      	ldrb	r0, [r4, #0]
}
   1bde8:	b005      	add	sp, #20
   1bdea:	bd30      	pop	{r4, r5, pc}
        if (command_radio_config_get_tx_gains((uint8 *)&result, tx_drive_level, tx_coarse_gain, rf_gain, ext_pa_gain) != RPC_ERR_OK)
   1bdec:	9300      	str	r3, [sp, #0]
   1bdee:	0013      	movs	r3, r2
   1bdf0:	000a      	movs	r2, r1
   1bdf2:	0001      	movs	r1, r0
   1bdf4:	0020      	movs	r0, r4
   1bdf6:	f7e8 fcb6 	bl	4766 <command_radio_config_get_tx_gains>
   1bdfa:	2800      	cmp	r0, #0
   1bdfc:	d1f1      	bne.n	1bde2 <production_radio_config_get_tx_gains+0x1c>
   1bdfe:	e7f2      	b.n	1bde6 <production_radio_config_get_tx_gains+0x20>

0001be00 <production_radio_config_set_rio_v>:
 * @brief set up radio AIO for calibration tests
 * @param rio select aio to be used This is the integer number of the RIO/AIO
 * @param voltage in mv
 */
NEUL_RET production_radio_config_set_rio_v(uint8 rio, uint16 mv)
{
   1be00:	b513      	push	{r0, r1, r4, lr}
    NEUL_RET result = NEUL_RET_OK;
   1be02:	466b      	mov	r3, sp
   1be04:	1ddc      	adds	r4, r3, #7
   1be06:	2300      	movs	r3, #0

    if (command_radio_config_set_rio_v(rio, mv, (uint8 *)&result) != RPC_ERR_OK)
   1be08:	0022      	movs	r2, r4
    NEUL_RET result = NEUL_RET_OK;
   1be0a:	7023      	strb	r3, [r4, #0]
    if (command_radio_config_set_rio_v(rio, mv, (uint8 *)&result) != RPC_ERR_OK)
   1be0c:	f7e8 fced 	bl	47ea <command_radio_config_set_rio_v>
   1be10:	2800      	cmp	r0, #0
   1be12:	d001      	beq.n	1be18 <production_radio_config_set_rio_v+0x18>
    {
        result = NEUL_RET_ERROR;
   1be14:	2301      	movs	r3, #1
   1be16:	7023      	strb	r3, [r4, #0]
    }

    return result;
   1be18:	7820      	ldrb	r0, [r4, #0]
}
   1be1a:	bd16      	pop	{r1, r2, r4, pc}

0001be1c <production_radio_config_set_gpio>:
 * @brief Set up Radio PIOs for calibration tests
 * @param pio bit mask specifying which pios are set
 * @return success or failure
 */
NEUL_RET production_radio_config_set_gpio(uint64 pio)
{
   1be1c:	b513      	push	{r0, r1, r4, lr}
    NEUL_RET result = NEUL_RET_OK;
   1be1e:	466b      	mov	r3, sp
   1be20:	1ddc      	adds	r4, r3, #7
   1be22:	2300      	movs	r3, #0

    if (command_radio_config_set_gpio(pio, (uint8 *)&result) != RPC_ERR_OK)
   1be24:	0022      	movs	r2, r4
    NEUL_RET result = NEUL_RET_OK;
   1be26:	7023      	strb	r3, [r4, #0]
    if (command_radio_config_set_gpio(pio, (uint8 *)&result) != RPC_ERR_OK)
   1be28:	f7e8 fd10 	bl	484c <command_radio_config_set_gpio>
   1be2c:	2800      	cmp	r0, #0
   1be2e:	d001      	beq.n	1be34 <production_radio_config_set_gpio+0x18>
    {
        result = NEUL_RET_ERROR;
   1be30:	2301      	movs	r3, #1
   1be32:	7023      	strb	r3, [r4, #0]
    }

    return result;
   1be34:	7820      	ldrb	r0, [r4, #0]
}
   1be36:	bd16      	pop	{r1, r2, r4, pc}

0001be38 <production_radio_config_tx_verify>:
 * @param voltage voltage that should be used as a lookup value in the voltage gain compensation table
 * @param num_subcarrier Number of subcarriers
 * @param subcarrier_index Position of subcarrier
 */
NEUL_RET production_radio_config_tx_verify(int8 tx_power, uint32 tx_frequency, uint32 tx_duration, uint8 tx_band, int16 temperature, int16 voltage, uint8 num_subcarrier, uint8 subcarrier_index)
{
   1be38:	b5f0      	push	{r4, r5, r6, r7, lr}
   1be3a:	b08b      	sub	sp, #44	; 0x2c
   1be3c:	ac10      	add	r4, sp, #64	; 0x40
   1be3e:	9307      	str	r3, [sp, #28]
   1be40:	2300      	movs	r3, #0
   1be42:	5ee5      	ldrsh	r5, [r4, r3]
   1be44:	ac11      	add	r4, sp, #68	; 0x44
   1be46:	2300      	movs	r3, #0
   1be48:	5ee6      	ldrsh	r6, [r4, r3]
   1be4a:	ac12      	add	r4, sp, #72	; 0x48
   1be4c:	7827      	ldrb	r7, [r4, #0]
   1be4e:	ac13      	add	r4, sp, #76	; 0x4c
   1be50:	7824      	ldrb	r4, [r4, #0]
    NEUL_RET result;

    if (command_radio_config_tx_verify(tx_power, tx_frequency, tx_duration, tx_band, temperature,
   1be52:	ab02      	add	r3, sp, #8
{
   1be54:	46a4      	mov	ip, r4
    if (command_radio_config_tx_verify(tx_power, tx_frequency, tx_duration, tx_band, temperature,
   1be56:	241f      	movs	r4, #31
   1be58:	18e4      	adds	r4, r4, r3
   1be5a:	4663      	mov	r3, ip
   1be5c:	9404      	str	r4, [sp, #16]
   1be5e:	9303      	str	r3, [sp, #12]
   1be60:	9702      	str	r7, [sp, #8]
   1be62:	9b07      	ldr	r3, [sp, #28]
   1be64:	9601      	str	r6, [sp, #4]
   1be66:	9500      	str	r5, [sp, #0]
   1be68:	f7e9 fa73 	bl	5352 <command_radio_config_tx_verify>
        voltage, num_subcarrier, subcarrier_index, (uint8 *)&result) != RPC_ERR_OK)
    {
        return NEUL_RET_ERROR;
   1be6c:	2301      	movs	r3, #1
    if (command_radio_config_tx_verify(tx_power, tx_frequency, tx_duration, tx_band, temperature,
   1be6e:	2800      	cmp	r0, #0
   1be70:	d100      	bne.n	1be74 <production_radio_config_tx_verify+0x3c>
    }

    return result;
   1be72:	7823      	ldrb	r3, [r4, #0]
}
   1be74:	0018      	movs	r0, r3
   1be76:	b00b      	add	sp, #44	; 0x2c
   1be78:	bdf0      	pop	{r4, r5, r6, r7, pc}

0001be7a <production_radio_config_tx_calist>:
 * @param num_subcarrier Number of subcarriers
 * @param subcarrier_index Position of subcarrier
 * @return success or failure
 */
NEUL_RET production_radio_config_tx_calist(uint32 start_frequency, uint32 step_frequency, uint32 stop_frequency, int8 start_power, int8 step_power, int8 stop_power, uint8 num_subcarrier, uint8 subcarrier_index)
{
   1be7a:	b5f0      	push	{r4, r5, r6, r7, lr}
   1be7c:	2500      	movs	r5, #0
   1be7e:	2600      	movs	r6, #0
   1be80:	b08b      	sub	sp, #44	; 0x2c
   1be82:	9307      	str	r3, [sp, #28]
   1be84:	ac10      	add	r4, sp, #64	; 0x40
   1be86:	5765      	ldrsb	r5, [r4, r5]
   1be88:	ac11      	add	r4, sp, #68	; 0x44
   1be8a:	57a6      	ldrsb	r6, [r4, r6]
   1be8c:	ac12      	add	r4, sp, #72	; 0x48
   1be8e:	7827      	ldrb	r7, [r4, #0]
   1be90:	ac13      	add	r4, sp, #76	; 0x4c
   1be92:	7824      	ldrb	r4, [r4, #0]
    NEUL_RET result;

    if (command_radio_config_tx_calist(start_frequency, step_frequency, stop_frequency, start_power, step_power, stop_power, num_subcarrier, subcarrier_index, (uint8 *)&result) != RPC_ERR_OK)
   1be94:	ab02      	add	r3, sp, #8
{
   1be96:	46a4      	mov	ip, r4
    if (command_radio_config_tx_calist(start_frequency, step_frequency, stop_frequency, start_power, step_power, stop_power, num_subcarrier, subcarrier_index, (uint8 *)&result) != RPC_ERR_OK)
   1be98:	241f      	movs	r4, #31
   1be9a:	18e4      	adds	r4, r4, r3
   1be9c:	4663      	mov	r3, ip
   1be9e:	9404      	str	r4, [sp, #16]
   1bea0:	9303      	str	r3, [sp, #12]
   1bea2:	9702      	str	r7, [sp, #8]
   1bea4:	9b07      	ldr	r3, [sp, #28]
   1bea6:	9601      	str	r6, [sp, #4]
   1bea8:	9500      	str	r5, [sp, #0]
   1beaa:	f7ea fa9a 	bl	63e2 <command_radio_config_tx_calist>
    {
        return NEUL_RET_ERROR;
   1beae:	2301      	movs	r3, #1
    if (command_radio_config_tx_calist(start_frequency, step_frequency, stop_frequency, start_power, step_power, stop_power, num_subcarrier, subcarrier_index, (uint8 *)&result) != RPC_ERR_OK)
   1beb0:	2800      	cmp	r0, #0
   1beb2:	d100      	bne.n	1beb6 <production_radio_config_tx_calist+0x3c>
    }

    return result;
   1beb4:	7823      	ldrb	r3, [r4, #0]
}
   1beb6:	0018      	movs	r0, r3
   1beb8:	b00b      	add	sp, #44	; 0x2c
   1beba:	bdf0      	pop	{r4, r5, r6, r7, pc}

0001bebc <production_radio_config_rx_calist>:
 * @param sweep_band Measured band
 * @param nrdexec_rxlist_callback Rx calibration callback function
 * @return success or failure
 */
NEUL_RET production_radio_config_rx_calist(uint32 start_frequency, uint32 step_frequency, uint32 stop_frequency, uint8 start_agc_index, uint8 step_agc_index, uint8 stop_agc_index, int16 ul_power, uint32 ul_freq, uint32 rssi_meas_duration, uint8 sweep_band, radio_test_callback callback)
{
   1bebc:	b5f0      	push	{r4, r5, r6, r7, lr}
   1bebe:	b08d      	sub	sp, #52	; 0x34
   1bec0:	ac12      	add	r4, sp, #72	; 0x48
   1bec2:	7824      	ldrb	r4, [r4, #0]
    NEUL_RET result;

    if(rdexec_rxlist_callback != NULL)
   1bec4:	4d15      	ldr	r5, [pc, #84]	; (1bf1c <production_radio_config_rx_calist+0x60>)
{
   1bec6:	9408      	str	r4, [sp, #32]
   1bec8:	ac13      	add	r4, sp, #76	; 0x4c
   1beca:	7824      	ldrb	r4, [r4, #0]
    if(rdexec_rxlist_callback != NULL)
   1becc:	682e      	ldr	r6, [r5, #0]
{
   1bece:	9409      	str	r4, [sp, #36]	; 0x24
   1bed0:	ac14      	add	r4, sp, #80	; 0x50
   1bed2:	2700      	movs	r7, #0
   1bed4:	5fe7      	ldrsh	r7, [r4, r7]
   1bed6:	ac17      	add	r4, sp, #92	; 0x5c
   1bed8:	7824      	ldrb	r4, [r4, #0]
   1beda:	46a4      	mov	ip, r4
    {
        return NEUL_RET_IN_PROGRESS;
   1bedc:	2409      	movs	r4, #9
    if(rdexec_rxlist_callback != NULL)
   1bede:	2e00      	cmp	r6, #0
   1bee0:	d118      	bne.n	1bf14 <production_radio_config_rx_calist+0x58>
    }
    if (command_radio_config_rx_calist(start_frequency, step_frequency, stop_frequency, start_agc_index, step_agc_index, stop_agc_index, ul_power, ul_freq, rssi_meas_duration, sweep_band, (uint8 *)&result) != RPC_ERR_OK)
   1bee2:	ac02      	add	r4, sp, #8
   1bee4:	3627      	adds	r6, #39	; 0x27
   1bee6:	1936      	adds	r6, r6, r4
   1bee8:	4664      	mov	r4, ip
   1beea:	9405      	str	r4, [sp, #20]
   1beec:	9c16      	ldr	r4, [sp, #88]	; 0x58
   1beee:	9606      	str	r6, [sp, #24]
   1bef0:	9404      	str	r4, [sp, #16]
   1bef2:	9c15      	ldr	r4, [sp, #84]	; 0x54
   1bef4:	9702      	str	r7, [sp, #8]
   1bef6:	9403      	str	r4, [sp, #12]
   1bef8:	9c09      	ldr	r4, [sp, #36]	; 0x24
   1befa:	9401      	str	r4, [sp, #4]
   1befc:	9c08      	ldr	r4, [sp, #32]
   1befe:	9400      	str	r4, [sp, #0]
   1bf00:	f7ea fab2 	bl	6468 <command_radio_config_rx_calist>
    {
        return NEUL_RET_ERROR;
   1bf04:	2401      	movs	r4, #1
    if (command_radio_config_rx_calist(start_frequency, step_frequency, stop_frequency, start_agc_index, step_agc_index, stop_agc_index, ul_power, ul_freq, rssi_meas_duration, sweep_band, (uint8 *)&result) != RPC_ERR_OK)
   1bf06:	2800      	cmp	r0, #0
   1bf08:	d104      	bne.n	1bf14 <production_radio_config_rx_calist+0x58>
    }

    if(result == NEUL_RET_IN_PROGRESS_BLOCK)
   1bf0a:	7834      	ldrb	r4, [r6, #0]
   1bf0c:	2c1b      	cmp	r4, #27
   1bf0e:	d101      	bne.n	1bf14 <production_radio_config_rx_calist+0x58>
    {
       rdexec_rxlist_callback = callback;
   1bf10:	9b18      	ldr	r3, [sp, #96]	; 0x60
   1bf12:	602b      	str	r3, [r5, #0]
    }

    return result;
}
   1bf14:	0020      	movs	r0, r4
   1bf16:	b00d      	add	sp, #52	; 0x34
   1bf18:	bdf0      	pop	{r4, r5, r6, r7, pc}
   1bf1a:	46c0      	nop			; (mov r8, r8)
   1bf1c:	01002c18 	.word	0x01002c18

0001bf20 <remote_command_rxcalist_response>:


void remote_command_rxcalist_response(CORES core, uint8 retcode, uint16 retdata_length, uint8 *retdata)
{
   1bf20:	b570      	push	{r4, r5, r6, lr}
    UNUSED(core);

    /* safely call callback */
    radio_test_callback callback = rdexec_rxlist_callback;
   1bf22:	4d06      	ldr	r5, [pc, #24]	; (1bf3c <remote_command_rxcalist_response+0x1c>)
{
   1bf24:	000c      	movs	r4, r1
    radio_test_callback callback = rdexec_rxlist_callback;
   1bf26:	682e      	ldr	r6, [r5, #0]
{
   1bf28:	0011      	movs	r1, r2

    if(callback == NULL)
   1bf2a:	2e00      	cmp	r6, #0
   1bf2c:	d005      	beq.n	1bf3a <remote_command_rxcalist_response+0x1a>
    {
        return;
    }

    callback(retcode, retdata_length, retdata);
   1bf2e:	001a      	movs	r2, r3
   1bf30:	0020      	movs	r0, r4
   1bf32:	47b0      	blx	r6
    if ((RADIO_TEST_RET)retcode == RADIO_TEST_RET_OK)
   1bf34:	2c00      	cmp	r4, #0
   1bf36:	d100      	bne.n	1bf3a <remote_command_rxcalist_response+0x1a>
    {
        rdexec_rxlist_callback = NULL;
   1bf38:	602c      	str	r4, [r5, #0]
    }
} //lint !e818
   1bf3a:	bd70      	pop	{r4, r5, r6, pc}
   1bf3c:	01002c18 	.word	0x01002c18

0001bf40 <production_radio_config_rx_verify>:
 * @param snr Signal to noise ratio in fixed point (Q7.8) dB to get
 * @param cbm received signal level in cBm to get
 * @return success or error
 */
NEUL_RET production_radio_config_rx_verify(uint32 frequency, uint8 gain_index, uint8 band, int16 temperature, int16 voltage, int16 *rssi, int16* snr, int16* cbm)
{
   1bf40:	b5f0      	push	{r4, r5, r6, r7, lr}
   1bf42:	b089      	sub	sp, #36	; 0x24
   1bf44:	ac0e      	add	r4, sp, #56	; 0x38
   1bf46:	2700      	movs	r7, #0
   1bf48:	5fe7      	ldrsh	r7, [r4, r7]
   1bf4a:	9c0f      	ldr	r4, [sp, #60]	; 0x3c
   1bf4c:	9d10      	ldr	r5, [sp, #64]	; 0x40
   1bf4e:	9e11      	ldr	r6, [sp, #68]	; 0x44
    NEUL_RET result;

    if (rssi == NULL || snr == NULL || cbm == NULL)
   1bf50:	2c00      	cmp	r4, #0
   1bf52:	d102      	bne.n	1bf5a <production_radio_config_rx_verify+0x1a>
    {
        return NEUL_RET_ERROR;
   1bf54:	2001      	movs	r0, #1
    {
        return NEUL_RET_ERROR;
    }

    return result;
}
   1bf56:	b009      	add	sp, #36	; 0x24
   1bf58:	bdf0      	pop	{r4, r5, r6, r7, pc}
    if (rssi == NULL || snr == NULL || cbm == NULL)
   1bf5a:	2d00      	cmp	r5, #0
   1bf5c:	d0fa      	beq.n	1bf54 <production_radio_config_rx_verify+0x14>
   1bf5e:	2e00      	cmp	r6, #0
   1bf60:	d0f8      	beq.n	1bf54 <production_radio_config_rx_verify+0x14>
    if (command_radio_config_rx_verify(frequency, gain_index,
   1bf62:	9402      	str	r4, [sp, #8]
   1bf64:	241f      	movs	r4, #31
   1bf66:	446c      	add	r4, sp
   1bf68:	9604      	str	r6, [sp, #16]
   1bf6a:	9503      	str	r5, [sp, #12]
   1bf6c:	9401      	str	r4, [sp, #4]
   1bf6e:	9700      	str	r7, [sp, #0]
   1bf70:	f7e9 fa35 	bl	53de <command_radio_config_rx_verify>
   1bf74:	2800      	cmp	r0, #0
   1bf76:	d1ed      	bne.n	1bf54 <production_radio_config_rx_verify+0x14>
    return result;
   1bf78:	7820      	ldrb	r0, [r4, #0]
   1bf7a:	e7ec      	b.n	1bf56 <production_radio_config_rx_verify+0x16>

0001bf7c <production_radio_config_get_gpio>:
/**
 * @brief get Radio PIOs for calibration tests
 * @param pio bit mask specifying which pios are set
 */
NEUL_RET production_radio_config_get_gpio(uint64 *pio)
{
   1bf7c:	b537      	push	{r0, r1, r2, r4, r5, lr}
    NEUL_RET result = NEUL_RET_OK;
   1bf7e:	466b      	mov	r3, sp
   1bf80:	1ddc      	adds	r4, r3, #7
   1bf82:	2300      	movs	r3, #0
{
   1bf84:	0005      	movs	r5, r0

    if (command_radio_config_get_gpio((uint8 *)&result, pio) != RPC_ERR_OK || pio == NULL)
   1bf86:	0001      	movs	r1, r0
   1bf88:	0020      	movs	r0, r4
    NEUL_RET result = NEUL_RET_OK;
   1bf8a:	7023      	strb	r3, [r4, #0]
    if (command_radio_config_get_gpio((uint8 *)&result, pio) != RPC_ERR_OK || pio == NULL)
   1bf8c:	f7e8 fc89 	bl	48a2 <command_radio_config_get_gpio>
   1bf90:	2800      	cmp	r0, #0
   1bf92:	d101      	bne.n	1bf98 <production_radio_config_get_gpio+0x1c>
   1bf94:	2d00      	cmp	r5, #0
   1bf96:	d101      	bne.n	1bf9c <production_radio_config_get_gpio+0x20>
    {
        result = NEUL_RET_ERROR;
   1bf98:	2301      	movs	r3, #1
   1bf9a:	7023      	strb	r3, [r4, #0]
    }

    return result;
   1bf9c:	7820      	ldrb	r0, [r4, #0]
}
   1bf9e:	bd3e      	pop	{r1, r2, r3, r4, r5, pc}

0001bfa0 <production_radio_config_tx_test>:
 * @param tx_band EUTRA band number
 * @param num_subcarrier Number of subcarriers
 * @param subcarrier_index Position of subcarrier
 */
NEUL_RET production_radio_config_tx_test(uint32 frequency, uint8 tx_band, uint8 num_subcarrier, uint8 subcarrier_index)
{
   1bfa0:	b51f      	push	{r0, r1, r2, r3, r4, lr}
    NEUL_RET     result;

    if (command_radio_config_tx_test(frequency, tx_band, num_subcarrier, subcarrier_index, (uint8*)&result) != RPC_ERR_OK)
   1bfa2:	240f      	movs	r4, #15
   1bfa4:	446c      	add	r4, sp
   1bfa6:	9400      	str	r4, [sp, #0]
   1bfa8:	f7e9 fc86 	bl	58b8 <command_radio_config_tx_test>
   1bfac:	2800      	cmp	r0, #0
   1bfae:	d001      	beq.n	1bfb4 <production_radio_config_tx_test+0x14>
    {
        result = NEUL_RET_ERROR;
   1bfb0:	2301      	movs	r3, #1
   1bfb2:	7023      	strb	r3, [r4, #0]
    }

    return result;
   1bfb4:	7820      	ldrb	r0, [r4, #0]
}
   1bfb6:	b004      	add	sp, #16
   1bfb8:	bd10      	pop	{r4, pc}

0001bfba <production_calibrate_temperature>:
/**
 * @brief calibrate_temperature.
 * @param temperature  current temperature in degrees deciCelsius
 */
NEUL_RET production_calibrate_temperature(int16 temperature_dC)
{
   1bfba:	b513      	push	{r0, r1, r4, lr}
    NEUL_RET     result;

    if (command_calibrate_temperature(temperature_dC, (uint8*)&result) != RPC_ERR_OK)
   1bfbc:	466b      	mov	r3, sp
   1bfbe:	1ddc      	adds	r4, r3, #7
   1bfc0:	0021      	movs	r1, r4
   1bfc2:	f7e9 fe67 	bl	5c94 <command_calibrate_temperature>
   1bfc6:	2800      	cmp	r0, #0
   1bfc8:	d001      	beq.n	1bfce <production_calibrate_temperature+0x14>
    {
        result = NEUL_RET_ERROR;
   1bfca:	2301      	movs	r3, #1
   1bfcc:	7023      	strb	r3, [r4, #0]
    }

    return result;
   1bfce:	7820      	ldrb	r0, [r4, #0]
}
   1bfd0:	bd16      	pop	{r1, r2, r4, pc}

0001bfd2 <set_plmn_search_range>:
 * @param end      end freq
 * @param pci physical cell ID
 * @return error or success
 */
NEUL_RET set_plmn_search_range(uint16 search_mode, uint32 earfcn_start, uint32 earfcn_end, uint16 pci)
{
   1bfd2:	b51f      	push	{r0, r1, r2, r3, r4, lr}
    NEUL_RET plmn_search_result;
    if(command_set_earfcn_range(search_mode, earfcn_start, earfcn_end, pci, (uint8 *)&plmn_search_result) != RPC_ERR_OK)
   1bfd4:	240f      	movs	r4, #15
   1bfd6:	446c      	add	r4, sp
   1bfd8:	9400      	str	r4, [sp, #0]
   1bfda:	f7e7 fa8d 	bl	34f8 <command_set_earfcn_range>
    {
        return NEUL_RET_ERROR;
   1bfde:	2301      	movs	r3, #1
    if(command_set_earfcn_range(search_mode, earfcn_start, earfcn_end, pci, (uint8 *)&plmn_search_result) != RPC_ERR_OK)
   1bfe0:	2800      	cmp	r0, #0
   1bfe2:	d100      	bne.n	1bfe6 <set_plmn_search_range+0x14>
    }

    return plmn_search_result;
   1bfe4:	7823      	ldrb	r3, [r4, #0]
}
   1bfe6:	0018      	movs	r0, r3
   1bfe8:	b004      	add	sp, #16
   1bfea:	bd10      	pop	{r4, pc}

0001bfec <clear_stored_earfcn>:
/**
 * @brief clear stored earfcn from rrc nv
 * @return error or success
 */
NEUL_RET clear_stored_earfcn(void)
{
   1bfec:	b513      	push	{r0, r1, r4, lr}
    NEUL_RET result;
    if (command_clear_stored_earfcn((uint8 *)&result) != RPC_ERR_OK)
   1bfee:	466b      	mov	r3, sp
   1bff0:	1ddc      	adds	r4, r3, #7
   1bff2:	0020      	movs	r0, r4
   1bff4:	f7e7 fab9 	bl	356a <command_clear_stored_earfcn>
    {
        return NEUL_RET_ERROR_RPC;
   1bff8:	2302      	movs	r3, #2
    if (command_clear_stored_earfcn((uint8 *)&result) != RPC_ERR_OK)
   1bffa:	2800      	cmp	r0, #0
   1bffc:	d100      	bne.n	1c000 <clear_stored_earfcn+0x14>
    }

    return result;
   1bffe:	7823      	ldrb	r3, [r4, #0]
}
   1c000:	0018      	movs	r0, r3
   1c002:	bd16      	pop	{r1, r2, r4, pc}

0001c004 <set_plmn_state>:
 * @param plmn
 * @param callback:callback for set plmn state result
 * @return error or success
 */
NEUL_RET set_plmn_state(uint16 plmn_mode, uint8 plmn[3], neul_set_plmn_state_callback callback)
{
   1c004:	b537      	push	{r0, r1, r2, r4, r5, lr}
    NEUL_RET plmn_select_result;

    if (command_execute_plmn_select(plmn_mode, plmn, (uint8 *)&plmn_select_result) == RPC_ERR_OK)
   1c006:	466b      	mov	r3, sp
   1c008:	1ddc      	adds	r4, r3, #7
{
   1c00a:	0015      	movs	r5, r2
    if (command_execute_plmn_select(plmn_mode, plmn, (uint8 *)&plmn_select_result) == RPC_ERR_OK)
   1c00c:	0022      	movs	r2, r4
   1c00e:	f7e7 fb92 	bl	3736 <command_execute_plmn_select>
        }

        return plmn_select_result;
    }

    return NEUL_RET_ERROR;
   1c012:	2301      	movs	r3, #1
    if (command_execute_plmn_select(plmn_mode, plmn, (uint8 *)&plmn_select_result) == RPC_ERR_OK)
   1c014:	2800      	cmp	r0, #0
   1c016:	d104      	bne.n	1c022 <set_plmn_state+0x1e>
        if (plmn_select_result == NEUL_RET_OK)
   1c018:	7823      	ldrb	r3, [r4, #0]
   1c01a:	2b00      	cmp	r3, #0
   1c01c:	d101      	bne.n	1c022 <set_plmn_state+0x1e>
            set_plmn_state_callback = callback;
   1c01e:	4a02      	ldr	r2, [pc, #8]	; (1c028 <set_plmn_state+0x24>)
   1c020:	6015      	str	r5, [r2, #0]
}
   1c022:	0018      	movs	r0, r3
   1c024:	bd3e      	pop	{r1, r2, r3, r4, r5, pc}
   1c026:	46c0      	nop			; (mov r8, r8)
   1c028:	01002c60 	.word	0x01002c60

0001c02c <get_plmn_state>:
 * @param current_mode
 * @param current_plmn, {0xff, 0xff, 0xff} means invalid plmn.
 * @return success or error
 */
NEUL_RET get_plmn_state(uint8 *current_mode, uint8 *current_plmn)
{
   1c02c:	b510      	push	{r4, lr}
    if ((current_plmn == NULL) || (current_mode == NULL))
    {
        return NEUL_RET_ERROR;
   1c02e:	2301      	movs	r3, #1
    if ((current_plmn == NULL) || (current_mode == NULL))
   1c030:	2900      	cmp	r1, #0
   1c032:	d006      	beq.n	1c042 <get_plmn_state+0x16>
   1c034:	2800      	cmp	r0, #0
   1c036:	d004      	beq.n	1c042 <get_plmn_state+0x16>
    }

    //We shouldn't need the AcT since it should always be the same for us
    if (command_get_plmn_status(current_mode, current_plmn) != RPC_ERR_OK)
   1c038:	f7e7 fbad 	bl	3796 <command_get_plmn_status>
   1c03c:	1e43      	subs	r3, r0, #1
   1c03e:	4198      	sbcs	r0, r3
        return NEUL_RET_ERROR;
   1c040:	b2c3      	uxtb	r3, r0
    {
        return NEUL_RET_ERROR;
    }

    return NEUL_RET_OK;
}
   1c042:	0018      	movs	r0, r3
   1c044:	bd10      	pop	{r4, pc}
	...

0001c048 <get_available_plmn>:
/** Get available plmn (+COPS=?)
 * @param callback The function to call with the available plmn search ind
 * @return NEUL_RET
 */
NEUL_RET get_available_plmn(neul_get_available_plmn_callback available_plmn_callback)
{
   1c048:	b537      	push	{r0, r1, r2, r4, r5, lr}
    NEUL_RET result;

    if (command_get_available_plmn((uint8*)&result) != RPC_ERR_OK)
   1c04a:	466b      	mov	r3, sp
   1c04c:	1ddc      	adds	r4, r3, #7
{
   1c04e:	0005      	movs	r5, r0
    if (command_get_available_plmn((uint8*)&result) != RPC_ERR_OK)
   1c050:	0020      	movs	r0, r4
   1c052:	f7e7 fbce 	bl	37f2 <command_get_available_plmn>
    {
        return NEUL_RET_ERROR;
   1c056:	2301      	movs	r3, #1
    if (command_get_available_plmn((uint8*)&result) != RPC_ERR_OK)
   1c058:	2800      	cmp	r0, #0
   1c05a:	d104      	bne.n	1c066 <get_available_plmn+0x1e>
    }

    if (result == NEUL_RET_IN_PROGRESS_BLOCK)
   1c05c:	7823      	ldrb	r3, [r4, #0]
   1c05e:	2b1b      	cmp	r3, #27
   1c060:	d101      	bne.n	1c066 <get_available_plmn+0x1e>
    {
        get_available_plmn_callback = available_plmn_callback;
   1c062:	4a02      	ldr	r2, [pc, #8]	; (1c06c <get_available_plmn+0x24>)
   1c064:	6015      	str	r5, [r2, #0]
    }

    return result;
}
   1c066:	0018      	movs	r0, r3
   1c068:	bd3e      	pop	{r1, r2, r3, r4, r5, pc}
   1c06a:	46c0      	nop			; (mov r8, r8)
   1c06c:	01002c34 	.word	0x01002c34

0001c070 <set_service_state>:
 * @param attach_state  1: attach, 0: detach
 * @param callback:callback for set service state result
 * @return success, error or in progress indicator
 */
NEUL_RET set_service_state(uint16 attach_state, neul_attach_callback callback)
{
   1c070:	b537      	push	{r0, r1, r2, r4, r5, lr}
    NEUL_RET set_result;

    if(command_set_attach_state(attach_state, (uint8 *) &set_result) == RPC_ERR_OK)
   1c072:	466b      	mov	r3, sp
   1c074:	1ddc      	adds	r4, r3, #7
{
   1c076:	000d      	movs	r5, r1
    if(command_set_attach_state(attach_state, (uint8 *) &set_result) == RPC_ERR_OK)
   1c078:	0021      	movs	r1, r4
   1c07a:	f7e7 fbe0 	bl	383e <command_set_attach_state>
        }

        return set_result;
    }

    return NEUL_RET_ERROR;
   1c07e:	2301      	movs	r3, #1
    if(command_set_attach_state(attach_state, (uint8 *) &set_result) == RPC_ERR_OK)
   1c080:	2800      	cmp	r0, #0
   1c082:	d104      	bne.n	1c08e <set_service_state+0x1e>
        if(set_result == NEUL_RET_OK)
   1c084:	7823      	ldrb	r3, [r4, #0]
   1c086:	2b00      	cmp	r3, #0
   1c088:	d101      	bne.n	1c08e <set_service_state+0x1e>
            attach_callback  = callback;
   1c08a:	4a02      	ldr	r2, [pc, #8]	; (1c094 <set_service_state+0x24>)
   1c08c:	6015      	str	r5, [r2, #0]
}
   1c08e:	0018      	movs	r0, r3
   1c090:	bd3e      	pop	{r1, r2, r3, r4, r5, pc}
   1c092:	46c0      	nop			; (mov r8, r8)
   1c094:	01002c20 	.word	0x01002c20

0001c098 <remote_command_attach_status_set_result_ind>:

void remote_command_attach_status_set_result_ind(CORES core, uint8 service_set_result)
{
   1c098:	b510      	push	{r4, lr}
    UNUSED(core);

    /* safely call callback */
    neul_attach_callback callback = attach_callback;
   1c09a:	4b03      	ldr	r3, [pc, #12]	; (1c0a8 <remote_command_attach_status_set_result_ind+0x10>)
   1c09c:	681b      	ldr	r3, [r3, #0]
    if (callback != NULL)
   1c09e:	2b00      	cmp	r3, #0
   1c0a0:	d001      	beq.n	1c0a6 <remote_command_attach_status_set_result_ind+0xe>
    {
        callback((NEUL_RET)service_set_result);
   1c0a2:	0008      	movs	r0, r1
   1c0a4:	4798      	blx	r3
    }
}
   1c0a6:	bd10      	pop	{r4, pc}
   1c0a8:	01002c20 	.word	0x01002c20

0001c0ac <remote_command_plmn_select_result_ind>:

void remote_command_plmn_select_result_ind(CORES core, uint8 plmn_select_result)
{
   1c0ac:	b510      	push	{r4, lr}
    UNUSED(core);

    /* safely call callback */
    neul_set_plmn_state_callback callback = set_plmn_state_callback;
   1c0ae:	4b03      	ldr	r3, [pc, #12]	; (1c0bc <remote_command_plmn_select_result_ind+0x10>)
   1c0b0:	681b      	ldr	r3, [r3, #0]
    if (callback != NULL)
   1c0b2:	2b00      	cmp	r3, #0
   1c0b4:	d001      	beq.n	1c0ba <remote_command_plmn_select_result_ind+0xe>
    {
        callback((NEUL_RET)plmn_select_result);
   1c0b6:	0008      	movs	r0, r1
   1c0b8:	4798      	blx	r3
    }
}
   1c0ba:	bd10      	pop	{r4, pc}
   1c0bc:	01002c60 	.word	0x01002c60

0001c0c0 <remote_command_pin_result_ind>:

void remote_command_pin_result_ind(CORES core, uint8 pin_result, uint8 retries_remaining)
{
   1c0c0:	b510      	push	{r4, lr}
    UNUSED(core);

    /* safely call callback */
    neul_pin_command_callback callback = pin_command_callback;
   1c0c2:	4b04      	ldr	r3, [pc, #16]	; (1c0d4 <remote_command_pin_result_ind+0x14>)
{
   1c0c4:	0008      	movs	r0, r1
    neul_pin_command_callback callback = pin_command_callback;
   1c0c6:	681b      	ldr	r3, [r3, #0]
    if (callback != NULL)
   1c0c8:	2b00      	cmp	r3, #0
   1c0ca:	d001      	beq.n	1c0d0 <remote_command_pin_result_ind+0x10>
    {
        callback(pin_result, retries_remaining);
   1c0cc:	0011      	movs	r1, r2
   1c0ce:	4798      	blx	r3
    }
}
   1c0d0:	bd10      	pop	{r4, pc}
   1c0d2:	46c0      	nop			; (mov r8, r8)
   1c0d4:	01002c4c 	.word	0x01002c4c

0001c0d8 <remote_command_pin_status_ind>:

void remote_command_pin_status_ind(CORES core, uint8 pin_status)
{
   1c0d8:	b510      	push	{r4, lr}
    UNUSED(core);

    /* safely call callback */
    neul_sim_pin_ind_callback callback = sim_pin_ind_call_back;
   1c0da:	4b03      	ldr	r3, [pc, #12]	; (1c0e8 <remote_command_pin_status_ind+0x10>)
   1c0dc:	681b      	ldr	r3, [r3, #0]
    if (callback != NULL)
   1c0de:	2b00      	cmp	r3, #0
   1c0e0:	d001      	beq.n	1c0e6 <remote_command_pin_status_ind+0xe>
    {
        callback(pin_status);
   1c0e2:	0008      	movs	r0, r1
   1c0e4:	4798      	blx	r3
    }
}
   1c0e6:	bd10      	pop	{r4, pc}
   1c0e8:	01002c68 	.word	0x01002c68

0001c0ec <get_service_state>:
/**
 * @brief get service state
 * @param state  1: attached, 0: detached
 */
NEUL_RET get_service_state(uint8 *state)
{
   1c0ec:	b510      	push	{r4, lr}
    if (command_read_service_status(state) != RPC_ERR_OK)
   1c0ee:	f7e7 fe5f 	bl	3db0 <command_read_service_status>
   1c0f2:	1e43      	subs	r3, r0, #1
   1c0f4:	4198      	sbcs	r0, r3
    {
        return NEUL_RET_ERROR;
    }

    return NEUL_RET_OK;
}
   1c0f6:	b2c0      	uxtb	r0, r0
   1c0f8:	bd10      	pop	{r4, pc}
	...

0001c0fc <get_csq>:
/**
 * @brief Get signal strength indicator
 * @return     signal strength in decimal of 0 to 99
 */
NEUL_RET get_csq(uint8 *csq)
{
   1c0fc:	b530      	push	{r4, r5, lr}
   1c0fe:	0004      	movs	r4, r0
   1c100:	b099      	sub	sp, #100	; 0x64
    ue_stats  ue_stats_bin;

    if (csq == NULL)
   1c102:	2800      	cmp	r0, #0
   1c104:	d103      	bne.n	1c10e <get_csq+0x12>
    {
        return NEUL_RET_ERROR;
   1c106:	2501      	movs	r5, #1
    {
        *csq = NEUL_PH_CSQ_UNKNOWN;
    }

    return NEUL_RET_OK;
}
   1c108:	0028      	movs	r0, r5
   1c10a:	b019      	add	sp, #100	; 0x64
   1c10c:	bd30      	pop	{r4, r5, pc}
    memset(&ue_stats_bin, 0, sizeof(ue_stats_bin));
   1c10e:	2260      	movs	r2, #96	; 0x60
   1c110:	2100      	movs	r1, #0
   1c112:	4668      	mov	r0, sp
   1c114:	f7e4 f8e4 	bl	2e0 <memset>
    if (get_ue_stats(&ue_stats_bin) != 0)
   1c118:	4668      	mov	r0, sp
   1c11a:	f000 fe14 	bl	1cd46 <get_ue_stats>
   1c11e:	1e05      	subs	r5, r0, #0
   1c120:	d1f1      	bne.n	1c106 <get_csq+0xa>
    if (ue_stats_bin.total_power != UE_STATS_INVALID_POWER)
   1c122:	9802      	ldr	r0, [sp, #8]
   1c124:	4b0b      	ldr	r3, [pc, #44]	; (1c154 <get_csq+0x58>)
   1c126:	4298      	cmp	r0, r3
   1c128:	d011      	beq.n	1c14e <get_csq+0x52>
        if(NEUL_GET_REAL_RSSI_FROM_RSSI(ue_stats_bin.total_power) >= NEUL_PH_RSSI_HIGH)
   1c12a:	4b0b      	ldr	r3, [pc, #44]	; (1c158 <get_csq+0x5c>)
   1c12c:	4298      	cmp	r0, r3
   1c12e:	db02      	blt.n	1c136 <get_csq+0x3a>
            *csq = NEUL_PH_CSQ_HIGH;
   1c130:	231f      	movs	r3, #31
        *csq = NEUL_PH_CSQ_UNKNOWN;
   1c132:	7023      	strb	r3, [r4, #0]
   1c134:	e7e8      	b.n	1c108 <get_csq+0xc>
        else if(NEUL_GET_REAL_RSSI_FROM_RSSI(ue_stats_bin.total_power) <= NEUL_PH_RSSI_LOW)
   1c136:	4b09      	ldr	r3, [pc, #36]	; (1c15c <get_csq+0x60>)
   1c138:	4298      	cmp	r0, r3
   1c13a:	da01      	bge.n	1c140 <get_csq+0x44>
            *csq = NEUL_PH_CSQ_LOW;
   1c13c:	7025      	strb	r5, [r4, #0]
   1c13e:	e7e3      	b.n	1c108 <get_csq+0xc>
            *csq = (uint8)((NEUL_GET_REAL_RSSI_FROM_RSSI(ue_stats_bin.total_power) - NEUL_PH_RSSI_LOW) / 2);
   1c140:	210a      	movs	r1, #10
   1c142:	f7e4 f9c3 	bl	4cc <__divsi3>
   1c146:	3071      	adds	r0, #113	; 0x71
   1c148:	1040      	asrs	r0, r0, #1
   1c14a:	7020      	strb	r0, [r4, #0]
   1c14c:	e7dc      	b.n	1c108 <get_csq+0xc>
        *csq = NEUL_PH_CSQ_UNKNOWN;
   1c14e:	2363      	movs	r3, #99	; 0x63
   1c150:	e7ef      	b.n	1c132 <get_csq+0x36>
   1c152:	46c0      	nop			; (mov r8, r8)
   1c154:	ffff8000 	.word	0xffff8000
   1c158:	fffffdf9 	.word	0xfffffdf9
   1c15c:	fffffb97 	.word	0xfffffb97

0001c160 <get_registration_status>:
 * @param active_time Indicates the Active Time value (T3324) allocated to the UE in E-UTRAN,0xFFFF means invalid
 * @param periodic_tau the extended periodic TAU value (T3412),0xFFFF means invalid
 * @return success or fail
 */
NEUL_RET get_registration_status(uint8 *state, uint16* tac, uint32* ci, bool *reject_flag, EMM_CAUSE_INFO *reject_cause, uint16 *active_time, uint16 *periodic_tau)
{
   1c160:	b57f      	push	{r0, r1, r2, r3, r4, r5, r6, lr}
   1c162:	9d08      	ldr	r5, [sp, #32]
   1c164:	9e0a      	ldr	r6, [sp, #40]	; 0x28
    if ((state == NULL) || (tac == NULL)  || (ci == NULL) || (reject_flag == NULL) || (reject_cause == NULL) || (periodic_tau == NULL))
    {
        return NEUL_RET_ERROR;
   1c166:	2401      	movs	r4, #1
    if ((state == NULL) || (tac == NULL)  || (ci == NULL) || (reject_flag == NULL) || (reject_cause == NULL) || (periodic_tau == NULL))
   1c168:	2800      	cmp	r0, #0
   1c16a:	d013      	beq.n	1c194 <get_registration_status+0x34>
   1c16c:	2900      	cmp	r1, #0
   1c16e:	d011      	beq.n	1c194 <get_registration_status+0x34>
   1c170:	2a00      	cmp	r2, #0
   1c172:	d00f      	beq.n	1c194 <get_registration_status+0x34>
   1c174:	2b00      	cmp	r3, #0
   1c176:	d00d      	beq.n	1c194 <get_registration_status+0x34>
   1c178:	2d00      	cmp	r5, #0
   1c17a:	d00b      	beq.n	1c194 <get_registration_status+0x34>
   1c17c:	2e00      	cmp	r6, #0
   1c17e:	d009      	beq.n	1c194 <get_registration_status+0x34>
    }

    if (command_get_registration_status(state, tac, ci, reject_flag, (uint8 *)reject_cause, active_time, periodic_tau) != RPC_ERR_OK)
   1c180:	9c09      	ldr	r4, [sp, #36]	; 0x24
   1c182:	9602      	str	r6, [sp, #8]
   1c184:	9401      	str	r4, [sp, #4]
   1c186:	9500      	str	r5, [sp, #0]
   1c188:	f7e7 fbb2 	bl	38f0 <command_get_registration_status>
    {
        return NEUL_RET_ERROR_RPC;
    }

    return NEUL_RET_OK;
   1c18c:	0004      	movs	r4, r0
   1c18e:	1e60      	subs	r0, r4, #1
   1c190:	4184      	sbcs	r4, r0
   1c192:	0064      	lsls	r4, r4, #1
}
   1c194:	0020      	movs	r0, r4
   1c196:	b004      	add	sp, #16
   1c198:	bd70      	pop	{r4, r5, r6, pc}

0001c19a <set_bands>:
 * @param num_bands number of bands to set(the max number is 4 now)
 * @param bands an array of band data containing num_bands bands
 * @return error or success
 */
NEUL_RET set_bands(uint8 num_bands, uint8 *bands)
{
   1c19a:	b513      	push	{r0, r1, r4, lr}
    uint8 set_band_result = NEUL_RET_ERROR;
   1c19c:	466b      	mov	r3, sp
   1c19e:	1ddc      	adds	r4, r3, #7
   1c1a0:	2301      	movs	r3, #1
    RPC_ERR rpc_return_code;
    NEUL_RET result;

    rpc_return_code = command_set_band(num_bands, bands, &set_band_result);
   1c1a2:	0022      	movs	r2, r4
   1c1a4:	b280      	uxth	r0, r0
    uint8 set_band_result = NEUL_RET_ERROR;
   1c1a6:	7023      	strb	r3, [r4, #0]
    rpc_return_code = command_set_band(num_bands, bands, &set_band_result);
   1c1a8:	f7e7 fa05 	bl	35b6 <command_set_band>

    result = (NEUL_RET)set_band_result;
   1c1ac:	7820      	ldrb	r0, [r4, #0]
    {
        return NEUL_RET_OK;
    }

    return result;
}
   1c1ae:	bd16      	pop	{r1, r2, r4, pc}

0001c1b0 <get_bands>:
 * @param num_bands number of band data items returned
 * @param bands a pointer to a buffer of max_bands_size bytes
 * @return error or success
 */
 NEUL_RET get_bands(uint16 max_bands_size, uint16 *num_bands, uint8 *bands)
{
   1c1b0:	b537      	push	{r0, r1, r2, r4, r5, lr}
   1c1b2:	0013      	movs	r3, r2
    uint8 get_band_result = NEUL_RET_ERROR;
   1c1b4:	466a      	mov	r2, sp
   1c1b6:	2401      	movs	r4, #1
   1c1b8:	1dd5      	adds	r5, r2, #7
   1c1ba:	71d4      	strb	r4, [r2, #7]
    RPC_ERR rpc_return_code;
    NEUL_RET result;


    rpc_return_code = command_get_band(&get_band_result, max_bands_size, num_bands, bands);
   1c1bc:	000a      	movs	r2, r1
   1c1be:	0001      	movs	r1, r0
   1c1c0:	0028      	movs	r0, r5
   1c1c2:	f7e7 fa28 	bl	3616 <command_get_band>
    result = (NEUL_RET)get_band_result;

    if ((result == NEUL_RET_OK) && (rpc_return_code == RPC_ERR_OK ))
   1c1c6:	782b      	ldrb	r3, [r5, #0]
   1c1c8:	2b00      	cmp	r3, #0
   1c1ca:	d102      	bne.n	1c1d2 <get_bands+0x22>
   1c1cc:	1e44      	subs	r4, r0, #1
   1c1ce:	41a0      	sbcs	r0, r4
    {
        return NEUL_RET_OK;
   1c1d0:	b2c4      	uxtb	r4, r0
    }

    return NEUL_RET_ERROR;
}
   1c1d2:	0020      	movs	r0, r4
   1c1d4:	bd3e      	pop	{r1, r2, r3, r4, r5, pc}

0001c1d6 <get_support_bands>:
 * @param num_supported_band number of supported band data items returned
 * @param supported_bands a pointer to a buffer of max_supported_bands_size bytes
 * @return error or success
 */
NEUL_RET get_support_bands(uint16 max_support_bands_size, uint16 *num_supported_bands, uint8 *supported_bands)
{
   1c1d6:	b573      	push	{r0, r1, r4, r5, r6, lr}
   1c1d8:	0013      	movs	r3, r2
    uint8 get_band_result = NEUL_RET_ERROR;
   1c1da:	466a      	mov	r2, sp
   1c1dc:	1dd4      	adds	r4, r2, #7
   1c1de:	2201      	movs	r2, #1
{
   1c1e0:	000d      	movs	r5, r1
    uint8 get_band_result = NEUL_RET_ERROR;
   1c1e2:	7022      	strb	r2, [r4, #0]
{
   1c1e4:	0006      	movs	r6, r0
    RPC_ERR rpc_return_code;

    rpc_return_code = command_get_supported_bands(&get_band_result, max_support_bands_size, num_supported_bands, supported_bands);
   1c1e6:	000a      	movs	r2, r1
   1c1e8:	0001      	movs	r1, r0
   1c1ea:	0020      	movs	r0, r4
   1c1ec:	f7e7 fa43 	bl	3676 <command_get_supported_bands>

    // RPC layer may truncate the array if it won't fit, but not the number of elements. IOT-5448
    if (*num_supported_bands > max_support_bands_size)
   1c1f0:	882b      	ldrh	r3, [r5, #0]
   1c1f2:	42b3      	cmp	r3, r6
   1c1f4:	d900      	bls.n	1c1f8 <get_support_bands+0x22>
    {
        *num_supported_bands = max_support_bands_size;
   1c1f6:	802e      	strh	r6, [r5, #0]
    }

    if ((get_band_result == 0)|| (rpc_return_code == RPC_ERR_OK ))
    {
        return NEUL_RET_OK;
   1c1f8:	2300      	movs	r3, #0
    if ((get_band_result == 0)|| (rpc_return_code == RPC_ERR_OK ))
   1c1fa:	7822      	ldrb	r2, [r4, #0]
   1c1fc:	429a      	cmp	r2, r3
   1c1fe:	d002      	beq.n	1c206 <get_support_bands+0x30>
   1c200:	1e43      	subs	r3, r0, #1
   1c202:	4198      	sbcs	r0, r3
        return NEUL_RET_OK;
   1c204:	b2c3      	uxtb	r3, r0
    }

    return NEUL_RET_ERROR;
}
   1c206:	0018      	movs	r0, r3
   1c208:	bd76      	pop	{r1, r2, r4, r5, r6, pc}

0001c20a <get_connection_status>:
 * @brief gives details of the terminal perceived radio connection status
 * @param status 0: Idle, 1: Connected
 * @return success or error
 */
NEUL_RET get_connection_status(uint8 *status)
{
   1c20a:	b510      	push	{r4, lr}
    if (status == NULL)
    {
        return NEUL_RET_ERROR;
   1c20c:	2301      	movs	r3, #1
    if (status == NULL)
   1c20e:	2800      	cmp	r0, #0
   1c210:	d005      	beq.n	1c21e <get_connection_status+0x14>
    }

    if (command_get_connection_status(status) != RPC_ERR_OK)
   1c212:	f7e7 fbbb 	bl	398c <command_get_connection_status>
    {
        return NEUL_RET_ERROR_RPC;
    }

    return NEUL_RET_OK;
   1c216:	0003      	movs	r3, r0
   1c218:	1e58      	subs	r0, r3, #1
   1c21a:	4183      	sbcs	r3, r0
   1c21c:	005b      	lsls	r3, r3, #1
}
   1c21e:	0018      	movs	r0, r3
   1c220:	bd10      	pop	{r4, pc}
	...

0001c224 <set_cfun>:
 * @param fun radio power state 0: off 1: on
 * @param callback The function to call with the cfun result
 * @return success, error or in progress indicator
 */
NEUL_RET set_cfun(uint16 cfun, neul_radio_power_state_callback callback)
{
   1c224:	b537      	push	{r0, r1, r2, r4, r5, lr}
    NEUL_RET cfun_set_result;
    RPC_ERR rpc_return_code;

    rpc_return_code = command_set_ue_cfun(cfun, (uint8 *)&cfun_set_result);
   1c226:	466b      	mov	r3, sp
   1c228:	1ddc      	adds	r4, r3, #7
{
   1c22a:	000d      	movs	r5, r1
    rpc_return_code = command_set_ue_cfun(cfun, (uint8 *)&cfun_set_result);
   1c22c:	0021      	movs	r1, r4
   1c22e:	f7e7 fd95 	bl	3d5c <command_set_ue_cfun>
        }

        return cfun_set_result;
    }

    return NEUL_RET_ERROR;
   1c232:	2301      	movs	r3, #1
    if(rpc_return_code == RPC_ERR_OK)
   1c234:	2800      	cmp	r0, #0
   1c236:	d104      	bne.n	1c242 <set_cfun+0x1e>
        if(cfun_set_result == NEUL_RET_OK)
   1c238:	7823      	ldrb	r3, [r4, #0]
   1c23a:	2b00      	cmp	r3, #0
   1c23c:	d101      	bne.n	1c242 <set_cfun+0x1e>
            cfun_result_callback = callback;
   1c23e:	4a02      	ldr	r2, [pc, #8]	; (1c248 <set_cfun+0x24>)
   1c240:	6015      	str	r5, [r2, #0]
}
   1c242:	0018      	movs	r0, r3
   1c244:	bd3e      	pop	{r1, r2, r3, r4, r5, pc}
   1c246:	46c0      	nop			; (mov r8, r8)
   1c248:	01002c24 	.word	0x01002c24

0001c24c <remote_command_cfun_result_ind>:

void remote_command_cfun_result_ind(CORES core, uint8 cfun_result)
{
   1c24c:	b510      	push	{r4, lr}
    UNUSED(core);

    /* safely call callback */
    neul_radio_power_state_callback cfun_callback = cfun_result_callback;
   1c24e:	4b03      	ldr	r3, [pc, #12]	; (1c25c <remote_command_cfun_result_ind+0x10>)
   1c250:	681b      	ldr	r3, [r3, #0]
    if (cfun_callback != NULL)
   1c252:	2b00      	cmp	r3, #0
   1c254:	d001      	beq.n	1c25a <remote_command_cfun_result_ind+0xe>
    {
        cfun_callback((NEUL_RET)cfun_result);
   1c256:	0008      	movs	r0, r1
   1c258:	4798      	blx	r3
    }
}
   1c25a:	bd10      	pop	{r4, pc}
   1c25c:	01002c24 	.word	0x01002c24

0001c260 <get_cfun>:
/**
 * @brief get system func
 * @param fun 1:power on
 */
NEUL_RET get_cfun(uint16 *cfun)
{
   1c260:	b537      	push	{r0, r1, r2, r4, r5, lr}
    // TODO: RPC was created with uint8, but set is unit16. needs to be changed
    uint8 cfun_tmp;

    if (command_read_ue_cfun(&cfun_tmp) != RPC_ERR_OK)
   1c262:	466b      	mov	r3, sp
   1c264:	1ddc      	adds	r4, r3, #7
{
   1c266:	0005      	movs	r5, r0
    if (command_read_ue_cfun(&cfun_tmp) != RPC_ERR_OK)
   1c268:	0020      	movs	r0, r4
   1c26a:	f7e7 fdc7 	bl	3dfc <command_read_ue_cfun>
    {
        return NEUL_RET_ERROR;
   1c26e:	2301      	movs	r3, #1
    if (command_read_ue_cfun(&cfun_tmp) != RPC_ERR_OK)
   1c270:	2800      	cmp	r0, #0
   1c272:	d102      	bne.n	1c27a <get_cfun+0x1a>
    }

    *cfun = cfun_tmp;
   1c274:	7823      	ldrb	r3, [r4, #0]
   1c276:	802b      	strh	r3, [r5, #0]
    return NEUL_RET_OK;
   1c278:	0003      	movs	r3, r0
}
   1c27a:	0018      	movs	r0, r3
   1c27c:	bd3e      	pop	{r1, r2, r3, r4, r5, pc}

0001c27e <get_defined_cids>:
 * @param cids_max_length size of cids buffer in bytes
 * @param cids_num number of band data items returned
 * @param cids a pointer to a buffer of cids_max_length bytes
 */
NEUL_RET get_defined_cids(uint16 cids_max_length, uint16 *cids_num, uint8 *cids)
{
   1c27e:	b510      	push	{r4, lr}
    if (cids_num == NULL || cids == NULL)
    {
        return NEUL_RET_ERROR;
   1c280:	2301      	movs	r3, #1
    if (cids_num == NULL || cids == NULL)
   1c282:	2900      	cmp	r1, #0
   1c284:	d006      	beq.n	1c294 <get_defined_cids+0x16>
   1c286:	2a00      	cmp	r2, #0
   1c288:	d004      	beq.n	1c294 <get_defined_cids+0x16>
    }

    if (command_get_defined_cids(cids_max_length, cids_num, cids) != RPC_ERR_OK)
   1c28a:	f7e7 fddd 	bl	3e48 <command_get_defined_cids>
   1c28e:	1e43      	subs	r3, r0, #1
   1c290:	4198      	sbcs	r0, r3
        return NEUL_RET_ERROR;
   1c292:	b2c3      	uxtb	r3, r0
    {
        return NEUL_RET_ERROR;
    }

    return NEUL_RET_OK;
}
   1c294:	0018      	movs	r0, r3
   1c296:	bd10      	pop	{r4, pc}

0001c298 <get_pending_data_seqs>:
 * @param seqs_max_length size of seqs buffer in bytes
 * @param seqs_num number of pending data items returned
 * @param seqs a pointer to a buffer of seqs_max_length bytes
 */
NEUL_RET get_pending_data_seqs(uint8 socket_num, uint16 seqs_max_length, uint16 *seqs_length, uint8 *data_seqs)
{
   1c298:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
   1c29a:	0005      	movs	r5, r0
   1c29c:	9101      	str	r1, [sp, #4]
   1c29e:	0017      	movs	r7, r2
   1c2a0:	001e      	movs	r6, r3
    SOCKET_TYPE so_type = get_sock_type(socket_num);
   1c2a2:	f7eb fbff 	bl	7aa4 <get_sock_type>
   1c2a6:	0004      	movs	r4, r0

    if (seqs_length == NULL || data_seqs == NULL)
    {
        return NEUL_RET_ERROR;
   1c2a8:	2001      	movs	r0, #1
    if (seqs_length == NULL || data_seqs == NULL)
   1c2aa:	2f00      	cmp	r7, #0
   1c2ac:	d009      	beq.n	1c2c2 <get_pending_data_seqs+0x2a>
   1c2ae:	2e00      	cmp	r6, #0
   1c2b0:	d007      	beq.n	1c2c2 <get_pending_data_seqs+0x2a>
    }

    if (so_type == SOCK_STREAM) // GET TCP pending data seqs
   1c2b2:	4284      	cmp	r4, r0
   1c2b4:	d106      	bne.n	1c2c4 <get_pending_data_seqs+0x2c>
    {
        if (!get_tcp_pending_data_seqs(socket_num, data_seqs))
   1c2b6:	0031      	movs	r1, r6
   1c2b8:	0028      	movs	r0, r5
   1c2ba:	f7eb fc01 	bl	7ac0 <get_tcp_pending_data_seqs>
   1c2be:	4060      	eors	r0, r4
        return NEUL_RET_ERROR;
   1c2c0:	b2c0      	uxtb	r0, r0
            return NEUL_RET_ERROR;
        }
    }

    return NEUL_RET_OK;
}
   1c2c2:	bdfe      	pop	{r1, r2, r3, r4, r5, r6, r7, pc}
        if (command_get_pending_data_seqs(socket_num, seqs_max_length, seqs_length, data_seqs) != RPC_ERR_OK)
   1c2c4:	0033      	movs	r3, r6
   1c2c6:	003a      	movs	r2, r7
   1c2c8:	9901      	ldr	r1, [sp, #4]
   1c2ca:	0028      	movs	r0, r5
   1c2cc:	f7e7 fec6 	bl	405c <command_get_pending_data_seqs>
   1c2d0:	1e44      	subs	r4, r0, #1
   1c2d2:	41a0      	sbcs	r0, r4
   1c2d4:	e7f4      	b.n	1c2c0 <get_pending_data_seqs+0x28>

0001c2d6 <delete_pdp_context>:
 * @brief delete a pdp context
 * @param cid: The cid to activate
 * @return success or error
 */
NEUL_RET delete_pdp_context(uint16 cid)
{
   1c2d6:	b513      	push	{r0, r1, r4, lr}
    RPC_ERR     rpc_result;
    NEUL_RET    neul_result = NEUL_RET_OK;
   1c2d8:	466b      	mov	r3, sp
   1c2da:	1ddc      	adds	r4, r3, #7
   1c2dc:	2300      	movs	r3, #0

    rpc_result = command_delete_pdp_context(cid, (uint8 *) &neul_result);
   1c2de:	0021      	movs	r1, r4
    NEUL_RET    neul_result = NEUL_RET_OK;
   1c2e0:	7023      	strb	r3, [r4, #0]
    rpc_result = command_delete_pdp_context(cid, (uint8 *) &neul_result);
   1c2e2:	f7e7 fbc8 	bl	3a76 <command_delete_pdp_context>
    if((rpc_result == RPC_ERR_OK) && (neul_result == NEUL_RET_OK))
    {
        return NEUL_RET_OK;
    }

    return NEUL_RET_ERROR;
   1c2e6:	2301      	movs	r3, #1
    if((rpc_result == RPC_ERR_OK) && (neul_result == NEUL_RET_OK))
   1c2e8:	2800      	cmp	r0, #0
   1c2ea:	d103      	bne.n	1c2f4 <delete_pdp_context+0x1e>
   1c2ec:	7823      	ldrb	r3, [r4, #0]
   1c2ee:	1e58      	subs	r0, r3, #1
   1c2f0:	4183      	sbcs	r3, r0
        return NEUL_RET_OK;
   1c2f2:	b2db      	uxtb	r3, r3
}
   1c2f4:	0018      	movs	r0, r3
   1c2f6:	bd16      	pop	{r1, r2, r4, pc}

0001c2f8 <activate_pdp_context>:
 * @brief Activates a pdp context
 * @param context The context to activate
 * @return success or error
 */
NEUL_RET activate_pdp_context(const pdp_context *context)
{
   1c2f8:	b5f0      	push	{r4, r5, r6, r7, lr}
    NEUL_RET result = NEUL_RET_OK;
   1c2fa:	2527      	movs	r5, #39	; 0x27
   1c2fc:	2300      	movs	r3, #0
{
   1c2fe:	b08b      	sub	sp, #44	; 0x2c
    NEUL_RET result = NEUL_RET_OK;
   1c300:	446d      	add	r5, sp
{
   1c302:	0004      	movs	r4, r0
    NEUL_RET result = NEUL_RET_OK;
   1c304:	702b      	strb	r3, [r5, #0]

    if (context == NULL)
   1c306:	4298      	cmp	r0, r3
   1c308:	d102      	bne.n	1c310 <activate_pdp_context+0x18>
    {
        return NEUL_RET_ERROR;
   1c30a:	2001      	movs	r0, #1
    {
        return NEUL_RET_ERROR;
    }

    return result;
}
   1c30c:	b00b      	add	sp, #44	; 0x2c
   1c30e:	bdf0      	pop	{r4, r5, r6, r7, pc}
    if (command_set_pdp_context(context->cid, context->pdp_type, (uint16) strlen((char *)context->apn), context->apn, context->d_comp, context->h_comp,
   1c310:	7846      	ldrb	r6, [r0, #1]
   1c312:	7907      	ldrb	r7, [r0, #4]
   1c314:	68c0      	ldr	r0, [r0, #12]
   1c316:	f7ff f842 	bl	1b39e <strlen>
   1c31a:	7a23      	ldrb	r3, [r4, #8]
   1c31c:	b282      	uxth	r2, r0
   1c31e:	9305      	str	r3, [sp, #20]
   1c320:	79e3      	ldrb	r3, [r4, #7]
   1c322:	9506      	str	r5, [sp, #24]
   1c324:	9304      	str	r3, [sp, #16]
   1c326:	79a3      	ldrb	r3, [r4, #6]
   1c328:	0039      	movs	r1, r7
   1c32a:	9303      	str	r3, [sp, #12]
   1c32c:	7963      	ldrb	r3, [r4, #5]
   1c32e:	0030      	movs	r0, r6
   1c330:	9302      	str	r3, [sp, #8]
   1c332:	78e3      	ldrb	r3, [r4, #3]
   1c334:	9301      	str	r3, [sp, #4]
   1c336:	78a3      	ldrb	r3, [r4, #2]
   1c338:	9300      	str	r3, [sp, #0]
   1c33a:	68e3      	ldr	r3, [r4, #12]
   1c33c:	f7e7 fb4c 	bl	39d8 <command_set_pdp_context>
   1c340:	2800      	cmp	r0, #0
   1c342:	d1e2      	bne.n	1c30a <activate_pdp_context+0x12>
    return result;
   1c344:	7828      	ldrb	r0, [r5, #0]
   1c346:	e7e1      	b.n	1c30c <activate_pdp_context+0x14>

0001c348 <get_pdp_context>:
 * @return success or error
 */
NEUL_RET get_pdp_context(uint8 cid, pdp_context *context)
{
    uint16 apn_length = 0;
    uint16 context_length = 0;
   1c348:	2216      	movs	r2, #22
{
   1c34a:	b570      	push	{r4, r5, r6, lr}
   1c34c:	000c      	movs	r4, r1
    uint16 apn_length = 0;
   1c34e:	2100      	movs	r1, #0
{
   1c350:	b086      	sub	sp, #24
    uint16 apn_length = 0;
   1c352:	ab05      	add	r3, sp, #20
    uint16 context_length = 0;
   1c354:	446a      	add	r2, sp
    uint16 apn_length = 0;
   1c356:	8019      	strh	r1, [r3, #0]
    uint16 context_length = 0;
   1c358:	8011      	strh	r1, [r2, #0]
    NEUL_RET result ;

    if (context == NULL)
   1c35a:	428c      	cmp	r4, r1
   1c35c:	d102      	bne.n	1c364 <get_pdp_context+0x1c>
    {
        return NEUL_RET_ERROR;
   1c35e:	2001      	movs	r0, #1
    {
        return NEUL_RET_ERROR;
    }
    context->apn = p_apn;
    return NEUL_RET_OK;
}
   1c360:	b006      	add	sp, #24
   1c362:	bd70      	pop	{r4, r5, r6, pc}
    if(command_get_pdp_context(cid, (uint8 *)&result, NEUL_MAX_APN_SIZE, &apn_length, p_apn,
   1c364:	2613      	movs	r6, #19
   1c366:	9202      	str	r2, [sp, #8]
   1c368:	2278      	movs	r2, #120	; 0x78
    uint8   *p_apn = context->apn;
   1c36a:	68e5      	ldr	r5, [r4, #12]
    if(command_get_pdp_context(cid, (uint8 *)&result, NEUL_MAX_APN_SIZE, &apn_length, p_apn,
   1c36c:	446e      	add	r6, sp
   1c36e:	9201      	str	r2, [sp, #4]
   1c370:	9403      	str	r4, [sp, #12]
   1c372:	9500      	str	r5, [sp, #0]
   1c374:	3a13      	subs	r2, #19
   1c376:	0031      	movs	r1, r6
   1c378:	f7e7 fba7 	bl	3aca <command_get_pdp_context>
   1c37c:	2800      	cmp	r0, #0
   1c37e:	d1ee      	bne.n	1c35e <get_pdp_context+0x16>
    if (result != NEUL_RET_OK)
   1c380:	7830      	ldrb	r0, [r6, #0]
   1c382:	2800      	cmp	r0, #0
   1c384:	d1eb      	bne.n	1c35e <get_pdp_context+0x16>
    context->apn = p_apn;
   1c386:	60e5      	str	r5, [r4, #12]
    return NEUL_RET_OK;
   1c388:	e7ea      	b.n	1c360 <get_pdp_context+0x18>

0001c38a <set_pdp_context_auth_param>:
 * @param login_str User name for access to the IP network max length is 60
 * @param password_str Password for access to the IP network max length is 60
 * @return success or error
 */
NEUL_RET set_pdp_context_auth_param(uint8 cid, uint8 auth_port, uint8 *login_str, uint8 *password_str)
{
   1c38a:	b5f0      	push	{r4, r5, r6, r7, lr}
    NEUL_RET result = NEUL_RET_OK;
   1c38c:	2417      	movs	r4, #23
{
   1c38e:	b089      	sub	sp, #36	; 0x24
   1c390:	001e      	movs	r6, r3
    NEUL_RET result = NEUL_RET_OK;
   1c392:	ab02      	add	r3, sp, #8
   1c394:	18e4      	adds	r4, r4, r3
   1c396:	2300      	movs	r3, #0
{
   1c398:	0007      	movs	r7, r0
   1c39a:	9105      	str	r1, [sp, #20]
   1c39c:	0015      	movs	r5, r2
    NEUL_RET result = NEUL_RET_OK;
   1c39e:	7023      	strb	r3, [r4, #0]

    if ((login_str == NULL) || (password_str == NULL))
   1c3a0:	429a      	cmp	r2, r3
   1c3a2:	d102      	bne.n	1c3aa <set_pdp_context_auth_param+0x20>
    {
        return NEUL_RET_ERROR;
   1c3a4:	2001      	movs	r0, #1
    {
        return NEUL_RET_ERROR;
    }

    return result;
}
   1c3a6:	b009      	add	sp, #36	; 0x24
   1c3a8:	bdf0      	pop	{r4, r5, r6, r7, pc}
    if ((login_str == NULL) || (password_str == NULL))
   1c3aa:	2e00      	cmp	r6, #0
   1c3ac:	d0fa      	beq.n	1c3a4 <set_pdp_context_auth_param+0x1a>
    if (command_set_pdp_context_auth_param(cid, auth_port, (uint16) strlen((char *)login_str), login_str, (uint16) strlen((char *)password_str), password_str, (uint8*)&result) != RPC_ERR_OK)
   1c3ae:	0010      	movs	r0, r2
   1c3b0:	f7fe fff5 	bl	1b39e <strlen>
   1c3b4:	9004      	str	r0, [sp, #16]
   1c3b6:	0030      	movs	r0, r6
   1c3b8:	f7fe fff1 	bl	1b39e <strlen>
   1c3bc:	466b      	mov	r3, sp
   1c3be:	b280      	uxth	r0, r0
   1c3c0:	8a1a      	ldrh	r2, [r3, #16]
   1c3c2:	9905      	ldr	r1, [sp, #20]
   1c3c4:	9000      	str	r0, [sp, #0]
   1c3c6:	9402      	str	r4, [sp, #8]
   1c3c8:	9601      	str	r6, [sp, #4]
   1c3ca:	002b      	movs	r3, r5
   1c3cc:	0038      	movs	r0, r7
   1c3ce:	f7e7 fbba 	bl	3b46 <command_set_pdp_context_auth_param>
   1c3d2:	2800      	cmp	r0, #0
   1c3d4:	d1e6      	bne.n	1c3a4 <set_pdp_context_auth_param+0x1a>
    return result;
   1c3d6:	7820      	ldrb	r0, [r4, #0]
   1c3d8:	e7e5      	b.n	1c3a6 <set_pdp_context_auth_param+0x1c>

0001c3da <get_pdp_context_auth_param>:
 * @param login_str User name for access to the IP network max length is 60
 * @param password_str Password for access to the IP network max length is 60
 * @return success or error
 */
NEUL_RET get_pdp_context_auth_param(uint8 cid, uint8* auth_prot, uint8 *login_str, uint8 *password_str)
{
   1c3da:	b5f0      	push	{r4, r5, r6, r7, lr}
     NEUL_RET result = NEUL_RET_OK;
   1c3dc:	241b      	movs	r4, #27
     uint16 login_str_length = 0;
     uint16 password_str_length = 0;
   1c3de:	271e      	movs	r7, #30
     NEUL_RET result = NEUL_RET_OK;
   1c3e0:	2500      	movs	r5, #0
{
   1c3e2:	b089      	sub	sp, #36	; 0x24
     NEUL_RET result = NEUL_RET_OK;
   1c3e4:	446c      	add	r4, sp
     uint16 login_str_length = 0;
   1c3e6:	ae07      	add	r6, sp, #28
     uint16 password_str_length = 0;
   1c3e8:	446f      	add	r7, sp
     NEUL_RET result = NEUL_RET_OK;
   1c3ea:	7025      	strb	r5, [r4, #0]
     uint16 login_str_length = 0;
   1c3ec:	8035      	strh	r5, [r6, #0]
     uint16 password_str_length = 0;
   1c3ee:	803d      	strh	r5, [r7, #0]

     if ((auth_prot == NULL) || (login_str == NULL) || (password_str == NULL))
   1c3f0:	42a9      	cmp	r1, r5
   1c3f2:	d102      	bne.n	1c3fa <get_pdp_context_auth_param+0x20>
     {
        return NEUL_RET_ERROR;
   1c3f4:	2001      	movs	r0, #1
     {
        return NEUL_RET_ERROR;
     }

     return result;
}
   1c3f6:	b009      	add	sp, #36	; 0x24
   1c3f8:	bdf0      	pop	{r4, r5, r6, r7, pc}
     if ((auth_prot == NULL) || (login_str == NULL) || (password_str == NULL))
   1c3fa:	2a00      	cmp	r2, #0
   1c3fc:	d0fa      	beq.n	1c3f4 <get_pdp_context_auth_param+0x1a>
   1c3fe:	2b00      	cmp	r3, #0
   1c400:	d0f8      	beq.n	1c3f4 <get_pdp_context_auth_param+0x1a>
     if (command_get_pdp_context_auth_param(cid, (uint8*)&result, auth_prot, NEUL_CGAUTH_MAX_USERNAME_LEN + 1, &login_str_length,
   1c402:	9304      	str	r3, [sp, #16]
   1c404:	233d      	movs	r3, #61	; 0x3d
   1c406:	9201      	str	r2, [sp, #4]
   1c408:	9703      	str	r7, [sp, #12]
   1c40a:	000a      	movs	r2, r1
   1c40c:	9302      	str	r3, [sp, #8]
   1c40e:	9600      	str	r6, [sp, #0]
   1c410:	0021      	movs	r1, r4
   1c412:	f7e7 fbd9 	bl	3bc8 <command_get_pdp_context_auth_param>
   1c416:	2800      	cmp	r0, #0
   1c418:	d1ec      	bne.n	1c3f4 <get_pdp_context_auth_param+0x1a>
     return result;
   1c41a:	7820      	ldrb	r0, [r4, #0]
   1c41c:	e7eb      	b.n	1c3f6 <get_pdp_context_auth_param+0x1c>

0001c41e <set_nconfig>:
 * @param function:function to set
 * @param value:function value to set
 * @return NEUL_RET_OK or NEUL_RET_ERROR
 */
NEUL_RET set_nconfig(uint8 function, uint16 value)
{
   1c41e:	b513      	push	{r0, r1, r4, lr}
    uint8       neul_result      = 0;
   1c420:	466b      	mov	r3, sp
   1c422:	1ddc      	adds	r4, r3, #7
   1c424:	2300      	movs	r3, #0
    RPC_ERR     rpc_return_code;

    rpc_return_code = command_set_nconfig(function, value, &neul_result);
   1c426:	0022      	movs	r2, r4
    uint8       neul_result      = 0;
   1c428:	7023      	strb	r3, [r4, #0]
    rpc_return_code = command_set_nconfig(function, value, &neul_result);
   1c42a:	f7e7 fc0e 	bl	3c4a <command_set_nconfig>
    if (((NEUL_RET)neul_result == NEUL_RET_OK) && (rpc_return_code == RPC_ERR_OK ))
   1c42e:	7820      	ldrb	r0, [r4, #0]
    {
        return NEUL_RET_OK;
    }

    return (NEUL_RET)neul_result;
}
   1c430:	bd16      	pop	{r1, r2, r4, pc}

0001c432 <get_nconfig>:
 * @param function:function to get
 * @param value:function value to get
 * @return NEUL_RET_OK or NEUL_RET_ERROR
 */
NEUL_RET get_nconfig(uint8 function, uint16 *value)
{
   1c432:	b513      	push	{r0, r1, r4, lr}
    uint8       neul_result             = 0;
   1c434:	466b      	mov	r3, sp
   1c436:	1ddc      	adds	r4, r3, #7
   1c438:	2300      	movs	r3, #0
{
   1c43a:	000a      	movs	r2, r1
    uint8       neul_result             = 0;
   1c43c:	7023      	strb	r3, [r4, #0]
    RPC_ERR     rpc_return_code;

    if (value == NULL)
   1c43e:	4299      	cmp	r1, r3
   1c440:	d008      	beq.n	1c454 <get_nconfig+0x22>
    {
        return NEUL_RET_ERROR;
    }

    rpc_return_code = command_get_nconfig(function, &neul_result, value);
   1c442:	0021      	movs	r1, r4
   1c444:	f7e7 fc32 	bl	3cac <command_get_nconfig>
   1c448:	0002      	movs	r2, r0
    if (((NEUL_RET)neul_result == NEUL_RET_OK) && (rpc_return_code == RPC_ERR_OK ))
   1c44a:	7820      	ldrb	r0, [r4, #0]
   1c44c:	2800      	cmp	r0, #0
   1c44e:	d101      	bne.n	1c454 <get_nconfig+0x22>
   1c450:	2a00      	cmp	r2, #0
   1c452:	d000      	beq.n	1c456 <get_nconfig+0x24>
    {
        return NEUL_RET_OK;
    }

    return NEUL_RET_ERROR;
   1c454:	2001      	movs	r0, #1
}
   1c456:	bd16      	pop	{r1, r2, r4, pc}

0001c458 <set_connection_status_callback>:
 * @param callback The function to call with the connection status
 * @return indicate if call was successful. Will fail if a callback is already registered.
 */
NEUL_RET set_connection_status_callback( neul_connection_status_callback callback)
{
    connection_status_callback = callback;
   1c458:	4b01      	ldr	r3, [pc, #4]	; (1c460 <set_connection_status_callback+0x8>)
   1c45a:	6018      	str	r0, [r3, #0]
    return NEUL_RET_OK;
}
   1c45c:	2000      	movs	r0, #0
   1c45e:	4770      	bx	lr
   1c460:	01002c2c 	.word	0x01002c2c

0001c464 <set_psm_status_reporting_callback>:
 * Sets a callback that will be triggered when we receive psm status changed (+NPRSR)
 * @param callback The function to call with the psm status
 */
void set_psm_status_reporting_callback( neul_psm_status_reporting_callback callback)
{
    neul_psm_status_callback = callback;
   1c464:	4b01      	ldr	r3, [pc, #4]	; (1c46c <set_psm_status_reporting_callback+0x8>)
   1c466:	6018      	str	r0, [r3, #0]
}
   1c468:	4770      	bx	lr
   1c46a:	46c0      	nop			; (mov r8, r8)
   1c46c:	01002c3c 	.word	0x01002c3c

0001c470 <set_registration_status_callback>:
 * Sets a callback that will be triggered when we change from being in/out of service (+CEREG)
 * @param callback The function to call with service status
 */
NEUL_RET set_registration_status_callback( neul_registration_status_callback callback )
{
    registration_status_callback = callback;
   1c470:	4b01      	ldr	r3, [pc, #4]	; (1c478 <set_registration_status_callback+0x8>)
   1c472:	6018      	str	r0, [r3, #0]

    return NEUL_RET_OK;
}
   1c474:	2000      	movs	r0, #0
   1c476:	4770      	bx	lr
   1c478:	01002c54 	.word	0x01002c54

0001c47c <set_t3324_t3412_ext_value_changed_callback>:
 * @brief Sets a callback that will be triggered when t3324 and t3412_ext from network changed
 * @param callback The function to call with t3324 and t3412_ext changed
 */
NEUL_RET set_t3324_t3412_ext_value_changed_callback( neul_t3324_t3412_ext_value_changed_callback callback )
{
    t3324_t3412_ext_value_changed_callback = callback;
   1c47c:	4b01      	ldr	r3, [pc, #4]	; (1c484 <set_t3324_t3412_ext_value_changed_callback+0x8>)
   1c47e:	6018      	str	r0, [r3, #0]

    return NEUL_RET_OK;
}
   1c480:	2000      	movs	r0, #0
   1c482:	4770      	bx	lr
   1c484:	01002c6c 	.word	0x01002c6c

0001c488 <set_power_saving_mode>:
 * @param mode 0: disable the use of psm,1: enable, 2: Disable the use of PSM and discard all parameters for PSM.
 * @param requested_periodic_tau requested periodic tau value to set, 0xFFFF means not set
 * @param requested_active_time requested active time value to set, 0xFFFF means not set
 */
NEUL_RET set_power_saving_mode(uint8 mode, uint16 requested_periodic_tau, uint16 requested_active_time)
{
   1c488:	b513      	push	{r0, r1, r4, lr}
    NEUL_RET result;

    if (command_set_power_saving_mode(mode, requested_periodic_tau, requested_active_time, (uint8*)&result) != RPC_ERR_OK)
   1c48a:	466b      	mov	r3, sp
   1c48c:	1ddc      	adds	r4, r3, #7
   1c48e:	0023      	movs	r3, r4
   1c490:	f7e8 fcd7 	bl	4e42 <command_set_power_saving_mode>
    {
        return NEUL_RET_ERROR;
   1c494:	2301      	movs	r3, #1
    if (command_set_power_saving_mode(mode, requested_periodic_tau, requested_active_time, (uint8*)&result) != RPC_ERR_OK)
   1c496:	2800      	cmp	r0, #0
   1c498:	d100      	bne.n	1c49c <set_power_saving_mode+0x14>
    }

    return result;
   1c49a:	7823      	ldrb	r3, [r4, #0]
}
   1c49c:	0018      	movs	r0, r3
   1c49e:	bd16      	pop	{r1, r2, r4, pc}

0001c4a0 <get_power_saving_mode>:
 * @param mode power saving mode to get
 * @param requested_periodic_tau requested periodic tau value to get
 * @param requested_active_time requested active time value to get
 */
NEUL_RET get_power_saving_mode(uint8 *mode, uint8 *requested_periodic_tau, uint8 *requested_active_time)
{
   1c4a0:	b513      	push	{r0, r1, r4, lr}
   1c4a2:	0013      	movs	r3, r2
    NEUL_RET result;

    if (command_get_power_saving_mode((uint8*)&result, mode, requested_periodic_tau, requested_active_time) != RPC_ERR_OK)
   1c4a4:	466a      	mov	r2, sp
   1c4a6:	1dd4      	adds	r4, r2, #7
   1c4a8:	000a      	movs	r2, r1
   1c4aa:	0001      	movs	r1, r0
   1c4ac:	0020      	movs	r0, r4
   1c4ae:	f7e8 fcfe 	bl	4eae <command_get_power_saving_mode>
    {
        return NEUL_RET_ERROR;
   1c4b2:	2301      	movs	r3, #1
    if (command_get_power_saving_mode((uint8*)&result, mode, requested_periodic_tau, requested_active_time) != RPC_ERR_OK)
   1c4b4:	2800      	cmp	r0, #0
   1c4b6:	d100      	bne.n	1c4ba <get_power_saving_mode+0x1a>
    }

    return result;
   1c4b8:	7823      	ldrb	r3, [r4, #0]
}
   1c4ba:	0018      	movs	r0, r3
   1c4bc:	bd16      	pop	{r1, r2, r4, pc}
	...

0001c4c0 <remote_command_registration_status_ind>:
 * indicates the the service status changed.
 * @param core:     The core this is called on
 * @param status:   The status changed to.
 */
void remote_command_registration_status_ind(CORES core, uint8 status)
{
   1c4c0:	b510      	push	{r4, lr}
    UNUSED(core);

    /* safely call callback */
    neul_registration_status_callback  callback = registration_status_callback;
   1c4c2:	4b03      	ldr	r3, [pc, #12]	; (1c4d0 <remote_command_registration_status_ind+0x10>)
   1c4c4:	681b      	ldr	r3, [r3, #0]
    if (callback != NULL)
   1c4c6:	2b00      	cmp	r3, #0
   1c4c8:	d001      	beq.n	1c4ce <remote_command_registration_status_ind+0xe>
    {
        callback(status);
   1c4ca:	0008      	movs	r0, r1
   1c4cc:	4798      	blx	r3
    }
}
   1c4ce:	bd10      	pop	{r4, pc}
   1c4d0:	01002c54 	.word	0x01002c54

0001c4d4 <remote_command_t3324_t3412_ext_value_changed_ind>:
 * @param core:     The core this is called on
 * @param t3324:    The t3324 changed to.
 * @param t3312_ext:The t3312_ext changed to.
 */
void remote_command_t3324_t3412_ext_value_changed_ind(CORES core,uint16 t3324,uint16 t3412_ext)
{
   1c4d4:	b510      	push	{r4, lr}
    UNUSED(core);
    neul_t3324_t3412_ext_value_changed_callback callback = t3324_t3412_ext_value_changed_callback;
   1c4d6:	4b04      	ldr	r3, [pc, #16]	; (1c4e8 <remote_command_t3324_t3412_ext_value_changed_ind+0x14>)
{
   1c4d8:	0008      	movs	r0, r1
    neul_t3324_t3412_ext_value_changed_callback callback = t3324_t3412_ext_value_changed_callback;
   1c4da:	681b      	ldr	r3, [r3, #0]
    if(callback != NULL)
   1c4dc:	2b00      	cmp	r3, #0
   1c4de:	d001      	beq.n	1c4e4 <remote_command_t3324_t3412_ext_value_changed_ind+0x10>
    {
        callback(t3324,t3412_ext);
   1c4e0:	0011      	movs	r1, r2
   1c4e2:	4798      	blx	r3
    }
}
   1c4e4:	bd10      	pop	{r4, pc}
   1c4e6:	46c0      	nop			; (mov r8, r8)
   1c4e8:	01002c6c 	.word	0x01002c6c

0001c4ec <remote_command_connection_status_ind>:
 * indicates the the connect status changed.
 * @param core:     The core this is called on
 * @param status:   The status changed to.
 */
void remote_command_connection_status_ind(CORES core, uint8 connection_status)
{
   1c4ec:	b510      	push	{r4, lr}
    UNUSED(core);

    /* safely call callback */
    neul_connection_status_callback callback = connection_status_callback;
   1c4ee:	4b03      	ldr	r3, [pc, #12]	; (1c4fc <remote_command_connection_status_ind+0x10>)
   1c4f0:	681b      	ldr	r3, [r3, #0]
    if (callback != NULL)
   1c4f2:	2b00      	cmp	r3, #0
   1c4f4:	d001      	beq.n	1c4fa <remote_command_connection_status_ind+0xe>
    {
        callback(connection_status);
   1c4f6:	0008      	movs	r0, r1
   1c4f8:	4798      	blx	r3
    }
}
   1c4fa:	bd10      	pop	{r4, pc}
   1c4fc:	01002c2c 	.word	0x01002c2c

0001c500 <set_edrxs>:
 * @param type the type of access technology
 * @param edrx_value the value of eDRX
 * @return success or error
 */
NEUL_RET set_edrxs (uint8 mode, uint8 type, uint8 edrx_value, neul_set_edrx_changed_callback edrxcallback)
{
   1c500:	b57f      	push	{r0, r1, r2, r3, r4, r5, r6, lr}
    uint8   neul_result          = 0;
   1c502:	240f      	movs	r4, #15
{
   1c504:	001e      	movs	r6, r3
    uint8   neul_result          = 0;
   1c506:	2300      	movs	r3, #0
   1c508:	446c      	add	r4, sp
   1c50a:	7023      	strb	r3, [r4, #0]
    uint8   paging_time_window   = NEUL_EDRX_AND_PTW_INVALID_FALG;

    if (command_set_edrxs_and_ptw(mode, type, edrx_value, paging_time_window, &neul_result) != RPC_ERR_OK)
   1c50c:	33ff      	adds	r3, #255	; 0xff
   1c50e:	9400      	str	r4, [sp, #0]
{
   1c510:	0005      	movs	r5, r0
    if (command_set_edrxs_and_ptw(mode, type, edrx_value, paging_time_window, &neul_result) != RPC_ERR_OK)
   1c512:	f7e8 fd08 	bl	4f26 <command_set_edrxs_and_ptw>
    {
        return NEUL_RET_ERROR_RPC;
   1c516:	2302      	movs	r3, #2
    if (command_set_edrxs_and_ptw(mode, type, edrx_value, paging_time_window, &neul_result) != RPC_ERR_OK)
   1c518:	2800      	cmp	r0, #0
   1c51a:	d106      	bne.n	1c52a <set_edrxs+0x2a>
    }

    if ((NEUL_RET)neul_result == NEUL_RET_OK)
   1c51c:	7823      	ldrb	r3, [r4, #0]
   1c51e:	2b00      	cmp	r3, #0
   1c520:	d103      	bne.n	1c52a <set_edrxs+0x2a>
   1c522:	4a04      	ldr	r2, [pc, #16]	; (1c534 <set_edrxs+0x34>)
    {
        if (mode == EDRX_MODE_UNSOLICITED)
   1c524:	2d02      	cmp	r5, #2
   1c526:	d103      	bne.n	1c530 <set_edrxs+0x30>
        {
            set_edrx_changed_callback = edrxcallback;
   1c528:	6016      	str	r6, [r2, #0]
        }
    }

    return (NEUL_RET)neul_result;

}
   1c52a:	0018      	movs	r0, r3
   1c52c:	b004      	add	sp, #16
   1c52e:	bd70      	pop	{r4, r5, r6, pc}
            set_edrx_changed_callback = NULL;
   1c530:	6013      	str	r3, [r2, #0]
   1c532:	e7fa      	b.n	1c52a <set_edrxs+0x2a>
   1c534:	01002c5c 	.word	0x01002c5c

0001c538 <set_ptwedrxs>:
 * @param edrx_value the value of eDRX
 * @param paging_time_window the value of paging_time_window
 * @return success or error
 */
NEUL_RET set_ptwedrxs (uint8 mode, uint8 type, uint8 edrx_value, uint8 paging_time_window, neul_set_ptwedrx_changed_callback ptwedrxcallback)
{
   1c538:	b530      	push	{r4, r5, lr}
    uint8       neul_result      = 0;
   1c53a:	240f      	movs	r4, #15
{
   1c53c:	0005      	movs	r5, r0
    uint8       neul_result      = 0;
   1c53e:	2000      	movs	r0, #0
{
   1c540:	b085      	sub	sp, #20
    uint8       neul_result      = 0;
   1c542:	446c      	add	r4, sp
   1c544:	7020      	strb	r0, [r4, #0]

    if (command_set_edrxs_and_ptw(mode, type, edrx_value, paging_time_window, &neul_result) != RPC_ERR_OK)
   1c546:	9400      	str	r4, [sp, #0]
   1c548:	0028      	movs	r0, r5
   1c54a:	f7e8 fcec 	bl	4f26 <command_set_edrxs_and_ptw>
    {
        return NEUL_RET_ERROR_RPC;
   1c54e:	2302      	movs	r3, #2
    if (command_set_edrxs_and_ptw(mode, type, edrx_value, paging_time_window, &neul_result) != RPC_ERR_OK)
   1c550:	2800      	cmp	r0, #0
   1c552:	d107      	bne.n	1c564 <set_ptwedrxs+0x2c>
    }

    if ((NEUL_RET)neul_result == NEUL_RET_OK)
   1c554:	7823      	ldrb	r3, [r4, #0]
   1c556:	2b00      	cmp	r3, #0
   1c558:	d104      	bne.n	1c564 <set_ptwedrxs+0x2c>
   1c55a:	4a05      	ldr	r2, [pc, #20]	; (1c570 <set_ptwedrxs+0x38>)
    {
        if (mode == EDRX_MODE_UNSOLICITED)
   1c55c:	2d02      	cmp	r5, #2
   1c55e:	d104      	bne.n	1c56a <set_ptwedrxs+0x32>
        {
            set_ptwedrx_changed_callback = ptwedrxcallback;
   1c560:	9908      	ldr	r1, [sp, #32]
   1c562:	6011      	str	r1, [r2, #0]
        }
    }

    return (NEUL_RET)neul_result;

}
   1c564:	0018      	movs	r0, r3
   1c566:	b005      	add	sp, #20
   1c568:	bd30      	pop	{r4, r5, pc}
            set_ptwedrx_changed_callback = NULL;
   1c56a:	6013      	str	r3, [r2, #0]
   1c56c:	e7fa      	b.n	1c564 <set_ptwedrxs+0x2c>
   1c56e:	46c0      	nop			; (mov r8, r8)
   1c570:	01002c64 	.word	0x01002c64

0001c574 <pin_command>:
 * @param pin
 * @param callback:callback for verify pin result
 * @return error or success
 */
NEUL_RET pin_command(uint8 command, uint8 pin1[9], uint8 pin2[9], neul_pin_command_callback callback)
{
   1c574:	b537      	push	{r0, r1, r2, r4, r5, lr}
   1c576:	001d      	movs	r5, r3
    uint8 ret = NEUL_RET_ERROR;
   1c578:	466b      	mov	r3, sp
   1c57a:	1ddc      	adds	r4, r3, #7
   1c57c:	2301      	movs	r3, #1
   1c57e:	7023      	strb	r3, [r4, #0]

    if (command_execute_pin_command(command, pin1, pin2, &ret) == RPC_ERR_OK)
   1c580:	0023      	movs	r3, r4
   1c582:	f7e8 ffee 	bl	5562 <command_execute_pin_command>
   1c586:	2800      	cmp	r0, #0
   1c588:	d104      	bne.n	1c594 <pin_command+0x20>
    {
        if (ret == (NEUL_RET) NEUL_RET_OK)
   1c58a:	7823      	ldrb	r3, [r4, #0]
   1c58c:	2b00      	cmp	r3, #0
   1c58e:	d101      	bne.n	1c594 <pin_command+0x20>
        {
            pin_command_callback = callback;
   1c590:	4b01      	ldr	r3, [pc, #4]	; (1c598 <pin_command+0x24>)
   1c592:	601d      	str	r5, [r3, #0]
        }
    }
    return (NEUL_RET)ret;
   1c594:	7820      	ldrb	r0, [r4, #0]
}
   1c596:	bd3e      	pop	{r1, r2, r3, r4, r5, pc}
   1c598:	01002c4c 	.word	0x01002c4c

0001c59c <get_pin_state>:
 * @brief get SIM pin state
 * @param state ready, sim pin or sim puk
 * @return success or error
 */
NEUL_RET get_pin_state(uint8 *state)
{
   1c59c:	b513      	push	{r0, r1, r4, lr}
    NEUL_RET ret;
    if (state == NULL)
    {
        return NEUL_RET_ERROR;
   1c59e:	2301      	movs	r3, #1
{
   1c5a0:	1e01      	subs	r1, r0, #0
    if (state == NULL)
   1c5a2:	d008      	beq.n	1c5b6 <get_pin_state+0x1a>
    }

    if (command_get_pin_state((uint8 *)&ret, state) != RPC_ERR_OK)
   1c5a4:	466b      	mov	r3, sp
   1c5a6:	1ddc      	adds	r4, r3, #7
   1c5a8:	0020      	movs	r0, r4
   1c5aa:	f7e9 fde5 	bl	6178 <command_get_pin_state>
    {
        return NEUL_RET_ERROR_RPC;
   1c5ae:	2302      	movs	r3, #2
    if (command_get_pin_state((uint8 *)&ret, state) != RPC_ERR_OK)
   1c5b0:	2800      	cmp	r0, #0
   1c5b2:	d100      	bne.n	1c5b6 <get_pin_state+0x1a>
    }

    return ret;
   1c5b4:	7823      	ldrb	r3, [r4, #0]
}
   1c5b6:	0018      	movs	r0, r3
   1c5b8:	bd16      	pop	{r1, r2, r4, pc}

0001c5ba <get_pin_remaining_retries>:
 * @param retries pin or puk remaining retries
 * @param default_retries pin or puk fefault remaining retries
 * @return success or error
 */
NEUL_RET get_pin_remaining_retries(uint8 code, uint8 *retries, uint8 *default_retries)
{
   1c5ba:	b537      	push	{r0, r1, r2, r4, r5, lr}
   1c5bc:	0013      	movs	r3, r2
    NEUL_RET ret;
    if (retries == NULL || default_retries == NULL)
    {
        return NEUL_RET_ERROR;
   1c5be:	2401      	movs	r4, #1
    if (retries == NULL || default_retries == NULL)
   1c5c0:	2900      	cmp	r1, #0
   1c5c2:	d00b      	beq.n	1c5dc <get_pin_remaining_retries+0x22>
   1c5c4:	2a00      	cmp	r2, #0
   1c5c6:	d009      	beq.n	1c5dc <get_pin_remaining_retries+0x22>
    }

    if (command_get_pin_remaining_retries(code, (uint8 *)&ret, retries, default_retries) != RPC_ERR_OK)
   1c5c8:	466a      	mov	r2, sp
   1c5ca:	1dd5      	adds	r5, r2, #7
   1c5cc:	000a      	movs	r2, r1
   1c5ce:	0029      	movs	r1, r5
   1c5d0:	f7e9 fe00 	bl	61d4 <command_get_pin_remaining_retries>
    {
        return NEUL_RET_ERROR_RPC;
   1c5d4:	1924      	adds	r4, r4, r4
    if (command_get_pin_remaining_retries(code, (uint8 *)&ret, retries, default_retries) != RPC_ERR_OK)
   1c5d6:	2800      	cmp	r0, #0
   1c5d8:	d100      	bne.n	1c5dc <get_pin_remaining_retries+0x22>
    }

    return ret;
   1c5da:	782c      	ldrb	r4, [r5, #0]
}
   1c5dc:	0020      	movs	r0, r4
   1c5de:	bd3e      	pop	{r1, r2, r3, r4, r5, pc}

0001c5e0 <neul_radio_register_pin_handler>:
 * @brief register radio command pin handler callback
 * @return
 */
void neul_radio_register_pin_handler(neul_sim_pin_ind_callback callback)
{
    sim_pin_ind_call_back = callback;
   1c5e0:	4b01      	ldr	r3, [pc, #4]	; (1c5e8 <neul_radio_register_pin_handler+0x8>)
   1c5e2:	6018      	str	r0, [r3, #0]
}
   1c5e4:	4770      	bx	lr
   1c5e6:	46c0      	nop			; (mov r8, r8)
   1c5e8:	01002c68 	.word	0x01002c68

0001c5ec <get_edrxs_and_ptw>:
 * @param edrx_value the value of eDRX
 * @param paging_time_window the value of paging_time_window
 * @return success or error
 */
NEUL_RET get_edrxs_and_ptw (uint8 *type, uint8 *edrx_value, uint8 *paging_time_window)
{
   1c5ec:	b537      	push	{r0, r1, r2, r4, r5, lr}
   1c5ee:	0013      	movs	r3, r2
    uint8       neul_result     = 0;
   1c5f0:	466a      	mov	r2, sp
   1c5f2:	1dd5      	adds	r5, r2, #7
   1c5f4:	2200      	movs	r2, #0

    if ((type == NULL) || (edrx_value == NULL) || (paging_time_window == NULL))
    {
        return NEUL_RET_ERROR;
   1c5f6:	2401      	movs	r4, #1
    uint8       neul_result     = 0;
   1c5f8:	702a      	strb	r2, [r5, #0]
    if ((type == NULL) || (edrx_value == NULL) || (paging_time_window == NULL))
   1c5fa:	4290      	cmp	r0, r2
   1c5fc:	d00c      	beq.n	1c618 <get_edrxs_and_ptw+0x2c>
   1c5fe:	4291      	cmp	r1, r2
   1c600:	d00a      	beq.n	1c618 <get_edrxs_and_ptw+0x2c>
   1c602:	4293      	cmp	r3, r2
   1c604:	d008      	beq.n	1c618 <get_edrxs_and_ptw+0x2c>
    }

    if (command_get_edrxs_and_ptw(&neul_result, type, edrx_value, paging_time_window) != RPC_ERR_OK)
   1c606:	000a      	movs	r2, r1
   1c608:	0001      	movs	r1, r0
   1c60a:	0028      	movs	r0, r5
   1c60c:	f7e8 fcc4 	bl	4f98 <command_get_edrxs_and_ptw>
    {
        return NEUL_RET_ERROR_RPC;
   1c610:	1924      	adds	r4, r4, r4
    if (command_get_edrxs_and_ptw(&neul_result, type, edrx_value, paging_time_window) != RPC_ERR_OK)
   1c612:	2800      	cmp	r0, #0
   1c614:	d100      	bne.n	1c618 <get_edrxs_and_ptw+0x2c>
    }

    return (NEUL_RET)neul_result;
   1c616:	782c      	ldrb	r4, [r5, #0]

}
   1c618:	0020      	movs	r0, r4
   1c61a:	bd3e      	pop	{r1, r2, r3, r4, r5, pc}

0001c61c <remote_command_service_recovery>:
void remote_command_service_recovery( CORES core )
{
   1c61c:	b510      	push	{r4, lr}
    UNUSED(core);

    /* safely call callback */
    neul_service_recovery_callback callback = service_recovery_callback;
   1c61e:	4b03      	ldr	r3, [pc, #12]	; (1c62c <remote_command_service_recovery+0x10>)
   1c620:	681b      	ldr	r3, [r3, #0]
    if (callback != NULL)
   1c622:	2b00      	cmp	r3, #0
   1c624:	d000      	beq.n	1c628 <remote_command_service_recovery+0xc>
    {
        callback();
   1c626:	4798      	blx	r3
    }
}
   1c628:	bd10      	pop	{r4, pc}
   1c62a:	46c0      	nop			; (mov r8, r8)
   1c62c:	01002c58 	.word	0x01002c58

0001c630 <activate_pdp_req>:
 * @param cid cid to active
 * @param callback callback for php context activate result
 * @return success or error
 */
NEUL_RET activate_pdp_req(uint16 cid, neul_pdp_act_result_callback callback)
{
   1c630:	b537      	push	{r0, r1, r2, r4, r5, lr}
    NEUL_RET ret;

    if(command_pdp_activate_req(cid, (uint8*)&ret) != RPC_ERR_OK)
   1c632:	466b      	mov	r3, sp
   1c634:	1ddc      	adds	r4, r3, #7
{
   1c636:	000d      	movs	r5, r1
    if(command_pdp_activate_req(cid, (uint8*)&ret) != RPC_ERR_OK)
   1c638:	0021      	movs	r1, r4
   1c63a:	f7e8 f974 	bl	4926 <command_pdp_activate_req>
    {
        return NEUL_RET_ERROR_RPC;
   1c63e:	2302      	movs	r3, #2
    if(command_pdp_activate_req(cid, (uint8*)&ret) != RPC_ERR_OK)
   1c640:	2800      	cmp	r0, #0
   1c642:	d104      	bne.n	1c64e <activate_pdp_req+0x1e>
    }

    if (ret == NEUL_RET_OK)
   1c644:	7823      	ldrb	r3, [r4, #0]
   1c646:	2b00      	cmp	r3, #0
   1c648:	d101      	bne.n	1c64e <activate_pdp_req+0x1e>
    {
        pdp_act_callback = callback;
   1c64a:	4a02      	ldr	r2, [pc, #8]	; (1c654 <activate_pdp_req+0x24>)
   1c64c:	6015      	str	r5, [r2, #0]
    }

    return ret;
}
   1c64e:	0018      	movs	r0, r3
   1c650:	bd3e      	pop	{r1, r2, r3, r4, r5, pc}
   1c652:	46c0      	nop			; (mov r8, r8)
   1c654:	01002c40 	.word	0x01002c40

0001c658 <deactivate_pdp_req>:
 * @brief deactivate pdp context
 * @param cid cid to deactivate
 * @return success or error
 */
NEUL_RET deactivate_pdp_req(uint16 cid)
{
   1c658:	b513      	push	{r0, r1, r4, lr}
    NEUL_RET ret;

    if(command_pdp_deactivate_req(cid, (uint8*)&ret) != RPC_ERR_OK)
   1c65a:	466b      	mov	r3, sp
   1c65c:	1ddc      	adds	r4, r3, #7
   1c65e:	0021      	movs	r1, r4
   1c660:	f7e8 f98b 	bl	497a <command_pdp_deactivate_req>
    {
        return NEUL_RET_ERROR_RPC;
   1c664:	2302      	movs	r3, #2
    if(command_pdp_deactivate_req(cid, (uint8*)&ret) != RPC_ERR_OK)
   1c666:	2800      	cmp	r0, #0
   1c668:	d100      	bne.n	1c66c <deactivate_pdp_req+0x14>
    }

    return ret;
   1c66a:	7823      	ldrb	r3, [r4, #0]
}
   1c66c:	0018      	movs	r0, r3
   1c66e:	bd16      	pop	{r1, r2, r4, pc}

0001c670 <remote_command_pdp_act_or_deact_result_ind>:

void remote_command_pdp_act_or_deact_result_ind(CORES core, uint8 cid, uint8 state, uint8 result)
{
   1c670:	b570      	push	{r4, r5, r6, lr}
   1c672:	001c      	movs	r4, r3
    UNUSED(core);

    /* safely call callback */
    neul_pdp_act_result_callback callback = pdp_act_callback;
   1c674:	4b08      	ldr	r3, [pc, #32]	; (1c698 <remote_command_pdp_act_or_deact_result_ind+0x28>)
{
   1c676:	000d      	movs	r5, r1
    neul_pdp_act_result_callback callback = pdp_act_callback;
   1c678:	681b      	ldr	r3, [r3, #0]
{
   1c67a:	0016      	movs	r6, r2
    if (callback != NULL)
   1c67c:	2b00      	cmp	r3, #0
   1c67e:	d001      	beq.n	1c684 <remote_command_pdp_act_or_deact_result_ind+0x14>
    {
        callback(result);
   1c680:	0020      	movs	r0, r4
   1c682:	4798      	blx	r3
    }

    neul_pdp_context_report_callback report_callback = pdp_context_report_callback;
   1c684:	4b05      	ldr	r3, [pc, #20]	; (1c69c <remote_command_pdp_act_or_deact_result_ind+0x2c>)
   1c686:	681b      	ldr	r3, [r3, #0]
    if (pdp_context_report_callback != NULL)
   1c688:	2b00      	cmp	r3, #0
   1c68a:	d003      	beq.n	1c694 <remote_command_pdp_act_or_deact_result_ind+0x24>
    {
        report_callback(cid, (PDP_CONTEXT_REPORT_RESULT_STATE)state, (PDP_CONTEXT_REPORT_RESULT)result);
   1c68c:	0022      	movs	r2, r4
   1c68e:	0031      	movs	r1, r6
   1c690:	0028      	movs	r0, r5
   1c692:	4798      	blx	r3
    }
}
   1c694:	bd70      	pop	{r4, r5, r6, pc}
   1c696:	46c0      	nop			; (mov r8, r8)
   1c698:	01002c40 	.word	0x01002c40
   1c69c:	01002c44 	.word	0x01002c44

0001c6a0 <set_pdp_context_report_callback>:
 * @brief set pdp context activate or deactivate result report callback
 * @param callback pdp context activate or deactivate result report callback
 */
void set_pdp_context_report_callback(neul_pdp_context_report_callback callback)
{
    pdp_context_report_callback = callback;
   1c6a0:	4b01      	ldr	r3, [pc, #4]	; (1c6a8 <set_pdp_context_report_callback+0x8>)
   1c6a2:	6018      	str	r0, [r3, #0]
}
   1c6a4:	4770      	bx	lr
   1c6a6:	46c0      	nop			; (mov r8, r8)
   1c6a8:	01002c44 	.word	0x01002c44

0001c6ac <get_pdp_state>:

NEUL_RET get_pdp_state(uint8 cid, uint8 *state)
{
   1c6ac:	b5f0      	push	{r4, r5, r6, r7, lr}
   1c6ae:	000c      	movs	r4, r1
    uint16 apn_length     = 0;
   1c6b0:	2100      	movs	r1, #0
{
   1c6b2:	b0c1      	sub	sp, #260	; 0x104
    uint16 context_length = 0;
    NEUL_RET result ;
    pdp_context context = {0};
   1c6b4:	ad22      	add	r5, sp, #136	; 0x88
    uint16 context_length = 0;
   1c6b6:	ab02      	add	r3, sp, #8
{
   1c6b8:	9005      	str	r0, [sp, #20]
    uint16 apn_length     = 0;
   1c6ba:	af07      	add	r7, sp, #28
    pdp_context context = {0};
   1c6bc:	2278      	movs	r2, #120	; 0x78
   1c6be:	0028      	movs	r0, r5
    uint16 context_length = 0;
   1c6c0:	82d9      	strh	r1, [r3, #22]
    uint16 apn_length     = 0;
   1c6c2:	8039      	strh	r1, [r7, #0]
    pdp_context context = {0};
   1c6c4:	f7e3 fe0c 	bl	2e0 <memset>
    uint16 context_max_length = sizeof(context);
    uint8 apn_str[NEUL_MAX_APN_SIZE];
    context.apn = &apn_str[0];
   1c6c8:	ab08      	add	r3, sp, #32
   1c6ca:	60eb      	str	r3, [r5, #12]

    if (state == NULL)
   1c6cc:	2c00      	cmp	r4, #0
   1c6ce:	d102      	bne.n	1c6d6 <get_pdp_state+0x2a>
    {
        return NEUL_RET_ERROR;
   1c6d0:	2001      	movs	r0, #1
    {
        return NEUL_RET_ERROR;
    }

    return NEUL_RET_OK;
}
   1c6d2:	b041      	add	sp, #260	; 0x104
   1c6d4:	bdf0      	pop	{r4, r5, r6, r7, pc}
    if(command_get_pdp_context(cid, (uint8 *)&result, NEUL_MAX_APN_SIZE, &apn_length, context.apn,
   1c6d6:	2613      	movs	r6, #19
   1c6d8:	aa02      	add	r2, sp, #8
   1c6da:	18b6      	adds	r6, r6, r2
   1c6dc:	2216      	movs	r2, #22
   1c6de:	a902      	add	r1, sp, #8
   1c6e0:	1852      	adds	r2, r2, r1
   1c6e2:	9202      	str	r2, [sp, #8]
   1c6e4:	2278      	movs	r2, #120	; 0x78
   1c6e6:	9300      	str	r3, [sp, #0]
   1c6e8:	9201      	str	r2, [sp, #4]
   1c6ea:	9503      	str	r5, [sp, #12]
   1c6ec:	003b      	movs	r3, r7
   1c6ee:	3a13      	subs	r2, #19
   1c6f0:	0031      	movs	r1, r6
   1c6f2:	9805      	ldr	r0, [sp, #20]
   1c6f4:	f7e7 f9e9 	bl	3aca <command_get_pdp_context>
   1c6f8:	2800      	cmp	r0, #0
   1c6fa:	d1e9      	bne.n	1c6d0 <get_pdp_state+0x24>
    *state = context.state;
   1c6fc:	23f5      	movs	r3, #245	; 0xf5
   1c6fe:	aa02      	add	r2, sp, #8
   1c700:	189b      	adds	r3, r3, r2
   1c702:	781b      	ldrb	r3, [r3, #0]
   1c704:	7023      	strb	r3, [r4, #0]
    if((*state) < 2)
   1c706:	2b01      	cmp	r3, #1
   1c708:	d805      	bhi.n	1c716 <get_pdp_state+0x6a>
        *state = 0;
   1c70a:	7020      	strb	r0, [r4, #0]
    if (result != NEUL_RET_OK)
   1c70c:	7830      	ldrb	r0, [r6, #0]
   1c70e:	1e43      	subs	r3, r0, #1
   1c710:	4198      	sbcs	r0, r3
        return NEUL_RET_ERROR;
   1c712:	b2c0      	uxtb	r0, r0
   1c714:	e7dd      	b.n	1c6d2 <get_pdp_state+0x26>
        *state = 1;
   1c716:	2301      	movs	r3, #1
   1c718:	7023      	strb	r3, [r4, #0]
   1c71a:	e7f7      	b.n	1c70c <get_pdp_state+0x60>

0001c71c <remote_command_edrx_changed_ind>:


void remote_command_edrx_changed_ind(CORES core, uint8 type, uint8 requested_edrx_value, uint8 nw_provided_edrx_value, uint8 paging_time_window, uint8 requested_paging_time_window)
{
   1c71c:	b5f0      	push	{r4, r5, r6, r7, lr}
   1c71e:	b087      	sub	sp, #28
   1c720:	001e      	movs	r6, r3
   1c722:	ab0c      	add	r3, sp, #48	; 0x30
   1c724:	781f      	ldrb	r7, [r3, #0]
   1c726:	ab0d      	add	r3, sp, #52	; 0x34
   1c728:	781b      	ldrb	r3, [r3, #0]
   1c72a:	9104      	str	r1, [sp, #16]
   1c72c:	9305      	str	r3, [sp, #20]
    UNUSED(core);

    /* safely call callback */
    neul_set_edrx_changed_callback      edrx_changed_callback    = set_edrx_changed_callback;
   1c72e:	4b0d      	ldr	r3, [pc, #52]	; (1c764 <remote_command_edrx_changed_ind+0x48>)
{
   1c730:	0015      	movs	r5, r2
    neul_set_edrx_changed_callback      edrx_changed_callback    = set_edrx_changed_callback;
   1c732:	681b      	ldr	r3, [r3, #0]
   1c734:	1e1c      	subs	r4, r3, #0
    neul_set_ptwedrx_changed_callback   ptwedrx_changed_callback = set_ptwedrx_changed_callback;
   1c736:	4b0c      	ldr	r3, [pc, #48]	; (1c768 <remote_command_edrx_changed_ind+0x4c>)
   1c738:	681b      	ldr	r3, [r3, #0]
   1c73a:	9303      	str	r3, [sp, #12]

    if (edrx_changed_callback != NULL)
   1c73c:	d004      	beq.n	1c748 <remote_command_edrx_changed_ind+0x2c>
    {
        edrx_changed_callback(type, requested_edrx_value, nw_provided_edrx_value, paging_time_window);
   1c73e:	003b      	movs	r3, r7
   1c740:	0032      	movs	r2, r6
   1c742:	0029      	movs	r1, r5
   1c744:	9804      	ldr	r0, [sp, #16]
   1c746:	47a0      	blx	r4
    }

    if (ptwedrx_changed_callback != NULL)
   1c748:	9b03      	ldr	r3, [sp, #12]
   1c74a:	2b00      	cmp	r3, #0
   1c74c:	d007      	beq.n	1c75e <remote_command_edrx_changed_ind+0x42>
    {
        ptwedrx_changed_callback(type, requested_edrx_value, nw_provided_edrx_value, paging_time_window, requested_paging_time_window);
   1c74e:	9b05      	ldr	r3, [sp, #20]
   1c750:	0032      	movs	r2, r6
   1c752:	9300      	str	r3, [sp, #0]
   1c754:	0029      	movs	r1, r5
   1c756:	003b      	movs	r3, r7
   1c758:	9804      	ldr	r0, [sp, #16]
   1c75a:	9c03      	ldr	r4, [sp, #12]
   1c75c:	47a0      	blx	r4
    }
}
   1c75e:	b007      	add	sp, #28
   1c760:	bdf0      	pop	{r4, r5, r6, r7, pc}
   1c762:	46c0      	nop			; (mov r8, r8)
   1c764:	01002c5c 	.word	0x01002c5c
   1c768:	01002c64 	.word	0x01002c64

0001c76c <get_extended_error_cause>:
 * @param attach_rejected flag to indicate attach reject
 * @param cause the cause of attach reject
 * @return success or error
 */
NEUL_RET get_extended_error_cause (uint8 *attach_rejected, EMM_CAUSE_INFO *cause)
{
   1c76c:	b510      	push	{r4, lr}
    uint8       neul_result     = 0;

    if (cause == NULL)
    {
        return NEUL_RET_ERROR;
   1c76e:	2301      	movs	r3, #1
    if (cause == NULL)
   1c770:	2900      	cmp	r1, #0
   1c772:	d005      	beq.n	1c780 <get_extended_error_cause+0x14>
    }

    if (command_get_extended_error_cause(attach_rejected, (uint8 *)cause) != RPC_ERR_OK)
   1c774:	f7e8 fc82 	bl	507c <command_get_extended_error_cause>
    {
        return NEUL_RET_ERROR_RPC;
    }

    return (NEUL_RET)neul_result;
   1c778:	0003      	movs	r3, r0
   1c77a:	1e58      	subs	r0, r3, #1
   1c77c:	4183      	sbcs	r3, r0
   1c77e:	005b      	lsls	r3, r3, #1

}
   1c780:	0018      	movs	r0, r3
   1c782:	bd10      	pop	{r4, pc}

0001c784 <get_edrxedp>:
 * @param nw_provided_edrx the eDRX value of NW provide(nw_provided_edrx is 4-bit value)
 * @param paging_time the paging time window(paging_time is 4-bit value)
 * @return success or error
 */
NEUL_RET get_edrxedp (uint8 *registered_state, uint8 *act_type, uint8 *edrx_valid, uint8 *request_edrx, uint8 *nw_provided_edrx, uint8 *paging_time)
{
   1c784:	b5f0      	push	{r4, r5, r6, r7, lr}
    NEUL_RET    neul_result = NEUL_RET_OK;
   1c786:	2517      	movs	r5, #23
   1c788:	2400      	movs	r4, #0
{
   1c78a:	b087      	sub	sp, #28
    NEUL_RET    neul_result = NEUL_RET_OK;
   1c78c:	446d      	add	r5, sp
   1c78e:	702c      	strb	r4, [r5, #0]
{
   1c790:	9e0c      	ldr	r6, [sp, #48]	; 0x30
   1c792:	9f0d      	ldr	r7, [sp, #52]	; 0x34

    if ((registered_state == NULL) || (act_type == NULL) || (edrx_valid == NULL) || (request_edrx == NULL) || (nw_provided_edrx == NULL) || (paging_time == NULL))
    {
        return NEUL_RET_ERROR;
   1c794:	3401      	adds	r4, #1
    if ((registered_state == NULL) || (act_type == NULL) || (edrx_valid == NULL) || (request_edrx == NULL) || (nw_provided_edrx == NULL) || (paging_time == NULL))
   1c796:	2800      	cmp	r0, #0
   1c798:	d016      	beq.n	1c7c8 <get_edrxedp+0x44>
   1c79a:	2900      	cmp	r1, #0
   1c79c:	d014      	beq.n	1c7c8 <get_edrxedp+0x44>
   1c79e:	2a00      	cmp	r2, #0
   1c7a0:	d012      	beq.n	1c7c8 <get_edrxedp+0x44>
   1c7a2:	2b00      	cmp	r3, #0
   1c7a4:	d010      	beq.n	1c7c8 <get_edrxedp+0x44>
   1c7a6:	2e00      	cmp	r6, #0
   1c7a8:	d00e      	beq.n	1c7c8 <get_edrxedp+0x44>
   1c7aa:	2f00      	cmp	r7, #0
   1c7ac:	d00c      	beq.n	1c7c8 <get_edrxedp+0x44>
    }

    if (command_get_edrxrdp((uint8 *)&neul_result, registered_state, act_type, edrx_valid, request_edrx, nw_provided_edrx, paging_time) != RPC_ERR_OK)
   1c7ae:	9300      	str	r3, [sp, #0]
   1c7b0:	9702      	str	r7, [sp, #8]
   1c7b2:	0013      	movs	r3, r2
   1c7b4:	9601      	str	r6, [sp, #4]
   1c7b6:	000a      	movs	r2, r1
   1c7b8:	0001      	movs	r1, r0
   1c7ba:	0028      	movs	r0, r5
   1c7bc:	f7e8 fc8c 	bl	50d8 <command_get_edrxrdp>
    {
        return NEUL_RET_ERROR_RPC;
   1c7c0:	3401      	adds	r4, #1
    if (command_get_edrxrdp((uint8 *)&neul_result, registered_state, act_type, edrx_valid, request_edrx, nw_provided_edrx, paging_time) != RPC_ERR_OK)
   1c7c2:	2800      	cmp	r0, #0
   1c7c4:	d100      	bne.n	1c7c8 <get_edrxedp+0x44>
    }

    return neul_result;
   1c7c6:	782c      	ldrb	r4, [r5, #0]
}
   1c7c8:	0020      	movs	r0, r4
   1c7ca:	b007      	add	sp, #28
   1c7cc:	bdf0      	pop	{r4, r5, r6, r7, pc}

0001c7ce <get_mtu_size>:
 * @param ip-mtu in bytes
 * @param non-ip-mtu in bytes
 * @return success or error
 */
NEUL_RET get_mtu_size (uint8 cid, uint16 *ip_mtu_size, uint16 *non_ip_mtu_size)
{
   1c7ce:	b537      	push	{r0, r1, r2, r4, r5, lr}
   1c7d0:	0013      	movs	r3, r2
    NEUL_RET    neul_result = NEUL_RET_OK;
   1c7d2:	466a      	mov	r2, sp
   1c7d4:	1dd5      	adds	r5, r2, #7
   1c7d6:	2200      	movs	r2, #0

    if ((ip_mtu_size == NULL) || (non_ip_mtu_size == NULL) || (cid > NEUL_MAX_CID))
    {
        return NEUL_RET_ERROR;
   1c7d8:	2401      	movs	r4, #1
    NEUL_RET    neul_result = NEUL_RET_OK;
   1c7da:	702a      	strb	r2, [r5, #0]
    if ((ip_mtu_size == NULL) || (non_ip_mtu_size == NULL) || (cid > NEUL_MAX_CID))
   1c7dc:	4291      	cmp	r1, r2
   1c7de:	d00b      	beq.n	1c7f8 <get_mtu_size+0x2a>
   1c7e0:	4293      	cmp	r3, r2
   1c7e2:	d009      	beq.n	1c7f8 <get_mtu_size+0x2a>
   1c7e4:	280a      	cmp	r0, #10
   1c7e6:	d807      	bhi.n	1c7f8 <get_mtu_size+0x2a>
    }

    if (command_get_mtu_size(cid, (uint8 *)&neul_result, ip_mtu_size, non_ip_mtu_size) != RPC_ERR_OK)
   1c7e8:	000a      	movs	r2, r1
   1c7ea:	0029      	movs	r1, r5
   1c7ec:	f7e8 fe81 	bl	54f2 <command_get_mtu_size>
    {
        return NEUL_RET_ERROR_RPC;
   1c7f0:	1924      	adds	r4, r4, r4
    if (command_get_mtu_size(cid, (uint8 *)&neul_result, ip_mtu_size, non_ip_mtu_size) != RPC_ERR_OK)
   1c7f2:	2800      	cmp	r0, #0
   1c7f4:	d100      	bne.n	1c7f8 <get_mtu_size+0x2a>
    }

    return neul_result;
   1c7f6:	782c      	ldrb	r4, [r5, #0]
}
   1c7f8:	0020      	movs	r0, r4
   1c7fa:	bd3e      	pop	{r1, r2, r3, r4, r5, pc}

0001c7fc <remote_command_cring_ind>:
/**
* @brief RPC function called by the protocol core to indicate the UE was paged. Expected to trigger an A+CRING unsolicited indication.
* @param core Unused parameter
*/
void remote_command_cring_ind(CORES core)
{
   1c7fc:	b510      	push	{r4, lr}
    UNUSED(core);

    /* safely call callback */
    neul_cring_ind_callback callback = cring_ind_callback;
   1c7fe:	4b03      	ldr	r3, [pc, #12]	; (1c80c <remote_command_cring_ind+0x10>)
   1c800:	681b      	ldr	r3, [r3, #0]
    if (callback)
   1c802:	2b00      	cmp	r3, #0
   1c804:	d000      	beq.n	1c808 <remote_command_cring_ind+0xc>
    {
        callback();
   1c806:	4798      	blx	r3
    }
}
   1c808:	bd10      	pop	{r4, pc}
   1c80a:	46c0      	nop			; (mov r8, r8)
   1c80c:	01002c30 	.word	0x01002c30

0001c810 <get_apn_rate_control_context>:
 * @maximum_uplink_rate specifies the maximum number of messages the UE is restricted to send per uplink time unit
 * @except_uplink_time_unit specifies the time unit to be used for the exception data maximum uplink rate
 * @except_maximum_uplink_rate specifies the maximum number of additional exception messages the UE is restricted to send once maximum_uplink_rate is reached, per uplink time unit
 */
NEUL_RET get_apn_rate_control_context(uint8 cid, uint8 *additional_exception_reports, uint8 *uplink_time_unit, uint32 *maximum_uplink_rate, uint8 *except_uplink_time_unit, uint32 *except_maximum_uplink_rate)
{
   1c810:	b530      	push	{r4, r5, lr}
    NEUL_RET result;

    if ((additional_exception_reports == NULL) || (uplink_time_unit == NULL) || (maximum_uplink_rate == NULL))
    {
        return NEUL_RET_ERROR;
   1c812:	2401      	movs	r4, #1
{
   1c814:	b087      	sub	sp, #28
    if ((additional_exception_reports == NULL) || (uplink_time_unit == NULL) || (maximum_uplink_rate == NULL))
   1c816:	2900      	cmp	r1, #0
   1c818:	d013      	beq.n	1c842 <get_apn_rate_control_context+0x32>
   1c81a:	2a00      	cmp	r2, #0
   1c81c:	d011      	beq.n	1c842 <get_apn_rate_control_context+0x32>
   1c81e:	2b00      	cmp	r3, #0
   1c820:	d00f      	beq.n	1c842 <get_apn_rate_control_context+0x32>
    }

    if(command_get_apn_rate_control_context(cid ,(uint8 *)&result, additional_exception_reports, uplink_time_unit, maximum_uplink_rate, except_uplink_time_unit, except_maximum_uplink_rate) != RPC_ERR_OK)
   1c822:	2517      	movs	r5, #23
   1c824:	9c0b      	ldr	r4, [sp, #44]	; 0x2c
   1c826:	446d      	add	r5, sp
   1c828:	9402      	str	r4, [sp, #8]
   1c82a:	9c0a      	ldr	r4, [sp, #40]	; 0x28
   1c82c:	9300      	str	r3, [sp, #0]
   1c82e:	9401      	str	r4, [sp, #4]
   1c830:	0013      	movs	r3, r2
   1c832:	000a      	movs	r2, r1
   1c834:	0029      	movs	r1, r5
   1c836:	f7e8 ff17 	bl	5668 <command_get_apn_rate_control_context>
    {
        return NEUL_RET_ERROR_RPC;
   1c83a:	2402      	movs	r4, #2
    if(command_get_apn_rate_control_context(cid ,(uint8 *)&result, additional_exception_reports, uplink_time_unit, maximum_uplink_rate, except_uplink_time_unit, except_maximum_uplink_rate) != RPC_ERR_OK)
   1c83c:	2800      	cmp	r0, #0
   1c83e:	d100      	bne.n	1c842 <get_apn_rate_control_context+0x32>
    }

    return result;
   1c840:	782c      	ldrb	r4, [r5, #0]
}
   1c842:	0020      	movs	r0, r4
   1c844:	b007      	add	sp, #28
   1c846:	bd30      	pop	{r4, r5, pc}

0001c848 <remote_command_psm_status_ind>:
 * indicates the the psm status changed.
 * @param core The core this is called on
 * @param psm_status 0:mormal mode;1:psm mode
 */
void remote_command_psm_status_ind(CORES core, uint8 psm_status)
{
   1c848:	b510      	push	{r4, lr}
    UNUSED(core);

    /* safely call callback */
    neul_psm_status_reporting_callback psm_status_callback = neul_psm_status_callback;
   1c84a:	4b03      	ldr	r3, [pc, #12]	; (1c858 <remote_command_psm_status_ind+0x10>)
   1c84c:	681b      	ldr	r3, [r3, #0]
    if (psm_status_callback != NULL)
   1c84e:	2b00      	cmp	r3, #0
   1c850:	d001      	beq.n	1c856 <remote_command_psm_status_ind+0xe>
    {
        psm_status_callback(psm_status);
   1c852:	0008      	movs	r0, r1
   1c854:	4798      	blx	r3
    }
}
   1c856:	bd10      	pop	{r4, pc}
   1c858:	01002c3c 	.word	0x01002c3c

0001c85c <set_power_band_class>:
 * @param band band to set
 * @param power_class
 * @return success or error
 */
NEUL_RET set_power_band_class(uint8 band, uint8 power_class)
{
   1c85c:	b513      	push	{r0, r1, r4, lr}
    NEUL_RET          result;

    if (command_set_power_band_class(band, power_class, (uint8 *)&result) != RPC_ERR_OK)
   1c85e:	466b      	mov	r3, sp
   1c860:	1ddc      	adds	r4, r3, #7
   1c862:	0022      	movs	r2, r4
   1c864:	f7e8 ff4a 	bl	56fc <command_set_power_band_class>
    {
        return NEUL_RET_ERROR_RPC;
   1c868:	2302      	movs	r3, #2
    if (command_set_power_band_class(band, power_class, (uint8 *)&result) != RPC_ERR_OK)
   1c86a:	2800      	cmp	r0, #0
   1c86c:	d100      	bne.n	1c870 <set_power_band_class+0x14>
    }

    return result;
   1c86e:	7823      	ldrb	r3, [r4, #0]
}
   1c870:	0018      	movs	r0, r3
   1c872:	bd16      	pop	{r1, r2, r4, pc}

0001c874 <get_power_band_class>:
 * @brief read the map of band and power class
 * @param band_map_power_class_t the value of band and power class
 * @return success or error
 */
NEUL_RET get_power_band_class(uint8 band, uint8 *power_class)
{
   1c874:	b513      	push	{r0, r1, r4, lr}
   1c876:	000a      	movs	r2, r1
    NEUL_RET         get_result;

    if (power_class == NULL)
    {
        return NEUL_RET_ERROR;
   1c878:	2301      	movs	r3, #1
    if (power_class == NULL)
   1c87a:	2900      	cmp	r1, #0
   1c87c:	d008      	beq.n	1c890 <get_power_band_class+0x1c>
    }

    if (command_get_power_band_class(band, (uint8 *)&get_result, power_class) != RPC_ERR_OK)
   1c87e:	466b      	mov	r3, sp
   1c880:	1ddc      	adds	r4, r3, #7
   1c882:	0021      	movs	r1, r4
   1c884:	f7e8 ff6b 	bl	575e <command_get_power_band_class>
    {
       return NEUL_RET_ERROR_RPC;
   1c888:	2302      	movs	r3, #2
    if (command_get_power_band_class(band, (uint8 *)&get_result, power_class) != RPC_ERR_OK)
   1c88a:	2800      	cmp	r0, #0
   1c88c:	d100      	bne.n	1c890 <get_power_band_class+0x1c>
    }

    return get_result;
   1c88e:	7823      	ldrb	r3, [r4, #0]
}
   1c890:	0018      	movs	r0, r3
   1c892:	bd16      	pop	{r1, r2, r4, pc}

0001c894 <set_initial_pdp_context>:
 * @brief set initial pdp context
 * @param attach_without_pdn EPS Attach with or without PDN connection
 * @return success or error
 */
NEUL_RET set_initial_pdp_context(uint8 attach_without_pdn)
{
   1c894:	b513      	push	{r0, r1, r4, lr}
    NEUL_RET          result;

    if (command_set_initial_pdp_context(attach_without_pdn, (uint8 *)&result) != RPC_ERR_OK)
   1c896:	466b      	mov	r3, sp
   1c898:	1ddc      	adds	r4, r3, #7
   1c89a:	0021      	movs	r1, r4
   1c89c:	f7e8 ffb5 	bl	580a <command_set_initial_pdp_context>
    {
        return NEUL_RET_ERROR_RPC;
   1c8a0:	2302      	movs	r3, #2
    if (command_set_initial_pdp_context(attach_without_pdn, (uint8 *)&result) != RPC_ERR_OK)
   1c8a2:	2800      	cmp	r0, #0
   1c8a4:	d100      	bne.n	1c8a8 <set_initial_pdp_context+0x14>
    }

    return result;
   1c8a6:	7823      	ldrb	r3, [r4, #0]
}
   1c8a8:	0018      	movs	r0, r3
   1c8aa:	bd16      	pop	{r1, r2, r4, pc}

0001c8ac <get_initial_pdp_context>:
 * @brief get initial pdp context configuration parameters
 * @param attach_without_pdn EPS Attach with or without PDN connection
 * @return success or error
 */
NEUL_RET get_initial_pdp_context(uint8 *attach_without_pdn)
{
   1c8ac:	b513      	push	{r0, r1, r4, lr}
    NEUL_RET          result;

    if (attach_without_pdn == NULL)
    {
        return NEUL_RET_ERROR;
   1c8ae:	2301      	movs	r3, #1
{
   1c8b0:	1e01      	subs	r1, r0, #0
    if (attach_without_pdn == NULL)
   1c8b2:	d008      	beq.n	1c8c6 <get_initial_pdp_context+0x1a>
    }

    if (command_get_initial_pdp_context((uint8 *)&result, attach_without_pdn) != RPC_ERR_OK)
   1c8b4:	466b      	mov	r3, sp
   1c8b6:	1ddc      	adds	r4, r3, #7
   1c8b8:	0020      	movs	r0, r4
   1c8ba:	f7e8 ffcf 	bl	585c <command_get_initial_pdp_context>
    {
        return NEUL_RET_ERROR_RPC;
   1c8be:	2302      	movs	r3, #2
    if (command_get_initial_pdp_context((uint8 *)&result, attach_without_pdn) != RPC_ERR_OK)
   1c8c0:	2800      	cmp	r0, #0
   1c8c2:	d100      	bne.n	1c8c6 <get_initial_pdp_context+0x1a>
    }

    return result;
   1c8c4:	7823      	ldrb	r3, [r4, #0]
}
   1c8c6:	0018      	movs	r0, r3
   1c8c8:	bd16      	pop	{r1, r2, r4, pc}
	...

0001c8cc <remote_command_get_plmn_results_ind>:
 * @param available_plmn_length the available plmn information list array size
 * @param available_plmn the available plmn information list array point
 * @param result get available plmn information result
 */
void remote_command_get_plmn_results_ind(CORES core, uint16 available_plmn_length, uint8 *available_plmn, uint8 result)
{
   1c8cc:	b510      	push	{r4, lr}
   1c8ce:	0010      	movs	r0, r2
    UNUSED(core);

    /* safely call callback */
    neul_get_available_plmn_callback callback = get_available_plmn_callback;
   1c8d0:	4a04      	ldr	r2, [pc, #16]	; (1c8e4 <remote_command_get_plmn_results_ind+0x18>)
   1c8d2:	6814      	ldr	r4, [r2, #0]
    if (callback != NULL)
   1c8d4:	2c00      	cmp	r4, #0
   1c8d6:	d003      	beq.n	1c8e0 <remote_command_get_plmn_results_ind+0x14>
    {
        callback((plmn_info*)available_plmn, (uint8)available_plmn_length/sizeof(plmn_info), result); //lint !e826
   1c8d8:	b2c9      	uxtb	r1, r1
   1c8da:	0889      	lsrs	r1, r1, #2
   1c8dc:	001a      	movs	r2, r3
   1c8de:	47a0      	blx	r4
    }
}
   1c8e0:	bd10      	pop	{r4, pc}
   1c8e2:	46c0      	nop			; (mov r8, r8)
   1c8e4:	01002c34 	.word	0x01002c34

0001c8e8 <abort_radio_processing_command>:
/**
 * @brief abort radio processing command
 * @return success or error
 */
NEUL_RET abort_radio_processing_command(void)
{
   1c8e8:	b513      	push	{r0, r1, r4, lr}
    NEUL_RET          result;

    if (command_abort_processing_command((uint8*)&result) != RPC_ERR_OK)
   1c8ea:	466b      	mov	r3, sp
   1c8ec:	1ddc      	adds	r4, r3, #7
   1c8ee:	0020      	movs	r0, r4
   1c8f0:	f7e9 f8d9 	bl	5aa6 <command_abort_processing_command>
    {
        return NEUL_RET_ERROR;
   1c8f4:	2301      	movs	r3, #1
    if (command_abort_processing_command((uint8*)&result) != RPC_ERR_OK)
   1c8f6:	2800      	cmp	r0, #0
   1c8f8:	d100      	bne.n	1c8fc <abort_radio_processing_command+0x14>
    }

    return result;
   1c8fa:	7823      	ldrb	r3, [r4, #0]
}
   1c8fc:	0018      	movs	r0, r3
   1c8fe:	bd16      	pop	{r1, r2, r4, pc}

0001c900 <remote_command_radio_command_abort_ind>:

void remote_command_radio_command_abort_ind(CORES core, uint8 result)
{
   1c900:	b510      	push	{r4, lr}
    UNUSED(core);

    /* safely call callback */
    neul_radio_cmd_abort_callback callback = radio_command_abort_callback;
   1c902:	4b03      	ldr	r3, [pc, #12]	; (1c910 <remote_command_radio_command_abort_ind+0x10>)
   1c904:	681b      	ldr	r3, [r3, #0]
    if (callback != NULL)
   1c906:	2b00      	cmp	r3, #0
   1c908:	d001      	beq.n	1c90e <remote_command_radio_command_abort_ind+0xe>
    {
        callback((NEUL_RET)result);
   1c90a:	0008      	movs	r0, r1
   1c90c:	4798      	blx	r3
    }
}
   1c90e:	bd10      	pop	{r4, pc}
   1c910:	01002c50 	.word	0x01002c50

0001c914 <neul_radio_register_abort_handler>:
 * @brief register radio command abort handler callback
 * @return
 */
void neul_radio_register_abort_handler(neul_radio_cmd_abort_callback  callback)
{
    radio_command_abort_callback = callback;
   1c914:	4b01      	ldr	r3, [pc, #4]	; (1c91c <neul_radio_register_abort_handler+0x8>)
   1c916:	6018      	str	r0, [r3, #0]
}
   1c918:	4770      	bx	lr
   1c91a:	46c0      	nop			; (mov r8, r8)
   1c91c:	01002c50 	.word	0x01002c50

0001c920 <set_ip_info_callback>:
 * Sets a callback that will be triggered when we receive IP info changed (+NIPINFO)
 * @param callback The function to call with the IP info
 */
NEUL_RET set_ip_info_callback( neul_ip_info_callback callback )
{
    ip_info_callback = callback;
   1c920:	4b01      	ldr	r3, [pc, #4]	; (1c928 <set_ip_info_callback+0x8>)
   1c922:	6018      	str	r0, [r3, #0]

    return NEUL_RET_OK;
}
   1c924:	2000      	movs	r0, #0
   1c926:	4770      	bx	lr
   1c928:	01002c38 	.word	0x01002c38

0001c92c <remote_command_ip_info>:
 * @param current_ip_type:  The current IP type
 * @param requested_ip_type:The requested IP type
 * @param failure_cause:    The failure cause.
 */
void remote_command_ip_info(CORES core, uint8 cid, uint8 current_ip_type, uint8 requested_ip_type, uint8 failure_cause)
{
   1c92c:	b510      	push	{r4, lr}
    UNUSED(core);

    /* safely call callback */
    neul_ip_info_callback  callback = ip_info_callback;
   1c92e:	4c05      	ldr	r4, [pc, #20]	; (1c944 <remote_command_ip_info+0x18>)
{
   1c930:	0008      	movs	r0, r1
    neul_ip_info_callback  callback = ip_info_callback;
   1c932:	6824      	ldr	r4, [r4, #0]
{
   1c934:	0011      	movs	r1, r2
   1c936:	001a      	movs	r2, r3
   1c938:	ab02      	add	r3, sp, #8
   1c93a:	781b      	ldrb	r3, [r3, #0]
    if (callback != NULL)
   1c93c:	2c00      	cmp	r4, #0
   1c93e:	d000      	beq.n	1c942 <remote_command_ip_info+0x16>
    {
        callback(cid, (NEUL_PDN_TYPE)current_ip_type, (NEUL_PDN_TYPE)requested_ip_type, failure_cause);
   1c940:	47a0      	blx	r4
    }
}
   1c942:	bd10      	pop	{r4, pc}
   1c944:	01002c38 	.word	0x01002c38

0001c948 <rai_req>:
/**
 * @brief indicate no more PS data
 * @return success or error
 */
NEUL_RET rai_req(void)
{
   1c948:	b510      	push	{r4, lr}
    if (command_rai_req() != RPC_ERR_OK)
   1c94a:	f7e9 f903 	bl	5b54 <command_rai_req>
    {
        return NEUL_RET_ERROR_RPC;
    }

    return NEUL_RET_OK;
   1c94e:	1e43      	subs	r3, r0, #1
   1c950:	4198      	sbcs	r0, r3
   1c952:	0040      	lsls	r0, r0, #1
}
   1c954:	bd10      	pop	{r4, pc}

0001c956 <set_pdp_context_dynamic_param_request_state>:
 * @param param_item parameter item
 * @param state true or false enable/disable to get the pdp context dynamic parameter
 * @return success or error
 */
NEUL_RET set_pdp_context_dynamic_param_request_state(PDP_CONTEXT_DYNAMIC_PARAM param_item, bool state)
{
   1c956:	b513      	push	{r0, r1, r4, lr}
    NEUL_RET        result;

    if (command_set_pdp_context_dynamic_param_request_state(param_item, state, (uint8*)&result) != RPC_ERR_OK)
   1c958:	466b      	mov	r3, sp
   1c95a:	1ddc      	adds	r4, r3, #7
   1c95c:	0022      	movs	r2, r4
   1c95e:	f7e9 f93f 	bl	5be0 <command_set_pdp_context_dynamic_param_request_state>
    {
        return NEUL_RET_ERROR_RPC;
   1c962:	2302      	movs	r3, #2
    if (command_set_pdp_context_dynamic_param_request_state(param_item, state, (uint8*)&result) != RPC_ERR_OK)
   1c964:	2800      	cmp	r0, #0
   1c966:	d100      	bne.n	1c96a <set_pdp_context_dynamic_param_request_state+0x14>
    }

    return result;
   1c968:	7823      	ldrb	r3, [r4, #0]
}
   1c96a:	0018      	movs	r0, r3
   1c96c:	bd16      	pop	{r1, r2, r4, pc}

0001c96e <get_pdp_context_dynamic_param_request_state>:
 * @param param_item parameter item
 * @param state true or false enable/disable to get the pdp context dynamic parameter
 * @return success or error
 */
NEUL_RET get_pdp_context_dynamic_param_request_state(PDP_CONTEXT_DYNAMIC_PARAM param_item, bool *state)
{
   1c96e:	b510      	push	{r4, lr}
    if (state == NULL)
    {
        return NEUL_RET_ERROR;
   1c970:	2301      	movs	r3, #1
    if (state == NULL)
   1c972:	2900      	cmp	r1, #0
   1c974:	d005      	beq.n	1c982 <get_pdp_context_dynamic_param_request_state+0x14>
    }

    if (command_get_pdp_context_dynamic_param_request_state(param_item, state) != RPC_ERR_OK)
   1c976:	f7e9 f964 	bl	5c42 <command_get_pdp_context_dynamic_param_request_state>
    {
        return NEUL_RET_ERROR_RPC;
    }

    return NEUL_RET_OK;
   1c97a:	0003      	movs	r3, r0
   1c97c:	1e58      	subs	r0, r3, #1
   1c97e:	4183      	sbcs	r3, r0
   1c980:	005b      	lsls	r3, r3, #1
}
   1c982:	0018      	movs	r0, r3
   1c984:	bd10      	pop	{r4, pc}
	...

0001c988 <modify_pdp_req>:
 * @param cid cid to modify
 * @param callback pdp modify callback
 * @return NEUL_RET
 */
NEUL_RET modify_pdp_req(uint16 cid, neul_pdp_modify_callback callback)
{
   1c988:	b537      	push	{r0, r1, r2, r4, r5, lr}
    NEUL_RET ret;

    if(command_pdp_modify_req(cid, (uint8*)&ret) != RPC_ERR_OK)
   1c98a:	466b      	mov	r3, sp
   1c98c:	1ddc      	adds	r4, r3, #7
{
   1c98e:	000d      	movs	r5, r1
    if(command_pdp_modify_req(cid, (uint8*)&ret) != RPC_ERR_OK)
   1c990:	0021      	movs	r1, r4
   1c992:	f7e9 fa46 	bl	5e22 <command_pdp_modify_req>
    {
        return NEUL_RET_ERROR_RPC;
   1c996:	2302      	movs	r3, #2
    if(command_pdp_modify_req(cid, (uint8*)&ret) != RPC_ERR_OK)
   1c998:	2800      	cmp	r0, #0
   1c99a:	d104      	bne.n	1c9a6 <modify_pdp_req+0x1e>
    }

    if (ret == NEUL_RET_IN_PROGRESS_BLOCK)
   1c99c:	7823      	ldrb	r3, [r4, #0]
   1c99e:	2b1b      	cmp	r3, #27
   1c9a0:	d101      	bne.n	1c9a6 <modify_pdp_req+0x1e>
    {
        pdp_modify_callback = callback;
   1c9a2:	4a02      	ldr	r2, [pc, #8]	; (1c9ac <modify_pdp_req+0x24>)
   1c9a4:	6015      	str	r5, [r2, #0]
    }

    return ret;
}
   1c9a6:	0018      	movs	r0, r3
   1c9a8:	bd3e      	pop	{r1, r2, r3, r4, r5, pc}
   1c9aa:	46c0      	nop			; (mov r8, r8)
   1c9ac:	01002c48 	.word	0x01002c48

0001c9b0 <remote_command_pdp_modify_result>:
 * @brief indicate the result of pdp modify
 * @param core The core this is called on
 * @param ret pdp modify result
 */
void remote_command_pdp_modify_result(CORES core, uint8 ret)
{
   1c9b0:	b510      	push	{r4, lr}
    UNUSED(core);

    neul_pdp_modify_callback callback = pdp_modify_callback;
   1c9b2:	4b03      	ldr	r3, [pc, #12]	; (1c9c0 <remote_command_pdp_modify_result+0x10>)
   1c9b4:	681b      	ldr	r3, [r3, #0]

    if (callback)
   1c9b6:	2b00      	cmp	r3, #0
   1c9b8:	d001      	beq.n	1c9be <remote_command_pdp_modify_result+0xe>
    {
        callback((NEUL_RET)ret);
   1c9ba:	0008      	movs	r0, r1
   1c9bc:	4798      	blx	r3
    }
}
   1c9be:	bd10      	pop	{r4, pc}
   1c9c0:	01002c48 	.word	0x01002c48

0001c9c4 <remote_command_ciot_opt_status_ind>:
 * @param cplane_opt_supported ue support opt
 * @param uplane_opt_supported ue preferred opt
 * @return success or error
 */
void remote_command_ciot_opt_status_ind(CORES core, bool cplane_opt_supported, bool uplane_opt_supported)
{
   1c9c4:	b510      	push	{r4, lr}
    UNUSED(core);

    neul_set_ciot_opt_callback opt_callback = ciot_opt_callback;
   1c9c6:	4b08      	ldr	r3, [pc, #32]	; (1c9e8 <remote_command_ciot_opt_status_ind+0x24>)
   1c9c8:	681b      	ldr	r3, [r3, #0]

    if (!opt_callback)
   1c9ca:	2b00      	cmp	r3, #0
   1c9cc:	d006      	beq.n	1c9dc <remote_command_ciot_opt_status_ind+0x18>
    {
        return;
    }

    if (cplane_opt_supported && uplane_opt_supported)
   1c9ce:	2900      	cmp	r1, #0
   1c9d0:	d005      	beq.n	1c9de <remote_command_ciot_opt_status_ind+0x1a>
    {
        opt_callback(CIOT_EPS_OPT_SUPPORT_CP_UP);
   1c9d2:	2003      	movs	r0, #3
    if (cplane_opt_supported && uplane_opt_supported)
   1c9d4:	2a00      	cmp	r2, #0
   1c9d6:	d100      	bne.n	1c9da <remote_command_ciot_opt_status_ind+0x16>
    }
    else if (cplane_opt_supported && !uplane_opt_supported)
    {
        opt_callback(CIOT_EPS_OPT_SUPPORT_CP);
   1c9d8:	2001      	movs	r0, #1
    {
        opt_callback(CIOT_EPS_OPT_SUPPORT_UP);
    }
    else
    {
        opt_callback(CIOT_EPS_OPT_NO_SUPPORT);
   1c9da:	4798      	blx	r3
    }
}
   1c9dc:	bd10      	pop	{r4, pc}
        opt_callback(CIOT_EPS_OPT_SUPPORT_UP);
   1c9de:	2002      	movs	r0, #2
    else if (!cplane_opt_supported && uplane_opt_supported)
   1c9e0:	2a00      	cmp	r2, #0
   1c9e2:	d1fa      	bne.n	1c9da <remote_command_ciot_opt_status_ind+0x16>
        opt_callback(CIOT_EPS_OPT_NO_SUPPORT);
   1c9e4:	0010      	movs	r0, r2
   1c9e6:	e7f8      	b.n	1c9da <remote_command_ciot_opt_status_ind+0x16>
   1c9e8:	01002c28 	.word	0x01002c28

0001c9ec <set_ciot_opt>:
 * @param preferred_ue_opt ue preferred opt
 * @param set_ciot_opt_callback ciot opt callback
 * @return success or error
 */
NEUL_RET set_ciot_opt (uint8 supported_ue_opt, uint8 preferred_ue_opt, neul_set_ciot_opt_callback set_ciot_opt_callback)
{
   1c9ec:	b537      	push	{r0, r1, r2, r4, r5, lr}
    uint8   neul_result          = 0;
   1c9ee:	466b      	mov	r3, sp
   1c9f0:	1ddc      	adds	r4, r3, #7
   1c9f2:	2300      	movs	r3, #0
{
   1c9f4:	0015      	movs	r5, r2

    if (command_set_ciot_opt(supported_ue_opt, preferred_ue_opt, &neul_result) != RPC_ERR_OK)
   1c9f6:	0022      	movs	r2, r4
    uint8   neul_result          = 0;
   1c9f8:	7023      	strb	r3, [r4, #0]
    if (command_set_ciot_opt(supported_ue_opt, preferred_ue_opt, &neul_result) != RPC_ERR_OK)
   1c9fa:	f7e9 fa3c 	bl	5e76 <command_set_ciot_opt>
    {
        return NEUL_RET_ERROR_RPC;
   1c9fe:	2302      	movs	r3, #2
    if (command_set_ciot_opt(supported_ue_opt, preferred_ue_opt, &neul_result) != RPC_ERR_OK)
   1ca00:	2800      	cmp	r0, #0
   1ca02:	d104      	bne.n	1ca0e <set_ciot_opt+0x22>
    }

    if (neul_result == NEUL_RET_OK)
   1ca04:	7823      	ldrb	r3, [r4, #0]
   1ca06:	2b00      	cmp	r3, #0
   1ca08:	d101      	bne.n	1ca0e <set_ciot_opt+0x22>
    {
        ciot_opt_callback = set_ciot_opt_callback;
   1ca0a:	4a02      	ldr	r2, [pc, #8]	; (1ca14 <set_ciot_opt+0x28>)
   1ca0c:	6015      	str	r5, [r2, #0]
    }

    return (NEUL_RET)neul_result;
}
   1ca0e:	0018      	movs	r0, r3
   1ca10:	bd3e      	pop	{r1, r2, r3, r4, r5, pc}
   1ca12:	46c0      	nop			; (mov r8, r8)
   1ca14:	01002c28 	.word	0x01002c28

0001ca18 <get_ciot_opt>:
 * @param upported_ue_opt ue support opt
 * @param preferred_ue_opt ue preferred opt
 * @return success or error
 */
NEUL_RET get_ciot_opt(uint8* supported_ue_opt, uint8* preferred_ue_opt)
{
   1ca18:	b513      	push	{r0, r1, r4, lr}
    uint8       neul_result     = 0;
   1ca1a:	466b      	mov	r3, sp
   1ca1c:	1ddc      	adds	r4, r3, #7
   1ca1e:	2300      	movs	r3, #0
{
   1ca20:	000a      	movs	r2, r1
    uint8       neul_result     = 0;
   1ca22:	7023      	strb	r3, [r4, #0]

    if ((supported_ue_opt == NULL) || (preferred_ue_opt == NULL))
    {
        return NEUL_RET_ERROR;
   1ca24:	3301      	adds	r3, #1
    if ((supported_ue_opt == NULL) || (preferred_ue_opt == NULL))
   1ca26:	2800      	cmp	r0, #0
   1ca28:	d009      	beq.n	1ca3e <get_ciot_opt+0x26>
   1ca2a:	2900      	cmp	r1, #0
   1ca2c:	d007      	beq.n	1ca3e <get_ciot_opt+0x26>
    }

    if (command_get_ciot_opt(&neul_result, supported_ue_opt, preferred_ue_opt) != RPC_ERR_OK)
   1ca2e:	0001      	movs	r1, r0
   1ca30:	0020      	movs	r0, r4
   1ca32:	f7e9 fa51 	bl	5ed8 <command_get_ciot_opt>
    {
        return NEUL_RET_ERROR_RPC;
   1ca36:	2302      	movs	r3, #2
    if (command_get_ciot_opt(&neul_result, supported_ue_opt, preferred_ue_opt) != RPC_ERR_OK)
   1ca38:	2800      	cmp	r0, #0
   1ca3a:	d100      	bne.n	1ca3e <get_ciot_opt+0x26>
    }

    return (NEUL_RET)neul_result;
   1ca3c:	7823      	ldrb	r3, [r4, #0]
}
   1ca3e:	0018      	movs	r0, r3
   1ca40:	bd16      	pop	{r1, r2, r4, pc}

0001ca42 <delete_qos>:
 * @brief delete quality of service (QCI) for pdp context
 * @param cid cid to delete
 * @return success or error
 */
NEUL_RET delete_qos(uint16 cid)
{
   1ca42:	b513      	push	{r0, r1, r4, lr}
    NEUL_RET ret;

    if(command_delete_qos(cid, (uint8*)&ret) != RPC_ERR_OK)
   1ca44:	466b      	mov	r3, sp
   1ca46:	1ddc      	adds	r4, r3, #7
   1ca48:	0021      	movs	r1, r4
   1ca4a:	f7e9 fadc 	bl	6006 <command_delete_qos>
    {
        return NEUL_RET_ERROR_RPC;
   1ca4e:	2302      	movs	r3, #2
    if(command_delete_qos(cid, (uint8*)&ret) != RPC_ERR_OK)
   1ca50:	2800      	cmp	r0, #0
   1ca52:	d100      	bne.n	1ca56 <delete_qos+0x14>
    }

    return ret;
   1ca54:	7823      	ldrb	r3, [r4, #0]
}
   1ca56:	0018      	movs	r0, r3
   1ca58:	bd16      	pop	{r1, r2, r4, pc}

0001ca5a <set_qos_req>:
 * @param cid cid to modify
 * @param qci requested QCI value
 * @return success or error
 */
NEUL_RET set_qos_req(uint16 cid, uint8 qci)
{
   1ca5a:	b513      	push	{r0, r1, r4, lr}
    NEUL_RET ret;

    if(command_set_qos_req(cid, qci, (uint8*)&ret) != RPC_ERR_OK)
   1ca5c:	466b      	mov	r3, sp
   1ca5e:	1ddc      	adds	r4, r3, #7
   1ca60:	0022      	movs	r2, r4
   1ca62:	f7e9 fa6e 	bl	5f42 <command_set_qos_req>
    {
        return NEUL_RET_ERROR_RPC;
   1ca66:	2302      	movs	r3, #2
    if(command_set_qos_req(cid, qci, (uint8*)&ret) != RPC_ERR_OK)
   1ca68:	2800      	cmp	r0, #0
   1ca6a:	d100      	bne.n	1ca6e <set_qos_req+0x14>
    }

    return ret;
   1ca6c:	7823      	ldrb	r3, [r4, #0]
}
   1ca6e:	0018      	movs	r0, r3
   1ca70:	bd16      	pop	{r1, r2, r4, pc}

0001ca72 <get_qos>:
 * @param cid cid to modify
 * @param qci requested QCI value
 * @return success or error
 */
NEUL_RET get_qos(uint16 cid, uint8 *qci)
{
   1ca72:	b513      	push	{r0, r1, r4, lr}
    NEUL_RET ret;

    if(command_get_qos(cid, (uint8*)&ret, qci) != RPC_ERR_OK)
   1ca74:	466b      	mov	r3, sp
   1ca76:	1ddc      	adds	r4, r3, #7
{
   1ca78:	000a      	movs	r2, r1
    if(command_get_qos(cid, (uint8*)&ret, qci) != RPC_ERR_OK)
   1ca7a:	0021      	movs	r1, r4
   1ca7c:	f7e9 fa93 	bl	5fa6 <command_get_qos>
    {
        return NEUL_RET_ERROR_RPC;
   1ca80:	2302      	movs	r3, #2
    if(command_get_qos(cid, (uint8*)&ret, qci) != RPC_ERR_OK)
   1ca82:	2800      	cmp	r0, #0
   1ca84:	d100      	bne.n	1ca88 <get_qos+0x16>
    }

    return ret;
   1ca86:	7823      	ldrb	r3, [r4, #0]
}
   1ca88:	0018      	movs	r0, r3
   1ca8a:	bd16      	pop	{r1, r2, r4, pc}

0001ca8c <delete_tft_req>:
 * @brief delete modified TFT packet filters for cid
 * @param cid cid
 * @return success or error
 */
NEUL_RET delete_tft_req(uint16 cid)
{
   1ca8c:	b513      	push	{r0, r1, r4, lr}
    NEUL_RET ret;

    if(command_delete_tft_req(cid, (uint8*)&ret) != RPC_ERR_OK)
   1ca8e:	466b      	mov	r3, sp
   1ca90:	1ddc      	adds	r4, r3, #7
   1ca92:	0021      	movs	r1, r4
   1ca94:	f7e9 fae1 	bl	605a <command_delete_tft_req>
    {
        return NEUL_RET_ERROR_RPC;
   1ca98:	2302      	movs	r3, #2
    if(command_delete_tft_req(cid, (uint8*)&ret) != RPC_ERR_OK)
   1ca9a:	2800      	cmp	r0, #0
   1ca9c:	d100      	bne.n	1caa0 <delete_tft_req+0x14>
    }

    return ret;
   1ca9e:	7823      	ldrb	r3, [r4, #0]
}
   1caa0:	0018      	movs	r0, r3
   1caa2:	bd16      	pop	{r1, r2, r4, pc}

0001caa4 <set_tft_req>:
 * @brief sets packet filter for TFT
 * @param tft The params of TFT
 * @return success or error
 */
NEUL_RET set_tft_req(tft_context *tft)
{
   1caa4:	b513      	push	{r0, r1, r4, lr}
    NEUL_RET ret;

    if (tft == NULL)
    {
        return NEUL_RET_ERROR;
   1caa6:	2301      	movs	r3, #1
{
   1caa8:	1e01      	subs	r1, r0, #0
    if (tft == NULL)
   1caaa:	d009      	beq.n	1cac0 <set_tft_req+0x1c>
    }

    if(command_set_tft_req(sizeof(tft_context),(uint8 *)tft,
   1caac:	466b      	mov	r3, sp
   1caae:	1ddc      	adds	r4, r3, #7
   1cab0:	0022      	movs	r2, r4
   1cab2:	2048      	movs	r0, #72	; 0x48
   1cab4:	f7e9 fafb 	bl	60ae <command_set_tft_req>
                           (uint8*)&ret) != RPC_ERR_OK)
    {
        return NEUL_RET_ERROR_RPC;
   1cab8:	2302      	movs	r3, #2
    if(command_set_tft_req(sizeof(tft_context),(uint8 *)tft,
   1caba:	2800      	cmp	r0, #0
   1cabc:	d100      	bne.n	1cac0 <set_tft_req+0x1c>
    }

    return ret;
   1cabe:	7823      	ldrb	r3, [r4, #0]
}
   1cac0:	0018      	movs	r0, r3
   1cac2:	bd16      	pop	{r1, r2, r4, pc}

0001cac4 <get_tft_context>:
 * @param tft The tft params for designated packet filters
 * @param num_of_packet_filters The number of packet filters for cid
 * @return success or error
 */
NEUL_RET get_tft_context(uint8 cid,uint8 packet_filter, tft_context *tft, uint8 *num_of_packet_filters)
{
   1cac4:	b530      	push	{r4, r5, lr}
    uint16 tft_context_length = 0;
   1cac6:	250e      	movs	r5, #14
   1cac8:	2400      	movs	r4, #0
{
   1caca:	b085      	sub	sp, #20
    uint16 tft_context_length = 0;
   1cacc:	446d      	add	r5, sp
   1cace:	802c      	strh	r4, [r5, #0]
    if (tft == NULL || num_of_packet_filters == NULL)
    {
        return NEUL_RET_ERROR;
   1cad0:	3401      	adds	r4, #1
    if (tft == NULL || num_of_packet_filters == NULL)
   1cad2:	2a00      	cmp	r2, #0
   1cad4:	d00f      	beq.n	1caf6 <get_tft_context+0x32>
   1cad6:	2b00      	cmp	r3, #0
   1cad8:	d00d      	beq.n	1caf6 <get_tft_context+0x32>
    }

    if (command_get_tft_context(cid, packet_filter, sizeof(tft_context), &tft_context_length, (uint8 *)tft, num_of_packet_filters) != RPC_ERR_OK)
   1cada:	9301      	str	r3, [sp, #4]
   1cadc:	9200      	str	r2, [sp, #0]
   1cade:	002b      	movs	r3, r5
   1cae0:	2248      	movs	r2, #72	; 0x48
   1cae2:	f7e9 fb14 	bl	610e <command_get_tft_context>
    {
        return NEUL_RET_ERROR_RPC;
   1cae6:	3401      	adds	r4, #1
    if (command_get_tft_context(cid, packet_filter, sizeof(tft_context), &tft_context_length, (uint8 *)tft, num_of_packet_filters) != RPC_ERR_OK)
   1cae8:	2800      	cmp	r0, #0
   1caea:	d104      	bne.n	1caf6 <get_tft_context+0x32>
    }

    if (tft_context_length != sizeof(tft_context))
   1caec:	882c      	ldrh	r4, [r5, #0]
   1caee:	3c48      	subs	r4, #72	; 0x48
   1caf0:	1e60      	subs	r0, r4, #1
   1caf2:	4184      	sbcs	r4, r0
        return NEUL_RET_ERROR;
   1caf4:	b2e4      	uxtb	r4, r4
    {
        return NEUL_RET_ERROR;
    }

    return NEUL_RET_OK;
}
   1caf6:	0020      	movs	r0, r4
   1caf8:	b005      	add	sp, #20
   1cafa:	bd30      	pop	{r4, r5, pc}

0001cafc <get_cid_status>:
 * @param status socket status
 * @param backoff remaining backoff time value, uint : s, valid only when status is SOCKET_OR_CID_STATUS_BACK_OFF
 * @return NUEL_RET
**/
NEUL_RET get_cid_status(uint8 cid, SOCKET_OR_CID_STATUS *status,uint16 *backoff)
{
   1cafc:	b513      	push	{r0, r1, r4, lr}
   1cafe:	0013      	movs	r3, r2
    NEUL_RET ret;

    if(command_get_cid_status(cid, (uint8 *)&ret, (uint8*)status, backoff) != RPC_ERR_OK)
   1cb00:	466a      	mov	r2, sp
   1cb02:	1dd4      	adds	r4, r2, #7
   1cb04:	000a      	movs	r2, r1
   1cb06:	0021      	movs	r1, r4
   1cb08:	f7e9 fbfb 	bl	6302 <command_get_cid_status>
    {
        return NEUL_RET_ERROR;
   1cb0c:	2301      	movs	r3, #1
    if(command_get_cid_status(cid, (uint8 *)&ret, (uint8*)status, backoff) != RPC_ERR_OK)
   1cb0e:	2800      	cmp	r0, #0
   1cb10:	d100      	bne.n	1cb14 <get_cid_status+0x18>
    }

    return ret;
   1cb12:	7823      	ldrb	r3, [r4, #0]
}
   1cb14:	0018      	movs	r0, r3
   1cb16:	bd16      	pop	{r1, r2, r4, pc}

0001cb18 <request_reboot>:
#include "rtc.h"

#define HALF_SECOND_RTC_DELAY (0xffff >> 2)

void request_reboot(REBOOT_CAUSE reason)
{
   1cb18:	b570      	push	{r4, r5, r6, lr}
   1cb1a:	0005      	movs	r5, r0
    /* 
     * This is added to allow an external application to reboot UE
     * disconnect and then launch codeloader
     */

    rtc_reboot_time = (uint32) (rtc_get_time() + HALF_SECOND_RTC_DELAY);
   1cb1c:	f7fb fd68 	bl	185f0 <rtc_get_time>
   1cb20:	4b05      	ldr	r3, [pc, #20]	; (1cb38 <request_reboot+0x20>)
   1cb22:	18c4      	adds	r4, r0, r3

    while (rtc_get_time() < rtc_reboot_time)    //Wait half a second for peripherals to finish
   1cb24:	f7fb fd64 	bl	185f0 <rtc_get_time>
   1cb28:	2900      	cmp	r1, #0
   1cb2a:	d101      	bne.n	1cb30 <request_reboot+0x18>
   1cb2c:	4284      	cmp	r4, r0
   1cb2e:	d8f9      	bhi.n	1cb24 <request_reboot+0xc>
    {
    }
    reboot_system(reason);
   1cb30:	0028      	movs	r0, r5
   1cb32:	f7fb fbbb 	bl	182ac <reboot_system>
}
   1cb36:	bd70      	pop	{r4, r5, r6, pc}
   1cb38:	00003fff 	.word	0x00003fff

0001cb3c <set_short_message_service_type>:
static neul_receive_short_message           sms_cmt_pdu_callback;
static neul_send_msg_reuslt_callback        sms_send_msg_result_callback;
static neul_send_cmd_result_callback        sms_send_cmd_result_callback;

NEUL_RET set_short_message_service_type(uint16 service , uint8 * mt, uint8 * mo, uint8 * bm)
{
   1cb3c:	b51f      	push	{r0, r1, r2, r3, r4, lr}
    NEUL_RET result;
    if(command_sms_set_short_message_service(service ,(uint8 *)&result, mt, mo, bm) == RPC_ERR_OK)
   1cb3e:	240f      	movs	r4, #15
   1cb40:	446c      	add	r4, sp
   1cb42:	9300      	str	r3, [sp, #0]
   1cb44:	0013      	movs	r3, r2
   1cb46:	000a      	movs	r2, r1
   1cb48:	0021      	movs	r1, r4
   1cb4a:	f7e7 ff40 	bl	49ce <command_sms_set_short_message_service>
    {
        return result;
    }
    return NEUL_RET_ERROR;
   1cb4e:	2301      	movs	r3, #1
    if(command_sms_set_short_message_service(service ,(uint8 *)&result, mt, mo, bm) == RPC_ERR_OK)
   1cb50:	2800      	cmp	r0, #0
   1cb52:	d100      	bne.n	1cb56 <set_short_message_service_type+0x1a>
        return result;
   1cb54:	7823      	ldrb	r3, [r4, #0]
}
   1cb56:	0018      	movs	r0, r3
   1cb58:	b004      	add	sp, #16
   1cb5a:	bd10      	pop	{r4, pc}

0001cb5c <read_short_message_service_type>:

NEUL_RET read_short_message_service_type(uint8 * service , uint8 * mt, uint8 * mo, uint8 * bm)
{
   1cb5c:	b51f      	push	{r0, r1, r2, r3, r4, lr}
    NEUL_RET result;
    if(command_sms_read_short_message_service((uint8 *)&result, service ,mt, mo, bm) == RPC_ERR_OK)
   1cb5e:	240f      	movs	r4, #15
   1cb60:	446c      	add	r4, sp
   1cb62:	9300      	str	r3, [sp, #0]
   1cb64:	0013      	movs	r3, r2
   1cb66:	000a      	movs	r2, r1
   1cb68:	0001      	movs	r1, r0
   1cb6a:	0020      	movs	r0, r4
   1cb6c:	f7e7 ff6d 	bl	4a4a <command_sms_read_short_message_service>
    {
        return result;
    }
    return NEUL_RET_ERROR;
   1cb70:	2301      	movs	r3, #1
    if(command_sms_read_short_message_service((uint8 *)&result, service ,mt, mo, bm) == RPC_ERR_OK)
   1cb72:	2800      	cmp	r0, #0
   1cb74:	d100      	bne.n	1cb78 <read_short_message_service_type+0x1c>
        return result;
   1cb76:	7823      	ldrb	r3, [r4, #0]
}
   1cb78:	0018      	movs	r0, r3
   1cb7a:	b004      	add	sp, #16
   1cb7c:	bd10      	pop	{r4, pc}

0001cb7e <set_more_message_to_send>:

NEUL_RET set_more_message_to_send(uint8 mode)
{
   1cb7e:	b513      	push	{r0, r1, r4, lr}
    NEUL_RET result;
    if(command_sms_set_more_message_to_send(mode ,(uint8 *)&result) == RPC_ERR_OK)
   1cb80:	466b      	mov	r3, sp
   1cb82:	1ddc      	adds	r4, r3, #7
   1cb84:	0021      	movs	r1, r4
   1cb86:	f7e7 ffa2 	bl	4ace <command_sms_set_more_message_to_send>
    {
        return result;
    }
    return NEUL_RET_ERROR;
   1cb8a:	2301      	movs	r3, #1
    if(command_sms_set_more_message_to_send(mode ,(uint8 *)&result) == RPC_ERR_OK)
   1cb8c:	2800      	cmp	r0, #0
   1cb8e:	d100      	bne.n	1cb92 <set_more_message_to_send+0x14>
        return result;
   1cb90:	7823      	ldrb	r3, [r4, #0]
}
   1cb92:	0018      	movs	r0, r3
   1cb94:	bd16      	pop	{r1, r2, r4, pc}

0001cb96 <read_more_message_to_send>:

NEUL_RET read_more_message_to_send(uint8 * mode)
{
   1cb96:	b513      	push	{r0, r1, r4, lr}
    NEUL_RET result;
    if(command_sms_read_more_message_to_send((uint8 *)&result, mode) == RPC_ERR_OK)
   1cb98:	466b      	mov	r3, sp
   1cb9a:	1ddc      	adds	r4, r3, #7
{
   1cb9c:	0001      	movs	r1, r0
    if(command_sms_read_more_message_to_send((uint8 *)&result, mode) == RPC_ERR_OK)
   1cb9e:	0020      	movs	r0, r4
   1cba0:	f7e7 ffbe 	bl	4b20 <command_sms_read_more_message_to_send>
    {
        return result;
    }
    return NEUL_RET_ERROR;
   1cba4:	2301      	movs	r3, #1
    if(command_sms_read_more_message_to_send((uint8 *)&result, mode) == RPC_ERR_OK)
   1cba6:	2800      	cmp	r0, #0
   1cba8:	d100      	bne.n	1cbac <read_more_message_to_send+0x16>
        return result;
   1cbaa:	7823      	ldrb	r3, [r4, #0]
}
   1cbac:	0018      	movs	r0, r3
   1cbae:	bd16      	pop	{r1, r2, r4, pc}

0001cbb0 <set_short_message_service_address>:

NEUL_RET set_short_message_service_address(uint8 type, uint8 len,uint8 * ser_addr)
{
   1cbb0:	b513      	push	{r0, r1, r4, lr}
    NEUL_RET result;
    if(ser_addr == NULL)
   1cbb2:	2a00      	cmp	r2, #0
   1cbb4:	d101      	bne.n	1cbba <set_short_message_service_address+0xa>
    {
       return NEUL_RET_ERROR;
   1cbb6:	2001      	movs	r0, #1
        {
            return result;
        }
        return NEUL_RET_ERROR;
    }
}
   1cbb8:	bd16      	pop	{r1, r2, r4, pc}
        if(command_sms_set_short_message_service_address(type, (uint16)len, ser_addr, (uint8 *)&result) == RPC_ERR_OK)
   1cbba:	466b      	mov	r3, sp
   1cbbc:	1ddc      	adds	r4, r3, #7
   1cbbe:	b289      	uxth	r1, r1
   1cbc0:	0023      	movs	r3, r4
   1cbc2:	f7e7 ffdb 	bl	4b7c <command_sms_set_short_message_service_address>
   1cbc6:	2800      	cmp	r0, #0
   1cbc8:	d1f5      	bne.n	1cbb6 <set_short_message_service_address+0x6>
            return result;
   1cbca:	7820      	ldrb	r0, [r4, #0]
   1cbcc:	e7f4      	b.n	1cbb8 <set_short_message_service_address+0x8>
	...

0001cbd0 <send_short_message>:

NEUL_RET send_short_message(uint8 sms_len, uint16 pdu_length, uint8 *pdu, neul_send_msg_reuslt_callback callback)
{
   1cbd0:	b537      	push	{r0, r1, r2, r4, r5, lr}
   1cbd2:	001d      	movs	r5, r3
    NEUL_RET result;
    if(pdu == NULL)
   1cbd4:	2a00      	cmp	r2, #0
   1cbd6:	d101      	bne.n	1cbdc <send_short_message+0xc>
    {
        return NEUL_RET_ERROR;
   1cbd8:	2001      	movs	r0, #1
            }
            return result;
        }
        return NEUL_RET_ERROR;
    }
}
   1cbda:	bd3e      	pop	{r1, r2, r3, r4, r5, pc}
        if(command_sms_send_short_message(sms_len, pdu_length, pdu, (uint8 *)&result) == RPC_ERR_OK)
   1cbdc:	466b      	mov	r3, sp
   1cbde:	1ddc      	adds	r4, r3, #7
   1cbe0:	0023      	movs	r3, r4
   1cbe2:	f7e8 f837 	bl	4c54 <command_sms_send_short_message>
   1cbe6:	2800      	cmp	r0, #0
   1cbe8:	d1f6      	bne.n	1cbd8 <send_short_message+0x8>
            if(result == NEUL_RET_IN_PROGRESS_BLOCK)
   1cbea:	7820      	ldrb	r0, [r4, #0]
   1cbec:	281b      	cmp	r0, #27
   1cbee:	d1f4      	bne.n	1cbda <send_short_message+0xa>
                sms_send_msg_result_callback = callback;
   1cbf0:	4b01      	ldr	r3, [pc, #4]	; (1cbf8 <send_short_message+0x28>)
   1cbf2:	601d      	str	r5, [r3, #0]
   1cbf4:	e7f1      	b.n	1cbda <send_short_message+0xa>
   1cbf6:	46c0      	nop			; (mov r8, r8)
   1cbf8:	01002c78 	.word	0x01002c78

0001cbfc <send_command>:

NEUL_RET send_command(uint8 sms_len, uint16 pdu_length, uint8 *pdu, neul_send_cmd_result_callback callback)
{
   1cbfc:	b537      	push	{r0, r1, r2, r4, r5, lr}
   1cbfe:	001d      	movs	r5, r3
    NEUL_RET result;
    if(pdu == NULL)
   1cc00:	2a00      	cmp	r2, #0
   1cc02:	d101      	bne.n	1cc08 <send_command+0xc>
    {
        return NEUL_RET_ERROR;
   1cc04:	2001      	movs	r0, #1
            }
            return result;
        }
        return NEUL_RET_ERROR;
    }
}
   1cc06:	bd3e      	pop	{r1, r2, r3, r4, r5, pc}
        if(command_sms_send_command(sms_len, pdu_length, pdu, (uint8 *)&result) == RPC_ERR_OK)
   1cc08:	466b      	mov	r3, sp
   1cc0a:	1ddc      	adds	r4, r3, #7
   1cc0c:	0023      	movs	r3, r4
   1cc0e:	f7e8 f857 	bl	4cc0 <command_sms_send_command>
   1cc12:	2800      	cmp	r0, #0
   1cc14:	d1f6      	bne.n	1cc04 <send_command+0x8>
            if(result == NEUL_RET_IN_PROGRESS_BLOCK)
   1cc16:	7820      	ldrb	r0, [r4, #0]
   1cc18:	281b      	cmp	r0, #27
   1cc1a:	d1f4      	bne.n	1cc06 <send_command+0xa>
                sms_send_cmd_result_callback = callback;
   1cc1c:	4b01      	ldr	r3, [pc, #4]	; (1cc24 <send_command+0x28>)
   1cc1e:	601d      	str	r5, [r3, #0]
   1cc20:	e7f1      	b.n	1cc06 <send_command+0xa>
   1cc22:	46c0      	nop			; (mov r8, r8)
   1cc24:	01002c74 	.word	0x01002c74

0001cc28 <set_new_msg_ack>:

NEUL_RET set_new_msg_ack(NEUL_SMS_RECEIVE_PDU_RES_TYPE report_type, uint8 sms_len,uint8 *pdu)
{
   1cc28:	b513      	push	{r0, r1, r4, lr}
    NEUL_RET result;
    if(pdu == NULL && sms_len != 0)
   1cc2a:	2a00      	cmp	r2, #0
   1cc2c:	d103      	bne.n	1cc36 <set_new_msg_ack+0xe>
   1cc2e:	2900      	cmp	r1, #0
   1cc30:	d001      	beq.n	1cc36 <set_new_msg_ack+0xe>
    {
        return NEUL_RET_ERROR;
   1cc32:	2001      	movs	r0, #1
        {
            return result;
        }
        return NEUL_RET_ERROR;
    }
}
   1cc34:	bd16      	pop	{r1, r2, r4, pc}
        if(command_sms_set_new_msg_ack((uint8)report_type, (uint16)sms_len, pdu, (uint8 *)&result) == RPC_ERR_OK)
   1cc36:	466b      	mov	r3, sp
   1cc38:	1ddc      	adds	r4, r3, #7
   1cc3a:	b289      	uxth	r1, r1
   1cc3c:	0023      	movs	r3, r4
   1cc3e:	f7e8 f875 	bl	4d2c <command_sms_set_new_msg_ack>
   1cc42:	2800      	cmp	r0, #0
   1cc44:	d1f5      	bne.n	1cc32 <set_new_msg_ack+0xa>
            return result;
   1cc46:	7820      	ldrb	r0, [r4, #0]
   1cc48:	e7f4      	b.n	1cc34 <set_new_msg_ack+0xc>

0001cc4a <get_cnma_acknowledgement_expected>:

NEUL_RET get_cnma_acknowledgement_expected()
{
   1cc4a:	b513      	push	{r0, r1, r4, lr}
    NEUL_RET result;

    if(command_get_cnma_acknowledgement_expected((uint8 *)&result) == RPC_ERR_OK)
   1cc4c:	466b      	mov	r3, sp
   1cc4e:	1ddc      	adds	r4, r3, #7
   1cc50:	0020      	movs	r0, r4
   1cc52:	f7e8 f8a1 	bl	4d98 <command_get_cnma_acknowledgement_expected>
    {
        return result;
    }

    return NEUL_RET_ERROR;
   1cc56:	2301      	movs	r3, #1
    if(command_get_cnma_acknowledgement_expected((uint8 *)&result) == RPC_ERR_OK)
   1cc58:	2800      	cmp	r0, #0
   1cc5a:	d100      	bne.n	1cc5e <get_cnma_acknowledgement_expected+0x14>
        return result;
   1cc5c:	7823      	ldrb	r3, [r4, #0]
}
   1cc5e:	0018      	movs	r0, r3
   1cc60:	bd16      	pop	{r1, r2, r4, pc}

0001cc62 <read_short_message_service_address>:

NEUL_RET read_short_message_service_address(uint8 *type, uint16 max_length, uint16 *length,uint8 * ser_addr)
{
   1cc62:	b51f      	push	{r0, r1, r2, r3, r4, lr}
    NEUL_RET result;
    if(ser_addr == NULL)
   1cc64:	2b00      	cmp	r3, #0
   1cc66:	d104      	bne.n	1cc72 <read_short_message_service_address+0x10>
    {
        *type=0;
   1cc68:	7003      	strb	r3, [r0, #0]
        return NEUL_RET_ERROR;
   1cc6a:	3301      	adds	r3, #1
        {
            return result;
        }
        return NEUL_RET_ERROR;
    }
}
   1cc6c:	0018      	movs	r0, r3
   1cc6e:	b004      	add	sp, #16
   1cc70:	bd10      	pop	{r4, pc}
        if(command_sms_read_short_message_service_address((uint8 *)&result, type, max_length, length, ser_addr) == RPC_ERR_OK)
   1cc72:	240f      	movs	r4, #15
   1cc74:	446c      	add	r4, sp
   1cc76:	9300      	str	r3, [sp, #0]
   1cc78:	0013      	movs	r3, r2
   1cc7a:	000a      	movs	r2, r1
   1cc7c:	0001      	movs	r1, r0
   1cc7e:	0020      	movs	r0, r4
   1cc80:	f7e7 ffb2 	bl	4be8 <command_sms_read_short_message_service_address>
        return NEUL_RET_ERROR;
   1cc84:	2301      	movs	r3, #1
        if(command_sms_read_short_message_service_address((uint8 *)&result, type, max_length, length, ser_addr) == RPC_ERR_OK)
   1cc86:	2800      	cmp	r0, #0
   1cc88:	d1f0      	bne.n	1cc6c <read_short_message_service_address+0xa>
            return result;
   1cc8a:	7823      	ldrb	r3, [r4, #0]
   1cc8c:	e7ee      	b.n	1cc6c <read_short_message_service_address+0xa>
	...

0001cc90 <set_sms_pdu_callback>:
 * @brief Set the callback when receive MT short message
 * @param callback
 */
NEUL_RET set_sms_pdu_callback(neul_receive_short_message callback)
{
    sms_cmt_pdu_callback = callback;
   1cc90:	4b01      	ldr	r3, [pc, #4]	; (1cc98 <set_sms_pdu_callback+0x8>)
   1cc92:	6018      	str	r0, [r3, #0]
    return NEUL_RET_OK;
}
   1cc94:	2000      	movs	r0, #0
   1cc96:	4770      	bx	lr
   1cc98:	01002c70 	.word	0x01002c70

0001cc9c <remote_command_sms_cmt_pdu_ind>:
 * @param core:       the core this is called on
 * @param pdu_length: the pdu length
 * @param pdu:        the received message pdu
 */
void remote_command_sms_cmt_pdu_ind(CORES core, uint8 alpha, uint16 pdu_length, uint8 *pdu)
{
   1cc9c:	b510      	push	{r4, lr}
   1cc9e:	0008      	movs	r0, r1
   1cca0:	0011      	movs	r1, r2
    UNUSED(core);

    /* safely call callback */
    neul_receive_short_message   callback = sms_cmt_pdu_callback;
   1cca2:	4a03      	ldr	r2, [pc, #12]	; (1ccb0 <remote_command_sms_cmt_pdu_ind+0x14>)
   1cca4:	6814      	ldr	r4, [r2, #0]
    if (callback != NULL)
   1cca6:	2c00      	cmp	r4, #0
   1cca8:	d001      	beq.n	1ccae <remote_command_sms_cmt_pdu_ind+0x12>
    {
        callback(alpha,pdu_length,pdu);
   1ccaa:	001a      	movs	r2, r3
   1ccac:	47a0      	blx	r4
    }

}//lint !e818
   1ccae:	bd10      	pop	{r4, pc}
   1ccb0:	01002c70 	.word	0x01002c70

0001ccb4 <remote_command_sms_mgs_result_ind>:

void remote_command_sms_mgs_result_ind(CORES core, uint8 sms_mgs_result, uint8 mr, uint16 ackpdu_length, uint8 *ackpdu)
{
   1ccb4:	b510      	push	{r4, lr}
   1ccb6:	0008      	movs	r0, r1
   1ccb8:	0011      	movs	r1, r2
   1ccba:	001a      	movs	r2, r3
    UNUSED(core);

    neul_send_msg_reuslt_callback callback = sms_send_msg_result_callback;
   1ccbc:	4b03      	ldr	r3, [pc, #12]	; (1cccc <remote_command_sms_mgs_result_ind+0x18>)
   1ccbe:	681c      	ldr	r4, [r3, #0]
    if(callback != NULL)
   1ccc0:	2c00      	cmp	r4, #0
   1ccc2:	d001      	beq.n	1ccc8 <remote_command_sms_mgs_result_ind+0x14>
    {
        callback(sms_mgs_result, mr, ackpdu_length, ackpdu);
   1ccc4:	9b02      	ldr	r3, [sp, #8]
   1ccc6:	47a0      	blx	r4
    }
}
   1ccc8:	bd10      	pop	{r4, pc}
   1ccca:	46c0      	nop			; (mov r8, r8)
   1cccc:	01002c78 	.word	0x01002c78

0001ccd0 <remote_command_sms_cmd_result_ind>:

void remote_command_sms_cmd_result_ind(CORES core, uint8 sms_cmd_result, uint8 mr, uint16 ackpdu_length, uint8 *ackpdu)
{
   1ccd0:	b510      	push	{r4, lr}
   1ccd2:	0008      	movs	r0, r1
   1ccd4:	0011      	movs	r1, r2
   1ccd6:	001a      	movs	r2, r3
    UNUSED(core);

    neul_send_msg_reuslt_callback callback = sms_send_cmd_result_callback;
   1ccd8:	4b03      	ldr	r3, [pc, #12]	; (1cce8 <remote_command_sms_cmd_result_ind+0x18>)
   1ccda:	681c      	ldr	r4, [r3, #0]
    if(callback != NULL)
   1ccdc:	2c00      	cmp	r4, #0
   1ccde:	d001      	beq.n	1cce4 <remote_command_sms_cmd_result_ind+0x14>
    {
        callback(sms_cmd_result, mr, ackpdu_length, ackpdu);
   1cce0:	9b02      	ldr	r3, [sp, #8]
   1cce2:	47a0      	blx	r4
    }
}
   1cce4:	bd10      	pop	{r4, pc}
   1cce6:	46c0      	nop			; (mov r8, r8)
   1cce8:	01002c74 	.word	0x01002c74

0001ccec <get_chipinfo>:
 * @brief read chip information
 * @param pointer to chipinfo structure
 * @return success or failure
 */
NEUL_RET get_chipinfo(ue_chipinfo_t *chipinfo)
{
   1ccec:	b573      	push	{r0, r1, r4, r5, r6, lr}
    NEUL_RET result = NEUL_RET_OK;
   1ccee:	466b      	mov	r3, sp
    uint16 chipinfo_length = 0;
   1ccf0:	466a      	mov	r2, sp
    NEUL_RET result = NEUL_RET_OK;
   1ccf2:	1d5c      	adds	r4, r3, #5
   1ccf4:	2300      	movs	r3, #0
    uint16 chipinfo_length = 0;
   1ccf6:	1d96      	adds	r6, r2, #6
{
   1ccf8:	0005      	movs	r5, r0
    NEUL_RET result = NEUL_RET_OK;
   1ccfa:	7023      	strb	r3, [r4, #0]
    uint16 chipinfo_length = 0;
   1ccfc:	8033      	strh	r3, [r6, #0]
    if (chipinfo == NULL)
   1ccfe:	4298      	cmp	r0, r3
   1cd00:	d103      	bne.n	1cd0a <get_chipinfo+0x1e>
    {
        result = NEUL_RET_ERROR;
   1cd02:	2301      	movs	r3, #1
   1cd04:	7023      	strb	r3, [r4, #0]
        {
            result =  NEUL_RET_ERROR;
        }
    }

    return result;
   1cd06:	7820      	ldrb	r0, [r4, #0]
}
   1cd08:	bd76      	pop	{r1, r2, r4, r5, r6, pc}
        if ((command_get_chipinfo((uint8 *) &result, sizeof(ue_chipinfo_t), &chipinfo_length, (uint8 *) chipinfo ) != RPC_ERR_OK) ||
   1cd0a:	0003      	movs	r3, r0
   1cd0c:	0032      	movs	r2, r6
   1cd0e:	2106      	movs	r1, #6
   1cd10:	0020      	movs	r0, r4
   1cd12:	f7e8 faee 	bl	52f2 <command_get_chipinfo>
   1cd16:	2800      	cmp	r0, #0
   1cd18:	d1f3      	bne.n	1cd02 <get_chipinfo+0x16>
   1cd1a:	8833      	ldrh	r3, [r6, #0]
   1cd1c:	2b06      	cmp	r3, #6
   1cd1e:	d1f0      	bne.n	1cd02 <get_chipinfo+0x16>
            (chipinfo_length != sizeof(ue_chipinfo_t)) || (chipinfo->version != NEUL_CHIPINFO_VERSION))
   1cd20:	882b      	ldrh	r3, [r5, #0]
   1cd22:	2b01      	cmp	r3, #1
   1cd24:	d1ed      	bne.n	1cd02 <get_chipinfo+0x16>
   1cd26:	e7ee      	b.n	1cd06 <get_chipinfo+0x1a>

0001cd28 <get_chip_temp_coefficient>:
 * @brief read chip information
 * @param pointer to uint16 for temperature_coefficient
 * @return success or failure
 */
NEUL_RET get_chip_temp_coefficient(uint16 *temp_coeff)
{
   1cd28:	b510      	push	{r4, lr}
    NEUL_RET result = NEUL_RET_OK;

    if (temp_coeff == NULL)
    {
        result = NEUL_RET_ERROR;
   1cd2a:	2301      	movs	r3, #1
    if (temp_coeff == NULL)
   1cd2c:	2800      	cmp	r0, #0
   1cd2e:	d004      	beq.n	1cd3a <get_chip_temp_coefficient+0x12>
    }
    else
    {
        if (command_get_temp_coefficient(temp_coeff) != RPC_ERR_OK)
   1cd30:	f7e8 faba 	bl	52a8 <command_get_temp_coefficient>
   1cd34:	1e43      	subs	r3, r0, #1
   1cd36:	4198      	sbcs	r0, r3
        result = NEUL_RET_ERROR;
   1cd38:	b2c3      	uxtb	r3, r0
            result =  NEUL_RET_ERROR;
        }
    }

    return result;
}
   1cd3a:	0018      	movs	r0, r3
   1cd3c:	bd10      	pop	{r4, pc}

0001cd3e <prepare_for_powerdown>:

    return result;
}

void prepare_for_powerdown(void)
{
   1cd3e:	b510      	push	{r4, lr}
    (void)command_prepare_for_powerdown();
   1cd40:	f7e7 fddd 	bl	48fe <command_prepare_for_powerdown>
}
   1cd44:	bd10      	pop	{r4, pc}

0001cd46 <get_ue_stats>:
 /*
 * api function for ue_stats
 */
 
NEUL_RET get_ue_stats(ue_stats *ue_stats_bin)
{
   1cd46:	b537      	push	{r0, r1, r2, r4, r5, lr}
    uint16 ue_stats_len = 0;
   1cd48:	466b      	mov	r3, sp
   1cd4a:	1d9d      	adds	r5, r3, #6
   1cd4c:	2300      	movs	r3, #0
{
   1cd4e:	0004      	movs	r4, r0
    uint16 ue_stats_len = 0;
   1cd50:	802b      	strh	r3, [r5, #0]
    
    if (ue_stats_bin == NULL)
   1cd52:	4298      	cmp	r0, r3
   1cd54:	d101      	bne.n	1cd5a <get_ue_stats+0x14>
    {
        return NEUL_RET_ERROR;
   1cd56:	2001      	movs	r0, #1
    {
         return NEUL_RET_ERROR;
    }
    
    return NEUL_RET_OK;
}
   1cd58:	bd3e      	pop	{r1, r2, r3, r4, r5, pc}
    if (command_query_ue_stats(sizeof(ue_stats), &ue_stats_len, (uint8 *) ue_stats_bin) != RPC_ERR_OK)
   1cd5a:	0002      	movs	r2, r0
   1cd5c:	0029      	movs	r1, r5
   1cd5e:	2060      	movs	r0, #96	; 0x60
   1cd60:	f7e6 ffd5 	bl	3d0e <command_query_ue_stats>
   1cd64:	2800      	cmp	r0, #0
   1cd66:	d1f6      	bne.n	1cd56 <get_ue_stats+0x10>
    if ((ue_stats_len != sizeof(ue_stats)) || (ue_stats_bin->version != UE_STATS_VERSION))
   1cd68:	882b      	ldrh	r3, [r5, #0]
   1cd6a:	2b60      	cmp	r3, #96	; 0x60
   1cd6c:	d1f3      	bne.n	1cd56 <get_ue_stats+0x10>
   1cd6e:	8820      	ldrh	r0, [r4, #0]
   1cd70:	3808      	subs	r0, #8
   1cd72:	1e43      	subs	r3, r0, #1
   1cd74:	4198      	sbcs	r0, r3
        return NEUL_RET_ERROR;
   1cd76:	b2c0      	uxtb	r0, r0
   1cd78:	e7ee      	b.n	1cd58 <get_ue_stats+0x12>

0001cd7a <get_cell_info>:
 * @param max_cell_info_num max currently UE_MAX_CELL_INFO_NUM
 * @param number of cell info structures returned 
 * @param cell_info point of cell_info array
 */
NEUL_RET get_cell_info(uint8 max_cell_info_num, uint8 *cell_info_num, ue_cell_info *cell_info)
{   
   1cd7a:	b57f      	push	{r0, r1, r2, r3, r4, r5, r6, lr}
    NEUL_RET  result;
    uint16    cell_info_buffer_length;
    
    if (command_get_cell_info((uint8 *) &result, max_cell_info_num*sizeof(ue_cell_info), &cell_info_buffer_length, (uint8 *)cell_info, cell_info_num) != RPC_ERR_OK)
   1cd7c:	250d      	movs	r5, #13
   1cd7e:	0013      	movs	r3, r2
{   
   1cd80:	000e      	movs	r6, r1
   1cd82:	0014      	movs	r4, r2
    if (command_get_cell_info((uint8 *) &result, max_cell_info_num*sizeof(ue_cell_info), &cell_info_buffer_length, (uint8 *)cell_info, cell_info_num) != RPC_ERR_OK)
   1cd84:	220e      	movs	r2, #14
   1cd86:	446d      	add	r5, sp
   1cd88:	0101      	lsls	r1, r0, #4
   1cd8a:	9600      	str	r6, [sp, #0]
   1cd8c:	446a      	add	r2, sp
   1cd8e:	0028      	movs	r0, r5
   1cd90:	f7e8 f93e 	bl	5010 <command_get_cell_info>
    {
        return NEUL_RET_ERROR;
   1cd94:	2301      	movs	r3, #1
    if (command_get_cell_info((uint8 *) &result, max_cell_info_num*sizeof(ue_cell_info), &cell_info_buffer_length, (uint8 *)cell_info, cell_info_num) != RPC_ERR_OK)
   1cd96:	2800      	cmp	r0, #0
   1cd98:	d105      	bne.n	1cda6 <get_cell_info+0x2c>
   1cd9a:	7833      	ldrb	r3, [r6, #0]
   1cd9c:	011b      	lsls	r3, r3, #4
   1cd9e:	18e3      	adds	r3, r4, r3
    }

    for (uint8 index = 0; index < *cell_info_num; index++)
   1cda0:	429c      	cmp	r4, r3
   1cda2:	d103      	bne.n	1cdac <get_cell_info+0x32>
        {
            return NEUL_RET_ERROR;
        }
    }

    return result;
   1cda4:	782b      	ldrb	r3, [r5, #0]
}
   1cda6:	0018      	movs	r0, r3
   1cda8:	b004      	add	sp, #16
   1cdaa:	bd70      	pop	{r4, r5, r6, pc}
   1cdac:	3410      	adds	r4, #16
        if (cell_info[index].version != UE_CELL_INFO_VERSION)
   1cdae:	0021      	movs	r1, r4
   1cdb0:	3910      	subs	r1, #16
   1cdb2:	7809      	ldrb	r1, [r1, #0]
   1cdb4:	2902      	cmp	r1, #2
   1cdb6:	d0f3      	beq.n	1cda0 <get_cell_info+0x26>
        return NEUL_RET_ERROR;
   1cdb8:	2301      	movs	r3, #1
   1cdba:	e7f4      	b.n	1cda6 <get_cell_info+0x2c>

0001cdbc <get_imei>:

/* Return the IMEI in the location pointed by imei.
 * IMEI is IMEI_PACKED_LENGTH bytes long.
 */
NEUL_RET get_imei (uint8 *imei)
{
   1cdbc:	b530      	push	{r4, r5, lr}
    uint8 command_ret_code = (uint8) NEUL_RET_OK;
   1cdbe:	240d      	movs	r4, #13
   1cdc0:	2200      	movs	r2, #0
{
   1cdc2:	b085      	sub	sp, #20
    uint8 command_ret_code = (uint8) NEUL_RET_OK;
   1cdc4:	446c      	add	r4, sp
{
   1cdc6:	0003      	movs	r3, r0
    uint8 command_ret_code = (uint8) NEUL_RET_OK;
   1cdc8:	7022      	strb	r2, [r4, #0]
    RPC_ERR ret_val;
    uint16 id_len;
    if (!imei)
   1cdca:	4290      	cmp	r0, r2
   1cdcc:	d102      	bne.n	1cdd4 <get_imei+0x18>
    {
        return NEUL_RET_ERROR;
   1cdce:	2001      	movs	r0, #1
    if (ret_val != RPC_ERR_OK || command_ret_code != NEUL_RET_OK || id_len != IMEI_PACKED_LENGTH)
    {
        return NEUL_RET_ERROR;
    }
    return NEUL_RET_OK;
}
   1cdd0:	b005      	add	sp, #20
   1cdd2:	bd30      	pop	{r4, r5, pc}
    ret_val = command_get_id(ID_TYPE_IMEI, IMEI_PACKED_LENGTH, &id_len, imei, &command_ret_code);
   1cdd4:	250e      	movs	r5, #14
   1cdd6:	446d      	add	r5, sp
   1cdd8:	9400      	str	r4, [sp, #0]
   1cdda:	002a      	movs	r2, r5
   1cddc:	2108      	movs	r1, #8
   1cdde:	2001      	movs	r0, #1
   1cde0:	f7e6 fb25 	bl	342e <command_get_id>
    if (ret_val != RPC_ERR_OK || command_ret_code != NEUL_RET_OK || id_len != IMEI_PACKED_LENGTH)
   1cde4:	2800      	cmp	r0, #0
   1cde6:	d1f2      	bne.n	1cdce <get_imei+0x12>
   1cde8:	7823      	ldrb	r3, [r4, #0]
   1cdea:	2b00      	cmp	r3, #0
   1cdec:	d1ef      	bne.n	1cdce <get_imei+0x12>
   1cdee:	8828      	ldrh	r0, [r5, #0]
   1cdf0:	3808      	subs	r0, #8
   1cdf2:	1e43      	subs	r3, r0, #1
   1cdf4:	4198      	sbcs	r0, r3
        return NEUL_RET_ERROR;
   1cdf6:	b2c0      	uxtb	r0, r0
   1cdf8:	e7ea      	b.n	1cdd0 <get_imei+0x14>
	...

0001cdfc <set_svn>:
 */
NEUL_RET set_svn (const uint8 *svn)
{
    if (!svn)
    {
        return NEUL_RET_ERROR;
   1cdfc:	2301      	movs	r3, #1
    if (!svn)
   1cdfe:	2800      	cmp	r0, #0
   1ce00:	d003      	beq.n	1ce0a <set_svn+0xe>
    }

    // Save the SVN stored
    memcpy(neul_identity_svn, svn, SVN_PACKED_LENGTH);
   1ce02:	4b03      	ldr	r3, [pc, #12]	; (1ce10 <set_svn+0x14>)
   1ce04:	7802      	ldrb	r2, [r0, #0]
   1ce06:	701a      	strb	r2, [r3, #0]
    return NEUL_RET_OK;
   1ce08:	2300      	movs	r3, #0
}
   1ce0a:	0018      	movs	r0, r3
   1ce0c:	4770      	bx	lr
   1ce0e:	46c0      	nop			; (mov r8, r8)
   1ce10:	01002c7c 	.word	0x01002c7c

0001ce14 <get_svn>:
 */
NEUL_RET get_svn (uint8 *svn)
{
    if (!svn)
    {
        return NEUL_RET_ERROR;
   1ce14:	2301      	movs	r3, #1
    if (!svn)
   1ce16:	2800      	cmp	r0, #0
   1ce18:	d003      	beq.n	1ce22 <get_svn+0xe>
    }

    // Save the SVN stored
    memcpy(svn,neul_identity_svn,SVN_PACKED_LENGTH);
   1ce1a:	4b03      	ldr	r3, [pc, #12]	; (1ce28 <get_svn+0x14>)
   1ce1c:	781b      	ldrb	r3, [r3, #0]
   1ce1e:	7003      	strb	r3, [r0, #0]
    return NEUL_RET_OK;
   1ce20:	2300      	movs	r3, #0
}
   1ce22:	0018      	movs	r0, r3
   1ce24:	4770      	bx	lr
   1ce26:	46c0      	nop			; (mov r8, r8)
   1ce28:	01002c7c 	.word	0x01002c7c

0001ce2c <get_imeisv>:
{
   1ce2c:	b57f      	push	{r0, r1, r2, r3, r4, r5, r6, lr}
    uint8 command_ret_code = (uint8) NEUL_RET_OK;
   1ce2e:	250d      	movs	r5, #13
   1ce30:	2300      	movs	r3, #0
   1ce32:	446d      	add	r5, sp
{
   1ce34:	0004      	movs	r4, r0
    uint8 command_ret_code = (uint8) NEUL_RET_OK;
   1ce36:	702b      	strb	r3, [r5, #0]
    if (!imeisv)
   1ce38:	4298      	cmp	r0, r3
   1ce3a:	d102      	bne.n	1ce42 <get_imeisv+0x16>
        return NEUL_RET_ERROR;
   1ce3c:	2001      	movs	r0, #1
}
   1ce3e:	b004      	add	sp, #16
   1ce40:	bd70      	pop	{r4, r5, r6, pc}
    ret_val = command_get_id(ID_TYPE_IMEI, IMEI_PACKED_LENGTH, &id_len, imeisv, &command_ret_code);
   1ce42:	260e      	movs	r6, #14
   1ce44:	446e      	add	r6, sp
   1ce46:	0003      	movs	r3, r0
   1ce48:	9500      	str	r5, [sp, #0]
   1ce4a:	0032      	movs	r2, r6
   1ce4c:	2108      	movs	r1, #8
   1ce4e:	2001      	movs	r0, #1
   1ce50:	f7e6 faed 	bl	342e <command_get_id>
    if (ret_val != RPC_ERR_OK || command_ret_code != NEUL_RET_OK || id_len != IMEI_PACKED_LENGTH)
   1ce54:	2800      	cmp	r0, #0
   1ce56:	d1f1      	bne.n	1ce3c <get_imeisv+0x10>
   1ce58:	782b      	ldrb	r3, [r5, #0]
   1ce5a:	2b00      	cmp	r3, #0
   1ce5c:	d1ee      	bne.n	1ce3c <get_imeisv+0x10>
   1ce5e:	8833      	ldrh	r3, [r6, #0]
   1ce60:	2b08      	cmp	r3, #8
   1ce62:	d1eb      	bne.n	1ce3c <get_imeisv+0x10>
    return get_svn(imeisv+IMEI_PACKED_LENGTH-1);
   1ce64:	1de0      	adds	r0, r4, #7
   1ce66:	f7ff ffd5 	bl	1ce14 <get_svn>
   1ce6a:	e7e8      	b.n	1ce3e <get_imeisv+0x12>

0001ce6c <get_serial_number>:

/* Return the SERIAL_NUMBER in the location pointed by serialnumber.
 * SERIAL_NUMBER is SERIALNUMBER_LENGTH bytes long.
 */
NEUL_RET get_serial_number (uint8 *serialnumber)
{
   1ce6c:	b530      	push	{r4, r5, lr}
    uint8 command_ret_code = (uint8) NEUL_RET_OK;
   1ce6e:	240d      	movs	r4, #13
{
   1ce70:	0003      	movs	r3, r0
    uint8 command_ret_code = (uint8) NEUL_RET_OK;
   1ce72:	2000      	movs	r0, #0
{
   1ce74:	b085      	sub	sp, #20
    uint8 command_ret_code = (uint8) NEUL_RET_OK;
   1ce76:	446c      	add	r4, sp
   1ce78:	7020      	strb	r0, [r4, #0]
    RPC_ERR ret_val;
    uint16 id_len;
    if (!serialnumber)
   1ce7a:	4283      	cmp	r3, r0
   1ce7c:	d102      	bne.n	1ce84 <get_serial_number+0x18>
    {
        return NEUL_RET_ERROR;
   1ce7e:	2001      	movs	r0, #1
    if ((ret_val != RPC_ERR_OK) || (command_ret_code != NEUL_RET_OK) || (id_len != SERIALNUMBER_LENGTH))
    {
        return NEUL_RET_ERROR;
    }
    return NEUL_RET_OK;
}
   1ce80:	b005      	add	sp, #20
   1ce82:	bd30      	pop	{r4, r5, pc}
    ret_val = command_get_id(ID_TYPE_SERIALNUMBER, SERIALNUMBER_LENGTH, &id_len, serialnumber, &command_ret_code);
   1ce84:	250e      	movs	r5, #14
   1ce86:	446d      	add	r5, sp
   1ce88:	9400      	str	r4, [sp, #0]
   1ce8a:	002a      	movs	r2, r5
   1ce8c:	2110      	movs	r1, #16
   1ce8e:	f7e6 face 	bl	342e <command_get_id>
    if ((ret_val != RPC_ERR_OK) || (command_ret_code != NEUL_RET_OK) || (id_len != SERIALNUMBER_LENGTH))
   1ce92:	2800      	cmp	r0, #0
   1ce94:	d1f3      	bne.n	1ce7e <get_serial_number+0x12>
   1ce96:	7823      	ldrb	r3, [r4, #0]
   1ce98:	2b00      	cmp	r3, #0
   1ce9a:	d1f0      	bne.n	1ce7e <get_serial_number+0x12>
   1ce9c:	8828      	ldrh	r0, [r5, #0]
   1ce9e:	3810      	subs	r0, #16
   1cea0:	1e43      	subs	r3, r0, #1
   1cea2:	4198      	sbcs	r0, r3
        return NEUL_RET_ERROR;
   1cea4:	b2c0      	uxtb	r0, r0
   1cea6:	e7eb      	b.n	1ce80 <get_serial_number+0x14>

0001cea8 <freeifaddrs>:

/** @brief free data structure returned by
 * @param ifa    app_ifaddrs linked list
 */
void freeifaddrs(struct ifaddrs *ifa)
{
   1cea8:	b570      	push	{r4, r5, r6, lr}
   1ceaa:	0004      	movs	r4, r0
    struct ifaddrs *current;
    while(ifa)
   1ceac:	2c00      	cmp	r4, #0
   1ceae:	d100      	bne.n	1ceb2 <freeifaddrs+0xa>
        }
        ifa = ifa->ifa_next;
        
        irfree(current);
    }
}
   1ceb0:	bd70      	pop	{r4, r5, r6, pc}
        if (current->ifa_name != NULL)
   1ceb2:	6860      	ldr	r0, [r4, #4]
   1ceb4:	2800      	cmp	r0, #0
   1ceb6:	d001      	beq.n	1cebc <freeifaddrs+0x14>
            irfree(current->ifa_name);
   1ceb8:	f7f5 fdbe 	bl	12a38 <irfree>
        ifa = ifa->ifa_next;
   1cebc:	6825      	ldr	r5, [r4, #0]
        irfree(current);
   1cebe:	0020      	movs	r0, r4
   1cec0:	f7f5 fdba 	bl	12a38 <irfree>
        ifa = ifa->ifa_next;
   1cec4:	002c      	movs	r4, r5
   1cec6:	e7f1      	b.n	1ceac <freeifaddrs+0x4>

0001cec8 <getifaddrs>:
    *ifap = NULL;
   1cec8:	2300      	movs	r3, #0
{
   1ceca:	b5f0      	push	{r4, r5, r6, r7, lr}
   1cecc:	b08d      	sub	sp, #52	; 0x34
    *ifap = NULL;
   1cece:	6003      	str	r3, [r0, #0]
{
   1ced0:	0007      	movs	r7, r0
    neul_return_code = get_defined_cids(NEUL_MAX_CID + 1, &returned_cids, cids);
   1ced2:	aa09      	add	r2, sp, #36	; 0x24
   1ced4:	a908      	add	r1, sp, #32
   1ced6:	200b      	movs	r0, #11
   1ced8:	f7ff f9d1 	bl	1c27e <get_defined_cids>
   1cedc:	9003      	str	r0, [sp, #12]
    if (neul_return_code != NEUL_RET_OK)
   1cede:	2800      	cmp	r0, #0
   1cee0:	d004      	beq.n	1ceec <getifaddrs+0x24>
                return NEUL_RET_ERROR;
   1cee2:	2301      	movs	r3, #1
   1cee4:	9303      	str	r3, [sp, #12]
}
   1cee6:	9803      	ldr	r0, [sp, #12]
   1cee8:	b00d      	add	sp, #52	; 0x34
   1ceea:	bdf0      	pop	{r4, r5, r6, r7, pc}
    data_temp = irmalloc(EXPECTED_IFADDR_LEN);
   1ceec:	2070      	movs	r0, #112	; 0x70
   1ceee:	f7f5 fd87 	bl	12a00 <irmalloc>
   1cef2:	1e06      	subs	r6, r0, #0
    if (data_temp == NULL)
   1cef4:	d0f5      	beq.n	1cee2 <getifaddrs+0x1a>
    for (uint8 i = 0; i < returned_cids; i++)
   1cef6:	9b03      	ldr	r3, [sp, #12]
   1cef8:	9305      	str	r3, [sp, #20]
    struct ifaddrs *current = NULL;
   1cefa:	9304      	str	r3, [sp, #16]
    for (uint8 i = 0; i < returned_cids; i++)
   1cefc:	ab08      	add	r3, sp, #32
   1cefe:	881b      	ldrh	r3, [r3, #0]
   1cf00:	9a05      	ldr	r2, [sp, #20]
   1cf02:	4293      	cmp	r3, r2
   1cf04:	d809      	bhi.n	1cf1a <getifaddrs+0x52>
    if (current != NULL)
   1cf06:	9b04      	ldr	r3, [sp, #16]
   1cf08:	2b00      	cmp	r3, #0
   1cf0a:	d002      	beq.n	1cf12 <getifaddrs+0x4a>
        current->ifa_next = NULL;
   1cf0c:	2300      	movs	r3, #0
   1cf0e:	9a04      	ldr	r2, [sp, #16]
   1cf10:	6013      	str	r3, [r2, #0]
    irfree(data_temp);
   1cf12:	0030      	movs	r0, r6
   1cf14:	f7f5 fd90 	bl	12a38 <irfree>
    return NEUL_RET_OK;
   1cf18:	e7e5      	b.n	1cee6 <getifaddrs+0x1e>
        if (command_getifaddr(cids[i], EXPECTED_IFADDR_LEN, &ifaddr_data_length, data_temp, &result) != RPC_ERR_OK)
   1cf1a:	2512      	movs	r5, #18
   1cf1c:	240f      	movs	r4, #15
   1cf1e:	ab04      	add	r3, sp, #16
   1cf20:	9a05      	ldr	r2, [sp, #20]
   1cf22:	18ed      	adds	r5, r5, r3
   1cf24:	ab09      	add	r3, sp, #36	; 0x24
   1cf26:	5c98      	ldrb	r0, [r3, r2]
   1cf28:	ab04      	add	r3, sp, #16
   1cf2a:	18e4      	adds	r4, r4, r3
   1cf2c:	9400      	str	r4, [sp, #0]
   1cf2e:	0033      	movs	r3, r6
   1cf30:	002a      	movs	r2, r5
   1cf32:	2170      	movs	r1, #112	; 0x70
   1cf34:	f7e6 faae 	bl	3494 <command_getifaddr>
   1cf38:	2800      	cmp	r0, #0
   1cf3a:	d006      	beq.n	1cf4a <getifaddrs+0x82>
            freeifaddrs(*ifap);
   1cf3c:	6838      	ldr	r0, [r7, #0]
   1cf3e:	f7ff ffb3 	bl	1cea8 <freeifaddrs>
                irfree(data_temp);
   1cf42:	0030      	movs	r0, r6
   1cf44:	f7f5 fd78 	bl	12a38 <irfree>
   1cf48:	e7cb      	b.n	1cee2 <getifaddrs+0x1a>
        if ((result > 0) || (ifaddr_data_length > EXPECTED_IFADDR_LEN))
   1cf4a:	7823      	ldrb	r3, [r4, #0]
   1cf4c:	2b00      	cmp	r3, #0
   1cf4e:	d1f5      	bne.n	1cf3c <getifaddrs+0x74>
   1cf50:	882b      	ldrh	r3, [r5, #0]
   1cf52:	2b70      	cmp	r3, #112	; 0x70
   1cf54:	d8f2      	bhi.n	1cf3c <getifaddrs+0x74>
   1cf56:	0035      	movs	r5, r6
   1cf58:	e04b      	b.n	1cff2 <getifaddrs+0x12a>
            ifaddr_data_buff = irmalloc(sizeof(struct ifaddrs));
   1cf5a:	2038      	movs	r0, #56	; 0x38
   1cf5c:	f7f5 fd50 	bl	12a00 <irmalloc>
   1cf60:	1e04      	subs	r4, r0, #0
            if (ifaddr_data_buff == NULL)
   1cf62:	d104      	bne.n	1cf6e <getifaddrs+0xa6>
                freeifaddrs(*ifap);
   1cf64:	6838      	ldr	r0, [r7, #0]
   1cf66:	f7ff ff9f 	bl	1cea8 <freeifaddrs>
               *ifap = NULL;
   1cf6a:	603c      	str	r4, [r7, #0]
   1cf6c:	e7e9      	b.n	1cf42 <getifaddrs+0x7a>
            ifaddr_data_buff->ifa_flags = addrs_structs_p->ifa_flags;
   1cf6e:	682b      	ldr	r3, [r5, #0]
   1cf70:	60c3      	str	r3, [r0, #12]
            ip_addr_copy(ifaddr_data_buff->ifa_addr, addrs_structs_p->ifa_addr);
   1cf72:	7d2a      	ldrb	r2, [r5, #20]
   1cf74:	1c43      	adds	r3, r0, #1
   1cf76:	77da      	strb	r2, [r3, #31]
   1cf78:	7d2a      	ldrb	r2, [r5, #20]
   1cf7a:	686b      	ldr	r3, [r5, #4]
   1cf7c:	6103      	str	r3, [r0, #16]
   1cf7e:	2a06      	cmp	r2, #6
   1cf80:	d105      	bne.n	1cf8e <getifaddrs+0xc6>
   1cf82:	68ab      	ldr	r3, [r5, #8]
   1cf84:	6143      	str	r3, [r0, #20]
   1cf86:	68eb      	ldr	r3, [r5, #12]
   1cf88:	6183      	str	r3, [r0, #24]
   1cf8a:	692b      	ldr	r3, [r5, #16]
   1cf8c:	61c3      	str	r3, [r0, #28]
   1cf8e:	002b      	movs	r3, r5
            ip_addr_copy(ifaddr_data_buff->ifa_netmask, addrs_structs_p->ifa_netmask);
   1cf90:	0022      	movs	r2, r4
   1cf92:	3328      	adds	r3, #40	; 0x28
   1cf94:	7819      	ldrb	r1, [r3, #0]
   1cf96:	3234      	adds	r2, #52	; 0x34
   1cf98:	7011      	strb	r1, [r2, #0]
   1cf9a:	781a      	ldrb	r2, [r3, #0]
   1cf9c:	69ab      	ldr	r3, [r5, #24]
   1cf9e:	6263      	str	r3, [r4, #36]	; 0x24
   1cfa0:	2a06      	cmp	r2, #6
   1cfa2:	d105      	bne.n	1cfb0 <getifaddrs+0xe8>
   1cfa4:	69eb      	ldr	r3, [r5, #28]
   1cfa6:	62a3      	str	r3, [r4, #40]	; 0x28
   1cfa8:	6a2b      	ldr	r3, [r5, #32]
   1cfaa:	62e3      	str	r3, [r4, #44]	; 0x2c
   1cfac:	6a6b      	ldr	r3, [r5, #36]	; 0x24
   1cfae:	6323      	str	r3, [r4, #48]	; 0x30
            ifaddr_data_buff->cid = addrs_structs_p->cid;
   1cfb0:	2230      	movs	r2, #48	; 0x30
   1cfb2:	5eab      	ldrsh	r3, [r5, r2]
   1cfb4:	8123      	strh	r3, [r4, #8]
            if (*ifap == NULL || current == NULL)
   1cfb6:	683b      	ldr	r3, [r7, #0]
   1cfb8:	2b00      	cmp	r3, #0
   1cfba:	d002      	beq.n	1cfc2 <getifaddrs+0xfa>
   1cfbc:	9b04      	ldr	r3, [sp, #16]
   1cfbe:	2b00      	cmp	r3, #0
   1cfc0:	d122      	bne.n	1d008 <getifaddrs+0x140>
                *ifap = ifaddr_data_buff;
   1cfc2:	603c      	str	r4, [r7, #0]
            if (addrs_structs_p->ifa_name_size > 0)
   1cfc4:	8da8      	ldrh	r0, [r5, #44]	; 0x2c
   1cfc6:	2800      	cmp	r0, #0
   1cfc8:	d021      	beq.n	1d00e <getifaddrs+0x146>
                current->ifa_name = irmalloc(addrs_structs_p->ifa_name_size);
   1cfca:	f7f5 fd19 	bl	12a00 <irmalloc>
   1cfce:	6060      	str	r0, [r4, #4]
                if (current->ifa_name != NULL)
   1cfd0:	2800      	cmp	r0, #0
   1cfd2:	d004      	beq.n	1cfde <getifaddrs+0x116>
                    memcpy(current->ifa_name, data_temp + addrs_structs_p->ifa_name_offset, addrs_structs_p->ifa_name_size);
   1cfd4:	8de9      	ldrh	r1, [r5, #46]	; 0x2e
   1cfd6:	8daa      	ldrh	r2, [r5, #44]	; 0x2c
   1cfd8:	1871      	adds	r1, r6, r1
   1cfda:	f7e3 f909 	bl	1f0 <memcpy>
            ifaddr_data_length -= (sizeof(struct ipc_app_ifaddrs) + addrs_structs_p->ifa_name_size);
   1cfde:	2212      	movs	r2, #18
   1cfe0:	ab04      	add	r3, sp, #16
   1cfe2:	18d2      	adds	r2, r2, r3
   1cfe4:	8813      	ldrh	r3, [r2, #0]
   1cfe6:	8da9      	ldrh	r1, [r5, #44]	; 0x2c
   1cfe8:	3b34      	subs	r3, #52	; 0x34
   1cfea:	1a5b      	subs	r3, r3, r1
   1cfec:	8013      	strh	r3, [r2, #0]
            addrs_structs_p++;
   1cfee:	3534      	adds	r5, #52	; 0x34
   1cff0:	9404      	str	r4, [sp, #16]
        while (ifaddr_data_length > sizeof(struct ipc_app_ifaddrs))
   1cff2:	2312      	movs	r3, #18
   1cff4:	aa04      	add	r2, sp, #16
   1cff6:	189b      	adds	r3, r3, r2
   1cff8:	881b      	ldrh	r3, [r3, #0]
   1cffa:	2b34      	cmp	r3, #52	; 0x34
   1cffc:	d8ad      	bhi.n	1cf5a <getifaddrs+0x92>
    for (uint8 i = 0; i < returned_cids; i++)
   1cffe:	9b05      	ldr	r3, [sp, #20]
   1d000:	3301      	adds	r3, #1
   1d002:	b2db      	uxtb	r3, r3
   1d004:	9305      	str	r3, [sp, #20]
   1d006:	e779      	b.n	1cefc <getifaddrs+0x34>
                current->ifa_next = ifaddr_data_buff;
   1d008:	9b04      	ldr	r3, [sp, #16]
   1d00a:	601c      	str	r4, [r3, #0]
   1d00c:	e7da      	b.n	1cfc4 <getifaddrs+0xfc>
                current->ifa_name = NULL;
   1d00e:	6060      	str	r0, [r4, #4]
   1d010:	e7e5      	b.n	1cfde <getifaddrs+0x116>

0001d012 <freednsaddrs>:

/** @brief free data structure returned by
 * @param dnsa    dns server address linked list
 */
void freednsaddrs(struct dnsaddrs *dnsa)
{
   1d012:	b510      	push	{r4, lr}
    struct dnsaddrs *current;
    while(dnsa)
   1d014:	2800      	cmp	r0, #0
   1d016:	d100      	bne.n	1d01a <freednsaddrs+0x8>
        current = dnsa;
        dnsa    = dnsa->dnsa_next;
        
        irfree(current);
    }
}
   1d018:	bd10      	pop	{r4, pc}
        dnsa    = dnsa->dnsa_next;
   1d01a:	6804      	ldr	r4, [r0, #0]
        irfree(current);
   1d01c:	f7f5 fd0c 	bl	12a38 <irfree>
        dnsa    = dnsa->dnsa_next;
   1d020:	0020      	movs	r0, r4
   1d022:	e7f7      	b.n	1d014 <freednsaddrs+0x2>

0001d024 <getdnsaddr>:
    *dnsap = NULL;
   1d024:	2300      	movs	r3, #0
{
   1d026:	b5f0      	push	{r4, r5, r6, r7, lr}
   1d028:	b089      	sub	sp, #36	; 0x24
   1d02a:	9004      	str	r0, [sp, #16]
    *dnsap = NULL;
   1d02c:	600b      	str	r3, [r1, #0]
    dns_server_addr_data = (ip_addr_t *)irmalloc(sizeof(ip_addr_t) * MAX_DNS_SERVER_ADDR_NUM);
   1d02e:	2078      	movs	r0, #120	; 0x78
{
   1d030:	000f      	movs	r7, r1
    dns_server_addr_data = (ip_addr_t *)irmalloc(sizeof(ip_addr_t) * MAX_DNS_SERVER_ADDR_NUM);
   1d032:	f7f5 fce5 	bl	12a00 <irmalloc>
        return NEUL_RET_MEMORY_ERROR;
   1d036:	230d      	movs	r3, #13
    dns_server_addr_data = (ip_addr_t *)irmalloc(sizeof(ip_addr_t) * MAX_DNS_SERVER_ADDR_NUM);
   1d038:	1e06      	subs	r6, r0, #0
        return NEUL_RET_MEMORY_ERROR;
   1d03a:	9302      	str	r3, [sp, #8]
    if (dns_server_addr_data == NULL)
   1d03c:	d01b      	beq.n	1d076 <getdnsaddr+0x52>
    if (command_get_dns_server_ip_address(cid, (uint8*)&neul_return_code, (uint16)(sizeof(ip_addr_t) * MAX_DNS_SERVER_ADDR_NUM + 1), &length, (uint8*)dns_server_addr_data) != RPC_ERR_OK)
   1d03e:	001c      	movs	r4, r3
   1d040:	ab04      	add	r3, sp, #16
   1d042:	18e4      	adds	r4, r4, r3
   1d044:	230e      	movs	r3, #14
   1d046:	aa04      	add	r2, sp, #16
   1d048:	9000      	str	r0, [sp, #0]
   1d04a:	189b      	adds	r3, r3, r2
   1d04c:	0021      	movs	r1, r4
   1d04e:	2279      	movs	r2, #121	; 0x79
   1d050:	9804      	ldr	r0, [sp, #16]
   1d052:	f7e8 fd93 	bl	5b7c <command_get_dns_server_ip_address>
   1d056:	2800      	cmp	r0, #0
   1d058:	d004      	beq.n	1d064 <getdnsaddr+0x40>
            irfree(dns_server_addr_data);
   1d05a:	0030      	movs	r0, r6
   1d05c:	f7f5 fcec 	bl	12a38 <irfree>
            return NEUL_RET_ERROR;
   1d060:	2301      	movs	r3, #1
   1d062:	e007      	b.n	1d074 <getdnsaddr+0x50>
    if (neul_return_code != NEUL_RET_OK)
   1d064:	7823      	ldrb	r3, [r4, #0]
   1d066:	9302      	str	r3, [sp, #8]
   1d068:	2b00      	cmp	r3, #0
   1d06a:	d007      	beq.n	1d07c <getdnsaddr+0x58>
        irfree(dns_server_addr_data);
   1d06c:	0030      	movs	r0, r6
   1d06e:	f7f5 fce3 	bl	12a38 <irfree>
        return neul_return_code;
   1d072:	7823      	ldrb	r3, [r4, #0]
   1d074:	9302      	str	r3, [sp, #8]
}
   1d076:	9802      	ldr	r0, [sp, #8]
   1d078:	b009      	add	sp, #36	; 0x24
   1d07a:	bdf0      	pop	{r4, r5, r6, r7, pc}
    dns_server_addr_number = (uint8)length/sizeof(ip_addr_t);
   1d07c:	ab04      	add	r3, sp, #16
   1d07e:	7b98      	ldrb	r0, [r3, #14]
   1d080:	2114      	movs	r1, #20
   1d082:	f7e3 f999 	bl	3b8 <__udivsi3>
   1d086:	b2c3      	uxtb	r3, r0
   1d088:	2014      	movs	r0, #20
   1d08a:	0035      	movs	r5, r6
   1d08c:	4358      	muls	r0, r3
   1d08e:	1983      	adds	r3, r0, r6
   1d090:	9305      	str	r3, [sp, #20]
    struct dnsaddrs *current                 = NULL;
   1d092:	9b02      	ldr	r3, [sp, #8]
   1d094:	9303      	str	r3, [sp, #12]
    while (i < dns_server_addr_number)
   1d096:	9b05      	ldr	r3, [sp, #20]
   1d098:	429d      	cmp	r5, r3
   1d09a:	d103      	bne.n	1d0a4 <getdnsaddr+0x80>
    irfree(dns_server_addr_data);
   1d09c:	0030      	movs	r0, r6
   1d09e:	f7f5 fccb 	bl	12a38 <irfree>
    return NEUL_RET_OK;
   1d0a2:	e7e8      	b.n	1d076 <getdnsaddr+0x52>
        dnsaddr_data_buff = irzalloc(sizeof(struct dnsaddrs));
   1d0a4:	201c      	movs	r0, #28
   1d0a6:	f7f5 fcb5 	bl	12a14 <irzalloc>
   1d0aa:	1e04      	subs	r4, r0, #0
        if (dnsaddr_data_buff == NULL)
   1d0ac:	d104      	bne.n	1d0b8 <getdnsaddr+0x94>
            freednsaddrs(*dnsap);
   1d0ae:	6838      	ldr	r0, [r7, #0]
   1d0b0:	f7ff ffaf 	bl	1d012 <freednsaddrs>
           *dnsap = NULL;
   1d0b4:	603c      	str	r4, [r7, #0]
   1d0b6:	e7d0      	b.n	1d05a <getdnsaddr+0x36>
        dnsaddr_data_buff->cid = cid;
   1d0b8:	466b      	mov	r3, sp
   1d0ba:	7c1b      	ldrb	r3, [r3, #16]
   1d0bc:	7103      	strb	r3, [r0, #4]
        ip_addr_copy(dnsaddr_data_buff->dns_addr, dns_server_addr_data[i]);
   1d0be:	7c2b      	ldrb	r3, [r5, #16]
   1d0c0:	7603      	strb	r3, [r0, #24]
   1d0c2:	7c2a      	ldrb	r2, [r5, #16]
   1d0c4:	682b      	ldr	r3, [r5, #0]
   1d0c6:	6083      	str	r3, [r0, #8]
   1d0c8:	2a06      	cmp	r2, #6
   1d0ca:	d105      	bne.n	1d0d8 <getdnsaddr+0xb4>
   1d0cc:	686b      	ldr	r3, [r5, #4]
   1d0ce:	60c3      	str	r3, [r0, #12]
   1d0d0:	68ab      	ldr	r3, [r5, #8]
   1d0d2:	6103      	str	r3, [r0, #16]
   1d0d4:	68eb      	ldr	r3, [r5, #12]
   1d0d6:	6143      	str	r3, [r0, #20]
        if (*dnsap == NULL || current == NULL)
   1d0d8:	683b      	ldr	r3, [r7, #0]
   1d0da:	2b00      	cmp	r3, #0
   1d0dc:	d002      	beq.n	1d0e4 <getdnsaddr+0xc0>
   1d0de:	9b03      	ldr	r3, [sp, #12]
   1d0e0:	2b00      	cmp	r3, #0
   1d0e2:	d103      	bne.n	1d0ec <getdnsaddr+0xc8>
            *dnsap = dnsaddr_data_buff;
   1d0e4:	603c      	str	r4, [r7, #0]
   1d0e6:	3514      	adds	r5, #20
    struct dnsaddrs *current                 = NULL;
   1d0e8:	9403      	str	r4, [sp, #12]
   1d0ea:	e7d4      	b.n	1d096 <getdnsaddr+0x72>
            current->dnsa_next = dnsaddr_data_buff;
   1d0ec:	9b03      	ldr	r3, [sp, #12]
   1d0ee:	601c      	str	r4, [r3, #0]
   1d0f0:	e7f9      	b.n	1d0e6 <getdnsaddr+0xc2>
	...

0001d0f4 <set_ipaddr_callback>:
/**
 * Sets a callback that will be used to let us know of changes to the IP address
 * @param callback The callback function, which will return the cid of the changed interface
 */
NEUL_RET set_ipaddr_callback(ip_changed_callback callback)
{
   1d0f4:	b530      	push	{r4, r5, lr}
    uint8 i;
    for (i = 0; i < MAX_NUM_IP_CALLBACK; i++)
    {
        if (ip_changed_callback_table[i] == callback)
   1d0f6:	490d      	ldr	r1, [pc, #52]	; (1d12c <set_ipaddr_callback+0x38>)
        {
            return NEUL_RET_OK;
   1d0f8:	2200      	movs	r2, #0
        if (ip_changed_callback_table[i] == callback)
   1d0fa:	680b      	ldr	r3, [r1, #0]
   1d0fc:	4298      	cmp	r0, r3
   1d0fe:	d00d      	beq.n	1d11c <set_ipaddr_callback+0x28>
   1d100:	684d      	ldr	r5, [r1, #4]
   1d102:	42a8      	cmp	r0, r5
   1d104:	d00a      	beq.n	1d11c <set_ipaddr_callback+0x28>
   1d106:	688c      	ldr	r4, [r1, #8]
   1d108:	42a0      	cmp	r0, r4
   1d10a:	d007      	beq.n	1d11c <set_ipaddr_callback+0x28>
        }
    }

    for (i = 0; i < MAX_NUM_IP_CALLBACK; i++)
    {
        if (ip_changed_callback_table[i] == NULL)
   1d10c:	4293      	cmp	r3, r2
   1d10e:	d008      	beq.n	1d122 <set_ipaddr_callback+0x2e>
   1d110:	4295      	cmp	r5, r2
   1d112:	d005      	beq.n	1d120 <set_ipaddr_callback+0x2c>
            ip_changed_callback_table[i] = callback;
            return NEUL_RET_OK;
        }
    }
    
    return NEUL_RET_ERROR;
   1d114:	3201      	adds	r2, #1
        if (ip_changed_callback_table[i] == NULL)
   1d116:	2302      	movs	r3, #2
   1d118:	2c00      	cmp	r4, #0
   1d11a:	d002      	beq.n	1d122 <set_ipaddr_callback+0x2e>
}
   1d11c:	0010      	movs	r0, r2
   1d11e:	bd30      	pop	{r4, r5, pc}
        if (ip_changed_callback_table[i] == NULL)
   1d120:	2301      	movs	r3, #1
            ip_changed_callback_table[i] = callback;
   1d122:	009b      	lsls	r3, r3, #2
   1d124:	50c8      	str	r0, [r1, r3]
            return NEUL_RET_OK;
   1d126:	2200      	movs	r2, #0
   1d128:	e7f8      	b.n	1d11c <set_ipaddr_callback+0x28>
   1d12a:	46c0      	nop			; (mov r8, r8)
   1d12c:	01002c80 	.word	0x01002c80

0001d130 <remote_command_ip_address_changed>:
/**
 * @brief callback to receive IP address changed ind
 * @param cid  The cid which IP has changed
 */
void remote_command_ip_address_changed(CORES core, uint8 cid)
{
   1d130:	b570      	push	{r4, r5, r6, lr}
   1d132:	000d      	movs	r5, r1
   1d134:	2400      	movs	r4, #0
    UNUSED(core);
    uint8 i;
    for (i = 0; i < MAX_NUM_IP_CALLBACK; i++)
    {
        if (ip_changed_callback_table[i] != NULL)
   1d136:	4b05      	ldr	r3, [pc, #20]	; (1d14c <remote_command_ip_address_changed+0x1c>)
   1d138:	00a2      	lsls	r2, r4, #2
   1d13a:	58d3      	ldr	r3, [r2, r3]
   1d13c:	2b00      	cmp	r3, #0
   1d13e:	d001      	beq.n	1d144 <remote_command_ip_address_changed+0x14>
        {
            (ip_changed_callback_table[i])(cid);
   1d140:	0028      	movs	r0, r5
   1d142:	4798      	blx	r3
   1d144:	3401      	adds	r4, #1
    for (i = 0; i < MAX_NUM_IP_CALLBACK; i++)
   1d146:	2c03      	cmp	r4, #3
   1d148:	d1f5      	bne.n	1d136 <remote_command_ip_address_changed+0x6>
        }

    }
}
   1d14a:	bd70      	pop	{r4, r5, r6, pc}
   1d14c:	01002c80 	.word	0x01002c80

0001d150 <icmp_ping_send>:
}

/* @brief send icmp ping packet, and register callback to receive response
 */
NEUL_RET icmp_ping_send(ip_addr_t *remote_addr, uint16 p_size, uint32 timeout, icmp_ping_callback callback)
{
   1d150:	b57f      	push	{r0, r1, r2, r3, r4, r5, r6, lr}
    NEUL_RET    neul_result;
    RPC_ERR     rpc_return_code;

    if ((remote_addr == NULL) || (callback == NULL))
    {
        return NEUL_RET_ERROR;
   1d152:	2401      	movs	r4, #1
    if ((remote_addr == NULL) || (callback == NULL))
   1d154:	2800      	cmp	r0, #0
   1d156:	d017      	beq.n	1d188 <icmp_ping_send+0x38>
   1d158:	2b00      	cmp	r3, #0
   1d15a:	d015      	beq.n	1d188 <icmp_ping_send+0x38>
    }
    //Only one ping once a time.
    if (ping_callback == NULL)
   1d15c:	4d0c      	ldr	r5, [pc, #48]	; (1d190 <icmp_ping_send+0x40>)
        {
            ping_callback = NULL;
            return neul_result;
        }
    }
    return NEUL_RET_IN_PROGRESS;
   1d15e:	3408      	adds	r4, #8
    if (ping_callback == NULL)
   1d160:	682e      	ldr	r6, [r5, #0]
   1d162:	2e00      	cmp	r6, #0
   1d164:	d110      	bne.n	1d188 <icmp_ping_send+0x38>
        rpc_return_code = command_set_ping(sizeof(ip_addr_t), (uint8*)remote_addr, p_size, timeout, (uint8 *)&neul_result);
   1d166:	3406      	adds	r4, #6
   1d168:	446c      	add	r4, sp
        ping_callback = callback;
   1d16a:	602b      	str	r3, [r5, #0]
        rpc_return_code = command_set_ping(sizeof(ip_addr_t), (uint8*)remote_addr, p_size, timeout, (uint8 *)&neul_result);
   1d16c:	9400      	str	r4, [sp, #0]
   1d16e:	0013      	movs	r3, r2
   1d170:	000a      	movs	r2, r1
   1d172:	0001      	movs	r1, r0
   1d174:	2014      	movs	r0, #20
   1d176:	f7e7 f80e 	bl	4196 <command_set_ping>
        if ((neul_result == NEUL_RET_OK) && (rpc_return_code == RPC_ERR_OK))
   1d17a:	7824      	ldrb	r4, [r4, #0]
   1d17c:	2c00      	cmp	r4, #0
   1d17e:	d101      	bne.n	1d184 <icmp_ping_send+0x34>
   1d180:	2800      	cmp	r0, #0
   1d182:	d001      	beq.n	1d188 <icmp_ping_send+0x38>
            ping_callback = NULL;
   1d184:	2300      	movs	r3, #0
   1d186:	602b      	str	r3, [r5, #0]
}
   1d188:	0020      	movs	r0, r4
   1d18a:	b004      	add	sp, #16
   1d18c:	bd70      	pop	{r4, r5, r6, pc}
   1d18e:	46c0      	nop			; (mov r8, r8)
   1d190:	01002c8c 	.word	0x01002c8c

0001d194 <remote_command_ping_ind>:

void remote_command_ping_ind(CORES core, uint16 remote_addr_length, uint8 *remote_addr, uint8 result, uint8 ttl, uint32 rtt)
{
   1d194:	b570      	push	{r4, r5, r6, lr}
   1d196:	b086      	sub	sp, #24
   1d198:	001c      	movs	r4, r3
   1d19a:	ab0a      	add	r3, sp, #40	; 0x28
   1d19c:	0011      	movs	r1, r2
   1d19e:	781d      	ldrb	r5, [r3, #0]
    UNUSED(core);
    UNUSED(remote_addr_length);

    ip_addr_t   remote_ip_addr;

    if (remote_addr == NULL)
   1d1a0:	2a00      	cmp	r2, #0
   1d1a2:	d010      	beq.n	1d1c6 <remote_command_ping_ind+0x32>
    {
        return;
    }

    memcpy(&remote_ip_addr, remote_addr, sizeof(ip_addr_t));
   1d1a4:	2214      	movs	r2, #20
   1d1a6:	a801      	add	r0, sp, #4
   1d1a8:	f7e3 f822 	bl	1f0 <memcpy>
    icmp_handle_calllback(&remote_ip_addr, (bool)result, ttl, rtt);
   1d1ac:	1e61      	subs	r1, r4, #1
   1d1ae:	418c      	sbcs	r4, r1
   1d1b0:	b2e1      	uxtb	r1, r4
    icmp_ping_callback callback = ping_callback;
   1d1b2:	4c06      	ldr	r4, [pc, #24]	; (1d1cc <remote_command_ping_ind+0x38>)
   1d1b4:	6826      	ldr	r6, [r4, #0]
    if (callback != NULL)
   1d1b6:	2e00      	cmp	r6, #0
   1d1b8:	d005      	beq.n	1d1c6 <remote_command_ping_ind+0x32>
        (callback)(remote_addr, success, ttl, rtt);
   1d1ba:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
   1d1bc:	002a      	movs	r2, r5
   1d1be:	a801      	add	r0, sp, #4
   1d1c0:	47b0      	blx	r6
        ping_callback = NULL;
   1d1c2:	2300      	movs	r3, #0
   1d1c4:	6023      	str	r3, [r4, #0]
}//lint !e818
   1d1c6:	b006      	add	sp, #24
   1d1c8:	bd70      	pop	{r4, r5, r6, pc}
   1d1ca:	46c0      	nop			; (mov r8, r8)
   1d1cc:	01002c8c 	.word	0x01002c8c

0001d1d0 <ipaddr_aton>:
 * @param addr conversion result is stored here
 * @return 1 on success, 0 on error
 */
int
ipaddr_aton(const char *cp, ip_addr_t *addr)
{
   1d1d0:	b510      	push	{r4, lr}
   1d1d2:	1e02      	subs	r2, r0, #0
  if (cp != NULL) {
   1d1d4:	d10c      	bne.n	1d1f0 <ipaddr_aton+0x20>
      IP_SET_TYPE_VAL(*addr, IPADDR_TYPE_V4);
    }
    return ip4addr_aton(cp, ip_2_ip4(addr)); //lint !e613
  }
  return 0;
}
   1d1d6:	bd10      	pop	{r4, pc}
      if (*c == ':') {
   1d1d8:	2b3a      	cmp	r3, #58	; 0x3a
   1d1da:	d106      	bne.n	1d1ea <ipaddr_aton+0x1a>
        if (addr) {
   1d1dc:	2900      	cmp	r1, #0
   1d1de:	d001      	beq.n	1d1e4 <ipaddr_aton+0x14>
          IP_SET_TYPE_VAL(*addr, IPADDR_TYPE_V6);
   1d1e0:	3b34      	subs	r3, #52	; 0x34
   1d1e2:	740b      	strb	r3, [r1, #16]
        return ip6addr_aton(cp, ip_2_ip6(addr)); //lint !e613
   1d1e4:	f000 f998 	bl	1d518 <ip6addr_aton>
   1d1e8:	e7f5      	b.n	1d1d6 <ipaddr_aton+0x6>
      } else if (*c == '.') {
   1d1ea:	2b2e      	cmp	r3, #46	; 0x2e
   1d1ec:	d003      	beq.n	1d1f6 <ipaddr_aton+0x26>
    for (c = cp; *c != 0; c++) {
   1d1ee:	3201      	adds	r2, #1
   1d1f0:	7813      	ldrb	r3, [r2, #0]
   1d1f2:	2b00      	cmp	r3, #0
   1d1f4:	d1f0      	bne.n	1d1d8 <ipaddr_aton+0x8>
    if (addr) {
   1d1f6:	2900      	cmp	r1, #0
   1d1f8:	d001      	beq.n	1d1fe <ipaddr_aton+0x2e>
      IP_SET_TYPE_VAL(*addr, IPADDR_TYPE_V4);
   1d1fa:	2300      	movs	r3, #0
   1d1fc:	740b      	strb	r3, [r1, #16]
    return ip4addr_aton(cp, ip_2_ip4(addr)); //lint !e613
   1d1fe:	f000 f851 	bl	1d2a4 <ip4addr_aton>
   1d202:	e7e8      	b.n	1d1d6 <ipaddr_aton+0x6>

0001d204 <ip4addr_ntoa_r>:
 * @return either pointer to buf which now holds the ASCII
 *         representation of addr or NULL if buf was too small
 */
char*
ip4addr_ntoa_r(const ip4_addr_t *addr, char *buf, int buflen)
{
   1d204:	b5f0      	push	{r4, r5, r6, r7, lr}
  uint8 rem;
  uint8 n;
  uint8 i;
  int len = 0;

  s_addr = ip4_addr_get_u32(addr);
   1d206:	2600      	movs	r6, #0

  rp = buf;
   1d208:	000f      	movs	r7, r1
  s_addr = ip4_addr_get_u32(addr);
   1d20a:	6803      	ldr	r3, [r0, #0]
{
   1d20c:	b087      	sub	sp, #28
   1d20e:	9101      	str	r1, [sp, #4]
   1d210:	9202      	str	r2, [sp, #8]
  s_addr = ip4_addr_get_u32(addr);
   1d212:	9305      	str	r3, [sp, #20]
  int len = 0;
   1d214:	9600      	str	r6, [sp, #0]
  ap = (uint8 *)&s_addr;
  for (n = 0; n < 4; n++) {
    i = 0;
   1d216:	2400      	movs	r4, #0
   1d218:	ab05      	add	r3, sp, #20
   1d21a:	5d9d      	ldrb	r5, [r3, r6]
    do {
      rem = *ap % (uint8)10;
   1d21c:	0028      	movs	r0, r5
   1d21e:	210a      	movs	r1, #10
   1d220:	f7e3 f950 	bl	4c4 <__aeabi_uidivmod>
      *ap /= (uint8)10;
   1d224:	0028      	movs	r0, r5
      rem = *ap % (uint8)10;
   1d226:	b2cb      	uxtb	r3, r1
      *ap /= (uint8)10;
   1d228:	210a      	movs	r1, #10
      rem = *ap % (uint8)10;
   1d22a:	9303      	str	r3, [sp, #12]
      *ap /= (uint8)10;
   1d22c:	f7e3 f8c4 	bl	3b8 <__udivsi3>
      inv[i++] = '0' + (char) rem;
   1d230:	9903      	ldr	r1, [sp, #12]
   1d232:	1c63      	adds	r3, r4, #1
   1d234:	3130      	adds	r1, #48	; 0x30
   1d236:	aa04      	add	r2, sp, #16
      *ap /= (uint8)10;
   1d238:	b2c5      	uxtb	r5, r0
      inv[i++] = '0' + (char) rem;
   1d23a:	b2db      	uxtb	r3, r3
   1d23c:	5511      	strb	r1, [r2, r4]
    } while (*ap);
   1d23e:	2d00      	cmp	r5, #0
   1d240:	d118      	bne.n	1d274 <ip4addr_ntoa_r+0x70>
   1d242:	0013      	movs	r3, r2
   1d244:	3304      	adds	r3, #4
   1d246:	559d      	strb	r5, [r3, r6]
   1d248:	9b00      	ldr	r3, [sp, #0]
   1d24a:	1af8      	subs	r0, r7, r3
    while (i--) {
      if (len++ >= buflen) {
        return NULL;
      }
      *rp++ = inv[i];
   1d24c:	0007      	movs	r7, r0
   1d24e:	1c59      	adds	r1, r3, #1
   1d250:	18c2      	adds	r2, r0, r3
   1d252:	9100      	str	r1, [sp, #0]
    while (i--) {
   1d254:	2cff      	cmp	r4, #255	; 0xff
   1d256:	d10f      	bne.n	1d278 <ip4addr_ntoa_r+0x74>
    }
    if (len++ >= buflen) {
   1d258:	9902      	ldr	r1, [sp, #8]
   1d25a:	428b      	cmp	r3, r1
   1d25c:	da17      	bge.n	1d28e <ip4addr_ntoa_r+0x8a>
      return NULL;
    }
    *rp++ = '.';
   1d25e:	232e      	movs	r3, #46	; 0x2e
   1d260:	3601      	adds	r6, #1
   1d262:	1c57      	adds	r7, r2, #1
   1d264:	7013      	strb	r3, [r2, #0]
  for (n = 0; n < 4; n++) {
   1d266:	2e04      	cmp	r6, #4
   1d268:	d1d5      	bne.n	1d216 <ip4addr_ntoa_r+0x12>
    ap++;
  }
  *--rp = 0;
   1d26a:	2300      	movs	r3, #0
  return buf;
   1d26c:	9801      	ldr	r0, [sp, #4]
  *--rp = 0;
   1d26e:	7013      	strb	r3, [r2, #0]
}
   1d270:	b007      	add	sp, #28
   1d272:	bdf0      	pop	{r4, r5, r6, r7, pc}
      inv[i++] = '0' + (char) rem;
   1d274:	001c      	movs	r4, r3
   1d276:	e7d1      	b.n	1d21c <ip4addr_ntoa_r+0x18>
      if (len++ >= buflen) {
   1d278:	9d02      	ldr	r5, [sp, #8]
   1d27a:	1e62      	subs	r2, r4, #1
   1d27c:	b2d2      	uxtb	r2, r2
   1d27e:	42ab      	cmp	r3, r5
   1d280:	da05      	bge.n	1d28e <ip4addr_ntoa_r+0x8a>
      *rp++ = inv[i];
   1d282:	ad04      	add	r5, sp, #16
   1d284:	5d2c      	ldrb	r4, [r5, r4]
   1d286:	54fc      	strb	r4, [r7, r3]
   1d288:	0014      	movs	r4, r2
   1d28a:	000b      	movs	r3, r1
   1d28c:	e7df      	b.n	1d24e <ip4addr_ntoa_r+0x4a>
        return NULL;
   1d28e:	2000      	movs	r0, #0
   1d290:	e7ee      	b.n	1d270 <ip4addr_ntoa_r+0x6c>
	...

0001d294 <ip4addr_ntoa>:
{
   1d294:	b510      	push	{r4, lr}
  return ip4addr_ntoa_r(addr, str, IP4ADDR_STRLEN_MAX);
   1d296:	2210      	movs	r2, #16
   1d298:	4901      	ldr	r1, [pc, #4]	; (1d2a0 <ip4addr_ntoa+0xc>)
   1d29a:	f7ff ffb3 	bl	1d204 <ip4addr_ntoa_r>
}
   1d29e:	bd10      	pop	{r4, pc}
   1d2a0:	01002c90 	.word	0x01002c90

0001d2a4 <ip4addr_aton>:
 * @return 1 if cp could be converted to addr, 0 on failure
 */

int
ip4addr_aton(const char *cp, ip4_addr_t *addr)
{
   1d2a4:	b5f0      	push	{r4, r5, r6, r7, lr}
   1d2a6:	0003      	movs	r3, r0
  uint8 base;
  char c;
  uint32 parts[4];
  uint32 *pp = parts;

  c = *cp;
   1d2a8:	7802      	ldrb	r2, [r0, #0]
    }
    val = 0;
    base = 10;
    if (c == '0') {
      c = *++cp;
      if (c == 'x' || c == 'X') {
   1d2aa:	2020      	movs	r0, #32
  c = *cp;
   1d2ac:	2500      	movs	r5, #0
      if (c == 'x' || c == 'X') {
   1d2ae:	4684      	mov	ip, r0
{
   1d2b0:	b089      	sub	sp, #36	; 0x24
   1d2b2:	9101      	str	r1, [sp, #4]
   1d2b4:	a804      	add	r0, sp, #16
   1d2b6:	1944      	adds	r4, r0, r5
   1d2b8:	9403      	str	r4, [sp, #12]
    if (!isdigit(c)) {
   1d2ba:	0014      	movs	r4, r2
   1d2bc:	3c30      	subs	r4, #48	; 0x30
   1d2be:	2c09      	cmp	r4, #9
   1d2c0:	d900      	bls.n	1d2c4 <ip4addr_aton+0x20>
   1d2c2:	e07f      	b.n	1d3c4 <ip4addr_aton+0x120>
    base = 10;
   1d2c4:	270a      	movs	r7, #10
    if (c == '0') {
   1d2c6:	2a30      	cmp	r2, #48	; 0x30
   1d2c8:	d107      	bne.n	1d2da <ip4addr_aton+0x36>
      c = *++cp;
   1d2ca:	785a      	ldrb	r2, [r3, #1]
      if (c == 'x' || c == 'X') {
   1d2cc:	4666      	mov	r6, ip
   1d2ce:	0014      	movs	r4, r2
   1d2d0:	43b4      	bics	r4, r6
   1d2d2:	2c58      	cmp	r4, #88	; 0x58
   1d2d4:	d00d      	beq.n	1d2f2 <ip4addr_aton+0x4e>
      c = *++cp;
   1d2d6:	3301      	adds	r3, #1
        base = 16;
        c = *++cp;
      } else {
        base = 8;
   1d2d8:	3f02      	subs	r7, #2
   1d2da:	001c      	movs	r4, r3
   1d2dc:	2300      	movs	r3, #0
      }
    }
    for (;;) {
      if (isdigit(c)) {
   1d2de:	0016      	movs	r6, r2
   1d2e0:	3e30      	subs	r6, #48	; 0x30
   1d2e2:	2e09      	cmp	r6, #9
   1d2e4:	d809      	bhi.n	1d2fa <ip4addr_aton+0x56>
        val = (val * base) + (int) (c - '0'); //lint !e737
   1d2e6:	437b      	muls	r3, r7
   1d2e8:	189b      	adds	r3, r3, r2
   1d2ea:	3b30      	subs	r3, #48	; 0x30
        c = *++cp;
      } else if (base == 16 && isxdigit(c)) {
        val = (val << 4) | (int) (c + 10 - (islower(c) ? 'a' : 'A')); //lint !e737
        c = *++cp;
   1d2ec:	7862      	ldrb	r2, [r4, #1]
   1d2ee:	3401      	adds	r4, #1
   1d2f0:	e7f5      	b.n	1d2de <ip4addr_aton+0x3a>
        c = *++cp;
   1d2f2:	789a      	ldrb	r2, [r3, #2]
        base = 16;
   1d2f4:	2710      	movs	r7, #16
        c = *++cp;
   1d2f6:	3302      	adds	r3, #2
   1d2f8:	e7ef      	b.n	1d2da <ip4addr_aton+0x36>
      } else if (base == 16 && isxdigit(c)) {
   1d2fa:	2f10      	cmp	r7, #16
   1d2fc:	d114      	bne.n	1d328 <ip4addr_aton+0x84>
   1d2fe:	0016      	movs	r6, r2
   1d300:	3e61      	subs	r6, #97	; 0x61
   1d302:	b2f6      	uxtb	r6, r6
   1d304:	9602      	str	r6, [sp, #8]
   1d306:	4661      	mov	r1, ip
   1d308:	0016      	movs	r6, r2
   1d30a:	438e      	bics	r6, r1
   1d30c:	3e41      	subs	r6, #65	; 0x41
   1d30e:	b2f6      	uxtb	r6, r6
   1d310:	2e05      	cmp	r6, #5
   1d312:	d809      	bhi.n	1d328 <ip4addr_aton+0x84>
        val = (val << 4) | (int) (c + 10 - (islower(c) ? 'a' : 'A')); //lint !e737
   1d314:	9902      	ldr	r1, [sp, #8]
   1d316:	011b      	lsls	r3, r3, #4
   1d318:	320a      	adds	r2, #10
   1d31a:	2661      	movs	r6, #97	; 0x61
   1d31c:	2919      	cmp	r1, #25
   1d31e:	d900      	bls.n	1d322 <ip4addr_aton+0x7e>
   1d320:	3e20      	subs	r6, #32
   1d322:	1b92      	subs	r2, r2, r6
   1d324:	4313      	orrs	r3, r2
   1d326:	e7e1      	b.n	1d2ec <ip4addr_aton+0x48>
      } else {
        break;
      }
    }
    if (c == '.') {
   1d328:	2a2e      	cmp	r2, #46	; 0x2e
   1d32a:	d106      	bne.n	1d33a <ip4addr_aton+0x96>
       * Internet format:
       *  a.b.c.d
       *  a.b.c   (with c treated as 16 bits)
       *  a.b (with b treated as 24 bits)
       */
      if (pp >= parts + 3) {
   1d32c:	2d0c      	cmp	r5, #12
   1d32e:	d049      	beq.n	1d3c4 <ip4addr_aton+0x120>
        return 0;
      }
      *pp++ = val;
   1d330:	5143      	str	r3, [r0, r5]
      c = *++cp;
   1d332:	7862      	ldrb	r2, [r4, #1]
   1d334:	1c63      	adds	r3, r4, #1
   1d336:	3504      	adds	r5, #4
    if (!isdigit(c)) {
   1d338:	e7bc      	b.n	1d2b4 <ip4addr_aton+0x10>
    }
  }
  /*
   * Check for trailing characters.
   */
  if (c != '\0' && !isspace(c)) {
   1d33a:	2420      	movs	r4, #32
   1d33c:	0015      	movs	r5, r2
   1d33e:	43a5      	bics	r5, r4
   1d340:	d003      	beq.n	1d34a <ip4addr_aton+0xa6>
   1d342:	3a09      	subs	r2, #9
      return 0;
   1d344:	2400      	movs	r4, #0
  if (c != '\0' && !isspace(c)) {
   1d346:	2a04      	cmp	r2, #4
   1d348:	d81a      	bhi.n	1d380 <ip4addr_aton+0xdc>
  }
  /*
   * Concoct the address according to
   * the number of parts specified.
   */
  switch ((pp - parts) + 1) {
   1d34a:	9a03      	ldr	r2, [sp, #12]
   1d34c:	1a14      	subs	r4, r2, r0
   1d34e:	10a4      	asrs	r4, r4, #2
   1d350:	3401      	adds	r4, #1
   1d352:	2c04      	cmp	r4, #4
   1d354:	d80e      	bhi.n	1d374 <ip4addr_aton+0xd0>
   1d356:	0020      	movs	r0, r4
   1d358:	f7e3 f824 	bl	3a4 <__gnu_thumb1_case_uqi>
   1d35c:	15030c12 	.word	0x15030c12
   1d360:	23          	.byte	0x23
   1d361:	00          	.byte	0x00

  case 1:             /* a -- 32 bits */
    break;

  case 2:             /* a.b -- 8.24 bits */
    if (val > 0xffffffUL) {
   1d362:	4a19      	ldr	r2, [pc, #100]	; (1d3c8 <ip4addr_aton+0x124>)
      return 0;
   1d364:	2400      	movs	r4, #0
    if (val > 0xffffffUL) {
   1d366:	4293      	cmp	r3, r2
   1d368:	d80a      	bhi.n	1d380 <ip4addr_aton+0xdc>
      return 0;
    }
    if (parts[0] > 0xff) {
   1d36a:	9a04      	ldr	r2, [sp, #16]
   1d36c:	2aff      	cmp	r2, #255	; 0xff
   1d36e:	d807      	bhi.n	1d380 <ip4addr_aton+0xdc>
      return 0;
    }
    val |= parts[0] << 24;
   1d370:	0612      	lsls	r2, r2, #24
      return 0;
    }
    if ((parts[0] > 0xff) || (parts[1] > 0xff) || (parts[2] > 0xff)) {
      return 0;
    }
    val |= (parts[0] << 24) | (parts[1] << 16) | (parts[2] << 8);
   1d372:	4313      	orrs	r3, r2
    break;
  default:
    // LWIP_ASSERT("unhandled", 0);
    break;
  }
  if (addr) {
   1d374:	9a01      	ldr	r2, [sp, #4]
    ip4_addr_set_u32(addr, htonl(val));
  }
  return 1;
   1d376:	2401      	movs	r4, #1
  if (addr) {
   1d378:	2a00      	cmp	r2, #0
   1d37a:	d001      	beq.n	1d380 <ip4addr_aton+0xdc>
   1d37c:	ba1b      	rev	r3, r3
    ip4_addr_set_u32(addr, htonl(val));
   1d37e:	6013      	str	r3, [r2, #0]
}
   1d380:	0020      	movs	r0, r4
   1d382:	b009      	add	sp, #36	; 0x24
   1d384:	bdf0      	pop	{r4, r5, r6, r7, pc}
    if (val > 0xffff) {
   1d386:	4a11      	ldr	r2, [pc, #68]	; (1d3cc <ip4addr_aton+0x128>)
      return 0;
   1d388:	2400      	movs	r4, #0
    if (val > 0xffff) {
   1d38a:	4293      	cmp	r3, r2
   1d38c:	d8f8      	bhi.n	1d380 <ip4addr_aton+0xdc>
    if ((parts[0] > 0xff) || (parts[1] > 0xff)) {
   1d38e:	9a04      	ldr	r2, [sp, #16]
   1d390:	2aff      	cmp	r2, #255	; 0xff
   1d392:	d8f5      	bhi.n	1d380 <ip4addr_aton+0xdc>
   1d394:	9805      	ldr	r0, [sp, #20]
   1d396:	28ff      	cmp	r0, #255	; 0xff
   1d398:	d8f2      	bhi.n	1d380 <ip4addr_aton+0xdc>
    val |= (parts[0] << 24) | (parts[1] << 16);
   1d39a:	0612      	lsls	r2, r2, #24
   1d39c:	0400      	lsls	r0, r0, #16
    val |= (parts[0] << 24) | (parts[1] << 16) | (parts[2] << 8);
   1d39e:	4302      	orrs	r2, r0
   1d3a0:	e7e7      	b.n	1d372 <ip4addr_aton+0xce>
      return 0;
   1d3a2:	2400      	movs	r4, #0
    if (val > 0xff) {
   1d3a4:	2bff      	cmp	r3, #255	; 0xff
   1d3a6:	d8eb      	bhi.n	1d380 <ip4addr_aton+0xdc>
    if ((parts[0] > 0xff) || (parts[1] > 0xff) || (parts[2] > 0xff)) {
   1d3a8:	9a04      	ldr	r2, [sp, #16]
   1d3aa:	2aff      	cmp	r2, #255	; 0xff
   1d3ac:	d8e8      	bhi.n	1d380 <ip4addr_aton+0xdc>
   1d3ae:	9d05      	ldr	r5, [sp, #20]
   1d3b0:	2dff      	cmp	r5, #255	; 0xff
   1d3b2:	d8e5      	bhi.n	1d380 <ip4addr_aton+0xdc>
   1d3b4:	9806      	ldr	r0, [sp, #24]
   1d3b6:	28ff      	cmp	r0, #255	; 0xff
   1d3b8:	d8e2      	bhi.n	1d380 <ip4addr_aton+0xdc>
    val |= (parts[0] << 24) | (parts[1] << 16) | (parts[2] << 8);
   1d3ba:	0612      	lsls	r2, r2, #24
   1d3bc:	042d      	lsls	r5, r5, #16
   1d3be:	432a      	orrs	r2, r5
   1d3c0:	0200      	lsls	r0, r0, #8
   1d3c2:	e7ec      	b.n	1d39e <ip4addr_aton+0xfa>
      return 0;
   1d3c4:	2400      	movs	r4, #0
   1d3c6:	e7db      	b.n	1d380 <ip4addr_aton+0xdc>
   1d3c8:	00ffffff 	.word	0x00ffffff
   1d3cc:	0000ffff 	.word	0x0000ffff

0001d3d0 <ip6addr_ntoa_r>:
 * @return either pointer to buf which now holds the ASCII
 *         representation of addr or NULL if buf was too small
 */
char *
ip6addr_ntoa_r(const ip6_addr_t *addr, char *buf, int buflen)
{
   1d3d0:	b5f0      	push	{r4, r5, r6, r7, lr}
  uint32 current_block_index, current_block_value, next_block_value;
  int32 i;
  uint8 zero_flag, empty_block_flag;

  i = 0;
  empty_block_flag = 0; /* used to indicate a zero chain for "::' */
   1d3d2:	2500      	movs	r5, #0
{
   1d3d4:	b085      	sub	sp, #20
   1d3d6:	9003      	str	r0, [sp, #12]
  i = 0;
   1d3d8:	002e      	movs	r6, r5

  for (current_block_index = 0; current_block_index < 8; current_block_index++) {
   1d3da:	0028      	movs	r0, r5
    /* get the current 16-bit block */
    current_block_value = htonl(addr->addr[current_block_index >> 1]);
    if ((current_block_index & 0x1) == 0) {
   1d3dc:	2701      	movs	r7, #1
    current_block_value = htonl(addr->addr[current_block_index >> 1]);
   1d3de:	0843      	lsrs	r3, r0, #1
   1d3e0:	9c03      	ldr	r4, [sp, #12]
   1d3e2:	009b      	lsls	r3, r3, #2
   1d3e4:	591c      	ldr	r4, [r3, r4]
    if ((current_block_index & 0x1) == 0) {
   1d3e6:	4007      	ands	r7, r0
   1d3e8:	ba24      	rev	r4, r4
   1d3ea:	46bc      	mov	ip, r7
   1d3ec:	2f00      	cmp	r7, #0
   1d3ee:	d100      	bne.n	1d3f2 <ip6addr_ntoa_r+0x22>
      current_block_value = current_block_value >> 16;
   1d3f0:	0c24      	lsrs	r4, r4, #16
    }
    current_block_value &= 0xffff;
   1d3f2:	b2a3      	uxth	r3, r4
   1d3f4:	9301      	str	r3, [sp, #4]

    /* Check for empty block. */
    if (current_block_value == 0) {
   1d3f6:	2b00      	cmp	r3, #0
   1d3f8:	d000      	beq.n	1d3fc <ip6addr_ntoa_r+0x2c>
   1d3fa:	e07d      	b.n	1d4f8 <ip6addr_ntoa_r+0x128>
      if (current_block_index == 7) {
   1d3fc:	2807      	cmp	r0, #7
   1d3fe:	d108      	bne.n	1d412 <ip6addr_ntoa_r+0x42>
        /* special case, we must render a ':' for the last block. */
        buf[i++] = ':';
   1d400:	333a      	adds	r3, #58	; 0x3a
   1d402:	558b      	strb	r3, [r1, r6]
   1d404:	3601      	adds	r6, #1
        if (i >= buflen) {
   1d406:	42b2      	cmp	r2, r6
   1d408:	dc1c      	bgt.n	1d444 <ip6addr_ntoa_r+0x74>
          return NULL;
   1d40a:	2100      	movs	r1, #0
  }

  buf[i] = 0;

  return buf;
}
   1d40c:	0008      	movs	r0, r1
   1d40e:	b005      	add	sp, #20
   1d410:	bdf0      	pop	{r4, r5, r6, r7, pc}
      if (empty_block_flag == 0) {
   1d412:	2d00      	cmp	r5, #0
   1d414:	d119      	bne.n	1d44a <ip6addr_ntoa_r+0x7a>
        next_block_value = htonl(addr->addr[(current_block_index + 1) >> 1]);
   1d416:	1c43      	adds	r3, r0, #1
   1d418:	9f03      	ldr	r7, [sp, #12]
   1d41a:	085b      	lsrs	r3, r3, #1
   1d41c:	009b      	lsls	r3, r3, #2
   1d41e:	59db      	ldr	r3, [r3, r7]
        if ((current_block_index & 0x1) == 0x01) {
   1d420:	4667      	mov	r7, ip
   1d422:	ba1b      	rev	r3, r3
   1d424:	2f00      	cmp	r7, #0
   1d426:	d000      	beq.n	1d42a <ip6addr_ntoa_r+0x5a>
            next_block_value = next_block_value >> 16;
   1d428:	0c1b      	lsrs	r3, r3, #16
        next_block_value &= 0xffff;
   1d42a:	b29b      	uxth	r3, r3
        if (next_block_value == 0) {
   1d42c:	2b00      	cmp	r3, #0
   1d42e:	d10e      	bne.n	1d44e <ip6addr_ntoa_r+0x7e>
          buf[i++] = ':';
   1d430:	243a      	movs	r4, #58	; 0x3a
   1d432:	1c73      	adds	r3, r6, #1
   1d434:	558c      	strb	r4, [r1, r6]
          if (i >= buflen) {
   1d436:	429a      	cmp	r2, r3
   1d438:	dde7      	ble.n	1d40a <ip6addr_ntoa_r+0x3a>
   1d43a:	001e      	movs	r6, r3
          empty_block_flag = 1;
   1d43c:	2501      	movs	r5, #1
  for (current_block_index = 0; current_block_index < 8; current_block_index++) {
   1d43e:	3001      	adds	r0, #1
   1d440:	2808      	cmp	r0, #8
   1d442:	d1cb      	bne.n	1d3dc <ip6addr_ntoa_r+0xc>
  buf[i] = 0;
   1d444:	2300      	movs	r3, #0
   1d446:	558b      	strb	r3, [r1, r6]
  return buf;
   1d448:	e7e0      	b.n	1d40c <ip6addr_ntoa_r+0x3c>
      } else if (empty_block_flag == 1) {
   1d44a:	2d01      	cmp	r5, #1
   1d44c:	d0f7      	beq.n	1d43e <ip6addr_ntoa_r+0x6e>
   1d44e:	198f      	adds	r7, r1, r6
   1d450:	1c73      	adds	r3, r6, #1
    if (current_block_index > 0) {
   1d452:	2800      	cmp	r0, #0
   1d454:	d054      	beq.n	1d500 <ip6addr_ntoa_r+0x130>
      buf[i++] = ':';
   1d456:	263a      	movs	r6, #58	; 0x3a
   1d458:	703e      	strb	r6, [r7, #0]
      if (i >= buflen) {
   1d45a:	429a      	cmp	r2, r3
   1d45c:	ddd5      	ble.n	1d40a <ip6addr_ntoa_r+0x3a>
    if ((current_block_value & 0xf000) == 0) {
   1d45e:	26f0      	movs	r6, #240	; 0xf0
   1d460:	0236      	lsls	r6, r6, #8
   1d462:	4234      	tst	r4, r6
   1d464:	d04e      	beq.n	1d504 <ip6addr_ntoa_r+0x134>
      buf[i++] = xchar(((current_block_value & 0xf000) >> 12));
   1d466:	9e01      	ldr	r6, [sp, #4]
   1d468:	0b36      	lsrs	r6, r6, #12
   1d46a:	b2f7      	uxtb	r7, r6
   1d46c:	46b4      	mov	ip, r6
   1d46e:	003e      	movs	r6, r7
   1d470:	3637      	adds	r6, #55	; 0x37
   1d472:	9602      	str	r6, [sp, #8]
   1d474:	4666      	mov	r6, ip
   1d476:	2e09      	cmp	r6, #9
   1d478:	d802      	bhi.n	1d480 <ip6addr_ntoa_r+0xb0>
   1d47a:	003e      	movs	r6, r7
   1d47c:	3630      	adds	r6, #48	; 0x30
   1d47e:	9602      	str	r6, [sp, #8]
   1d480:	466e      	mov	r6, sp
   1d482:	7a36      	ldrb	r6, [r6, #8]
   1d484:	1c5f      	adds	r7, r3, #1
   1d486:	54ce      	strb	r6, [r1, r3]
      if (i >= buflen) {
   1d488:	42ba      	cmp	r2, r7
   1d48a:	ddbe      	ble.n	1d40a <ip6addr_ntoa_r+0x3a>
   1d48c:	003b      	movs	r3, r7
      zero_flag = 0;
   1d48e:	2600      	movs	r6, #0
    if (((current_block_value & 0xf00) == 0) && (zero_flag)) {
   1d490:	27f0      	movs	r7, #240	; 0xf0
   1d492:	013f      	lsls	r7, r7, #4
   1d494:	423c      	tst	r4, r7
   1d496:	d101      	bne.n	1d49c <ip6addr_ntoa_r+0xcc>
   1d498:	2e00      	cmp	r6, #0
   1d49a:	d10d      	bne.n	1d4b8 <ip6addr_ntoa_r+0xe8>
   1d49c:	9e01      	ldr	r6, [sp, #4]
   1d49e:	0536      	lsls	r6, r6, #20
   1d4a0:	0f36      	lsrs	r6, r6, #28
   1d4a2:	b2f7      	uxtb	r7, r6
      buf[i++] = xchar(((current_block_value & 0xf00) >> 8));
   1d4a4:	3737      	adds	r7, #55	; 0x37
   1d4a6:	2e09      	cmp	r6, #9
   1d4a8:	d800      	bhi.n	1d4ac <ip6addr_ntoa_r+0xdc>
   1d4aa:	3f07      	subs	r7, #7
   1d4ac:	1c5e      	adds	r6, r3, #1
   1d4ae:	54cf      	strb	r7, [r1, r3]
      if (i >= buflen) {
   1d4b0:	42b2      	cmp	r2, r6
   1d4b2:	ddaa      	ble.n	1d40a <ip6addr_ntoa_r+0x3a>
   1d4b4:	0033      	movs	r3, r6
      zero_flag = 0;
   1d4b6:	2600      	movs	r6, #0
    if (((current_block_value & 0xf0) == 0) && (zero_flag)) {
   1d4b8:	27f0      	movs	r7, #240	; 0xf0
   1d4ba:	423c      	tst	r4, r7
   1d4bc:	d101      	bne.n	1d4c2 <ip6addr_ntoa_r+0xf2>
   1d4be:	2e00      	cmp	r6, #0
   1d4c0:	d10c      	bne.n	1d4dc <ip6addr_ntoa_r+0x10c>
   1d4c2:	9e01      	ldr	r6, [sp, #4]
   1d4c4:	0636      	lsls	r6, r6, #24
   1d4c6:	0f36      	lsrs	r6, r6, #28
   1d4c8:	b2f7      	uxtb	r7, r6
      buf[i++] = xchar(((current_block_value & 0xf0) >> 4));
   1d4ca:	3737      	adds	r7, #55	; 0x37
   1d4cc:	2e09      	cmp	r6, #9
   1d4ce:	d800      	bhi.n	1d4d2 <ip6addr_ntoa_r+0x102>
   1d4d0:	3f07      	subs	r7, #7
   1d4d2:	1c5e      	adds	r6, r3, #1
   1d4d4:	54cf      	strb	r7, [r1, r3]
      if (i >= buflen) {
   1d4d6:	42b2      	cmp	r2, r6
   1d4d8:	dd97      	ble.n	1d40a <ip6addr_ntoa_r+0x3a>
   1d4da:	0033      	movs	r3, r6
   1d4dc:	260f      	movs	r6, #15
   1d4de:	9f01      	ldr	r7, [sp, #4]
   1d4e0:	4037      	ands	r7, r6
    buf[i++] = xchar((current_block_value & 0xf));
   1d4e2:	4026      	ands	r6, r4
   1d4e4:	003c      	movs	r4, r7
   1d4e6:	3437      	adds	r4, #55	; 0x37
   1d4e8:	2e09      	cmp	r6, #9
   1d4ea:	d800      	bhi.n	1d4ee <ip6addr_ntoa_r+0x11e>
   1d4ec:	3c07      	subs	r4, #7
   1d4ee:	1c5e      	adds	r6, r3, #1
   1d4f0:	54cc      	strb	r4, [r1, r3]
    if (i >= buflen) {
   1d4f2:	42b2      	cmp	r2, r6
   1d4f4:	dca3      	bgt.n	1d43e <ip6addr_ntoa_r+0x6e>
   1d4f6:	e788      	b.n	1d40a <ip6addr_ntoa_r+0x3a>
    } else if (empty_block_flag == 1) {
   1d4f8:	2d01      	cmp	r5, #1
   1d4fa:	d1a8      	bne.n	1d44e <ip6addr_ntoa_r+0x7e>
      empty_block_flag = 2;
   1d4fc:	3501      	adds	r5, #1
   1d4fe:	e7a6      	b.n	1d44e <ip6addr_ntoa_r+0x7e>
   1d500:	0033      	movs	r3, r6
   1d502:	e7ac      	b.n	1d45e <ip6addr_ntoa_r+0x8e>
      zero_flag = 1;
   1d504:	2601      	movs	r6, #1
   1d506:	e7c3      	b.n	1d490 <ip6addr_ntoa_r+0xc0>

0001d508 <ip6addr_ntoa>:
{
   1d508:	b510      	push	{r4, lr}
  return ip6addr_ntoa_r(addr, str, 40);
   1d50a:	2228      	movs	r2, #40	; 0x28
   1d50c:	4901      	ldr	r1, [pc, #4]	; (1d514 <ip6addr_ntoa+0xc>)
   1d50e:	f7ff ff5f 	bl	1d3d0 <ip6addr_ntoa_r>
}
   1d512:	bd10      	pop	{r4, pc}
   1d514:	01002ca0 	.word	0x01002ca0

0001d518 <ip6addr_aton>:
  uint32 addr_index, zero_blocks, current_block_index, current_block_value;
  const char * s;

  /* Count the number of colons, to count the number of blocks in a "::" sequence
     zero_blocks may be 1 even if there are no :: sequences */
  zero_blocks = 8;
   1d518:	2308      	movs	r3, #8
{
   1d51a:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
  for (s = cp; *s != 0; s++) {
   1d51c:	0002      	movs	r2, r0
    if (*s == ':') {
      zero_blocks--;
    } else if (!isxdigit(*s)) {
   1d51e:	2420      	movs	r4, #32
  zero_blocks = 8;
   1d520:	9300      	str	r3, [sp, #0]
  for (s = cp; *s != 0; s++) {
   1d522:	7813      	ldrb	r3, [r2, #0]
   1d524:	2b00      	cmp	r3, #0
   1d526:	d102      	bne.n	1d52e <ip6addr_aton+0x16>
   1d528:	001a      	movs	r2, r3
   1d52a:	001c      	movs	r4, r3
   1d52c:	e031      	b.n	1d592 <ip6addr_aton+0x7a>
    if (*s == ':') {
   1d52e:	2b3a      	cmp	r3, #58	; 0x3a
   1d530:	d104      	bne.n	1d53c <ip6addr_aton+0x24>
      zero_blocks--;
   1d532:	9b00      	ldr	r3, [sp, #0]
   1d534:	3b01      	subs	r3, #1
   1d536:	9300      	str	r3, [sp, #0]
  for (s = cp; *s != 0; s++) {
   1d538:	3201      	adds	r2, #1
   1d53a:	e7f2      	b.n	1d522 <ip6addr_aton+0xa>
    } else if (!isxdigit(*s)) {
   1d53c:	001d      	movs	r5, r3
   1d53e:	3d30      	subs	r5, #48	; 0x30
   1d540:	2d09      	cmp	r5, #9
   1d542:	d9f9      	bls.n	1d538 <ip6addr_aton+0x20>
   1d544:	43a3      	bics	r3, r4
   1d546:	3b41      	subs	r3, #65	; 0x41
   1d548:	2b05      	cmp	r3, #5
   1d54a:	d9f5      	bls.n	1d538 <ip6addr_aton+0x20>
   1d54c:	2300      	movs	r3, #0
   1d54e:	e7eb      	b.n	1d528 <ip6addr_aton+0x10>
  /* parse each block */
  addr_index = 0;
  current_block_index = 0;
  current_block_value = 0;
  for (s = cp; *s != 0; s++) {
    if (*s == ':') {
   1d550:	2d3a      	cmp	r5, #58	; 0x3a
   1d552:	d145      	bne.n	1d5e0 <ip6addr_aton+0xc8>
      if (addr) {
   1d554:	2900      	cmp	r1, #0
   1d556:	d008      	beq.n	1d56a <ip6addr_aton+0x52>
        if (current_block_index & 0x1) {
   1d558:	2701      	movs	r7, #1
   1d55a:	00a5      	lsls	r5, r4, #2
   1d55c:	423a      	tst	r2, r7
   1d55e:	d009      	beq.n	1d574 <ip6addr_aton+0x5c>
   1d560:	194d      	adds	r5, r1, r5
          addr->addr[addr_index++] |= current_block_value;
   1d562:	682f      	ldr	r7, [r5, #0]
   1d564:	3401      	adds	r4, #1
   1d566:	433b      	orrs	r3, r7
   1d568:	602b      	str	r3, [r5, #0]
        }
        else {
          addr->addr[addr_index] = current_block_value << 16;
        }
      }
      current_block_index++;
   1d56a:	3201      	adds	r2, #1
      current_block_value = 0;
      if (current_block_index > 7) {
   1d56c:	2a07      	cmp	r2, #7
   1d56e:	d904      	bls.n	1d57a <ip6addr_aton+0x62>
        /* address too long! */
        return 0;
   1d570:	2000      	movs	r0, #0
  if (current_block_index != 7) {
    return 0;
  }

  return 1;
}
   1d572:	bdfe      	pop	{r1, r2, r3, r4, r5, r6, r7, pc}
          addr->addr[addr_index] = current_block_value << 16;
   1d574:	041b      	lsls	r3, r3, #16
   1d576:	514b      	str	r3, [r1, r5]
   1d578:	e7f7      	b.n	1d56a <ip6addr_aton+0x52>
      if (s[1] == ':') {
   1d57a:	7845      	ldrb	r5, [r0, #1]
      current_block_value = 0;
   1d57c:	2300      	movs	r3, #0
      if (s[1] == ':') {
   1d57e:	2d3a      	cmp	r5, #58	; 0x3a
   1d580:	d106      	bne.n	1d590 <ip6addr_aton+0x78>
        if (s[2] == ':') {
   1d582:	7883      	ldrb	r3, [r0, #2]
   1d584:	2b3a      	cmp	r3, #58	; 0x3a
   1d586:	d0f3      	beq.n	1d570 <ip6addr_aton+0x58>
        while (zero_blocks > 0) {
   1d588:	9b00      	ldr	r3, [sp, #0]
   1d58a:	2b00      	cmp	r3, #0
   1d58c:	d118      	bne.n	1d5c0 <ip6addr_aton+0xa8>
        s++;
   1d58e:	3001      	adds	r0, #1
  for (s = cp; *s != 0; s++) {
   1d590:	3001      	adds	r0, #1
   1d592:	7805      	ldrb	r5, [r0, #0]
   1d594:	2d00      	cmp	r5, #0
   1d596:	d1db      	bne.n	1d550 <ip6addr_aton+0x38>
  if (addr) { //lint !e850 ignore 2 modified
   1d598:	2900      	cmp	r1, #0
   1d59a:	d00d      	beq.n	1d5b8 <ip6addr_aton+0xa0>
   1d59c:	00a4      	lsls	r4, r4, #2
    if (current_block_index & 0x1) {
   1d59e:	07d0      	lsls	r0, r2, #31
   1d5a0:	d53e      	bpl.n	1d620 <ip6addr_aton+0x108>
   1d5a2:	190c      	adds	r4, r1, r4
      addr->addr[addr_index++] |= current_block_value;
   1d5a4:	6820      	ldr	r0, [r4, #0]
   1d5a6:	4303      	orrs	r3, r0
   1d5a8:	6023      	str	r3, [r4, #0]
   1d5aa:	0008      	movs	r0, r1
   1d5ac:	3010      	adds	r0, #16
   1d5ae:	680b      	ldr	r3, [r1, #0]
   1d5b0:	ba1b      	rev	r3, r3
      addr->addr[addr_index] = htonl(addr->addr[addr_index]);
   1d5b2:	c108      	stmia	r1!, {r3}
    for (addr_index = 0; addr_index < 4; addr_index++) {
   1d5b4:	4281      	cmp	r1, r0
   1d5b6:	d1fa      	bne.n	1d5ae <ip6addr_aton+0x96>
  if (current_block_index != 7) {
   1d5b8:	3a07      	subs	r2, #7
        return 0;
   1d5ba:	4250      	negs	r0, r2
   1d5bc:	4150      	adcs	r0, r2
   1d5be:	e7d8      	b.n	1d572 <ip6addr_aton+0x5a>
          zero_blocks--;
   1d5c0:	9b00      	ldr	r3, [sp, #0]
   1d5c2:	3b01      	subs	r3, #1
   1d5c4:	9300      	str	r3, [sp, #0]
          if (current_block_index & 0x1) {
   1d5c6:	2301      	movs	r3, #1
   1d5c8:	4013      	ands	r3, r2
   1d5ca:	d004      	beq.n	1d5d6 <ip6addr_aton+0xbe>
            addr_index++;
   1d5cc:	3401      	adds	r4, #1
          current_block_index++;
   1d5ce:	3201      	adds	r2, #1
          if (current_block_index > 7) {
   1d5d0:	2a08      	cmp	r2, #8
   1d5d2:	d1d9      	bne.n	1d588 <ip6addr_aton+0x70>
   1d5d4:	e7cc      	b.n	1d570 <ip6addr_aton+0x58>
            if (addr) {
   1d5d6:	2900      	cmp	r1, #0
   1d5d8:	d0f9      	beq.n	1d5ce <ip6addr_aton+0xb6>
              addr->addr[addr_index] = 0;
   1d5da:	00a5      	lsls	r5, r4, #2
   1d5dc:	506b      	str	r3, [r5, r1]
   1d5de:	e7f6      	b.n	1d5ce <ip6addr_aton+0xb6>
    } else if (isxdigit(*s)) {
   1d5e0:	002f      	movs	r7, r5
   1d5e2:	3f30      	subs	r7, #48	; 0x30
   1d5e4:	b2fe      	uxtb	r6, r7
   1d5e6:	9601      	str	r6, [sp, #4]
   1d5e8:	2e09      	cmp	r6, #9
   1d5ea:	d908      	bls.n	1d5fe <ip6addr_aton+0xe6>
   1d5ec:	2620      	movs	r6, #32
   1d5ee:	002f      	movs	r7, r5
   1d5f0:	43b7      	bics	r7, r6
   1d5f2:	46bc      	mov	ip, r7
   1d5f4:	3e61      	subs	r6, #97	; 0x61
   1d5f6:	44b4      	add	ip, r6
   1d5f8:	4666      	mov	r6, ip
   1d5fa:	2e05      	cmp	r6, #5
   1d5fc:	d8cc      	bhi.n	1d598 <ip6addr_aton+0x80>
      current_block_value = (current_block_value << 4) +
   1d5fe:	011b      	lsls	r3, r3, #4
   1d600:	469c      	mov	ip, r3
          (isdigit(*s) ? *s - '0' :
   1d602:	9b01      	ldr	r3, [sp, #4]
   1d604:	2b09      	cmp	r3, #9
   1d606:	d803      	bhi.n	1d610 <ip6addr_aton+0xf8>
   1d608:	002b      	movs	r3, r5
   1d60a:	3b30      	subs	r3, #48	; 0x30
      current_block_value = (current_block_value << 4) +
   1d60c:	4463      	add	r3, ip
   1d60e:	e7bf      	b.n	1d590 <ip6addr_aton+0x78>
          (isdigit(*s) ? *s - '0' :
   1d610:	002f      	movs	r7, r5
          10 + (islower(*s) ? *s - 'a' : *s - 'A')); //lint !e737
   1d612:	002b      	movs	r3, r5
          (isdigit(*s) ? *s - '0' :
   1d614:	3f61      	subs	r7, #97	; 0x61
          10 + (islower(*s) ? *s - 'a' : *s - 'A')); //lint !e737
   1d616:	3b37      	subs	r3, #55	; 0x37
          (isdigit(*s) ? *s - '0' :
   1d618:	2f19      	cmp	r7, #25
   1d61a:	d8f7      	bhi.n	1d60c <ip6addr_aton+0xf4>
          10 + (islower(*s) ? *s - 'a' : *s - 'A')); //lint !e737
   1d61c:	3b20      	subs	r3, #32
   1d61e:	e7f5      	b.n	1d60c <ip6addr_aton+0xf4>
      addr->addr[addr_index] = current_block_value << 16;
   1d620:	041b      	lsls	r3, r3, #16
   1d622:	510b      	str	r3, [r1, r4]
   1d624:	e7c1      	b.n	1d5aa <ip6addr_aton+0x92>
	...

0001d628 <neul_string_convert_BCD_to_str>:
    return i;
}

/* convert packed BCD to a string */
int neul_string_convert_BCD_to_str(char *out, const uint8 *in, uint16 b_len)
{
   1d628:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
   1d62a:	0006      	movs	r6, r0
   1d62c:	000f      	movs	r7, r1
   1d62e:	9200      	str	r2, [sp, #0]
    int out_len = 0;

    if (out == NULL || in == NULL || b_len == 0)
   1d630:	2800      	cmp	r0, #0
   1d632:	d02a      	beq.n	1d68a <neul_string_convert_BCD_to_str+0x62>
   1d634:	2900      	cmp	r1, #0
   1d636:	d028      	beq.n	1d68a <neul_string_convert_BCD_to_str+0x62>
   1d638:	2a00      	cmp	r2, #0
   1d63a:	d026      	beq.n	1d68a <neul_string_convert_BCD_to_str+0x62>
    {
        return -1;
    }

    for (int i = 0; i < b_len/2; i++)
   1d63c:	000d      	movs	r5, r1
    int out_len = 0;
   1d63e:	2400      	movs	r4, #0
    for (int i = 0; i < b_len/2; i++)
   1d640:	0853      	lsrs	r3, r2, #1
   1d642:	9301      	str	r3, [sp, #4]
   1d644:	9a01      	ldr	r2, [sp, #4]
   1d646:	1930      	adds	r0, r6, r4
   1d648:	1beb      	subs	r3, r5, r7
   1d64a:	4293      	cmp	r3, r2
   1d64c:	db0d      	blt.n	1d66a <neul_string_convert_BCD_to_str+0x42>
    {
        out_len += sprintf(out + out_len, "%u", (uint8)(in[i] & 0x0F));        // lower nibble
        out_len += sprintf(out + out_len, "%u", (uint8)(in[i] & 0xF0) >> 4);   // upper nibbl
    }
    // If it is an odd number add one digit more
    if ((b_len & 0x1) != 0)
   1d64e:	9b00      	ldr	r3, [sp, #0]
   1d650:	07db      	lsls	r3, r3, #31
   1d652:	d506      	bpl.n	1d662 <neul_string_convert_BCD_to_str+0x3a>
    {
        out_len += sprintf(out + out_len, "%u", (uint8)(in[b_len/2] & 0x0F));  // lower nibble
   1d654:	230f      	movs	r3, #15
   1d656:	5cba      	ldrb	r2, [r7, r2]
   1d658:	490d      	ldr	r1, [pc, #52]	; (1d690 <neul_string_convert_BCD_to_str+0x68>)
   1d65a:	401a      	ands	r2, r3
   1d65c:	f7fe f85a 	bl	1b714 <sprintf>
   1d660:	1824      	adds	r4, r4, r0
    }
    out[out_len] = '\0'; // It is a string so add the null terminated character
   1d662:	2300      	movs	r3, #0
   1d664:	5533      	strb	r3, [r6, r4]
    return out_len;
}
   1d666:	0020      	movs	r0, r4
   1d668:	bdfe      	pop	{r1, r2, r3, r4, r5, r6, r7, pc}
        out_len += sprintf(out + out_len, "%u", (uint8)(in[i] & 0x0F));        // lower nibble
   1d66a:	230f      	movs	r3, #15
   1d66c:	782a      	ldrb	r2, [r5, #0]
   1d66e:	4908      	ldr	r1, [pc, #32]	; (1d690 <neul_string_convert_BCD_to_str+0x68>)
   1d670:	401a      	ands	r2, r3
   1d672:	f7fe f84f 	bl	1b714 <sprintf>
        out_len += sprintf(out + out_len, "%u", (uint8)(in[i] & 0xF0) >> 4);   // upper nibbl
   1d676:	782a      	ldrb	r2, [r5, #0]
        out_len += sprintf(out + out_len, "%u", (uint8)(in[i] & 0x0F));        // lower nibble
   1d678:	1824      	adds	r4, r4, r0
        out_len += sprintf(out + out_len, "%u", (uint8)(in[i] & 0xF0) >> 4);   // upper nibbl
   1d67a:	1930      	adds	r0, r6, r4
   1d67c:	0912      	lsrs	r2, r2, #4
   1d67e:	4904      	ldr	r1, [pc, #16]	; (1d690 <neul_string_convert_BCD_to_str+0x68>)
   1d680:	f7fe f848 	bl	1b714 <sprintf>
   1d684:	3501      	adds	r5, #1
   1d686:	1824      	adds	r4, r4, r0
   1d688:	e7dc      	b.n	1d644 <neul_string_convert_BCD_to_str+0x1c>
        return -1;
   1d68a:	2401      	movs	r4, #1
   1d68c:	4264      	negs	r4, r4
   1d68e:	e7ea      	b.n	1d666 <neul_string_convert_BCD_to_str+0x3e>
   1d690:	00024fe2 	.word	0x00024fe2

0001d694 <neul_string_convert_str_to_BCD>:

/* convert a string to packed BCD */
int neul_string_convert_str_to_BCD(uint8 *bin_data, const char *str_data, uint16 bin_len)
{
   1d694:	b5f0      	push	{r4, r5, r6, r7, lr}
    int out_len;

    uint8 digit1;
    uint8 digit2;

    if (bin_data == NULL || str_data == NULL || bin_len == 0)
   1d696:	2800      	cmp	r0, #0
   1d698:	d103      	bne.n	1d6a2 <neul_string_convert_str_to_BCD+0xe>
    {
        return -1;
   1d69a:	2401      	movs	r4, #1
   1d69c:	4264      	negs	r4, r4
        }

        bin_data[bin_len/2] = (uint8)ctoi(str_data[bin_len - 1]); // just digit 1, digit2 = 0
    }
    return bin_len;
}
   1d69e:	0020      	movs	r0, r4
   1d6a0:	bdf0      	pop	{r4, r5, r6, r7, pc}
    if (bin_data == NULL || str_data == NULL || bin_len == 0)
   1d6a2:	2900      	cmp	r1, #0
   1d6a4:	d0f9      	beq.n	1d69a <neul_string_convert_str_to_BCD+0x6>
   1d6a6:	2a00      	cmp	r2, #0
   1d6a8:	d0f7      	beq.n	1d69a <neul_string_convert_str_to_BCD+0x6>
    for ( out_len = 0; out_len +1 < bin_len; out_len += 2)       //lint !e440  False positive complaint about bit_len not being modified.
   1d6aa:	2500      	movs	r5, #0
   1d6ac:	0014      	movs	r4, r2
   1d6ae:	1c6b      	adds	r3, r5, #1
   1d6b0:	429a      	cmp	r2, r3
   1d6b2:	dc0b      	bgt.n	1d6cc <neul_string_convert_str_to_BCD+0x38>
    if ((bin_len & 0x1) != 0)
   1d6b4:	07d3      	lsls	r3, r2, #31
   1d6b6:	d5f2      	bpl.n	1d69e <neul_string_convert_str_to_BCD+0xa>
        if ((str_data[bin_len - 1] < '0') || (str_data[bin_len - 1] > '9'))
   1d6b8:	1889      	adds	r1, r1, r2
   1d6ba:	3901      	subs	r1, #1
   1d6bc:	780b      	ldrb	r3, [r1, #0]
   1d6be:	3b30      	subs	r3, #48	; 0x30
   1d6c0:	b2db      	uxtb	r3, r3
   1d6c2:	2b09      	cmp	r3, #9
   1d6c4:	d8e9      	bhi.n	1d69a <neul_string_convert_str_to_BCD+0x6>
        bin_data[bin_len/2] = (uint8)ctoi(str_data[bin_len - 1]); // just digit 1, digit2 = 0
   1d6c6:	0852      	lsrs	r2, r2, #1
   1d6c8:	5483      	strb	r3, [r0, r2]
   1d6ca:	e7e8      	b.n	1d69e <neul_string_convert_str_to_BCD+0xa>
        if ((str_data[out_len] < '0') || (str_data[out_len] > '9') || (str_data[out_len + 1] < '0') || (str_data[out_len + 1] > '9'))
   1d6cc:	5d4f      	ldrb	r7, [r1, r5]
   1d6ce:	3f30      	subs	r7, #48	; 0x30
   1d6d0:	b2fb      	uxtb	r3, r7
   1d6d2:	2b09      	cmp	r3, #9
   1d6d4:	d8e1      	bhi.n	1d69a <neul_string_convert_str_to_BCD+0x6>
   1d6d6:	194b      	adds	r3, r1, r5
   1d6d8:	785b      	ldrb	r3, [r3, #1]
   1d6da:	3b30      	subs	r3, #48	; 0x30
   1d6dc:	b2de      	uxtb	r6, r3
   1d6de:	2e09      	cmp	r6, #9
   1d6e0:	d8db      	bhi.n	1d69a <neul_string_convert_str_to_BCD+0x6>
        bin_data[out_len/2] = digit1 | ((digit2 << 4) & 0xFF);
   1d6e2:	011b      	lsls	r3, r3, #4
   1d6e4:	106e      	asrs	r6, r5, #1
   1d6e6:	433b      	orrs	r3, r7
   1d6e8:	5583      	strb	r3, [r0, r6]
    for ( out_len = 0; out_len +1 < bin_len; out_len += 2)       //lint !e440  False positive complaint about bit_len not being modified.
   1d6ea:	3502      	adds	r5, #2
   1d6ec:	e7df      	b.n	1d6ae <neul_string_convert_str_to_BCD+0x1a>

0001d6ee <neul_string_convert_uint8_array_to_uint32>:

/* Covert a uint8 array to uint32 value */
bool neul_string_convert_uint8_array_to_uint32(const uint8 *array, uint32 len, uint32 *result)
{
   1d6ee:	b510      	push	{r4, lr}
    uint32 i = 0;
    uint32 value = 0;

    if ((array == NULL) || (len == 0) || (len > sizeof(uint32)) || (result == NULL))
    {
        return false;
   1d6f0:	1e03      	subs	r3, r0, #0
    if ((array == NULL) || (len == 0) || (len > sizeof(uint32)) || (result == NULL))
   1d6f2:	d00e      	beq.n	1d712 <neul_string_convert_uint8_array_to_uint32+0x24>
   1d6f4:	1e4c      	subs	r4, r1, #1
        return false;
   1d6f6:	2300      	movs	r3, #0
    if ((array == NULL) || (len == 0) || (len > sizeof(uint32)) || (result == NULL))
   1d6f8:	2c03      	cmp	r4, #3
   1d6fa:	d80a      	bhi.n	1d712 <neul_string_convert_uint8_array_to_uint32+0x24>
   1d6fc:	429a      	cmp	r2, r3
   1d6fe:	d008      	beq.n	1d712 <neul_string_convert_uint8_array_to_uint32+0x24>
   1d700:	1841      	adds	r1, r0, r1
    }

    for (; i < len; i++)
    {
        value <<= 8;
        value |= array[i];
   1d702:	7804      	ldrb	r4, [r0, #0]
        value <<= 8;
   1d704:	021b      	lsls	r3, r3, #8
   1d706:	3001      	adds	r0, #1
        value |= array[i];
   1d708:	4323      	orrs	r3, r4
    for (; i < len; i++)
   1d70a:	4288      	cmp	r0, r1
   1d70c:	d1f9      	bne.n	1d702 <neul_string_convert_uint8_array_to_uint32+0x14>
    }

    *result = value;
   1d70e:	6013      	str	r3, [r2, #0]
    return true;
   1d710:	2301      	movs	r3, #1
}
   1d712:	0018      	movs	r0, r3
   1d714:	bd10      	pop	{r4, pc}
	...

0001d718 <activity_indication_init>:

    return ACTIVITY_INDICATION_RET_OK;
}

void activity_indication_init(void)
{
   1d718:	b530      	push	{r4, r5, lr}
   1d71a:	b085      	sub	sp, #20
    NEUL_RET get_activity_indication_delay = NEUL_RET_ERROR;
    NEUL_RET get_indication_pin;
    char     activity_indication_delay_milliseconds[MAX_INDICATION_DELAY_CONFIG_LEN+1] = {0};
   1d71c:	2205      	movs	r2, #5
   1d71e:	2100      	movs	r1, #0
   1d720:	a802      	add	r0, sp, #8
   1d722:	f7e2 fddd 	bl	2e0 <memset>
    uint16   kvalue_length;

    if(activity_indication_pin != PIN_NONE)
   1d726:	4c1e      	ldr	r4, [pc, #120]	; (1d7a0 <activity_indication_init+0x88>)
   1d728:	7823      	ldrb	r3, [r4, #0]
   1d72a:	2b28      	cmp	r3, #40	; 0x28
   1d72c:	d10a      	bne.n	1d744 <activity_indication_init+0x2c>
    {
        return;
    }

    get_indication_pin = neul_kv_get(BASE_KEYID_ACTIVITY_INDICATION_PIN, sizeof(uint8), &kvalue_length, (uint8 *)&(activity_indication_pin));
   1d72e:	466a      	mov	r2, sp
   1d730:	0023      	movs	r3, r4
   1d732:	3206      	adds	r2, #6
   1d734:	2101      	movs	r1, #1
   1d736:	2008      	movs	r0, #8
   1d738:	f7e9 ff3b 	bl	75b2 <neul_kv_get>
    if(get_indication_pin != NEUL_RET_OK)
   1d73c:	2800      	cmp	r0, #0
   1d73e:	d003      	beq.n	1d748 <activity_indication_init+0x30>
    {
        activity_indication_pin = PIN_NONE;
   1d740:	2328      	movs	r3, #40	; 0x28
   1d742:	7023      	strb	r3, [r4, #0]
        else
        {
            activity_indication_pin = PIN_NONE;
        }
    }
}
   1d744:	b005      	add	sp, #20
   1d746:	bd30      	pop	{r4, r5, pc}
    else if(activity_indication_pin != PIN_NONE)
   1d748:	7823      	ldrb	r3, [r4, #0]
   1d74a:	2b28      	cmp	r3, #40	; 0x28
   1d74c:	d0fa      	beq.n	1d744 <activity_indication_init+0x2c>
        get_activity_indication_delay = neul_kv_get(BASE_KEYID_ACTIVITY_INDICATION_DELAY_MILLISECONDS, MAX_INDICATION_DELAY_CONFIG_LEN, \
   1d74e:	466a      	mov	r2, sp
   1d750:	2104      	movs	r1, #4
   1d752:	ab02      	add	r3, sp, #8
   1d754:	3206      	adds	r2, #6
   1d756:	2009      	movs	r0, #9
   1d758:	f7e9 ff2b 	bl	75b2 <neul_kv_get>
   1d75c:	4d11      	ldr	r5, [pc, #68]	; (1d7a4 <activity_indication_init+0x8c>)
   1d75e:	1e01      	subs	r1, r0, #0
        if(get_activity_indication_delay == NEUL_RET_OK)
   1d760:	d106      	bne.n	1d770 <activity_indication_init+0x58>
            activity_delay_milliseconds = strtoul(activity_indication_delay_milliseconds, NULL, 10);
   1d762:	220a      	movs	r2, #10
   1d764:	a802      	add	r0, sp, #8
   1d766:	f7fd fd37 	bl	1b1d8 <strtoul>
   1d76a:	6028      	str	r0, [r5, #0]
            if(activity_delay_milliseconds == 0)
   1d76c:	2800      	cmp	r0, #0
   1d76e:	d101      	bne.n	1d774 <activity_indication_init+0x5c>
                 activity_delay_milliseconds = DEFAULT_INDICATION_DELAY_MILLISECONDS;
   1d770:	23c8      	movs	r3, #200	; 0xc8
   1d772:	602b      	str	r3, [r5, #0]
        activity_delay_milliseconds = (uint32)osMs2Tick((uint64_t)activity_delay_milliseconds);
   1d774:	6828      	ldr	r0, [r5, #0]
   1d776:	2100      	movs	r1, #0
   1d778:	f7f7 f834 	bl	147e4 <osMs2Tick>
        if(gpio_claim(activity_indication_pin, GPIO_DIRECTION_OUTPUT))
   1d77c:	2101      	movs	r1, #1
        activity_delay_milliseconds = (uint32)osMs2Tick((uint64_t)activity_delay_milliseconds);
   1d77e:	6028      	str	r0, [r5, #0]
        if(gpio_claim(activity_indication_pin, GPIO_DIRECTION_OUTPUT))
   1d780:	7820      	ldrb	r0, [r4, #0]
   1d782:	f7f9 fceb 	bl	1715c <gpio_claim>
   1d786:	2800      	cmp	r0, #0
   1d788:	d0da      	beq.n	1d740 <activity_indication_init+0x28>
            gpio_clear(activity_indication_pin);
   1d78a:	7820      	ldrb	r0, [r4, #0]
   1d78c:	f7f9 fd8a 	bl	172a4 <gpio_clear>
    if(indication_mutex == NULL)
   1d790:	4c05      	ldr	r4, [pc, #20]	; (1d7a8 <activity_indication_init+0x90>)
   1d792:	6820      	ldr	r0, [r4, #0]
   1d794:	2800      	cmp	r0, #0
   1d796:	d1d5      	bne.n	1d744 <activity_indication_init+0x2c>
        indication_mutex = osMutexNew(NULL);
   1d798:	f7f7 f8ee 	bl	14978 <osMutexNew>
   1d79c:	6020      	str	r0, [r4, #0]
   1d79e:	e7d1      	b.n	1d744 <activity_indication_init+0x2c>
   1d7a0:	010005e0 	.word	0x010005e0
   1d7a4:	01002cc8 	.word	0x01002cc8
   1d7a8:	01002cd0 	.word	0x01002cd0

0001d7ac <activity_indication_output>:

    indication_delete_semaphore();
}

ACTIVITY_INDICATION_RET activity_indication_output(bool active_pin)
{
   1d7ac:	b570      	push	{r4, r5, r6, lr}
    if (activity_indication_pin != PIN_NONE)
   1d7ae:	4d25      	ldr	r5, [pc, #148]	; (1d844 <activity_indication_output+0x98>)
            indication_count -= 1;
            non_os_exit_critical();
            return ACTIVITY_INDICATION_RET_OK;
        }
    }
    return ACTIVITY_INDICATION_RET_ERROR;
   1d7b0:	2301      	movs	r3, #1
    if (activity_indication_pin != PIN_NONE)
   1d7b2:	782a      	ldrb	r2, [r5, #0]
   1d7b4:	2a28      	cmp	r2, #40	; 0x28
   1d7b6:	d028      	beq.n	1d80a <activity_indication_output+0x5e>
   1d7b8:	4c23      	ldr	r4, [pc, #140]	; (1d848 <activity_indication_output+0x9c>)
        if(active_pin)
   1d7ba:	2800      	cmp	r0, #0
   1d7bc:	d030      	beq.n	1d820 <activity_indication_output+0x74>
            non_os_enter_critical();
   1d7be:	f7fa fcf9 	bl	181b4 <non_os_enter_critical>
            indication_count += 1;
   1d7c2:	7823      	ldrb	r3, [r4, #0]
   1d7c4:	3301      	adds	r3, #1
   1d7c6:	7023      	strb	r3, [r4, #0]
            non_os_exit_critical();
   1d7c8:	f7fa fd08 	bl	181dc <non_os_exit_critical>
    if(indication_mutex != NULL)
   1d7cc:	4e1f      	ldr	r6, [pc, #124]	; (1d84c <activity_indication_output+0xa0>)
   1d7ce:	6830      	ldr	r0, [r6, #0]
   1d7d0:	2800      	cmp	r0, #0
   1d7d2:	d009      	beq.n	1d7e8 <activity_indication_output+0x3c>
        if (osMutexAcquire(indication_mutex, blockTime) != osOK)
   1d7d4:	2101      	movs	r1, #1
   1d7d6:	4249      	negs	r1, r1
   1d7d8:	f7f7 f8e4 	bl	149a4 <osMutexAcquire>
   1d7dc:	2800      	cmp	r0, #0
   1d7de:	d003      	beq.n	1d7e8 <activity_indication_output+0x3c>
            panic(PANIC_ACTIVITY_INDICATION, PANIC_INDICATION_UNABLE_TO_TAKE_SEMAPHORE);
   1d7e0:	2100      	movs	r1, #0
   1d7e2:	202b      	movs	r0, #43	; 0x2b
   1d7e4:	f7e4 f994 	bl	1b10 <panic>
            if(indication_count == 1)
   1d7e8:	7823      	ldrb	r3, [r4, #0]
   1d7ea:	2b01      	cmp	r3, #1
   1d7ec:	d109      	bne.n	1d802 <activity_indication_output+0x56>
                (void)osDelay((uint32_t)ACTIVITY_WAIT_TIME);
   1d7ee:	2005      	movs	r0, #5
   1d7f0:	f7f7 f83b 	bl	1486a <osDelay>
                gpio_set(activity_indication_pin);
   1d7f4:	7828      	ldrb	r0, [r5, #0]
   1d7f6:	f7f9 fd2d 	bl	17254 <gpio_set>
                (void)osDelay((uint32_t)(activity_delay_milliseconds));
   1d7fa:	4b15      	ldr	r3, [pc, #84]	; (1d850 <activity_indication_output+0xa4>)
   1d7fc:	6818      	ldr	r0, [r3, #0]
   1d7fe:	f7f7 f834 	bl	1486a <osDelay>
    if(indication_mutex != NULL)
   1d802:	6830      	ldr	r0, [r6, #0]
   1d804:	2800      	cmp	r0, #0
   1d806:	d102      	bne.n	1d80e <activity_indication_output+0x62>
            return ACTIVITY_INDICATION_RET_OK;
   1d808:	2300      	movs	r3, #0
}
   1d80a:	0018      	movs	r0, r3
   1d80c:	bd70      	pop	{r4, r5, r6, pc}
        if (osMutexRelease(indication_mutex) != osOK) //lint !e455
   1d80e:	f7f7 f8ed 	bl	149ec <osMutexRelease>
   1d812:	2800      	cmp	r0, #0
   1d814:	d0f8      	beq.n	1d808 <activity_indication_output+0x5c>
            panic(PANIC_ACTIVITY_INDICATION, PANIC_INDICATION_UNABLE_TO_GIVE_SEMAPHORE);
   1d816:	2101      	movs	r1, #1
   1d818:	202b      	movs	r0, #43	; 0x2b
   1d81a:	f7e4 f979 	bl	1b10 <panic>
   1d81e:	e7f3      	b.n	1d808 <activity_indication_output+0x5c>
            if(indication_count == 0)
   1d820:	7821      	ldrb	r1, [r4, #0]
    return ACTIVITY_INDICATION_RET_ERROR;
   1d822:	2301      	movs	r3, #1
            if(indication_count == 0)
   1d824:	2900      	cmp	r1, #0
   1d826:	d0f0      	beq.n	1d80a <activity_indication_output+0x5e>
            if(indication_count == 1)
   1d828:	4299      	cmp	r1, r3
   1d82a:	d102      	bne.n	1d832 <activity_indication_output+0x86>
                gpio_clear(activity_indication_pin);
   1d82c:	0010      	movs	r0, r2
   1d82e:	f7f9 fd39 	bl	172a4 <gpio_clear>
            non_os_enter_critical();
   1d832:	f7fa fcbf 	bl	181b4 <non_os_enter_critical>
            indication_count -= 1;
   1d836:	7823      	ldrb	r3, [r4, #0]
   1d838:	3b01      	subs	r3, #1
   1d83a:	7023      	strb	r3, [r4, #0]
            non_os_exit_critical();
   1d83c:	f7fa fcce 	bl	181dc <non_os_exit_critical>
   1d840:	e7e2      	b.n	1d808 <activity_indication_output+0x5c>
   1d842:	46c0      	nop			; (mov r8, r8)
   1d844:	010005e0 	.word	0x010005e0
   1d848:	01002ccc 	.word	0x01002ccc
   1d84c:	01002cd0 	.word	0x01002cd0
   1d850:	01002cc8 	.word	0x01002cc8

0001d854 <ppp_output_cb_fn>:
 * @param len
 * @param ctx
 * @return
 */
static u32_t ppp_output_cb_fn(ppp_pcb *pcb, u8_t *data, u32_t len, void *ctx)
{
   1d854:	b510      	push	{r4, lr}
    UNUSED(ctx);
    UNUSED(pcb);
    return sio_write(ppp_uart_handler, data, len);
   1d856:	4b02      	ldr	r3, [pc, #8]	; (1d860 <ppp_output_cb_fn+0xc>)
   1d858:	6818      	ldr	r0, [r3, #0]
   1d85a:	f004 ff7c 	bl	22756 <sio_write>
}
   1d85e:	bd10      	pop	{r4, pc}
   1d860:	01002d00 	.word	0x01002d00

0001d864 <pppd_terminate>:
/**
 * terminate pppd if we've been idle for a second
 * @param arguement not used
 */
static void pppd_terminate(void *argument)
{
   1d864:	b510      	push	{r4, lr}
    UNUSED(argument);
    // must have no input for 1 second after last '+'
    if (last_packet_recv_time == terminate_timer_last_recv)
   1d866:	4b09      	ldr	r3, [pc, #36]	; (1d88c <pppd_terminate+0x28>)
   1d868:	681a      	ldr	r2, [r3, #0]
   1d86a:	4b09      	ldr	r3, [pc, #36]	; (1d890 <pppd_terminate+0x2c>)
   1d86c:	681b      	ldr	r3, [r3, #0]
   1d86e:	429a      	cmp	r2, r3
   1d870:	d107      	bne.n	1d882 <pppd_terminate+0x1e>
    {
        lwip_support_log("pppd: termination request");
   1d872:	4808      	ldr	r0, [pc, #32]	; (1d894 <pppd_terminate+0x30>)
   1d874:	f004 fd4a 	bl	2230c <lwip_support_log>
        (void) ppp_close(ppps, 1);  // ignore return value as we can't do anything with it here
   1d878:	4b07      	ldr	r3, [pc, #28]	; (1d898 <pppd_terminate+0x34>)
   1d87a:	2101      	movs	r1, #1
   1d87c:	6818      	ldr	r0, [r3, #0]
   1d87e:	f000 fb79 	bl	1df74 <ppp_close>
    }
    num_plus_symbols = 0;
   1d882:	2200      	movs	r2, #0
   1d884:	4b05      	ldr	r3, [pc, #20]	; (1d89c <pppd_terminate+0x38>)
   1d886:	701a      	strb	r2, [r3, #0]
}
   1d888:	bd10      	pop	{r4, pc}
   1d88a:	46c0      	nop			; (mov r8, r8)
   1d88c:	01002cd8 	.word	0x01002cd8
   1d890:	01002d60 	.word	0x01002d60
   1d894:	0002576e 	.word	0x0002576e
   1d898:	01002d58 	.word	0x01002d58
   1d89c:	01002cdc 	.word	0x01002cdc

0001d8a0 <ppp_socket_callback>:
{
   1d8a0:	b507      	push	{r0, r1, r2, lr}
    uint32 unused = 0;
   1d8a2:	2200      	movs	r2, #0
    (void)osMessageQueuePut(ppp_queue_handle, (void*)&unused, 0, osNoWait);
   1d8a4:	4803      	ldr	r0, [pc, #12]	; (1d8b4 <ppp_socket_callback+0x14>)
   1d8a6:	0013      	movs	r3, r2
   1d8a8:	a901      	add	r1, sp, #4
   1d8aa:	6800      	ldr	r0, [r0, #0]
    uint32 unused = 0;
   1d8ac:	9201      	str	r2, [sp, #4]
    (void)osMessageQueuePut(ppp_queue_handle, (void*)&unused, 0, osNoWait);
   1d8ae:	f7f7 f947 	bl	14b40 <osMessageQueuePut>
}
   1d8b2:	bd07      	pop	{r0, r1, r2, pc}
   1d8b4:	01002cf8 	.word	0x01002cf8

0001d8b8 <ppp_uart_callback>:
    uint32 unused = 0;
   1d8b8:	2300      	movs	r3, #0
{
   1d8ba:	b573      	push	{r0, r1, r4, r5, r6, lr}
    if (input_data_first == NULL)
   1d8bc:	4e15      	ldr	r6, [pc, #84]	; (1d914 <ppp_uart_callback+0x5c>)
    uint32 unused = 0;
   1d8be:	9301      	str	r3, [sp, #4]
    uart_release_callback = uart_buffer_release_cb;
   1d8c0:	4b15      	ldr	r3, [pc, #84]	; (1d918 <ppp_uart_callback+0x60>)
{
   1d8c2:	0005      	movs	r5, r0
    uart_release_callback = uart_buffer_release_cb;
   1d8c4:	601a      	str	r2, [r3, #0]
    if (input_data_first == NULL)
   1d8c6:	6832      	ldr	r2, [r6, #0]
{
   1d8c8:	000c      	movs	r4, r1
    if (input_data_first == NULL)
   1d8ca:	2a00      	cmp	r2, #0
   1d8cc:	d10a      	bne.n	1d8e4 <ppp_uart_callback+0x2c>
        (void)osMessageQueuePut(ppp_queue_handle, (void*)&unused, 0, osNoWait);
   1d8ce:	4813      	ldr	r0, [pc, #76]	; (1d91c <ppp_uart_callback+0x64>)
   1d8d0:	0013      	movs	r3, r2
   1d8d2:	a901      	add	r1, sp, #4
   1d8d4:	6800      	ldr	r0, [r0, #0]
   1d8d6:	f7f7 f933 	bl	14b40 <osMessageQueuePut>
        input_data_array[0].buffer = buffer;
   1d8da:	4b11      	ldr	r3, [pc, #68]	; (1d920 <ppp_uart_callback+0x68>)
   1d8dc:	601d      	str	r5, [r3, #0]
        input_data_array[0].length = length;
   1d8de:	809c      	strh	r4, [r3, #4]
        input_data_first = &input_data_array[0];
   1d8e0:	6033      	str	r3, [r6, #0]
}
   1d8e2:	bd73      	pop	{r0, r1, r4, r5, r6, pc}
        if ((uint32)input_data_first->buffer + input_data_first->length == (uint32)buffer)
   1d8e4:	8893      	ldrh	r3, [r2, #4]
   1d8e6:	6811      	ldr	r1, [r2, #0]
   1d8e8:	18c9      	adds	r1, r1, r3
   1d8ea:	4288      	cmp	r0, r1
   1d8ec:	d102      	bne.n	1d8f4 <ppp_uart_callback+0x3c>
            input_data_first->length += length;
   1d8ee:	191c      	adds	r4, r3, r4
   1d8f0:	8094      	strh	r4, [r2, #4]
   1d8f2:	e7f6      	b.n	1d8e2 <ppp_uart_callback+0x2a>
            if (input_data_first->next == NULL)
   1d8f4:	6893      	ldr	r3, [r2, #8]
   1d8f6:	2b00      	cmp	r3, #0
   1d8f8:	d108      	bne.n	1d90c <ppp_uart_callback+0x54>
                current = (input_data_first == &input_data_array[0]) ? &input_data_array[1] : &input_data_array[0];
   1d8fa:	4909      	ldr	r1, [pc, #36]	; (1d920 <ppp_uart_callback+0x68>)
   1d8fc:	4b09      	ldr	r3, [pc, #36]	; (1d924 <ppp_uart_callback+0x6c>)
   1d8fe:	428a      	cmp	r2, r1
   1d900:	d000      	beq.n	1d904 <ppp_uart_callback+0x4c>
   1d902:	000b      	movs	r3, r1
                input_data_first->next = current;
   1d904:	6093      	str	r3, [r2, #8]
                current->buffer = buffer;
   1d906:	601d      	str	r5, [r3, #0]
                current->length += length;
   1d908:	809c      	strh	r4, [r3, #4]
}
   1d90a:	e7ea      	b.n	1d8e2 <ppp_uart_callback+0x2a>
                current->length += length;
   1d90c:	889a      	ldrh	r2, [r3, #4]
   1d90e:	18a4      	adds	r4, r4, r2
   1d910:	e7fa      	b.n	1d908 <ppp_uart_callback+0x50>
   1d912:	46c0      	nop			; (mov r8, r8)
   1d914:	01002cd4 	.word	0x01002cd4
   1d918:	01002d64 	.word	0x01002d64
   1d91c:	01002cf8 	.word	0x01002cf8
   1d920:	01002ef8 	.word	0x01002ef8
   1d924:	01002f04 	.word	0x01002f04

0001d928 <linkStatusCB>:
{
   1d928:	4673      	mov	r3, lr
   1d92a:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
   1d92c:	9301      	str	r3, [sp, #4]
    if (errCode != PPPERR_NONE)
   1d92e:	2900      	cmp	r1, #0
   1d930:	d028      	beq.n	1d984 <linkStatusCB+0x5c>
        neul_lwip_serial_deinit(ppp_uart_handler);
   1d932:	4b15      	ldr	r3, [pc, #84]	; (1d988 <linkStatusCB+0x60>)
        non_os_enter_critical();
   1d934:	2400      	movs	r4, #0
        neul_lwip_serial_deinit(ppp_uart_handler);
   1d936:	6818      	ldr	r0, [r3, #0]
   1d938:	f004 ff38 	bl	227ac <neul_lwip_serial_deinit>
        non_os_enter_critical();
   1d93c:	f7fa fc3a 	bl	181b4 <non_os_enter_critical>
   1d940:	4d12      	ldr	r5, [pc, #72]	; (1d98c <linkStatusCB+0x64>)
   1d942:	1967      	adds	r7, r4, r5
            if (input_data_array[i].length != 0)
   1d944:	88bb      	ldrh	r3, [r7, #4]
   1d946:	2b00      	cmp	r3, #0
   1d948:	d00b      	beq.n	1d962 <linkStatusCB+0x3a>
                assert(uart_release_callback != NULL);  //Asset not panic, as this should not be possible (so is never expected outside of dev)
   1d94a:	4e11      	ldr	r6, [pc, #68]	; (1d990 <linkStatusCB+0x68>)
   1d94c:	6833      	ldr	r3, [r6, #0]
   1d94e:	2b00      	cmp	r3, #0
   1d950:	d103      	bne.n	1d95a <linkStatusCB+0x32>
   1d952:	9901      	ldr	r1, [sp, #4]
   1d954:	2016      	movs	r0, #22
   1d956:	f7e4 f8db 	bl	1b10 <panic>
                uart_release_callback(input_data_array[i].buffer, input_data_array[i].length);
   1d95a:	88b9      	ldrh	r1, [r7, #4]
   1d95c:	6833      	ldr	r3, [r6, #0]
   1d95e:	5928      	ldr	r0, [r5, r4]
   1d960:	4798      	blx	r3
   1d962:	340c      	adds	r4, #12
        for (int i = 0; i < INPUT_DATA_SIZE; i++)
   1d964:	2c18      	cmp	r4, #24
   1d966:	d1eb      	bne.n	1d940 <linkStatusCB+0x18>
        input_data_first = NULL;
   1d968:	2200      	movs	r2, #0
   1d96a:	4b0a      	ldr	r3, [pc, #40]	; (1d994 <linkStatusCB+0x6c>)
   1d96c:	601a      	str	r2, [r3, #0]
        non_os_exit_critical();
   1d96e:	f7fa fc35 	bl	181dc <non_os_exit_critical>
        (void) osTimerStop (terminate_timer);  // in case we're in the middle of a terminate check
   1d972:	4b09      	ldr	r3, [pc, #36]	; (1d998 <linkStatusCB+0x70>)
   1d974:	6818      	ldr	r0, [r3, #0]
   1d976:	f7f6 ffc7 	bl	14908 <osTimerStop>
        if (ppp_exited != NULL)
   1d97a:	4b08      	ldr	r3, [pc, #32]	; (1d99c <linkStatusCB+0x74>)
   1d97c:	681b      	ldr	r3, [r3, #0]
   1d97e:	2b00      	cmp	r3, #0
   1d980:	d000      	beq.n	1d984 <linkStatusCB+0x5c>
            ppp_exited();
   1d982:	4798      	blx	r3
}
   1d984:	bdf7      	pop	{r0, r1, r2, r4, r5, r6, r7, pc}
   1d986:	46c0      	nop			; (mov r8, r8)
   1d988:	01002d00 	.word	0x01002d00
   1d98c:	01002ef8 	.word	0x01002ef8
   1d990:	01002d64 	.word	0x01002d64
   1d994:	01002cd4 	.word	0x01002cd4
   1d998:	01002d5c 	.word	0x01002d5c
   1d99c:	01002ce0 	.word	0x01002ce0

0001d9a0 <ppp_main>:
    uint16 length;
    data_array_ll *next;

    uint32 current_packet_recv_time;

    terminate_timer = osTimerNew ((osTimerFunc_t) pppd_terminate, osTimerOnce, NULL, NULL);
   1d9a0:	2300      	movs	r3, #0
{
   1d9a2:	b5f0      	push	{r4, r5, r6, r7, lr}
    terminate_timer = osTimerNew ((osTimerFunc_t) pppd_terminate, osTimerOnce, NULL, NULL);
   1d9a4:	001a      	movs	r2, r3
{
   1d9a6:	b085      	sub	sp, #20
    terminate_timer = osTimerNew ((osTimerFunc_t) pppd_terminate, osTimerOnce, NULL, NULL);
   1d9a8:	0019      	movs	r1, r3
   1d9aa:	4845      	ldr	r0, [pc, #276]	; (1dac0 <ppp_main+0x120>)
   1d9ac:	f7f6 ff64 	bl	14878 <osTimerNew>
   1d9b0:	4e44      	ldr	r6, [pc, #272]	; (1dac4 <ppp_main+0x124>)
   1d9b2:	6030      	str	r0, [r6, #0]

    while (1) //lint !e716
    {
        if(osMessageQueueGet(ppp_queue_handle, (void*)&ppp_message, NULL, osWaitForever) == osOK)
   1d9b4:	2301      	movs	r3, #1
   1d9b6:	4844      	ldr	r0, [pc, #272]	; (1dac8 <ppp_main+0x128>)
   1d9b8:	425b      	negs	r3, r3
   1d9ba:	2200      	movs	r2, #0
   1d9bc:	a903      	add	r1, sp, #12
   1d9be:	6800      	ldr	r0, [r0, #0]
   1d9c0:	f7f7 f8ea 	bl	14b98 <osMessageQueueGet>
   1d9c4:	2800      	cmp	r0, #0
   1d9c6:	d1f5      	bne.n	1d9b4 <ppp_main+0x14>
        {
            //If we set input_data_head to NULL then it can get changed in IRQ, so this check has been made volatile
            while ((((volatile data_array_ll *)input_data_first) != NULL))
   1d9c8:	4f40      	ldr	r7, [pc, #256]	; (1dacc <ppp_main+0x12c>)
   1d9ca:	683b      	ldr	r3, [r7, #0]
   1d9cc:	2b00      	cmp	r3, #0
   1d9ce:	d105      	bne.n	1d9dc <ppp_main+0x3c>
                }

                uart_release_callback(buffer, length);
            }
            // check if there is data to read
            while (netif_ip4_socket_recv(&pppd_netif))
   1d9d0:	483f      	ldr	r0, [pc, #252]	; (1dad0 <ppp_main+0x130>)
   1d9d2:	f004 fcd5 	bl	22380 <netif_ip4_socket_recv>
   1d9d6:	2800      	cmp	r0, #0
   1d9d8:	d1fa      	bne.n	1d9d0 <ppp_main+0x30>
   1d9da:	e7eb      	b.n	1d9b4 <ppp_main+0x14>
                current_packet_recv_time = sys_now();
   1d9dc:	f004 ff44 	bl	22868 <sys_now>
                input_data_first->length = 0;
   1d9e0:	2400      	movs	r4, #0
                current_packet_recv_time = sys_now();
   1d9e2:	9001      	str	r0, [sp, #4]
                non_os_enter_critical();
   1d9e4:	f7fa fbe6 	bl	181b4 <non_os_enter_critical>
                next = input_data_first->next;
   1d9e8:	683b      	ldr	r3, [r7, #0]
   1d9ea:	689a      	ldr	r2, [r3, #8]
                length = input_data_first->length;
   1d9ec:	8899      	ldrh	r1, [r3, #4]
                input_data_first->next = NULL;
   1d9ee:	609c      	str	r4, [r3, #8]
                input_data_first->length = 0;
   1d9f0:	809c      	strh	r4, [r3, #4]
                buffer = input_data_first->buffer;
   1d9f2:	681d      	ldr	r5, [r3, #0]
                length = input_data_first->length;
   1d9f4:	9100      	str	r1, [sp, #0]
                input_data_first = next;
   1d9f6:	603a      	str	r2, [r7, #0]
                non_os_exit_critical();
   1d9f8:	f7fa fbf0 	bl	181dc <non_os_exit_critical>
                if (((current_packet_recv_time - last_packet_recv_time) & 0x7Fffffff) > 1000)
   1d9fc:	4f35      	ldr	r7, [pc, #212]	; (1dad4 <ppp_main+0x134>)
   1d9fe:	9b01      	ldr	r3, [sp, #4]
   1da00:	683a      	ldr	r2, [r7, #0]
   1da02:	1a9b      	subs	r3, r3, r2
   1da04:	22fa      	movs	r2, #250	; 0xfa
   1da06:	005b      	lsls	r3, r3, #1
   1da08:	085b      	lsrs	r3, r3, #1
   1da0a:	0092      	lsls	r2, r2, #2
   1da0c:	4293      	cmp	r3, r2
   1da0e:	d80b      	bhi.n	1da28 <ppp_main+0x88>
                if ((num_plus_symbols > 0) && (num_plus_symbols < 3))
   1da10:	4931      	ldr	r1, [pc, #196]	; (1dad8 <ppp_main+0x138>)
   1da12:	780a      	ldrb	r2, [r1, #0]
   1da14:	1e53      	subs	r3, r2, #1
   1da16:	2b01      	cmp	r3, #1
   1da18:	d81d      	bhi.n	1da56 <ppp_main+0xb6>
   1da1a:	2300      	movs	r3, #0
   1da1c:	e013      	b.n	1da46 <ppp_main+0xa6>
        if (buf_ptr[i] == '+')
   1da1e:	5d2a      	ldrb	r2, [r5, r4]
   1da20:	1c63      	adds	r3, r4, #1
   1da22:	2a2b      	cmp	r2, #43	; 0x2b
   1da24:	d108      	bne.n	1da38 <ppp_main+0x98>
   1da26:	001c      	movs	r4, r3
    for(uint16 i=0; i< length; i++)
   1da28:	9900      	ldr	r1, [sp, #0]
   1da2a:	b2a2      	uxth	r2, r4
   1da2c:	b2e3      	uxtb	r3, r4
   1da2e:	4291      	cmp	r1, r2
   1da30:	d8f5      	bhi.n	1da1e <ppp_main+0x7e>
                    num_plus_symbols = count_num_plus(buffer, length);
   1da32:	4a29      	ldr	r2, [pc, #164]	; (1dad8 <ppp_main+0x138>)
   1da34:	7013      	strb	r3, [r2, #0]
   1da36:	e7eb      	b.n	1da10 <ppp_main+0x70>
            count = 0;
   1da38:	2300      	movs	r3, #0
   1da3a:	e7fa      	b.n	1da32 <ppp_main+0x92>
   1da3c:	1c58      	adds	r0, r3, #1
        if (buf_ptr[i] == '+')
   1da3e:	5ceb      	ldrb	r3, [r5, r3]
   1da40:	2b2b      	cmp	r3, #43	; 0x2b
   1da42:	d12e      	bne.n	1daa2 <ppp_main+0x102>
   1da44:	0003      	movs	r3, r0
    for(uint16 i=0; i< length; i++)
   1da46:	b29c      	uxth	r4, r3
   1da48:	46a4      	mov	ip, r4
   1da4a:	9c00      	ldr	r4, [sp, #0]
   1da4c:	b2d8      	uxtb	r0, r3
   1da4e:	45a4      	cmp	ip, r4
   1da50:	d3f4      	bcc.n	1da3c <ppp_main+0x9c>
                    num_plus_symbols += count_num_plus(buffer, length);
   1da52:	1812      	adds	r2, r2, r0
   1da54:	700a      	strb	r2, [r1, #0]
                if (num_plus_symbols >=3)
   1da56:	780b      	ldrb	r3, [r1, #0]
   1da58:	2b02      	cmp	r3, #2
   1da5a:	d90a      	bls.n	1da72 <ppp_main+0xd2>
                    (void) osTimerStop (terminate_timer);  // just in case
   1da5c:	6830      	ldr	r0, [r6, #0]
   1da5e:	f7f6 ff53 	bl	14908 <osTimerStop>
                    (void) osTimerStart ( terminate_timer, 1000);
   1da62:	21fa      	movs	r1, #250	; 0xfa
                    terminate_timer_last_recv = current_packet_recv_time;
   1da64:	4b1d      	ldr	r3, [pc, #116]	; (1dadc <ppp_main+0x13c>)
   1da66:	9a01      	ldr	r2, [sp, #4]
                    (void) osTimerStart ( terminate_timer, 1000);
   1da68:	0089      	lsls	r1, r1, #2
   1da6a:	6830      	ldr	r0, [r6, #0]
                    terminate_timer_last_recv = current_packet_recv_time;
   1da6c:	601a      	str	r2, [r3, #0]
                    (void) osTimerStart ( terminate_timer, 1000);
   1da6e:	f7f6 ff2b 	bl	148c8 <osTimerStart>
                if (ppps->phase <= PPP_PHASE_ESTABLISH)
   1da72:	4c1b      	ldr	r4, [pc, #108]	; (1dae0 <ppp_main+0x140>)
   1da74:	6820      	ldr	r0, [r4, #0]
   1da76:	1c43      	adds	r3, r0, #1
   1da78:	7fdb      	ldrb	r3, [r3, #31]
   1da7a:	2b06      	cmp	r3, #6
   1da7c:	d81b      	bhi.n	1dab6 <ppp_main+0x116>
                    if (strstr((const char*) buffer, "CLIENT") != NULL)
   1da7e:	4919      	ldr	r1, [pc, #100]	; (1dae4 <ppp_main+0x144>)
   1da80:	0028      	movs	r0, r5
   1da82:	f004 fc09 	bl	22298 <strstr>
   1da86:	2800      	cmp	r0, #0
   1da88:	d00d      	beq.n	1daa6 <ppp_main+0x106>
                        (void) sio_write(ppp_uart_handler, (u8_t*) "CLIENTSERVER", 12);
   1da8a:	4b17      	ldr	r3, [pc, #92]	; (1dae8 <ppp_main+0x148>)
   1da8c:	220c      	movs	r2, #12
   1da8e:	4917      	ldr	r1, [pc, #92]	; (1daec <ppp_main+0x14c>)
   1da90:	6818      	ldr	r0, [r3, #0]
   1da92:	f004 fe60 	bl	22756 <sio_write>
                uart_release_callback(buffer, length);
   1da96:	4b16      	ldr	r3, [pc, #88]	; (1daf0 <ppp_main+0x150>)
   1da98:	9900      	ldr	r1, [sp, #0]
   1da9a:	681b      	ldr	r3, [r3, #0]
   1da9c:	0028      	movs	r0, r5
   1da9e:	4798      	blx	r3
   1daa0:	e792      	b.n	1d9c8 <ppp_main+0x28>
            count = 0;
   1daa2:	2000      	movs	r0, #0
   1daa4:	e7d5      	b.n	1da52 <ppp_main+0xb2>
                        pppos_input(ppps, (uint8 *)buffer, (int)length);
   1daa6:	0029      	movs	r1, r5
                        last_packet_recv_time = current_packet_recv_time; // update to current time
   1daa8:	9b01      	ldr	r3, [sp, #4]
                        pppos_input(ppps, (uint8 *)buffer, (int)length);
   1daaa:	9a00      	ldr	r2, [sp, #0]
   1daac:	6820      	ldr	r0, [r4, #0]
                        last_packet_recv_time = current_packet_recv_time; // update to current time
   1daae:	603b      	str	r3, [r7, #0]
                    pppos_input(ppps, (uint8 *)buffer, (int)length);
   1dab0:	f000 fd1e 	bl	1e4f0 <pppos_input>
   1dab4:	e7ef      	b.n	1da96 <ppp_main+0xf6>
                    last_packet_recv_time = current_packet_recv_time; // update to current time
   1dab6:	9b01      	ldr	r3, [sp, #4]
                    pppos_input(ppps, (uint8 *)buffer, (int)length);
   1dab8:	9a00      	ldr	r2, [sp, #0]
                    last_packet_recv_time = current_packet_recv_time; // update to current time
   1daba:	603b      	str	r3, [r7, #0]
                    pppos_input(ppps, (uint8 *)buffer, (int)length);
   1dabc:	0029      	movs	r1, r5
   1dabe:	e7f7      	b.n	1dab0 <ppp_main+0x110>
   1dac0:	0001d865 	.word	0x0001d865
   1dac4:	01002d5c 	.word	0x01002d5c
   1dac8:	01002cf8 	.word	0x01002cf8
   1dacc:	01002cd4 	.word	0x01002cd4
   1dad0:	01002d04 	.word	0x01002d04
   1dad4:	01002cd8 	.word	0x01002cd8
   1dad8:	01002cdc 	.word	0x01002cdc
   1dadc:	01002d60 	.word	0x01002d60
   1dae0:	01002d58 	.word	0x01002d58
   1dae4:	00025734 	.word	0x00025734
   1dae8:	01002d00 	.word	0x01002d00
   1daec:	0002573b 	.word	0x0002573b
   1daf0:	01002d64 	.word	0x01002d64

0001daf4 <ppp_set_serial_config>:
 * @param baud baud rate to use
 * @param xonxoff Enables software flow control
 * @return true is successfully set, false if any values are not allowed
 */
bool ppp_set_serial_config(PIN tx_pin, PIN rx_pin, PIN rts_pin, PIN cts_pin, uint32 baud, bool xonxoff)
{
   1daf4:	b570      	push	{r4, r5, r6, lr}
   1daf6:	ac04      	add	r4, sp, #16
   1daf8:	cc20      	ldmia	r4!, {r5}
   1dafa:	7824      	ldrb	r4, [r4, #0]
    // Must have tx & rx pins set
    // 9600 and below is too slow.
    if ((tx_pin == PIN_NONE) || (rx_pin == PIN_NONE) || ( baud < MIN_PPP_BAUD_RATE))
   1dafc:	2828      	cmp	r0, #40	; 0x28
   1dafe:	d019      	beq.n	1db34 <ppp_set_serial_config+0x40>
   1db00:	2928      	cmp	r1, #40	; 0x28
   1db02:	d017      	beq.n	1db34 <ppp_set_serial_config+0x40>
   1db04:	4e0c      	ldr	r6, [pc, #48]	; (1db38 <ppp_set_serial_config+0x44>)
   1db06:	42b5      	cmp	r5, r6
   1db08:	d914      	bls.n	1db34 <ppp_set_serial_config+0x40>
    {
        return false;
    }

    // force the use of flow control at speeds > 115200
    if (baud > MAX_PPP_NO_FLOWCONTROL_BAUD_RATE)
   1db0a:	26e1      	movs	r6, #225	; 0xe1
   1db0c:	0276      	lsls	r6, r6, #9
   1db0e:	42b5      	cmp	r5, r6
   1db10:	d905      	bls.n	1db1e <ppp_set_serial_config+0x2a>
    {
        if ( !xonxoff && ((rts_pin == PIN_NONE) || (cts_pin == PIN_NONE)))
   1db12:	2c00      	cmp	r4, #0
   1db14:	d103      	bne.n	1db1e <ppp_set_serial_config+0x2a>
   1db16:	2a28      	cmp	r2, #40	; 0x28
   1db18:	d00a      	beq.n	1db30 <ppp_set_serial_config+0x3c>
   1db1a:	2b28      	cmp	r3, #40	; 0x28
   1db1c:	d008      	beq.n	1db30 <ppp_set_serial_config+0x3c>
        {
            return false;
        }
    }

    neul_lwip_serial_set_pins(tx_pin, rx_pin, rts_pin, cts_pin);
   1db1e:	f004 fe29 	bl	22774 <neul_lwip_serial_set_pins>
    neul_lwip_serial_set_baud(baud);
   1db22:	0028      	movs	r0, r5
   1db24:	f004 fe30 	bl	22788 <neul_lwip_serial_set_baud>
    neul_lwip_serial_enable_software_flow_control(xonxoff);
   1db28:	0020      	movs	r0, r4
   1db2a:	f004 fe33 	bl	22794 <neul_lwip_serial_enable_software_flow_control>
    return true;
   1db2e:	2401      	movs	r4, #1
}
   1db30:	0020      	movs	r0, r4
   1db32:	bd70      	pop	{r4, r5, r6, pc}
        return false;
   1db34:	2400      	movs	r4, #0
   1db36:	e7fb      	b.n	1db30 <ppp_set_serial_config+0x3c>
   1db38:	0000e0ff 	.word	0x0000e0ff

0001db3c <ppp_set_ppp_exit_callback>:
/** set PPP exit callback
 * @param callback to call when PPP exits
 */
void ppp_set_ppp_exit_callback(ppp_exited_cb callback)
{
    ppp_exited = callback;
   1db3c:	4b01      	ldr	r3, [pc, #4]	; (1db44 <ppp_set_ppp_exit_callback+0x8>)
   1db3e:	6018      	str	r0, [r3, #0]
}
   1db40:	4770      	bx	lr
   1db42:	46c0      	nop			; (mov r8, r8)
   1db44:	01002ce0 	.word	0x01002ce0

0001db48 <pppd_set_ip_address>:
/** set address for PPP to use
 * @param ip_addr ip address to use
 */
void pppd_set_ip_address(const ip_addr_t *ip_addr)
{
    ppp_addr_set = true;
   1db48:	2201      	movs	r2, #1
   1db4a:	4b08      	ldr	r3, [pc, #32]	; (1db6c <pppd_set_ip_address+0x24>)
   1db4c:	701a      	strb	r2, [r3, #0]
    ip_addr_copy(ppp_ipaddr, *ip_addr);
   1db4e:	7c01      	ldrb	r1, [r0, #16]
   1db50:	4b07      	ldr	r3, [pc, #28]	; (1db70 <pppd_set_ip_address+0x28>)
   1db52:	6802      	ldr	r2, [r0, #0]
   1db54:	7419      	strb	r1, [r3, #16]
   1db56:	601a      	str	r2, [r3, #0]
   1db58:	2906      	cmp	r1, #6
   1db5a:	d105      	bne.n	1db68 <pppd_set_ip_address+0x20>
   1db5c:	6842      	ldr	r2, [r0, #4]
   1db5e:	605a      	str	r2, [r3, #4]
   1db60:	6882      	ldr	r2, [r0, #8]
   1db62:	609a      	str	r2, [r3, #8]
   1db64:	68c2      	ldr	r2, [r0, #12]
   1db66:	60da      	str	r2, [r3, #12]
}
   1db68:	4770      	bx	lr
   1db6a:	46c0      	nop			; (mov r8, r8)
   1db6c:	01002cdd 	.word	0x01002cdd
   1db70:	01002ce4 	.word	0x01002ce4

0001db74 <pppd_go>:

/** start pppd
 * requires uart and address to have been set
 */
void  pppd_go(void)
{
   1db74:	b573      	push	{r0, r1, r4, r5, r6, lr}

    lwip_support_log("pppd: starting pppd thread");
   1db76:	4839      	ldr	r0, [pc, #228]	; (1dc5c <pppd_go+0xe8>)
   1db78:	4675      	mov	r5, lr
   1db7a:	f004 fbc7 	bl	2230c <lwip_support_log>

    if (!ppp_addr_set)
   1db7e:	4b38      	ldr	r3, [pc, #224]	; (1dc60 <pppd_go+0xec>)
   1db80:	781b      	ldrb	r3, [r3, #0]
   1db82:	2b00      	cmp	r3, #0
   1db84:	d068      	beq.n	1dc58 <pppd_go+0xe4>
    {
        return;
    }

    if (ppp_thread == NULL)
   1db86:	4c37      	ldr	r4, [pc, #220]	; (1dc64 <pppd_go+0xf0>)
   1db88:	6826      	ldr	r6, [r4, #0]
   1db8a:	2e00      	cmp	r6, #0
   1db8c:	d110      	bne.n	1dbb0 <pppd_go+0x3c>
    ppp_queue_handle = osMessageQueueNew(PPP_QUEUE_LEN, PPP_QUEUE_ITEM_SIZE, NULL);
   1db8e:	0032      	movs	r2, r6
   1db90:	2104      	movs	r1, #4
   1db92:	2002      	movs	r0, #2
   1db94:	f7f6 ffb2 	bl	14afc <osMessageQueueNew>
   1db98:	4b33      	ldr	r3, [pc, #204]	; (1dc68 <pppd_go+0xf4>)
    {
        //Create our message queue
        ppp_create_queue();
        ppp_thread = sys_thread_new("ppp_thread", ppp_main, NULL, 800, osPriorityLow1);
   1db9a:	0032      	movs	r2, r6
    ppp_queue_handle = osMessageQueueNew(PPP_QUEUE_LEN, PPP_QUEUE_ITEM_SIZE, NULL);
   1db9c:	6018      	str	r0, [r3, #0]
        ppp_thread = sys_thread_new("ppp_thread", ppp_main, NULL, 800, osPriorityLow1);
   1db9e:	2309      	movs	r3, #9
   1dba0:	9300      	str	r3, [sp, #0]
   1dba2:	23c8      	movs	r3, #200	; 0xc8
   1dba4:	4931      	ldr	r1, [pc, #196]	; (1dc6c <pppd_go+0xf8>)
   1dba6:	009b      	lsls	r3, r3, #2
   1dba8:	4831      	ldr	r0, [pc, #196]	; (1dc70 <pppd_go+0xfc>)
   1dbaa:	f004 fe21 	bl	227f0 <sys_thread_new>
   1dbae:	6020      	str	r0, [r4, #0]
    }

    if (ppp_thread != NULL)
   1dbb0:	6823      	ldr	r3, [r4, #0]
   1dbb2:	2b00      	cmp	r3, #0
   1dbb4:	d050      	beq.n	1dc58 <pppd_go+0xe4>
    neul_lwip_serial_set_rx_callback(ppp_uart_callback);
   1dbb6:	482f      	ldr	r0, [pc, #188]	; (1dc74 <pppd_go+0x100>)
   1dbb8:	f004 fdf2 	bl	227a0 <neul_lwip_serial_set_rx_callback>
    ppp_uart_handler = sio_open(0);
   1dbbc:	2000      	movs	r0, #0
   1dbbe:	f004 fd75 	bl	226ac <sio_open>
   1dbc2:	4b2d      	ldr	r3, [pc, #180]	; (1dc78 <pppd_go+0x104>)
   1dbc4:	6018      	str	r0, [r3, #0]
    assert(ppp_uart_handler != NULL);
   1dbc6:	2800      	cmp	r0, #0
   1dbc8:	d103      	bne.n	1dbd2 <pppd_go+0x5e>
   1dbca:	0029      	movs	r1, r5
   1dbcc:	3016      	adds	r0, #22
   1dbce:	f7e3 ff9f 	bl	1b10 <panic>
    if (ppps == NULL)
   1dbd2:	4e2a      	ldr	r6, [pc, #168]	; (1dc7c <pppd_go+0x108>)
   1dbd4:	6833      	ldr	r3, [r6, #0]
   1dbd6:	2b00      	cmp	r3, #0
   1dbd8:	d124      	bne.n	1dc24 <pppd_go+0xb0>
        if (ppp_init() != 0)
   1dbda:	f000 f8af 	bl	1dd3c <ppp_init>
   1dbde:	2800      	cmp	r0, #0
   1dbe0:	d13a      	bne.n	1dc58 <pppd_go+0xe4>
        ip_addr_copy((pppd_netif.ip_addr), (ppp_ipaddr));
   1dbe2:	4b27      	ldr	r3, [pc, #156]	; (1dc80 <pppd_go+0x10c>)
   1dbe4:	4c27      	ldr	r4, [pc, #156]	; (1dc84 <pppd_go+0x110>)
   1dbe6:	7c19      	ldrb	r1, [r3, #16]
   1dbe8:	681a      	ldr	r2, [r3, #0]
   1dbea:	7521      	strb	r1, [r4, #20]
   1dbec:	6062      	str	r2, [r4, #4]
   1dbee:	2906      	cmp	r1, #6
   1dbf0:	d105      	bne.n	1dbfe <pppd_go+0x8a>
   1dbf2:	685a      	ldr	r2, [r3, #4]
   1dbf4:	60a2      	str	r2, [r4, #8]
   1dbf6:	689a      	ldr	r2, [r3, #8]
   1dbf8:	68db      	ldr	r3, [r3, #12]
   1dbfa:	60e2      	str	r2, [r4, #12]
   1dbfc:	6123      	str	r3, [r4, #16]
        ppps = pppos_create(&pppd_netif, ppp_output_cb_fn, linkStatusCB, NULL);
   1dbfe:	2300      	movs	r3, #0
   1dc00:	4a21      	ldr	r2, [pc, #132]	; (1dc88 <pppd_go+0x114>)
   1dc02:	4922      	ldr	r1, [pc, #136]	; (1dc8c <pppd_go+0x118>)
   1dc04:	0020      	movs	r0, r4
   1dc06:	f000 fc47 	bl	1e498 <pppos_create>
   1dc0a:	6030      	str	r0, [r6, #0]
        assert(ppps != NULL);
   1dc0c:	2800      	cmp	r0, #0
   1dc0e:	d103      	bne.n	1dc18 <pppd_go+0xa4>
   1dc10:	0029      	movs	r1, r5
   1dc12:	3016      	adds	r0, #22
   1dc14:	f7e3 ff7c 	bl	1b10 <panic>
        pppd_netif.num = 0;      //in slip the num is the serial bus ID being used
   1dc18:	2300      	movs	r3, #0
   1dc1a:	3451      	adds	r4, #81	; 0x51
        netif_ip4_socket_recv_notify_register(ppp_socket_callback);
   1dc1c:	481c      	ldr	r0, [pc, #112]	; (1dc90 <pppd_go+0x11c>)
        pppd_netif.num = 0;      //in slip the num is the serial bus ID being used
   1dc1e:	7023      	strb	r3, [r4, #0]
        netif_ip4_socket_recv_notify_register(ppp_socket_callback);
   1dc20:	f004 fbe6 	bl	223f0 <netif_ip4_socket_recv_notify_register>
    ppp_set_ipcp_ouraddr(ppps, (ip4_addr_t*) &local_fake_addr);
   1dc24:	6830      	ldr	r0, [r6, #0]
   1dc26:	4a1b      	ldr	r2, [pc, #108]	; (1dc94 <pppd_go+0x120>)
   1dc28:	0003      	movs	r3, r0
   1dc2a:	33f8      	adds	r3, #248	; 0xf8
   1dc2c:	601a      	str	r2, [r3, #0]
   1dc2e:	2301      	movs	r3, #1
   1dc30:	1cc2      	adds	r2, r0, #3
   1dc32:	7fd1      	ldrb	r1, [r2, #31]
   1dc34:	430b      	orrs	r3, r1
   1dc36:	77d3      	strb	r3, [r2, #31]
    ppp_set_ipcp_hisaddr(ppps, ip_2_ip4(&ppp_ipaddr));
   1dc38:	0003      	movs	r3, r0
   1dc3a:	4a11      	ldr	r2, [pc, #68]	; (1dc80 <pppd_go+0x10c>)
   1dc3c:	33fc      	adds	r3, #252	; 0xfc
   1dc3e:	6812      	ldr	r2, [r2, #0]
   1dc40:	601a      	str	r2, [r3, #0]
    ppp_set_asyncmap(ppps, 0xa0000);
   1dc42:	23a0      	movs	r3, #160	; 0xa0
   1dc44:	031b      	lsls	r3, r3, #12
   1dc46:	6443      	str	r3, [r0, #68]	; 0x44
    lwip_err = ppp_listen(ppps);
   1dc48:	f000 f862 	bl	1dd10 <ppp_listen>
    assert(lwip_err == 0);
   1dc4c:	2800      	cmp	r0, #0
   1dc4e:	d003      	beq.n	1dc58 <pppd_go+0xe4>
   1dc50:	0029      	movs	r1, r5
   1dc52:	2016      	movs	r0, #22
   1dc54:	f7e3 ff5c 	bl	1b10 <panic>
    {
        (void) ppp_setup();
    }
}
   1dc58:	bd73      	pop	{r0, r1, r4, r5, r6, pc}
   1dc5a:	46c0      	nop			; (mov r8, r8)
   1dc5c:	00025748 	.word	0x00025748
   1dc60:	01002cdd 	.word	0x01002cdd
   1dc64:	01002cfc 	.word	0x01002cfc
   1dc68:	01002cf8 	.word	0x01002cf8
   1dc6c:	0001d9a1 	.word	0x0001d9a1
   1dc70:	00025763 	.word	0x00025763
   1dc74:	0001d8b9 	.word	0x0001d8b9
   1dc78:	01002d00 	.word	0x01002d00
   1dc7c:	01002d58 	.word	0x01002d58
   1dc80:	01002ce4 	.word	0x01002ce4
   1dc84:	01002d04 	.word	0x01002d04
   1dc88:	0001d929 	.word	0x0001d929
   1dc8c:	0001d855 	.word	0x0001d855
   1dc90:	0001d8a1 	.word	0x0001d8a1
   1dc94:	010200c0 	.word	0x010200c0

0001dc98 <ppp_netif_init_cb>:
static err_t ppp_netif_init_cb(struct netif *netif) {
  netif->name[0] = 'p';
  netif->name[1] = 'p';
#if LWIP_IPV4
  /* FIXME: change that when netif_null_output_ip4() will materialize */
  netif->output = ppp_netif_output_ip4;
   1dc98:	4b05      	ldr	r3, [pc, #20]	; (1dcb0 <ppp_netif_init_cb+0x18>)
#endif /* LWIP_IPV4 */
#if PPP_IPV6_SUPPORT
  netif->output_ip6 = ppp_netif_output_ip6;
#endif /* PPP_IPV6_SUPPORT */
  netif->flags = NETIF_FLAG_UP;
   1dc9a:	4a06      	ldr	r2, [pc, #24]	; (1dcb4 <ppp_netif_init_cb+0x1c>)
  netif->output = ppp_netif_output_ip4;
   1dc9c:	6443      	str	r3, [r0, #68]	; 0x44
  netif->flags = NETIF_FLAG_UP;
   1dc9e:	0003      	movs	r3, r0
   1dca0:	334e      	adds	r3, #78	; 0x4e
   1dca2:	801a      	strh	r2, [r3, #0]
  netif->name[0] = 'p';
   1dca4:	2370      	movs	r3, #112	; 0x70
   1dca6:	3050      	adds	r0, #80	; 0x50
   1dca8:	7003      	strb	r3, [r0, #0]
#if LWIP_NETIF_HOSTNAME
  /* @todo: Initialize interface hostname */
  /* netif_set_hostname(netif, "lwip"); */
#endif /* LWIP_NETIF_HOSTNAME */
  return ERR_OK;
}
   1dcaa:	2000      	movs	r0, #0
   1dcac:	4770      	bx	lr
   1dcae:	46c0      	nop			; (mov r8, r8)
   1dcb0:	0001dce1 	.word	0x0001dce1
   1dcb4:	00007001 	.word	0x00007001

0001dcb8 <ppp_do_connect>:
  LWIP_ASSERT("pcb->phase == PPP_PHASE_DEAD || pcb->phase == PPP_PHASE_HOLDOFF", pcb->phase == PPP_PHASE_DEAD || pcb->phase == PPP_PHASE_HOLDOFF);
   1dcb8:	2202      	movs	r2, #2
static void ppp_do_connect(void *arg) {
   1dcba:	b570      	push	{r4, r5, r6, lr}
  LWIP_ASSERT("pcb->phase == PPP_PHASE_DEAD || pcb->phase == PPP_PHASE_HOLDOFF", pcb->phase == PPP_PHASE_DEAD || pcb->phase == PPP_PHASE_HOLDOFF);
   1dcbc:	1c45      	adds	r5, r0, #1
   1dcbe:	7feb      	ldrb	r3, [r5, #31]
static void ppp_do_connect(void *arg) {
   1dcc0:	0004      	movs	r4, r0
  LWIP_ASSERT("pcb->phase == PPP_PHASE_DEAD || pcb->phase == PPP_PHASE_HOLDOFF", pcb->phase == PPP_PHASE_DEAD || pcb->phase == PPP_PHASE_HOLDOFF);
   1dcc2:	4393      	bics	r3, r2
   1dcc4:	d003      	beq.n	1dcce <ppp_do_connect+0x16>
   1dcc6:	4671      	mov	r1, lr
   1dcc8:	2016      	movs	r0, #22
   1dcca:	f7e3 ff21 	bl	1b10 <panic>

/*
 * new_phase - signal the start of a new phase of pppd's operation.
 */
void new_phase(ppp_pcb *pcb, int p) {
  pcb->phase = p;
   1dcce:	2303      	movs	r3, #3
   1dcd0:	77eb      	strb	r3, [r5, #31]
  pcb->link_cb->connect(pcb, pcb->link_ctx_cb);
   1dcd2:	68e3      	ldr	r3, [r4, #12]
   1dcd4:	6921      	ldr	r1, [r4, #16]
   1dcd6:	681b      	ldr	r3, [r3, #0]
   1dcd8:	0020      	movs	r0, r4
   1dcda:	4798      	blx	r3
}
   1dcdc:	bd70      	pop	{r4, r5, r6, pc}
	...

0001dce0 <ppp_netif_output_ip4>:
static err_t ppp_netif_output_ip4(struct netif *netif, struct pbuf *pb, const ip4_addr_t *ipaddr) {
   1dce0:	b510      	push	{r4, lr}
   1dce2:	6c80      	ldr	r0, [r0, #72]	; 0x48
   1dce4:	000a      	movs	r2, r1
      || (protocol == PPP_IP && !pcb->if4_up)
   1dce6:	1cc3      	adds	r3, r0, #3
   1dce8:	7fdb      	ldrb	r3, [r3, #31]
   1dcea:	071b      	lsls	r3, r3, #28
   1dcec:	d408      	bmi.n	1dd00 <ppp_netif_output_ip4+0x20>
    PPPDEBUG(LOG_ERR, ("ppp_netif_output[%d]: link not up\n", pcb->netif->num));
   1dcee:	69c3      	ldr	r3, [r0, #28]
   1dcf0:	4806      	ldr	r0, [pc, #24]	; (1dd0c <ppp_netif_output_ip4+0x2c>)
   1dcf2:	3351      	adds	r3, #81	; 0x51
   1dcf4:	7819      	ldrb	r1, [r3, #0]
   1dcf6:	f004 fb09 	bl	2230c <lwip_support_log>
  err = ERR_RTE;
   1dcfa:	2004      	movs	r0, #4
   1dcfc:	4240      	negs	r0, r0
}
   1dcfe:	bd10      	pop	{r4, pc}
  err = pcb->link_cb->netif_output(pcb, pcb->link_ctx_cb, pb, protocol);
   1dd00:	68c3      	ldr	r3, [r0, #12]
   1dd02:	6901      	ldr	r1, [r0, #16]
   1dd04:	695c      	ldr	r4, [r3, #20]
   1dd06:	2321      	movs	r3, #33	; 0x21
   1dd08:	47a0      	blx	r4
   1dd0a:	e7f8      	b.n	1dcfe <ppp_netif_output_ip4+0x1e>
   1dd0c:	00025828 	.word	0x00025828

0001dd10 <ppp_listen>:
err_t ppp_listen(ppp_pcb *pcb) {
   1dd10:	b510      	push	{r4, lr}
  if (pcb->phase != PPP_PHASE_DEAD) {
   1dd12:	1c42      	adds	r2, r0, #1
   1dd14:	7fd4      	ldrb	r4, [r2, #31]
   1dd16:	2c00      	cmp	r4, #0
   1dd18:	d10a      	bne.n	1dd30 <ppp_listen+0x20>
  if (pcb->link_cb->listen) {
   1dd1a:	68c3      	ldr	r3, [r0, #12]
   1dd1c:	6859      	ldr	r1, [r3, #4]
   1dd1e:	2900      	cmp	r1, #0
   1dd20:	d009      	beq.n	1dd36 <ppp_listen+0x26>
  pcb->phase = p;
   1dd22:	2103      	movs	r1, #3
   1dd24:	77d1      	strb	r1, [r2, #31]
    pcb->link_cb->listen(pcb, pcb->link_ctx_cb);
   1dd26:	6901      	ldr	r1, [r0, #16]
   1dd28:	685b      	ldr	r3, [r3, #4]
   1dd2a:	4798      	blx	r3
    return ERR_OK;
   1dd2c:	0020      	movs	r0, r4
}
   1dd2e:	bd10      	pop	{r4, pc}
    return ERR_ALREADY;
   1dd30:	2009      	movs	r0, #9
  return ERR_IF;
   1dd32:	4240      	negs	r0, r0
   1dd34:	e7fb      	b.n	1dd2e <ppp_listen+0x1e>
   1dd36:	200c      	movs	r0, #12
   1dd38:	e7fb      	b.n	1dd32 <ppp_listen+0x22>
	...

0001dd3c <ppp_init>:
{
   1dd3c:	b510      	push	{r4, lr}
  LWIP_MEMPOOL_INIT(PPPOS_PCB);
   1dd3e:	4805      	ldr	r0, [pc, #20]	; (1dd54 <ppp_init+0x18>)
   1dd40:	f004 fb04 	bl	2234c <memp_init_pool>
  LWIP_MEMPOOL_INIT(PPP_PCB);
   1dd44:	4804      	ldr	r0, [pc, #16]	; (1dd58 <ppp_init+0x1c>)
   1dd46:	f004 fb01 	bl	2234c <memp_init_pool>
  magic_init();
   1dd4a:	f002 fdd9 	bl	20900 <magic_init>
}
   1dd4e:	2000      	movs	r0, #0
   1dd50:	bd10      	pop	{r4, pc}
   1dd52:	46c0      	nop			; (mov r8, r8)
   1dd54:	00025aa0 	.word	0x00025aa0
   1dd58:	00025788 	.word	0x00025788

0001dd5c <ppp_new>:
ppp_pcb *ppp_new(struct netif *pppif, const struct link_callbacks *callbacks, void *link_ctx_cb, ppp_link_status_cb_fn link_status_cb, void *ctx_cb) {
   1dd5c:	b5f0      	push	{r4, r5, r6, r7, lr}
   1dd5e:	b087      	sub	sp, #28
   1dd60:	0006      	movs	r6, r0
   1dd62:	9104      	str	r1, [sp, #16]
   1dd64:	9205      	str	r2, [sp, #20]
   1dd66:	1e1d      	subs	r5, r3, #0
  if (link_status_cb == NULL) {
   1dd68:	d103      	bne.n	1dd72 <ppp_new+0x16>
    return NULL;
   1dd6a:	2400      	movs	r4, #0
}
   1dd6c:	0020      	movs	r0, r4
   1dd6e:	b007      	add	sp, #28
   1dd70:	bdf0      	pop	{r4, r5, r6, r7, pc}
  pcb = (ppp_pcb*)LWIP_MEMPOOL_ALLOC(PPP_PCB);
   1dd72:	4f1d      	ldr	r7, [pc, #116]	; (1dde8 <ppp_new+0x8c>)
   1dd74:	0038      	movs	r0, r7
   1dd76:	f004 faea 	bl	2234e <memp_malloc_pool>
   1dd7a:	1e04      	subs	r4, r0, #0
  if (pcb == NULL) {
   1dd7c:	d0f5      	beq.n	1dd6a <ppp_new+0xe>
  memset(pcb, 0, sizeof(ppp_pcb));
   1dd7e:	2292      	movs	r2, #146	; 0x92
   1dd80:	2100      	movs	r1, #0
   1dd82:	0052      	lsls	r2, r2, #1
   1dd84:	f7e2 faac 	bl	2e0 <memset>
  pcb->settings.fsm_timeout_time = FSM_DEFTIMEOUT;
   1dd88:	4b18      	ldr	r3, [pc, #96]	; (1ddec <ppp_new+0x90>)
  pcb->netif = pppif;
   1dd8a:	61e6      	str	r6, [r4, #28]
  pcb->settings.fsm_timeout_time = FSM_DEFTIMEOUT;
   1dd8c:	6063      	str	r3, [r4, #4]
  pcb->settings.fsm_max_nak_loops = FSM_DEFMAXNAKLOOPS;
   1dd8e:	230a      	movs	r3, #10
   1dd90:	8123      	strh	r3, [r4, #8]
  pcb->settings.lcp_echo_interval = LCP_ECHOINTERVAL;
   1dd92:	3b07      	subs	r3, #7
   1dd94:	72a3      	strb	r3, [r4, #10]
  if (!netif_add(pcb->netif,
   1dd96:	2300      	movs	r3, #0
   1dd98:	4915      	ldr	r1, [pc, #84]	; (1ddf0 <ppp_new+0x94>)
   1dd9a:	9302      	str	r3, [sp, #8]
   1dd9c:	4b15      	ldr	r3, [pc, #84]	; (1ddf4 <ppp_new+0x98>)
   1dd9e:	9400      	str	r4, [sp, #0]
   1dda0:	9301      	str	r3, [sp, #4]
   1dda2:	4a15      	ldr	r2, [pc, #84]	; (1ddf8 <ppp_new+0x9c>)
   1dda4:	000b      	movs	r3, r1
   1dda6:	0030      	movs	r0, r6
   1dda8:	f004 fb28 	bl	223fc <netif_add>
   1ddac:	2800      	cmp	r0, #0
   1ddae:	d107      	bne.n	1ddc0 <ppp_new+0x64>
    LWIP_MEMPOOL_FREE(PPP_PCB, pcb);
   1ddb0:	0038      	movs	r0, r7
   1ddb2:	0021      	movs	r1, r4
   1ddb4:	f004 fad2 	bl	2235c <memp_free_pool>
    PPPDEBUG(LOG_ERR, ("ppp_new: netif_add failed\n"));
   1ddb8:	4810      	ldr	r0, [pc, #64]	; (1ddfc <ppp_new+0xa0>)
   1ddba:	f004 faa7 	bl	2230c <lwip_support_log>
   1ddbe:	e7d4      	b.n	1dd6a <ppp_new+0xe>
  pcb->link_cb = callbacks;
   1ddc0:	9b04      	ldr	r3, [sp, #16]
  pcb->link_status_cb = link_status_cb;
   1ddc2:	6165      	str	r5, [r4, #20]
  pcb->link_cb = callbacks;
   1ddc4:	60e3      	str	r3, [r4, #12]
  pcb->link_ctx_cb = link_ctx_cb;
   1ddc6:	9b05      	ldr	r3, [sp, #20]
   1ddc8:	4d0d      	ldr	r5, [pc, #52]	; (1de00 <ppp_new+0xa4>)
   1ddca:	6123      	str	r3, [r4, #16]
  pcb->ctx_cb = ctx_cb;
   1ddcc:	9b0c      	ldr	r3, [sp, #48]	; 0x30
   1ddce:	61a3      	str	r3, [r4, #24]
   1ddd0:	3504      	adds	r5, #4
  for (i = 0; (protp = protocols[i]) != NULL; ++i) {
   1ddd2:	1f2b      	subs	r3, r5, #4
   1ddd4:	681b      	ldr	r3, [r3, #0]
   1ddd6:	2b00      	cmp	r3, #0
   1ddd8:	d102      	bne.n	1dde0 <ppp_new+0x84>
  pcb->phase = p;
   1ddda:	1c62      	adds	r2, r4, #1
   1dddc:	77d3      	strb	r3, [r2, #31]
  return pcb;
   1ddde:	e7c5      	b.n	1dd6c <ppp_new+0x10>
      (*protp->init)(pcb);
   1dde0:	685b      	ldr	r3, [r3, #4]
   1dde2:	0020      	movs	r0, r4
   1dde4:	4798      	blx	r3
   1dde6:	e7f3      	b.n	1ddd0 <ppp_new+0x74>
   1dde8:	00025788 	.word	0x00025788
   1ddec:	05020a06 	.word	0x05020a06
   1ddf0:	0002570c 	.word	0x0002570c
   1ddf4:	0001dc99 	.word	0x0001dc99
   1ddf8:	00025720 	.word	0x00025720
   1ddfc:	0002584b 	.word	0x0002584b
   1de00:	00025894 	.word	0x00025894

0001de04 <ppp_start>:
  pcb->phase = p;
   1de04:	2206      	movs	r2, #6
void ppp_start(ppp_pcb *pcb) {
   1de06:	b510      	push	{r4, lr}
   1de08:	0004      	movs	r4, r0
  pcb->phase = p;
   1de0a:	1c43      	adds	r3, r0, #1
   1de0c:	77da      	strb	r2, [r3, #31]
  lcp_open(pcb);
   1de0e:	f002 f9c1 	bl	20194 <lcp_open>
  lcp_lowerup(pcb);
   1de12:	0020      	movs	r0, r4
   1de14:	f002 f802 	bl	1fe1c <lcp_lowerup>
}
   1de18:	bd10      	pop	{r4, pc}

0001de1a <ppp_link_end>:
  pcb->phase = p;
   1de1a:	2200      	movs	r2, #0
void ppp_link_end(ppp_pcb *pcb) {
   1de1c:	b510      	push	{r4, lr}
  pcb->phase = p;
   1de1e:	1c43      	adds	r3, r0, #1
   1de20:	77da      	strb	r2, [r3, #31]
  if (pcb->err_code == PPPERR_NONE) {
   1de22:	1c83      	adds	r3, r0, #2
   1de24:	7fda      	ldrb	r2, [r3, #31]
   1de26:	2a00      	cmp	r2, #0
   1de28:	d101      	bne.n	1de2e <ppp_link_end+0x14>
    pcb->err_code = PPPERR_CONNECT;
   1de2a:	3206      	adds	r2, #6
   1de2c:	77da      	strb	r2, [r3, #31]
  pcb->link_status_cb(pcb, pcb->err_code, pcb->ctx_cb);
   1de2e:	7fd9      	ldrb	r1, [r3, #31]
   1de30:	6982      	ldr	r2, [r0, #24]
   1de32:	6943      	ldr	r3, [r0, #20]
   1de34:	4798      	blx	r3
}
   1de36:	bd10      	pop	{r4, pc}

0001de38 <ppp_singlebuf>:
struct pbuf *ppp_singlebuf(struct pbuf *p) {
   1de38:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  if(p->tot_len == p->len) {
   1de3a:	8901      	ldrh	r1, [r0, #8]
   1de3c:	8943      	ldrh	r3, [r0, #10]
struct pbuf *ppp_singlebuf(struct pbuf *p) {
   1de3e:	0004      	movs	r4, r0
  if(p->tot_len == p->len) {
   1de40:	428b      	cmp	r3, r1
   1de42:	d009      	beq.n	1de58 <ppp_singlebuf+0x20>
  q = pbuf_alloc(PBUF_RAW, p->tot_len, PBUF_RAM);
   1de44:	2200      	movs	r2, #0
   1de46:	2004      	movs	r0, #4
   1de48:	f004 fb4a 	bl	224e0 <pbuf_alloc>
   1de4c:	1e06      	subs	r6, r0, #0
  if(!q) {
   1de4e:	d105      	bne.n	1de5c <ppp_singlebuf+0x24>
    PPPDEBUG(LOG_ERR,
   1de50:	8921      	ldrh	r1, [r4, #8]
   1de52:	480b      	ldr	r0, [pc, #44]	; (1de80 <ppp_singlebuf+0x48>)
   1de54:	f004 fa5a 	bl	2230c <lwip_support_log>
}
   1de58:	0020      	movs	r0, r4
   1de5a:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
  for(b = p, pl = (u8_t*)q->payload; b != NULL; b = b->next) {
   1de5c:	0025      	movs	r5, r4
   1de5e:	6847      	ldr	r7, [r0, #4]
    MEMCPY(pl, b->payload, b->len);
   1de60:	896a      	ldrh	r2, [r5, #10]
   1de62:	6869      	ldr	r1, [r5, #4]
   1de64:	0038      	movs	r0, r7
   1de66:	f7e2 f9c3 	bl	1f0 <memcpy>
    pl += b->len;
   1de6a:	896b      	ldrh	r3, [r5, #10]
  for(b = p, pl = (u8_t*)q->payload; b != NULL; b = b->next) {
   1de6c:	682d      	ldr	r5, [r5, #0]
    pl += b->len;
   1de6e:	18ff      	adds	r7, r7, r3
  for(b = p, pl = (u8_t*)q->payload; b != NULL; b = b->next) {
   1de70:	2d00      	cmp	r5, #0
   1de72:	d1f5      	bne.n	1de60 <ppp_singlebuf+0x28>
  pbuf_free(p);
   1de74:	0020      	movs	r0, r4
   1de76:	f004 fb6d 	bl	22554 <pbuf_free>
  return q;
   1de7a:	0034      	movs	r4, r6
   1de7c:	e7ec      	b.n	1de58 <ppp_singlebuf+0x20>
   1de7e:	46c0      	nop			; (mov r8, r8)
   1de80:	00025866 	.word	0x00025866

0001de84 <ppp_input>:
void ppp_input(ppp_pcb *pcb, struct pbuf *pb) {
   1de84:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
   1de86:	000c      	movs	r4, r1
   1de88:	0006      	movs	r6, r0
  magic_randomize();
   1de8a:	f002 fd43 	bl	20914 <magic_randomize>
  if (pb->len < 2) {
   1de8e:	8963      	ldrh	r3, [r4, #10]
   1de90:	2b01      	cmp	r3, #1
   1de92:	d809      	bhi.n	1dea8 <ppp_input+0x24>
    PPPDEBUG(LOG_ERR, ("ppp_input[%d]: packet too short\n", pcb->netif->num));
   1de94:	69f3      	ldr	r3, [r6, #28]
   1de96:	4829      	ldr	r0, [pc, #164]	; (1df3c <ppp_input+0xb8>)
   1de98:	3351      	adds	r3, #81	; 0x51
   1de9a:	7819      	ldrb	r1, [r3, #0]
   1de9c:	f004 fa36 	bl	2230c <lwip_support_log>
  pbuf_free(pb);
   1dea0:	0020      	movs	r0, r4
   1dea2:	f004 fb57 	bl	22554 <pbuf_free>
   1dea6:	e03a      	b.n	1df1e <ppp_input+0x9a>
  pbuf_header(pb, -(s16_t)sizeof(protocol));
   1dea8:	2102      	movs	r1, #2
  protocol = (((u8_t *)pb->payload)[0] << 8) | ((u8_t*)pb->payload)[1];
   1deaa:	6862      	ldr	r2, [r4, #4]
  pbuf_header(pb, -(s16_t)sizeof(protocol));
   1deac:	4249      	negs	r1, r1
  protocol = (((u8_t *)pb->payload)[0] << 8) | ((u8_t*)pb->payload)[1];
   1deae:	7813      	ldrb	r3, [r2, #0]
   1deb0:	7855      	ldrb	r5, [r2, #1]
   1deb2:	021b      	lsls	r3, r3, #8
   1deb4:	431d      	orrs	r5, r3
  pbuf_header(pb, -(s16_t)sizeof(protocol));
   1deb6:	0020      	movs	r0, r4
  protocol = (((u8_t *)pb->payload)[0] << 8) | ((u8_t*)pb->payload)[1];
   1deb8:	b22d      	sxth	r5, r5
  pbuf_header(pb, -(s16_t)sizeof(protocol));
   1deba:	f004 fb5a 	bl	22572 <pbuf_header>
  if (protocol != PPP_LCP && pcb->lcp_fsm.state != PPP_FSM_OPENED) {
   1debe:	4b20      	ldr	r3, [pc, #128]	; (1df40 <ppp_input+0xbc>)
  protocol = (((u8_t *)pb->payload)[0] << 8) | ((u8_t*)pb->payload)[1];
   1dec0:	b2af      	uxth	r7, r5
  if (protocol != PPP_LCP && pcb->lcp_fsm.state != PPP_FSM_OPENED) {
   1dec2:	429f      	cmp	r7, r3
   1dec4:	d008      	beq.n	1ded8 <ppp_input+0x54>
   1dec6:	0032      	movs	r2, r6
   1dec8:	3234      	adds	r2, #52	; 0x34
   1deca:	7812      	ldrb	r2, [r2, #0]
   1decc:	2a09      	cmp	r2, #9
   1dece:	d003      	beq.n	1ded8 <ppp_input+0x54>
    ppp_dbglog("Discarded non-LCP packet when LCP not open");
   1ded0:	481c      	ldr	r0, [pc, #112]	; (1df44 <ppp_input+0xc0>)
   1ded2:	f000 fe99 	bl	1ec08 <ppp_dbglog>
    goto drop;
   1ded6:	e7e3      	b.n	1dea0 <ppp_input+0x1c>
  if (pcb->phase <= PPP_PHASE_AUTHENTICATE
   1ded8:	1c72      	adds	r2, r6, #1
   1deda:	7fd2      	ldrb	r2, [r2, #31]
   1dedc:	2a07      	cmp	r2, #7
   1dede:	d806      	bhi.n	1deee <ppp_input+0x6a>
   && !(protocol == PPP_LCP
   1dee0:	429f      	cmp	r7, r3
   1dee2:	d004      	beq.n	1deee <ppp_input+0x6a>
    ppp_dbglog("discarding proto 0x%x in phase %d", protocol, pcb->phase);
   1dee4:	0039      	movs	r1, r7
   1dee6:	4818      	ldr	r0, [pc, #96]	; (1df48 <ppp_input+0xc4>)
   1dee8:	f000 fe8e 	bl	1ec08 <ppp_dbglog>
    goto drop;
   1deec:	e7d8      	b.n	1dea0 <ppp_input+0x1c>
  switch(protocol) {
   1deee:	2d21      	cmp	r5, #33	; 0x21
   1def0:	d011      	beq.n	1df16 <ppp_input+0x92>
        if (protp->protocol == protocol) {
   1def2:	4d16      	ldr	r5, [pc, #88]	; (1df4c <ppp_input+0xc8>)
   1def4:	882b      	ldrh	r3, [r5, #0]
   1def6:	42bb      	cmp	r3, r7
   1def8:	d003      	beq.n	1df02 <ppp_input+0x7e>
   1defa:	4d15      	ldr	r5, [pc, #84]	; (1df50 <ppp_input+0xcc>)
   1defc:	882b      	ldrh	r3, [r5, #0]
   1defe:	42bb      	cmp	r3, r7
   1df00:	d10e      	bne.n	1df20 <ppp_input+0x9c>
          pb = ppp_singlebuf(pb);
   1df02:	0020      	movs	r0, r4
   1df04:	f7ff ff98 	bl	1de38 <ppp_singlebuf>
          (*protp->input)(pcb, (u8_t*)pb->payload, pb->len);
   1df08:	68ab      	ldr	r3, [r5, #8]
          pb = ppp_singlebuf(pb);
   1df0a:	0004      	movs	r4, r0
          (*protp->input)(pcb, (u8_t*)pb->payload, pb->len);
   1df0c:	8942      	ldrh	r2, [r0, #10]
   1df0e:	6841      	ldr	r1, [r0, #4]
   1df10:	0030      	movs	r0, r6
   1df12:	4798      	blx	r3
          goto out;
   1df14:	e7c4      	b.n	1dea0 <ppp_input+0x1c>
      ip4_input(pb, pcb->netif);
   1df16:	69f1      	ldr	r1, [r6, #28]
   1df18:	0020      	movs	r0, r4
   1df1a:	f004 fab6 	bl	2248a <ip4_input>
}
   1df1e:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
        ppp_warn("Unsupported protocol 0x%x received", protocol);
   1df20:	0039      	movs	r1, r7
   1df22:	480c      	ldr	r0, [pc, #48]	; (1df54 <ppp_input+0xd0>)
   1df24:	f000 fe4c 	bl	1ebc0 <ppp_warn>
        pbuf_header(pb, (s16_t)sizeof(protocol));
   1df28:	2102      	movs	r1, #2
   1df2a:	0020      	movs	r0, r4
   1df2c:	f004 fb21 	bl	22572 <pbuf_header>
        lcp_sprotrej(pcb, (u8_t*)pb->payload, pb->len);
   1df30:	8962      	ldrh	r2, [r4, #10]
   1df32:	6861      	ldr	r1, [r4, #4]
   1df34:	0030      	movs	r0, r6
   1df36:	f002 fcd3 	bl	208e0 <lcp_sprotrej>
      break;
   1df3a:	e7b1      	b.n	1dea0 <ppp_input+0x1c>
   1df3c:	00025797 	.word	0x00025797
   1df40:	0000c021 	.word	0x0000c021
   1df44:	000257b8 	.word	0x000257b8
   1df48:	000257e3 	.word	0x000257e3
   1df4c:	00025fb0 	.word	0x00025fb0
   1df50:	00025c84 	.word	0x00025c84
   1df54:	00025805 	.word	0x00025805

0001df58 <ppp_write>:
err_t ppp_write(ppp_pcb *pcb, struct pbuf *p) {
   1df58:	b510      	push	{r4, lr}
  return pcb->link_cb->write(pcb, pcb->link_ctx_cb, p);
   1df5a:	68c3      	ldr	r3, [r0, #12]
err_t ppp_write(ppp_pcb *pcb, struct pbuf *p) {
   1df5c:	000a      	movs	r2, r1
  return pcb->link_cb->write(pcb, pcb->link_ctx_cb, p);
   1df5e:	691b      	ldr	r3, [r3, #16]
   1df60:	6901      	ldr	r1, [r0, #16]
   1df62:	4798      	blx	r3
}
   1df64:	bd10      	pop	{r4, pc}

0001df66 <ppp_link_terminated>:
void ppp_link_terminated(ppp_pcb *pcb) {
   1df66:	b510      	push	{r4, lr}
  pcb->link_cb->disconnect(pcb, pcb->link_ctx_cb);
   1df68:	68c3      	ldr	r3, [r0, #12]
   1df6a:	6901      	ldr	r1, [r0, #16]
   1df6c:	689b      	ldr	r3, [r3, #8]
   1df6e:	4798      	blx	r3
}
   1df70:	bd10      	pop	{r4, pc}
	...

0001df74 <ppp_close>:
  pcb->err_code = PPPERR_USER;
   1df74:	2305      	movs	r3, #5
{
   1df76:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
  pcb->err_code = PPPERR_USER;
   1df78:	1c87      	adds	r7, r0, #2
{
   1df7a:	9101      	str	r1, [sp, #4]
  pcb->err_code = PPPERR_USER;
   1df7c:	77fb      	strb	r3, [r7, #31]
  if (pcb->phase == PPP_PHASE_HOLDOFF) {
   1df7e:	1c46      	adds	r6, r0, #1
   1df80:	7ff3      	ldrb	r3, [r6, #31]
{
   1df82:	0005      	movs	r5, r0
  if (pcb->phase == PPP_PHASE_HOLDOFF) {
   1df84:	2b02      	cmp	r3, #2
   1df86:	d105      	bne.n	1df94 <ppp_close+0x20>
    sys_untimeout(ppp_do_connect, pcb);
   1df88:	0001      	movs	r1, r0
   1df8a:	4816      	ldr	r0, [pc, #88]	; (1dfe4 <ppp_close+0x70>)
   1df8c:	f004 fcd6 	bl	2293c <sys_untimeout>
  pcb->phase = p;
   1df90:	2300      	movs	r3, #0
   1df92:	77f3      	strb	r3, [r6, #31]
  if (pcb->phase == PPP_PHASE_DEAD) {
   1df94:	7ff4      	ldrb	r4, [r6, #31]
   1df96:	2c00      	cmp	r4, #0
   1df98:	d106      	bne.n	1dfa8 <ppp_close+0x34>
    pcb->link_status_cb(pcb, pcb->err_code, pcb->ctx_cb);
   1df9a:	7ff9      	ldrb	r1, [r7, #31]
   1df9c:	696b      	ldr	r3, [r5, #20]
   1df9e:	69aa      	ldr	r2, [r5, #24]
   1dfa0:	0028      	movs	r0, r5
   1dfa2:	4798      	blx	r3
  return ERR_OK;
   1dfa4:	2000      	movs	r0, #0
}
   1dfa6:	bdfe      	pop	{r1, r2, r3, r4, r5, r6, r7, pc}
  if (pcb->phase >= PPP_PHASE_TERMINATE) {
   1dfa8:	2c0a      	cmp	r4, #10
   1dfaa:	d818      	bhi.n	1dfde <ppp_close+0x6a>
  if (pcb->phase < PPP_PHASE_ESTABLISH) {
   1dfac:	2c05      	cmp	r4, #5
   1dfae:	d805      	bhi.n	1dfbc <ppp_close+0x48>
  pcb->phase = p;
   1dfb0:	230c      	movs	r3, #12
    ppp_link_terminated(pcb);
   1dfb2:	0028      	movs	r0, r5
  pcb->phase = p;
   1dfb4:	77f3      	strb	r3, [r6, #31]
    ppp_link_terminated(pcb);
   1dfb6:	f7ff ffd6 	bl	1df66 <ppp_link_terminated>
   1dfba:	e7f3      	b.n	1dfa4 <ppp_close+0x30>
  if (nocarrier && pcb->phase == PPP_PHASE_RUNNING) {
   1dfbc:	9b01      	ldr	r3, [sp, #4]
   1dfbe:	2b00      	cmp	r3, #0
   1dfc0:	d008      	beq.n	1dfd4 <ppp_close+0x60>
   1dfc2:	2c0a      	cmp	r4, #10
   1dfc4:	d106      	bne.n	1dfd4 <ppp_close+0x60>
    lcp_lowerdown(pcb);
   1dfc6:	0028      	movs	r0, r5
   1dfc8:	f002 fc02 	bl	207d0 <lcp_lowerdown>
    link_terminated(pcb);
   1dfcc:	0028      	movs	r0, r5
   1dfce:	f000 fe29 	bl	1ec24 <link_terminated>
   1dfd2:	e7e7      	b.n	1dfa4 <ppp_close+0x30>
  lcp_close(pcb, "User request");
   1dfd4:	4904      	ldr	r1, [pc, #16]	; (1dfe8 <ppp_close+0x74>)
   1dfd6:	0028      	movs	r0, r5
   1dfd8:	f002 f8f6 	bl	201c8 <lcp_close>
   1dfdc:	e7e2      	b.n	1dfa4 <ppp_close+0x30>
    return ERR_INPROGRESS;
   1dfde:	2005      	movs	r0, #5
   1dfe0:	4240      	negs	r0, r0
   1dfe2:	e7e0      	b.n	1dfa6 <ppp_close+0x32>
   1dfe4:	0001dcb9 	.word	0x0001dcb9
   1dfe8:	0002578a 	.word	0x0002578a

0001dfec <new_phase>:
  pcb->phase = p;
   1dfec:	3001      	adds	r0, #1
   1dfee:	77c1      	strb	r1, [r0, #31]
#if PPP_NOTIFY_PHASE
  if (pcb->notify_phase_cb != NULL) {
    pcb->notify_phase_cb(pcb, p, pcb->ctx_cb);
  }
#endif /* PPP_NOTIFY_PHASE */
}
   1dff0:	4770      	bx	lr

0001dff2 <ppp_send_config>:

/*
 * ppp_send_config - configure the transmit-side characteristics of
 * the ppp interface.
 */
int ppp_send_config(ppp_pcb *pcb, int mtu, u32_t accm, int pcomp, int accomp) {
   1dff2:	b513      	push	{r0, r1, r4, lr}
  LWIP_UNUSED_ARG(mtu);
  /* pcb->mtu = mtu; -- set correctly with netif_set_mtu */

  if (pcb->link_cb->send_config) {
   1dff4:	68c1      	ldr	r1, [r0, #12]
   1dff6:	698c      	ldr	r4, [r1, #24]
   1dff8:	2c00      	cmp	r4, #0
   1dffa:	d003      	beq.n	1e004 <ppp_send_config+0x12>
    pcb->link_cb->send_config(pcb, pcb->link_ctx_cb, accm, pcomp, accomp);
   1dffc:	9904      	ldr	r1, [sp, #16]
   1dffe:	9100      	str	r1, [sp, #0]
   1e000:	6901      	ldr	r1, [r0, #16]
   1e002:	47a0      	blx	r4
  }

  PPPDEBUG(LOG_INFO, ("ppp_send_config[%d]\n", pcb->netif->num) );
  return 0;
}
   1e004:	2000      	movs	r0, #0
   1e006:	bd16      	pop	{r1, r2, r4, pc}

0001e008 <ppp_recv_config>:

/*
 * ppp_recv_config - configure the receive-side characteristics of
 * the ppp interface.
 */
int ppp_recv_config(ppp_pcb *pcb, int mru, u32_t accm, int pcomp, int accomp) {
   1e008:	b513      	push	{r0, r1, r4, lr}
  LWIP_UNUSED_ARG(mru);

  if (pcb->link_cb->recv_config) {
   1e00a:	68c1      	ldr	r1, [r0, #12]
   1e00c:	69cc      	ldr	r4, [r1, #28]
   1e00e:	2c00      	cmp	r4, #0
   1e010:	d003      	beq.n	1e01a <ppp_recv_config+0x12>
    pcb->link_cb->recv_config(pcb, pcb->link_ctx_cb, accm, pcomp, accomp);
   1e012:	9904      	ldr	r1, [sp, #16]
   1e014:	9100      	str	r1, [sp, #0]
   1e016:	6901      	ldr	r1, [r0, #16]
   1e018:	47a0      	blx	r4
  }

  PPPDEBUG(LOG_INFO, ("ppp_recv_config[%d]\n", pcb->netif->num));
  return 0;
}
   1e01a:	2000      	movs	r0, #0
   1e01c:	bd16      	pop	{r1, r2, r4, pc}

0001e01e <sifaddr>:

#if PPP_IPV4_SUPPORT
/*
 * sifaddr - Config the interface IP addresses and netmask.
 */
int sifaddr(ppp_pcb *pcb, u32_t our_adr, u32_t his_adr, u32_t netmask) {
   1e01e:	b51f      	push	{r0, r1, r2, r3, r4, lr}
  ip4_addr_t ip, nm, gw;

  ip4_addr_set_u32(&ip, our_adr);
   1e020:	9101      	str	r1, [sp, #4]
  ip4_addr_set_u32(&nm, netmask);
   1e022:	9302      	str	r3, [sp, #8]
  ip4_addr_set_u32(&gw, his_adr);
   1e024:	9203      	str	r2, [sp, #12]
  netif_set_addr(pcb->netif, &ip, &nm, &gw);
   1e026:	ab03      	add	r3, sp, #12
   1e028:	aa02      	add	r2, sp, #8
   1e02a:	a901      	add	r1, sp, #4
   1e02c:	69c0      	ldr	r0, [r0, #28]
   1e02e:	f004 fa29 	bl	22484 <netif_set_addr>
  return 1;
}
   1e032:	2001      	movs	r0, #1
   1e034:	b005      	add	sp, #20
   1e036:	bd00      	pop	{pc}

0001e038 <cifaddr>:
/********************************************************************
 *
 * cifaddr - Clear the interface IP addresses, and delete routes
 * through the interface if possible.
 */
int cifaddr(ppp_pcb *pcb, u32_t our_adr, u32_t his_adr) {
   1e038:	b510      	push	{r4, lr}
  LWIP_UNUSED_ARG(our_adr);
  LWIP_UNUSED_ARG(his_adr);

  netif_set_addr(pcb->netif, IP4_ADDR_ANY4, IP4_ADDR_BROADCAST, IP4_ADDR_ANY4);
   1e03a:	4904      	ldr	r1, [pc, #16]	; (1e04c <cifaddr+0x14>)
   1e03c:	69c0      	ldr	r0, [r0, #28]
   1e03e:	000b      	movs	r3, r1
   1e040:	4a03      	ldr	r2, [pc, #12]	; (1e050 <cifaddr+0x18>)
   1e042:	f004 fa1f 	bl	22484 <netif_set_addr>
  return 1;
}
   1e046:	2001      	movs	r0, #1
   1e048:	bd10      	pop	{r4, pc}
   1e04a:	46c0      	nop			; (mov r8, r8)
   1e04c:	0002570c 	.word	0x0002570c
   1e050:	00025720 	.word	0x00025720

0001e054 <sifup>:

/*
 * sifup - Config the interface up and enable IP packets to pass.
 */
int sifup(ppp_pcb *pcb) {
  pcb->if4_up = 1;
   1e054:	2308      	movs	r3, #8
int sifup(ppp_pcb *pcb) {
   1e056:	b570      	push	{r4, r5, r6, lr}
  pcb->if4_up = 1;
   1e058:	1cc2      	adds	r2, r0, #3
   1e05a:	7fd1      	ldrb	r1, [r2, #31]
int sifup(ppp_pcb *pcb) {
   1e05c:	0004      	movs	r4, r0
  pcb->if4_up = 1;
   1e05e:	430b      	orrs	r3, r1
   1e060:	77d3      	strb	r3, [r2, #31]
  pcb->err_code = PPPERR_NONE;
   1e062:	2300      	movs	r3, #0
   1e064:	1c85      	adds	r5, r0, #2
   1e066:	77eb      	strb	r3, [r5, #31]
  netif_set_link_up(pcb->netif);
   1e068:	69c0      	ldr	r0, [r0, #28]
   1e06a:	f004 fa0c 	bl	22486 <netif_set_link_up>

  PPPDEBUG(LOG_DEBUG, ("sifup[%d]: err_code=%d\n", pcb->netif->num, pcb->err_code));
  pcb->link_status_cb(pcb, pcb->err_code, pcb->ctx_cb);
   1e06e:	7fe9      	ldrb	r1, [r5, #31]
   1e070:	0020      	movs	r0, r4
   1e072:	6963      	ldr	r3, [r4, #20]
   1e074:	69a2      	ldr	r2, [r4, #24]
   1e076:	4798      	blx	r3
  return 1;
}
   1e078:	2001      	movs	r0, #1
   1e07a:	bd70      	pop	{r4, r5, r6, pc}

0001e07c <sifdown>:
 * sifdown - Disable the indicated protocol and config the interface
 *           down if there are no remaining protocols.
 */
int sifdown(ppp_pcb *pcb) {

  pcb->if4_up = 0;
   1e07c:	2108      	movs	r1, #8
int sifdown(ppp_pcb *pcb) {
   1e07e:	b510      	push	{r4, lr}
  pcb->if4_up = 0;
   1e080:	1cc2      	adds	r2, r0, #3
   1e082:	7fd3      	ldrb	r3, [r2, #31]
   1e084:	438b      	bics	r3, r1
   1e086:	77d3      	strb	r3, [r2, #31]
   /* set the interface down if IPv6 is down as well */
   && !pcb->if6_up
#endif /* PPP_IPV6_SUPPORT */
  ) {
    /* make sure the netif link callback is called */
    netif_set_link_down(pcb->netif);
   1e088:	69c0      	ldr	r0, [r0, #28]
   1e08a:	f004 f9fd 	bl	22488 <netif_set_link_down>
  }
  PPPDEBUG(LOG_DEBUG, ("sifdown[%d]: err_code=%d\n", pcb->netif->num, pcb->err_code));
  return 1;
}
   1e08e:	2001      	movs	r0, #1
   1e090:	bd10      	pop	{r4, pc}

0001e092 <get_mask>:
   */
  /* return mask; */
  return mask;
#endif /* 0 */
  LWIP_UNUSED_ARG(addr);
  return IPADDR_BROADCAST;
   1e092:	2001      	movs	r0, #1
}
   1e094:	4240      	negs	r0, r0
   1e096:	4770      	bx	lr

0001e098 <netif_set_mtu>:
/*
 * netif_set_mtu - set the MTU on the PPP network interface.
 */
void netif_set_mtu(ppp_pcb *pcb, int mtu) {

  pcb->netif->mtu = mtu;
   1e098:	69c3      	ldr	r3, [r0, #28]
   1e09a:	334c      	adds	r3, #76	; 0x4c
   1e09c:	8019      	strh	r1, [r3, #0]
  PPPDEBUG(LOG_INFO, ("netif_set_mtu[%d]: mtu=%d\n", pcb->netif->num, mtu));
}
   1e09e:	4770      	bx	lr

0001e0a0 <pppos_send_config>:
}
#endif /* PPP_INPROC_IRQ_SAFE */

static void
pppos_send_config(ppp_pcb *ppp, void *ctx, u32_t accm, int pcomp, int accomp)
{
   1e0a0:	b570      	push	{r4, r5, r6, lr}
  int i;
  pppos_pcb *pppos = (pppos_pcb *)ctx;
  LWIP_UNUSED_ARG(ppp);

  pppos->pcomp = pcomp;
   1e0a2:	2001      	movs	r0, #1
   1e0a4:	000c      	movs	r4, r1
   1e0a6:	2602      	movs	r6, #2
   1e0a8:	342c      	adds	r4, #44	; 0x2c
   1e0aa:	4003      	ands	r3, r0
   1e0ac:	005d      	lsls	r5, r3, #1
   1e0ae:	7823      	ldrb	r3, [r4, #0]
   1e0b0:	43b3      	bics	r3, r6
  pppos->accomp = accomp;
   1e0b2:	432b      	orrs	r3, r5
   1e0b4:	2504      	movs	r5, #4
   1e0b6:	9e04      	ldr	r6, [sp, #16]
   1e0b8:	43ab      	bics	r3, r5
   1e0ba:	4030      	ands	r0, r6
   1e0bc:	0080      	lsls	r0, r0, #2
   1e0be:	4303      	orrs	r3, r0
   1e0c0:	7023      	strb	r3, [r4, #0]

  /* Load the ACCM bits for the 32 control codes. */
  for (i = 0; i < 32/8; i++) {
    pppos->out_accm[i] = (u8_t)((accm >> (8 * i)) & 0xFF);
   1e0c2:	0a13      	lsrs	r3, r2, #8
   1e0c4:	730a      	strb	r2, [r1, #12]
   1e0c6:	734b      	strb	r3, [r1, #13]
   1e0c8:	0c13      	lsrs	r3, r2, #16
   1e0ca:	0e12      	lsrs	r2, r2, #24
   1e0cc:	738b      	strb	r3, [r1, #14]
   1e0ce:	73ca      	strb	r2, [r1, #15]
  }

  PPPDEBUG(LOG_INFO, ("pppos_send_config[%d]: out_accm=%X %X %X %X\n",
            pppos->ppp->netif->num,
            pppos->out_accm[0], pppos->out_accm[1], pppos->out_accm[2], pppos->out_accm[3]));
}
   1e0d0:	bd70      	pop	{r4, r5, r6, pc}

0001e0d2 <pppos_recv_config>:
  LWIP_UNUSED_ARG(accomp);

  /* Load the ACCM bits for the 32 control codes. */
  PPPOS_PROTECT(lev);
  for (i = 0; i < 32 / 8; i++) {
    pppos->in_accm[i] = (u8_t)(accm >> (i * 8));
   1e0d2:	000b      	movs	r3, r1
   1e0d4:	0a10      	lsrs	r0, r2, #8
   1e0d6:	332d      	adds	r3, #45	; 0x2d
   1e0d8:	701a      	strb	r2, [r3, #0]
   1e0da:	7058      	strb	r0, [r3, #1]
   1e0dc:	3130      	adds	r1, #48	; 0x30
   1e0de:	0c10      	lsrs	r0, r2, #16
   1e0e0:	0e12      	lsrs	r2, r2, #24
   1e0e2:	7098      	strb	r0, [r3, #2]
   1e0e4:	700a      	strb	r2, [r1, #0]
  PPPOS_UNPROTECT(lev);

  PPPDEBUG(LOG_INFO, ("pppos_recv_config[%d]: in_accm=%X %X %X %X\n",
            pppos->ppp->netif->num,
            pppos->in_accm[0], pppos->in_accm[1], pppos->in_accm[2], pppos->in_accm[3]));
}
   1e0e6:	4770      	bx	lr

0001e0e8 <pppos_destroy>:
{
   1e0e8:	b510      	push	{r4, lr}
  LWIP_MEMPOOL_FREE(PPPOS_PCB, pppos);
   1e0ea:	4802      	ldr	r0, [pc, #8]	; (1e0f4 <pppos_destroy+0xc>)
   1e0ec:	f004 f936 	bl	2235c <memp_free_pool>
}
   1e0f0:	2000      	movs	r0, #0
   1e0f2:	bd10      	pop	{r4, pc}
   1e0f4:	00025aa0 	.word	0x00025aa0

0001e0f8 <pppos_input_free_current_packet>:
/*
 * Drop the input packet.
 */
static void
pppos_input_free_current_packet(pppos_pcb *pppos)
{
   1e0f8:	b510      	push	{r4, lr}
  if (pppos->in_head != NULL) {
   1e0fa:	6d03      	ldr	r3, [r0, #80]	; 0x50
{
   1e0fc:	0004      	movs	r4, r0
  if (pppos->in_head != NULL) {
   1e0fe:	2b00      	cmp	r3, #0
   1e100:	d00b      	beq.n	1e11a <pppos_input_free_current_packet+0x22>
    if (pppos->in_tail && (pppos->in_tail != pppos->in_head)) {
   1e102:	6d40      	ldr	r0, [r0, #84]	; 0x54
   1e104:	2800      	cmp	r0, #0
   1e106:	d003      	beq.n	1e110 <pppos_input_free_current_packet+0x18>
   1e108:	4283      	cmp	r3, r0
   1e10a:	d001      	beq.n	1e110 <pppos_input_free_current_packet+0x18>
      pbuf_free(pppos->in_tail);
   1e10c:	f004 fa22 	bl	22554 <pbuf_free>
    }
    pbuf_free(pppos->in_head);
   1e110:	6d20      	ldr	r0, [r4, #80]	; 0x50
   1e112:	f004 fa1f 	bl	22554 <pbuf_free>
    pppos->in_head = NULL;
   1e116:	2300      	movs	r3, #0
   1e118:	6523      	str	r3, [r4, #80]	; 0x50
  }
  pppos->in_tail = NULL;
   1e11a:	2300      	movs	r3, #0
   1e11c:	6563      	str	r3, [r4, #84]	; 0x54
}
   1e11e:	bd10      	pop	{r4, pc}

0001e120 <pppos_disconnect>:
  pppos->open = 0;
   1e120:	000a      	movs	r2, r1
{
   1e122:	b510      	push	{r4, lr}
   1e124:	0004      	movs	r4, r0
  pppos->open = 0;
   1e126:	2001      	movs	r0, #1
   1e128:	322c      	adds	r2, #44	; 0x2c
   1e12a:	7813      	ldrb	r3, [r2, #0]
   1e12c:	4383      	bics	r3, r0
   1e12e:	7013      	strb	r3, [r2, #0]
  pppos_input_free_current_packet(pppos);
   1e130:	0008      	movs	r0, r1
   1e132:	f7ff ffe1 	bl	1e0f8 <pppos_input_free_current_packet>
  ppp_link_end(ppp); /* notify upper layers */
   1e136:	0020      	movs	r0, r4
   1e138:	f7ff fe6f 	bl	1de1a <ppp_link_end>
}
   1e13c:	bd10      	pop	{r4, pc}

0001e13e <pppos_connect>:
{
   1e13e:	b570      	push	{r4, r5, r6, lr}
   1e140:	0005      	movs	r5, r0
  memset(&pppos->last_xmit, 0, sizeof(pppos_pcb) - offsetof(pppos_pcb, last_xmit));
   1e142:	0008      	movs	r0, r1
{
   1e144:	000c      	movs	r4, r1
  memset(&pppos->last_xmit, 0, sizeof(pppos_pcb) - offsetof(pppos_pcb, last_xmit));
   1e146:	2258      	movs	r2, #88	; 0x58
   1e148:	2100      	movs	r1, #0
   1e14a:	3008      	adds	r0, #8
   1e14c:	f7e2 f8c8 	bl	2e0 <memset>
  pppos->in_accm[15] = 0x60; /* no need to protect since RX is not running */
   1e150:	0022      	movs	r2, r4
   1e152:	2360      	movs	r3, #96	; 0x60
   1e154:	323c      	adds	r2, #60	; 0x3c
   1e156:	7013      	strb	r3, [r2, #0]
  pppos->out_accm[15] = 0x60;
   1e158:	76e3      	strb	r3, [r4, #27]
  pppos->open = 1;
   1e15a:	342c      	adds	r4, #44	; 0x2c
   1e15c:	7822      	ldrb	r2, [r4, #0]
   1e15e:	3b5f      	subs	r3, #95	; 0x5f
   1e160:	4313      	orrs	r3, r2
  ppp_start(ppp); /* notify upper layers */
   1e162:	0028      	movs	r0, r5
  pppos->open = 1;
   1e164:	7023      	strb	r3, [r4, #0]
  ppp_start(ppp); /* notify upper layers */
   1e166:	f7ff fe4d 	bl	1de04 <ppp_start>
}
   1e16a:	bd70      	pop	{r4, r5, r6, pc}

0001e16c <pppos_listen>:
   1e16c:	b510      	push	{r4, lr}
   1e16e:	f7ff ffe6 	bl	1e13e <pppos_connect>
   1e172:	bd10      	pop	{r4, pc}

0001e174 <pppos_output_append>:
 * If pbuf is full, send the pbuf and reuse it.
 * Return the current pbuf.
 */
static err_t
pppos_output_append(pppos_pcb *pppos, err_t err, struct pbuf *nb, u8_t c, u8_t accm, u16_t *fcs)
{
   1e174:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
   1e176:	001d      	movs	r5, r3
   1e178:	ab08      	add	r3, sp, #32
   1e17a:	781b      	ldrb	r3, [r3, #0]
   1e17c:	0006      	movs	r6, r0
   1e17e:	9100      	str	r1, [sp, #0]
   1e180:	0014      	movs	r4, r2
   1e182:	9301      	str	r3, [sp, #4]
  if (err != ERR_OK) {
   1e184:	2900      	cmp	r1, #0
   1e186:	d137      	bne.n	1e1f8 <pppos_output_append+0x84>
  }

  /* Make sure there is room for the character and an escape code.
   * Sure we don't quite fill the buffer if the character doesn't
   * get escaped but is one character worth complicating this? */
  if ((PBUF_POOL_BUFSIZE - nb->len) < 2) {
   1e188:	8952      	ldrh	r2, [r2, #10]
   1e18a:	4b20      	ldr	r3, [pc, #128]	; (1e20c <pppos_output_append+0x98>)
   1e18c:	1a9b      	subs	r3, r3, r2
   1e18e:	2b01      	cmp	r3, #1
   1e190:	d80a      	bhi.n	1e1a8 <pppos_output_append+0x34>
    u32_t l = pppos->output_cb(pppos->ppp, (u8_t*)nb->payload, nb->len, pppos->ppp->ctx_cb);
   1e192:	6800      	ldr	r0, [r0, #0]
   1e194:	6861      	ldr	r1, [r4, #4]
   1e196:	6983      	ldr	r3, [r0, #24]
   1e198:	6877      	ldr	r7, [r6, #4]
   1e19a:	47b8      	blx	r7
    if (l != nb->len) {
   1e19c:	8963      	ldrh	r3, [r4, #10]
   1e19e:	4283      	cmp	r3, r0
   1e1a0:	d12f      	bne.n	1e202 <pppos_output_append+0x8e>
      return ERR_IF;
    }
    nb->len = 0;
   1e1a2:	466b      	mov	r3, sp
   1e1a4:	881b      	ldrh	r3, [r3, #0]
   1e1a6:	8163      	strh	r3, [r4, #10]
  }

  /* Update FCS before checking for special characters. */
  if (fcs) {
   1e1a8:	9b09      	ldr	r3, [sp, #36]	; 0x24
   1e1aa:	2b00      	cmp	r3, #0
   1e1ac:	d00a      	beq.n	1e1c4 <pppos_output_append+0x50>
    *fcs = PPP_FCS(*fcs, c);
   1e1ae:	881a      	ldrh	r2, [r3, #0]
   1e1b0:	4917      	ldr	r1, [pc, #92]	; (1e210 <pppos_output_append+0x9c>)
   1e1b2:	0013      	movs	r3, r2
   1e1b4:	406b      	eors	r3, r5
   1e1b6:	b2db      	uxtb	r3, r3
   1e1b8:	005b      	lsls	r3, r3, #1
   1e1ba:	5a5b      	ldrh	r3, [r3, r1]
   1e1bc:	0a12      	lsrs	r2, r2, #8
   1e1be:	405a      	eors	r2, r3
   1e1c0:	9b09      	ldr	r3, [sp, #36]	; 0x24
   1e1c2:	801a      	strh	r2, [r3, #0]
   1e1c4:	8963      	ldrh	r3, [r4, #10]
   1e1c6:	6861      	ldr	r1, [r4, #4]
   1e1c8:	1c5a      	adds	r2, r3, #1
   1e1ca:	18cb      	adds	r3, r1, r3
  }

  /* Copy to output buffer escaping special characters. */
  if (accm && ESCAPE_P(pppos->out_accm, c)) {
   1e1cc:	9901      	ldr	r1, [sp, #4]
   1e1ce:	b292      	uxth	r2, r2
   1e1d0:	2900      	cmp	r1, #0
   1e1d2:	d013      	beq.n	1e1fc <pppos_output_append+0x88>
   1e1d4:	2007      	movs	r0, #7
   1e1d6:	08e9      	lsrs	r1, r5, #3
   1e1d8:	1876      	adds	r6, r6, r1
   1e1da:	7b31      	ldrb	r1, [r6, #12]
   1e1dc:	4028      	ands	r0, r5
   1e1de:	4101      	asrs	r1, r0
   1e1e0:	07c9      	lsls	r1, r1, #31
   1e1e2:	d50b      	bpl.n	1e1fc <pppos_output_append+0x88>
    *((u8_t*)nb->payload + nb->len++) = PPP_ESCAPE;
   1e1e4:	8162      	strh	r2, [r4, #10]
   1e1e6:	227d      	movs	r2, #125	; 0x7d
   1e1e8:	701a      	strb	r2, [r3, #0]
    *((u8_t*)nb->payload + nb->len++) = c ^ PPP_TRANS;
   1e1ea:	8962      	ldrh	r2, [r4, #10]
   1e1ec:	6861      	ldr	r1, [r4, #4]
   1e1ee:	1c53      	adds	r3, r2, #1
   1e1f0:	8163      	strh	r3, [r4, #10]
   1e1f2:	2320      	movs	r3, #32
   1e1f4:	405d      	eors	r5, r3
   1e1f6:	548d      	strb	r5, [r1, r2]
  } else {
    *((u8_t*)nb->payload + nb->len++) = c;
  }

  return ERR_OK;
}
   1e1f8:	9800      	ldr	r0, [sp, #0]
   1e1fa:	bdfe      	pop	{r1, r2, r3, r4, r5, r6, r7, pc}
    *((u8_t*)nb->payload + nb->len++) = c;
   1e1fc:	8162      	strh	r2, [r4, #10]
   1e1fe:	701d      	strb	r5, [r3, #0]
   1e200:	e7fa      	b.n	1e1f8 <pppos_output_append+0x84>
      return ERR_IF;
   1e202:	230c      	movs	r3, #12
   1e204:	425b      	negs	r3, r3
   1e206:	9300      	str	r3, [sp, #0]
   1e208:	e7f6      	b.n	1e1f8 <pppos_output_append+0x84>
   1e20a:	46c0      	nop			; (mov r8, r8)
   1e20c:	000005dc 	.word	0x000005dc
   1e210:	000258a0 	.word	0x000258a0

0001e214 <pppos_output_last>:

static err_t
pppos_output_last(pppos_pcb *pppos, err_t err, struct pbuf *nb, u16_t *fcs)
{
   1e214:	b5f0      	push	{r4, r5, r6, r7, lr}
   1e216:	b085      	sub	sp, #20
   1e218:	9303      	str	r3, [sp, #12]
  ppp_pcb *ppp = pppos->ppp;

  /* Add FCS and trailing flag. */
  err = pppos_output_append(pppos, err,  nb, ~(*fcs) & 0xFF, 1, NULL);
   1e21a:	881b      	ldrh	r3, [r3, #0]
   1e21c:	2600      	movs	r6, #0
{
   1e21e:	0014      	movs	r4, r2
  err = pppos_output_append(pppos, err,  nb, ~(*fcs) & 0xFF, 1, NULL);
   1e220:	43db      	mvns	r3, r3
   1e222:	2201      	movs	r2, #1
  ppp_pcb *ppp = pppos->ppp;
   1e224:	6807      	ldr	r7, [r0, #0]
  err = pppos_output_append(pppos, err,  nb, ~(*fcs) & 0xFF, 1, NULL);
   1e226:	b2db      	uxtb	r3, r3
   1e228:	9601      	str	r6, [sp, #4]
   1e22a:	9200      	str	r2, [sp, #0]
   1e22c:	0022      	movs	r2, r4
{
   1e22e:	0005      	movs	r5, r0
  err = pppos_output_append(pppos, err,  nb, ~(*fcs) & 0xFF, 1, NULL);
   1e230:	f7ff ffa0 	bl	1e174 <pppos_output_append>
  err = pppos_output_append(pppos, err,  nb, (~(*fcs) >> 8) & 0xFF, 1, NULL);
   1e234:	9b03      	ldr	r3, [sp, #12]
   1e236:	2201      	movs	r2, #1
   1e238:	881b      	ldrh	r3, [r3, #0]
  err = pppos_output_append(pppos, err,  nb, ~(*fcs) & 0xFF, 1, NULL);
   1e23a:	0001      	movs	r1, r0
  err = pppos_output_append(pppos, err,  nb, (~(*fcs) >> 8) & 0xFF, 1, NULL);
   1e23c:	43db      	mvns	r3, r3
   1e23e:	121b      	asrs	r3, r3, #8
   1e240:	b2db      	uxtb	r3, r3
   1e242:	9601      	str	r6, [sp, #4]
   1e244:	9200      	str	r2, [sp, #0]
   1e246:	0028      	movs	r0, r5
   1e248:	0022      	movs	r2, r4
   1e24a:	f7ff ff93 	bl	1e174 <pppos_output_append>
  err = pppos_output_append(pppos, err,  nb, PPP_FLAG, 0, NULL);
   1e24e:	9601      	str	r6, [sp, #4]
  err = pppos_output_append(pppos, err,  nb, (~(*fcs) >> 8) & 0xFF, 1, NULL);
   1e250:	0001      	movs	r1, r0
  err = pppos_output_append(pppos, err,  nb, PPP_FLAG, 0, NULL);
   1e252:	9600      	str	r6, [sp, #0]
   1e254:	237e      	movs	r3, #126	; 0x7e
   1e256:	0022      	movs	r2, r4
   1e258:	0028      	movs	r0, r5
   1e25a:	f7ff ff8b 	bl	1e174 <pppos_output_append>
   1e25e:	1e06      	subs	r6, r0, #0

  if (err != ERR_OK) {
   1e260:	d115      	bne.n	1e28e <pppos_output_last+0x7a>
    goto failed;
  }

  /* Send remaining buffer if not empty */
  if (nb->len > 0) {
   1e262:	8962      	ldrh	r2, [r4, #10]
   1e264:	2a00      	cmp	r2, #0
   1e266:	d108      	bne.n	1e27a <pppos_output_last+0x66>
      err = ERR_IF;
      goto failed;
    }
  }

  pppos->last_xmit = sys_now();
   1e268:	f004 fafe 	bl	22868 <sys_now>
   1e26c:	60a8      	str	r0, [r5, #8]
failed:
  pppos->last_xmit = 0; /* prepend PPP_FLAG to next packet */
  LINK_STATS_INC(link.err);
  LINK_STATS_INC(link.drop);
  MIB2_STATS_NETIF_INC(ppp->netif, ifoutdiscards);
  pbuf_free(nb);
   1e26e:	0020      	movs	r0, r4
   1e270:	f004 f970 	bl	22554 <pbuf_free>
  return err;
}
   1e274:	0030      	movs	r0, r6
   1e276:	b005      	add	sp, #20
   1e278:	bdf0      	pop	{r4, r5, r6, r7, pc}
    u32_t l = pppos->output_cb(ppp, (u8_t*)nb->payload, nb->len, ppp->ctx_cb);
   1e27a:	69bb      	ldr	r3, [r7, #24]
   1e27c:	0038      	movs	r0, r7
   1e27e:	6861      	ldr	r1, [r4, #4]
   1e280:	686f      	ldr	r7, [r5, #4]
   1e282:	47b8      	blx	r7
    if (l != nb->len) {
   1e284:	8963      	ldrh	r3, [r4, #10]
   1e286:	4283      	cmp	r3, r0
   1e288:	d0ee      	beq.n	1e268 <pppos_output_last+0x54>
      err = ERR_IF;
   1e28a:	260c      	movs	r6, #12
   1e28c:	4276      	negs	r6, r6
  pppos->last_xmit = 0; /* prepend PPP_FLAG to next packet */
   1e28e:	2300      	movs	r3, #0
   1e290:	60ab      	str	r3, [r5, #8]
   1e292:	e7ec      	b.n	1e26e <pppos_output_last+0x5a>

0001e294 <pppos_netif_output>:
{
   1e294:	b5f0      	push	{r4, r5, r6, r7, lr}
   1e296:	b08b      	sub	sp, #44	; 0x2c
   1e298:	9005      	str	r0, [sp, #20]
   1e29a:	9206      	str	r2, [sp, #24]
   1e29c:	000c      	movs	r4, r1
  nb = pbuf_alloc(PBUF_RAW, 0, PBUF_POOL);
   1e29e:	2203      	movs	r2, #3
   1e2a0:	2100      	movs	r1, #0
   1e2a2:	2004      	movs	r0, #4
{
   1e2a4:	9303      	str	r3, [sp, #12]
  nb = pbuf_alloc(PBUF_RAW, 0, PBUF_POOL);
   1e2a6:	f004 f91b 	bl	224e0 <pbuf_alloc>
   1e2aa:	1e05      	subs	r5, r0, #0
  if (nb == NULL) {
   1e2ac:	d10b      	bne.n	1e2c6 <pppos_netif_output+0x32>
    PPPDEBUG(LOG_WARNING, ("pppos_netif_output[%d]: alloc fail\n", ppp->netif->num));
   1e2ae:	9b05      	ldr	r3, [sp, #20]
   1e2b0:	4844      	ldr	r0, [pc, #272]	; (1e3c4 <pppos_netif_output+0x130>)
   1e2b2:	69db      	ldr	r3, [r3, #28]
    return ERR_MEM;
   1e2b4:	2401      	movs	r4, #1
    PPPDEBUG(LOG_WARNING, ("pppos_netif_output[%d]: alloc fail\n", ppp->netif->num));
   1e2b6:	3351      	adds	r3, #81	; 0x51
   1e2b8:	7819      	ldrb	r1, [r3, #0]
   1e2ba:	f004 f827 	bl	2230c <lwip_support_log>
    return ERR_MEM;
   1e2be:	4264      	negs	r4, r4
}
   1e2c0:	0020      	movs	r0, r4
   1e2c2:	b00b      	add	sp, #44	; 0x2c
   1e2c4:	bdf0      	pop	{r4, r5, r6, r7, pc}
  if ((sys_now() - pppos->last_xmit) >= PPP_MAXIDLEFLAG) {
   1e2c6:	f004 facf 	bl	22868 <sys_now>
   1e2ca:	68a3      	ldr	r3, [r4, #8]
   1e2cc:	2100      	movs	r1, #0
   1e2ce:	1ac0      	subs	r0, r0, r3
   1e2d0:	2863      	cmp	r0, #99	; 0x63
   1e2d2:	d907      	bls.n	1e2e4 <pppos_netif_output+0x50>
    err = pppos_output_append(pppos, err,  nb, PPP_FLAG, 0, NULL);
   1e2d4:	9101      	str	r1, [sp, #4]
   1e2d6:	9100      	str	r1, [sp, #0]
   1e2d8:	237e      	movs	r3, #126	; 0x7e
   1e2da:	002a      	movs	r2, r5
   1e2dc:	0020      	movs	r0, r4
   1e2de:	f7ff ff49 	bl	1e174 <pppos_output_append>
   1e2e2:	0001      	movs	r1, r0
  fcs_out = PPP_INITFCS;
   1e2e4:	260e      	movs	r6, #14
   1e2e6:	ab06      	add	r3, sp, #24
   1e2e8:	18f6      	adds	r6, r6, r3
   1e2ea:	2301      	movs	r3, #1
   1e2ec:	425b      	negs	r3, r3
   1e2ee:	8033      	strh	r3, [r6, #0]
  if (!pppos->accomp) {
   1e2f0:	0023      	movs	r3, r4
   1e2f2:	332c      	adds	r3, #44	; 0x2c
   1e2f4:	781b      	ldrb	r3, [r3, #0]
   1e2f6:	075b      	lsls	r3, r3, #29
   1e2f8:	d410      	bmi.n	1e31c <pppos_netif_output+0x88>
    err = pppos_output_append(pppos, err,  nb, PPP_ALLSTATIONS, 1, &fcs_out);
   1e2fa:	2701      	movs	r7, #1
   1e2fc:	23ff      	movs	r3, #255	; 0xff
   1e2fe:	002a      	movs	r2, r5
   1e300:	9601      	str	r6, [sp, #4]
   1e302:	9700      	str	r7, [sp, #0]
   1e304:	0020      	movs	r0, r4
   1e306:	f7ff ff35 	bl	1e174 <pppos_output_append>
    err = pppos_output_append(pppos, err,  nb, PPP_UI, 1, &fcs_out);
   1e30a:	9601      	str	r6, [sp, #4]
    err = pppos_output_append(pppos, err,  nb, PPP_ALLSTATIONS, 1, &fcs_out);
   1e30c:	0001      	movs	r1, r0
    err = pppos_output_append(pppos, err,  nb, PPP_UI, 1, &fcs_out);
   1e30e:	9700      	str	r7, [sp, #0]
   1e310:	2303      	movs	r3, #3
   1e312:	002a      	movs	r2, r5
   1e314:	0020      	movs	r0, r4
   1e316:	f7ff ff2d 	bl	1e174 <pppos_output_append>
   1e31a:	0001      	movs	r1, r0
  if (!pppos->pcomp || protocol > 0xFF) {
   1e31c:	0023      	movs	r3, r4
   1e31e:	332c      	adds	r3, #44	; 0x2c
   1e320:	781b      	ldrb	r3, [r3, #0]
   1e322:	079b      	lsls	r3, r3, #30
   1e324:	d502      	bpl.n	1e32c <pppos_netif_output+0x98>
   1e326:	9b03      	ldr	r3, [sp, #12]
   1e328:	2bff      	cmp	r3, #255	; 0xff
   1e32a:	d90c      	bls.n	1e346 <pppos_netif_output+0xb2>
    err = pppos_output_append(pppos, err,  nb, (protocol >> 8) & 0xFF, 1, &fcs_out);
   1e32c:	220e      	movs	r2, #14
   1e32e:	a806      	add	r0, sp, #24
   1e330:	1812      	adds	r2, r2, r0
   1e332:	9201      	str	r2, [sp, #4]
   1e334:	2201      	movs	r2, #1
   1e336:	9b03      	ldr	r3, [sp, #12]
   1e338:	9200      	str	r2, [sp, #0]
   1e33a:	0a1b      	lsrs	r3, r3, #8
   1e33c:	002a      	movs	r2, r5
   1e33e:	0020      	movs	r0, r4
   1e340:	f7ff ff18 	bl	1e174 <pppos_output_append>
   1e344:	0001      	movs	r1, r0
  err = pppos_output_append(pppos, err,  nb, protocol & 0xFF, 1, &fcs_out);
   1e346:	220e      	movs	r2, #14
   1e348:	2701      	movs	r7, #1
   1e34a:	466b      	mov	r3, sp
   1e34c:	a806      	add	r0, sp, #24
   1e34e:	1812      	adds	r2, r2, r0
   1e350:	7b1b      	ldrb	r3, [r3, #12]
   1e352:	0020      	movs	r0, r4
   1e354:	9201      	str	r2, [sp, #4]
   1e356:	9700      	str	r7, [sp, #0]
   1e358:	002a      	movs	r2, r5
   1e35a:	f7ff ff0b 	bl	1e174 <pppos_output_append>
   1e35e:	0001      	movs	r1, r0
  for(p = pb; p; p = p->next) {
   1e360:	9e06      	ldr	r6, [sp, #24]
      err = pppos_output_append(pppos, err,  nb, *s++, 1, &fcs_out);
   1e362:	9707      	str	r7, [sp, #28]
  for(p = pb; p; p = p->next) {
   1e364:	2e00      	cmp	r6, #0
   1e366:	d113      	bne.n	1e390 <pppos_netif_output+0xfc>
  err = pppos_output_last(pppos, err, nb, &fcs_out);
   1e368:	230e      	movs	r3, #14
   1e36a:	aa06      	add	r2, sp, #24
   1e36c:	189b      	adds	r3, r3, r2
   1e36e:	0020      	movs	r0, r4
   1e370:	002a      	movs	r2, r5
   1e372:	f7ff ff4f 	bl	1e214 <pppos_output_last>
   1e376:	1e04      	subs	r4, r0, #0
  if (err == ERR_OK) {
   1e378:	d0a2      	beq.n	1e2c0 <pppos_netif_output+0x2c>
    PPPDEBUG(LOG_WARNING, ("pppos_netif_output[%d]: output failed proto=0x%"X16_F", len = %d\n", ppp->netif->num, protocol, pb->tot_len));
   1e37a:	9a05      	ldr	r2, [sp, #20]
   1e37c:	9b06      	ldr	r3, [sp, #24]
   1e37e:	69d2      	ldr	r2, [r2, #28]
   1e380:	891b      	ldrh	r3, [r3, #8]
   1e382:	3251      	adds	r2, #81	; 0x51
   1e384:	7811      	ldrb	r1, [r2, #0]
   1e386:	4810      	ldr	r0, [pc, #64]	; (1e3c8 <pppos_netif_output+0x134>)
   1e388:	9a03      	ldr	r2, [sp, #12]
   1e38a:	f003 ffbf 	bl	2230c <lwip_support_log>
   1e38e:	e797      	b.n	1e2c0 <pppos_netif_output+0x2c>
    u16_t n = p->len;
   1e390:	8977      	ldrh	r7, [r6, #10]
   1e392:	6873      	ldr	r3, [r6, #4]
   1e394:	9304      	str	r3, [sp, #16]
    while (n-- > 0) {
   1e396:	3f01      	subs	r7, #1
   1e398:	4b0c      	ldr	r3, [pc, #48]	; (1e3cc <pppos_netif_output+0x138>)
   1e39a:	b2bf      	uxth	r7, r7
   1e39c:	429f      	cmp	r7, r3
   1e39e:	d101      	bne.n	1e3a4 <pppos_netif_output+0x110>
  for(p = pb; p; p = p->next) {
   1e3a0:	6836      	ldr	r6, [r6, #0]
   1e3a2:	e7df      	b.n	1e364 <pppos_netif_output+0xd0>
      err = pppos_output_append(pppos, err,  nb, *s++, 1, &fcs_out);
   1e3a4:	220e      	movs	r2, #14
   1e3a6:	9b04      	ldr	r3, [sp, #16]
   1e3a8:	a806      	add	r0, sp, #24
   1e3aa:	1812      	adds	r2, r2, r0
   1e3ac:	781b      	ldrb	r3, [r3, #0]
   1e3ae:	9201      	str	r2, [sp, #4]
   1e3b0:	9a07      	ldr	r2, [sp, #28]
   1e3b2:	0020      	movs	r0, r4
   1e3b4:	9200      	str	r2, [sp, #0]
   1e3b6:	002a      	movs	r2, r5
   1e3b8:	f7ff fedc 	bl	1e174 <pppos_output_append>
   1e3bc:	9b04      	ldr	r3, [sp, #16]
   1e3be:	0001      	movs	r1, r0
   1e3c0:	3301      	adds	r3, #1
   1e3c2:	e7e7      	b.n	1e394 <pppos_netif_output+0x100>
   1e3c4:	00025b3f 	.word	0x00025b3f
   1e3c8:	00025b63 	.word	0x00025b63
   1e3cc:	0000ffff 	.word	0x0000ffff

0001e3d0 <pppos_write>:
{
   1e3d0:	b5f0      	push	{r4, r5, r6, r7, lr}
   1e3d2:	0007      	movs	r7, r0
   1e3d4:	b087      	sub	sp, #28
   1e3d6:	000d      	movs	r5, r1
   1e3d8:	0014      	movs	r4, r2
  nb = pbuf_alloc(PBUF_RAW, 0, PBUF_POOL);
   1e3da:	2100      	movs	r1, #0
   1e3dc:	2203      	movs	r2, #3
   1e3de:	2004      	movs	r0, #4
   1e3e0:	f004 f87e 	bl	224e0 <pbuf_alloc>
   1e3e4:	1e06      	subs	r6, r0, #0
  if (nb == NULL) {
   1e3e6:	d10d      	bne.n	1e404 <pppos_write+0x34>
    PPPDEBUG(LOG_WARNING, ("pppos_write[%d]: alloc fail\n", ppp->netif->num));
   1e3e8:	69fb      	ldr	r3, [r7, #28]
   1e3ea:	4828      	ldr	r0, [pc, #160]	; (1e48c <pppos_write+0xbc>)
   1e3ec:	3351      	adds	r3, #81	; 0x51
   1e3ee:	7819      	ldrb	r1, [r3, #0]
   1e3f0:	f003 ff8c 	bl	2230c <lwip_support_log>
    return ERR_MEM;
   1e3f4:	2501      	movs	r5, #1
    pbuf_free(p);
   1e3f6:	0020      	movs	r0, r4
   1e3f8:	f004 f8ac 	bl	22554 <pbuf_free>
    return ERR_MEM;
   1e3fc:	426d      	negs	r5, r5
}
   1e3fe:	0028      	movs	r0, r5
   1e400:	b007      	add	sp, #28
   1e402:	bdf0      	pop	{r4, r5, r6, r7, pc}
  if ((sys_now() - pppos->last_xmit) >= PPP_MAXIDLEFLAG) {
   1e404:	f004 fa30 	bl	22868 <sys_now>
   1e408:	68ab      	ldr	r3, [r5, #8]
   1e40a:	2100      	movs	r1, #0
   1e40c:	1ac0      	subs	r0, r0, r3
   1e40e:	2863      	cmp	r0, #99	; 0x63
   1e410:	d907      	bls.n	1e422 <pppos_write+0x52>
    err = pppos_output_append(pppos, err,  nb, PPP_FLAG, 0, NULL);
   1e412:	9101      	str	r1, [sp, #4]
   1e414:	9100      	str	r1, [sp, #0]
   1e416:	237e      	movs	r3, #126	; 0x7e
   1e418:	0032      	movs	r2, r6
   1e41a:	0028      	movs	r0, r5
   1e41c:	f7ff feaa 	bl	1e174 <pppos_output_append>
   1e420:	0001      	movs	r1, r0
  fcs_out = PPP_INITFCS;
   1e422:	230e      	movs	r3, #14
   1e424:	aa02      	add	r2, sp, #8
   1e426:	189b      	adds	r3, r3, r2
   1e428:	2201      	movs	r2, #1
   1e42a:	4252      	negs	r2, r2
   1e42c:	801a      	strh	r2, [r3, #0]
  n = p->len;
   1e42e:	8963      	ldrh	r3, [r4, #10]
   1e430:	9303      	str	r3, [sp, #12]
   1e432:	6863      	ldr	r3, [r4, #4]
   1e434:	9302      	str	r3, [sp, #8]
  while (n-- > 0) {
   1e436:	9b03      	ldr	r3, [sp, #12]
   1e438:	a802      	add	r0, sp, #8
   1e43a:	3b01      	subs	r3, #1
   1e43c:	b29b      	uxth	r3, r3
   1e43e:	9303      	str	r3, [sp, #12]
   1e440:	230e      	movs	r3, #14
   1e442:	4a13      	ldr	r2, [pc, #76]	; (1e490 <pppos_write+0xc0>)
   1e444:	181b      	adds	r3, r3, r0
   1e446:	9803      	ldr	r0, [sp, #12]
   1e448:	4290      	cmp	r0, r2
   1e44a:	d110      	bne.n	1e46e <pppos_write+0x9e>
  err = pppos_output_last(pppos, err, nb, &fcs_out);
   1e44c:	0028      	movs	r0, r5
   1e44e:	0032      	movs	r2, r6
   1e450:	f7ff fee0 	bl	1e214 <pppos_output_last>
   1e454:	1e05      	subs	r5, r0, #0
  if (err == ERR_OK) {
   1e456:	d006      	beq.n	1e466 <pppos_write+0x96>
    PPPDEBUG(LOG_WARNING, ("pppos_write[%d]: output failed len=%d\n", ppp->netif->num, p->len));
   1e458:	69fb      	ldr	r3, [r7, #28]
   1e45a:	8962      	ldrh	r2, [r4, #10]
   1e45c:	3351      	adds	r3, #81	; 0x51
   1e45e:	7819      	ldrb	r1, [r3, #0]
   1e460:	480c      	ldr	r0, [pc, #48]	; (1e494 <pppos_write+0xc4>)
   1e462:	f003 ff53 	bl	2230c <lwip_support_log>
  pbuf_free(p);
   1e466:	0020      	movs	r0, r4
   1e468:	f004 f874 	bl	22554 <pbuf_free>
  return err;
   1e46c:	e7c7      	b.n	1e3fe <pppos_write+0x2e>
    err = pppos_output_append(pppos, err,  nb, *s++, 1, &fcs_out);
   1e46e:	9a02      	ldr	r2, [sp, #8]
   1e470:	0028      	movs	r0, r5
   1e472:	7812      	ldrb	r2, [r2, #0]
   1e474:	9301      	str	r3, [sp, #4]
   1e476:	2301      	movs	r3, #1
   1e478:	9300      	str	r3, [sp, #0]
   1e47a:	0013      	movs	r3, r2
   1e47c:	0032      	movs	r2, r6
   1e47e:	f7ff fe79 	bl	1e174 <pppos_output_append>
   1e482:	9b02      	ldr	r3, [sp, #8]
   1e484:	0001      	movs	r1, r0
   1e486:	3301      	adds	r3, #1
   1e488:	e7d4      	b.n	1e434 <pppos_write+0x64>
   1e48a:	46c0      	nop			; (mov r8, r8)
   1e48c:	00025b9f 	.word	0x00025b9f
   1e490:	0000ffff 	.word	0x0000ffff
   1e494:	00025bbc 	.word	0x00025bbc

0001e498 <pppos_create>:
{
   1e498:	b5f0      	push	{r4, r5, r6, r7, lr}
  pppos = (pppos_pcb *)LWIP_MEMPOOL_ALLOC(PPPOS_PCB);
   1e49a:	4e13      	ldr	r6, [pc, #76]	; (1e4e8 <pppos_create+0x50>)
{
   1e49c:	b087      	sub	sp, #28
   1e49e:	0007      	movs	r7, r0
  pppos = (pppos_pcb *)LWIP_MEMPOOL_ALLOC(PPPOS_PCB);
   1e4a0:	0030      	movs	r0, r6
{
   1e4a2:	9103      	str	r1, [sp, #12]
   1e4a4:	9204      	str	r2, [sp, #16]
   1e4a6:	9305      	str	r3, [sp, #20]
  pppos = (pppos_pcb *)LWIP_MEMPOOL_ALLOC(PPPOS_PCB);
   1e4a8:	f003 ff51 	bl	2234e <memp_malloc_pool>
   1e4ac:	0004      	movs	r4, r0
    return NULL;
   1e4ae:	1e05      	subs	r5, r0, #0
  if (pppos == NULL) {
   1e4b0:	d00d      	beq.n	1e4ce <pppos_create+0x36>
  ppp = ppp_new(pppif, &pppos_callbacks, pppos, link_status_cb, ctx_cb);
   1e4b2:	9b05      	ldr	r3, [sp, #20]
   1e4b4:	0002      	movs	r2, r0
   1e4b6:	9300      	str	r3, [sp, #0]
   1e4b8:	490c      	ldr	r1, [pc, #48]	; (1e4ec <pppos_create+0x54>)
   1e4ba:	9b04      	ldr	r3, [sp, #16]
   1e4bc:	0038      	movs	r0, r7
   1e4be:	f7ff fc4d 	bl	1dd5c <ppp_new>
   1e4c2:	1e05      	subs	r5, r0, #0
  if (ppp == NULL) {
   1e4c4:	d106      	bne.n	1e4d4 <pppos_create+0x3c>
    LWIP_MEMPOOL_FREE(PPPOS_PCB, pppos);
   1e4c6:	0021      	movs	r1, r4
   1e4c8:	0030      	movs	r0, r6
   1e4ca:	f003 ff47 	bl	2235c <memp_free_pool>
}
   1e4ce:	0028      	movs	r0, r5
   1e4d0:	b007      	add	sp, #28
   1e4d2:	bdf0      	pop	{r4, r5, r6, r7, pc}
  memset(pppos, 0, sizeof(pppos_pcb));
   1e4d4:	2260      	movs	r2, #96	; 0x60
   1e4d6:	2100      	movs	r1, #0
   1e4d8:	0020      	movs	r0, r4
   1e4da:	f7e1 ff01 	bl	2e0 <memset>
  pppos->output_cb = output_cb;
   1e4de:	9b03      	ldr	r3, [sp, #12]
  pppos->ppp = ppp;
   1e4e0:	6025      	str	r5, [r4, #0]
  pppos->output_cb = output_cb;
   1e4e2:	6063      	str	r3, [r4, #4]
  return ppp;
   1e4e4:	e7f3      	b.n	1e4ce <pppos_create+0x36>
   1e4e6:	46c0      	nop			; (mov r8, r8)
   1e4e8:	00025aa0 	.word	0x00025aa0
   1e4ec:	00025aa4 	.word	0x00025aa4

0001e4f0 <pppos_input>:
{
   1e4f0:	b5f0      	push	{r4, r5, r6, r7, lr}
   1e4f2:	0006      	movs	r6, r0
    if (!pppos->open) {
   1e4f4:	2701      	movs	r7, #1
{
   1e4f6:	b085      	sub	sp, #20
  pppos_pcb *pppos = (pppos_pcb *)ppp->link_ctx_cb;
   1e4f8:	6904      	ldr	r4, [r0, #16]
{
   1e4fa:	9102      	str	r1, [sp, #8]
   1e4fc:	9203      	str	r2, [sp, #12]
  while (l-- > 0) {
   1e4fe:	9101      	str	r1, [sp, #4]
   1e500:	9a03      	ldr	r2, [sp, #12]
   1e502:	9b02      	ldr	r3, [sp, #8]
   1e504:	189b      	adds	r3, r3, r2
   1e506:	9a01      	ldr	r2, [sp, #4]
   1e508:	1a9b      	subs	r3, r3, r2
   1e50a:	2b00      	cmp	r3, #0
   1e50c:	dc01      	bgt.n	1e512 <pppos_input+0x22>
}
   1e50e:	b005      	add	sp, #20
   1e510:	bdf0      	pop	{r4, r5, r6, r7, pc}
    cur_char = *s++;
   1e512:	9b01      	ldr	r3, [sp, #4]
   1e514:	781d      	ldrb	r5, [r3, #0]
    if (!pppos->open) {
   1e516:	0023      	movs	r3, r4
   1e518:	332c      	adds	r3, #44	; 0x2c
   1e51a:	781b      	ldrb	r3, [r3, #0]
   1e51c:	423b      	tst	r3, r7
   1e51e:	d0f6      	beq.n	1e50e <pppos_input+0x1e>
    escaped = ESCAPE_P(pppos->in_accm, cur_char);
   1e520:	2307      	movs	r3, #7
   1e522:	0039      	movs	r1, r7
   1e524:	402b      	ands	r3, r5
   1e526:	4099      	lsls	r1, r3
   1e528:	000b      	movs	r3, r1
   1e52a:	08ea      	lsrs	r2, r5, #3
   1e52c:	18a2      	adds	r2, r4, r2
   1e52e:	322d      	adds	r2, #45	; 0x2d
   1e530:	7812      	ldrb	r2, [r2, #0]
   1e532:	4013      	ands	r3, r2
    if (escaped) {
   1e534:	b25b      	sxtb	r3, r3
   1e536:	2b00      	cmp	r3, #0
   1e538:	d056      	beq.n	1e5e8 <pppos_input+0xf8>
      if (cur_char == PPP_ESCAPE) {
   1e53a:	2d7d      	cmp	r5, #125	; 0x7d
   1e53c:	d106      	bne.n	1e54c <pppos_input+0x5c>
        pppos->in_escaped = 1;
   1e53e:	0023      	movs	r3, r4
   1e540:	335d      	adds	r3, #93	; 0x5d
   1e542:	701f      	strb	r7, [r3, #0]
   1e544:	9b01      	ldr	r3, [sp, #4]
   1e546:	3301      	adds	r3, #1
   1e548:	9301      	str	r3, [sp, #4]
   1e54a:	e7d9      	b.n	1e500 <pppos_input+0x10>
      } else if (cur_char == PPP_FLAG) {
   1e54c:	2d7e      	cmp	r5, #126	; 0x7e
   1e54e:	d143      	bne.n	1e5d8 <pppos_input+0xe8>
        if (pppos->in_state <= PDADDRESS) {
   1e550:	0025      	movs	r5, r4
   1e552:	355c      	adds	r5, #92	; 0x5c
   1e554:	782a      	ldrb	r2, [r5, #0]
   1e556:	2a02      	cmp	r2, #2
   1e558:	d90a      	bls.n	1e570 <pppos_input+0x80>
        } else if (pppos->in_state < PDDATA) {
   1e55a:	2a05      	cmp	r2, #5
   1e55c:	d810      	bhi.n	1e580 <pppos_input+0x90>
          PPPDEBUG(LOG_WARNING,
   1e55e:	69f3      	ldr	r3, [r6, #28]
   1e560:	485d      	ldr	r0, [pc, #372]	; (1e6d8 <pppos_input+0x1e8>)
   1e562:	3351      	adds	r3, #81	; 0x51
   1e564:	7819      	ldrb	r1, [r3, #0]
   1e566:	f003 fed1 	bl	2230c <lwip_support_log>
  pppos_input_free_current_packet(pppos);
   1e56a:	0020      	movs	r0, r4
   1e56c:	f7ff fdc4 	bl	1e0f8 <pppos_input_free_current_packet>
        pppos->in_fcs = PPP_INITFCS;
   1e570:	2201      	movs	r2, #1
   1e572:	0023      	movs	r3, r4
   1e574:	4252      	negs	r2, r2
   1e576:	335a      	adds	r3, #90	; 0x5a
   1e578:	801a      	strh	r2, [r3, #0]
   1e57a:	2302      	movs	r3, #2
   1e57c:	802b      	strh	r3, [r5, #0]
   1e57e:	e7e1      	b.n	1e544 <pppos_input+0x54>
        } else if (pppos->in_fcs != PPP_GOODFCS) {
   1e580:	0023      	movs	r3, r4
   1e582:	335a      	adds	r3, #90	; 0x5a
   1e584:	881a      	ldrh	r2, [r3, #0]
   1e586:	4b55      	ldr	r3, [pc, #340]	; (1e6dc <pppos_input+0x1ec>)
   1e588:	429a      	cmp	r2, r3
   1e58a:	d1ee      	bne.n	1e56a <pppos_input+0x7a>
          if(pppos->in_tail->len > 2) {
   1e58c:	6d62      	ldr	r2, [r4, #84]	; 0x54
   1e58e:	8953      	ldrh	r3, [r2, #10]
   1e590:	2b02      	cmp	r3, #2
   1e592:	d912      	bls.n	1e5ba <pppos_input+0xca>
            pppos->in_tail->len -= 2;
   1e594:	3b02      	subs	r3, #2
   1e596:	8153      	strh	r3, [r2, #10]
            pppos->in_tail->tot_len = pppos->in_tail->len;
   1e598:	6d63      	ldr	r3, [r4, #84]	; 0x54
   1e59a:	895a      	ldrh	r2, [r3, #10]
   1e59c:	811a      	strh	r2, [r3, #8]
            if (pppos->in_tail != pppos->in_head) {
   1e59e:	6d61      	ldr	r1, [r4, #84]	; 0x54
   1e5a0:	6d20      	ldr	r0, [r4, #80]	; 0x50
   1e5a2:	4281      	cmp	r1, r0
   1e5a4:	d001      	beq.n	1e5aa <pppos_input+0xba>
              pbuf_cat(pppos->in_head, pppos->in_tail);
   1e5a6:	f004 f80f 	bl	225c8 <pbuf_cat>
          pppos->in_head = NULL;
   1e5aa:	2300      	movs	r3, #0
          inp = pppos->in_head;
   1e5ac:	6d21      	ldr	r1, [r4, #80]	; 0x50
          pppos->in_tail = NULL;
   1e5ae:	6563      	str	r3, [r4, #84]	; 0x54
          pppos->in_head = NULL;
   1e5b0:	6523      	str	r3, [r4, #80]	; 0x50
          ppp_input(ppp, inp);
   1e5b2:	0030      	movs	r0, r6
   1e5b4:	f7ff fc66 	bl	1de84 <ppp_input>
   1e5b8:	e7da      	b.n	1e570 <pppos_input+0x80>
            pppos->in_tail->tot_len = pppos->in_tail->len;
   1e5ba:	8113      	strh	r3, [r2, #8]
            if (pppos->in_tail != pppos->in_head) {
   1e5bc:	6d61      	ldr	r1, [r4, #84]	; 0x54
   1e5be:	6d20      	ldr	r0, [r4, #80]	; 0x50
   1e5c0:	4281      	cmp	r1, r0
   1e5c2:	d001      	beq.n	1e5c8 <pppos_input+0xd8>
              pbuf_cat(pppos->in_head, pppos->in_tail);
   1e5c4:	f004 f800 	bl	225c8 <pbuf_cat>
            pbuf_realloc(pppos->in_head, pppos->in_head->tot_len - 2);
   1e5c8:	6d23      	ldr	r3, [r4, #80]	; 0x50
   1e5ca:	8919      	ldrh	r1, [r3, #8]
   1e5cc:	0018      	movs	r0, r3
   1e5ce:	3902      	subs	r1, #2
   1e5d0:	b289      	uxth	r1, r1
   1e5d2:	f003 ffb9 	bl	22548 <pbuf_realloc>
   1e5d6:	e7e8      	b.n	1e5aa <pppos_input+0xba>
        PPPDEBUG(LOG_WARNING,
   1e5d8:	69f3      	ldr	r3, [r6, #28]
   1e5da:	002a      	movs	r2, r5
   1e5dc:	3351      	adds	r3, #81	; 0x51
   1e5de:	7819      	ldrb	r1, [r3, #0]
   1e5e0:	483f      	ldr	r0, [pc, #252]	; (1e6e0 <pppos_input+0x1f0>)
   1e5e2:	f003 fe93 	bl	2230c <lwip_support_log>
   1e5e6:	e7ad      	b.n	1e544 <pppos_input+0x54>
      if (pppos->in_escaped) {
   1e5e8:	0022      	movs	r2, r4
   1e5ea:	325d      	adds	r2, #93	; 0x5d
   1e5ec:	7811      	ldrb	r1, [r2, #0]
   1e5ee:	2900      	cmp	r1, #0
   1e5f0:	d002      	beq.n	1e5f8 <pppos_input+0x108>
        pppos->in_escaped = 0;
   1e5f2:	7013      	strb	r3, [r2, #0]
        cur_char ^= PPP_TRANS;
   1e5f4:	2320      	movs	r3, #32
   1e5f6:	405d      	eors	r5, r3
      switch(pppos->in_state) {
   1e5f8:	0023      	movs	r3, r4
   1e5fa:	335c      	adds	r3, #92	; 0x5c
   1e5fc:	7818      	ldrb	r0, [r3, #0]
   1e5fe:	2806      	cmp	r0, #6
   1e600:	d81a      	bhi.n	1e638 <pppos_input+0x148>
   1e602:	f7e1 fecf 	bl	3a4 <__gnu_thumb1_case_uqi>
   1e606:	0604      	.short	0x0604
   1e608:	29110e0b 	.word	0x29110e0b
   1e60c:	2e          	.byte	0x2e
   1e60d:	00          	.byte	0x00
          if (cur_char != PPP_ALLSTATIONS) {
   1e60e:	2dff      	cmp	r5, #255	; 0xff
   1e610:	d112      	bne.n	1e638 <pppos_input+0x148>
          pppos->in_fcs = PPP_INITFCS;
   1e612:	2101      	movs	r1, #1
   1e614:	0022      	movs	r2, r4
   1e616:	4249      	negs	r1, r1
   1e618:	325a      	adds	r2, #90	; 0x5a
   1e61a:	8011      	strh	r1, [r2, #0]
            pppos->in_state = PDCONTROL;
   1e61c:	2203      	movs	r2, #3
          if (cur_char == PPP_ALLSTATIONS) {
   1e61e:	2dff      	cmp	r5, #255	; 0xff
   1e620:	d009      	beq.n	1e636 <pppos_input+0x146>
            pppos->in_state = PDPROTOCOL1;
   1e622:	2204      	movs	r2, #4
          if (cur_char == PPP_UI) {
   1e624:	2d03      	cmp	r5, #3
   1e626:	d006      	beq.n	1e636 <pppos_input+0x146>
   1e628:	0021      	movs	r1, r4
   1e62a:	b2aa      	uxth	r2, r5
   1e62c:	3158      	adds	r1, #88	; 0x58
          if (cur_char & 1) {
   1e62e:	423d      	tst	r5, r7
   1e630:	d00e      	beq.n	1e650 <pppos_input+0x160>
            pppos->in_protocol = cur_char;
   1e632:	800a      	strh	r2, [r1, #0]
            pppos->in_state = PDDATA;
   1e634:	2206      	movs	r2, #6
   1e636:	701a      	strb	r2, [r3, #0]
      pppos->in_fcs = PPP_FCS(pppos->in_fcs, cur_char);
   1e638:	0022      	movs	r2, r4
   1e63a:	325a      	adds	r2, #90	; 0x5a
   1e63c:	8813      	ldrh	r3, [r2, #0]
   1e63e:	4929      	ldr	r1, [pc, #164]	; (1e6e4 <pppos_input+0x1f4>)
   1e640:	405d      	eors	r5, r3
   1e642:	b2ed      	uxtb	r5, r5
   1e644:	006d      	lsls	r5, r5, #1
   1e646:	5a69      	ldrh	r1, [r5, r1]
   1e648:	0a1b      	lsrs	r3, r3, #8
   1e64a:	404b      	eors	r3, r1
   1e64c:	8013      	strh	r3, [r2, #0]
   1e64e:	e779      	b.n	1e544 <pppos_input+0x54>
            pppos->in_protocol = (u16_t)cur_char << 8;
   1e650:	0212      	lsls	r2, r2, #8
   1e652:	800a      	strh	r2, [r1, #0]
            pppos->in_state = PDPROTOCOL2;
   1e654:	2205      	movs	r2, #5
   1e656:	e7ee      	b.n	1e636 <pppos_input+0x146>
          pppos->in_protocol |= cur_char;
   1e658:	0021      	movs	r1, r4
   1e65a:	3158      	adds	r1, #88	; 0x58
   1e65c:	880a      	ldrh	r2, [r1, #0]
   1e65e:	432a      	orrs	r2, r5
   1e660:	e7e7      	b.n	1e632 <pppos_input+0x142>
          if (pppos->in_tail == NULL || pppos->in_tail->len == PBUF_POOL_BUFSIZE) {
   1e662:	6d63      	ldr	r3, [r4, #84]	; 0x54
   1e664:	2b00      	cmp	r3, #0
   1e666:	d00c      	beq.n	1e682 <pppos_input+0x192>
   1e668:	491f      	ldr	r1, [pc, #124]	; (1e6e8 <pppos_input+0x1f8>)
   1e66a:	895a      	ldrh	r2, [r3, #10]
   1e66c:	428a      	cmp	r2, r1
   1e66e:	d12c      	bne.n	1e6ca <pppos_input+0x1da>
              pppos->in_tail->tot_len = pppos->in_tail->len;
   1e670:	811a      	strh	r2, [r3, #8]
              if (pppos->in_tail != pppos->in_head) {
   1e672:	6d61      	ldr	r1, [r4, #84]	; 0x54
   1e674:	6d20      	ldr	r0, [r4, #80]	; 0x50
   1e676:	4281      	cmp	r1, r0
   1e678:	d003      	beq.n	1e682 <pppos_input+0x192>
                pbuf_cat(pppos->in_head, pppos->in_tail);
   1e67a:	f003 ffa5 	bl	225c8 <pbuf_cat>
                pppos->in_tail = NULL;
   1e67e:	2300      	movs	r3, #0
   1e680:	6563      	str	r3, [r4, #84]	; 0x54
            next_pbuf = pbuf_alloc(PBUF_RAW, pbuf_alloc_len, PBUF_POOL);
   1e682:	2203      	movs	r2, #3
   1e684:	2100      	movs	r1, #0
   1e686:	2004      	movs	r0, #4
   1e688:	f003 ff2a 	bl	224e0 <pbuf_alloc>
            if (next_pbuf == NULL) {
   1e68c:	2800      	cmp	r0, #0
   1e68e:	d10c      	bne.n	1e6aa <pppos_input+0x1ba>
              PPPDEBUG(LOG_ERR, ("pppos_input[%d]: NO FREE PBUFS!\n", ppp->netif->num));
   1e690:	69f3      	ldr	r3, [r6, #28]
   1e692:	4816      	ldr	r0, [pc, #88]	; (1e6ec <pppos_input+0x1fc>)
   1e694:	3351      	adds	r3, #81	; 0x51
   1e696:	7819      	ldrb	r1, [r3, #0]
   1e698:	f003 fe38 	bl	2230c <lwip_support_log>
  pppos_input_free_current_packet(pppos);
   1e69c:	0020      	movs	r0, r4
   1e69e:	f7ff fd2b 	bl	1e0f8 <pppos_input_free_current_packet>
              pppos->in_state = PDSTART;  /* Wait for flag sequence. */
   1e6a2:	0023      	movs	r3, r4
   1e6a4:	335c      	adds	r3, #92	; 0x5c
   1e6a6:	701f      	strb	r7, [r3, #0]
              break;
   1e6a8:	e7c6      	b.n	1e638 <pppos_input+0x148>
            if (pppos->in_head == NULL) {
   1e6aa:	6d23      	ldr	r3, [r4, #80]	; 0x50
   1e6ac:	2b00      	cmp	r3, #0
   1e6ae:	d10b      	bne.n	1e6c8 <pppos_input+0x1d8>
              *(payload++) = pppos->in_protocol >> 8;
   1e6b0:	0021      	movs	r1, r4
              next_pbuf->len += sizeof(pppos->in_protocol);
   1e6b2:	8943      	ldrh	r3, [r0, #10]
              *(payload++) = pppos->in_protocol >> 8;
   1e6b4:	3158      	adds	r1, #88	; 0x58
              next_pbuf->len += sizeof(pppos->in_protocol);
   1e6b6:	3302      	adds	r3, #2
   1e6b8:	8143      	strh	r3, [r0, #10]
              *(payload++) = pppos->in_protocol >> 8;
   1e6ba:	880b      	ldrh	r3, [r1, #0]
              u8_t *payload = ((u8_t*)next_pbuf->payload) + pbuf_alloc_len;
   1e6bc:	6842      	ldr	r2, [r0, #4]
              *(payload++) = pppos->in_protocol >> 8;
   1e6be:	0a1b      	lsrs	r3, r3, #8
   1e6c0:	7013      	strb	r3, [r2, #0]
              *(payload) = pppos->in_protocol & 0xFF;
   1e6c2:	880b      	ldrh	r3, [r1, #0]
   1e6c4:	7053      	strb	r3, [r2, #1]
              pppos->in_head = next_pbuf;
   1e6c6:	6520      	str	r0, [r4, #80]	; 0x50
            pppos->in_tail = next_pbuf;
   1e6c8:	6560      	str	r0, [r4, #84]	; 0x54
          ((u8_t*)pppos->in_tail->payload)[pppos->in_tail->len++] = cur_char;
   1e6ca:	6d63      	ldr	r3, [r4, #84]	; 0x54
   1e6cc:	895a      	ldrh	r2, [r3, #10]
   1e6ce:	6859      	ldr	r1, [r3, #4]
   1e6d0:	1c50      	adds	r0, r2, #1
   1e6d2:	8158      	strh	r0, [r3, #10]
   1e6d4:	548d      	strb	r5, [r1, r2]
          break;
   1e6d6:	e7af      	b.n	1e638 <pppos_input+0x148>
   1e6d8:	00025ac4 	.word	0x00025ac4
   1e6dc:	0000f0b8 	.word	0x0000f0b8
   1e6e0:	00025af4 	.word	0x00025af4
   1e6e4:	000258a0 	.word	0x000258a0
   1e6e8:	000005dc 	.word	0x000005dc
   1e6ec:	00025b1e 	.word	0x00025b1e

0001e6f0 <ppp_vslprintf>:
/*
 * ppp_vslprintf - like ppp_slprintf, takes a va_list instead of a list of args.
 */
#define OUTCHAR(c)	(buflen > 0? (--buflen, *buf++ = (c)): 0)

int ppp_vslprintf(char *buf, int buflen, const char *fmt, va_list args) {
   1e6f0:	b5f0      	push	{r4, r5, r6, r7, lr}
   1e6f2:	001d      	movs	r5, r3
    struct buffer_info bufinfo;
#endif /* PRINTPKT_SUPPORT */

    buf0 = buf;
    --buflen;
    while (buflen > 0) {
   1e6f4:	0007      	movs	r7, r0
int ppp_vslprintf(char *buf, int buflen, const char *fmt, va_list args) {
   1e6f6:	b095      	sub	sp, #84	; 0x54
   1e6f8:	900a      	str	r0, [sp, #40]	; 0x28
   1e6fa:	9205      	str	r2, [sp, #20]
    --buflen;
   1e6fc:	1e4c      	subs	r4, r1, #1
    while (buflen > 0) {
   1e6fe:	2c00      	cmp	r4, #0
   1e700:	dc00      	bgt.n	1e704 <ppp_vslprintf+0x14>
   1e702:	e0cf      	b.n	1e8a4 <ppp_vslprintf+0x1b4>
   1e704:	9e05      	ldr	r6, [sp, #20]
   1e706:	e000      	b.n	1e70a <ppp_vslprintf+0x1a>
	for (f = fmt; *f != '%' && *f != 0; ++f)
   1e708:	3601      	adds	r6, #1
   1e70a:	7833      	ldrb	r3, [r6, #0]
   1e70c:	2b25      	cmp	r3, #37	; 0x25
   1e70e:	d001      	beq.n	1e714 <ppp_vslprintf+0x24>
   1e710:	2b00      	cmp	r3, #0
   1e712:	d1f9      	bne.n	1e708 <ppp_vslprintf+0x18>
	    ;
	if (f > fmt) {
   1e714:	9b05      	ldr	r3, [sp, #20]
   1e716:	42b3      	cmp	r3, r6
   1e718:	d20d      	bcs.n	1e736 <ppp_vslprintf+0x46>
	    len = f - fmt;
   1e71a:	1af3      	subs	r3, r6, r3
   1e71c:	9404      	str	r4, [sp, #16]
   1e71e:	429c      	cmp	r4, r3
   1e720:	dd00      	ble.n	1e724 <ppp_vslprintf+0x34>
   1e722:	9304      	str	r3, [sp, #16]
	    if (len > buflen)
		len = buflen;
	    memcpy(buf, fmt, len);
   1e724:	0038      	movs	r0, r7
   1e726:	9a04      	ldr	r2, [sp, #16]
   1e728:	9905      	ldr	r1, [sp, #20]
   1e72a:	f7e1 fd61 	bl	1f0 <memcpy>
	    buf += len;
   1e72e:	9b04      	ldr	r3, [sp, #16]
	    buflen -= len;
   1e730:	9605      	str	r6, [sp, #20]
	    buf += len;
   1e732:	18ff      	adds	r7, r7, r3
	    buflen -= len;
   1e734:	1ae4      	subs	r4, r4, r3
	    fmt = f;
	}
	if (*fmt == 0)
   1e736:	9b05      	ldr	r3, [sp, #20]
   1e738:	781b      	ldrb	r3, [r3, #0]
   1e73a:	2b00      	cmp	r3, #0
   1e73c:	d100      	bne.n	1e740 <ppp_vslprintf+0x50>
   1e73e:	e0b1      	b.n	1e8a4 <ppp_vslprintf+0x1b4>
	    break;
	c = *++fmt;
   1e740:	9b05      	ldr	r3, [sp, #20]
   1e742:	785e      	ldrb	r6, [r3, #1]
	width = 0;
	prec = -1;
	fillch = ' ';
	if (c == '0') {
   1e744:	2e30      	cmp	r6, #48	; 0x30
   1e746:	d01a      	beq.n	1e77e <ppp_vslprintf+0x8e>
	fillch = ' ';
   1e748:	2220      	movs	r2, #32
	c = *++fmt;
   1e74a:	3301      	adds	r3, #1
	fillch = ' ';
   1e74c:	9209      	str	r2, [sp, #36]	; 0x24
	    fillch = '0';
	    c = *++fmt;
	}
	if (c == '*') {
   1e74e:	2e2a      	cmp	r6, #42	; 0x2a
   1e750:	d01b      	beq.n	1e78a <ppp_vslprintf+0x9a>
	    width = va_arg(args, int);
	    c = *++fmt;
	} else {
	    while (isdigit(c)) {
   1e752:	4ab6      	ldr	r2, [pc, #728]	; (1ea2c <ppp_vslprintf+0x33c>)
   1e754:	6812      	ldr	r2, [r2, #0]
   1e756:	9204      	str	r2, [sp, #16]
	width = 0;
   1e758:	2200      	movs	r2, #0
   1e75a:	9208      	str	r2, [sp, #32]
	    while (isdigit(c)) {
   1e75c:	2004      	movs	r0, #4
   1e75e:	9a04      	ldr	r2, [sp, #16]
   1e760:	1c59      	adds	r1, r3, #1
   1e762:	1992      	adds	r2, r2, r6
   1e764:	7852      	ldrb	r2, [r2, #1]
   1e766:	4202      	tst	r2, r0
   1e768:	d014      	beq.n	1e794 <ppp_vslprintf+0xa4>
		width = width * 10 + c - '0';
   1e76a:	200a      	movs	r0, #10
   1e76c:	9a08      	ldr	r2, [sp, #32]
   1e76e:	4342      	muls	r2, r0
   1e770:	4694      	mov	ip, r2
   1e772:	4466      	add	r6, ip
   1e774:	3e30      	subs	r6, #48	; 0x30
   1e776:	9608      	str	r6, [sp, #32]
		c = *++fmt;
   1e778:	785e      	ldrb	r6, [r3, #1]
   1e77a:	000b      	movs	r3, r1
   1e77c:	e7ee      	b.n	1e75c <ppp_vslprintf+0x6c>
	    c = *++fmt;
   1e77e:	9b05      	ldr	r3, [sp, #20]
   1e780:	9a05      	ldr	r2, [sp, #20]
	    fillch = '0';
   1e782:	9609      	str	r6, [sp, #36]	; 0x24
	    c = *++fmt;
   1e784:	3302      	adds	r3, #2
   1e786:	7896      	ldrb	r6, [r2, #2]
   1e788:	e7e1      	b.n	1e74e <ppp_vslprintf+0x5e>
	    width = va_arg(args, int);
   1e78a:	682a      	ldr	r2, [r5, #0]
	    c = *++fmt;
   1e78c:	785e      	ldrb	r6, [r3, #1]
	    width = va_arg(args, int);
   1e78e:	9208      	str	r2, [sp, #32]
   1e790:	3504      	adds	r5, #4
	    c = *++fmt;
   1e792:	3301      	adds	r3, #1
	    }
	}
	if (c == '.') {
   1e794:	2e2e      	cmp	r6, #46	; 0x2e
   1e796:	d137      	bne.n	1e808 <ppp_vslprintf+0x118>
	    c = *++fmt;
   1e798:	785e      	ldrb	r6, [r3, #1]
	    if (c == '*') {
   1e79a:	2e2a      	cmp	r6, #42	; 0x2a
   1e79c:	d016      	beq.n	1e7cc <ppp_vslprintf+0xdc>
		prec = va_arg(args, int);
		c = *++fmt;
	    } else {
		prec = 0;
		while (isdigit(c)) {
   1e79e:	4aa3      	ldr	r2, [pc, #652]	; (1ea2c <ppp_vslprintf+0x33c>)
   1e7a0:	3301      	adds	r3, #1
   1e7a2:	6812      	ldr	r2, [r2, #0]
   1e7a4:	9205      	str	r2, [sp, #20]
		prec = 0;
   1e7a6:	2200      	movs	r2, #0
   1e7a8:	9204      	str	r2, [sp, #16]
		while (isdigit(c)) {
   1e7aa:	2004      	movs	r0, #4
   1e7ac:	9a05      	ldr	r2, [sp, #20]
   1e7ae:	1c59      	adds	r1, r3, #1
   1e7b0:	1992      	adds	r2, r2, r6
   1e7b2:	7852      	ldrb	r2, [r2, #1]
   1e7b4:	4202      	tst	r2, r0
   1e7b6:	d00e      	beq.n	1e7d6 <ppp_vslprintf+0xe6>
		    prec = prec * 10 + c - '0';
   1e7b8:	200a      	movs	r0, #10
   1e7ba:	9a04      	ldr	r2, [sp, #16]
   1e7bc:	4342      	muls	r2, r0
   1e7be:	4694      	mov	ip, r2
   1e7c0:	4466      	add	r6, ip
   1e7c2:	3e30      	subs	r6, #48	; 0x30
   1e7c4:	9604      	str	r6, [sp, #16]
		    c = *++fmt;
   1e7c6:	785e      	ldrb	r6, [r3, #1]
   1e7c8:	000b      	movs	r3, r1
   1e7ca:	e7ee      	b.n	1e7aa <ppp_vslprintf+0xba>
		prec = va_arg(args, int);
   1e7cc:	682a      	ldr	r2, [r5, #0]
		c = *++fmt;
   1e7ce:	789e      	ldrb	r6, [r3, #2]
		prec = va_arg(args, int);
   1e7d0:	9204      	str	r2, [sp, #16]
   1e7d2:	3504      	adds	r5, #4
		c = *++fmt;
   1e7d4:	3302      	adds	r3, #2
	    }
	}
	str = 0;
	base = 0;
	neg = 0;
	++fmt;
   1e7d6:	1c5a      	adds	r2, r3, #1
   1e7d8:	9205      	str	r2, [sp, #20]
	switch (c) {
   1e7da:	2e6c      	cmp	r6, #108	; 0x6c
   1e7dc:	d054      	beq.n	1e888 <ppp_vslprintf+0x198>
   1e7de:	dc23      	bgt.n	1e828 <ppp_vslprintf+0x138>
   1e7e0:	2e58      	cmp	r6, #88	; 0x58
   1e7e2:	d100      	bne.n	1e7e6 <ppp_vslprintf+0xf6>
   1e7e4:	e08a      	b.n	1e8fc <ppp_vslprintf+0x20c>
   1e7e6:	dc13      	bgt.n	1e810 <ppp_vslprintf+0x120>
   1e7e8:	2e42      	cmp	r6, #66	; 0x42
   1e7ea:	d100      	bne.n	1e7ee <ppp_vslprintf+0xfe>
   1e7ec:	e114      	b.n	1ea18 <ppp_vslprintf+0x328>
   1e7ee:	2e49      	cmp	r6, #73	; 0x49
   1e7f0:	d100      	bne.n	1e7f4 <ppp_vslprintf+0x104>
   1e7f2:	e0a2      	b.n	1e93a <ppp_vslprintf+0x24a>
		OUTCHAR(hexchars[(c >> 4) & 0xf]);
		OUTCHAR(hexchars[c & 0xf]);
	    }
	    continue;
	default:
	    *buf++ = '%';
   1e7f4:	2125      	movs	r1, #37	; 0x25
   1e7f6:	1c7a      	adds	r2, r7, #1
   1e7f8:	7039      	strb	r1, [r7, #0]
	    if (c != '%')
   1e7fa:	428e      	cmp	r6, r1
   1e7fc:	d100      	bne.n	1e800 <ppp_vslprintf+0x110>
	++fmt;
   1e7fe:	9b05      	ldr	r3, [sp, #20]
		--fmt;		/* so %z outputs %z etc. */
	    --buflen;
   1e800:	3c01      	subs	r4, #1
	    continue;
   1e802:	9305      	str	r3, [sp, #20]
	    *buf++ = '%';
   1e804:	0017      	movs	r7, r2
	    continue;
   1e806:	e77a      	b.n	1e6fe <ppp_vslprintf+0xe>
	prec = -1;
   1e808:	2201      	movs	r2, #1
   1e80a:	4252      	negs	r2, r2
   1e80c:	9204      	str	r2, [sp, #16]
   1e80e:	e7e2      	b.n	1e7d6 <ppp_vslprintf+0xe6>
	switch (c) {
   1e810:	2e63      	cmp	r6, #99	; 0x63
   1e812:	d100      	bne.n	1e816 <ppp_vslprintf+0x126>
   1e814:	e088      	b.n	1e928 <ppp_vslprintf+0x238>
   1e816:	2e64      	cmp	r6, #100	; 0x64
   1e818:	d1ec      	bne.n	1e7f4 <ppp_vslprintf+0x104>
	    i = va_arg(args, int);
   1e81a:	6828      	ldr	r0, [r5, #0]
   1e81c:	1d2b      	adds	r3, r5, #4
   1e81e:	9306      	str	r3, [sp, #24]
	    if (i < 0) {
   1e820:	2800      	cmp	r0, #0
   1e822:	da2f      	bge.n	1e884 <ppp_vslprintf+0x194>
		val = -i;
   1e824:	4240      	negs	r0, r0
   1e826:	e04a      	b.n	1e8be <ppp_vslprintf+0x1ce>
	switch (c) {
   1e828:	2e73      	cmp	r6, #115	; 0x73
   1e82a:	d100      	bne.n	1e82e <ppp_vslprintf+0x13e>
   1e82c:	e06c      	b.n	1e908 <ppp_vslprintf+0x218>
   1e82e:	dc20      	bgt.n	1e872 <ppp_vslprintf+0x182>
   1e830:	2e6f      	cmp	r6, #111	; 0x6f
   1e832:	d050      	beq.n	1e8d6 <ppp_vslprintf+0x1e6>
   1e834:	2e71      	cmp	r6, #113	; 0x71
   1e836:	d1dd      	bne.n	1e7f4 <ppp_vslprintf+0x104>
	    p = va_arg(args, unsigned char *);
   1e838:	1d2b      	adds	r3, r5, #4
   1e83a:	682d      	ldr	r5, [r5, #0]
   1e83c:	9306      	str	r3, [sp, #24]
	    if (p == NULL)
   1e83e:	2d00      	cmp	r5, #0
   1e840:	d100      	bne.n	1e844 <ppp_vslprintf+0x154>
		p = (const unsigned char *)"<NULL>";
   1e842:	4d7b      	ldr	r5, [pc, #492]	; (1ea30 <ppp_vslprintf+0x340>)
	    if (fillch == '0' && prec >= 0) {
   1e844:	9b09      	ldr	r3, [sp, #36]	; 0x24
   1e846:	2b30      	cmp	r3, #48	; 0x30
   1e848:	d102      	bne.n	1e850 <ppp_vslprintf+0x160>
   1e84a:	9b04      	ldr	r3, [sp, #16]
   1e84c:	2b00      	cmp	r3, #0
   1e84e:	da08      	bge.n	1e862 <ppp_vslprintf+0x172>
		n = strlen((const char *)p);
   1e850:	0028      	movs	r0, r5
   1e852:	f7fc fda4 	bl	1b39e <strlen>
		if (prec >= 0 && n > prec)
   1e856:	9b04      	ldr	r3, [sp, #16]
   1e858:	2b00      	cmp	r3, #0
   1e85a:	db01      	blt.n	1e860 <ppp_vslprintf+0x170>
   1e85c:	4283      	cmp	r3, r0
   1e85e:	dd00      	ble.n	1e862 <ppp_vslprintf+0x172>
		n = strlen((const char *)p);
   1e860:	9004      	str	r0, [sp, #16]
	    while (n > 0 && buflen > 0) {
   1e862:	9b04      	ldr	r3, [sp, #16]
   1e864:	2b00      	cmp	r3, #0
   1e866:	dd02      	ble.n	1e86e <ppp_vslprintf+0x17e>
   1e868:	2c00      	cmp	r4, #0
   1e86a:	dd00      	ble.n	1e86e <ppp_vslprintf+0x17e>
   1e86c:	e07b      	b.n	1e966 <ppp_vslprintf+0x276>
	    p = va_arg(args, unsigned char *);
   1e86e:	9d06      	ldr	r5, [sp, #24]
   1e870:	e745      	b.n	1e6fe <ppp_vslprintf+0xe>
	switch (c) {
   1e872:	2e76      	cmp	r6, #118	; 0x76
   1e874:	d0e0      	beq.n	1e838 <ppp_vslprintf+0x148>
   1e876:	2e78      	cmp	r6, #120	; 0x78
   1e878:	d040      	beq.n	1e8fc <ppp_vslprintf+0x20c>
   1e87a:	2e75      	cmp	r6, #117	; 0x75
   1e87c:	d1ba      	bne.n	1e7f4 <ppp_vslprintf+0x104>
	    val = va_arg(args, unsigned int);
   1e87e:	1d2b      	adds	r3, r5, #4
   1e880:	6828      	ldr	r0, [r5, #0]
   1e882:	9306      	str	r3, [sp, #24]
	neg = 0;
   1e884:	2600      	movs	r6, #0
   1e886:	e01b      	b.n	1e8c0 <ppp_vslprintf+0x1d0>
	    c = *fmt++;
   1e888:	1c9a      	adds	r2, r3, #2
	    switch (c) {
   1e88a:	785b      	ldrb	r3, [r3, #1]
   1e88c:	2b64      	cmp	r3, #100	; 0x64
   1e88e:	d00f      	beq.n	1e8b0 <ppp_vslprintf+0x1c0>
   1e890:	2b75      	cmp	r3, #117	; 0x75
   1e892:	d017      	beq.n	1e8c4 <ppp_vslprintf+0x1d4>
		OUTCHAR('%');
   1e894:	2c00      	cmp	r4, #0
   1e896:	dc00      	bgt.n	1e89a <ppp_vslprintf+0x1aa>
   1e898:	e731      	b.n	1e6fe <ppp_vslprintf+0xe>
   1e89a:	2325      	movs	r3, #37	; 0x25
   1e89c:	703b      	strb	r3, [r7, #0]
		OUTCHAR('l');
   1e89e:	2c01      	cmp	r4, #1
   1e8a0:	d115      	bne.n	1e8ce <ppp_vslprintf+0x1de>
		OUTCHAR('%');
   1e8a2:	3701      	adds	r7, #1
	    len = buflen;
	memcpy(buf, str, len);
	buf += len;
	buflen -= len;
    }
    *buf = 0;
   1e8a4:	2300      	movs	r3, #0
   1e8a6:	703b      	strb	r3, [r7, #0]
    return buf - buf0;
   1e8a8:	9b0a      	ldr	r3, [sp, #40]	; 0x28
   1e8aa:	1af8      	subs	r0, r7, r3
}
   1e8ac:	b015      	add	sp, #84	; 0x54
   1e8ae:	bdf0      	pop	{r4, r5, r6, r7, pc}
		val = va_arg(args, long);
   1e8b0:	6828      	ldr	r0, [r5, #0]
   1e8b2:	1d2b      	adds	r3, r5, #4
   1e8b4:	9306      	str	r3, [sp, #24]
		if ((long)val < 0) {
   1e8b6:	2800      	cmp	r0, #0
   1e8b8:	da07      	bge.n	1e8ca <ppp_vslprintf+0x1da>
		    val = (unsigned long)-(long)val;
   1e8ba:	4240      	negs	r0, r0
	    c = *fmt++;
   1e8bc:	9205      	str	r2, [sp, #20]
		neg = 1;
   1e8be:	2601      	movs	r6, #1
	    base = 10;
   1e8c0:	230a      	movs	r3, #10
   1e8c2:	e00d      	b.n	1e8e0 <ppp_vslprintf+0x1f0>
		val = va_arg(args, unsigned long);
   1e8c4:	1d2b      	adds	r3, r5, #4
   1e8c6:	6828      	ldr	r0, [r5, #0]
   1e8c8:	9306      	str	r3, [sp, #24]
	    c = *fmt++;
   1e8ca:	9205      	str	r2, [sp, #20]
   1e8cc:	e7da      	b.n	1e884 <ppp_vslprintf+0x194>
		OUTCHAR('l');
   1e8ce:	707e      	strb	r6, [r7, #1]
   1e8d0:	3c02      	subs	r4, #2
   1e8d2:	3702      	adds	r7, #2
   1e8d4:	e713      	b.n	1e6fe <ppp_vslprintf+0xe>
	    val = va_arg(args, unsigned int);
   1e8d6:	1d2b      	adds	r3, r5, #4
   1e8d8:	9306      	str	r3, [sp, #24]
	neg = 0;
   1e8da:	2600      	movs	r6, #0
	    base = 8;
   1e8dc:	2308      	movs	r3, #8
	    val = va_arg(args, unsigned int);
   1e8de:	6828      	ldr	r0, [r5, #0]
	    *--str = 0;
   1e8e0:	2200      	movs	r2, #0
   1e8e2:	252f      	movs	r5, #47	; 0x2f
	    base = 10;
   1e8e4:	9307      	str	r3, [sp, #28]
	    *--str = 0;
   1e8e6:	ab0c      	add	r3, sp, #48	; 0x30
   1e8e8:	77da      	strb	r2, [r3, #31]
	    while (str > num + neg) {
   1e8ea:	930b      	str	r3, [sp, #44]	; 0x2c
	    *--str = 0;
   1e8ec:	aa08      	add	r2, sp, #32
   1e8ee:	9b04      	ldr	r3, [sp, #16]
   1e8f0:	18ad      	adds	r5, r5, r2
   1e8f2:	9a0b      	ldr	r2, [sp, #44]	; 0x2c
   1e8f4:	1a9b      	subs	r3, r3, r2
   1e8f6:	3b1f      	subs	r3, #31
   1e8f8:	9304      	str	r3, [sp, #16]
	    while (str > num + neg) {
   1e8fa:	e0ce      	b.n	1ea9a <ppp_vslprintf+0x3aa>
	    val = va_arg(args, unsigned int);
   1e8fc:	1d2b      	adds	r3, r5, #4
   1e8fe:	9306      	str	r3, [sp, #24]
   1e900:	6828      	ldr	r0, [r5, #0]
	neg = 0;
   1e902:	2600      	movs	r6, #0
	    base = 16;
   1e904:	2310      	movs	r3, #16
   1e906:	e7eb      	b.n	1e8e0 <ppp_vslprintf+0x1f0>
	    str = va_arg(args, char *);
   1e908:	1d2b      	adds	r3, r5, #4
   1e90a:	682d      	ldr	r5, [r5, #0]
   1e90c:	9306      	str	r3, [sp, #24]
	    len = strlen(str);
   1e90e:	0028      	movs	r0, r5
   1e910:	f7fc fd45 	bl	1b39e <strlen>
	    if (prec >= 0 && len > prec)
   1e914:	9b04      	ldr	r3, [sp, #16]
   1e916:	2b00      	cmp	r3, #0
   1e918:	da00      	bge.n	1e91c <ppp_vslprintf+0x22c>
   1e91a:	e0cb      	b.n	1eab4 <ppp_vslprintf+0x3c4>
   1e91c:	9b04      	ldr	r3, [sp, #16]
   1e91e:	4298      	cmp	r0, r3
   1e920:	dc00      	bgt.n	1e924 <ppp_vslprintf+0x234>
   1e922:	e0c7      	b.n	1eab4 <ppp_vslprintf+0x3c4>
   1e924:	0018      	movs	r0, r3
   1e926:	e0c5      	b.n	1eab4 <ppp_vslprintf+0x3c4>
	    num[0] = va_arg(args, int);
   1e928:	1d2b      	adds	r3, r5, #4
   1e92a:	682a      	ldr	r2, [r5, #0]
   1e92c:	9306      	str	r3, [sp, #24]
   1e92e:	ab0c      	add	r3, sp, #48	; 0x30
   1e930:	701a      	strb	r2, [r3, #0]
	    num[1] = 0;
   1e932:	2200      	movs	r2, #0
	    str = num;
   1e934:	001d      	movs	r5, r3
	    num[1] = 0;
   1e936:	705a      	strb	r2, [r3, #1]
	    break;
   1e938:	e7e9      	b.n	1e90e <ppp_vslprintf+0x21e>
   1e93a:	682a      	ldr	r2, [r5, #0]
	    ppp_slprintf(num, sizeof(num), "%d.%d.%d.%d", (ip >> 24) & 0xff,
   1e93c:	21ff      	movs	r1, #255	; 0xff
   1e93e:	ba12      	rev	r2, r2
   1e940:	0010      	movs	r0, r2
	    ip = va_arg(args, u32_t);
   1e942:	1d2b      	adds	r3, r5, #4
	    ppp_slprintf(num, sizeof(num), "%d.%d.%d.%d", (ip >> 24) & 0xff,
   1e944:	4008      	ands	r0, r1
	    ip = va_arg(args, u32_t);
   1e946:	9306      	str	r3, [sp, #24]
	    ppp_slprintf(num, sizeof(num), "%d.%d.%d.%d", (ip >> 24) & 0xff,
   1e948:	9002      	str	r0, [sp, #8]
   1e94a:	0e13      	lsrs	r3, r2, #24
		     (ip >> 16) & 0xff, (ip >> 8) & 0xff, ip & 0xff);
   1e94c:	0a10      	lsrs	r0, r2, #8
   1e94e:	0c12      	lsrs	r2, r2, #16
	    ppp_slprintf(num, sizeof(num), "%d.%d.%d.%d", (ip >> 24) & 0xff,
   1e950:	4008      	ands	r0, r1
   1e952:	400a      	ands	r2, r1
   1e954:	9001      	str	r0, [sp, #4]
   1e956:	9200      	str	r2, [sp, #0]
   1e958:	39df      	subs	r1, #223	; 0xdf
   1e95a:	4a36      	ldr	r2, [pc, #216]	; (1ea34 <ppp_vslprintf+0x344>)
   1e95c:	a80c      	add	r0, sp, #48	; 0x30
   1e95e:	f000 f903 	bl	1eb68 <ppp_slprintf>
	    str = num;
   1e962:	ad0c      	add	r5, sp, #48	; 0x30
	    break;
   1e964:	e7d3      	b.n	1e90e <ppp_vslprintf+0x21e>
		--n;
   1e966:	9b04      	ldr	r3, [sp, #16]
		c = *p++;
   1e968:	782a      	ldrb	r2, [r5, #0]
		--n;
   1e96a:	3b01      	subs	r3, #1
   1e96c:	9304      	str	r3, [sp, #16]
		if (!quoted && c >= 0x80) {
   1e96e:	2e71      	cmp	r6, #113	; 0x71
   1e970:	d100      	bne.n	1e974 <ppp_vslprintf+0x284>
   1e972:	e0c0      	b.n	1eaf6 <ppp_vslprintf+0x406>
   1e974:	003b      	movs	r3, r7
   1e976:	2a7f      	cmp	r2, #127	; 0x7f
   1e978:	dd06      	ble.n	1e988 <ppp_vslprintf+0x298>
		    OUTCHAR('M');
   1e97a:	214d      	movs	r1, #77	; 0x4d
   1e97c:	7039      	strb	r1, [r7, #0]
		    OUTCHAR('-');
   1e97e:	2c01      	cmp	r4, #1
   1e980:	d10c      	bne.n	1e99c <ppp_vslprintf+0x2ac>
		    OUTCHAR('M');
   1e982:	2400      	movs	r4, #0
   1e984:	3301      	adds	r3, #1
		    c -= 0x80;
   1e986:	3a80      	subs	r2, #128	; 0x80
		if (c < 0x20 || (0x7f <= c && c < 0xa0)) {
   1e988:	2a1f      	cmp	r2, #31
   1e98a:	dd00      	ble.n	1e98e <ppp_vslprintf+0x29e>
   1e98c:	e0bd      	b.n	1eb0a <ppp_vslprintf+0x41a>
			if (c == '\t')
   1e98e:	2a09      	cmp	r2, #9
   1e990:	d000      	beq.n	1e994 <ppp_vslprintf+0x2a4>
   1e992:	e0c1      	b.n	1eb18 <ppp_vslprintf+0x428>
		    OUTCHAR(c);
   1e994:	2c00      	cmp	r4, #0
   1e996:	d00c      	beq.n	1e9b2 <ppp_vslprintf+0x2c2>
   1e998:	3c01      	subs	r4, #1
   1e99a:	e01d      	b.n	1e9d8 <ppp_vslprintf+0x2e8>
		    OUTCHAR('-');
   1e99c:	212d      	movs	r1, #45	; 0x2d
   1e99e:	3c02      	subs	r4, #2
   1e9a0:	3302      	adds	r3, #2
   1e9a2:	7079      	strb	r1, [r7, #1]
   1e9a4:	e7ef      	b.n	1e986 <ppp_vslprintf+0x296>
			case '\t':	OUTCHAR('t');	break;
   1e9a6:	2c00      	cmp	r4, #0
   1e9a8:	d003      	beq.n	1e9b2 <ppp_vslprintf+0x2c2>
   1e9aa:	2274      	movs	r2, #116	; 0x74
   1e9ac:	1e8c      	subs	r4, r1, #2
   1e9ae:	1cbb      	adds	r3, r7, #2
			case '\b':	OUTCHAR('b');	break;
   1e9b0:	707a      	strb	r2, [r7, #1]
   1e9b2:	3501      	adds	r5, #1
			    OUTCHAR('^');
   1e9b4:	001f      	movs	r7, r3
   1e9b6:	e754      	b.n	1e862 <ppp_vslprintf+0x172>
			case '\n':	OUTCHAR('n');	break;
   1e9b8:	2c00      	cmp	r4, #0
   1e9ba:	d0fa      	beq.n	1e9b2 <ppp_vslprintf+0x2c2>
   1e9bc:	1e8c      	subs	r4, r1, #2
   1e9be:	1cbb      	adds	r3, r7, #2
   1e9c0:	226e      	movs	r2, #110	; 0x6e
   1e9c2:	e7f5      	b.n	1e9b0 <ppp_vslprintf+0x2c0>
			case '\b':	OUTCHAR('b');	break;
   1e9c4:	2c00      	cmp	r4, #0
   1e9c6:	d0f4      	beq.n	1e9b2 <ppp_vslprintf+0x2c2>
   1e9c8:	1e8c      	subs	r4, r1, #2
   1e9ca:	1cbb      	adds	r3, r7, #2
   1e9cc:	2262      	movs	r2, #98	; 0x62
   1e9ce:	e7ef      	b.n	1e9b0 <ppp_vslprintf+0x2c0>
			case '\f':	OUTCHAR('f');	break;
   1e9d0:	2c00      	cmp	r4, #0
   1e9d2:	d0ee      	beq.n	1e9b2 <ppp_vslprintf+0x2c2>
   1e9d4:	2266      	movs	r2, #102	; 0x66
   1e9d6:	3c01      	subs	r4, #1
		    OUTCHAR(c);
   1e9d8:	701a      	strb	r2, [r3, #0]
   1e9da:	3301      	adds	r3, #1
   1e9dc:	e7e9      	b.n	1e9b2 <ppp_vslprintf+0x2c2>
			    OUTCHAR('x');
   1e9de:	2c00      	cmp	r4, #0
   1e9e0:	d0e7      	beq.n	1e9b2 <ppp_vslprintf+0x2c2>
   1e9e2:	2378      	movs	r3, #120	; 0x78
   1e9e4:	707b      	strb	r3, [r7, #1]
   1e9e6:	1cbb      	adds	r3, r7, #2
			    OUTCHAR(hexchars[c >> 4]);
   1e9e8:	2902      	cmp	r1, #2
   1e9ea:	d100      	bne.n	1e9ee <ppp_vslprintf+0x2fe>
   1e9ec:	e09d      	b.n	1eb2a <ppp_vslprintf+0x43a>
   1e9ee:	4812      	ldr	r0, [pc, #72]	; (1ea38 <ppp_vslprintf+0x348>)
   1e9f0:	1113      	asrs	r3, r2, #4
   1e9f2:	5cc3      	ldrb	r3, [r0, r3]
   1e9f4:	70bb      	strb	r3, [r7, #2]
   1e9f6:	1cfb      	adds	r3, r7, #3
			    OUTCHAR(hexchars[c & 0xf]);
   1e9f8:	2903      	cmp	r1, #3
   1e9fa:	d100      	bne.n	1e9fe <ppp_vslprintf+0x30e>
   1e9fc:	e095      	b.n	1eb2a <ppp_vslprintf+0x43a>
   1e9fe:	1f0c      	subs	r4, r1, #4
   1ea00:	210f      	movs	r1, #15
   1ea02:	400a      	ands	r2, r1
   1ea04:	5c82      	ldrb	r2, [r0, r2]
   1ea06:	1d3b      	adds	r3, r7, #4
   1ea08:	70fa      	strb	r2, [r7, #3]
   1ea0a:	e7d2      	b.n	1e9b2 <ppp_vslprintf+0x2c2>
			    OUTCHAR(c ^ 0x40);
   1ea0c:	2140      	movs	r1, #64	; 0x40
   1ea0e:	404a      	eors	r2, r1
   1ea10:	705a      	strb	r2, [r3, #1]
   1ea12:	3c02      	subs	r4, #2
   1ea14:	3302      	adds	r3, #2
   1ea16:	e7cc      	b.n	1e9b2 <ppp_vslprintf+0x2c2>
		OUTCHAR(hexchars[c & 0xf]);
   1ea18:	230f      	movs	r3, #15
   1ea1a:	469c      	mov	ip, r3
   1ea1c:	682a      	ldr	r2, [r5, #0]
		OUTCHAR(hexchars[(c >> 4) & 0xf]);
   1ea1e:	4906      	ldr	r1, [pc, #24]	; (1ea38 <ppp_vslprintf+0x348>)
	    p = va_arg(args, unsigned char *);
   1ea20:	1d28      	adds	r0, r5, #4
	    for (n = prec; n > 0; --n) {
   1ea22:	9b04      	ldr	r3, [sp, #16]
   1ea24:	2b00      	cmp	r3, #0
   1ea26:	dc09      	bgt.n	1ea3c <ppp_vslprintf+0x34c>
	    p = va_arg(args, unsigned char *);
   1ea28:	0005      	movs	r5, r0
   1ea2a:	e668      	b.n	1e6fe <ppp_vslprintf+0xe>
   1ea2c:	010005dc 	.word	0x010005dc
   1ea30:	00025bf8 	.word	0x00025bf8
   1ea34:	00025bff 	.word	0x00025bff
   1ea38:	00025be3 	.word	0x00025be3
		if (fillch == ' ')
   1ea3c:	9e09      	ldr	r6, [sp, #36]	; 0x24
		c = *p++;
   1ea3e:	7813      	ldrb	r3, [r2, #0]
		if (fillch == ' ')
   1ea40:	2e20      	cmp	r6, #32
   1ea42:	d108      	bne.n	1ea56 <ppp_vslprintf+0x366>
		    OUTCHAR(' ');
   1ea44:	2c00      	cmp	r4, #0
   1ea46:	dd0f      	ble.n	1ea68 <ppp_vslprintf+0x378>
   1ea48:	466e      	mov	r6, sp
   1ea4a:	2524      	movs	r5, #36	; 0x24
   1ea4c:	1976      	adds	r6, r6, r5
   1ea4e:	7836      	ldrb	r6, [r6, #0]
   1ea50:	3c01      	subs	r4, #1
   1ea52:	703e      	strb	r6, [r7, #0]
   1ea54:	3701      	adds	r7, #1
		OUTCHAR(hexchars[(c >> 4) & 0xf]);
   1ea56:	2c00      	cmp	r4, #0
   1ea58:	dd06      	ble.n	1ea68 <ppp_vslprintf+0x378>
   1ea5a:	111e      	asrs	r6, r3, #4
   1ea5c:	5d8e      	ldrb	r6, [r1, r6]
   1ea5e:	703e      	strb	r6, [r7, #0]
		OUTCHAR(hexchars[c & 0xf]);
   1ea60:	2c01      	cmp	r4, #1
   1ea62:	d106      	bne.n	1ea72 <ppp_vslprintf+0x382>
		OUTCHAR(hexchars[(c >> 4) & 0xf]);
   1ea64:	2400      	movs	r4, #0
   1ea66:	3701      	adds	r7, #1
	    for (n = prec; n > 0; --n) {
   1ea68:	9b04      	ldr	r3, [sp, #16]
   1ea6a:	3201      	adds	r2, #1
   1ea6c:	3b01      	subs	r3, #1
   1ea6e:	9304      	str	r3, [sp, #16]
   1ea70:	e7d7      	b.n	1ea22 <ppp_vslprintf+0x332>
		OUTCHAR(hexchars[c & 0xf]);
   1ea72:	4665      	mov	r5, ip
   1ea74:	402b      	ands	r3, r5
   1ea76:	5ccb      	ldrb	r3, [r1, r3]
   1ea78:	3c02      	subs	r4, #2
   1ea7a:	707b      	strb	r3, [r7, #1]
   1ea7c:	3702      	adds	r7, #2
   1ea7e:	e7f3      	b.n	1ea68 <ppp_vslprintf+0x378>
   1ea80:	9907      	ldr	r1, [sp, #28]
   1ea82:	f7e1 fd1f 	bl	4c4 <__aeabi_uidivmod>
		*--str = hexchars[val % base];
   1ea86:	4b37      	ldr	r3, [pc, #220]	; (1eb64 <ppp_vslprintf+0x474>)
   1ea88:	3d01      	subs	r5, #1
   1ea8a:	5c5b      	ldrb	r3, [r3, r1]
   1ea8c:	702b      	strb	r3, [r5, #0]
   1ea8e:	9b04      	ldr	r3, [sp, #16]
   1ea90:	18eb      	adds	r3, r5, r3
		if (--prec <= 0 && val == 0)
   1ea92:	2b00      	cmp	r3, #0
   1ea94:	dc01      	bgt.n	1ea9a <ppp_vslprintf+0x3aa>
   1ea96:	2800      	cmp	r0, #0
   1ea98:	d003      	beq.n	1eaa2 <ppp_vslprintf+0x3b2>
	    while (str > num + neg) {
   1ea9a:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
   1ea9c:	199b      	adds	r3, r3, r6
   1ea9e:	429d      	cmp	r5, r3
   1eaa0:	d8ee      	bhi.n	1ea80 <ppp_vslprintf+0x390>
	    switch (neg) {
   1eaa2:	2e01      	cmp	r6, #1
   1eaa4:	d102      	bne.n	1eaac <ppp_vslprintf+0x3bc>
		*--str = '-';
   1eaa6:	232d      	movs	r3, #45	; 0x2d
   1eaa8:	3d01      	subs	r5, #1
   1eaaa:	702b      	strb	r3, [r5, #0]
	    len = num + sizeof(num) - 1 - str;
   1eaac:	202f      	movs	r0, #47	; 0x2f
   1eaae:	ab08      	add	r3, sp, #32
   1eab0:	18c0      	adds	r0, r0, r3
   1eab2:	1b40      	subs	r0, r0, r5
	if (width > 0) {
   1eab4:	9b08      	ldr	r3, [sp, #32]
   1eab6:	2b00      	cmp	r3, #0
   1eab8:	dd11      	ble.n	1eade <ppp_vslprintf+0x3ee>
	    if ((n = width - len) > 0) {
   1eaba:	9a08      	ldr	r2, [sp, #32]
   1eabc:	0023      	movs	r3, r4
   1eabe:	4294      	cmp	r4, r2
   1eac0:	dd00      	ble.n	1eac4 <ppp_vslprintf+0x3d4>
   1eac2:	0013      	movs	r3, r2
   1eac4:	1a1b      	subs	r3, r3, r0
   1eac6:	2b00      	cmp	r3, #0
   1eac8:	dd09      	ble.n	1eade <ppp_vslprintf+0x3ee>
		buflen -= n;
   1eaca:	1ae4      	subs	r4, r4, r3
   1eacc:	18fb      	adds	r3, r7, r3
		    *buf++ = fillch;
   1eace:	466a      	mov	r2, sp
   1ead0:	2124      	movs	r1, #36	; 0x24
   1ead2:	1852      	adds	r2, r2, r1
   1ead4:	7812      	ldrb	r2, [r2, #0]
   1ead6:	703a      	strb	r2, [r7, #0]
   1ead8:	3701      	adds	r7, #1
		for (; n > 0; --n)
   1eada:	429f      	cmp	r7, r3
   1eadc:	d1f7      	bne.n	1eace <ppp_vslprintf+0x3de>
   1eade:	0026      	movs	r6, r4
   1eae0:	4284      	cmp	r4, r0
   1eae2:	dd00      	ble.n	1eae6 <ppp_vslprintf+0x3f6>
   1eae4:	0006      	movs	r6, r0
	memcpy(buf, str, len);
   1eae6:	0038      	movs	r0, r7
   1eae8:	0032      	movs	r2, r6
   1eaea:	0029      	movs	r1, r5
   1eaec:	f7e1 fb80 	bl	1f0 <memcpy>
	buf += len;
   1eaf0:	19bf      	adds	r7, r7, r6
	buflen -= len;
   1eaf2:	1ba4      	subs	r4, r4, r6
   1eaf4:	e6bb      	b.n	1e86e <ppp_vslprintf+0x17e>
		if (quoted && (c == '"' || c == '\\'))
   1eaf6:	2a22      	cmp	r2, #34	; 0x22
   1eaf8:	d001      	beq.n	1eafe <ppp_vslprintf+0x40e>
   1eafa:	2a5c      	cmp	r2, #92	; 0x5c
   1eafc:	d117      	bne.n	1eb2e <ppp_vslprintf+0x43e>
		    OUTCHAR('\\');
   1eafe:	215c      	movs	r1, #92	; 0x5c
   1eb00:	3c01      	subs	r4, #1
   1eb02:	1c7b      	adds	r3, r7, #1
   1eb04:	7039      	strb	r1, [r7, #0]
		if (c < 0x20 || (0x7f <= c && c < 0xa0)) {
   1eb06:	2a1f      	cmp	r2, #31
   1eb08:	dd25      	ble.n	1eb56 <ppp_vslprintf+0x466>
   1eb0a:	0011      	movs	r1, r2
   1eb0c:	397f      	subs	r1, #127	; 0x7f
   1eb0e:	2920      	cmp	r1, #32
   1eb10:	d900      	bls.n	1eb14 <ppp_vslprintf+0x424>
   1eb12:	e73f      	b.n	1e994 <ppp_vslprintf+0x2a4>
		    if (quoted) {
   1eb14:	2e71      	cmp	r6, #113	; 0x71
   1eb16:	d01e      	beq.n	1eb56 <ppp_vslprintf+0x466>
			    OUTCHAR('^');
   1eb18:	2c00      	cmp	r4, #0
   1eb1a:	d100      	bne.n	1eb1e <ppp_vslprintf+0x42e>
   1eb1c:	e749      	b.n	1e9b2 <ppp_vslprintf+0x2c2>
   1eb1e:	215e      	movs	r1, #94	; 0x5e
   1eb20:	7019      	strb	r1, [r3, #0]
			    OUTCHAR(c ^ 0x40);
   1eb22:	2c01      	cmp	r4, #1
   1eb24:	d000      	beq.n	1eb28 <ppp_vslprintf+0x438>
   1eb26:	e771      	b.n	1ea0c <ppp_vslprintf+0x31c>
			    OUTCHAR('^');
   1eb28:	3301      	adds	r3, #1
   1eb2a:	2400      	movs	r4, #0
   1eb2c:	e741      	b.n	1e9b2 <ppp_vslprintf+0x2c2>
		if (c < 0x20 || (0x7f <= c && c < 0xa0)) {
   1eb2e:	003b      	movs	r3, r7
   1eb30:	2a1f      	cmp	r2, #31
   1eb32:	dcea      	bgt.n	1eb0a <ppp_vslprintf+0x41a>
   1eb34:	0021      	movs	r1, r4
			OUTCHAR('\\');
   1eb36:	205c      	movs	r0, #92	; 0x5c
   1eb38:	7038      	strb	r0, [r7, #0]
			switch (c) {
   1eb3a:	0010      	movs	r0, r2
   1eb3c:	3808      	subs	r0, #8
			OUTCHAR('\\');
   1eb3e:	3c01      	subs	r4, #1
   1eb40:	1c7b      	adds	r3, r7, #1
			switch (c) {
   1eb42:	2804      	cmp	r0, #4
   1eb44:	d900      	bls.n	1eb48 <ppp_vslprintf+0x458>
   1eb46:	e74a      	b.n	1e9de <ppp_vslprintf+0x2ee>
   1eb48:	f7e2 fe60 	bl	180c <__gnu_thumb1_case_shi>
   1eb4c:	ff2dff3c 	.word	0xff2dff3c
   1eb50:	ff49ff36 	.word	0xff49ff36
   1eb54:	ff42      	.short	0xff42
			OUTCHAR('\\');
   1eb56:	2c00      	cmp	r4, #0
   1eb58:	d100      	bne.n	1eb5c <ppp_vslprintf+0x46c>
   1eb5a:	e72a      	b.n	1e9b2 <ppp_vslprintf+0x2c2>
   1eb5c:	0021      	movs	r1, r4
   1eb5e:	001f      	movs	r7, r3
   1eb60:	e7e9      	b.n	1eb36 <ppp_vslprintf+0x446>
   1eb62:	46c0      	nop			; (mov r8, r8)
   1eb64:	00025be3 	.word	0x00025be3

0001eb68 <ppp_slprintf>:
int ppp_slprintf(char *buf, int buflen, const char *fmt, ...) {
   1eb68:	b40c      	push	{r2, r3}
   1eb6a:	b507      	push	{r0, r1, r2, lr}
   1eb6c:	ab04      	add	r3, sp, #16
   1eb6e:	cb04      	ldmia	r3!, {r2}
    va_start(args, fmt);
   1eb70:	9301      	str	r3, [sp, #4]
    n = ppp_vslprintf(buf, buflen, fmt, args);
   1eb72:	f7ff fdbd 	bl	1e6f0 <ppp_vslprintf>
}
   1eb76:	b003      	add	sp, #12
   1eb78:	bc08      	pop	{r3}
   1eb7a:	b002      	add	sp, #8
   1eb7c:	4718      	bx	r3
	...

0001eb80 <ppp_logit>:
}

/*
 * ppp_logit - does the hard work for fatal et al.
 */
static void ppp_logit(int level, const char *fmt, va_list args) {
   1eb80:	b510      	push	{r4, lr}
   1eb82:	0004      	movs	r4, r0
   1eb84:	b0a0      	sub	sp, #128	; 0x80
   1eb86:	0013      	movs	r3, r2
    char buf[128];

    ppp_vslprintf(buf, sizeof(buf), fmt, args);
   1eb88:	4668      	mov	r0, sp
   1eb8a:	000a      	movs	r2, r1
   1eb8c:	2180      	movs	r1, #128	; 0x80
   1eb8e:	f7ff fdaf 	bl	1e6f0 <ppp_vslprintf>
}

static void ppp_log_write(int level, char *buf) {
    LWIP_UNUSED_ARG(level); /* necessary if PPPDEBUG is defined to an empty function */
    LWIP_UNUSED_ARG(buf);
    PPPDEBUG(level, ("%s\n", buf) );
   1eb92:	07a3      	lsls	r3, r4, #30
   1eb94:	d003      	beq.n	1eb9e <ppp_logit+0x1e>
   1eb96:	4669      	mov	r1, sp
   1eb98:	4802      	ldr	r0, [pc, #8]	; (1eba4 <ppp_logit+0x24>)
   1eb9a:	f003 fbb7 	bl	2230c <lwip_support_log>
}
   1eb9e:	b020      	add	sp, #128	; 0x80
   1eba0:	bd10      	pop	{r4, pc}
   1eba2:	46c0      	nop			; (mov r8, r8)
   1eba4:	00025bf4 	.word	0x00025bf4

0001eba8 <ppp_error>:
}

/*
 * ppp_error - log an error message.
 */
void ppp_error(const char *fmt, ...) {
   1eba8:	b40f      	push	{r0, r1, r2, r3}
   1ebaa:	b507      	push	{r0, r1, r2, lr}
   1ebac:	aa04      	add	r2, sp, #16
   1ebae:	ca02      	ldmia	r2!, {r1}
    va_list pvar;

    va_start(pvar, fmt);
    ppp_logit(LOG_ERR, fmt, pvar);
   1ebb0:	2083      	movs	r0, #131	; 0x83
    va_start(pvar, fmt);
   1ebb2:	9201      	str	r2, [sp, #4]
    ppp_logit(LOG_ERR, fmt, pvar);
   1ebb4:	f7ff ffe4 	bl	1eb80 <ppp_logit>
    va_end(pvar);
#if 0 /* UNUSED */
    ++error_count;
#endif /* UNUSED */
}
   1ebb8:	b003      	add	sp, #12
   1ebba:	bc08      	pop	{r3}
   1ebbc:	b004      	add	sp, #16
   1ebbe:	4718      	bx	r3

0001ebc0 <ppp_warn>:

/*
 * ppp_warn - log a warning message.
 */
void ppp_warn(const char *fmt, ...) {
   1ebc0:	b40f      	push	{r0, r1, r2, r3}
   1ebc2:	b507      	push	{r0, r1, r2, lr}
   1ebc4:	aa04      	add	r2, sp, #16
   1ebc6:	ca02      	ldmia	r2!, {r1}
    va_list pvar;

    va_start(pvar, fmt);
    ppp_logit(LOG_WARNING, fmt, pvar);
   1ebc8:	2081      	movs	r0, #129	; 0x81
    va_start(pvar, fmt);
   1ebca:	9201      	str	r2, [sp, #4]
    ppp_logit(LOG_WARNING, fmt, pvar);
   1ebcc:	f7ff ffd8 	bl	1eb80 <ppp_logit>
    va_end(pvar);
}
   1ebd0:	b003      	add	sp, #12
   1ebd2:	bc08      	pop	{r3}
   1ebd4:	b004      	add	sp, #16
   1ebd6:	4718      	bx	r3

0001ebd8 <ppp_notice>:

/*
 * ppp_notice - log a notice-level message.
 */
void ppp_notice(const char *fmt, ...) {
   1ebd8:	b40f      	push	{r0, r1, r2, r3}
   1ebda:	b507      	push	{r0, r1, r2, lr}
   1ebdc:	aa04      	add	r2, sp, #16
   1ebde:	ca02      	ldmia	r2!, {r1}
    va_list pvar;

    va_start(pvar, fmt);
    ppp_logit(LOG_NOTICE, fmt, pvar);
   1ebe0:	2081      	movs	r0, #129	; 0x81
    va_start(pvar, fmt);
   1ebe2:	9201      	str	r2, [sp, #4]
    ppp_logit(LOG_NOTICE, fmt, pvar);
   1ebe4:	f7ff ffcc 	bl	1eb80 <ppp_logit>
    va_end(pvar);
}
   1ebe8:	b003      	add	sp, #12
   1ebea:	bc08      	pop	{r3}
   1ebec:	b004      	add	sp, #16
   1ebee:	4718      	bx	r3

0001ebf0 <ppp_info>:

/*
 * ppp_info - log an informational message.
 */
void ppp_info(const char *fmt, ...) {
   1ebf0:	b40f      	push	{r0, r1, r2, r3}
   1ebf2:	b507      	push	{r0, r1, r2, lr}
   1ebf4:	aa04      	add	r2, sp, #16
   1ebf6:	ca02      	ldmia	r2!, {r1}
    va_list pvar;

    va_start(pvar, fmt);
    ppp_logit(LOG_INFO, fmt, pvar);
   1ebf8:	2080      	movs	r0, #128	; 0x80
    va_start(pvar, fmt);
   1ebfa:	9201      	str	r2, [sp, #4]
    ppp_logit(LOG_INFO, fmt, pvar);
   1ebfc:	f7ff ffc0 	bl	1eb80 <ppp_logit>
    va_end(pvar);
}
   1ec00:	b003      	add	sp, #12
   1ec02:	bc08      	pop	{r3}
   1ec04:	b004      	add	sp, #16
   1ec06:	4718      	bx	r3

0001ec08 <ppp_dbglog>:

/*
 * ppp_dbglog - log a debug message.
 */
void ppp_dbglog(const char *fmt, ...) {
   1ec08:	b40f      	push	{r0, r1, r2, r3}
   1ec0a:	b507      	push	{r0, r1, r2, lr}
   1ec0c:	aa04      	add	r2, sp, #16
   1ec0e:	ca02      	ldmia	r2!, {r1}
    va_list pvar;

    va_start(pvar, fmt);
    ppp_logit(LOG_DEBUG, fmt, pvar);
   1ec10:	2080      	movs	r0, #128	; 0x80
    va_start(pvar, fmt);
   1ec12:	9201      	str	r2, [sp, #4]
    ppp_logit(LOG_DEBUG, fmt, pvar);
   1ec14:	f7ff ffb4 	bl	1eb80 <ppp_logit>
    va_end(pvar);
}
   1ec18:	b003      	add	sp, #12
   1ec1a:	bc08      	pop	{r3}
   1ec1c:	b004      	add	sp, #16
   1ec1e:	4718      	bx	r3

0001ec20 <link_required>:
/*
 * An Open on LCP has requested a change from Dead to Establish phase.
 */
void link_required(ppp_pcb *pcb) {
    LWIP_UNUSED_ARG(pcb);
}
   1ec20:	4770      	bx	lr
	...

0001ec24 <link_terminated>:

/*
 * LCP has terminated the link; go to the Dead phase and take the
 * physical layer down.
 */
void link_terminated(ppp_pcb *pcb) {
   1ec24:	b510      	push	{r4, lr}
    if (pcb->phase == PPP_PHASE_DEAD
   1ec26:	1c43      	adds	r3, r0, #1
   1ec28:	7fdb      	ldrb	r3, [r3, #31]
void link_terminated(ppp_pcb *pcb) {
   1ec2a:	0004      	movs	r4, r0
    if (pcb->phase == PPP_PHASE_DEAD
   1ec2c:	2b00      	cmp	r3, #0
   1ec2e:	d00b      	beq.n	1ec48 <link_terminated+0x24>
#ifdef HAVE_MULTILINK
    || pcb->phase == PPP_PHASE_MASTER
#endif /* HAVE_MULTILINK */
    )
	return;
    new_phase(pcb, PPP_PHASE_DISCONNECT);
   1ec30:	210c      	movs	r1, #12
   1ec32:	f7ff f9db 	bl	1dfec <new_phase>
    }
    session_end(devnam);
#endif /* UNUSED */

    if (!doing_multilink) {
	ppp_notice("Connection terminated.");
   1ec36:	4805      	ldr	r0, [pc, #20]	; (1ec4c <link_terminated+0x28>)
   1ec38:	f7ff ffce 	bl	1ebd8 <ppp_notice>
	print_link_stats();
#endif /* PPP_STATS_SUPPORT */
    } else
	ppp_notice("Link terminated.");

    lcp_lowerdown(pcb);
   1ec3c:	0020      	movs	r0, r4
   1ec3e:	f001 fdc7 	bl	207d0 <lcp_lowerdown>

    ppp_link_terminated(pcb);
   1ec42:	0020      	movs	r0, r4
   1ec44:	f7ff f98f 	bl	1df66 <ppp_link_terminated>
	else
	    mp_bundle_terminated();
    } else
	new_phase(pcb, PPP_PHASE_DEAD);
#endif
}
   1ec48:	bd10      	pop	{r4, pc}
   1ec4a:	46c0      	nop			; (mov r8, r8)
   1ec4c:	00025c28 	.word	0x00025c28

0001ec50 <upper_layers_down>:
    }
    /* XXX if doing_multilink, should do something to stop
       network-layer traffic on the link */
}

void upper_layers_down(ppp_pcb *pcb) {
   1ec50:	b570      	push	{r4, r5, r6, lr}
   1ec52:	0005      	movs	r5, r0
   1ec54:	4e0d      	ldr	r6, [pc, #52]	; (1ec8c <upper_layers_down+0x3c>)
    int i;
    const struct protent *protp;

    for (i = 0; (protp = protocols[i]) != NULL; ++i) {
   1ec56:	6834      	ldr	r4, [r6, #0]
   1ec58:	2c00      	cmp	r4, #0
   1ec5a:	d102      	bne.n	1ec62 <upper_layers_down+0x12>
        if (protp->protocol != PPP_LCP && protp->lowerdown != NULL)
	    (*protp->lowerdown)(pcb);
        if (protp->protocol < 0xC000 && protp->close != NULL)
	    (*protp->close)(pcb, "LCP down");
    }
    pcb->num_np_open = 0;
   1ec5c:	35d4      	adds	r5, #212	; 0xd4
   1ec5e:	802c      	strh	r4, [r5, #0]
    pcb->num_np_up = 0;
}
   1ec60:	bd70      	pop	{r4, r5, r6, pc}
        if (protp->protocol != PPP_LCP && protp->lowerdown != NULL)
   1ec62:	8822      	ldrh	r2, [r4, #0]
   1ec64:	4b0a      	ldr	r3, [pc, #40]	; (1ec90 <upper_layers_down+0x40>)
   1ec66:	429a      	cmp	r2, r3
   1ec68:	d004      	beq.n	1ec74 <upper_layers_down+0x24>
   1ec6a:	6963      	ldr	r3, [r4, #20]
   1ec6c:	2b00      	cmp	r3, #0
   1ec6e:	d001      	beq.n	1ec74 <upper_layers_down+0x24>
	    (*protp->lowerdown)(pcb);
   1ec70:	0028      	movs	r0, r5
   1ec72:	4798      	blx	r3
        if (protp->protocol < 0xC000 && protp->close != NULL)
   1ec74:	8822      	ldrh	r2, [r4, #0]
   1ec76:	4b07      	ldr	r3, [pc, #28]	; (1ec94 <upper_layers_down+0x44>)
   1ec78:	429a      	cmp	r2, r3
   1ec7a:	d805      	bhi.n	1ec88 <upper_layers_down+0x38>
   1ec7c:	69e3      	ldr	r3, [r4, #28]
   1ec7e:	2b00      	cmp	r3, #0
   1ec80:	d002      	beq.n	1ec88 <upper_layers_down+0x38>
	    (*protp->close)(pcb, "LCP down");
   1ec82:	4905      	ldr	r1, [pc, #20]	; (1ec98 <upper_layers_down+0x48>)
   1ec84:	0028      	movs	r0, r5
   1ec86:	4798      	blx	r3
   1ec88:	3604      	adds	r6, #4
   1ec8a:	e7e4      	b.n	1ec56 <upper_layers_down+0x6>
   1ec8c:	00025894 	.word	0x00025894
   1ec90:	0000c021 	.word	0x0000c021
   1ec94:	0000bfff 	.word	0x0000bfff
   1ec98:	00025c3f 	.word	0x00025c3f

0001ec9c <link_down>:
void link_down(ppp_pcb *pcb) {
   1ec9c:	b510      	push	{r4, lr}
   1ec9e:	0004      	movs	r4, r0
	upper_layers_down(pcb);
   1eca0:	f7ff ffd6 	bl	1ec50 <upper_layers_down>
	if (pcb->phase != PPP_PHASE_DEAD
   1eca4:	1c63      	adds	r3, r4, #1
   1eca6:	7fdb      	ldrb	r3, [r3, #31]
   1eca8:	2b00      	cmp	r3, #0
   1ecaa:	d003      	beq.n	1ecb4 <link_down+0x18>
	    new_phase(pcb, PPP_PHASE_ESTABLISH);
   1ecac:	2106      	movs	r1, #6
   1ecae:	0020      	movs	r0, r4
   1ecb0:	f7ff f99c 	bl	1dfec <new_phase>
}
   1ecb4:	bd10      	pop	{r4, pc}
	...

0001ecb8 <continue_networks>:
#endif /* MPPE_SUPPORT */
        )
	continue_networks(pcb);
}

void continue_networks(ppp_pcb *pcb) {
   1ecb8:	b570      	push	{r4, r5, r6, lr}
   1ecba:	0004      	movs	r4, r0
   1ecbc:	4d0e      	ldr	r5, [pc, #56]	; (1ecf8 <continue_networks+0x40>)
    const struct protent *protp;

    /*
     * Start the "real" network protocols.
     */
    for (i = 0; (protp = protocols[i]) != NULL; ++i)
   1ecbe:	682b      	ldr	r3, [r5, #0]
   1ecc0:	2b00      	cmp	r3, #0
   1ecc2:	d109      	bne.n	1ecd8 <continue_networks+0x20>
	    && protp->open != NULL) {
	    (*protp->open)(pcb);
	    ++pcb->num_np_open;
	}

    if (pcb->num_np_open == 0)
   1ecc4:	0023      	movs	r3, r4
   1ecc6:	33d4      	adds	r3, #212	; 0xd4
   1ecc8:	781b      	ldrb	r3, [r3, #0]
   1ecca:	2b00      	cmp	r3, #0
   1eccc:	d103      	bne.n	1ecd6 <continue_networks+0x1e>
	/* nothing to do */
	lcp_close(pcb, "No network protocols running");
   1ecce:	490b      	ldr	r1, [pc, #44]	; (1ecfc <continue_networks+0x44>)
   1ecd0:	0020      	movs	r0, r4
   1ecd2:	f001 fa79 	bl	201c8 <lcp_close>
}
   1ecd6:	bd70      	pop	{r4, r5, r6, pc}
	if (protp->protocol < 0xC000
   1ecd8:	8819      	ldrh	r1, [r3, #0]
   1ecda:	4a09      	ldr	r2, [pc, #36]	; (1ed00 <continue_networks+0x48>)
   1ecdc:	4291      	cmp	r1, r2
   1ecde:	d809      	bhi.n	1ecf4 <continue_networks+0x3c>
	    && protp->open != NULL) {
   1ece0:	699b      	ldr	r3, [r3, #24]
   1ece2:	2b00      	cmp	r3, #0
   1ece4:	d006      	beq.n	1ecf4 <continue_networks+0x3c>
	    (*protp->open)(pcb);
   1ece6:	0020      	movs	r0, r4
   1ece8:	4798      	blx	r3
	    ++pcb->num_np_open;
   1ecea:	0022      	movs	r2, r4
   1ecec:	32d4      	adds	r2, #212	; 0xd4
   1ecee:	7813      	ldrb	r3, [r2, #0]
   1ecf0:	3301      	adds	r3, #1
   1ecf2:	7013      	strb	r3, [r2, #0]
   1ecf4:	3504      	adds	r5, #4
   1ecf6:	e7e2      	b.n	1ecbe <continue_networks+0x6>
   1ecf8:	00025894 	.word	0x00025894
   1ecfc:	00025c0b 	.word	0x00025c0b
   1ed00:	0000bfff 	.word	0x0000bfff

0001ed04 <start_networks>:
void start_networks(ppp_pcb *pcb) {
   1ed04:	b510      	push	{r4, lr}
   1ed06:	0004      	movs	r4, r0
    new_phase(pcb, PPP_PHASE_NETWORK);
   1ed08:	2109      	movs	r1, #9
   1ed0a:	f7ff f96f 	bl	1dfec <new_phase>
	continue_networks(pcb);
   1ed0e:	0020      	movs	r0, r4
   1ed10:	f7ff ffd2 	bl	1ecb8 <continue_networks>
}
   1ed14:	bd10      	pop	{r4, pc}
	...

0001ed18 <link_established>:
void link_established(ppp_pcb *pcb) {
   1ed18:	b570      	push	{r4, r5, r6, lr}
   1ed1a:	0005      	movs	r5, r0
   1ed1c:	4c09      	ldr	r4, [pc, #36]	; (1ed44 <link_established+0x2c>)
	for (i = 0; (protp = protocols[i]) != NULL; ++i)
   1ed1e:	6823      	ldr	r3, [r4, #0]
   1ed20:	2b00      	cmp	r3, #0
   1ed22:	d103      	bne.n	1ed2c <link_established+0x14>
    start_networks(pcb);
   1ed24:	0028      	movs	r0, r5
   1ed26:	f7ff ffed 	bl	1ed04 <start_networks>
}
   1ed2a:	bd70      	pop	{r4, r5, r6, pc}
	    if (protp->protocol != PPP_LCP
   1ed2c:	8819      	ldrh	r1, [r3, #0]
   1ed2e:	4a06      	ldr	r2, [pc, #24]	; (1ed48 <link_established+0x30>)
   1ed30:	4291      	cmp	r1, r2
   1ed32:	d004      	beq.n	1ed3e <link_established+0x26>
		&& protp->lowerup != NULL)
   1ed34:	691b      	ldr	r3, [r3, #16]
   1ed36:	2b00      	cmp	r3, #0
   1ed38:	d001      	beq.n	1ed3e <link_established+0x26>
		(*protp->lowerup)(pcb);
   1ed3a:	0028      	movs	r0, r5
   1ed3c:	4798      	blx	r3
   1ed3e:	3404      	adds	r4, #4
   1ed40:	e7ed      	b.n	1ed1e <link_established+0x6>
   1ed42:	46c0      	nop			; (mov r8, r8)
   1ed44:	00025894 	.word	0x00025894
   1ed48:	0000c021 	.word	0x0000c021

0001ed4c <np_up>:


/*
 * np_up - a network protocol has come up.
 */
void np_up(ppp_pcb *pcb, int proto) {
   1ed4c:	b510      	push	{r4, lr}
#if PPP_IDLETIMELIMIT
    int tlim;
#endif /* PPP_IDLETIMELIMIT */
    LWIP_UNUSED_ARG(proto);

    if (pcb->num_np_up == 0) {
   1ed4e:	0004      	movs	r4, r0
   1ed50:	34d5      	adds	r4, #213	; 0xd5
   1ed52:	7823      	ldrb	r3, [r4, #0]
   1ed54:	2b00      	cmp	r3, #0
   1ed56:	d102      	bne.n	1ed5e <np_up+0x12>
	/*
	 * At this point we consider that the link has come up successfully.
	 */
	new_phase(pcb, PPP_PHASE_RUNNING);
   1ed58:	210a      	movs	r1, #10
   1ed5a:	f7ff f947 	bl	1dfec <new_phase>
	 */
	if (updetach && !nodetach)
	    detach();
#endif /* Unused */
    }
    ++pcb->num_np_up;
   1ed5e:	7823      	ldrb	r3, [r4, #0]
   1ed60:	3301      	adds	r3, #1
   1ed62:	7023      	strb	r3, [r4, #0]
}
   1ed64:	bd10      	pop	{r4, pc}

0001ed66 <np_down>:
/*
 * np_down - a network protocol has gone down.
 */
void np_down(ppp_pcb *pcb, int proto) {
    LWIP_UNUSED_ARG(proto);
    if (--pcb->num_np_up == 0) {
   1ed66:	0002      	movs	r2, r0
void np_down(ppp_pcb *pcb, int proto) {
   1ed68:	b510      	push	{r4, lr}
    if (--pcb->num_np_up == 0) {
   1ed6a:	32d5      	adds	r2, #213	; 0xd5
   1ed6c:	7813      	ldrb	r3, [r2, #0]
   1ed6e:	3b01      	subs	r3, #1
   1ed70:	b2db      	uxtb	r3, r3
   1ed72:	7013      	strb	r3, [r2, #0]
   1ed74:	2b00      	cmp	r3, #0
   1ed76:	d102      	bne.n	1ed7e <np_down+0x18>
	UNTIMEOUT(connect_time_expired, NULL);
#endif /* PPP_MAXCONNECT */
#ifdef MAXOCTETS
	UNTIMEOUT(check_maxoctets, NULL);
#endif
	new_phase(pcb, PPP_PHASE_NETWORK);
   1ed78:	2109      	movs	r1, #9
   1ed7a:	f7ff f937 	bl	1dfec <new_phase>
    }
}
   1ed7e:	bd10      	pop	{r4, pc}

0001ed80 <np_finished>:
/*
 * np_finished - a network protocol has finished using the link.
 */
void np_finished(ppp_pcb *pcb, int proto) {
    LWIP_UNUSED_ARG(proto);
    if (--pcb->num_np_open <= 0) {
   1ed80:	0002      	movs	r2, r0
void np_finished(ppp_pcb *pcb, int proto) {
   1ed82:	b510      	push	{r4, lr}
    if (--pcb->num_np_open <= 0) {
   1ed84:	32d4      	adds	r2, #212	; 0xd4
   1ed86:	7813      	ldrb	r3, [r2, #0]
   1ed88:	3b01      	subs	r3, #1
   1ed8a:	b2db      	uxtb	r3, r3
   1ed8c:	7013      	strb	r3, [r2, #0]
   1ed8e:	2b00      	cmp	r3, #0
   1ed90:	d102      	bne.n	1ed98 <np_finished+0x18>
	/* no further use for the link: shut up shop. */
	lcp_close(pcb, "No network protocols running");
   1ed92:	4902      	ldr	r1, [pc, #8]	; (1ed9c <np_finished+0x1c>)
   1ed94:	f001 fa18 	bl	201c8 <lcp_close>
    }
}
   1ed98:	bd10      	pop	{r4, pc}
   1ed9a:	46c0      	nop			; (mov r8, r8)
   1ed9c:	00025c0b 	.word	0x00025c0b

0001eda0 <ipcp_cilen>:

/*
 * ipcp_cilen - Return length of our CI.
 * Called by fsm_sconfreq, Send Configure Request.
 */
static int ipcp_cilen(fsm *f) {
   1eda0:	b510      	push	{r4, lr}

    /*
     * First see if we want to change our options to the old
     * forms because we have received old forms from the peer.
     */
    if (go->neg_addr && go->old_addrs && !ho->neg_addr && ho->old_addrs)
   1eda2:	2380      	movs	r3, #128	; 0x80
    ppp_pcb *pcb = f->pcb;
   1eda4:	6802      	ldr	r2, [r0, #0]
    if (go->neg_addr && go->old_addrs && !ho->neg_addr && ho->old_addrs)
   1eda6:	2003      	movs	r0, #3
   1eda8:	005b      	lsls	r3, r3, #1
   1edaa:	5cd1      	ldrb	r1, [r2, r3]
   1edac:	4008      	ands	r0, r1
   1edae:	2803      	cmp	r0, #3
   1edb0:	d108      	bne.n	1edc4 <ipcp_cilen+0x24>
   1edb2:	248c      	movs	r4, #140	; 0x8c
   1edb4:	0064      	lsls	r4, r4, #1
   1edb6:	5d14      	ldrb	r4, [r2, r4]
   1edb8:	4020      	ands	r0, r4
   1edba:	2802      	cmp	r0, #2
   1edbc:	d102      	bne.n	1edc4 <ipcp_cilen+0x24>
	go->neg_addr = 0;
   1edbe:	3801      	subs	r0, #1
   1edc0:	4381      	bics	r1, r0
   1edc2:	54d1      	strb	r1, [r2, r3]
	    go->vj_protocol = ho->vj_protocol;
	}
    }
#endif /* VJ_SUPPORT */

    return (LENCIADDRS(!go->neg_addr && go->old_addrs) +
   1edc4:	5cd3      	ldrb	r3, [r2, r3]
   1edc6:	2203      	movs	r2, #3
   1edc8:	200a      	movs	r0, #10
   1edca:	401a      	ands	r2, r3
   1edcc:	2a02      	cmp	r2, #2
   1edce:	d000      	beq.n	1edd2 <ipcp_cilen+0x32>
   1edd0:	2000      	movs	r0, #0
#if VJ_SUPPORT
	    LENCIVJ(go->neg_vj, go->old_vj) +
#endif /* VJ_SUPPORT */
	    LENCIADDR(go->neg_addr) +
   1edd2:	2206      	movs	r2, #6
   1edd4:	07db      	lsls	r3, r3, #31
   1edd6:	17db      	asrs	r3, r3, #31
   1edd8:	401a      	ands	r2, r3
   1edda:	1880      	adds	r0, r0, r2
#if 0 /* UNUSED - WINS */
	    LENCIWINS(go->winsaddr[0]) +
	    LENCIWINS(go->winsaddr[1]) +
#endif /* UNUSED - WINS */
	    0);
}
   1eddc:	bd10      	pop	{r4, pc}

0001edde <ipcp_addci>:

/*
 * ipcp_addci - Add our desired CIs to a packet.
 * Called by fsm_sconfreq, Send Configure Request.
 */
static void ipcp_addci(fsm *f, u_char *ucp, int *lenp) {
   1edde:	b570      	push	{r4, r5, r6, lr}
	} else \
	    addr = 0; \
    }
#endif /* UNUSED - WINS */

    ADDCIADDRS(CI_ADDRS, !go->neg_addr && go->old_addrs, go->ouraddr,
   1ede0:	2680      	movs	r6, #128	; 0x80
   1ede2:	2503      	movs	r5, #3
    ppp_pcb *pcb = f->pcb;
   1ede4:	6803      	ldr	r3, [r0, #0]
    ADDCIADDRS(CI_ADDRS, !go->neg_addr && go->old_addrs, go->ouraddr,
   1ede6:	0076      	lsls	r6, r6, #1
   1ede8:	5d9c      	ldrb	r4, [r3, r6]
    int len = *lenp;
   1edea:	6810      	ldr	r0, [r2, #0]
    ADDCIADDRS(CI_ADDRS, !go->neg_addr && go->old_addrs, go->ouraddr,
   1edec:	4025      	ands	r5, r4
   1edee:	2d02      	cmp	r5, #2
   1edf0:	d11b      	bne.n	1ee2a <ipcp_addci+0x4c>
   1edf2:	2809      	cmp	r0, #9
   1edf4:	dd34      	ble.n	1ee60 <ipcp_addci+0x82>
   1edf6:	2401      	movs	r4, #1
   1edf8:	001d      	movs	r5, r3
   1edfa:	700c      	strb	r4, [r1, #0]
   1edfc:	3409      	adds	r4, #9
   1edfe:	704c      	strb	r4, [r1, #1]
   1ee00:	35fc      	adds	r5, #252	; 0xfc
   1ee02:	68ac      	ldr	r4, [r5, #8]
   1ee04:	380a      	subs	r0, #10
   1ee06:	ba24      	rev	r4, r4
   1ee08:	0e26      	lsrs	r6, r4, #24
   1ee0a:	708e      	strb	r6, [r1, #2]
   1ee0c:	0c26      	lsrs	r6, r4, #16
   1ee0e:	70ce      	strb	r6, [r1, #3]
   1ee10:	0a26      	lsrs	r6, r4, #8
   1ee12:	710e      	strb	r6, [r1, #4]
   1ee14:	714c      	strb	r4, [r1, #5]
   1ee16:	68ec      	ldr	r4, [r5, #12]
   1ee18:	ba24      	rev	r4, r4
   1ee1a:	0e25      	lsrs	r5, r4, #24
   1ee1c:	718d      	strb	r5, [r1, #6]
   1ee1e:	0c25      	lsrs	r5, r4, #16
   1ee20:	71cd      	strb	r5, [r1, #7]
   1ee22:	0a25      	lsrs	r5, r4, #8
   1ee24:	720d      	strb	r5, [r1, #8]
   1ee26:	724c      	strb	r4, [r1, #9]
   1ee28:	310a      	adds	r1, #10
#if VJ_SUPPORT
    ADDCIVJ(CI_COMPRESSTYPE, go->neg_vj, go->vj_protocol, go->old_vj,
	    go->maxslotindex, go->cflag);
#endif /* VJ_SUPPORT */

    ADDCIADDR(CI_ADDR, go->neg_addr, go->ouraddr);
   1ee2a:	2580      	movs	r5, #128	; 0x80
   1ee2c:	2601      	movs	r6, #1
   1ee2e:	006d      	lsls	r5, r5, #1
   1ee30:	5d5c      	ldrb	r4, [r3, r5]
   1ee32:	4234      	tst	r4, r6
   1ee34:	d010      	beq.n	1ee58 <ipcp_addci+0x7a>
   1ee36:	2805      	cmp	r0, #5
   1ee38:	dd15      	ble.n	1ee66 <ipcp_addci+0x88>
   1ee3a:	2403      	movs	r4, #3
   1ee3c:	700c      	strb	r4, [r1, #0]
   1ee3e:	1924      	adds	r4, r4, r4
   1ee40:	704c      	strb	r4, [r1, #1]
   1ee42:	33fc      	adds	r3, #252	; 0xfc
   1ee44:	689b      	ldr	r3, [r3, #8]
   1ee46:	3806      	subs	r0, #6
   1ee48:	ba1b      	rev	r3, r3
   1ee4a:	0e1c      	lsrs	r4, r3, #24
   1ee4c:	708c      	strb	r4, [r1, #2]
   1ee4e:	0c1c      	lsrs	r4, r3, #16
   1ee50:	70cc      	strb	r4, [r1, #3]
   1ee52:	0a1c      	lsrs	r4, r3, #8
   1ee54:	710c      	strb	r4, [r1, #4]
   1ee56:	714b      	strb	r3, [r1, #5]
    ADDCIWINS(CI_MS_WINS1, go->winsaddr[0]);

    ADDCIWINS(CI_MS_WINS2, go->winsaddr[1]);
#endif /* UNUSED - WINS */
    
    *lenp -= len;
   1ee58:	6813      	ldr	r3, [r2, #0]
   1ee5a:	1a18      	subs	r0, r3, r0
   1ee5c:	6010      	str	r0, [r2, #0]
}
   1ee5e:	bd70      	pop	{r4, r5, r6, pc}
    ADDCIADDRS(CI_ADDRS, !go->neg_addr && go->old_addrs, go->ouraddr,
   1ee60:	43ac      	bics	r4, r5
   1ee62:	559c      	strb	r4, [r3, r6]
   1ee64:	e7e1      	b.n	1ee2a <ipcp_addci+0x4c>
    ADDCIADDR(CI_ADDR, go->neg_addr, go->ouraddr);
   1ee66:	43b4      	bics	r4, r6
   1ee68:	555c      	strb	r4, [r3, r5]
   1ee6a:	e7f5      	b.n	1ee58 <ipcp_addci+0x7a>

0001ee6c <ipcp_ackci>:
	if (addr != cilong) \
	    goto bad; \
    }
#endif /* UNUSED - WINS */

    ACKCIADDRS(CI_ADDRS, !go->neg_addr && go->old_addrs, go->ouraddr,
   1ee6c:	2380      	movs	r3, #128	; 0x80
static int ipcp_ackci(fsm *f, u_char *p, int len) {
   1ee6e:	b5f0      	push	{r4, r5, r6, r7, lr}
    ppp_pcb *pcb = f->pcb;
   1ee70:	6804      	ldr	r4, [r0, #0]
    ACKCIADDRS(CI_ADDRS, !go->neg_addr && go->old_addrs, go->ouraddr,
   1ee72:	005b      	lsls	r3, r3, #1
   1ee74:	5ce5      	ldrb	r5, [r4, r3]
   1ee76:	3bfd      	subs	r3, #253	; 0xfd
   1ee78:	402b      	ands	r3, r5
   1ee7a:	2b02      	cmp	r3, #2
   1ee7c:	d12b      	bne.n	1eed6 <ipcp_ackci+0x6a>
	goto bad;
    return (1);

bad:
    IPCPDEBUG(("ipcp_ackci: received bad Ack!"));
    return (0);
   1ee7e:	2000      	movs	r0, #0
    ACKCIADDRS(CI_ADDRS, !go->neg_addr && go->old_addrs, go->ouraddr,
   1ee80:	3a0a      	subs	r2, #10
   1ee82:	d447      	bmi.n	1ef14 <ipcp_ackci+0xa8>
   1ee84:	784b      	ldrb	r3, [r1, #1]
   1ee86:	2b0a      	cmp	r3, #10
   1ee88:	d144      	bne.n	1ef14 <ipcp_ackci+0xa8>
   1ee8a:	780b      	ldrb	r3, [r1, #0]
   1ee8c:	2b01      	cmp	r3, #1
   1ee8e:	d141      	bne.n	1ef14 <ipcp_ackci+0xa8>
   1ee90:	78cb      	ldrb	r3, [r1, #3]
   1ee92:	788e      	ldrb	r6, [r1, #2]
   1ee94:	021b      	lsls	r3, r3, #8
   1ee96:	4333      	orrs	r3, r6
   1ee98:	ba5b      	rev16	r3, r3
   1ee9a:	b29b      	uxth	r3, r3
   1ee9c:	790e      	ldrb	r6, [r1, #4]
   1ee9e:	021b      	lsls	r3, r3, #8
   1eea0:	431e      	orrs	r6, r3
   1eea2:	794b      	ldrb	r3, [r1, #5]
   1eea4:	0236      	lsls	r6, r6, #8
   1eea6:	4333      	orrs	r3, r6
   1eea8:	1c66      	adds	r6, r4, #1
   1eeaa:	36ff      	adds	r6, #255	; 0xff
   1eeac:	6877      	ldr	r7, [r6, #4]
   1eeae:	ba1b      	rev	r3, r3
   1eeb0:	429f      	cmp	r7, r3
   1eeb2:	d12f      	bne.n	1ef14 <ipcp_ackci+0xa8>
   1eeb4:	79cb      	ldrb	r3, [r1, #7]
   1eeb6:	798f      	ldrb	r7, [r1, #6]
   1eeb8:	021b      	lsls	r3, r3, #8
   1eeba:	433b      	orrs	r3, r7
   1eebc:	ba5b      	rev16	r3, r3
   1eebe:	b29b      	uxth	r3, r3
   1eec0:	7a0f      	ldrb	r7, [r1, #8]
   1eec2:	021b      	lsls	r3, r3, #8
   1eec4:	431f      	orrs	r7, r3
   1eec6:	7a4b      	ldrb	r3, [r1, #9]
   1eec8:	023f      	lsls	r7, r7, #8
   1eeca:	433b      	orrs	r3, r7
   1eecc:	68b6      	ldr	r6, [r6, #8]
   1eece:	ba1b      	rev	r3, r3
   1eed0:	429e      	cmp	r6, r3
   1eed2:	d11f      	bne.n	1ef14 <ipcp_ackci+0xa8>
   1eed4:	310a      	adds	r1, #10
    ACKCIADDR(CI_ADDR, go->neg_addr, go->ouraddr);
   1eed6:	07eb      	lsls	r3, r5, #31
   1eed8:	d51a      	bpl.n	1ef10 <ipcp_ackci+0xa4>
    return (0);
   1eeda:	2000      	movs	r0, #0
    ACKCIADDR(CI_ADDR, go->neg_addr, go->ouraddr);
   1eedc:	3a06      	subs	r2, #6
   1eede:	d419      	bmi.n	1ef14 <ipcp_ackci+0xa8>
   1eee0:	784b      	ldrb	r3, [r1, #1]
   1eee2:	2b06      	cmp	r3, #6
   1eee4:	d116      	bne.n	1ef14 <ipcp_ackci+0xa8>
   1eee6:	780b      	ldrb	r3, [r1, #0]
   1eee8:	2b03      	cmp	r3, #3
   1eeea:	d113      	bne.n	1ef14 <ipcp_ackci+0xa8>
   1eeec:	78cb      	ldrb	r3, [r1, #3]
   1eeee:	788d      	ldrb	r5, [r1, #2]
   1eef0:	021b      	lsls	r3, r3, #8
   1eef2:	432b      	orrs	r3, r5
   1eef4:	ba5b      	rev16	r3, r3
   1eef6:	790d      	ldrb	r5, [r1, #4]
   1eef8:	b29b      	uxth	r3, r3
   1eefa:	021b      	lsls	r3, r3, #8
   1eefc:	431d      	orrs	r5, r3
   1eefe:	3401      	adds	r4, #1
   1ef00:	794b      	ldrb	r3, [r1, #5]
   1ef02:	022d      	lsls	r5, r5, #8
   1ef04:	34ff      	adds	r4, #255	; 0xff
   1ef06:	432b      	orrs	r3, r5
   1ef08:	6861      	ldr	r1, [r4, #4]
   1ef0a:	ba1b      	rev	r3, r3
   1ef0c:	4299      	cmp	r1, r3
   1ef0e:	d101      	bne.n	1ef14 <ipcp_ackci+0xa8>
    return (1);
   1ef10:	4250      	negs	r0, r2
   1ef12:	4150      	adcs	r0, r2
}
   1ef14:	bdf0      	pop	{r4, r5, r6, r7, pc}

0001ef16 <ipcp_rejci>:

/*
 * ipcp_rejci - Reject some of our CIs.
 * Callback from fsm_rconfnakrej.
 */
static int ipcp_rejci(fsm *f, u_char *p, int len) {
   1ef16:	b5f0      	push	{r4, r5, r6, r7, lr}
    ppp_pcb *pcb = f->pcb;
   1ef18:	6803      	ldr	r3, [r0, #0]
static int ipcp_rejci(fsm *f, u_char *p, int len) {
   1ef1a:	b087      	sub	sp, #28
   1ef1c:	9001      	str	r0, [sp, #4]
    u_short cishort;
#endif /* VJ_SUPPORT */
    u32_t cilong;
    ipcp_options try_;		/* options to request next time */

    try_ = *go;
   1ef1e:	1c58      	adds	r0, r3, #1
   1ef20:	ac03      	add	r4, sp, #12
   1ef22:	30ff      	adds	r0, #255	; 0xff
   1ef24:	c8e0      	ldmia	r0!, {r5, r6, r7}
   1ef26:	c4e0      	stmia	r4!, {r5, r6, r7}
   1ef28:	2080      	movs	r0, #128	; 0x80
   1ef2a:	0040      	lsls	r0, r0, #1
   1ef2c:	5c1e      	ldrb	r6, [r3, r0]
   1ef2e:	07f0      	lsls	r0, r6, #31
   1ef30:	0fc0      	lsrs	r0, r0, #31
   1ef32:	9000      	str	r0, [sp, #0]
	    goto bad; \
	try_.winsaddr[opt == CI_MS_WINS2] = 0; \
    }
#endif /* UNUSED - WINS */

    REJCIADDRS(CI_ADDRS, !go->neg_addr && go->old_addrs,
   1ef34:	2003      	movs	r0, #3
    try_ = *go;
   1ef36:	07b7      	lsls	r7, r6, #30
   1ef38:	0fff      	lsrs	r7, r7, #31
    REJCIADDRS(CI_ADDRS, !go->neg_addr && go->old_addrs,
   1ef3a:	4030      	ands	r0, r6
   1ef3c:	2802      	cmp	r0, #2
   1ef3e:	d131      	bne.n	1efa4 <ipcp_rejci+0x8e>
   1ef40:	7848      	ldrb	r0, [r1, #1]
   1ef42:	280a      	cmp	r0, #10
   1ef44:	d12e      	bne.n	1efa4 <ipcp_rejci+0x8e>
   1ef46:	2a09      	cmp	r2, #9
   1ef48:	dd2c      	ble.n	1efa4 <ipcp_rejci+0x8e>
   1ef4a:	7808      	ldrb	r0, [r1, #0]
   1ef4c:	2801      	cmp	r0, #1
   1ef4e:	d129      	bne.n	1efa4 <ipcp_rejci+0x8e>
   1ef50:	78c8      	ldrb	r0, [r1, #3]
   1ef52:	788c      	ldrb	r4, [r1, #2]
   1ef54:	0200      	lsls	r0, r0, #8
   1ef56:	4320      	orrs	r0, r4
   1ef58:	ba40      	rev16	r0, r0
   1ef5a:	790c      	ldrb	r4, [r1, #4]
   1ef5c:	b280      	uxth	r0, r0
   1ef5e:	0200      	lsls	r0, r0, #8
   1ef60:	4320      	orrs	r0, r4
   1ef62:	1c5f      	adds	r7, r3, #1
   1ef64:	794c      	ldrb	r4, [r1, #5]
   1ef66:	0200      	lsls	r0, r0, #8
   1ef68:	37ff      	adds	r7, #255	; 0xff
   1ef6a:	4304      	orrs	r4, r0
   1ef6c:	687d      	ldr	r5, [r7, #4]
   1ef6e:	ba24      	rev	r4, r4
	*go = try_;
    return 1;

bad:
    IPCPDEBUG(("ipcp_rejci: received bad Reject!"));
    return 0;
   1ef70:	2000      	movs	r0, #0
    REJCIADDRS(CI_ADDRS, !go->neg_addr && go->old_addrs,
   1ef72:	42a5      	cmp	r5, r4
   1ef74:	d14d      	bne.n	1f012 <ipcp_rejci+0xfc>
   1ef76:	798c      	ldrb	r4, [r1, #6]
   1ef78:	68bf      	ldr	r7, [r7, #8]
   1ef7a:	46a4      	mov	ip, r4
   1ef7c:	4665      	mov	r5, ip
   1ef7e:	79cc      	ldrb	r4, [r1, #7]
   1ef80:	0224      	lsls	r4, r4, #8
   1ef82:	432c      	orrs	r4, r5
   1ef84:	ba64      	rev16	r4, r4
   1ef86:	7a0d      	ldrb	r5, [r1, #8]
   1ef88:	b2a4      	uxth	r4, r4
   1ef8a:	0224      	lsls	r4, r4, #8
   1ef8c:	432c      	orrs	r4, r5
   1ef8e:	0224      	lsls	r4, r4, #8
   1ef90:	46a4      	mov	ip, r4
   1ef92:	4665      	mov	r5, ip
   1ef94:	7a4c      	ldrb	r4, [r1, #9]
   1ef96:	432c      	orrs	r4, r5
   1ef98:	ba24      	rev	r4, r4
   1ef9a:	42a7      	cmp	r7, r4
   1ef9c:	d139      	bne.n	1f012 <ipcp_rejci+0xfc>
   1ef9e:	0007      	movs	r7, r0
   1efa0:	3a0a      	subs	r2, #10
   1efa2:	310a      	adds	r1, #10
    REJCIADDR(CI_ADDR, neg_addr, go->ouraddr);
   1efa4:	07f0      	lsls	r0, r6, #31
   1efa6:	d51c      	bpl.n	1efe2 <ipcp_rejci+0xcc>
   1efa8:	7848      	ldrb	r0, [r1, #1]
   1efaa:	2806      	cmp	r0, #6
   1efac:	d119      	bne.n	1efe2 <ipcp_rejci+0xcc>
   1efae:	2a05      	cmp	r2, #5
   1efb0:	dd17      	ble.n	1efe2 <ipcp_rejci+0xcc>
   1efb2:	780c      	ldrb	r4, [r1, #0]
    return 0;
   1efb4:	2000      	movs	r0, #0
    REJCIADDR(CI_ADDR, neg_addr, go->ouraddr);
   1efb6:	2c03      	cmp	r4, #3
   1efb8:	d12b      	bne.n	1f012 <ipcp_rejci+0xfc>
   1efba:	78cc      	ldrb	r4, [r1, #3]
   1efbc:	788e      	ldrb	r6, [r1, #2]
   1efbe:	0224      	lsls	r4, r4, #8
   1efc0:	4334      	orrs	r4, r6
   1efc2:	ba64      	rev16	r4, r4
   1efc4:	790e      	ldrb	r6, [r1, #4]
   1efc6:	b2a4      	uxth	r4, r4
   1efc8:	0224      	lsls	r4, r4, #8
   1efca:	4326      	orrs	r6, r4
   1efcc:	794c      	ldrb	r4, [r1, #5]
   1efce:	1c59      	adds	r1, r3, #1
   1efd0:	0236      	lsls	r6, r6, #8
   1efd2:	31ff      	adds	r1, #255	; 0xff
   1efd4:	4334      	orrs	r4, r6
   1efd6:	6849      	ldr	r1, [r1, #4]
   1efd8:	ba24      	rev	r4, r4
   1efda:	42a1      	cmp	r1, r4
   1efdc:	d119      	bne.n	1f012 <ipcp_rejci+0xfc>
   1efde:	3a06      	subs	r2, #6
   1efe0:	9000      	str	r0, [sp, #0]
    return 0;
   1efe2:	2000      	movs	r0, #0
    if (len != 0)
   1efe4:	4282      	cmp	r2, r0
   1efe6:	d114      	bne.n	1f012 <ipcp_rejci+0xfc>
    if (f->state != PPP_FSM_OPENED)
   1efe8:	9a01      	ldr	r2, [sp, #4]
   1efea:	7c11      	ldrb	r1, [r2, #16]
   1efec:	2201      	movs	r2, #1
    return 1;
   1efee:	0010      	movs	r0, r2
    if (f->state != PPP_FSM_OPENED)
   1eff0:	2909      	cmp	r1, #9
   1eff2:	d00e      	beq.n	1f012 <ipcp_rejci+0xfc>
	*go = try_;
   1eff4:	a903      	add	r1, sp, #12
   1eff6:	7808      	ldrb	r0, [r1, #0]
   1eff8:	007c      	lsls	r4, r7, #1
   1effa:	9f00      	ldr	r7, [sp, #0]
   1effc:	4390      	bics	r0, r2
   1effe:	4307      	orrs	r7, r0
   1f000:	2002      	movs	r0, #2
   1f002:	4387      	bics	r7, r0
   1f004:	4327      	orrs	r7, r4
   1f006:	3301      	adds	r3, #1
   1f008:	700f      	strb	r7, [r1, #0]
   1f00a:	33ff      	adds	r3, #255	; 0xff
   1f00c:	c931      	ldmia	r1!, {r0, r4, r5}
   1f00e:	c331      	stmia	r3!, {r0, r4, r5}
    return 1;
   1f010:	0010      	movs	r0, r2
}
   1f012:	b007      	add	sp, #28
   1f014:	bdf0      	pop	{r4, r5, r6, r7, pc}

0001f016 <ipcp_close>:
static void ipcp_close(ppp_pcb *pcb, const char *reason) {
   1f016:	b510      	push	{r4, lr}
    fsm *f = &pcb->ipcp_fsm;
   1f018:	30d8      	adds	r0, #216	; 0xd8
    fsm_close(f, reason);
   1f01a:	f001 fe57 	bl	20ccc <fsm_close>
}
   1f01e:	bd10      	pop	{r4, pc}

0001f020 <ipcp_open>:
static void ipcp_open(ppp_pcb *pcb) {
   1f020:	b510      	push	{r4, lr}
   1f022:	0004      	movs	r4, r0
    fsm *f = &pcb->ipcp_fsm;
   1f024:	30d8      	adds	r0, #216	; 0xd8
    fsm_open(f);
   1f026:	f001 fd47 	bl	20ab8 <fsm_open>
    pcb->ipcp_is_open = 1;
   1f02a:	2302      	movs	r3, #2
   1f02c:	3403      	adds	r4, #3
   1f02e:	7fe2      	ldrb	r2, [r4, #31]
   1f030:	4313      	orrs	r3, r2
   1f032:	77e3      	strb	r3, [r4, #31]
}
   1f034:	bd10      	pop	{r4, pc}

0001f036 <ipcp_lowerdown>:
static void ipcp_lowerdown(ppp_pcb *pcb) {
   1f036:	b510      	push	{r4, lr}
    fsm *f = &pcb->ipcp_fsm;
   1f038:	30d8      	adds	r0, #216	; 0xd8
    fsm_lowerdown(f);
   1f03a:	f001 fd11 	bl	20a60 <fsm_lowerdown>
}
   1f03e:	bd10      	pop	{r4, pc}

0001f040 <ipcp_lowerup>:
static void ipcp_lowerup(ppp_pcb *pcb) {
   1f040:	b510      	push	{r4, lr}
    fsm *f = &pcb->ipcp_fsm;
   1f042:	30d8      	adds	r0, #216	; 0xd8
    fsm_lowerup(f);
   1f044:	f001 fcf6 	bl	20a34 <fsm_lowerup>
}
   1f048:	bd10      	pop	{r4, pc}

0001f04a <ipcp_input>:
static void ipcp_input(ppp_pcb *pcb, u_char *p, int len) {
   1f04a:	b510      	push	{r4, lr}
    fsm *f = &pcb->ipcp_fsm;
   1f04c:	30d8      	adds	r0, #216	; 0xd8
    fsm_input(f, p, len);
   1f04e:	f001 fe8d 	bl	20d6c <fsm_input>
}
   1f052:	bd10      	pop	{r4, pc}

0001f054 <ipcp_init>:
static void ipcp_init(ppp_pcb *pcb) {
   1f054:	b570      	push	{r4, r5, r6, lr}
    f->pcb = pcb;
   1f056:	0005      	movs	r5, r0
static void ipcp_init(ppp_pcb *pcb) {
   1f058:	0004      	movs	r4, r0
    f->protocol = PPP_IPCP;
   1f05a:	4b0d      	ldr	r3, [pc, #52]	; (1f090 <ipcp_init+0x3c>)
    f->pcb = pcb;
   1f05c:	35d8      	adds	r5, #216	; 0xd8
    f->protocol = PPP_IPCP;
   1f05e:	81eb      	strh	r3, [r5, #14]
    f->callbacks = &ipcp_callbacks;
   1f060:	4b0c      	ldr	r3, [pc, #48]	; (1f094 <ipcp_init+0x40>)
    f->pcb = pcb;
   1f062:	6028      	str	r0, [r5, #0]
    f->callbacks = &ipcp_callbacks;
   1f064:	606b      	str	r3, [r5, #4]
    fsm_init(f);
   1f066:	0028      	movs	r0, r5
   1f068:	f001 fcdc 	bl	20a24 <fsm_init>
    f->maxnakloops = 100;
   1f06c:	2364      	movs	r3, #100	; 0x64
    wo->neg_addr = wo->old_addrs = 1;
   1f06e:	0020      	movs	r0, r4
   1f070:	2102      	movs	r1, #2
   1f072:	2201      	movs	r2, #1
    f->maxnakloops = 100;
   1f074:	75eb      	strb	r3, [r5, #23]
    wo->neg_addr = wo->old_addrs = 1;
   1f076:	30f4      	adds	r0, #244	; 0xf4
   1f078:	7803      	ldrb	r3, [r0, #0]
   1f07a:	430b      	orrs	r3, r1
   1f07c:	4313      	orrs	r3, r2
   1f07e:	7003      	strb	r3, [r0, #0]
    ao->neg_addr = ao->old_addrs = 1;
   1f080:	2386      	movs	r3, #134	; 0x86
   1f082:	005b      	lsls	r3, r3, #1
   1f084:	5ce0      	ldrb	r0, [r4, r3]
   1f086:	4301      	orrs	r1, r0
   1f088:	430a      	orrs	r2, r1
   1f08a:	54e2      	strb	r2, [r4, r3]
}
   1f08c:	bd70      	pop	{r4, r5, r6, pc}
   1f08e:	46c0      	nop			; (mov r8, r8)
   1f090:	ffff8021 	.word	0xffff8021
   1f094:	00025c48 	.word	0x00025c48

0001f098 <ipcp_finished>:
/*
 * ipcp_finished - possibly shut down the lower layers.
 */
static void ipcp_finished(fsm *f) {
	ppp_pcb *pcb = f->pcb;
	if (pcb->ipcp_is_open) {
   1f098:	2102      	movs	r1, #2
static void ipcp_finished(fsm *f) {
   1f09a:	b510      	push	{r4, lr}
	ppp_pcb *pcb = f->pcb;
   1f09c:	6800      	ldr	r0, [r0, #0]
	if (pcb->ipcp_is_open) {
   1f09e:	1cc2      	adds	r2, r0, #3
   1f0a0:	7fd3      	ldrb	r3, [r2, #31]
   1f0a2:	420b      	tst	r3, r1
   1f0a4:	d004      	beq.n	1f0b0 <ipcp_finished+0x18>
		pcb->ipcp_is_open = 0;
   1f0a6:	438b      	bics	r3, r1
   1f0a8:	77d3      	strb	r3, [r2, #31]
		np_finished(pcb, PPP_IP);
   1f0aa:	311f      	adds	r1, #31
   1f0ac:	f7ff fe68 	bl	1ed80 <np_finished>
	}
}
   1f0b0:	bd10      	pop	{r4, pc}

0001f0b2 <ipcp_down>:
    if (pcb->ipcp_is_up) {
   1f0b2:	2104      	movs	r1, #4
static void ipcp_down(fsm *f) {
   1f0b4:	b510      	push	{r4, lr}
    ppp_pcb *pcb = f->pcb;
   1f0b6:	6804      	ldr	r4, [r0, #0]
    if (pcb->ipcp_is_up) {
   1f0b8:	1ce2      	adds	r2, r4, #3
   1f0ba:	7fd3      	ldrb	r3, [r2, #31]
   1f0bc:	420b      	tst	r3, r1
   1f0be:	d005      	beq.n	1f0cc <ipcp_down+0x1a>
	pcb->ipcp_is_up = 0;
   1f0c0:	438b      	bics	r3, r1
   1f0c2:	77d3      	strb	r3, [r2, #31]
	np_down(pcb, PPP_IP);
   1f0c4:	311d      	adds	r1, #29
   1f0c6:	0020      	movs	r0, r4
   1f0c8:	f7ff fe4d 	bl	1ed66 <np_down>
	sifdown(pcb);
   1f0cc:	0020      	movs	r0, r4
   1f0ce:	f7fe ffd5 	bl	1e07c <sifdown>
	ipcp_clear_addrs(pcb, go->ouraddr,
   1f0d2:	0022      	movs	r2, r4
   1f0d4:	1c63      	adds	r3, r4, #1
   1f0d6:	3219      	adds	r2, #25
   1f0d8:	33ff      	adds	r3, #255	; 0xff
   1f0da:	32ff      	adds	r2, #255	; 0xff
    cifaddr(pcb, ouraddr, hisaddr);
   1f0dc:	6892      	ldr	r2, [r2, #8]
   1f0de:	6859      	ldr	r1, [r3, #4]
   1f0e0:	0020      	movs	r0, r4
   1f0e2:	f7fe ffa9 	bl	1e038 <cifaddr>
}
   1f0e6:	bd10      	pop	{r4, pc}

0001f0e8 <ipcp_up>:
static void ipcp_up(fsm *f) {
   1f0e8:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    if (!ho->neg_addr && !ho->old_addrs)
   1f0ea:	238c      	movs	r3, #140	; 0x8c
    ppp_pcb *pcb = f->pcb;
   1f0ec:	6804      	ldr	r4, [r0, #0]
    if (!ho->neg_addr && !ho->old_addrs)
   1f0ee:	005b      	lsls	r3, r3, #1
   1f0f0:	5ce3      	ldrb	r3, [r4, r3]
static void ipcp_up(fsm *f) {
   1f0f2:	0005      	movs	r5, r0
    if (!ho->neg_addr && !ho->old_addrs)
   1f0f4:	079b      	lsls	r3, r3, #30
   1f0f6:	d106      	bne.n	1f106 <ipcp_up+0x1e>
	ho->hisaddr = wo->hisaddr;
   1f0f8:	0022      	movs	r2, r4
   1f0fa:	0023      	movs	r3, r4
   1f0fc:	32f4      	adds	r2, #244	; 0xf4
   1f0fe:	3319      	adds	r3, #25
   1f100:	6892      	ldr	r2, [r2, #8]
   1f102:	33ff      	adds	r3, #255	; 0xff
   1f104:	609a      	str	r2, [r3, #8]
    if (!(go->neg_addr || go->old_addrs) && (wo->neg_addr || wo->old_addrs)
   1f106:	2380      	movs	r3, #128	; 0x80
   1f108:	2203      	movs	r2, #3
   1f10a:	005b      	lsls	r3, r3, #1
   1f10c:	5ce3      	ldrb	r3, [r4, r3]
   1f10e:	4213      	tst	r3, r2
   1f110:	d110      	bne.n	1f134 <ipcp_up+0x4c>
   1f112:	0023      	movs	r3, r4
   1f114:	33f4      	adds	r3, #244	; 0xf4
   1f116:	7819      	ldrb	r1, [r3, #0]
   1f118:	4211      	tst	r1, r2
   1f11a:	d00b      	beq.n	1f134 <ipcp_up+0x4c>
	&& wo->ouraddr != 0) {
   1f11c:	685b      	ldr	r3, [r3, #4]
   1f11e:	2b00      	cmp	r3, #0
   1f120:	d008      	beq.n	1f134 <ipcp_up+0x4c>
	ppp_error("Peer refused to agree to our IP address");
   1f122:	4836      	ldr	r0, [pc, #216]	; (1f1fc <ipcp_up+0x114>)
   1f124:	f7ff fd40 	bl	1eba8 <ppp_error>
    fsm *f = &pcb->ipcp_fsm;
   1f128:	6828      	ldr	r0, [r5, #0]
    fsm_close(f, reason);
   1f12a:	4935      	ldr	r1, [pc, #212]	; (1f200 <ipcp_up+0x118>)
    fsm *f = &pcb->ipcp_fsm;
   1f12c:	30d8      	adds	r0, #216	; 0xd8
    fsm_close(f, reason);
   1f12e:	f001 fdcd 	bl	20ccc <fsm_close>
}
   1f132:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    if (go->ouraddr == 0) {
   1f134:	1c66      	adds	r6, r4, #1
   1f136:	36ff      	adds	r6, #255	; 0xff
   1f138:	6873      	ldr	r3, [r6, #4]
   1f13a:	2b00      	cmp	r3, #0
   1f13c:	d107      	bne.n	1f14e <ipcp_up+0x66>
	ppp_error("Could not determine local IP address");
   1f13e:	4c31      	ldr	r4, [pc, #196]	; (1f204 <ipcp_up+0x11c>)
   1f140:	0020      	movs	r0, r4
   1f142:	f7ff fd31 	bl	1eba8 <ppp_error>
    fsm *f = &pcb->ipcp_fsm;
   1f146:	6828      	ldr	r0, [r5, #0]
    fsm_close(f, reason);
   1f148:	0021      	movs	r1, r4
    fsm *f = &pcb->ipcp_fsm;
   1f14a:	30d8      	adds	r0, #216	; 0xd8
   1f14c:	e7ef      	b.n	1f12e <ipcp_up+0x46>
    if (ho->hisaddr == 0 && !pcb->settings.noremoteip) {
   1f14e:	0023      	movs	r3, r4
   1f150:	3319      	adds	r3, #25
   1f152:	33ff      	adds	r3, #255	; 0xff
   1f154:	689a      	ldr	r2, [r3, #8]
   1f156:	2a00      	cmp	r2, #0
   1f158:	d107      	bne.n	1f16a <ipcp_up+0x82>
   1f15a:	7822      	ldrb	r2, [r4, #0]
   1f15c:	0792      	lsls	r2, r2, #30
   1f15e:	d404      	bmi.n	1f16a <ipcp_up+0x82>
	ho->hisaddr = lwip_htonl(0x0a404040);
   1f160:	4929      	ldr	r1, [pc, #164]	; (1f208 <ipcp_up+0x120>)
	ppp_warn("Could not determine remote IP address: defaulting to %I",
   1f162:	482a      	ldr	r0, [pc, #168]	; (1f20c <ipcp_up+0x124>)
	ho->hisaddr = lwip_htonl(0x0a404040);
   1f164:	6099      	str	r1, [r3, #8]
	ppp_warn("Could not determine remote IP address: defaulting to %I",
   1f166:	f7ff fd2b 	bl	1ebc0 <ppp_warn>
   1f16a:	0023      	movs	r3, r4
   1f16c:	33fc      	adds	r3, #252	; 0xfc
   1f16e:	6a59      	ldr	r1, [r3, #36]	; 0x24
   1f170:	ba0b      	rev	r3, r1
    if (ho->hisaddr != 0) {
   1f172:	2900      	cmp	r1, #0
   1f174:	d00c      	beq.n	1f190 <ipcp_up+0xa8>
	if ((addr >> IP_CLASSA_NSHIFT) == IP_LOOPBACKNET
   1f176:	0e1a      	lsrs	r2, r3, #24
   1f178:	2a7f      	cmp	r2, #127	; 0x7f
   1f17a:	d002      	beq.n	1f182 <ipcp_up+0x9a>
	    || IP_MULTICAST(addr) || IP_BADCLASS(addr)
   1f17c:	0f5b      	lsrs	r3, r3, #29
   1f17e:	2b07      	cmp	r3, #7
   1f180:	d106      	bne.n	1f190 <ipcp_up+0xa8>
		ppp_error("Peer is not authorized to use remote address %I", ho->hisaddr);
   1f182:	4823      	ldr	r0, [pc, #140]	; (1f210 <ipcp_up+0x128>)
   1f184:	f7ff fd10 	bl	1eba8 <ppp_error>
    fsm *f = &pcb->ipcp_fsm;
   1f188:	0020      	movs	r0, r4
    fsm_close(f, reason);
   1f18a:	4922      	ldr	r1, [pc, #136]	; (1f214 <ipcp_up+0x12c>)
    fsm *f = &pcb->ipcp_fsm;
   1f18c:	30d8      	adds	r0, #216	; 0xd8
   1f18e:	e7ce      	b.n	1f12e <ipcp_up+0x46>
	if (!sifaddr(pcb, go->ouraddr, ho->hisaddr, mask)) {
   1f190:	0027      	movs	r7, r4
	mask = get_mask(go->ouraddr);
   1f192:	6870      	ldr	r0, [r6, #4]
   1f194:	f7fe ff7d 	bl	1e092 <get_mask>
	if (!sifaddr(pcb, go->ouraddr, ho->hisaddr, mask)) {
   1f198:	3719      	adds	r7, #25
   1f19a:	37ff      	adds	r7, #255	; 0xff
	mask = get_mask(go->ouraddr);
   1f19c:	0003      	movs	r3, r0
	if (!sifaddr(pcb, go->ouraddr, ho->hisaddr, mask)) {
   1f19e:	68ba      	ldr	r2, [r7, #8]
   1f1a0:	6871      	ldr	r1, [r6, #4]
   1f1a2:	0020      	movs	r0, r4
   1f1a4:	f7fe ff3b 	bl	1e01e <sifaddr>
   1f1a8:	2800      	cmp	r0, #0
   1f1aa:	d104      	bne.n	1f1b6 <ipcp_up+0xce>
	    ppp_warn("Interface configuration failed");
   1f1ac:	4c1a      	ldr	r4, [pc, #104]	; (1f218 <ipcp_up+0x130>)
   1f1ae:	0020      	movs	r0, r4
   1f1b0:	f7ff fd06 	bl	1ebc0 <ppp_warn>
   1f1b4:	e7c7      	b.n	1f146 <ipcp_up+0x5e>
	if (!sifup(pcb)) {
   1f1b6:	0020      	movs	r0, r4
   1f1b8:	f7fe ff4c 	bl	1e054 <sifup>
   1f1bc:	2800      	cmp	r0, #0
   1f1be:	d106      	bne.n	1f1ce <ipcp_up+0xe6>
	    ppp_warn("Interface failed to come up");
   1f1c0:	4816      	ldr	r0, [pc, #88]	; (1f21c <ipcp_up+0x134>)
   1f1c2:	f7ff fcfd 	bl	1ebc0 <ppp_warn>
    fsm *f = &pcb->ipcp_fsm;
   1f1c6:	6828      	ldr	r0, [r5, #0]
    fsm_close(f, reason);
   1f1c8:	4913      	ldr	r1, [pc, #76]	; (1f218 <ipcp_up+0x130>)
    fsm *f = &pcb->ipcp_fsm;
   1f1ca:	30d8      	adds	r0, #216	; 0xd8
   1f1cc:	e7af      	b.n	1f12e <ipcp_up+0x46>
	wo->ouraddr = go->ouraddr;
   1f1ce:	0023      	movs	r3, r4
   1f1d0:	6871      	ldr	r1, [r6, #4]
   1f1d2:	33f4      	adds	r3, #244	; 0xf4
   1f1d4:	6059      	str	r1, [r3, #4]
	ppp_notice("local  IP address %I", go->ouraddr);
   1f1d6:	4812      	ldr	r0, [pc, #72]	; (1f220 <ipcp_up+0x138>)
   1f1d8:	f7ff fcfe 	bl	1ebd8 <ppp_notice>
	if (ho->hisaddr != 0)
   1f1dc:	68b9      	ldr	r1, [r7, #8]
   1f1de:	2900      	cmp	r1, #0
   1f1e0:	d002      	beq.n	1f1e8 <ipcp_up+0x100>
	    ppp_notice("remote IP address %I", ho->hisaddr);
   1f1e2:	4810      	ldr	r0, [pc, #64]	; (1f224 <ipcp_up+0x13c>)
   1f1e4:	f7ff fcf8 	bl	1ebd8 <ppp_notice>
    np_up(pcb, PPP_IP);
   1f1e8:	0020      	movs	r0, r4
   1f1ea:	2121      	movs	r1, #33	; 0x21
   1f1ec:	f7ff fdae 	bl	1ed4c <np_up>
    pcb->ipcp_is_up = 1;
   1f1f0:	2304      	movs	r3, #4
   1f1f2:	3403      	adds	r4, #3
   1f1f4:	7fe2      	ldrb	r2, [r4, #31]
   1f1f6:	4313      	orrs	r3, r2
   1f1f8:	77e3      	strb	r3, [r4, #31]
   1f1fa:	e79a      	b.n	1f132 <ipcp_up+0x4a>
   1f1fc:	00025ca4 	.word	0x00025ca4
   1f200:	00025ccc 	.word	0x00025ccc
   1f204:	00025ce3 	.word	0x00025ce3
   1f208:	4040400a 	.word	0x4040400a
   1f20c:	00025d08 	.word	0x00025d08
   1f210:	00025d40 	.word	0x00025d40
   1f214:	00025d70 	.word	0x00025d70
   1f218:	00025d8f 	.word	0x00025d8f
   1f21c:	00025dae 	.word	0x00025dae
   1f220:	00025dca 	.word	0x00025dca
   1f224:	00025ddf 	.word	0x00025ddf

0001f228 <ipcp_nakci>:
static int ipcp_nakci(fsm *f, u_char *p, int len, int treat_as_reject) {
   1f228:	b5f0      	push	{r4, r5, r6, r7, lr}
   1f22a:	b08f      	sub	sp, #60	; 0x3c
   1f22c:	9305      	str	r3, [sp, #20]
    ppp_pcb *pcb = f->pcb;
   1f22e:	6803      	ldr	r3, [r0, #0]
static int ipcp_nakci(fsm *f, u_char *p, int len, int treat_as_reject) {
   1f230:	9006      	str	r0, [sp, #24]
   1f232:	000c      	movs	r4, r1
   1f234:	0015      	movs	r5, r2
    BZERO(&no, sizeof(no));
   1f236:	2100      	movs	r1, #0
   1f238:	220c      	movs	r2, #12
   1f23a:	a808      	add	r0, sp, #32
    ppp_pcb *pcb = f->pcb;
   1f23c:	9302      	str	r3, [sp, #8]
    BZERO(&no, sizeof(no));
   1f23e:	f7e1 f84f 	bl	2e0 <memset>
    try_ = *go;
   1f242:	9b02      	ldr	r3, [sp, #8]
   1f244:	aa0b      	add	r2, sp, #44	; 0x2c
   1f246:	3301      	adds	r3, #1
   1f248:	33ff      	adds	r3, #255	; 0xff
   1f24a:	cb43      	ldmia	r3!, {r0, r1, r6}
   1f24c:	c243      	stmia	r2!, {r0, r1, r6}
   1f24e:	9802      	ldr	r0, [sp, #8]
   1f250:	2380      	movs	r3, #128	; 0x80
   1f252:	30fc      	adds	r0, #252	; 0xfc
   1f254:	6886      	ldr	r6, [r0, #8]
   1f256:	68c0      	ldr	r0, [r0, #12]
   1f258:	9a02      	ldr	r2, [sp, #8]
   1f25a:	9004      	str	r0, [sp, #16]
    NAKCIADDRS(CI_ADDRS, !go->neg_addr && go->old_addrs,
   1f25c:	2003      	movs	r0, #3
    try_ = *go;
   1f25e:	005b      	lsls	r3, r3, #1
   1f260:	5cd3      	ldrb	r3, [r2, r3]
   1f262:	46b4      	mov	ip, r6
   1f264:	07d9      	lsls	r1, r3, #31
   1f266:	079a      	lsls	r2, r3, #30
    NAKCIADDRS(CI_ADDRS, !go->neg_addr && go->old_addrs,
   1f268:	4018      	ands	r0, r3
    try_ = *go;
   1f26a:	0fc9      	lsrs	r1, r1, #31
   1f26c:	0fd2      	lsrs	r2, r2, #31
    NAKCIADDRS(CI_ADDRS, !go->neg_addr && go->old_addrs,
   1f26e:	9003      	str	r0, [sp, #12]
   1f270:	2802      	cmp	r0, #2
   1f272:	d139      	bne.n	1f2e8 <ipcp_nakci+0xc0>
   1f274:	7860      	ldrb	r0, [r4, #1]
   1f276:	280a      	cmp	r0, #10
   1f278:	d136      	bne.n	1f2e8 <ipcp_nakci+0xc0>
   1f27a:	2d09      	cmp	r5, #9
   1f27c:	dd34      	ble.n	1f2e8 <ipcp_nakci+0xc0>
   1f27e:	7820      	ldrb	r0, [r4, #0]
   1f280:	2801      	cmp	r0, #1
   1f282:	d131      	bne.n	1f2e8 <ipcp_nakci+0xc0>
   1f284:	78e6      	ldrb	r6, [r4, #3]
   1f286:	78a0      	ldrb	r0, [r4, #2]
   1f288:	0236      	lsls	r6, r6, #8
   1f28a:	4306      	orrs	r6, r0
   1f28c:	ba76      	rev16	r6, r6
   1f28e:	7920      	ldrb	r0, [r4, #4]
   1f290:	b2b6      	uxth	r6, r6
   1f292:	0236      	lsls	r6, r6, #8
   1f294:	4306      	orrs	r6, r0
   1f296:	7960      	ldrb	r0, [r4, #5]
   1f298:	0236      	lsls	r6, r6, #8
   1f29a:	4306      	orrs	r6, r0
   1f29c:	79e0      	ldrb	r0, [r4, #7]
   1f29e:	79a7      	ldrb	r7, [r4, #6]
   1f2a0:	0200      	lsls	r0, r0, #8
   1f2a2:	4338      	orrs	r0, r7
   1f2a4:	ba40      	rev16	r0, r0
   1f2a6:	7a27      	ldrb	r7, [r4, #8]
   1f2a8:	b280      	uxth	r0, r0
   1f2aa:	0200      	lsls	r0, r0, #8
   1f2ac:	4338      	orrs	r0, r7
   1f2ae:	0027      	movs	r7, r4
   1f2b0:	7a64      	ldrb	r4, [r4, #9]
   1f2b2:	0200      	lsls	r0, r0, #8
   1f2b4:	4320      	orrs	r0, r4
   1f2b6:	ba00      	rev	r0, r0
   1f2b8:	ac08      	add	r4, sp, #32
   1f2ba:	7824      	ldrb	r4, [r4, #0]
   1f2bc:	9001      	str	r0, [sp, #4]
   1f2be:	9803      	ldr	r0, [sp, #12]
   1f2c0:	3d0a      	subs	r5, #10
   1f2c2:	4304      	orrs	r4, r0
   1f2c4:	a808      	add	r0, sp, #32
   1f2c6:	7004      	strb	r4, [r0, #0]
   1f2c8:	9805      	ldr	r0, [sp, #20]
   1f2ca:	ba36      	rev	r6, r6
   1f2cc:	370a      	adds	r7, #10
   1f2ce:	2800      	cmp	r0, #0
   1f2d0:	d153      	bne.n	1f37a <ipcp_nakci+0x152>
   1f2d2:	0718      	lsls	r0, r3, #28
   1f2d4:	d502      	bpl.n	1f2dc <ipcp_nakci+0xb4>
   1f2d6:	2e00      	cmp	r6, #0
   1f2d8:	d000      	beq.n	1f2dc <ipcp_nakci+0xb4>
   1f2da:	46b4      	mov	ip, r6
   1f2dc:	003c      	movs	r4, r7
   1f2de:	06d8      	lsls	r0, r3, #27
   1f2e0:	d502      	bpl.n	1f2e8 <ipcp_nakci+0xc0>
   1f2e2:	9801      	ldr	r0, [sp, #4]
   1f2e4:	2800      	cmp	r0, #0
   1f2e6:	d14b      	bne.n	1f380 <ipcp_nakci+0x158>
    NAKCIADDR(CI_ADDR, neg_addr,
   1f2e8:	2601      	movs	r6, #1
   1f2ea:	0018      	movs	r0, r3
   1f2ec:	4030      	ands	r0, r6
   1f2ee:	9001      	str	r0, [sp, #4]
   1f2f0:	d023      	beq.n	1f33a <ipcp_nakci+0x112>
   1f2f2:	7860      	ldrb	r0, [r4, #1]
   1f2f4:	2806      	cmp	r0, #6
   1f2f6:	d120      	bne.n	1f33a <ipcp_nakci+0x112>
   1f2f8:	2d05      	cmp	r5, #5
   1f2fa:	dd1e      	ble.n	1f33a <ipcp_nakci+0x112>
   1f2fc:	7820      	ldrb	r0, [r4, #0]
   1f2fe:	2803      	cmp	r0, #3
   1f300:	d11b      	bne.n	1f33a <ipcp_nakci+0x112>
   1f302:	78e0      	ldrb	r0, [r4, #3]
   1f304:	78a7      	ldrb	r7, [r4, #2]
   1f306:	0200      	lsls	r0, r0, #8
   1f308:	4338      	orrs	r0, r7
   1f30a:	ba40      	rev16	r0, r0
   1f30c:	7927      	ldrb	r7, [r4, #4]
   1f30e:	b280      	uxth	r0, r0
   1f310:	0200      	lsls	r0, r0, #8
   1f312:	4338      	orrs	r0, r7
   1f314:	1da7      	adds	r7, r4, #6
   1f316:	7964      	ldrb	r4, [r4, #5]
   1f318:	0200      	lsls	r0, r0, #8
   1f31a:	4320      	orrs	r0, r4
   1f31c:	ac08      	add	r4, sp, #32
   1f31e:	7824      	ldrb	r4, [r4, #0]
   1f320:	3d06      	subs	r5, #6
   1f322:	4326      	orrs	r6, r4
   1f324:	ac08      	add	r4, sp, #32
   1f326:	7026      	strb	r6, [r4, #0]
   1f328:	9c05      	ldr	r4, [sp, #20]
   1f32a:	ba00      	rev	r0, r0
   1f32c:	2c00      	cmp	r4, #0
   1f32e:	d12a      	bne.n	1f386 <ipcp_nakci+0x15e>
   1f330:	003c      	movs	r4, r7
   1f332:	071e      	lsls	r6, r3, #28
   1f334:	d501      	bpl.n	1f33a <ipcp_nakci+0x112>
   1f336:	2800      	cmp	r0, #0
   1f338:	d129      	bne.n	1f38e <ipcp_nakci+0x166>
	    if (ciaddr2 && go->accept_remote)
   1f33a:	2010      	movs	r0, #16
   1f33c:	4018      	ands	r0, r3
   1f33e:	9007      	str	r0, [sp, #28]
    while (len >= CILEN_VOID) {
   1f340:	2d01      	cmp	r5, #1
   1f342:	dc26      	bgt.n	1f392 <ipcp_nakci+0x16a>
   1f344:	2401      	movs	r4, #1
    if (f->state != PPP_FSM_OPENED)
   1f346:	9b06      	ldr	r3, [sp, #24]
    return 1;
   1f348:	0020      	movs	r0, r4
    if (f->state != PPP_FSM_OPENED)
   1f34a:	7c1b      	ldrb	r3, [r3, #16]
   1f34c:	2b09      	cmp	r3, #9
   1f34e:	d012      	beq.n	1f376 <ipcp_nakci+0x14e>
	*go = try_;
   1f350:	a80b      	add	r0, sp, #44	; 0x2c
   1f352:	7803      	ldrb	r3, [r0, #0]
   1f354:	40a2      	lsls	r2, r4
   1f356:	43a3      	bics	r3, r4
   1f358:	4319      	orrs	r1, r3
   1f35a:	2302      	movs	r3, #2
   1f35c:	4399      	bics	r1, r3
   1f35e:	4663      	mov	r3, ip
   1f360:	930c      	str	r3, [sp, #48]	; 0x30
   1f362:	9b04      	ldr	r3, [sp, #16]
   1f364:	430a      	orrs	r2, r1
   1f366:	930d      	str	r3, [sp, #52]	; 0x34
   1f368:	9b02      	ldr	r3, [sp, #8]
   1f36a:	7002      	strb	r2, [r0, #0]
   1f36c:	3301      	adds	r3, #1
   1f36e:	33ff      	adds	r3, #255	; 0xff
   1f370:	c826      	ldmia	r0!, {r1, r2, r5}
   1f372:	c326      	stmia	r3!, {r1, r2, r5}
    return 1;
   1f374:	0020      	movs	r0, r4
}
   1f376:	b00f      	add	sp, #60	; 0x3c
   1f378:	bdf0      	pop	{r4, r5, r6, r7, pc}
    NAKCIADDRS(CI_ADDRS, !go->neg_addr && go->old_addrs,
   1f37a:	003c      	movs	r4, r7
   1f37c:	2200      	movs	r2, #0
   1f37e:	e7b3      	b.n	1f2e8 <ipcp_nakci+0xc0>
   1f380:	9801      	ldr	r0, [sp, #4]
   1f382:	9004      	str	r0, [sp, #16]
   1f384:	e7b0      	b.n	1f2e8 <ipcp_nakci+0xc0>
    NAKCIADDR(CI_ADDR, neg_addr,
   1f386:	2200      	movs	r2, #0
   1f388:	003c      	movs	r4, r7
   1f38a:	0011      	movs	r1, r2
   1f38c:	e7d5      	b.n	1f33a <ipcp_nakci+0x112>
   1f38e:	4684      	mov	ip, r0
   1f390:	e7d3      	b.n	1f33a <ipcp_nakci+0x112>
	GETCHAR(citype, p);
   1f392:	7820      	ldrb	r0, [r4, #0]
	GETCHAR(cilen, p);
   1f394:	1ca6      	adds	r6, r4, #2
	GETCHAR(citype, p);
   1f396:	9005      	str	r0, [sp, #20]
	GETCHAR(cilen, p);
   1f398:	0030      	movs	r0, r6
   1f39a:	7866      	ldrb	r6, [r4, #1]
	if ( cilen < CILEN_VOID || (len -= cilen) < 0 )
   1f39c:	2e01      	cmp	r6, #1
   1f39e:	d969      	bls.n	1f474 <ipcp_nakci+0x24c>
   1f3a0:	1bad      	subs	r5, r5, r6
   1f3a2:	d467      	bmi.n	1f474 <ipcp_nakci+0x24c>
	next = p + cilen - 2;
   1f3a4:	1eb7      	subs	r7, r6, #2
   1f3a6:	19c7      	adds	r7, r0, r7
	switch (citype) {
   1f3a8:	9805      	ldr	r0, [sp, #20]
   1f3aa:	2801      	cmp	r0, #1
   1f3ac:	d003      	beq.n	1f3b6 <ipcp_nakci+0x18e>
   1f3ae:	2803      	cmp	r0, #3
   1f3b0:	d038      	beq.n	1f424 <ipcp_nakci+0x1fc>
	    try_.neg_addr = 0;
   1f3b2:	003c      	movs	r4, r7
   1f3b4:	e7c4      	b.n	1f340 <ipcp_nakci+0x118>
	    if ((!go->neg_addr && go->old_addrs) || no.old_addrs
   1f3b6:	9903      	ldr	r1, [sp, #12]
   1f3b8:	2902      	cmp	r1, #2
   1f3ba:	d05b      	beq.n	1f474 <ipcp_nakci+0x24c>
   1f3bc:	a908      	add	r1, sp, #32
   1f3be:	7808      	ldrb	r0, [r1, #0]
   1f3c0:	2102      	movs	r1, #2
   1f3c2:	4008      	ands	r0, r1
   1f3c4:	d156      	bne.n	1f474 <ipcp_nakci+0x24c>
		|| cilen != CILEN_ADDRS)
   1f3c6:	2e0a      	cmp	r6, #10
   1f3c8:	d1d5      	bne.n	1f376 <ipcp_nakci+0x14e>
   1f3ca:	78e1      	ldrb	r1, [r4, #3]
   1f3cc:	78a0      	ldrb	r0, [r4, #2]
   1f3ce:	0209      	lsls	r1, r1, #8
   1f3d0:	4301      	orrs	r1, r0
   1f3d2:	ba49      	rev16	r1, r1
	    GETLONG(l, p);
   1f3d4:	7920      	ldrb	r0, [r4, #4]
   1f3d6:	b289      	uxth	r1, r1
   1f3d8:	0209      	lsls	r1, r1, #8
   1f3da:	4301      	orrs	r1, r0
   1f3dc:	7960      	ldrb	r0, [r4, #5]
   1f3de:	0209      	lsls	r1, r1, #8
   1f3e0:	4308      	orrs	r0, r1
   1f3e2:	ba00      	rev	r0, r0
	    if (ciaddr1 && go->accept_local)
   1f3e4:	2800      	cmp	r0, #0
   1f3e6:	d002      	beq.n	1f3ee <ipcp_nakci+0x1c6>
   1f3e8:	0719      	lsls	r1, r3, #28
   1f3ea:	d500      	bpl.n	1f3ee <ipcp_nakci+0x1c6>
   1f3ec:	4684      	mov	ip, r0
   1f3ee:	79e1      	ldrb	r1, [r4, #7]
   1f3f0:	79a0      	ldrb	r0, [r4, #6]
   1f3f2:	0209      	lsls	r1, r1, #8
   1f3f4:	4301      	orrs	r1, r0
   1f3f6:	ba49      	rev16	r1, r1
   1f3f8:	b289      	uxth	r1, r1
	    GETLONG(l, p);
   1f3fa:	7a20      	ldrb	r0, [r4, #8]
   1f3fc:	0209      	lsls	r1, r1, #8
   1f3fe:	4308      	orrs	r0, r1
   1f400:	7a61      	ldrb	r1, [r4, #9]
   1f402:	0200      	lsls	r0, r0, #8
   1f404:	4308      	orrs	r0, r1
   1f406:	ba00      	rev	r0, r0
	    if (ciaddr2 && go->accept_remote)
   1f408:	2800      	cmp	r0, #0
   1f40a:	d003      	beq.n	1f414 <ipcp_nakci+0x1ec>
   1f40c:	9907      	ldr	r1, [sp, #28]
   1f40e:	2900      	cmp	r1, #0
   1f410:	d000      	beq.n	1f414 <ipcp_nakci+0x1ec>
   1f412:	9004      	str	r0, [sp, #16]
	    no.old_addrs = 1;
   1f414:	2002      	movs	r0, #2
   1f416:	a908      	add	r1, sp, #32
   1f418:	7809      	ldrb	r1, [r1, #0]
   1f41a:	4301      	orrs	r1, r0
   1f41c:	a808      	add	r0, sp, #32
   1f41e:	7001      	strb	r1, [r0, #0]
	    try_.neg_addr = 0;
   1f420:	2100      	movs	r1, #0
	    break;
   1f422:	e7c6      	b.n	1f3b2 <ipcp_nakci+0x18a>
	    if (go->neg_addr || no.neg_addr || cilen != CILEN_ADDR)
   1f424:	9a01      	ldr	r2, [sp, #4]
   1f426:	2a00      	cmp	r2, #0
   1f428:	d124      	bne.n	1f474 <ipcp_nakci+0x24c>
   1f42a:	aa08      	add	r2, sp, #32
   1f42c:	7812      	ldrb	r2, [r2, #0]
   1f42e:	07d2      	lsls	r2, r2, #31
   1f430:	d422      	bmi.n	1f478 <ipcp_nakci+0x250>
   1f432:	2e06      	cmp	r6, #6
   1f434:	d120      	bne.n	1f478 <ipcp_nakci+0x250>
   1f436:	78e2      	ldrb	r2, [r4, #3]
   1f438:	78a0      	ldrb	r0, [r4, #2]
   1f43a:	0212      	lsls	r2, r2, #8
   1f43c:	4302      	orrs	r2, r0
   1f43e:	ba52      	rev16	r2, r2
   1f440:	b292      	uxth	r2, r2
	    GETLONG(l, p);
   1f442:	7920      	ldrb	r0, [r4, #4]
   1f444:	0212      	lsls	r2, r2, #8
   1f446:	4310      	orrs	r0, r2
   1f448:	7962      	ldrb	r2, [r4, #5]
   1f44a:	0200      	lsls	r0, r0, #8
   1f44c:	4310      	orrs	r0, r2
   1f44e:	ba00      	rev	r0, r0
	    if (ciaddr1 && go->accept_local)
   1f450:	2800      	cmp	r0, #0
   1f452:	d001      	beq.n	1f458 <ipcp_nakci+0x230>
   1f454:	071a      	lsls	r2, r3, #28
   1f456:	d40b      	bmi.n	1f470 <ipcp_nakci+0x248>
	    if (try_.ouraddr != 0)
   1f458:	4662      	mov	r2, ip
   1f45a:	2a00      	cmp	r2, #0
   1f45c:	d000      	beq.n	1f460 <ipcp_nakci+0x238>
		try_.neg_addr = 1;
   1f45e:	2101      	movs	r1, #1
	    no.neg_addr = 1;
   1f460:	aa08      	add	r2, sp, #32
   1f462:	7810      	ldrb	r0, [r2, #0]
   1f464:	2201      	movs	r2, #1
   1f466:	4302      	orrs	r2, r0
   1f468:	a808      	add	r0, sp, #32
   1f46a:	7002      	strb	r2, [r0, #0]
	    try_.old_addrs = 0;
   1f46c:	2200      	movs	r2, #0
	    break;
   1f46e:	e7a0      	b.n	1f3b2 <ipcp_nakci+0x18a>
   1f470:	4684      	mov	ip, r0
   1f472:	e7f4      	b.n	1f45e <ipcp_nakci+0x236>
    return 0;
   1f474:	2000      	movs	r0, #0
   1f476:	e77e      	b.n	1f376 <ipcp_nakci+0x14e>
   1f478:	9801      	ldr	r0, [sp, #4]
   1f47a:	e77c      	b.n	1f376 <ipcp_nakci+0x14e>

0001f47c <ipcp_resetci>:
static void ipcp_resetci(fsm *f) {
   1f47c:	b570      	push	{r4, r5, r6, lr}
    ppp_pcb *pcb = f->pcb;
   1f47e:	6800      	ldr	r0, [r0, #0]
    wo->req_addr = (wo->neg_addr || wo->old_addrs) &&
   1f480:	2103      	movs	r1, #3
   1f482:	0003      	movs	r3, r0
   1f484:	33f4      	adds	r3, #244	; 0xf4
   1f486:	781c      	ldrb	r4, [r3, #0]
   1f488:	2200      	movs	r2, #0
   1f48a:	420c      	tst	r4, r1
   1f48c:	d005      	beq.n	1f49a <ipcp_resetci+0x1e>
	(ao->neg_addr || ao->old_addrs);
   1f48e:	320d      	adds	r2, #13
   1f490:	32ff      	adds	r2, #255	; 0xff
   1f492:	5c82      	ldrb	r2, [r0, r2]
    wo->req_addr = (wo->neg_addr || wo->old_addrs) &&
   1f494:	400a      	ands	r2, r1
   1f496:	1e51      	subs	r1, r2, #1
   1f498:	418a      	sbcs	r2, r1
   1f49a:	2404      	movs	r4, #4
   1f49c:	7819      	ldrb	r1, [r3, #0]
   1f49e:	0092      	lsls	r2, r2, #2
   1f4a0:	43a1      	bics	r1, r4
   1f4a2:	430a      	orrs	r2, r1
   1f4a4:	701a      	strb	r2, [r3, #0]
    if (wo->ouraddr == 0)
   1f4a6:	685a      	ldr	r2, [r3, #4]
   1f4a8:	2a00      	cmp	r2, #0
   1f4aa:	d103      	bne.n	1f4b4 <ipcp_resetci+0x38>
	wo->accept_local = 1;
   1f4ac:	7819      	ldrb	r1, [r3, #0]
   1f4ae:	3208      	adds	r2, #8
   1f4b0:	430a      	orrs	r2, r1
   1f4b2:	701a      	strb	r2, [r3, #0]
    if (wo->hisaddr == 0)
   1f4b4:	689a      	ldr	r2, [r3, #8]
   1f4b6:	2a00      	cmp	r2, #0
   1f4b8:	d103      	bne.n	1f4c2 <ipcp_resetci+0x46>
	wo->accept_remote = 1;
   1f4ba:	7819      	ldrb	r1, [r3, #0]
   1f4bc:	3210      	adds	r2, #16
   1f4be:	430a      	orrs	r2, r1
   1f4c0:	701a      	strb	r2, [r3, #0]
    *go = *wo;
   1f4c2:	1c42      	adds	r2, r0, #1
   1f4c4:	32ff      	adds	r2, #255	; 0xff
   1f4c6:	cb32      	ldmia	r3!, {r1, r4, r5}
   1f4c8:	c232      	stmia	r2!, {r1, r4, r5}
    if (!pcb->ask_for_local)
   1f4ca:	2201      	movs	r2, #1
   1f4cc:	1cc3      	adds	r3, r0, #3
   1f4ce:	7fdb      	ldrb	r3, [r3, #31]
   1f4d0:	4013      	ands	r3, r2
   1f4d2:	1c42      	adds	r2, r0, #1
   1f4d4:	32ff      	adds	r2, #255	; 0xff
   1f4d6:	2b00      	cmp	r3, #0
   1f4d8:	d100      	bne.n	1f4dc <ipcp_resetci+0x60>
	go->ouraddr = 0;
   1f4da:	6053      	str	r3, [r2, #4]
    BZERO(&pcb->ipcp_hisoptions, sizeof(ipcp_options));
   1f4dc:	3019      	adds	r0, #25
   1f4de:	220c      	movs	r2, #12
   1f4e0:	2100      	movs	r1, #0
   1f4e2:	30ff      	adds	r0, #255	; 0xff
   1f4e4:	f7e0 fefc 	bl	2e0 <memset>
}
   1f4e8:	bd70      	pop	{r4, r5, r6, pc}

0001f4ea <ipcp_reqci>:
static int ipcp_reqci(fsm *f, u_char *inp, int *len, int reject_if_disagree) {
   1f4ea:	b5f0      	push	{r4, r5, r6, r7, lr}
    ppp_pcb *pcb = f->pcb;
   1f4ec:	6804      	ldr	r4, [r0, #0]
static int ipcp_reqci(fsm *f, u_char *inp, int *len, int reject_if_disagree) {
   1f4ee:	b089      	sub	sp, #36	; 0x24
    ipcp_options *ho = &pcb->ipcp_hisoptions;
   1f4f0:	0020      	movs	r0, r4
static int ipcp_reqci(fsm *f, u_char *inp, int *len, int reject_if_disagree) {
   1f4f2:	9304      	str	r3, [sp, #16]
    ipcp_options *ho = &pcb->ipcp_hisoptions;
   1f4f4:	3019      	adds	r0, #25
    int l = *len;		/* Length left */
   1f4f6:	6813      	ldr	r3, [r2, #0]
static int ipcp_reqci(fsm *f, u_char *inp, int *len, int reject_if_disagree) {
   1f4f8:	9103      	str	r1, [sp, #12]
   1f4fa:	9207      	str	r2, [sp, #28]
    BZERO(ho, sizeof(*ho));
   1f4fc:	2100      	movs	r1, #0
    ipcp_options *ho = &pcb->ipcp_hisoptions;
   1f4fe:	30ff      	adds	r0, #255	; 0xff
    BZERO(ho, sizeof(*ho));
   1f500:	220c      	movs	r2, #12
    int l = *len;		/* Length left */
   1f502:	9302      	str	r3, [sp, #8]
    BZERO(ho, sizeof(*ho));
   1f504:	f7e0 feec 	bl	2e0 <memset>
    u_char *ucp = inp;		/* Pointer to current output char */
   1f508:	9d03      	ldr	r5, [sp, #12]
    int rc = CONFACK;		/* Final packet return code */
   1f50a:	2302      	movs	r3, #2
    next = inp;
   1f50c:	0029      	movs	r1, r5
    int rc = CONFACK;		/* Final packet return code */
   1f50e:	9301      	str	r3, [sp, #4]
    while (l) {
   1f510:	9b02      	ldr	r3, [sp, #8]
   1f512:	2b00      	cmp	r3, #0
   1f514:	d130      	bne.n	1f578 <ipcp_reqci+0x8e>
    if (rc != CONFREJ && !ho->neg_addr && !ho->old_addrs &&
   1f516:	9b01      	ldr	r3, [sp, #4]
   1f518:	2b04      	cmp	r3, #4
   1f51a:	d026      	beq.n	1f56a <ipcp_reqci+0x80>
   1f51c:	238c      	movs	r3, #140	; 0x8c
   1f51e:	005b      	lsls	r3, r3, #1
   1f520:	5ce3      	ldrb	r3, [r4, r3]
   1f522:	079b      	lsls	r3, r3, #30
   1f524:	d121      	bne.n	1f56a <ipcp_reqci+0x80>
   1f526:	0022      	movs	r2, r4
   1f528:	2104      	movs	r1, #4
   1f52a:	32f4      	adds	r2, #244	; 0xf4
   1f52c:	7813      	ldrb	r3, [r2, #0]
   1f52e:	420b      	tst	r3, r1
   1f530:	d01b      	beq.n	1f56a <ipcp_reqci+0x80>
	wo->req_addr && !reject_if_disagree && !pcb->settings.noremoteip) {
   1f532:	9804      	ldr	r0, [sp, #16]
   1f534:	2800      	cmp	r0, #0
   1f536:	d118      	bne.n	1f56a <ipcp_reqci+0x80>
   1f538:	7820      	ldrb	r0, [r4, #0]
   1f53a:	0780      	lsls	r0, r0, #30
   1f53c:	d415      	bmi.n	1f56a <ipcp_reqci+0x80>
	if (rc == CONFACK) {
   1f53e:	9801      	ldr	r0, [sp, #4]
   1f540:	2802      	cmp	r0, #2
   1f542:	d102      	bne.n	1f54a <ipcp_reqci+0x60>
	    wo->req_addr = 0;		/* don't ask again */
   1f544:	438b      	bics	r3, r1
	    ucp = inp;			/* reset pointer */
   1f546:	9d03      	ldr	r5, [sp, #12]
	    wo->req_addr = 0;		/* don't ask again */
   1f548:	7013      	strb	r3, [r2, #0]
	PUTCHAR(CI_ADDR, ucp);
   1f54a:	2203      	movs	r2, #3
	PUTCHAR(CILEN_ADDR, ucp);
   1f54c:	2306      	movs	r3, #6
	PUTCHAR(CI_ADDR, ucp);
   1f54e:	702a      	strb	r2, [r5, #0]
	PUTCHAR(CILEN_ADDR, ucp);
   1f550:	706b      	strb	r3, [r5, #1]
   1f552:	34fc      	adds	r4, #252	; 0xfc
   1f554:	6823      	ldr	r3, [r4, #0]
	PUTLONG(tl, ucp);
   1f556:	9201      	str	r2, [sp, #4]
   1f558:	ba1b      	rev	r3, r3
   1f55a:	0e19      	lsrs	r1, r3, #24
   1f55c:	70a9      	strb	r1, [r5, #2]
   1f55e:	0c19      	lsrs	r1, r3, #16
   1f560:	70e9      	strb	r1, [r5, #3]
   1f562:	0a19      	lsrs	r1, r3, #8
   1f564:	7129      	strb	r1, [r5, #4]
   1f566:	716b      	strb	r3, [r5, #5]
   1f568:	3506      	adds	r5, #6
    *len = ucp - inp;			/* Compute output length */
   1f56a:	9b03      	ldr	r3, [sp, #12]
}
   1f56c:	9801      	ldr	r0, [sp, #4]
    *len = ucp - inp;			/* Compute output length */
   1f56e:	1aed      	subs	r5, r5, r3
   1f570:	9b07      	ldr	r3, [sp, #28]
   1f572:	601d      	str	r5, [r3, #0]
}
   1f574:	b009      	add	sp, #36	; 0x24
   1f576:	bdf0      	pop	{r4, r5, r6, r7, pc}
	if (l < 2 ||			/* Not enough data for CI header or */
   1f578:	9b02      	ldr	r3, [sp, #8]
   1f57a:	2b01      	cmp	r3, #1
   1f57c:	dd05      	ble.n	1f58a <ipcp_reqci+0xa0>
	    p[1] < 2 ||			/*  CI length too small or */
   1f57e:	784b      	ldrb	r3, [r1, #1]
	if (l < 2 ||			/* Not enough data for CI header or */
   1f580:	2b01      	cmp	r3, #1
   1f582:	d902      	bls.n	1f58a <ipcp_reqci+0xa0>
	    p[1] < 2 ||			/*  CI length too small or */
   1f584:	9a02      	ldr	r2, [sp, #8]
   1f586:	4293      	cmp	r3, r2
   1f588:	dd10      	ble.n	1f5ac <ipcp_reqci+0xc2>
	    cilen = l;			/* Reject till end of packet */
   1f58a:	466b      	mov	r3, sp
   1f58c:	891e      	ldrh	r6, [r3, #8]
	    l = 0;			/* Don't loop again */
   1f58e:	2300      	movs	r3, #0
	    goto endswitch;
   1f590:	9106      	str	r1, [sp, #24]
	    l = 0;			/* Don't loop again */
   1f592:	9302      	str	r3, [sp, #8]
	if (orc == CONFREJ &&		/* Reject this CI */
   1f594:	9b01      	ldr	r3, [sp, #4]
   1f596:	2b04      	cmp	r3, #4
   1f598:	d000      	beq.n	1f59c <ipcp_reqci+0xb2>
   1f59a:	e0df      	b.n	1f75c <ipcp_reqci+0x272>
	if (ucp != cip)
   1f59c:	42a9      	cmp	r1, r5
   1f59e:	d003      	beq.n	1f5a8 <ipcp_reqci+0xbe>
	    MEMCPY(ucp, cip, cilen);	/* Move it */
   1f5a0:	0032      	movs	r2, r6
   1f5a2:	0028      	movs	r0, r5
   1f5a4:	f7e0 fe24 	bl	1f0 <memcpy>
	INCPTR(cilen, ucp);
   1f5a8:	19ad      	adds	r5, r5, r6
   1f5aa:	e0d3      	b.n	1f754 <ipcp_reqci+0x26a>
	l -= cilen;			/* Adjust remaining length */
   1f5ac:	9a02      	ldr	r2, [sp, #8]
	GETCHAR(cilen, p);		/* Parse CI length */
   1f5ae:	b29e      	uxth	r6, r3
	l -= cilen;			/* Adjust remaining length */
   1f5b0:	1ad2      	subs	r2, r2, r3
   1f5b2:	9202      	str	r2, [sp, #8]
	next += cilen;			/* Step to next CI */
   1f5b4:	18ca      	adds	r2, r1, r3
   1f5b6:	9206      	str	r2, [sp, #24]
	switch (citype) {		/* Check CI type */
   1f5b8:	780a      	ldrb	r2, [r1, #0]
   1f5ba:	2a01      	cmp	r2, #1
   1f5bc:	d040      	beq.n	1f640 <ipcp_reqci+0x156>
   1f5be:	2a03      	cmp	r2, #3
   1f5c0:	d1e8      	bne.n	1f594 <ipcp_reqci+0xaa>
	    if (!ao->neg_addr || ho->old_addrs ||
   1f5c2:	2286      	movs	r2, #134	; 0x86
   1f5c4:	0052      	lsls	r2, r2, #1
   1f5c6:	5ca2      	ldrb	r2, [r4, r2]
   1f5c8:	07d2      	lsls	r2, r2, #31
   1f5ca:	d5e3      	bpl.n	1f594 <ipcp_reqci+0xaa>
   1f5cc:	228c      	movs	r2, #140	; 0x8c
   1f5ce:	0052      	lsls	r2, r2, #1
   1f5d0:	5ca2      	ldrb	r2, [r4, r2]
   1f5d2:	0792      	lsls	r2, r2, #30
   1f5d4:	d4de      	bmi.n	1f594 <ipcp_reqci+0xaa>
   1f5d6:	2b06      	cmp	r3, #6
   1f5d8:	d1dc      	bne.n	1f594 <ipcp_reqci+0xaa>
   1f5da:	78ca      	ldrb	r2, [r1, #3]
   1f5dc:	788b      	ldrb	r3, [r1, #2]
   1f5de:	0212      	lsls	r2, r2, #8
   1f5e0:	431a      	orrs	r2, r3
   1f5e2:	ba52      	rev16	r2, r2
	    GETLONG(tl, p);	/* Parse source address (his) */
   1f5e4:	790b      	ldrb	r3, [r1, #4]
   1f5e6:	b292      	uxth	r2, r2
   1f5e8:	0212      	lsls	r2, r2, #8
   1f5ea:	431a      	orrs	r2, r3
   1f5ec:	794b      	ldrb	r3, [r1, #5]
   1f5ee:	0212      	lsls	r2, r2, #8
   1f5f0:	431a      	orrs	r2, r3
   1f5f2:	0023      	movs	r3, r4
   1f5f4:	33fc      	adds	r3, #252	; 0xfc
   1f5f6:	681b      	ldr	r3, [r3, #0]
   1f5f8:	ba12      	rev	r2, r2
   1f5fa:	ba18      	rev	r0, r3
	    if (ciaddr1 != wo->hisaddr
   1f5fc:	4293      	cmp	r3, r2
   1f5fe:	d100      	bne.n	1f602 <ipcp_reqci+0x118>
   1f600:	e0b4      	b.n	1f76c <ipcp_reqci+0x282>
		&& (ciaddr1 == 0 || !wo->accept_remote)) {
   1f602:	2a00      	cmp	r2, #0
   1f604:	d005      	beq.n	1f612 <ipcp_reqci+0x128>
   1f606:	0023      	movs	r3, r4
   1f608:	33f4      	adds	r3, #244	; 0xf4
   1f60a:	781e      	ldrb	r6, [r3, #0]
	orc = CONFACK;			/* Assume success */
   1f60c:	2302      	movs	r3, #2
		&& (ciaddr1 == 0 || !wo->accept_remote)) {
   1f60e:	06f6      	lsls	r6, r6, #27
   1f610:	d40b      	bmi.n	1f62a <ipcp_reqci+0x140>
		if (!reject_if_disagree) {
   1f612:	9e04      	ldr	r6, [sp, #16]
		orc = CONFNAK;
   1f614:	2303      	movs	r3, #3
		if (!reject_if_disagree) {
   1f616:	2e00      	cmp	r6, #0
   1f618:	d107      	bne.n	1f62a <ipcp_reqci+0x140>
		    PUTLONG(tl, p);
   1f61a:	0e03      	lsrs	r3, r0, #24
   1f61c:	708b      	strb	r3, [r1, #2]
   1f61e:	0c03      	lsrs	r3, r0, #16
   1f620:	70cb      	strb	r3, [r1, #3]
   1f622:	0a03      	lsrs	r3, r0, #8
   1f624:	710b      	strb	r3, [r1, #4]
		orc = CONFNAK;
   1f626:	2303      	movs	r3, #3
		    PUTLONG(tl, p);
   1f628:	7148      	strb	r0, [r1, #5]
	    ho->neg_addr = 1;
   1f62a:	268c      	movs	r6, #140	; 0x8c
   1f62c:	2001      	movs	r0, #1
   1f62e:	0076      	lsls	r6, r6, #1
   1f630:	5da7      	ldrb	r7, [r4, r6]
   1f632:	4338      	orrs	r0, r7
   1f634:	55a0      	strb	r0, [r4, r6]
	    ho->hisaddr = ciaddr1;
   1f636:	19a0      	adds	r0, r4, r6
	GETCHAR(cilen, p);		/* Parse CI length */
   1f638:	3e13      	subs	r6, #19
	    ho->hisaddr = ciaddr1;
   1f63a:	6082      	str	r2, [r0, #8]
	GETCHAR(cilen, p);		/* Parse CI length */
   1f63c:	3eff      	subs	r6, #255	; 0xff
	    break;
   1f63e:	e065      	b.n	1f70c <ipcp_reqci+0x222>
	    if (!ao->old_addrs || ho->neg_addr ||
   1f640:	2086      	movs	r0, #134	; 0x86
   1f642:	0040      	lsls	r0, r0, #1
   1f644:	5c20      	ldrb	r0, [r4, r0]
   1f646:	0780      	lsls	r0, r0, #30
   1f648:	d5a4      	bpl.n	1f594 <ipcp_reqci+0xaa>
   1f64a:	208c      	movs	r0, #140	; 0x8c
   1f64c:	0040      	lsls	r0, r0, #1
   1f64e:	5c20      	ldrb	r0, [r4, r0]
   1f650:	4210      	tst	r0, r2
   1f652:	d19f      	bne.n	1f594 <ipcp_reqci+0xaa>
   1f654:	2b0a      	cmp	r3, #10
   1f656:	d19d      	bne.n	1f594 <ipcp_reqci+0xaa>
   1f658:	78ca      	ldrb	r2, [r1, #3]
   1f65a:	788b      	ldrb	r3, [r1, #2]
   1f65c:	0212      	lsls	r2, r2, #8
   1f65e:	431a      	orrs	r2, r3
   1f660:	ba52      	rev16	r2, r2
	    GETLONG(tl, p);		/* Parse source address (his) */
   1f662:	790b      	ldrb	r3, [r1, #4]
   1f664:	b292      	uxth	r2, r2
   1f666:	0212      	lsls	r2, r2, #8
   1f668:	431a      	orrs	r2, r3
   1f66a:	794b      	ldrb	r3, [r1, #5]
   1f66c:	0212      	lsls	r2, r2, #8
   1f66e:	431a      	orrs	r2, r3
   1f670:	ba13      	rev	r3, r2
   1f672:	9305      	str	r3, [sp, #20]
   1f674:	0023      	movs	r3, r4
   1f676:	33fc      	adds	r3, #252	; 0xfc
   1f678:	681b      	ldr	r3, [r3, #0]
	    if (ciaddr1 != wo->hisaddr
   1f67a:	9a05      	ldr	r2, [sp, #20]
   1f67c:	ba18      	rev	r0, r3
   1f67e:	4293      	cmp	r3, r2
   1f680:	d06f      	beq.n	1f762 <ipcp_reqci+0x278>
		&& (ciaddr1 == 0 || !wo->accept_remote)) {
   1f682:	2a00      	cmp	r2, #0
   1f684:	d005      	beq.n	1f692 <ipcp_reqci+0x1a8>
   1f686:	0023      	movs	r3, r4
   1f688:	33f4      	adds	r3, #244	; 0xf4
   1f68a:	781e      	ldrb	r6, [r3, #0]
	orc = CONFACK;			/* Assume success */
   1f68c:	2302      	movs	r3, #2
		&& (ciaddr1 == 0 || !wo->accept_remote)) {
   1f68e:	06f2      	lsls	r2, r6, #27
   1f690:	d40b      	bmi.n	1f6aa <ipcp_reqci+0x1c0>
		if (!reject_if_disagree) {
   1f692:	9e04      	ldr	r6, [sp, #16]
		orc = CONFNAK;
   1f694:	2303      	movs	r3, #3
		if (!reject_if_disagree) {
   1f696:	2e00      	cmp	r6, #0
   1f698:	d107      	bne.n	1f6aa <ipcp_reqci+0x1c0>
		    PUTLONG(tl, p);
   1f69a:	0e03      	lsrs	r3, r0, #24
   1f69c:	708b      	strb	r3, [r1, #2]
   1f69e:	0c03      	lsrs	r3, r0, #16
   1f6a0:	70cb      	strb	r3, [r1, #3]
   1f6a2:	0a03      	lsrs	r3, r0, #8
   1f6a4:	710b      	strb	r3, [r1, #4]
		orc = CONFNAK;
   1f6a6:	2303      	movs	r3, #3
		    PUTLONG(tl, p);
   1f6a8:	7148      	strb	r0, [r1, #5]
   1f6aa:	79c8      	ldrb	r0, [r1, #7]
   1f6ac:	798e      	ldrb	r6, [r1, #6]
   1f6ae:	0200      	lsls	r0, r0, #8
   1f6b0:	4330      	orrs	r0, r6
   1f6b2:	ba40      	rev16	r0, r0
	    GETLONG(tl, p);		/* Parse desination address (ours) */
   1f6b4:	7a0e      	ldrb	r6, [r1, #8]
   1f6b6:	b280      	uxth	r0, r0
   1f6b8:	0200      	lsls	r0, r0, #8
   1f6ba:	4330      	orrs	r0, r6
   1f6bc:	7a4e      	ldrb	r6, [r1, #9]
   1f6be:	0200      	lsls	r0, r0, #8
   1f6c0:	4330      	orrs	r0, r6
   1f6c2:	0026      	movs	r6, r4
   1f6c4:	36f8      	adds	r6, #248	; 0xf8
   1f6c6:	6837      	ldr	r7, [r6, #0]
   1f6c8:	ba00      	rev	r0, r0
   1f6ca:	ba3e      	rev	r6, r7
	    if (ciaddr2 != wo->ouraddr) {
   1f6cc:	4287      	cmp	r7, r0
   1f6ce:	d012      	beq.n	1f6f6 <ipcp_reqci+0x20c>
		if (ciaddr2 == 0 || !wo->accept_local) {
   1f6d0:	2800      	cmp	r0, #0
   1f6d2:	d004      	beq.n	1f6de <ipcp_reqci+0x1f4>
   1f6d4:	0027      	movs	r7, r4
   1f6d6:	37f4      	adds	r7, #244	; 0xf4
   1f6d8:	783a      	ldrb	r2, [r7, #0]
   1f6da:	0712      	lsls	r2, r2, #28
   1f6dc:	d42c      	bmi.n	1f738 <ipcp_reqci+0x24e>
		    if (!reject_if_disagree) {
   1f6de:	9a04      	ldr	r2, [sp, #16]
		    orc = CONFNAK;
   1f6e0:	2303      	movs	r3, #3
		    if (!reject_if_disagree) {
   1f6e2:	2a00      	cmp	r2, #0
   1f6e4:	d107      	bne.n	1f6f6 <ipcp_reqci+0x20c>
			PUTLONG(tl, p);
   1f6e6:	0e33      	lsrs	r3, r6, #24
   1f6e8:	718b      	strb	r3, [r1, #6]
   1f6ea:	0c33      	lsrs	r3, r6, #16
   1f6ec:	71cb      	strb	r3, [r1, #7]
   1f6ee:	0a33      	lsrs	r3, r6, #8
   1f6f0:	720b      	strb	r3, [r1, #8]
		    orc = CONFNAK;
   1f6f2:	2303      	movs	r3, #3
			PUTLONG(tl, p);
   1f6f4:	724e      	strb	r6, [r1, #9]
	    ho->old_addrs = 1;
   1f6f6:	278c      	movs	r7, #140	; 0x8c
   1f6f8:	2602      	movs	r6, #2
   1f6fa:	007f      	lsls	r7, r7, #1
   1f6fc:	5de2      	ldrb	r2, [r4, r7]
   1f6fe:	4316      	orrs	r6, r2
	    ho->hisaddr = ciaddr1;
   1f700:	9a05      	ldr	r2, [sp, #20]
	    ho->old_addrs = 1;
   1f702:	55e6      	strb	r6, [r4, r7]
	    ho->hisaddr = ciaddr1;
   1f704:	19e6      	adds	r6, r4, r7
   1f706:	60b2      	str	r2, [r6, #8]
	    ho->ouraddr = ciaddr2;
   1f708:	6070      	str	r0, [r6, #4]
	GETCHAR(cilen, p);		/* Parse CI length */
   1f70a:	260a      	movs	r6, #10
	if (orc == CONFACK &&		/* Good CI */
   1f70c:	2b02      	cmp	r3, #2
   1f70e:	d01d      	beq.n	1f74c <ipcp_reqci+0x262>
	    if (reject_if_disagree)	/* Getting fed up with sending NAKs? */
   1f710:	9b04      	ldr	r3, [sp, #16]
   1f712:	2b00      	cmp	r3, #0
   1f714:	d000      	beq.n	1f718 <ipcp_reqci+0x22e>
   1f716:	e73d      	b.n	1f594 <ipcp_reqci+0xaa>
		if (rc == CONFREJ)	/* Rejecting prior CI? */
   1f718:	9b01      	ldr	r3, [sp, #4]
   1f71a:	2b04      	cmp	r3, #4
   1f71c:	d01a      	beq.n	1f754 <ipcp_reqci+0x26a>
		if (rc == CONFACK) {	/* Ack'd all prior CIs? */
   1f71e:	2b02      	cmp	r3, #2
   1f720:	d01a      	beq.n	1f758 <ipcp_reqci+0x26e>
   1f722:	2303      	movs	r3, #3
	    rc = CONFREJ;
   1f724:	9301      	str	r3, [sp, #4]
   1f726:	e739      	b.n	1f59c <ipcp_reqci+0xb2>
		wo->req_addr = 0;	/* don't NAK with 0.0.0.0 later */
   1f728:	0022      	movs	r2, r4
   1f72a:	2004      	movs	r0, #4
   1f72c:	32f4      	adds	r2, #244	; 0xf4
   1f72e:	7813      	ldrb	r3, [r2, #0]
	GETCHAR(cilen, p);		/* Parse CI length */
   1f730:	260a      	movs	r6, #10
		wo->req_addr = 0;	/* don't NAK with 0.0.0.0 later */
   1f732:	4383      	bics	r3, r0
   1f734:	7013      	strb	r3, [r2, #0]
		break;
   1f736:	e72d      	b.n	1f594 <ipcp_reqci+0xaa>
		    wo->ouraddr = ciaddr2;	/* accept peer's idea */
   1f738:	6078      	str	r0, [r7, #4]
   1f73a:	e7dc      	b.n	1f6f6 <ipcp_reqci+0x20c>
		wo->req_addr = 0;	/* don't NAK with 0.0.0.0 later */
   1f73c:	0022      	movs	r2, r4
   1f73e:	2004      	movs	r0, #4
   1f740:	32f4      	adds	r2, #244	; 0xf4
   1f742:	7813      	ldrb	r3, [r2, #0]
	GETCHAR(cilen, p);		/* Parse CI length */
   1f744:	2606      	movs	r6, #6
		wo->req_addr = 0;	/* don't NAK with 0.0.0.0 later */
   1f746:	4383      	bics	r3, r0
   1f748:	7013      	strb	r3, [r2, #0]
		break;
   1f74a:	e723      	b.n	1f594 <ipcp_reqci+0xaa>
	if (orc == CONFACK &&		/* Good CI */
   1f74c:	9b01      	ldr	r3, [sp, #4]
   1f74e:	2b02      	cmp	r3, #2
   1f750:	d100      	bne.n	1f754 <ipcp_reqci+0x26a>
   1f752:	e723      	b.n	1f59c <ipcp_reqci+0xb2>
   1f754:	9906      	ldr	r1, [sp, #24]
   1f756:	e6db      	b.n	1f510 <ipcp_reqci+0x26>
		    ucp = inp;		/* Backup */
   1f758:	9d03      	ldr	r5, [sp, #12]
   1f75a:	e7e2      	b.n	1f722 <ipcp_reqci+0x238>
	    ucp = inp;			/* Backup */
   1f75c:	9d03      	ldr	r5, [sp, #12]
	    rc = CONFREJ;
   1f75e:	2304      	movs	r3, #4
   1f760:	e7e0      	b.n	1f724 <ipcp_reqci+0x23a>
	    } else if (ciaddr1 == 0 && wo->hisaddr == 0) {
   1f762:	9b05      	ldr	r3, [sp, #20]
   1f764:	2b00      	cmp	r3, #0
   1f766:	d0df      	beq.n	1f728 <ipcp_reqci+0x23e>
	orc = CONFACK;			/* Assume success */
   1f768:	2302      	movs	r3, #2
   1f76a:	e79e      	b.n	1f6aa <ipcp_reqci+0x1c0>
	    } else if (ciaddr1 == 0 && wo->hisaddr == 0) {
   1f76c:	2b00      	cmp	r3, #0
   1f76e:	d0e5      	beq.n	1f73c <ipcp_reqci+0x252>
	orc = CONFACK;			/* Assume success */
   1f770:	2302      	movs	r3, #2
   1f772:	e75a      	b.n	1f62a <ipcp_reqci+0x140>

0001f774 <ipcp_protrej>:
   1f774:	b510      	push	{r4, lr}
   1f776:	30d8      	adds	r0, #216	; 0xd8
   1f778:	f001 f972 	bl	20a60 <fsm_lowerdown>
   1f77c:	bd10      	pop	{r4, pc}
	...

0001f780 <lcp_cilen>:


/*
 * lcp_cilen - Return length of our CI.
 */
static int lcp_cilen(fsm *f) {
   1f780:	b570      	push	{r4, r5, r6, lr}
    ppp_pcb *pcb = f->pcb;
   1f782:	6804      	ldr	r4, [r0, #0]
    /*
     * NB: we only ask for one of CHAP, UPAP, or EAP, even if we will
     * accept more than one.  We prefer EAP first, then CHAP, then
     * PAP.
     */
    return (LENCISHORT(go->neg_mru && go->mru != PPP_DEFMRU) +
   1f784:	2200      	movs	r2, #0
   1f786:	0021      	movs	r1, r4
   1f788:	3164      	adds	r1, #100	; 0x64
   1f78a:	780b      	ldrb	r3, [r1, #0]
   1f78c:	0758      	lsls	r0, r3, #29
   1f78e:	d505      	bpl.n	1f79c <lcp_cilen+0x1c>
   1f790:	4815      	ldr	r0, [pc, #84]	; (1f7e8 <lcp_cilen+0x68>)
   1f792:	884a      	ldrh	r2, [r1, #2]
   1f794:	1812      	adds	r2, r2, r0
   1f796:	1e50      	subs	r0, r2, #1
   1f798:	4182      	sbcs	r2, r0
   1f79a:	0092      	lsls	r2, r2, #2
	    LENCILONG(go->neg_asyncmap && go->asyncmap != 0xFFFFFFFF) +
   1f79c:	2500      	movs	r5, #0
   1f79e:	0718      	lsls	r0, r3, #28
   1f7a0:	d503      	bpl.n	1f7aa <lcp_cilen+0x2a>
   1f7a2:	6ea0      	ldr	r0, [r4, #104]	; 0x68
   1f7a4:	3001      	adds	r0, #1
   1f7a6:	d000      	beq.n	1f7aa <lcp_cilen+0x2a>
   1f7a8:	3506      	adds	r5, #6
    return (LENCISHORT(go->neg_mru && go->mru != PPP_DEFMRU) +
   1f7aa:	1952      	adds	r2, r2, r5
#endif /* !EAP_SUPPORT && !CHAP_SUPPORT */
#endif /* PAP_SUPPORT */
#if LQR_SUPPORT
	    LENCILQR(go->neg_lqr) +
#endif /* LQR_SUPPORT */
	    LENCICBCP(go->neg_cbcp) +
   1f7ac:	2503      	movs	r5, #3
	    LENCILONG(go->neg_magicnumber) +
   1f7ae:	2606      	movs	r6, #6
	    LENCICBCP(go->neg_cbcp) +
   1f7b0:	b258      	sxtb	r0, r3
   1f7b2:	17c0      	asrs	r0, r0, #31
   1f7b4:	4005      	ands	r5, r0
	    LENCILONG(go->neg_asyncmap && go->asyncmap != 0xFFFFFFFF) +
   1f7b6:	1955      	adds	r5, r2, r5
	    LENCILONG(go->neg_magicnumber) +
   1f7b8:	06da      	lsls	r2, r3, #27
   1f7ba:	17d2      	asrs	r2, r2, #31
   1f7bc:	4016      	ands	r6, r2
	    LENCIVOID(go->neg_pcompression) +
   1f7be:	2202      	movs	r2, #2
   1f7c0:	0918      	lsrs	r0, r3, #4
	    LENCIVOID(go->neg_accompression) +
#ifdef HAVE_MULTILINK
	    LENCISHORT(go->neg_mrru) +
#endif /* HAVE_MULTILINK */
	    LENCIVOID(go->neg_ssnhf) +
   1f7c2:	3465      	adds	r4, #101	; 0x65
   1f7c4:	7824      	ldrb	r4, [r4, #0]
	    LENCIVOID(go->neg_pcompression) +
   1f7c6:	4010      	ands	r0, r2
	    LENCICBCP(go->neg_cbcp) +
   1f7c8:	19ad      	adds	r5, r5, r6
	    LENCIVOID(go->neg_accompression) +
   1f7ca:	095b      	lsrs	r3, r3, #5
   1f7cc:	4013      	ands	r3, r2
	    LENCILONG(go->neg_magicnumber) +
   1f7ce:	1940      	adds	r0, r0, r5
	    LENCIVOID(go->neg_pcompression) +
   1f7d0:	18c0      	adds	r0, r0, r3
	    LENCIVOID(go->neg_ssnhf) +
   1f7d2:	0063      	lsls	r3, r4, #1
   1f7d4:	4013      	ands	r3, r2
	    LENCIVOID(go->neg_accompression) +
   1f7d6:	18c0      	adds	r0, r0, r3
	    (go->neg_endpoint? CILEN_CHAR + go->endpoint.length: 0));
   1f7d8:	2300      	movs	r3, #0
   1f7da:	4214      	tst	r4, r2
   1f7dc:	d001      	beq.n	1f7e2 <lcp_cilen+0x62>
   1f7de:	7b8b      	ldrb	r3, [r1, #14]
   1f7e0:	3303      	adds	r3, #3
	    LENCIVOID(go->neg_ssnhf) +
   1f7e2:	18c0      	adds	r0, r0, r3
}
   1f7e4:	bd70      	pop	{r4, r5, r6, pc}
   1f7e6:	46c0      	nop			; (mov r8, r8)
   1f7e8:	fffffa24 	.word	0xfffffa24

0001f7ec <lcp_ackci>:
 *
 * Returns:
 *	0 - Ack was bad.
 *	1 - Ack was good.
 */
static int lcp_ackci(fsm *f, u_char *p, int len) {
   1f7ec:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
    ppp_pcb *pcb = f->pcb;
   1f7ee:	6805      	ldr	r5, [r0, #0]
	    if (cichar != val[i]) \
		goto bad; \
	} \
    }

    ACKCISHORT(CI_MRU, go->neg_mru && go->mru != PPP_DEFMRU, go->mru);
   1f7f0:	002e      	movs	r6, r5
   1f7f2:	3664      	adds	r6, #100	; 0x64
   1f7f4:	7834      	ldrb	r4, [r6, #0]
   1f7f6:	9601      	str	r6, [sp, #4]
   1f7f8:	0763      	lsls	r3, r4, #29
   1f7fa:	d51b      	bpl.n	1f834 <lcp_ackci+0x48>
   1f7fc:	8877      	ldrh	r7, [r6, #2]
   1f7fe:	4b58      	ldr	r3, [pc, #352]	; (1f960 <lcp_ackci+0x174>)
   1f800:	429f      	cmp	r7, r3
   1f802:	d017      	beq.n	1f834 <lcp_ackci+0x48>
    if (len != 0)
	goto bad;
    return (1);
bad:
    LCPDEBUG(("lcp_acki: received bad Ack!"));
    return (0);
   1f804:	2000      	movs	r0, #0
    ACKCISHORT(CI_MRU, go->neg_mru && go->mru != PPP_DEFMRU, go->mru);
   1f806:	3a04      	subs	r2, #4
   1f808:	d500      	bpl.n	1f80c <lcp_ackci+0x20>
   1f80a:	e099      	b.n	1f940 <lcp_ackci+0x154>
   1f80c:	784b      	ldrb	r3, [r1, #1]
   1f80e:	2b04      	cmp	r3, #4
   1f810:	d000      	beq.n	1f814 <lcp_ackci+0x28>
   1f812:	e095      	b.n	1f940 <lcp_ackci+0x154>
   1f814:	780b      	ldrb	r3, [r1, #0]
   1f816:	2b01      	cmp	r3, #1
   1f818:	d000      	beq.n	1f81c <lcp_ackci+0x30>
   1f81a:	e091      	b.n	1f940 <lcp_ackci+0x154>
   1f81c:	788b      	ldrb	r3, [r1, #2]
   1f81e:	469c      	mov	ip, r3
   1f820:	4666      	mov	r6, ip
   1f822:	78cb      	ldrb	r3, [r1, #3]
   1f824:	021b      	lsls	r3, r3, #8
   1f826:	4333      	orrs	r3, r6
   1f828:	ba5b      	rev16	r3, r3
   1f82a:	b29b      	uxth	r3, r3
   1f82c:	42bb      	cmp	r3, r7
   1f82e:	d000      	beq.n	1f832 <lcp_ackci+0x46>
   1f830:	e086      	b.n	1f940 <lcp_ackci+0x154>
   1f832:	3104      	adds	r1, #4
    ACKCILONG(CI_ASYNCMAP, go->neg_asyncmap && go->asyncmap != 0xFFFFFFFF,
   1f834:	0723      	lsls	r3, r4, #28
   1f836:	d51c      	bpl.n	1f872 <lcp_ackci+0x86>
   1f838:	6eaf      	ldr	r7, [r5, #104]	; 0x68
   1f83a:	1c7b      	adds	r3, r7, #1
   1f83c:	d019      	beq.n	1f872 <lcp_ackci+0x86>
    return (0);
   1f83e:	2000      	movs	r0, #0
    ACKCILONG(CI_ASYNCMAP, go->neg_asyncmap && go->asyncmap != 0xFFFFFFFF,
   1f840:	3a06      	subs	r2, #6
   1f842:	d47d      	bmi.n	1f940 <lcp_ackci+0x154>
   1f844:	784b      	ldrb	r3, [r1, #1]
   1f846:	2b06      	cmp	r3, #6
   1f848:	d17a      	bne.n	1f940 <lcp_ackci+0x154>
   1f84a:	780b      	ldrb	r3, [r1, #0]
   1f84c:	2b02      	cmp	r3, #2
   1f84e:	d177      	bne.n	1f940 <lcp_ackci+0x154>
   1f850:	788b      	ldrb	r3, [r1, #2]
   1f852:	469c      	mov	ip, r3
   1f854:	4666      	mov	r6, ip
   1f856:	78cb      	ldrb	r3, [r1, #3]
   1f858:	021b      	lsls	r3, r3, #8
   1f85a:	4333      	orrs	r3, r6
   1f85c:	ba5b      	rev16	r3, r3
   1f85e:	790e      	ldrb	r6, [r1, #4]
   1f860:	b29b      	uxth	r3, r3
   1f862:	021b      	lsls	r3, r3, #8
   1f864:	4333      	orrs	r3, r6
   1f866:	794e      	ldrb	r6, [r1, #5]
   1f868:	021b      	lsls	r3, r3, #8
   1f86a:	4333      	orrs	r3, r6
   1f86c:	429f      	cmp	r7, r3
   1f86e:	d167      	bne.n	1f940 <lcp_ackci+0x154>
   1f870:	3106      	adds	r1, #6
    ACKCICHAR(CI_CALLBACK, go->neg_cbcp, CBCP_OPT);
   1f872:	b263      	sxtb	r3, r4
   1f874:	2b00      	cmp	r3, #0
   1f876:	da0c      	bge.n	1f892 <lcp_ackci+0xa6>
    return (0);
   1f878:	2000      	movs	r0, #0
    ACKCICHAR(CI_CALLBACK, go->neg_cbcp, CBCP_OPT);
   1f87a:	3a03      	subs	r2, #3
   1f87c:	d460      	bmi.n	1f940 <lcp_ackci+0x154>
   1f87e:	784b      	ldrb	r3, [r1, #1]
   1f880:	2b03      	cmp	r3, #3
   1f882:	d15d      	bne.n	1f940 <lcp_ackci+0x154>
   1f884:	780b      	ldrb	r3, [r1, #0]
   1f886:	2b0d      	cmp	r3, #13
   1f888:	d15a      	bne.n	1f940 <lcp_ackci+0x154>
   1f88a:	788b      	ldrb	r3, [r1, #2]
   1f88c:	2b06      	cmp	r3, #6
   1f88e:	d157      	bne.n	1f940 <lcp_ackci+0x154>
   1f890:	3103      	adds	r1, #3
    ACKCILONG(CI_MAGICNUMBER, go->neg_magicnumber, go->magicnumber);
   1f892:	06e3      	lsls	r3, r4, #27
   1f894:	d518      	bpl.n	1f8c8 <lcp_ackci+0xdc>
    return (0);
   1f896:	2000      	movs	r0, #0
    ACKCILONG(CI_MAGICNUMBER, go->neg_magicnumber, go->magicnumber);
   1f898:	3a06      	subs	r2, #6
   1f89a:	d451      	bmi.n	1f940 <lcp_ackci+0x154>
   1f89c:	784b      	ldrb	r3, [r1, #1]
   1f89e:	2b06      	cmp	r3, #6
   1f8a0:	d14e      	bne.n	1f940 <lcp_ackci+0x154>
   1f8a2:	780b      	ldrb	r3, [r1, #0]
   1f8a4:	2b05      	cmp	r3, #5
   1f8a6:	d14b      	bne.n	1f940 <lcp_ackci+0x154>
   1f8a8:	78cb      	ldrb	r3, [r1, #3]
   1f8aa:	788f      	ldrb	r7, [r1, #2]
   1f8ac:	021b      	lsls	r3, r3, #8
   1f8ae:	433b      	orrs	r3, r7
   1f8b0:	ba5b      	rev16	r3, r3
   1f8b2:	790f      	ldrb	r7, [r1, #4]
   1f8b4:	b29b      	uxth	r3, r3
   1f8b6:	021b      	lsls	r3, r3, #8
   1f8b8:	433b      	orrs	r3, r7
   1f8ba:	6eee      	ldr	r6, [r5, #108]	; 0x6c
   1f8bc:	794f      	ldrb	r7, [r1, #5]
   1f8be:	021b      	lsls	r3, r3, #8
   1f8c0:	433b      	orrs	r3, r7
   1f8c2:	429e      	cmp	r6, r3
   1f8c4:	d13c      	bne.n	1f940 <lcp_ackci+0x154>
   1f8c6:	3106      	adds	r1, #6
    ACKCIVOID(CI_PCOMPRESSION, go->neg_pcompression);
   1f8c8:	06a3      	lsls	r3, r4, #26
   1f8ca:	d509      	bpl.n	1f8e0 <lcp_ackci+0xf4>
    return (0);
   1f8cc:	2000      	movs	r0, #0
    ACKCIVOID(CI_PCOMPRESSION, go->neg_pcompression);
   1f8ce:	3a02      	subs	r2, #2
   1f8d0:	d436      	bmi.n	1f940 <lcp_ackci+0x154>
   1f8d2:	784f      	ldrb	r7, [r1, #1]
   1f8d4:	780b      	ldrb	r3, [r1, #0]
   1f8d6:	2f02      	cmp	r7, #2
   1f8d8:	d132      	bne.n	1f940 <lcp_ackci+0x154>
   1f8da:	2b07      	cmp	r3, #7
   1f8dc:	d130      	bne.n	1f940 <lcp_ackci+0x154>
   1f8de:	3102      	adds	r1, #2
    ACKCIVOID(CI_ACCOMPRESSION, go->neg_accompression);
   1f8e0:	0663      	lsls	r3, r4, #25
   1f8e2:	d509      	bpl.n	1f8f8 <lcp_ackci+0x10c>
    return (0);
   1f8e4:	2000      	movs	r0, #0
    ACKCIVOID(CI_ACCOMPRESSION, go->neg_accompression);
   1f8e6:	3a02      	subs	r2, #2
   1f8e8:	d42a      	bmi.n	1f940 <lcp_ackci+0x154>
   1f8ea:	784c      	ldrb	r4, [r1, #1]
   1f8ec:	780b      	ldrb	r3, [r1, #0]
   1f8ee:	2c02      	cmp	r4, #2
   1f8f0:	d126      	bne.n	1f940 <lcp_ackci+0x154>
   1f8f2:	2b08      	cmp	r3, #8
   1f8f4:	d124      	bne.n	1f940 <lcp_ackci+0x154>
   1f8f6:	3102      	adds	r1, #2
    ACKCIVOID(CI_SSNHF, go->neg_ssnhf);
   1f8f8:	002b      	movs	r3, r5
   1f8fa:	3365      	adds	r3, #101	; 0x65
   1f8fc:	781b      	ldrb	r3, [r3, #0]
   1f8fe:	07d8      	lsls	r0, r3, #31
   1f900:	d509      	bpl.n	1f916 <lcp_ackci+0x12a>
    return (0);
   1f902:	2000      	movs	r0, #0
    ACKCIVOID(CI_SSNHF, go->neg_ssnhf);
   1f904:	3a02      	subs	r2, #2
   1f906:	d41b      	bmi.n	1f940 <lcp_ackci+0x154>
   1f908:	784f      	ldrb	r7, [r1, #1]
   1f90a:	780c      	ldrb	r4, [r1, #0]
   1f90c:	2f02      	cmp	r7, #2
   1f90e:	d117      	bne.n	1f940 <lcp_ackci+0x154>
   1f910:	2c12      	cmp	r4, #18
   1f912:	d115      	bne.n	1f940 <lcp_ackci+0x154>
   1f914:	3102      	adds	r1, #2
    ACKCIENDP(CI_EPDISC, go->neg_endpoint, go->endpoint.class_,
   1f916:	079b      	lsls	r3, r3, #30
   1f918:	d51c      	bpl.n	1f954 <lcp_ackci+0x168>
    return (0);
   1f91a:	2000      	movs	r0, #0
    ACKCIENDP(CI_EPDISC, go->neg_endpoint, go->endpoint.class_,
   1f91c:	9b01      	ldr	r3, [sp, #4]
   1f91e:	7b9b      	ldrb	r3, [r3, #14]
   1f920:	1cdc      	adds	r4, r3, #3
   1f922:	1b12      	subs	r2, r2, r4
   1f924:	4282      	cmp	r2, r0
   1f926:	db0b      	blt.n	1f940 <lcp_ackci+0x154>
   1f928:	784f      	ldrb	r7, [r1, #1]
   1f92a:	42bc      	cmp	r4, r7
   1f92c:	d108      	bne.n	1f940 <lcp_ackci+0x154>
   1f92e:	780c      	ldrb	r4, [r1, #0]
   1f930:	2c13      	cmp	r4, #19
   1f932:	d105      	bne.n	1f940 <lcp_ackci+0x154>
   1f934:	9c01      	ldr	r4, [sp, #4]
   1f936:	7b66      	ldrb	r6, [r4, #13]
   1f938:	788c      	ldrb	r4, [r1, #2]
   1f93a:	3103      	adds	r1, #3
   1f93c:	42a6      	cmp	r6, r4
   1f93e:	d007      	beq.n	1f950 <lcp_ackci+0x164>
}
   1f940:	bdfe      	pop	{r1, r2, r3, r4, r5, r6, r7, pc}
    ACKCIENDP(CI_EPDISC, go->neg_endpoint, go->endpoint.class_,
   1f942:	0004      	movs	r4, r0
   1f944:	3473      	adds	r4, #115	; 0x73
   1f946:	5d2e      	ldrb	r6, [r5, r4]
   1f948:	5c0c      	ldrb	r4, [r1, r0]
   1f94a:	42a6      	cmp	r6, r4
   1f94c:	d105      	bne.n	1f95a <lcp_ackci+0x16e>
   1f94e:	3001      	adds	r0, #1
   1f950:	4283      	cmp	r3, r0
   1f952:	dcf6      	bgt.n	1f942 <lcp_ackci+0x156>
    return (1);
   1f954:	4250      	negs	r0, r2
   1f956:	4150      	adcs	r0, r2
   1f958:	e7f2      	b.n	1f940 <lcp_ackci+0x154>
    return (0);
   1f95a:	2000      	movs	r0, #0
   1f95c:	e7f0      	b.n	1f940 <lcp_ackci+0x154>
   1f95e:	46c0      	nop			; (mov r8, r8)
   1f960:	000005dc 	.word	0x000005dc

0001f964 <lcp_rejci>:
 *
 * Returns:
 *	0 - Reject was bad.
 *	1 - Reject was good.
 */
static int lcp_rejci(fsm *f, u_char *p, int len) {
   1f964:	b5f0      	push	{r4, r5, r6, r7, lr}
    ppp_pcb *pcb = f->pcb;
   1f966:	6803      	ldr	r3, [r0, #0]
static int lcp_rejci(fsm *f, u_char *p, int len) {
   1f968:	b093      	sub	sp, #76	; 0x4c
    u_char cichar;
    u_short cishort;
    u32_t cilong;
    lcp_options try_;		/* options to request next time */

    try_ = *go;
   1f96a:	ad09      	add	r5, sp, #36	; 0x24
static int lcp_rejci(fsm *f, u_char *p, int len) {
   1f96c:	9007      	str	r0, [sp, #28]
    try_ = *go;
   1f96e:	0018      	movs	r0, r3
   1f970:	002c      	movs	r4, r5
   1f972:	3064      	adds	r0, #100	; 0x64
   1f974:	c8e0      	ldmia	r0!, {r5, r6, r7}
   1f976:	c4e0      	stmia	r4!, {r5, r6, r7}
   1f978:	c8e0      	ldmia	r0!, {r5, r6, r7}
   1f97a:	c4e0      	stmia	r4!, {r5, r6, r7}
   1f97c:	c8e0      	ldmia	r0!, {r5, r6, r7}
   1f97e:	c4e0      	stmia	r4!, {r5, r6, r7}
   1f980:	3824      	subs	r0, #36	; 0x24
   1f982:	7804      	ldrb	r4, [r0, #0]
   1f984:	0765      	lsls	r5, r4, #29
   1f986:	0fed      	lsrs	r5, r5, #31
   1f988:	9506      	str	r5, [sp, #24]
   1f98a:	0725      	lsls	r5, r4, #28
   1f98c:	0fed      	lsrs	r5, r5, #31
   1f98e:	9503      	str	r5, [sp, #12]
   1f990:	06e5      	lsls	r5, r4, #27
   1f992:	0fed      	lsrs	r5, r5, #31
   1f994:	9502      	str	r5, [sp, #8]
   1f996:	06a5      	lsls	r5, r4, #26
   1f998:	0fed      	lsrs	r5, r5, #31
   1f99a:	9501      	str	r5, [sp, #4]
   1f99c:	0665      	lsls	r5, r4, #25
   1f99e:	0fed      	lsrs	r5, r5, #31
   1f9a0:	9500      	str	r5, [sp, #0]
   1f9a2:	09e5      	lsrs	r5, r4, #7
   1f9a4:	9504      	str	r5, [sp, #16]
   1f9a6:	001d      	movs	r5, r3
   1f9a8:	3565      	adds	r5, #101	; 0x65
   1f9aa:	782d      	ldrb	r5, [r5, #0]
   1f9ac:	07ef      	lsls	r7, r5, #31
   1f9ae:	0fff      	lsrs	r7, r7, #31
   1f9b0:	07ad      	lsls	r5, r5, #30
   1f9b2:	9705      	str	r7, [sp, #20]
   1f9b4:	0fed      	lsrs	r5, r5, #31
		goto bad; \
	} \
	try_.neg = 0; \
    }

    REJCISHORT(CI_MRU, neg_mru, go->mru);
   1f9b6:	0766      	lsls	r6, r4, #29
   1f9b8:	d518      	bpl.n	1f9ec <lcp_rejci+0x88>
   1f9ba:	2a03      	cmp	r2, #3
   1f9bc:	dd16      	ble.n	1f9ec <lcp_rejci+0x88>
   1f9be:	784f      	ldrb	r7, [r1, #1]
   1f9c0:	2f04      	cmp	r7, #4
   1f9c2:	d113      	bne.n	1f9ec <lcp_rejci+0x88>
   1f9c4:	780f      	ldrb	r7, [r1, #0]
   1f9c6:	2f01      	cmp	r7, #1
   1f9c8:	d110      	bne.n	1f9ec <lcp_rejci+0x88>
   1f9ca:	788f      	ldrb	r7, [r1, #2]
   1f9cc:	8840      	ldrh	r0, [r0, #2]
   1f9ce:	46bc      	mov	ip, r7
   1f9d0:	4666      	mov	r6, ip
   1f9d2:	4684      	mov	ip, r0
   1f9d4:	78cf      	ldrb	r7, [r1, #3]
	*go = try_;
    return 1;

bad:
    LCPDEBUG(("lcp_rejci: received bad Reject!"));
    return 0;
   1f9d6:	2000      	movs	r0, #0
    REJCISHORT(CI_MRU, neg_mru, go->mru);
   1f9d8:	023f      	lsls	r7, r7, #8
   1f9da:	4337      	orrs	r7, r6
   1f9dc:	ba7f      	rev16	r7, r7
   1f9de:	b2bf      	uxth	r7, r7
   1f9e0:	45bc      	cmp	ip, r7
   1f9e2:	d000      	beq.n	1f9e6 <lcp_rejci+0x82>
   1f9e4:	e090      	b.n	1fb08 <lcp_rejci+0x1a4>
   1f9e6:	3a04      	subs	r2, #4
   1f9e8:	3104      	adds	r1, #4
   1f9ea:	9006      	str	r0, [sp, #24]
    REJCILONG(CI_ASYNCMAP, neg_asyncmap, go->asyncmap);
   1f9ec:	0720      	lsls	r0, r4, #28
   1f9ee:	d51a      	bpl.n	1fa26 <lcp_rejci+0xc2>
   1f9f0:	2a05      	cmp	r2, #5
   1f9f2:	dd18      	ble.n	1fa26 <lcp_rejci+0xc2>
   1f9f4:	7848      	ldrb	r0, [r1, #1]
   1f9f6:	2806      	cmp	r0, #6
   1f9f8:	d115      	bne.n	1fa26 <lcp_rejci+0xc2>
   1f9fa:	7808      	ldrb	r0, [r1, #0]
   1f9fc:	2802      	cmp	r0, #2
   1f9fe:	d112      	bne.n	1fa26 <lcp_rejci+0xc2>
   1fa00:	78c8      	ldrb	r0, [r1, #3]
   1fa02:	788f      	ldrb	r7, [r1, #2]
   1fa04:	0200      	lsls	r0, r0, #8
   1fa06:	4338      	orrs	r0, r7
   1fa08:	ba40      	rev16	r0, r0
   1fa0a:	b280      	uxth	r0, r0
   1fa0c:	790f      	ldrb	r7, [r1, #4]
   1fa0e:	0200      	lsls	r0, r0, #8
   1fa10:	4307      	orrs	r7, r0
   1fa12:	6e9e      	ldr	r6, [r3, #104]	; 0x68
   1fa14:	7948      	ldrb	r0, [r1, #5]
   1fa16:	023f      	lsls	r7, r7, #8
   1fa18:	4307      	orrs	r7, r0
    return 0;
   1fa1a:	2000      	movs	r0, #0
    REJCILONG(CI_ASYNCMAP, neg_asyncmap, go->asyncmap);
   1fa1c:	42be      	cmp	r6, r7
   1fa1e:	d173      	bne.n	1fb08 <lcp_rejci+0x1a4>
   1fa20:	3a06      	subs	r2, #6
   1fa22:	3106      	adds	r1, #6
   1fa24:	9003      	str	r0, [sp, #12]
    REJCICBCP(CI_CALLBACK, neg_cbcp, CBCP_OPT);
   1fa26:	b260      	sxtb	r0, r4
   1fa28:	2800      	cmp	r0, #0
   1fa2a:	da0e      	bge.n	1fa4a <lcp_rejci+0xe6>
   1fa2c:	2a02      	cmp	r2, #2
   1fa2e:	dd0c      	ble.n	1fa4a <lcp_rejci+0xe6>
   1fa30:	7848      	ldrb	r0, [r1, #1]
   1fa32:	2803      	cmp	r0, #3
   1fa34:	d109      	bne.n	1fa4a <lcp_rejci+0xe6>
   1fa36:	7808      	ldrb	r0, [r1, #0]
   1fa38:	280d      	cmp	r0, #13
   1fa3a:	d106      	bne.n	1fa4a <lcp_rejci+0xe6>
   1fa3c:	788f      	ldrb	r7, [r1, #2]
    return 0;
   1fa3e:	2000      	movs	r0, #0
    REJCICBCP(CI_CALLBACK, neg_cbcp, CBCP_OPT);
   1fa40:	2f06      	cmp	r7, #6
   1fa42:	d161      	bne.n	1fb08 <lcp_rejci+0x1a4>
   1fa44:	3a03      	subs	r2, #3
   1fa46:	3103      	adds	r1, #3
   1fa48:	9004      	str	r0, [sp, #16]
    REJCILONG(CI_MAGICNUMBER, neg_magicnumber, go->magicnumber);
   1fa4a:	06e0      	lsls	r0, r4, #27
   1fa4c:	d51a      	bpl.n	1fa84 <lcp_rejci+0x120>
   1fa4e:	2a05      	cmp	r2, #5
   1fa50:	dd18      	ble.n	1fa84 <lcp_rejci+0x120>
   1fa52:	7848      	ldrb	r0, [r1, #1]
   1fa54:	2806      	cmp	r0, #6
   1fa56:	d115      	bne.n	1fa84 <lcp_rejci+0x120>
   1fa58:	7808      	ldrb	r0, [r1, #0]
   1fa5a:	2805      	cmp	r0, #5
   1fa5c:	d112      	bne.n	1fa84 <lcp_rejci+0x120>
   1fa5e:	78c8      	ldrb	r0, [r1, #3]
   1fa60:	788f      	ldrb	r7, [r1, #2]
   1fa62:	0200      	lsls	r0, r0, #8
   1fa64:	4338      	orrs	r0, r7
   1fa66:	ba40      	rev16	r0, r0
   1fa68:	b280      	uxth	r0, r0
   1fa6a:	790f      	ldrb	r7, [r1, #4]
   1fa6c:	0200      	lsls	r0, r0, #8
   1fa6e:	4307      	orrs	r7, r0
   1fa70:	6ede      	ldr	r6, [r3, #108]	; 0x6c
   1fa72:	7948      	ldrb	r0, [r1, #5]
   1fa74:	023f      	lsls	r7, r7, #8
   1fa76:	4307      	orrs	r7, r0
    return 0;
   1fa78:	2000      	movs	r0, #0
    REJCILONG(CI_MAGICNUMBER, neg_magicnumber, go->magicnumber);
   1fa7a:	42be      	cmp	r6, r7
   1fa7c:	d144      	bne.n	1fb08 <lcp_rejci+0x1a4>
   1fa7e:	3a06      	subs	r2, #6
   1fa80:	3106      	adds	r1, #6
   1fa82:	9002      	str	r0, [sp, #8]
    REJCIVOID(CI_PCOMPRESSION, neg_pcompression);
   1fa84:	06a0      	lsls	r0, r4, #26
   1fa86:	d50b      	bpl.n	1faa0 <lcp_rejci+0x13c>
   1fa88:	2a01      	cmp	r2, #1
   1fa8a:	dd09      	ble.n	1faa0 <lcp_rejci+0x13c>
   1fa8c:	7848      	ldrb	r0, [r1, #1]
   1fa8e:	2802      	cmp	r0, #2
   1fa90:	d106      	bne.n	1faa0 <lcp_rejci+0x13c>
   1fa92:	7808      	ldrb	r0, [r1, #0]
   1fa94:	2807      	cmp	r0, #7
   1fa96:	d103      	bne.n	1faa0 <lcp_rejci+0x13c>
   1fa98:	2000      	movs	r0, #0
   1fa9a:	3a02      	subs	r2, #2
   1fa9c:	3102      	adds	r1, #2
   1fa9e:	9001      	str	r0, [sp, #4]
    REJCIVOID(CI_ACCOMPRESSION, neg_accompression);
   1faa0:	0660      	lsls	r0, r4, #25
   1faa2:	d50b      	bpl.n	1fabc <lcp_rejci+0x158>
   1faa4:	2a01      	cmp	r2, #1
   1faa6:	dd09      	ble.n	1fabc <lcp_rejci+0x158>
   1faa8:	7848      	ldrb	r0, [r1, #1]
   1faaa:	2802      	cmp	r0, #2
   1faac:	d106      	bne.n	1fabc <lcp_rejci+0x158>
   1faae:	7808      	ldrb	r0, [r1, #0]
   1fab0:	2808      	cmp	r0, #8
   1fab2:	d103      	bne.n	1fabc <lcp_rejci+0x158>
   1fab4:	2000      	movs	r0, #0
   1fab6:	3a02      	subs	r2, #2
   1fab8:	3102      	adds	r1, #2
   1faba:	9000      	str	r0, [sp, #0]
    REJCIVOID(CI_SSNHF, neg_ssnhf);
   1fabc:	0018      	movs	r0, r3
   1fabe:	3065      	adds	r0, #101	; 0x65
   1fac0:	7800      	ldrb	r0, [r0, #0]
   1fac2:	07c4      	lsls	r4, r0, #31
   1fac4:	d50b      	bpl.n	1fade <lcp_rejci+0x17a>
   1fac6:	2a01      	cmp	r2, #1
   1fac8:	dd09      	ble.n	1fade <lcp_rejci+0x17a>
   1faca:	784c      	ldrb	r4, [r1, #1]
   1facc:	2c02      	cmp	r4, #2
   1face:	d106      	bne.n	1fade <lcp_rejci+0x17a>
   1fad0:	780c      	ldrb	r4, [r1, #0]
   1fad2:	2c12      	cmp	r4, #18
   1fad4:	d103      	bne.n	1fade <lcp_rejci+0x17a>
   1fad6:	2400      	movs	r4, #0
   1fad8:	3a02      	subs	r2, #2
   1fada:	3102      	adds	r1, #2
   1fadc:	9405      	str	r4, [sp, #20]
    REJCIENDP(CI_EPDISC, neg_endpoint, go->endpoint.class_,
   1fade:	0780      	lsls	r0, r0, #30
   1fae0:	d51f      	bpl.n	1fb22 <lcp_rejci+0x1be>
   1fae2:	001f      	movs	r7, r3
   1fae4:	3764      	adds	r7, #100	; 0x64
   1fae6:	7bbc      	ldrb	r4, [r7, #14]
   1fae8:	1ca0      	adds	r0, r4, #2
   1faea:	4290      	cmp	r0, r2
   1faec:	da19      	bge.n	1fb22 <lcp_rejci+0x1be>
   1faee:	780d      	ldrb	r5, [r1, #0]
    return 0;
   1faf0:	2000      	movs	r0, #0
    REJCIENDP(CI_EPDISC, neg_endpoint, go->endpoint.class_,
   1faf2:	2d13      	cmp	r5, #19
   1faf4:	d108      	bne.n	1fb08 <lcp_rejci+0x1a4>
   1faf6:	784d      	ldrb	r5, [r1, #1]
   1faf8:	1ce6      	adds	r6, r4, #3
   1fafa:	42b5      	cmp	r5, r6
   1fafc:	d104      	bne.n	1fb08 <lcp_rejci+0x1a4>
   1fafe:	7b7e      	ldrb	r6, [r7, #13]
   1fb00:	788f      	ldrb	r7, [r1, #2]
   1fb02:	3103      	adds	r1, #3
   1fb04:	42be      	cmp	r6, r7
   1fb06:	d008      	beq.n	1fb1a <lcp_rejci+0x1b6>
}
   1fb08:	b013      	add	sp, #76	; 0x4c
   1fb0a:	bdf0      	pop	{r4, r5, r6, r7, pc}
    REJCIENDP(CI_EPDISC, neg_endpoint, go->endpoint.class_,
   1fb0c:	0007      	movs	r7, r0
   1fb0e:	3773      	adds	r7, #115	; 0x73
   1fb10:	5dde      	ldrb	r6, [r3, r7]
   1fb12:	5c0f      	ldrb	r7, [r1, r0]
   1fb14:	42be      	cmp	r6, r7
   1fb16:	d140      	bne.n	1fb9a <lcp_rejci+0x236>
   1fb18:	3001      	adds	r0, #1
   1fb1a:	4284      	cmp	r4, r0
   1fb1c:	dcf6      	bgt.n	1fb0c <lcp_rejci+0x1a8>
   1fb1e:	1b52      	subs	r2, r2, r5
   1fb20:	2500      	movs	r5, #0
    return 0;
   1fb22:	2000      	movs	r0, #0
    if (len != 0)
   1fb24:	4282      	cmp	r2, r0
   1fb26:	d1ef      	bne.n	1fb08 <lcp_rejci+0x1a4>
   1fb28:	2401      	movs	r4, #1
    if (f->state != PPP_FSM_OPENED)
   1fb2a:	9a07      	ldr	r2, [sp, #28]
    return 1;
   1fb2c:	0020      	movs	r0, r4
    if (f->state != PPP_FSM_OPENED)
   1fb2e:	7c12      	ldrb	r2, [r2, #16]
   1fb30:	2a09      	cmp	r2, #9
   1fb32:	d0e9      	beq.n	1fb08 <lcp_rejci+0x1a4>
	*go = try_;
   1fb34:	2604      	movs	r6, #4
   1fb36:	9a06      	ldr	r2, [sp, #24]
   1fb38:	a909      	add	r1, sp, #36	; 0x24
   1fb3a:	0090      	lsls	r0, r2, #2
   1fb3c:	780a      	ldrb	r2, [r1, #0]
   1fb3e:	40a5      	lsls	r5, r4
   1fb40:	43b2      	bics	r2, r6
   1fb42:	4302      	orrs	r2, r0
   1fb44:	2008      	movs	r0, #8
   1fb46:	4382      	bics	r2, r0
   1fb48:	9802      	ldr	r0, [sp, #8]
   1fb4a:	9e03      	ldr	r6, [sp, #12]
   1fb4c:	0107      	lsls	r7, r0, #4
   1fb4e:	2010      	movs	r0, #16
   1fb50:	00f6      	lsls	r6, r6, #3
   1fb52:	4332      	orrs	r2, r6
   1fb54:	2620      	movs	r6, #32
   1fb56:	4382      	bics	r2, r0
   1fb58:	9801      	ldr	r0, [sp, #4]
   1fb5a:	433a      	orrs	r2, r7
   1fb5c:	43b2      	bics	r2, r6
   1fb5e:	0140      	lsls	r0, r0, #5
   1fb60:	4310      	orrs	r0, r2
   1fb62:	2240      	movs	r2, #64	; 0x40
   1fb64:	4390      	bics	r0, r2
   1fb66:	9a04      	ldr	r2, [sp, #16]
   1fb68:	9e00      	ldr	r6, [sp, #0]
   1fb6a:	01d7      	lsls	r7, r2, #7
   1fb6c:	227f      	movs	r2, #127	; 0x7f
   1fb6e:	01b6      	lsls	r6, r6, #6
   1fb70:	4330      	orrs	r0, r6
   1fb72:	4010      	ands	r0, r2
   1fb74:	4338      	orrs	r0, r7
   1fb76:	784f      	ldrb	r7, [r1, #1]
   1fb78:	9a05      	ldr	r2, [sp, #20]
   1fb7a:	43a7      	bics	r7, r4
   1fb7c:	4317      	orrs	r7, r2
   1fb7e:	2202      	movs	r2, #2
   1fb80:	4397      	bics	r7, r2
   1fb82:	433d      	orrs	r5, r7
   1fb84:	7008      	strb	r0, [r1, #0]
   1fb86:	704d      	strb	r5, [r1, #1]
   1fb88:	3364      	adds	r3, #100	; 0x64
   1fb8a:	c925      	ldmia	r1!, {r0, r2, r5}
   1fb8c:	c325      	stmia	r3!, {r0, r2, r5}
   1fb8e:	c925      	ldmia	r1!, {r0, r2, r5}
   1fb90:	c325      	stmia	r3!, {r0, r2, r5}
   1fb92:	c925      	ldmia	r1!, {r0, r2, r5}
   1fb94:	c325      	stmia	r3!, {r0, r2, r5}
    return 1;
   1fb96:	0020      	movs	r0, r4
   1fb98:	e7b6      	b.n	1fb08 <lcp_rejci+0x1a4>
    return 0;
   1fb9a:	2000      	movs	r0, #0
   1fb9c:	e7b4      	b.n	1fb08 <lcp_rejci+0x1a4>
	...

0001fba0 <lcp_addci>:
static void lcp_addci(fsm *f, u_char *ucp, int *lenp) {
   1fba0:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    ppp_pcb *pcb = f->pcb;
   1fba2:	6800      	ldr	r0, [r0, #0]
    ADDCISHORT(CI_MRU, go->neg_mru && go->mru != PPP_DEFMRU, go->mru);
   1fba4:	2504      	movs	r5, #4
   1fba6:	0004      	movs	r4, r0
   1fba8:	3464      	adds	r4, #100	; 0x64
   1fbaa:	7826      	ldrb	r6, [r4, #0]
   1fbac:	000b      	movs	r3, r1
   1fbae:	422e      	tst	r6, r5
   1fbb0:	d00c      	beq.n	1fbcc <lcp_addci+0x2c>
   1fbb2:	4e3e      	ldr	r6, [pc, #248]	; (1fcac <lcp_addci+0x10c>)
   1fbb4:	8867      	ldrh	r7, [r4, #2]
   1fbb6:	42b7      	cmp	r7, r6
   1fbb8:	d008      	beq.n	1fbcc <lcp_addci+0x2c>
   1fbba:	2301      	movs	r3, #1
   1fbbc:	704d      	strb	r5, [r1, #1]
   1fbbe:	700b      	strb	r3, [r1, #0]
   1fbc0:	8863      	ldrh	r3, [r4, #2]
   1fbc2:	0a1b      	lsrs	r3, r3, #8
   1fbc4:	708b      	strb	r3, [r1, #2]
   1fbc6:	194b      	adds	r3, r1, r5
   1fbc8:	8865      	ldrh	r5, [r4, #2]
   1fbca:	70cd      	strb	r5, [r1, #3]
    ADDCILONG(CI_ASYNCMAP, go->neg_asyncmap && go->asyncmap != 0xFFFFFFFF,
   1fbcc:	7825      	ldrb	r5, [r4, #0]
   1fbce:	072d      	lsls	r5, r5, #28
   1fbd0:	d512      	bpl.n	1fbf8 <lcp_addci+0x58>
   1fbd2:	6e85      	ldr	r5, [r0, #104]	; 0x68
   1fbd4:	3501      	adds	r5, #1
   1fbd6:	d00f      	beq.n	1fbf8 <lcp_addci+0x58>
   1fbd8:	2502      	movs	r5, #2
   1fbda:	701d      	strb	r5, [r3, #0]
   1fbdc:	3504      	adds	r5, #4
   1fbde:	705d      	strb	r5, [r3, #1]
   1fbe0:	6e85      	ldr	r5, [r0, #104]	; 0x68
   1fbe2:	0e2d      	lsrs	r5, r5, #24
   1fbe4:	709d      	strb	r5, [r3, #2]
   1fbe6:	6e85      	ldr	r5, [r0, #104]	; 0x68
   1fbe8:	0c2d      	lsrs	r5, r5, #16
   1fbea:	70dd      	strb	r5, [r3, #3]
   1fbec:	6e85      	ldr	r5, [r0, #104]	; 0x68
   1fbee:	0a2d      	lsrs	r5, r5, #8
   1fbf0:	711d      	strb	r5, [r3, #4]
   1fbf2:	6e85      	ldr	r5, [r0, #104]	; 0x68
   1fbf4:	715d      	strb	r5, [r3, #5]
   1fbf6:	3306      	adds	r3, #6
    ADDCICHAR(CI_CALLBACK, go->neg_cbcp, CBCP_OPT);
   1fbf8:	7825      	ldrb	r5, [r4, #0]
   1fbfa:	2d7f      	cmp	r5, #127	; 0x7f
   1fbfc:	d906      	bls.n	1fc0c <lcp_addci+0x6c>
   1fbfe:	250d      	movs	r5, #13
   1fc00:	701d      	strb	r5, [r3, #0]
   1fc02:	3d0a      	subs	r5, #10
   1fc04:	705d      	strb	r5, [r3, #1]
   1fc06:	3503      	adds	r5, #3
   1fc08:	709d      	strb	r5, [r3, #2]
   1fc0a:	3303      	adds	r3, #3
    ADDCILONG(CI_MAGICNUMBER, go->neg_magicnumber, go->magicnumber);
   1fc0c:	7825      	ldrb	r5, [r4, #0]
   1fc0e:	06ed      	lsls	r5, r5, #27
   1fc10:	d50f      	bpl.n	1fc32 <lcp_addci+0x92>
   1fc12:	2505      	movs	r5, #5
   1fc14:	701d      	strb	r5, [r3, #0]
   1fc16:	3501      	adds	r5, #1
   1fc18:	705d      	strb	r5, [r3, #1]
   1fc1a:	6ec5      	ldr	r5, [r0, #108]	; 0x6c
   1fc1c:	0e2d      	lsrs	r5, r5, #24
   1fc1e:	709d      	strb	r5, [r3, #2]
   1fc20:	6ec5      	ldr	r5, [r0, #108]	; 0x6c
   1fc22:	0c2d      	lsrs	r5, r5, #16
   1fc24:	70dd      	strb	r5, [r3, #3]
   1fc26:	6ec5      	ldr	r5, [r0, #108]	; 0x6c
   1fc28:	0a2d      	lsrs	r5, r5, #8
   1fc2a:	711d      	strb	r5, [r3, #4]
   1fc2c:	6ec5      	ldr	r5, [r0, #108]	; 0x6c
   1fc2e:	715d      	strb	r5, [r3, #5]
   1fc30:	3306      	adds	r3, #6
    ADDCIVOID(CI_PCOMPRESSION, go->neg_pcompression);
   1fc32:	7825      	ldrb	r5, [r4, #0]
   1fc34:	06ad      	lsls	r5, r5, #26
   1fc36:	d504      	bpl.n	1fc42 <lcp_addci+0xa2>
   1fc38:	2507      	movs	r5, #7
   1fc3a:	701d      	strb	r5, [r3, #0]
   1fc3c:	3d05      	subs	r5, #5
   1fc3e:	705d      	strb	r5, [r3, #1]
   1fc40:	195b      	adds	r3, r3, r5
    ADDCIVOID(CI_ACCOMPRESSION, go->neg_accompression);
   1fc42:	7825      	ldrb	r5, [r4, #0]
   1fc44:	066d      	lsls	r5, r5, #25
   1fc46:	d504      	bpl.n	1fc52 <lcp_addci+0xb2>
   1fc48:	2508      	movs	r5, #8
   1fc4a:	701d      	strb	r5, [r3, #0]
   1fc4c:	3d06      	subs	r5, #6
   1fc4e:	705d      	strb	r5, [r3, #1]
   1fc50:	195b      	adds	r3, r3, r5
    ADDCIVOID(CI_SSNHF, go->neg_ssnhf);
   1fc52:	0005      	movs	r5, r0
   1fc54:	3565      	adds	r5, #101	; 0x65
   1fc56:	782e      	ldrb	r6, [r5, #0]
   1fc58:	07f6      	lsls	r6, r6, #31
   1fc5a:	d504      	bpl.n	1fc66 <lcp_addci+0xc6>
   1fc5c:	2612      	movs	r6, #18
   1fc5e:	701e      	strb	r6, [r3, #0]
   1fc60:	3e10      	subs	r6, #16
   1fc62:	705e      	strb	r6, [r3, #1]
   1fc64:	199b      	adds	r3, r3, r6
    ADDCIENDP(CI_EPDISC, go->neg_endpoint, go->endpoint.class_,
   1fc66:	782d      	ldrb	r5, [r5, #0]
   1fc68:	07ad      	lsls	r5, r5, #30
   1fc6a:	d512      	bpl.n	1fc92 <lcp_addci+0xf2>
   1fc6c:	2513      	movs	r5, #19
   1fc6e:	701d      	strb	r5, [r3, #0]
   1fc70:	7ba5      	ldrb	r5, [r4, #14]
   1fc72:	1cde      	adds	r6, r3, #3
   1fc74:	3503      	adds	r5, #3
   1fc76:	705d      	strb	r5, [r3, #1]
   1fc78:	7b64      	ldrb	r4, [r4, #13]
   1fc7a:	0005      	movs	r5, r0
   1fc7c:	3064      	adds	r0, #100	; 0x64
   1fc7e:	709c      	strb	r4, [r3, #2]
   1fc80:	4684      	mov	ip, r0
   1fc82:	0034      	movs	r4, r6
   1fc84:	3573      	adds	r5, #115	; 0x73
   1fc86:	4660      	mov	r0, ip
   1fc88:	7b80      	ldrb	r0, [r0, #14]
   1fc8a:	0023      	movs	r3, r4
   1fc8c:	1ba7      	subs	r7, r4, r6
   1fc8e:	42b8      	cmp	r0, r7
   1fc90:	dc07      	bgt.n	1fca2 <lcp_addci+0x102>
    if (ucp - start_ucp != *lenp) {
   1fc92:	6812      	ldr	r2, [r2, #0]
   1fc94:	1a5b      	subs	r3, r3, r1
   1fc96:	4293      	cmp	r3, r2
   1fc98:	d002      	beq.n	1fca0 <lcp_addci+0x100>
	ppp_error("Bug in lcp_addci: wrong length");
   1fc9a:	4805      	ldr	r0, [pc, #20]	; (1fcb0 <lcp_addci+0x110>)
   1fc9c:	f7fe ff84 	bl	1eba8 <ppp_error>
}
   1fca0:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    ADDCIENDP(CI_EPDISC, go->neg_endpoint, go->endpoint.class_,
   1fca2:	782b      	ldrb	r3, [r5, #0]
   1fca4:	3501      	adds	r5, #1
   1fca6:	7023      	strb	r3, [r4, #0]
   1fca8:	3401      	adds	r4, #1
   1fcaa:	e7ec      	b.n	1fc86 <lcp_addci+0xe6>
   1fcac:	000005dc 	.word	0x000005dc
   1fcb0:	00025e80 	.word	0x00025e80

0001fcb4 <lcp_protrej>:
static void lcp_protrej(ppp_pcb *pcb) {
   1fcb4:	b510      	push	{r4, lr}
   1fcb6:	0004      	movs	r4, r0
    ppp_error("Received Protocol-Reject for LCP!");
   1fcb8:	4803      	ldr	r0, [pc, #12]	; (1fcc8 <lcp_protrej+0x14>)
   1fcba:	f7fe ff75 	bl	1eba8 <ppp_error>
    fsm_protreject(&pcb->lcp_fsm);
   1fcbe:	0020      	movs	r0, r4
   1fcc0:	3024      	adds	r0, #36	; 0x24
   1fcc2:	f001 f82d 	bl	20d20 <fsm_protreject>
}
   1fcc6:	bd10      	pop	{r4, pc}
   1fcc8:	00025fd0 	.word	0x00025fd0

0001fccc <lcp_delayed_up>:
    if (f->flags & DELAYED_UP) {
   1fccc:	7c43      	ldrb	r3, [r0, #17]
static void lcp_delayed_up(void *arg) {
   1fcce:	b510      	push	{r4, lr}
    if (f->flags & DELAYED_UP) {
   1fcd0:	b25a      	sxtb	r2, r3
   1fcd2:	2a00      	cmp	r2, #0
   1fcd4:	da04      	bge.n	1fce0 <lcp_delayed_up+0x14>
	f->flags &= ~DELAYED_UP;
   1fcd6:	227f      	movs	r2, #127	; 0x7f
   1fcd8:	4013      	ands	r3, r2
   1fcda:	7443      	strb	r3, [r0, #17]
	fsm_lowerup(f);
   1fcdc:	f000 feaa 	bl	20a34 <fsm_lowerup>
}
   1fce0:	bd10      	pop	{r4, pc}
	...

0001fce4 <lcp_input>:
static void lcp_input(ppp_pcb *pcb, u_char *p, int len) {
   1fce4:	b570      	push	{r4, r5, r6, lr}
    fsm *f = &pcb->lcp_fsm;
   1fce6:	0004      	movs	r4, r0
    if (f->flags & DELAYED_UP) {
   1fce8:	3035      	adds	r0, #53	; 0x35
   1fcea:	7803      	ldrb	r3, [r0, #0]
static void lcp_input(ppp_pcb *pcb, u_char *p, int len) {
   1fcec:	0016      	movs	r6, r2
    if (f->flags & DELAYED_UP) {
   1fcee:	b25a      	sxtb	r2, r3
static void lcp_input(ppp_pcb *pcb, u_char *p, int len) {
   1fcf0:	000d      	movs	r5, r1
    fsm *f = &pcb->lcp_fsm;
   1fcf2:	3424      	adds	r4, #36	; 0x24
    if (f->flags & DELAYED_UP) {
   1fcf4:	2a00      	cmp	r2, #0
   1fcf6:	da09      	bge.n	1fd0c <lcp_input+0x28>
	f->flags &= ~DELAYED_UP;
   1fcf8:	227f      	movs	r2, #127	; 0x7f
   1fcfa:	4013      	ands	r3, r2
   1fcfc:	7003      	strb	r3, [r0, #0]
	UNTIMEOUT(lcp_delayed_up, f);
   1fcfe:	0021      	movs	r1, r4
   1fd00:	4805      	ldr	r0, [pc, #20]	; (1fd18 <lcp_input+0x34>)
   1fd02:	f002 fe1b 	bl	2293c <sys_untimeout>
	fsm_lowerup(f);
   1fd06:	0020      	movs	r0, r4
   1fd08:	f000 fe94 	bl	20a34 <fsm_lowerup>
    fsm_input(f, p, len);
   1fd0c:	0032      	movs	r2, r6
   1fd0e:	0029      	movs	r1, r5
   1fd10:	0020      	movs	r0, r4
   1fd12:	f001 f82b 	bl	20d6c <fsm_input>
}
   1fd16:	bd70      	pop	{r4, r5, r6, pc}
   1fd18:	0001fccd 	.word	0x0001fccd

0001fd1c <lcp_init>:
static void lcp_init(ppp_pcb *pcb) {
   1fd1c:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
   1fd1e:	0004      	movs	r4, r0
    lcp_options *wo = &pcb->lcp_wantoptions;
   1fd20:	0025      	movs	r5, r4
    f->protocol = PPP_LCP;
   1fd22:	4b1b      	ldr	r3, [pc, #108]	; (1fd90 <lcp_init+0x74>)
    wo->neg_mru = 1;
   1fd24:	2604      	movs	r6, #4
    f->pcb = pcb;
   1fd26:	6260      	str	r0, [r4, #36]	; 0x24
    f->protocol = PPP_LCP;
   1fd28:	8643      	strh	r3, [r0, #50]	; 0x32
    f->callbacks = &lcp_callbacks;
   1fd2a:	4b1a      	ldr	r3, [pc, #104]	; (1fd94 <lcp_init+0x78>)
    lcp_options *wo = &pcb->lcp_wantoptions;
   1fd2c:	3540      	adds	r5, #64	; 0x40
    f->callbacks = &lcp_callbacks;
   1fd2e:	6283      	str	r3, [r0, #40]	; 0x28
    fsm *f = &pcb->lcp_fsm;
   1fd30:	3024      	adds	r0, #36	; 0x24
    fsm_init(f);
   1fd32:	f000 fe77 	bl	20a24 <fsm_init>
    BZERO(wo, sizeof(*wo));
   1fd36:	0028      	movs	r0, r5
   1fd38:	2224      	movs	r2, #36	; 0x24
   1fd3a:	2100      	movs	r1, #0
   1fd3c:	f7e0 fad0 	bl	2e0 <memset>
    wo->neg_magicnumber = 1;
   1fd40:	2208      	movs	r2, #8
    wo->neg_pcompression = 1;
   1fd42:	2110      	movs	r1, #16
    wo->neg_accompression = 1;
   1fd44:	2020      	movs	r0, #32
    wo->neg_mru = 1;
   1fd46:	782b      	ldrb	r3, [r5, #0]
    wo->mru = PPP_DEFMRU;
   1fd48:	4f13      	ldr	r7, [pc, #76]	; (1fd98 <lcp_init+0x7c>)
    wo->neg_mru = 1;
   1fd4a:	4333      	orrs	r3, r6
   1fd4c:	702b      	strb	r3, [r5, #0]
    wo->mru = PPP_DEFMRU;
   1fd4e:	19a3      	adds	r3, r4, r6
   1fd50:	87df      	strh	r7, [r3, #62]	; 0x3e
    wo->neg_asyncmap = 1;
   1fd52:	782b      	ldrb	r3, [r5, #0]
    lcp_options *ao = &pcb->lcp_allowoptions;
   1fd54:	3488      	adds	r4, #136	; 0x88
    wo->neg_magicnumber = 1;
   1fd56:	4313      	orrs	r3, r2
    wo->neg_pcompression = 1;
   1fd58:	430b      	orrs	r3, r1
    wo->neg_accompression = 1;
   1fd5a:	4303      	orrs	r3, r0
   1fd5c:	3238      	adds	r2, #56	; 0x38
   1fd5e:	4313      	orrs	r3, r2
   1fd60:	702b      	strb	r3, [r5, #0]
    BZERO(ao, sizeof(*ao));
   1fd62:	3a1c      	subs	r2, #28
   1fd64:	2100      	movs	r1, #0
   1fd66:	0020      	movs	r0, r4
   1fd68:	f7e0 faba 	bl	2e0 <memset>
    ao->neg_magicnumber = 1;
   1fd6c:	2208      	movs	r2, #8
    ao->neg_pcompression = 1;
   1fd6e:	2110      	movs	r1, #16
    ao->neg_accompression = 1;
   1fd70:	2020      	movs	r0, #32
    ao->neg_mru = 1;
   1fd72:	7823      	ldrb	r3, [r4, #0]
    ao->mru = PPP_MAXMRU;
   1fd74:	8067      	strh	r7, [r4, #2]
    ao->neg_asyncmap = 1;
   1fd76:	431e      	orrs	r6, r3
    ao->neg_endpoint = 1;
   1fd78:	2302      	movs	r3, #2
    ao->neg_magicnumber = 1;
   1fd7a:	4316      	orrs	r6, r2
    ao->neg_pcompression = 1;
   1fd7c:	430e      	orrs	r6, r1
    ao->neg_accompression = 1;
   1fd7e:	4306      	orrs	r6, r0
   1fd80:	3238      	adds	r2, #56	; 0x38
   1fd82:	4316      	orrs	r6, r2
    ao->neg_endpoint = 1;
   1fd84:	7862      	ldrb	r2, [r4, #1]
    ao->neg_accompression = 1;
   1fd86:	7026      	strb	r6, [r4, #0]
    ao->neg_endpoint = 1;
   1fd88:	4313      	orrs	r3, r2
   1fd8a:	7063      	strb	r3, [r4, #1]
}
   1fd8c:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
   1fd8e:	46c0      	nop			; (mov r8, r8)
   1fd90:	ffffc021 	.word	0xffffc021
   1fd94:	00025ea0 	.word	0x00025ea0
   1fd98:	000005dc 	.word	0x000005dc

0001fd9c <lcp_finished>:


/*
 * lcp_finished - LCP has finished with the lower layer.
 */
static void lcp_finished(fsm *f) {
   1fd9c:	b510      	push	{r4, lr}
    ppp_pcb *pcb = f->pcb;
    link_terminated(pcb);
   1fd9e:	6800      	ldr	r0, [r0, #0]
   1fda0:	f7fe ff40 	bl	1ec24 <link_terminated>
}
   1fda4:	bd10      	pop	{r4, pc}

0001fda6 <lcp_starting>:
static void lcp_starting(fsm *f) {
   1fda6:	b510      	push	{r4, lr}
    link_required(pcb);
   1fda8:	6800      	ldr	r0, [r0, #0]
   1fdaa:	f7fe ff39 	bl	1ec20 <link_required>
}
   1fdae:	bd10      	pop	{r4, pc}

0001fdb0 <lcp_down>:
static void lcp_down(fsm *f) {
   1fdb0:	b573      	push	{r0, r1, r4, r5, r6, lr}
 */

static void lcp_echo_lowerdown(ppp_pcb *pcb) {
    fsm *f = &pcb->lcp_fsm;

    if (pcb->lcp_echo_timer_running != 0) {
   1fdb2:	2610      	movs	r6, #16
    ppp_pcb *pcb = f->pcb;
   1fdb4:	6804      	ldr	r4, [r0, #0]
    if (pcb->lcp_echo_timer_running != 0) {
   1fdb6:	1ce5      	adds	r5, r4, #3
   1fdb8:	7feb      	ldrb	r3, [r5, #31]
   1fdba:	4233      	tst	r3, r6
   1fdbc:	d007      	beq.n	1fdce <lcp_down+0x1e>
    fsm *f = &pcb->lcp_fsm;
   1fdbe:	0021      	movs	r1, r4
        UNTIMEOUT (LcpEchoTimeout, f);
   1fdc0:	4814      	ldr	r0, [pc, #80]	; (1fe14 <lcp_down+0x64>)
    fsm *f = &pcb->lcp_fsm;
   1fdc2:	3124      	adds	r1, #36	; 0x24
        UNTIMEOUT (LcpEchoTimeout, f);
   1fdc4:	f002 fdba 	bl	2293c <sys_untimeout>
        pcb->lcp_echo_timer_running = 0;
   1fdc8:	7feb      	ldrb	r3, [r5, #31]
   1fdca:	43b3      	bics	r3, r6
   1fdcc:	77eb      	strb	r3, [r5, #31]
    link_down(pcb);
   1fdce:	0020      	movs	r0, r4
   1fdd0:	f7fe ff64 	bl	1ec9c <link_down>
    ppp_send_config(pcb, PPP_MRU, 0xffffffff, 0, 0);
   1fdd4:	2300      	movs	r3, #0
   1fdd6:	2201      	movs	r2, #1
   1fdd8:	9300      	str	r3, [sp, #0]
   1fdda:	4252      	negs	r2, r2
   1fddc:	490e      	ldr	r1, [pc, #56]	; (1fe18 <lcp_down+0x68>)
   1fdde:	0020      	movs	r0, r4
   1fde0:	f7fe f907 	bl	1dff2 <ppp_send_config>
		    (go->neg_asyncmap? go->asyncmap: 0xffffffff),
   1fde4:	0023      	movs	r3, r4
   1fde6:	3364      	adds	r3, #100	; 0x64
   1fde8:	781a      	ldrb	r2, [r3, #0]
    ppp_recv_config(pcb, PPP_MRU,
   1fdea:	0712      	lsls	r2, r2, #28
   1fdec:	d50e      	bpl.n	1fe0c <lcp_down+0x5c>
   1fdee:	6ea2      	ldr	r2, [r4, #104]	; 0x68
		    go->neg_pcompression, go->neg_accompression);
   1fdf0:	7819      	ldrb	r1, [r3, #0]
    ppp_recv_config(pcb, PPP_MRU,
   1fdf2:	4d09      	ldr	r5, [pc, #36]	; (1fe18 <lcp_down+0x68>)
		    go->neg_pcompression, go->neg_accompression);
   1fdf4:	068b      	lsls	r3, r1, #26
   1fdf6:	0649      	lsls	r1, r1, #25
    ppp_recv_config(pcb, PPP_MRU,
   1fdf8:	0fc9      	lsrs	r1, r1, #31
   1fdfa:	9100      	str	r1, [sp, #0]
   1fdfc:	0fdb      	lsrs	r3, r3, #31
   1fdfe:	0029      	movs	r1, r5
   1fe00:	0020      	movs	r0, r4
    pcb->peer_mru = PPP_MRU;
   1fe02:	34d0      	adds	r4, #208	; 0xd0
    ppp_recv_config(pcb, PPP_MRU,
   1fe04:	f7fe f900 	bl	1e008 <ppp_recv_config>
    pcb->peer_mru = PPP_MRU;
   1fe08:	8025      	strh	r5, [r4, #0]
}
   1fe0a:	bd73      	pop	{r0, r1, r4, r5, r6, pc}
    ppp_recv_config(pcb, PPP_MRU,
   1fe0c:	2201      	movs	r2, #1
   1fe0e:	4252      	negs	r2, r2
   1fe10:	e7ee      	b.n	1fdf0 <lcp_down+0x40>
   1fe12:	46c0      	nop			; (mov r8, r8)
   1fe14:	000202e5 	.word	0x000202e5
   1fe18:	000005dc 	.word	0x000005dc

0001fe1c <lcp_lowerup>:
    if (ppp_send_config(pcb, PPP_MRU, 0xffffffff, 0, 0) < 0
   1fe1c:	2300      	movs	r3, #0
   1fe1e:	2201      	movs	r2, #1
void lcp_lowerup(ppp_pcb *pcb) {
   1fe20:	b573      	push	{r0, r1, r4, r5, r6, lr}
    if (ppp_send_config(pcb, PPP_MRU, 0xffffffff, 0, 0) < 0
   1fe22:	4d1d      	ldr	r5, [pc, #116]	; (1fe98 <lcp_lowerup+0x7c>)
   1fe24:	9300      	str	r3, [sp, #0]
   1fe26:	4252      	negs	r2, r2
   1fe28:	0029      	movs	r1, r5
void lcp_lowerup(ppp_pcb *pcb) {
   1fe2a:	0004      	movs	r4, r0
    if (ppp_send_config(pcb, PPP_MRU, 0xffffffff, 0, 0) < 0
   1fe2c:	f7fe f8e1 	bl	1dff2 <ppp_send_config>
   1fe30:	2800      	cmp	r0, #0
   1fe32:	db2b      	blt.n	1fe8c <lcp_lowerup+0x70>
			   wo->neg_pcompression, wo->neg_accompression) < 0)
   1fe34:	0023      	movs	r3, r4
	|| ppp_recv_config(pcb, PPP_MRU, (pcb->settings.lax_recv? 0: 0xffffffff),
   1fe36:	2201      	movs	r2, #1
			   wo->neg_pcompression, wo->neg_accompression) < 0)
   1fe38:	3340      	adds	r3, #64	; 0x40
   1fe3a:	7819      	ldrb	r1, [r3, #0]
	|| ppp_recv_config(pcb, PPP_MRU, (pcb->settings.lax_recv? 0: 0xffffffff),
   1fe3c:	7820      	ldrb	r0, [r4, #0]
			   wo->neg_pcompression, wo->neg_accompression) < 0)
   1fe3e:	068b      	lsls	r3, r1, #26
	|| ppp_recv_config(pcb, PPP_MRU, (pcb->settings.lax_recv? 0: 0xffffffff),
   1fe40:	0880      	lsrs	r0, r0, #2
			   wo->neg_pcompression, wo->neg_accompression) < 0)
   1fe42:	0649      	lsls	r1, r1, #25
	|| ppp_recv_config(pcb, PPP_MRU, (pcb->settings.lax_recv? 0: 0xffffffff),
   1fe44:	4382      	bics	r2, r0
   1fe46:	0fc9      	lsrs	r1, r1, #31
   1fe48:	9100      	str	r1, [sp, #0]
   1fe4a:	0fdb      	lsrs	r3, r3, #31
   1fe4c:	4252      	negs	r2, r2
   1fe4e:	0029      	movs	r1, r5
   1fe50:	0020      	movs	r0, r4
   1fe52:	f7fe f8d9 	bl	1e008 <ppp_recv_config>
   1fe56:	2800      	cmp	r0, #0
   1fe58:	db18      	blt.n	1fe8c <lcp_lowerup+0x70>
    pcb->peer_mru = PPP_MRU;
   1fe5a:	0023      	movs	r3, r4
    fsm *f = &pcb->lcp_fsm;
   1fe5c:	0026      	movs	r6, r4
    pcb->peer_mru = PPP_MRU;
   1fe5e:	33d0      	adds	r3, #208	; 0xd0
   1fe60:	801d      	strh	r5, [r3, #0]
    if (pcb->settings.listen_time != 0) {
   1fe62:	8863      	ldrh	r3, [r4, #2]
    fsm *f = &pcb->lcp_fsm;
   1fe64:	3624      	adds	r6, #36	; 0x24
    if (pcb->settings.listen_time != 0) {
   1fe66:	2b00      	cmp	r3, #0
   1fe68:	d011      	beq.n	1fe8e <lcp_lowerup+0x72>
	f->flags |= DELAYED_UP;
   1fe6a:	0022      	movs	r2, r4
   1fe6c:	2380      	movs	r3, #128	; 0x80
   1fe6e:	3235      	adds	r2, #53	; 0x35
   1fe70:	7811      	ldrb	r1, [r2, #0]
	TIMEOUTMS(lcp_delayed_up, f, pcb->settings.listen_time);
   1fe72:	4d0a      	ldr	r5, [pc, #40]	; (1fe9c <lcp_lowerup+0x80>)
	f->flags |= DELAYED_UP;
   1fe74:	425b      	negs	r3, r3
   1fe76:	430b      	orrs	r3, r1
   1fe78:	7013      	strb	r3, [r2, #0]
	TIMEOUTMS(lcp_delayed_up, f, pcb->settings.listen_time);
   1fe7a:	0031      	movs	r1, r6
   1fe7c:	0028      	movs	r0, r5
   1fe7e:	f002 fd5d 	bl	2293c <sys_untimeout>
   1fe82:	8860      	ldrh	r0, [r4, #2]
   1fe84:	0032      	movs	r2, r6
   1fe86:	0029      	movs	r1, r5
   1fe88:	f002 fcf6 	bl	22878 <sys_timeout>
}
   1fe8c:	bd73      	pop	{r0, r1, r4, r5, r6, pc}
	fsm_lowerup(f);
   1fe8e:	0030      	movs	r0, r6
   1fe90:	f000 fdd0 	bl	20a34 <fsm_lowerup>
   1fe94:	e7fa      	b.n	1fe8c <lcp_lowerup+0x70>
   1fe96:	46c0      	nop			; (mov r8, r8)
   1fe98:	000005dc 	.word	0x000005dc
   1fe9c:	0001fccd 	.word	0x0001fccd

0001fea0 <lcp_resetci>:
static void lcp_resetci(fsm *f) {
   1fea0:	b570      	push	{r4, r5, r6, lr}
    ppp_pcb *pcb = f->pcb;
   1fea2:	6804      	ldr	r4, [r0, #0]
    wo->magicnumber = magic();
   1fea4:	f000 fd3a 	bl	2091c <magic>
    wo->numloops = 0;
   1fea8:	0023      	movs	r3, r4
   1feaa:	2200      	movs	r2, #0
   1feac:	3340      	adds	r3, #64	; 0x40
    wo->magicnumber = magic();
   1feae:	64a0      	str	r0, [r4, #72]	; 0x48
    wo->numloops = 0;
   1feb0:	731a      	strb	r2, [r3, #12]
    *go = *wo;
   1feb2:	0022      	movs	r2, r4
   1feb4:	3264      	adds	r2, #100	; 0x64
   1feb6:	cb23      	ldmia	r3!, {r0, r1, r5}
   1feb8:	c223      	stmia	r2!, {r0, r1, r5}
   1feba:	cb23      	ldmia	r3!, {r0, r1, r5}
   1febc:	c223      	stmia	r2!, {r0, r1, r5}
   1febe:	cb23      	ldmia	r3!, {r0, r1, r5}
   1fec0:	c223      	stmia	r2!, {r0, r1, r5}
	go->neg_endpoint = 0;
   1fec2:	2101      	movs	r1, #1
	go->neg_ssnhf = 0;
   1fec4:	3a23      	subs	r2, #35	; 0x23
   1fec6:	7813      	ldrb	r3, [r2, #0]
	go->neg_endpoint = 0;
   1fec8:	438b      	bics	r3, r1
   1feca:	1849      	adds	r1, r1, r1
   1fecc:	438b      	bics	r3, r1
   1fece:	7013      	strb	r3, [r2, #0]
    if (pcb->settings.noendpoint)
   1fed0:	7823      	ldrb	r3, [r4, #0]
   1fed2:	071b      	lsls	r3, r3, #28
   1fed4:	d503      	bpl.n	1fede <lcp_resetci+0x3e>
	ao->neg_endpoint = 0;
   1fed6:	3223      	adds	r2, #35	; 0x23
   1fed8:	7853      	ldrb	r3, [r2, #1]
   1feda:	438b      	bics	r3, r1
   1fedc:	7053      	strb	r3, [r2, #1]
    pcb->peer_mru = PPP_MRU;
   1fede:	4b02      	ldr	r3, [pc, #8]	; (1fee8 <lcp_resetci+0x48>)
   1fee0:	34d0      	adds	r4, #208	; 0xd0
   1fee2:	8023      	strh	r3, [r4, #0]
}
   1fee4:	bd70      	pop	{r4, r5, r6, pc}
   1fee6:	46c0      	nop			; (mov r8, r8)
   1fee8:	000005dc 	.word	0x000005dc

0001feec <lcp_reqci>:
static int lcp_reqci(fsm *f, u_char *inp, int *lenp, int reject_if_disagree) {
   1feec:	b5f0      	push	{r4, r5, r6, r7, lr}
    ppp_pcb *pcb = f->pcb;
   1feee:	6807      	ldr	r7, [r0, #0]
static int lcp_reqci(fsm *f, u_char *inp, int *lenp, int reject_if_disagree) {
   1fef0:	b08b      	sub	sp, #44	; 0x2c
    lcp_options *ho = &pcb->lcp_hisoptions;
   1fef2:	0038      	movs	r0, r7
static int lcp_reqci(fsm *f, u_char *inp, int *lenp, int reject_if_disagree) {
   1fef4:	9309      	str	r3, [sp, #36]	; 0x24
    int l = *lenp;		/* Length left */
   1fef6:	6813      	ldr	r3, [r2, #0]
static int lcp_reqci(fsm *f, u_char *inp, int *lenp, int reject_if_disagree) {
   1fef8:	9106      	str	r1, [sp, #24]
   1fefa:	9208      	str	r2, [sp, #32]
    BZERO(ho, sizeof(*ho));
   1fefc:	2100      	movs	r1, #0
   1fefe:	2224      	movs	r2, #36	; 0x24
    lcp_options *ho = &pcb->lcp_hisoptions;
   1ff00:	30ac      	adds	r0, #172	; 0xac
    int l = *lenp;		/* Length left */
   1ff02:	9301      	str	r3, [sp, #4]
    BZERO(ho, sizeof(*ho));
   1ff04:	f7e0 f9ec 	bl	2e0 <memset>
    nakp = pbuf_alloc(PBUF_RAW, (u16_t)(PPP_CTRL_PBUF_MAX_SIZE), PPP_CTRL_PBUF_TYPE);
   1ff08:	2203      	movs	r2, #3
   1ff0a:	49a0      	ldr	r1, [pc, #640]	; (2018c <lcp_reqci+0x2a0>)
   1ff0c:	2004      	movs	r0, #4
   1ff0e:	f002 fae7 	bl	224e0 <pbuf_alloc>
   1ff12:	9002      	str	r0, [sp, #8]
        return 0;
   1ff14:	9003      	str	r0, [sp, #12]
    if(NULL == nakp)
   1ff16:	2800      	cmp	r0, #0
   1ff18:	d007      	beq.n	1ff2a <lcp_reqci+0x3e>
    if(nakp->tot_len != nakp->len) {
   1ff1a:	8902      	ldrh	r2, [r0, #8]
   1ff1c:	8943      	ldrh	r3, [r0, #10]
   1ff1e:	429a      	cmp	r2, r3
   1ff20:	d006      	beq.n	1ff30 <lcp_reqci+0x44>
        pbuf_free(nakp);
   1ff22:	f002 fb17 	bl	22554 <pbuf_free>
        return 0;
   1ff26:	2300      	movs	r3, #0
   1ff28:	9303      	str	r3, [sp, #12]
}
   1ff2a:	9803      	ldr	r0, [sp, #12]
   1ff2c:	b00b      	add	sp, #44	; 0x2c
   1ff2e:	bdf0      	pop	{r4, r5, r6, r7, pc}
    nakoutp = (u_char*)nakp->payload;
   1ff30:	9b02      	ldr	r3, [sp, #8]
   1ff32:	685d      	ldr	r5, [r3, #4]
    rejp = inp;
   1ff34:	9b06      	ldr	r3, [sp, #24]
   1ff36:	9305      	str	r3, [sp, #20]
    next = inp;
   1ff38:	001c      	movs	r4, r3
    int rc = CONFACK;		/* Final packet return code */
   1ff3a:	2302      	movs	r3, #2
   1ff3c:	9303      	str	r3, [sp, #12]
    while (l) {
   1ff3e:	9b01      	ldr	r3, [sp, #4]
   1ff40:	2b00      	cmp	r3, #0
   1ff42:	d10b      	bne.n	1ff5c <lcp_reqci+0x70>
    switch (rc) {
   1ff44:	9b03      	ldr	r3, [sp, #12]
   1ff46:	2b03      	cmp	r3, #3
   1ff48:	d100      	bne.n	1ff4c <lcp_reqci+0x60>
   1ff4a:	e105      	b.n	20158 <lcp_reqci+0x26c>
   1ff4c:	2b04      	cmp	r3, #4
   1ff4e:	d100      	bne.n	1ff52 <lcp_reqci+0x66>
   1ff50:	e112      	b.n	20178 <lcp_reqci+0x28c>
	*lenp = next - inp;
   1ff52:	9b06      	ldr	r3, [sp, #24]
   1ff54:	1ae4      	subs	r4, r4, r3
	*lenp = rejp - inp;
   1ff56:	9b08      	ldr	r3, [sp, #32]
   1ff58:	601c      	str	r4, [r3, #0]
	break;
   1ff5a:	e109      	b.n	20170 <lcp_reqci+0x284>
	if (l < 2 ||			/* Not enough data for CI header or */
   1ff5c:	9b01      	ldr	r3, [sp, #4]
   1ff5e:	2b01      	cmp	r3, #1
   1ff60:	dc00      	bgt.n	1ff64 <lcp_reqci+0x78>
   1ff62:	e10d      	b.n	20180 <lcp_reqci+0x294>
	    p[1] < 2 ||			/*  CI length too small or */
   1ff64:	7866      	ldrb	r6, [r4, #1]
	if (l < 2 ||			/* Not enough data for CI header or */
   1ff66:	2e01      	cmp	r6, #1
   1ff68:	d800      	bhi.n	1ff6c <lcp_reqci+0x80>
   1ff6a:	e109      	b.n	20180 <lcp_reqci+0x294>
	    p[1] > l) {			/*  CI length too big? */
   1ff6c:	9604      	str	r6, [sp, #16]
	    p[1] < 2 ||			/*  CI length too small or */
   1ff6e:	429e      	cmp	r6, r3
   1ff70:	dd00      	ble.n	1ff74 <lcp_reqci+0x88>
   1ff72:	e105      	b.n	20180 <lcp_reqci+0x294>
	switch (citype) {		/* Check CI type */
   1ff74:	7820      	ldrb	r0, [r4, #0]
	l -= cilen;			/* Adjust remaining length */
   1ff76:	1b9b      	subs	r3, r3, r6
   1ff78:	9301      	str	r3, [sp, #4]
	switch (citype) {		/* Check CI type */
   1ff7a:	3801      	subs	r0, #1
	next += cilen;			/* Step to next CI */
   1ff7c:	19a3      	adds	r3, r4, r6
   1ff7e:	9307      	str	r3, [sp, #28]
	switch (citype) {		/* Check CI type */
   1ff80:	2812      	cmp	r0, #18
   1ff82:	d864      	bhi.n	2004e <lcp_reqci+0x162>
   1ff84:	f7e0 fa0e 	bl	3a4 <__gnu_thumb1_case_uqi>
   1ff88:	63602e0a 	.word	0x63602e0a
   1ff8c:	bcae6372 	.word	0xbcae6372
   1ff90:	63636363 	.word	0x63636363
   1ff94:	63636363 	.word	0x63636363
   1ff98:	c163      	.short	0xc163
   1ff9a:	cf          	.byte	0xcf
   1ff9b:	00          	.byte	0x00
	    if (!ao->neg_mru ||		/* Allow option? */
   1ff9c:	003b      	movs	r3, r7
   1ff9e:	2204      	movs	r2, #4
   1ffa0:	3388      	adds	r3, #136	; 0x88
   1ffa2:	781b      	ldrb	r3, [r3, #0]
   1ffa4:	4213      	tst	r3, r2
   1ffa6:	d052      	beq.n	2004e <lcp_reqci+0x162>
   1ffa8:	4296      	cmp	r6, r2
   1ffaa:	d150      	bne.n	2004e <lcp_reqci+0x162>
   1ffac:	78e3      	ldrb	r3, [r4, #3]
   1ffae:	78a2      	ldrb	r2, [r4, #2]
   1ffb0:	021b      	lsls	r3, r3, #8
   1ffb2:	4313      	orrs	r3, r2
   1ffb4:	ba5b      	rev16	r3, r3
   1ffb6:	b29a      	uxth	r2, r3
	    if (cishort < PPP_MINMRU) {
   1ffb8:	2a7f      	cmp	r2, #127	; 0x7f
   1ffba:	d80b      	bhi.n	1ffd4 <lcp_reqci+0xe8>
		PUTCHAR(CI_MRU, nakoutp);
   1ffbc:	2301      	movs	r3, #1
   1ffbe:	702b      	strb	r3, [r5, #0]
		PUTSHORT(PPP_MINMRU, nakoutp);	/* Give him a hint */
   1ffc0:	2300      	movs	r3, #0
   1ffc2:	70ab      	strb	r3, [r5, #2]
   1ffc4:	3380      	adds	r3, #128	; 0x80
		PUTCHAR(CILEN_SHORT, nakoutp);
   1ffc6:	706e      	strb	r6, [r5, #1]
		PUTSHORT(PPP_MINMRU, nakoutp);	/* Give him a hint */
   1ffc8:	70eb      	strb	r3, [r5, #3]
   1ffca:	3504      	adds	r5, #4
	    if (reject_if_disagree	/* Getting fed up with sending NAKs? */
   1ffcc:	9b09      	ldr	r3, [sp, #36]	; 0x24
   1ffce:	2b00      	cmp	r3, #0
   1ffd0:	d13d      	bne.n	2004e <lcp_reqci+0x162>
   1ffd2:	e079      	b.n	200c8 <lcp_reqci+0x1dc>
	    ho->neg_mru = 1;		/* Remember he sent MRU */
   1ffd4:	0039      	movs	r1, r7
   1ffd6:	31ac      	adds	r1, #172	; 0xac
   1ffd8:	780a      	ldrb	r2, [r1, #0]
	    ho->mru = cishort;		/* And remember value */
   1ffda:	804b      	strh	r3, [r1, #2]
	    ho->neg_mru = 1;		/* Remember he sent MRU */
   1ffdc:	4316      	orrs	r6, r2
   1ffde:	700e      	strb	r6, [r1, #0]
		rc = CONFNAK;
   1ffe0:	9c07      	ldr	r4, [sp, #28]
   1ffe2:	e7ac      	b.n	1ff3e <lcp_reqci+0x52>
	    if (!ao->neg_asyncmap ||
   1ffe4:	003a      	movs	r2, r7
   1ffe6:	2108      	movs	r1, #8
   1ffe8:	3288      	adds	r2, #136	; 0x88
   1ffea:	7813      	ldrb	r3, [r2, #0]
   1ffec:	420b      	tst	r3, r1
   1ffee:	d02e      	beq.n	2004e <lcp_reqci+0x162>
   1fff0:	2e06      	cmp	r6, #6
   1fff2:	d12c      	bne.n	2004e <lcp_reqci+0x162>
   1fff4:	78e3      	ldrb	r3, [r4, #3]
   1fff6:	78a0      	ldrb	r0, [r4, #2]
   1fff8:	408b      	lsls	r3, r1
   1fffa:	4303      	orrs	r3, r0
   1fffc:	ba5b      	rev16	r3, r3
   1fffe:	b29b      	uxth	r3, r3
	    GETLONG(cilong, p);
   20000:	408b      	lsls	r3, r1
   20002:	7920      	ldrb	r0, [r4, #4]
   20004:	4303      	orrs	r3, r0
   20006:	408b      	lsls	r3, r1
   20008:	7960      	ldrb	r0, [r4, #5]
   2000a:	4303      	orrs	r3, r0
	    if ((ao->asyncmap & ~cilong) != 0) {
   2000c:	6850      	ldr	r0, [r2, #4]
   2000e:	4398      	bics	r0, r3
   20010:	d013      	beq.n	2003a <lcp_reqci+0x14e>
		PUTCHAR(CI_ASYNCMAP, nakoutp);
   20012:	3906      	subs	r1, #6
   20014:	7029      	strb	r1, [r5, #0]
		PUTCHAR(CILEN_LONG, nakoutp);
   20016:	706e      	strb	r6, [r5, #1]
		PUTLONG(ao->asyncmap | cilong, nakoutp);
   20018:	6851      	ldr	r1, [r2, #4]
   2001a:	4319      	orrs	r1, r3
   2001c:	0e09      	lsrs	r1, r1, #24
   2001e:	70a9      	strb	r1, [r5, #2]
   20020:	6851      	ldr	r1, [r2, #4]
   20022:	4319      	orrs	r1, r3
   20024:	0c09      	lsrs	r1, r1, #16
   20026:	70e9      	strb	r1, [r5, #3]
   20028:	6851      	ldr	r1, [r2, #4]
   2002a:	4319      	orrs	r1, r3
   2002c:	0a09      	lsrs	r1, r1, #8
   2002e:	7129      	strb	r1, [r5, #4]
   20030:	6852      	ldr	r2, [r2, #4]
   20032:	4313      	orrs	r3, r2
   20034:	716b      	strb	r3, [r5, #5]
   20036:	3506      	adds	r5, #6
		break;
   20038:	e7c8      	b.n	1ffcc <lcp_reqci+0xe0>
	    ho->neg_asyncmap = 1;
   2003a:	003a      	movs	r2, r7
   2003c:	32ac      	adds	r2, #172	; 0xac
   2003e:	7810      	ldrb	r0, [r2, #0]
	    ho->asyncmap = cilong;
   20040:	6053      	str	r3, [r2, #4]
	    ho->neg_asyncmap = 1;
   20042:	4301      	orrs	r1, r0
   20044:	7011      	strb	r1, [r2, #0]
	    break;
   20046:	e7cb      	b.n	1ffe0 <lcp_reqci+0xf4>
		ppp_dbglog("No auth is possible");
   20048:	4851      	ldr	r0, [pc, #324]	; (20190 <lcp_reqci+0x2a4>)
   2004a:	f7fe fddd 	bl	1ec08 <ppp_dbglog>
	    if (cip != rejp)		/* Need to move rejected CI? */
   2004e:	9b05      	ldr	r3, [sp, #20]
   20050:	429c      	cmp	r4, r3
   20052:	d004      	beq.n	2005e <lcp_reqci+0x172>
		MEMCPY(rejp, cip, cilen); /* Move it */
   20054:	9a04      	ldr	r2, [sp, #16]
   20056:	0021      	movs	r1, r4
   20058:	0018      	movs	r0, r3
   2005a:	f7e0 f8c9 	bl	1f0 <memcpy>
	    INCPTR(cilen, rejp);	/* Update output pointer */
   2005e:	9a04      	ldr	r2, [sp, #16]
   20060:	9b05      	ldr	r3, [sp, #20]
   20062:	4694      	mov	ip, r2
   20064:	4463      	add	r3, ip
   20066:	9305      	str	r3, [sp, #20]
	    rc = CONFREJ;
   20068:	2304      	movs	r3, #4
   2006a:	e031      	b.n	200d0 <lcp_reqci+0x1e4>
	    if (!(ao->neg_magicnumber || go->neg_magicnumber) ||
   2006c:	003b      	movs	r3, r7
   2006e:	3388      	adds	r3, #136	; 0x88
   20070:	781a      	ldrb	r2, [r3, #0]
   20072:	2310      	movs	r3, #16
   20074:	421a      	tst	r2, r3
   20076:	d104      	bne.n	20082 <lcp_reqci+0x196>
   20078:	003a      	movs	r2, r7
   2007a:	3264      	adds	r2, #100	; 0x64
   2007c:	7812      	ldrb	r2, [r2, #0]
   2007e:	421a      	tst	r2, r3
   20080:	d0e5      	beq.n	2004e <lcp_reqci+0x162>
   20082:	2e06      	cmp	r6, #6
   20084:	d1e3      	bne.n	2004e <lcp_reqci+0x162>
   20086:	78e3      	ldrb	r3, [r4, #3]
   20088:	78a2      	ldrb	r2, [r4, #2]
   2008a:	021b      	lsls	r3, r3, #8
   2008c:	4313      	orrs	r3, r2
   2008e:	ba5b      	rev16	r3, r3
	    GETLONG(cilong, p);
   20090:	7922      	ldrb	r2, [r4, #4]
   20092:	b29b      	uxth	r3, r3
   20094:	021b      	lsls	r3, r3, #8
   20096:	4313      	orrs	r3, r2
   20098:	7962      	ldrb	r2, [r4, #5]
   2009a:	021b      	lsls	r3, r3, #8
   2009c:	4313      	orrs	r3, r2
	    if (go->neg_magicnumber &&
   2009e:	003a      	movs	r2, r7
   200a0:	3264      	adds	r2, #100	; 0x64
   200a2:	7812      	ldrb	r2, [r2, #0]
   200a4:	06d2      	lsls	r2, r2, #27
   200a6:	d515      	bpl.n	200d4 <lcp_reqci+0x1e8>
   200a8:	6efa      	ldr	r2, [r7, #108]	; 0x6c
   200aa:	429a      	cmp	r2, r3
   200ac:	d112      	bne.n	200d4 <lcp_reqci+0x1e8>
		cilong = magic();	/* Don't put magic() inside macro! */
   200ae:	f000 fc35 	bl	2091c <magic>
		PUTCHAR(CI_MAGICNUMBER, nakoutp);
   200b2:	2305      	movs	r3, #5
   200b4:	702b      	strb	r3, [r5, #0]
		PUTLONG(cilong, nakoutp);
   200b6:	0e03      	lsrs	r3, r0, #24
   200b8:	70ab      	strb	r3, [r5, #2]
   200ba:	0c03      	lsrs	r3, r0, #16
   200bc:	70eb      	strb	r3, [r5, #3]
   200be:	0a03      	lsrs	r3, r0, #8
		PUTCHAR(CILEN_LONG, nakoutp);
   200c0:	706e      	strb	r6, [r5, #1]
		PUTLONG(cilong, nakoutp);
   200c2:	712b      	strb	r3, [r5, #4]
   200c4:	7168      	strb	r0, [r5, #5]
   200c6:	3506      	adds	r5, #6
		if (rc == CONFREJ)	/* Rejecting prior CI? */
   200c8:	9b03      	ldr	r3, [sp, #12]
   200ca:	2b04      	cmp	r3, #4
   200cc:	d088      	beq.n	1ffe0 <lcp_reqci+0xf4>
		rc = CONFNAK;
   200ce:	2303      	movs	r3, #3
	    rc = CONFREJ;
   200d0:	9303      	str	r3, [sp, #12]
   200d2:	e785      	b.n	1ffe0 <lcp_reqci+0xf4>
	    ho->neg_magicnumber = 1;
   200d4:	003a      	movs	r2, r7
   200d6:	2110      	movs	r1, #16
   200d8:	32ac      	adds	r2, #172	; 0xac
   200da:	7810      	ldrb	r0, [r2, #0]
	    ho->magicnumber = cilong;
   200dc:	6093      	str	r3, [r2, #8]
	    ho->neg_magicnumber = 1;
   200de:	4301      	orrs	r1, r0
   200e0:	7011      	strb	r1, [r2, #0]
	    break;
   200e2:	e77d      	b.n	1ffe0 <lcp_reqci+0xf4>
	    if (!ao->neg_pcompression ||
   200e4:	003b      	movs	r3, r7
   200e6:	3388      	adds	r3, #136	; 0x88
   200e8:	781a      	ldrb	r2, [r3, #0]
   200ea:	2320      	movs	r3, #32
	    if (!ao->neg_accompression ||
   200ec:	421a      	tst	r2, r3
   200ee:	d0ae      	beq.n	2004e <lcp_reqci+0x162>
   200f0:	2e02      	cmp	r6, #2
   200f2:	d1ac      	bne.n	2004e <lcp_reqci+0x162>
	    ho->neg_accompression = 1;
   200f4:	003a      	movs	r2, r7
   200f6:	32ac      	adds	r2, #172	; 0xac
   200f8:	7811      	ldrb	r1, [r2, #0]
   200fa:	430b      	orrs	r3, r1
   200fc:	7013      	strb	r3, [r2, #0]
	    break;
   200fe:	e76f      	b.n	1ffe0 <lcp_reqci+0xf4>
	    if (!ao->neg_accompression ||
   20100:	003b      	movs	r3, r7
   20102:	3388      	adds	r3, #136	; 0x88
   20104:	781a      	ldrb	r2, [r3, #0]
   20106:	2340      	movs	r3, #64	; 0x40
   20108:	e7f0      	b.n	200ec <lcp_reqci+0x200>
	    if (!ao->neg_ssnhf
   2010a:	003b      	movs	r3, r7
   2010c:	3388      	adds	r3, #136	; 0x88
   2010e:	785a      	ldrb	r2, [r3, #1]
   20110:	2301      	movs	r3, #1
   20112:	421a      	tst	r2, r3
   20114:	d09b      	beq.n	2004e <lcp_reqci+0x162>
		|| cilen != CILEN_VOID) {
   20116:	2e02      	cmp	r6, #2
   20118:	d199      	bne.n	2004e <lcp_reqci+0x162>
	    ho->neg_ssnhf = 1;
   2011a:	003a      	movs	r2, r7
   2011c:	32ac      	adds	r2, #172	; 0xac
   2011e:	7851      	ldrb	r1, [r2, #1]
   20120:	430b      	orrs	r3, r1
   20122:	7053      	strb	r3, [r2, #1]
	    break;
   20124:	e75c      	b.n	1ffe0 <lcp_reqci+0xf4>
	    if (!ao->neg_endpoint ||
   20126:	003b      	movs	r3, r7
   20128:	2202      	movs	r2, #2
   2012a:	3388      	adds	r3, #136	; 0x88
   2012c:	785b      	ldrb	r3, [r3, #1]
   2012e:	4213      	tst	r3, r2
   20130:	d08d      	beq.n	2004e <lcp_reqci+0x162>
   20132:	4296      	cmp	r6, r2
   20134:	d08b      	beq.n	2004e <lcp_reqci+0x162>
		cilen < CILEN_CHAR ||
   20136:	2e17      	cmp	r6, #23
   20138:	dc89      	bgt.n	2004e <lcp_reqci+0x162>
	    ho->neg_endpoint = 1;
   2013a:	003b      	movs	r3, r7
   2013c:	33ac      	adds	r3, #172	; 0xac
   2013e:	7858      	ldrb	r0, [r3, #1]
	    GETCHAR(cichar, p);
   20140:	78a1      	ldrb	r1, [r4, #2]
	    ho->neg_endpoint = 1;
   20142:	4302      	orrs	r2, r0
	    MEMCPY(ho->endpoint.value, p, cilen);
   20144:	0038      	movs	r0, r7
	    ho->neg_endpoint = 1;
   20146:	705a      	strb	r2, [r3, #1]
	    ho->endpoint.length = cilen;
   20148:	1ef2      	subs	r2, r6, #3
	    ho->endpoint.class_ = cichar;
   2014a:	7359      	strb	r1, [r3, #13]
	    ho->endpoint.length = cilen;
   2014c:	739a      	strb	r2, [r3, #14]
	    MEMCPY(ho->endpoint.value, p, cilen);
   2014e:	1ce1      	adds	r1, r4, #3
   20150:	30bb      	adds	r0, #187	; 0xbb
   20152:	f7e0 f84d 	bl	1f0 <memcpy>
	    break;
   20156:	e743      	b.n	1ffe0 <lcp_reqci+0xf4>
	*lenp = nakoutp - (u_char*)nakp->payload;
   20158:	9b02      	ldr	r3, [sp, #8]
	MEMCPY(inp, nakp->payload, *lenp);
   2015a:	9806      	ldr	r0, [sp, #24]
	*lenp = nakoutp - (u_char*)nakp->payload;
   2015c:	685b      	ldr	r3, [r3, #4]
   2015e:	1aea      	subs	r2, r5, r3
   20160:	9b08      	ldr	r3, [sp, #32]
   20162:	601a      	str	r2, [r3, #0]
	MEMCPY(inp, nakp->payload, *lenp);
   20164:	9b02      	ldr	r3, [sp, #8]
   20166:	685b      	ldr	r3, [r3, #4]
   20168:	0019      	movs	r1, r3
   2016a:	9301      	str	r3, [sp, #4]
   2016c:	f7e0 f840 	bl	1f0 <memcpy>
    pbuf_free(nakp);
   20170:	9802      	ldr	r0, [sp, #8]
   20172:	f002 f9ef 	bl	22554 <pbuf_free>
    return (rc);			/* Return final code */
   20176:	e6d8      	b.n	1ff2a <lcp_reqci+0x3e>
	*lenp = rejp - inp;
   20178:	9b05      	ldr	r3, [sp, #20]
   2017a:	9a06      	ldr	r2, [sp, #24]
   2017c:	1a9c      	subs	r4, r3, r2
   2017e:	e6ea      	b.n	1ff56 <lcp_reqci+0x6a>
   20180:	9b01      	ldr	r3, [sp, #4]
   20182:	9407      	str	r4, [sp, #28]
   20184:	9304      	str	r3, [sp, #16]
	    l = 0;			/* Don't loop again */
   20186:	2300      	movs	r3, #0
   20188:	9301      	str	r3, [sp, #4]
   2018a:	e760      	b.n	2004e <lcp_reqci+0x162>
   2018c:	000005dc 	.word	0x000005dc
   20190:	00025ff2 	.word	0x00025ff2

00020194 <lcp_open>:
void lcp_open(ppp_pcb *pcb) {
   20194:	0002      	movs	r2, r0
    f->flags &= ~(OPT_PASSIVE | OPT_SILENT);
   20196:	0013      	movs	r3, r2
void lcp_open(ppp_pcb *pcb) {
   20198:	b510      	push	{r4, lr}
    f->flags &= ~(OPT_PASSIVE | OPT_SILENT);
   2019a:	2405      	movs	r4, #5
   2019c:	3335      	adds	r3, #53	; 0x35
   2019e:	7819      	ldrb	r1, [r3, #0]
    if (wo->passive)
   201a0:	3240      	adds	r2, #64	; 0x40
    f->flags &= ~(OPT_PASSIVE | OPT_SILENT);
   201a2:	43a1      	bics	r1, r4
   201a4:	7019      	strb	r1, [r3, #0]
    if (wo->passive)
   201a6:	7814      	ldrb	r4, [r2, #0]
   201a8:	2201      	movs	r2, #1
    fsm *f = &pcb->lcp_fsm;
   201aa:	3024      	adds	r0, #36	; 0x24
    if (wo->passive)
   201ac:	4214      	tst	r4, r2
   201ae:	d001      	beq.n	201b4 <lcp_open+0x20>
	f->flags |= OPT_PASSIVE;
   201b0:	430a      	orrs	r2, r1
   201b2:	701a      	strb	r2, [r3, #0]
    if (wo->silent)
   201b4:	07a2      	lsls	r2, r4, #30
   201b6:	d503      	bpl.n	201c0 <lcp_open+0x2c>
	f->flags |= OPT_SILENT;
   201b8:	2204      	movs	r2, #4
   201ba:	7819      	ldrb	r1, [r3, #0]
   201bc:	430a      	orrs	r2, r1
   201be:	701a      	strb	r2, [r3, #0]
    fsm_open(f);
   201c0:	f000 fc7a 	bl	20ab8 <fsm_open>
}
   201c4:	bd10      	pop	{r4, pc}
	...

000201c8 <lcp_close>:
void lcp_close(ppp_pcb *pcb, const char *reason) {
   201c8:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    fsm *f = &pcb->lcp_fsm;
   201ca:	0005      	movs	r5, r0
    if (pcb->phase != PPP_PHASE_DEAD
   201cc:	1c43      	adds	r3, r0, #1
   201ce:	7fdb      	ldrb	r3, [r3, #31]
void lcp_close(ppp_pcb *pcb, const char *reason) {
   201d0:	0004      	movs	r4, r0
   201d2:	000f      	movs	r7, r1
    fsm *f = &pcb->lcp_fsm;
   201d4:	3524      	adds	r5, #36	; 0x24
    if (pcb->phase != PPP_PHASE_DEAD
   201d6:	2b00      	cmp	r3, #0
   201d8:	d002      	beq.n	201e0 <lcp_close+0x18>
	new_phase(pcb, PPP_PHASE_TERMINATE);
   201da:	210b      	movs	r1, #11
   201dc:	f7fd ff06 	bl	1dfec <new_phase>
    if (f->flags & DELAYED_UP) {
   201e0:	0026      	movs	r6, r4
   201e2:	3635      	adds	r6, #53	; 0x35
   201e4:	7833      	ldrb	r3, [r6, #0]
   201e6:	3434      	adds	r4, #52	; 0x34
   201e8:	2b7f      	cmp	r3, #127	; 0x7f
   201ea:	d905      	bls.n	201f8 <lcp_close+0x30>
	UNTIMEOUT(lcp_delayed_up, f);
   201ec:	0029      	movs	r1, r5
   201ee:	480c      	ldr	r0, [pc, #48]	; (20220 <lcp_close+0x58>)
   201f0:	f002 fba4 	bl	2293c <sys_untimeout>
	f->state = PPP_FSM_STOPPED;
   201f4:	2303      	movs	r3, #3
   201f6:	7023      	strb	r3, [r4, #0]
    oldstate = f->state;
   201f8:	7824      	ldrb	r4, [r4, #0]
    fsm_close(f, reason);
   201fa:	0039      	movs	r1, r7
   201fc:	0028      	movs	r0, r5
   201fe:	f000 fd65 	bl	20ccc <fsm_close>
    if (oldstate == PPP_FSM_STOPPED && (f->flags & (OPT_PASSIVE|OPT_SILENT|DELAYED_UP))) {
   20202:	2c03      	cmp	r4, #3
   20204:	d10a      	bne.n	2021c <lcp_close+0x54>
   20206:	7833      	ldrb	r3, [r6, #0]
   20208:	227a      	movs	r2, #122	; 0x7a
   2020a:	0019      	movs	r1, r3
   2020c:	4391      	bics	r1, r2
   2020e:	d005      	beq.n	2021c <lcp_close+0x54>
	f->flags &= ~DELAYED_UP;
   20210:	227f      	movs	r2, #127	; 0x7f
   20212:	4013      	ands	r3, r2
   20214:	7033      	strb	r3, [r6, #0]
	lcp_finished(f);
   20216:	0028      	movs	r0, r5
   20218:	f7ff fdc0 	bl	1fd9c <lcp_finished>
}
   2021c:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
   2021e:	46c0      	nop			; (mov r8, r8)
   20220:	0001fccd 	.word	0x0001fccd

00020224 <LcpEchoCheck>:
static void LcpEchoCheck(fsm *f) {
   20224:	b5f0      	push	{r4, r5, r6, r7, lr}
    ppp_pcb *pcb = f->pcb;
   20226:	6804      	ldr	r4, [r0, #0]
static void LcpEchoCheck(fsm *f) {
   20228:	b085      	sub	sp, #20
    if (pcb->settings.lcp_echo_fails != 0) {
   2022a:	7aa3      	ldrb	r3, [r4, #10]
static void LcpEchoCheck(fsm *f) {
   2022c:	0005      	movs	r5, r0
    if (pcb->settings.lcp_echo_fails != 0) {
   2022e:	2b00      	cmp	r3, #0
   20230:	d015      	beq.n	2025e <LcpEchoCheck+0x3a>
        if (pcb->lcp_echos_pending >= pcb->settings.lcp_echo_fails) {
   20232:	0026      	movs	r6, r4
   20234:	36d2      	adds	r6, #210	; 0xd2
   20236:	7831      	ldrb	r1, [r6, #0]
   20238:	428b      	cmp	r3, r1
   2023a:	d810      	bhi.n	2025e <LcpEchoCheck+0x3a>
    if (f->state == PPP_FSM_OPENED) {
   2023c:	7c07      	ldrb	r7, [r0, #16]
   2023e:	2f09      	cmp	r7, #9
   20240:	d10b      	bne.n	2025a <LcpEchoCheck+0x36>
	ppp_info("No response to %d echo-requests", pcb->lcp_echos_pending);
   20242:	4823      	ldr	r0, [pc, #140]	; (202d0 <LcpEchoCheck+0xac>)
   20244:	f7fe fcd4 	bl	1ebf0 <ppp_info>
        ppp_notice("Serial link appears to be disconnected.");
   20248:	4822      	ldr	r0, [pc, #136]	; (202d4 <LcpEchoCheck+0xb0>)
   2024a:	f7fe fcc5 	bl	1ebd8 <ppp_notice>
	pcb->err_code = PPPERR_PEERDEAD;
   2024e:	1ca3      	adds	r3, r4, #2
   20250:	77df      	strb	r7, [r3, #31]
	lcp_close(pcb, "Peer not responding");
   20252:	4921      	ldr	r1, [pc, #132]	; (202d8 <LcpEchoCheck+0xb4>)
   20254:	0020      	movs	r0, r4
   20256:	f7ff ffb7 	bl	201c8 <lcp_close>
            pcb->lcp_echos_pending = 0;
   2025a:	2300      	movs	r3, #0
   2025c:	7033      	strb	r3, [r6, #0]
    if (f->state == PPP_FSM_OPENED) {
   2025e:	7c29      	ldrb	r1, [r5, #16]
   20260:	2909      	cmp	r1, #9
   20262:	d117      	bne.n	20294 <LcpEchoCheck+0x70>
        lcp_magic = go->magicnumber;
   20264:	6ee2      	ldr	r2, [r4, #108]	; 0x6c
	PUTLONG(lcp_magic, pktp);
   20266:	ab03      	add	r3, sp, #12
   20268:	0e10      	lsrs	r0, r2, #24
   2026a:	7018      	strb	r0, [r3, #0]
   2026c:	0c10      	lsrs	r0, r2, #16
   2026e:	7058      	strb	r0, [r3, #1]
   20270:	0a10      	lsrs	r0, r2, #8
   20272:	7098      	strb	r0, [r3, #2]
        fsm_sdata(f, ECHOREQ, pcb->lcp_echo_number++, pkt, pktp - pkt);
   20274:	0020      	movs	r0, r4
	PUTLONG(lcp_magic, pktp);
   20276:	70da      	strb	r2, [r3, #3]
        fsm_sdata(f, ECHOREQ, pcb->lcp_echo_number++, pkt, pktp - pkt);
   20278:	30d3      	adds	r0, #211	; 0xd3
   2027a:	7802      	ldrb	r2, [r0, #0]
   2027c:	1c56      	adds	r6, r2, #1
   2027e:	7006      	strb	r6, [r0, #0]
   20280:	2004      	movs	r0, #4
   20282:	9000      	str	r0, [sp, #0]
   20284:	0028      	movs	r0, r5
   20286:	f000 fc44 	bl	20b12 <fsm_sdata>
	++pcb->lcp_echos_pending;
   2028a:	0022      	movs	r2, r4
   2028c:	32d2      	adds	r2, #210	; 0xd2
   2028e:	7813      	ldrb	r3, [r2, #0]
   20290:	3301      	adds	r3, #1
   20292:	7013      	strb	r3, [r2, #0]
    if (f->state != PPP_FSM_OPENED)
   20294:	7c2b      	ldrb	r3, [r5, #16]
   20296:	2b09      	cmp	r3, #9
   20298:	d117      	bne.n	202ca <LcpEchoCheck+0xa6>
    if (pcb->lcp_echo_timer_running)
   2029a:	1ce6      	adds	r6, r4, #3
   2029c:	7ff3      	ldrb	r3, [r6, #31]
   2029e:	06db      	lsls	r3, r3, #27
   202a0:	d502      	bpl.n	202a8 <LcpEchoCheck+0x84>
	ppp_warn("assertion lcp_echo_timer_running==0 failed");
   202a2:	480e      	ldr	r0, [pc, #56]	; (202dc <LcpEchoCheck+0xb8>)
   202a4:	f7fe fc8c 	bl	1ebc0 <ppp_warn>
    TIMEOUT (LcpEchoTimeout, f, pcb->settings.lcp_echo_interval);
   202a8:	4f0d      	ldr	r7, [pc, #52]	; (202e0 <LcpEchoCheck+0xbc>)
   202aa:	0029      	movs	r1, r5
   202ac:	0038      	movs	r0, r7
   202ae:	f002 fb45 	bl	2293c <sys_untimeout>
   202b2:	20fa      	movs	r0, #250	; 0xfa
   202b4:	7a63      	ldrb	r3, [r4, #9]
   202b6:	0080      	lsls	r0, r0, #2
   202b8:	4358      	muls	r0, r3
   202ba:	002a      	movs	r2, r5
   202bc:	0039      	movs	r1, r7
   202be:	f002 fadb 	bl	22878 <sys_timeout>
    pcb->lcp_echo_timer_running = 1;
   202c2:	2310      	movs	r3, #16
   202c4:	7ff2      	ldrb	r2, [r6, #31]
   202c6:	4313      	orrs	r3, r2
   202c8:	77f3      	strb	r3, [r6, #31]
}
   202ca:	b005      	add	sp, #20
   202cc:	bdf0      	pop	{r4, r5, r6, r7, pc}
   202ce:	46c0      	nop			; (mov r8, r8)
   202d0:	00025df9 	.word	0x00025df9
   202d4:	00025e19 	.word	0x00025e19
   202d8:	00025e41 	.word	0x00025e41
   202dc:	00025e55 	.word	0x00025e55
   202e0:	000202e5 	.word	0x000202e5

000202e4 <LcpEchoTimeout>:
    if (pcb->lcp_echo_timer_running != 0) {
   202e4:	2110      	movs	r1, #16
static void LcpEchoTimeout(void *arg) {
   202e6:	b510      	push	{r4, lr}
    if (pcb->lcp_echo_timer_running != 0) {
   202e8:	6803      	ldr	r3, [r0, #0]
   202ea:	3303      	adds	r3, #3
   202ec:	7fda      	ldrb	r2, [r3, #31]
   202ee:	420a      	tst	r2, r1
   202f0:	d003      	beq.n	202fa <LcpEchoTimeout+0x16>
        pcb->lcp_echo_timer_running = 0;
   202f2:	438a      	bics	r2, r1
   202f4:	77da      	strb	r2, [r3, #31]
        LcpEchoCheck ((fsm *) arg);
   202f6:	f7ff ff95 	bl	20224 <LcpEchoCheck>
}
   202fa:	bd10      	pop	{r4, pc}

000202fc <lcp_up>:
static void lcp_up(fsm *f) {
   202fc:	b5f0      	push	{r4, r5, r6, r7, lr}
    ppp_pcb *pcb = f->pcb;
   202fe:	6804      	ldr	r4, [r0, #0]
static void lcp_up(fsm *f) {
   20300:	b085      	sub	sp, #20
    if (!go->neg_magicnumber)
   20302:	0023      	movs	r3, r4
   20304:	3364      	adds	r3, #100	; 0x64
   20306:	781a      	ldrb	r2, [r3, #0]
   20308:	9302      	str	r3, [sp, #8]
   2030a:	0011      	movs	r1, r2
   2030c:	2310      	movs	r3, #16
static void lcp_up(fsm *f) {
   2030e:	9003      	str	r0, [sp, #12]
    if (!go->neg_magicnumber)
   20310:	4019      	ands	r1, r3
   20312:	d100      	bne.n	20316 <lcp_up+0x1a>
	go->magicnumber = 0;
   20314:	66e1      	str	r1, [r4, #108]	; 0x6c
    if (!ho->neg_magicnumber)
   20316:	0025      	movs	r5, r4
   20318:	35ac      	adds	r5, #172	; 0xac
   2031a:	7829      	ldrb	r1, [r5, #0]
   2031c:	400b      	ands	r3, r1
   2031e:	d100      	bne.n	20322 <lcp_up+0x26>
	ho->magicnumber = 0;
   20320:	60ab      	str	r3, [r5, #8]
   20322:	2304      	movs	r3, #4
    mtu = ho->neg_mru? ho->mru: PPP_MRU;
   20324:	4219      	tst	r1, r3
   20326:	d054      	beq.n	203d2 <lcp_up+0xd6>
   20328:	886f      	ldrh	r7, [r5, #2]
    mru = go->neg_mru? LWIP_MAX(wo->mru, go->mru): PPP_MRU;
   2032a:	421a      	tst	r2, r3
   2032c:	d053      	beq.n	203d6 <lcp_up+0xda>
   2032e:	9a02      	ldr	r2, [sp, #8]
   20330:	1d23      	adds	r3, r4, #4
   20332:	8fdb      	ldrh	r3, [r3, #62]	; 0x3e
   20334:	8856      	ldrh	r6, [r2, #2]
   20336:	42b3      	cmp	r3, r6
   20338:	d900      	bls.n	2033c <lcp_up+0x40>
   2033a:	001e      	movs	r6, r3
	netif_set_mtu(pcb, LWIP_MIN(LWIP_MIN(mtu, mru), ao->mru));
   2033c:	0023      	movs	r3, r4
   2033e:	3388      	adds	r3, #136	; 0x88
   20340:	8859      	ldrh	r1, [r3, #2]
   20342:	42b9      	cmp	r1, r7
   20344:	dd00      	ble.n	20348 <lcp_up+0x4c>
   20346:	0039      	movs	r1, r7
   20348:	42b1      	cmp	r1, r6
   2034a:	dd00      	ble.n	2034e <lcp_up+0x52>
   2034c:	0031      	movs	r1, r6
   2034e:	0020      	movs	r0, r4
   20350:	f7fd fea2 	bl	1e098 <netif_set_mtu>
		    (ho->neg_asyncmap? ho->asyncmap: 0xffffffff),
   20354:	782b      	ldrb	r3, [r5, #0]
    ppp_send_config(pcb, mtu,
   20356:	071b      	lsls	r3, r3, #28
   20358:	d53f      	bpl.n	203da <lcp_up+0xde>
   2035a:	686a      	ldr	r2, [r5, #4]
		    ho->neg_pcompression, ho->neg_accompression);
   2035c:	7829      	ldrb	r1, [r5, #0]
    ppp_send_config(pcb, mtu,
   2035e:	0020      	movs	r0, r4
		    ho->neg_pcompression, ho->neg_accompression);
   20360:	068b      	lsls	r3, r1, #26
   20362:	0649      	lsls	r1, r1, #25
    ppp_send_config(pcb, mtu,
   20364:	0fc9      	lsrs	r1, r1, #31
   20366:	0fdb      	lsrs	r3, r3, #31
   20368:	9100      	str	r1, [sp, #0]
   2036a:	0039      	movs	r1, r7
   2036c:	f7fd fe41 	bl	1dff2 <ppp_send_config>
		    (pcb->settings.lax_recv? 0: go->neg_asyncmap? go->asyncmap: 0xffffffff),
   20370:	7823      	ldrb	r3, [r4, #0]
    ppp_recv_config(pcb, mru,
   20372:	2200      	movs	r2, #0
   20374:	075b      	lsls	r3, r3, #29
   20376:	d404      	bmi.n	20382 <lcp_up+0x86>
		    (pcb->settings.lax_recv? 0: go->neg_asyncmap? go->asyncmap: 0xffffffff),
   20378:	9b02      	ldr	r3, [sp, #8]
   2037a:	781b      	ldrb	r3, [r3, #0]
   2037c:	071b      	lsls	r3, r3, #28
   2037e:	d52f      	bpl.n	203e0 <lcp_up+0xe4>
   20380:	6ea2      	ldr	r2, [r4, #104]	; 0x68
		    go->neg_pcompression, go->neg_accompression);
   20382:	9b02      	ldr	r3, [sp, #8]
    ppp_recv_config(pcb, mru,
   20384:	0020      	movs	r0, r4
		    go->neg_pcompression, go->neg_accompression);
   20386:	7819      	ldrb	r1, [r3, #0]
   20388:	068b      	lsls	r3, r1, #26
   2038a:	0649      	lsls	r1, r1, #25
    ppp_recv_config(pcb, mru,
   2038c:	0fc9      	lsrs	r1, r1, #31
   2038e:	0fdb      	lsrs	r3, r3, #31
   20390:	9100      	str	r1, [sp, #0]
   20392:	0031      	movs	r1, r6
   20394:	f7fd fe38 	bl	1e008 <ppp_recv_config>
    if (ho->neg_mru)
   20398:	782b      	ldrb	r3, [r5, #0]
   2039a:	075b      	lsls	r3, r3, #29
   2039c:	d503      	bpl.n	203a6 <lcp_up+0xaa>
	pcb->peer_mru = ho->mru;
   2039e:	0023      	movs	r3, r4
   203a0:	886a      	ldrh	r2, [r5, #2]
   203a2:	33d0      	adds	r3, #208	; 0xd0
   203a4:	801a      	strh	r2, [r3, #0]
    lcp_echo_lowerup(f->pcb);  /* Enable echo messages */
   203a6:	9b03      	ldr	r3, [sp, #12]
    pcb->lcp_echos_pending      = 0;
   203a8:	2200      	movs	r2, #0
    lcp_echo_lowerup(f->pcb);  /* Enable echo messages */
   203aa:	6818      	ldr	r0, [r3, #0]
    pcb->lcp_echo_timer_running = 0;
   203ac:	2110      	movs	r1, #16
    pcb->lcp_echos_pending      = 0;
   203ae:	0003      	movs	r3, r0
   203b0:	33d2      	adds	r3, #210	; 0xd2
   203b2:	801a      	strh	r2, [r3, #0]
    pcb->lcp_echo_timer_running = 0;
   203b4:	1cc2      	adds	r2, r0, #3
   203b6:	7fd3      	ldrb	r3, [r2, #31]
   203b8:	438b      	bics	r3, r1
   203ba:	77d3      	strb	r3, [r2, #31]
    if (pcb->settings.lcp_echo_interval != 0)
   203bc:	7a43      	ldrb	r3, [r0, #9]
   203be:	2b00      	cmp	r3, #0
   203c0:	d002      	beq.n	203c8 <lcp_up+0xcc>
    fsm *f = &pcb->lcp_fsm;
   203c2:	3024      	adds	r0, #36	; 0x24
        LcpEchoCheck (f);
   203c4:	f7ff ff2e 	bl	20224 <LcpEchoCheck>
    link_established(pcb);
   203c8:	0020      	movs	r0, r4
   203ca:	f7fe fca5 	bl	1ed18 <link_established>
}
   203ce:	b005      	add	sp, #20
   203d0:	bdf0      	pop	{r4, r5, r6, r7, pc}
    mtu = ho->neg_mru? ho->mru: PPP_MRU;
   203d2:	4f05      	ldr	r7, [pc, #20]	; (203e8 <lcp_up+0xec>)
   203d4:	e7a9      	b.n	2032a <lcp_up+0x2e>
    mru = go->neg_mru? LWIP_MAX(wo->mru, go->mru): PPP_MRU;
   203d6:	4e04      	ldr	r6, [pc, #16]	; (203e8 <lcp_up+0xec>)
   203d8:	e7b0      	b.n	2033c <lcp_up+0x40>
    ppp_send_config(pcb, mtu,
   203da:	2201      	movs	r2, #1
   203dc:	4252      	negs	r2, r2
   203de:	e7bd      	b.n	2035c <lcp_up+0x60>
		    (pcb->settings.lax_recv? 0: go->neg_asyncmap? go->asyncmap: 0xffffffff),
   203e0:	2201      	movs	r2, #1
   203e2:	4252      	negs	r2, r2
   203e4:	e7cd      	b.n	20382 <lcp_up+0x86>
   203e6:	46c0      	nop			; (mov r8, r8)
   203e8:	000005dc 	.word	0x000005dc

000203ec <lcp_nakci>:
static int lcp_nakci(fsm *f, u_char *p, int len, int treat_as_reject) {
   203ec:	b5f0      	push	{r4, r5, r6, r7, lr}
   203ee:	b0ab      	sub	sp, #172	; 0xac
    ppp_pcb *pcb = f->pcb;
   203f0:	6805      	ldr	r5, [r0, #0]
static int lcp_nakci(fsm *f, u_char *p, int len, int treat_as_reject) {
   203f2:	9008      	str	r0, [sp, #32]
   203f4:	000c      	movs	r4, r1
   203f6:	0016      	movs	r6, r2
    BZERO(&no, sizeof(no));
   203f8:	2100      	movs	r1, #0
   203fa:	2224      	movs	r2, #36	; 0x24
   203fc:	a818      	add	r0, sp, #96	; 0x60
   203fe:	f7df ff6f 	bl	2e0 <memset>
    try_ = *go;
   20402:	a921      	add	r1, sp, #132	; 0x84
   20404:	002b      	movs	r3, r5
   20406:	000a      	movs	r2, r1
   20408:	3364      	adds	r3, #100	; 0x64
   2040a:	cb83      	ldmia	r3!, {r0, r1, r7}
   2040c:	c283      	stmia	r2!, {r0, r1, r7}
   2040e:	cb83      	ldmia	r3!, {r0, r1, r7}
   20410:	c283      	stmia	r2!, {r0, r1, r7}
   20412:	cb83      	ldmia	r3!, {r0, r1, r7}
   20414:	c283      	stmia	r2!, {r0, r1, r7}
   20416:	3b24      	subs	r3, #36	; 0x24
   20418:	781a      	ldrb	r2, [r3, #0]
   2041a:	0753      	lsls	r3, r2, #29
   2041c:	0fdb      	lsrs	r3, r3, #31
   2041e:	9315      	str	r3, [sp, #84]	; 0x54
   20420:	0693      	lsls	r3, r2, #26
   20422:	0fdb      	lsrs	r3, r3, #31
   20424:	9314      	str	r3, [sp, #80]	; 0x50
   20426:	0653      	lsls	r3, r2, #25
   20428:	0fdb      	lsrs	r3, r3, #31
   2042a:	930b      	str	r3, [sp, #44]	; 0x2c
   2042c:	09d3      	lsrs	r3, r2, #7
   2042e:	930a      	str	r3, [sp, #40]	; 0x28
   20430:	002b      	movs	r3, r5
   20432:	3365      	adds	r3, #101	; 0x65
   20434:	781b      	ldrb	r3, [r3, #0]
   20436:	07d9      	lsls	r1, r3, #31
   20438:	079b      	lsls	r3, r3, #30
   2043a:	0fdb      	lsrs	r3, r3, #31
   2043c:	9309      	str	r3, [sp, #36]	; 0x24
   2043e:	002b      	movs	r3, r5
   20440:	3366      	adds	r3, #102	; 0x66
   20442:	881b      	ldrh	r3, [r3, #0]
   20444:	0fc9      	lsrs	r1, r1, #31
   20446:	9301      	str	r3, [sp, #4]
   20448:	6eab      	ldr	r3, [r5, #104]	; 0x68
   2044a:	9106      	str	r1, [sp, #24]
   2044c:	9302      	str	r3, [sp, #8]
   2044e:	6eeb      	ldr	r3, [r5, #108]	; 0x6c
   20450:	9316      	str	r3, [sp, #88]	; 0x58
   20452:	002b      	movs	r3, r5
   20454:	3370      	adds	r3, #112	; 0x70
   20456:	781b      	ldrb	r3, [r3, #0]
   20458:	9317      	str	r3, [sp, #92]	; 0x5c
    if (go->neg_mru && go->mru != PPP_DEFMRU) {
   2045a:	0753      	lsls	r3, r2, #29
   2045c:	d521      	bpl.n	204a2 <lcp_nakci+0xb6>
   2045e:	4fbb      	ldr	r7, [pc, #748]	; (2074c <lcp_nakci+0x360>)
   20460:	9b01      	ldr	r3, [sp, #4]
   20462:	42bb      	cmp	r3, r7
   20464:	d01d      	beq.n	204a2 <lcp_nakci+0xb6>
	NAKCISHORT(CI_MRU, neg_mru,
   20466:	2e03      	cmp	r6, #3
   20468:	dd1b      	ble.n	204a2 <lcp_nakci+0xb6>
   2046a:	7861      	ldrb	r1, [r4, #1]
   2046c:	2904      	cmp	r1, #4
   2046e:	d118      	bne.n	204a2 <lcp_nakci+0xb6>
   20470:	7823      	ldrb	r3, [r4, #0]
   20472:	2b01      	cmp	r3, #1
   20474:	d115      	bne.n	204a2 <lcp_nakci+0xb6>
   20476:	78a3      	ldrb	r3, [r4, #2]
   20478:	1d20      	adds	r0, r4, #4
   2047a:	78e4      	ldrb	r4, [r4, #3]
   2047c:	3e04      	subs	r6, #4
   2047e:	0224      	lsls	r4, r4, #8
   20480:	4323      	orrs	r3, r4
   20482:	ac18      	add	r4, sp, #96	; 0x60
   20484:	7824      	ldrb	r4, [r4, #0]
   20486:	ba5b      	rev16	r3, r3
   20488:	4321      	orrs	r1, r4
   2048a:	ac18      	add	r4, sp, #96	; 0x60
   2048c:	7021      	strb	r1, [r4, #0]
   2048e:	1d29      	adds	r1, r5, #4
   20490:	8fc9      	ldrh	r1, [r1, #62]	; 0x3e
   20492:	b29b      	uxth	r3, r3
   20494:	4299      	cmp	r1, r3
   20496:	d300      	bcc.n	2049a <lcp_nakci+0xae>
   20498:	e123      	b.n	206e2 <lcp_nakci+0x2f6>
   2049a:	42bb      	cmp	r3, r7
   2049c:	d800      	bhi.n	204a0 <lcp_nakci+0xb4>
   2049e:	e120      	b.n	206e2 <lcp_nakci+0x2f6>
   204a0:	0004      	movs	r4, r0
    if (go->neg_asyncmap && go->asyncmap != 0xFFFFFFFF) {
   204a2:	2108      	movs	r1, #8
   204a4:	420a      	tst	r2, r1
   204a6:	d020      	beq.n	204ea <lcp_nakci+0xfe>
   204a8:	9b02      	ldr	r3, [sp, #8]
   204aa:	3301      	adds	r3, #1
   204ac:	d01d      	beq.n	204ea <lcp_nakci+0xfe>
	NAKCILONG(CI_ASYNCMAP, neg_asyncmap,
   204ae:	2e05      	cmp	r6, #5
   204b0:	dd1b      	ble.n	204ea <lcp_nakci+0xfe>
   204b2:	7863      	ldrb	r3, [r4, #1]
   204b4:	2b06      	cmp	r3, #6
   204b6:	d118      	bne.n	204ea <lcp_nakci+0xfe>
   204b8:	7823      	ldrb	r3, [r4, #0]
   204ba:	2b02      	cmp	r3, #2
   204bc:	d115      	bne.n	204ea <lcp_nakci+0xfe>
   204be:	78e3      	ldrb	r3, [r4, #3]
   204c0:	78a0      	ldrb	r0, [r4, #2]
   204c2:	408b      	lsls	r3, r1
   204c4:	4303      	orrs	r3, r0
   204c6:	ba5b      	rev16	r3, r3
   204c8:	b29b      	uxth	r3, r3
   204ca:	408b      	lsls	r3, r1
   204cc:	7920      	ldrb	r0, [r4, #4]
   204ce:	9f02      	ldr	r7, [sp, #8]
   204d0:	4303      	orrs	r3, r0
   204d2:	7960      	ldrb	r0, [r4, #5]
   204d4:	021b      	lsls	r3, r3, #8
   204d6:	4338      	orrs	r0, r7
   204d8:	af18      	add	r7, sp, #96	; 0x60
   204da:	783f      	ldrb	r7, [r7, #0]
   204dc:	4303      	orrs	r3, r0
   204de:	4339      	orrs	r1, r7
   204e0:	af18      	add	r7, sp, #96	; 0x60
   204e2:	3e06      	subs	r6, #6
   204e4:	7039      	strb	r1, [r7, #0]
   204e6:	9302      	str	r3, [sp, #8]
   204e8:	3406      	adds	r4, #6
    NAKCICHAR(CI_CALLBACK, neg_cbcp,
   204ea:	b253      	sxtb	r3, r2
   204ec:	2b00      	cmp	r3, #0
   204ee:	da12      	bge.n	20516 <lcp_nakci+0x12a>
   204f0:	2e02      	cmp	r6, #2
   204f2:	dd10      	ble.n	20516 <lcp_nakci+0x12a>
   204f4:	7863      	ldrb	r3, [r4, #1]
   204f6:	2b03      	cmp	r3, #3
   204f8:	d10d      	bne.n	20516 <lcp_nakci+0x12a>
   204fa:	7823      	ldrb	r3, [r4, #0]
   204fc:	2b0d      	cmp	r3, #13
   204fe:	d10a      	bne.n	20516 <lcp_nakci+0x12a>
   20500:	ab18      	add	r3, sp, #96	; 0x60
   20502:	7819      	ldrb	r1, [r3, #0]
   20504:	2380      	movs	r3, #128	; 0x80
   20506:	425b      	negs	r3, r3
   20508:	430b      	orrs	r3, r1
   2050a:	a918      	add	r1, sp, #96	; 0x60
   2050c:	700b      	strb	r3, [r1, #0]
   2050e:	2300      	movs	r3, #0
   20510:	3e03      	subs	r6, #3
   20512:	3403      	adds	r4, #3
   20514:	930a      	str	r3, [sp, #40]	; 0x28
    int looped_back = 0;
   20516:	2100      	movs	r1, #0
    NAKCILONG(CI_MAGICNUMBER, neg_magicnumber,
   20518:	2310      	movs	r3, #16
    int looped_back = 0;
   2051a:	9113      	str	r1, [sp, #76]	; 0x4c
    NAKCILONG(CI_MAGICNUMBER, neg_magicnumber,
   2051c:	421a      	tst	r2, r3
   2051e:	d013      	beq.n	20548 <lcp_nakci+0x15c>
   20520:	2e05      	cmp	r6, #5
   20522:	dd11      	ble.n	20548 <lcp_nakci+0x15c>
   20524:	7862      	ldrb	r2, [r4, #1]
   20526:	2a06      	cmp	r2, #6
   20528:	d10e      	bne.n	20548 <lcp_nakci+0x15c>
   2052a:	7822      	ldrb	r2, [r4, #0]
   2052c:	2a05      	cmp	r2, #5
   2052e:	d10b      	bne.n	20548 <lcp_nakci+0x15c>
   20530:	aa18      	add	r2, sp, #96	; 0x60
   20532:	7812      	ldrb	r2, [r2, #0]
   20534:	3e06      	subs	r6, #6
   20536:	4313      	orrs	r3, r2
   20538:	aa18      	add	r2, sp, #96	; 0x60
   2053a:	7013      	strb	r3, [r2, #0]
   2053c:	f000 f9ee 	bl	2091c <magic>
   20540:	2301      	movs	r3, #1
   20542:	3406      	adds	r4, #6
   20544:	9016      	str	r0, [sp, #88]	; 0x58
   20546:	9313      	str	r3, [sp, #76]	; 0x4c
    NAKCIVOID(CI_PCOMPRESSION, neg_pcompression);
   20548:	002b      	movs	r3, r5
   2054a:	3364      	adds	r3, #100	; 0x64
   2054c:	781b      	ldrb	r3, [r3, #0]
   2054e:	9300      	str	r3, [sp, #0]
   20550:	2320      	movs	r3, #32
   20552:	9a00      	ldr	r2, [sp, #0]
   20554:	401a      	ands	r2, r3
   20556:	9203      	str	r2, [sp, #12]
   20558:	d010      	beq.n	2057c <lcp_nakci+0x190>
   2055a:	2e01      	cmp	r6, #1
   2055c:	dd0e      	ble.n	2057c <lcp_nakci+0x190>
   2055e:	7862      	ldrb	r2, [r4, #1]
   20560:	2a02      	cmp	r2, #2
   20562:	d10b      	bne.n	2057c <lcp_nakci+0x190>
   20564:	7822      	ldrb	r2, [r4, #0]
   20566:	2a07      	cmp	r2, #7
   20568:	d108      	bne.n	2057c <lcp_nakci+0x190>
   2056a:	aa18      	add	r2, sp, #96	; 0x60
   2056c:	7812      	ldrb	r2, [r2, #0]
   2056e:	3e02      	subs	r6, #2
   20570:	4313      	orrs	r3, r2
   20572:	aa18      	add	r2, sp, #96	; 0x60
   20574:	7013      	strb	r3, [r2, #0]
   20576:	2300      	movs	r3, #0
   20578:	3402      	adds	r4, #2
   2057a:	9314      	str	r3, [sp, #80]	; 0x50
    NAKCIVOID(CI_ACCOMPRESSION, neg_accompression);
   2057c:	2340      	movs	r3, #64	; 0x40
   2057e:	9a00      	ldr	r2, [sp, #0]
   20580:	401a      	ands	r2, r3
   20582:	9204      	str	r2, [sp, #16]
   20584:	d010      	beq.n	205a8 <lcp_nakci+0x1bc>
   20586:	2e01      	cmp	r6, #1
   20588:	dd0e      	ble.n	205a8 <lcp_nakci+0x1bc>
   2058a:	7862      	ldrb	r2, [r4, #1]
   2058c:	2a02      	cmp	r2, #2
   2058e:	d10b      	bne.n	205a8 <lcp_nakci+0x1bc>
   20590:	7822      	ldrb	r2, [r4, #0]
   20592:	2a08      	cmp	r2, #8
   20594:	d108      	bne.n	205a8 <lcp_nakci+0x1bc>
   20596:	aa18      	add	r2, sp, #96	; 0x60
   20598:	7812      	ldrb	r2, [r2, #0]
   2059a:	3e02      	subs	r6, #2
   2059c:	4313      	orrs	r3, r2
   2059e:	aa18      	add	r2, sp, #96	; 0x60
   205a0:	7013      	strb	r3, [r2, #0]
   205a2:	2300      	movs	r3, #0
   205a4:	3402      	adds	r4, #2
   205a6:	930b      	str	r3, [sp, #44]	; 0x2c
    NAKCIVOID(CI_SSNHF, neg_ssnhf);
   205a8:	002b      	movs	r3, r5
   205aa:	3365      	adds	r3, #101	; 0x65
   205ac:	781a      	ldrb	r2, [r3, #0]
   205ae:	2301      	movs	r3, #1
   205b0:	0011      	movs	r1, r2
   205b2:	4019      	ands	r1, r3
   205b4:	9105      	str	r1, [sp, #20]
   205b6:	d010      	beq.n	205da <lcp_nakci+0x1ee>
   205b8:	429e      	cmp	r6, r3
   205ba:	dd0e      	ble.n	205da <lcp_nakci+0x1ee>
   205bc:	7861      	ldrb	r1, [r4, #1]
   205be:	2902      	cmp	r1, #2
   205c0:	d10b      	bne.n	205da <lcp_nakci+0x1ee>
   205c2:	7821      	ldrb	r1, [r4, #0]
   205c4:	2912      	cmp	r1, #18
   205c6:	d108      	bne.n	205da <lcp_nakci+0x1ee>
   205c8:	a918      	add	r1, sp, #96	; 0x60
   205ca:	7849      	ldrb	r1, [r1, #1]
   205cc:	3e02      	subs	r6, #2
   205ce:	430b      	orrs	r3, r1
   205d0:	a918      	add	r1, sp, #96	; 0x60
   205d2:	704b      	strb	r3, [r1, #1]
   205d4:	2300      	movs	r3, #0
   205d6:	3402      	adds	r4, #2
   205d8:	9306      	str	r3, [sp, #24]
    NAKCIENDP(CI_EPDISC, neg_endpoint);
   205da:	2302      	movs	r3, #2
   205dc:	401a      	ands	r2, r3
   205de:	9207      	str	r2, [sp, #28]
   205e0:	d012      	beq.n	20608 <lcp_nakci+0x21c>
   205e2:	429e      	cmp	r6, r3
   205e4:	dd10      	ble.n	20608 <lcp_nakci+0x21c>
   205e6:	7822      	ldrb	r2, [r4, #0]
   205e8:	2a13      	cmp	r2, #19
   205ea:	d10d      	bne.n	20608 <lcp_nakci+0x21c>
   205ec:	7862      	ldrb	r2, [r4, #1]
   205ee:	429a      	cmp	r2, r3
   205f0:	d90a      	bls.n	20608 <lcp_nakci+0x21c>
   205f2:	42b2      	cmp	r2, r6
   205f4:	dc08      	bgt.n	20608 <lcp_nakci+0x21c>
   205f6:	1ab6      	subs	r6, r6, r2
   205f8:	18a4      	adds	r4, r4, r2
   205fa:	aa18      	add	r2, sp, #96	; 0x60
   205fc:	7852      	ldrb	r2, [r2, #1]
   205fe:	4313      	orrs	r3, r2
   20600:	aa18      	add	r2, sp, #96	; 0x60
   20602:	7053      	strb	r3, [r2, #1]
   20604:	2300      	movs	r3, #0
   20606:	9309      	str	r3, [sp, #36]	; 0x24
	    if (go->neg_ssnhf || no.neg_ssnhf || cilen != CILEN_VOID)
   20608:	ab18      	add	r3, sp, #96	; 0x60
   2060a:	7858      	ldrb	r0, [r3, #1]
   2060c:	2101      	movs	r1, #1
   2060e:	0003      	movs	r3, r0
	    if (go->neg_accompression || no.neg_accompression
   20610:	2240      	movs	r2, #64	; 0x40
	    if (go->neg_ssnhf || no.neg_ssnhf || cilen != CILEN_VOID)
   20612:	400b      	ands	r3, r1
   20614:	9311      	str	r3, [sp, #68]	; 0x44
	    if (go->neg_accompression || no.neg_accompression
   20616:	ab18      	add	r3, sp, #96	; 0x60
   20618:	781b      	ldrb	r3, [r3, #0]
   2061a:	401a      	ands	r2, r3
   2061c:	9210      	str	r2, [sp, #64]	; 0x40
	    if (go->neg_pcompression || no.neg_pcompression
   2061e:	2220      	movs	r2, #32
   20620:	401a      	ands	r2, r3
	    if (go->neg_magicnumber || no.neg_magicnumber ||
   20622:	001f      	movs	r7, r3
	    if (go->neg_pcompression || no.neg_pcompression
   20624:	920f      	str	r2, [sp, #60]	; 0x3c
	    if (go->neg_magicnumber || no.neg_magicnumber ||
   20626:	2210      	movs	r2, #16
   20628:	4017      	ands	r7, r2
   2062a:	970e      	str	r7, [sp, #56]	; 0x38
		|| no.neg_asyncmap || cilen != CILEN_LONG)
   2062c:	2708      	movs	r7, #8
   2062e:	401f      	ands	r7, r3
   20630:	970d      	str	r7, [sp, #52]	; 0x34
		|| no.neg_mru || cilen != CILEN_SHORT)
   20632:	2704      	movs	r7, #4
   20634:	403b      	ands	r3, r7
   20636:	930c      	str	r3, [sp, #48]	; 0x30
	    if (go->neg_endpoint || no.neg_endpoint || cilen < CILEN_CHAR)
   20638:	2302      	movs	r3, #2
   2063a:	4018      	ands	r0, r3
	    if (go->neg_magicnumber || no.neg_magicnumber ||
   2063c:	9b00      	ldr	r3, [sp, #0]
	    if (go->neg_endpoint || no.neg_endpoint || cilen < CILEN_CHAR)
   2063e:	9012      	str	r0, [sp, #72]	; 0x48
	    if (go->neg_magicnumber || no.neg_magicnumber ||
   20640:	401a      	ands	r2, r3
    while (len >= CILEN_VOID) {
   20642:	2e01      	cmp	r6, #1
   20644:	dc4f      	bgt.n	206e6 <lcp_nakci+0x2fa>
    if (f->state != PPP_FSM_OPENED) {
   20646:	9b08      	ldr	r3, [sp, #32]
    return 1;
   20648:	2001      	movs	r0, #1
    if (f->state != PPP_FSM_OPENED) {
   2064a:	7c1b      	ldrb	r3, [r3, #16]
   2064c:	2b09      	cmp	r3, #9
   2064e:	d100      	bne.n	20652 <lcp_nakci+0x266>
   20650:	e097      	b.n	20782 <lcp_nakci+0x396>
	    try_.numloops = 0;
   20652:	2400      	movs	r4, #0
	if (looped_back) {
   20654:	9b13      	ldr	r3, [sp, #76]	; 0x4c
   20656:	42a3      	cmp	r3, r4
   20658:	d010      	beq.n	2067c <lcp_nakci+0x290>
	    if (++try_.numloops >= pcb->settings.lcp_loopbackfail) {
   2065a:	9c17      	ldr	r4, [sp, #92]	; 0x5c
   2065c:	7a2b      	ldrb	r3, [r5, #8]
   2065e:	1824      	adds	r4, r4, r0
   20660:	b2e4      	uxtb	r4, r4
   20662:	42a3      	cmp	r3, r4
   20664:	d80a      	bhi.n	2067c <lcp_nakci+0x290>
		ppp_notice("Serial line is looped back.");
   20666:	483a      	ldr	r0, [pc, #232]	; (20750 <lcp_nakci+0x364>)
   20668:	f7fe fab6 	bl	1ebd8 <ppp_notice>
		pcb->err_code = PPPERR_LOOPBACK;
   2066c:	220c      	movs	r2, #12
   2066e:	1cab      	adds	r3, r5, #2
   20670:	77da      	strb	r2, [r3, #31]
		lcp_close(f->pcb, "Loopback detected");
   20672:	9b08      	ldr	r3, [sp, #32]
   20674:	4937      	ldr	r1, [pc, #220]	; (20754 <lcp_nakci+0x368>)
   20676:	6818      	ldr	r0, [r3, #0]
   20678:	f7ff fda6 	bl	201c8 <lcp_close>
	*go = try_;
   2067c:	2004      	movs	r0, #4
   2067e:	ab21      	add	r3, sp, #132	; 0x84
   20680:	7819      	ldrb	r1, [r3, #0]
   20682:	9a15      	ldr	r2, [sp, #84]	; 0x54
   20684:	4381      	bics	r1, r0
   20686:	0092      	lsls	r2, r2, #2
   20688:	4311      	orrs	r1, r2
   2068a:	2220      	movs	r2, #32
   2068c:	9814      	ldr	r0, [sp, #80]	; 0x50
   2068e:	4391      	bics	r1, r2
   20690:	0140      	lsls	r0, r0, #5
   20692:	4301      	orrs	r1, r0
   20694:	2040      	movs	r0, #64	; 0x40
   20696:	9e0b      	ldr	r6, [sp, #44]	; 0x2c
   20698:	4381      	bics	r1, r0
   2069a:	01b6      	lsls	r6, r6, #6
   2069c:	4331      	orrs	r1, r6
   2069e:	267f      	movs	r6, #127	; 0x7f
   206a0:	980a      	ldr	r0, [sp, #40]	; 0x28
   206a2:	4031      	ands	r1, r6
   206a4:	01c0      	lsls	r0, r0, #7
   206a6:	4301      	orrs	r1, r0
   206a8:	785e      	ldrb	r6, [r3, #1]
   206aa:	7019      	strb	r1, [r3, #0]
   206ac:	9906      	ldr	r1, [sp, #24]
   206ae:	3a1f      	subs	r2, #31
   206b0:	9809      	ldr	r0, [sp, #36]	; 0x24
   206b2:	4396      	bics	r6, r2
   206b4:	4011      	ands	r1, r2
   206b6:	4331      	orrs	r1, r6
   206b8:	2602      	movs	r6, #2
   206ba:	4090      	lsls	r0, r2
   206bc:	43b1      	bics	r1, r6
   206be:	4301      	orrs	r1, r0
   206c0:	7059      	strb	r1, [r3, #1]
   206c2:	4669      	mov	r1, sp
   206c4:	8889      	ldrh	r1, [r1, #4]
   206c6:	3564      	adds	r5, #100	; 0x64
   206c8:	8059      	strh	r1, [r3, #2]
   206ca:	9902      	ldr	r1, [sp, #8]
   206cc:	731c      	strb	r4, [r3, #12]
   206ce:	9122      	str	r1, [sp, #136]	; 0x88
   206d0:	9916      	ldr	r1, [sp, #88]	; 0x58
   206d2:	9123      	str	r1, [sp, #140]	; 0x8c
   206d4:	cb13      	ldmia	r3!, {r0, r1, r4}
   206d6:	c513      	stmia	r5!, {r0, r1, r4}
   206d8:	cb13      	ldmia	r3!, {r0, r1, r4}
   206da:	c513      	stmia	r5!, {r0, r1, r4}
   206dc:	cb13      	ldmia	r3!, {r0, r1, r4}
   206de:	c513      	stmia	r5!, {r0, r1, r4}
   206e0:	e04e      	b.n	20780 <lcp_nakci+0x394>
   206e2:	9301      	str	r3, [sp, #4]
   206e4:	e6dc      	b.n	204a0 <lcp_nakci+0xb4>
	GETCHAR(cilen, p);
   206e6:	1ca3      	adds	r3, r4, #2
   206e8:	469c      	mov	ip, r3
   206ea:	7863      	ldrb	r3, [r4, #1]
	GETCHAR(citype, p);
   206ec:	7820      	ldrb	r0, [r4, #0]
	if (cilen < CILEN_VOID || (len -= cilen) < 0)
   206ee:	2b01      	cmp	r3, #1
   206f0:	dd3f      	ble.n	20772 <lcp_nakci+0x386>
   206f2:	1af6      	subs	r6, r6, r3
   206f4:	d43d      	bmi.n	20772 <lcp_nakci+0x386>
	next = p + cilen - 2;
   206f6:	1e9f      	subs	r7, r3, #2
	switch (citype) {
   206f8:	3801      	subs	r0, #1
	next = p + cilen - 2;
   206fa:	4467      	add	r7, ip
	switch (citype) {
   206fc:	2812      	cmp	r0, #18
   206fe:	d823      	bhi.n	20748 <lcp_nakci+0x35c>
   20700:	f7df fe50 	bl	3a4 <__gnu_thumb1_case_uqi>
   20704:	22222c0a 	.word	0x22222c0a
   20708:	4a412239 	.word	0x4a412239
   2070c:	22222222 	.word	0x22222222
   20710:	22222222 	.word	0x22222222
   20714:	4f22      	.short	0x4f22
   20716:	59          	.byte	0x59
   20717:	00          	.byte	0x00
	    if ((go->neg_mru && go->mru != PPP_DEFMRU)
   20718:	9800      	ldr	r0, [sp, #0]
   2071a:	0740      	lsls	r0, r0, #29
   2071c:	d506      	bpl.n	2072c <lcp_nakci+0x340>
   2071e:	480b      	ldr	r0, [pc, #44]	; (2074c <lcp_nakci+0x360>)
   20720:	4684      	mov	ip, r0
   20722:	0028      	movs	r0, r5
   20724:	3064      	adds	r0, #100	; 0x64
   20726:	8840      	ldrh	r0, [r0, #2]
   20728:	4560      	cmp	r0, ip
   2072a:	d122      	bne.n	20772 <lcp_nakci+0x386>
		|| no.neg_mru || cilen != CILEN_SHORT)
   2072c:	980c      	ldr	r0, [sp, #48]	; 0x30
   2072e:	2800      	cmp	r0, #0
   20730:	d11f      	bne.n	20772 <lcp_nakci+0x386>
   20732:	2b04      	cmp	r3, #4
   20734:	d11d      	bne.n	20772 <lcp_nakci+0x386>
   20736:	78e3      	ldrb	r3, [r4, #3]
   20738:	78a0      	ldrb	r0, [r4, #2]
   2073a:	021b      	lsls	r3, r3, #8
   2073c:	4303      	orrs	r3, r0
   2073e:	ba5b      	rev16	r3, r3
	    if (cishort < PPP_DEFMRU) {
   20740:	4805      	ldr	r0, [pc, #20]	; (20758 <lcp_nakci+0x36c>)
   20742:	b29b      	uxth	r3, r3
   20744:	4283      	cmp	r3, r0
   20746:	d940      	bls.n	207ca <lcp_nakci+0x3de>
	    try_.neg_ssnhf = 1;
   20748:	003c      	movs	r4, r7
   2074a:	e77a      	b.n	20642 <lcp_nakci+0x256>
   2074c:	000005dc 	.word	0x000005dc
   20750:	00025f82 	.word	0x00025f82
   20754:	00025f9e 	.word	0x00025f9e
   20758:	000005db 	.word	0x000005db
	    if ((go->neg_asyncmap && go->asyncmap != 0xFFFFFFFF)
   2075c:	9800      	ldr	r0, [sp, #0]
   2075e:	0700      	lsls	r0, r0, #28
   20760:	d502      	bpl.n	20768 <lcp_nakci+0x37c>
   20762:	6ea8      	ldr	r0, [r5, #104]	; 0x68
   20764:	3001      	adds	r0, #1
   20766:	d104      	bne.n	20772 <lcp_nakci+0x386>
		|| no.neg_asyncmap || cilen != CILEN_LONG)
   20768:	980d      	ldr	r0, [sp, #52]	; 0x34
   2076a:	2800      	cmp	r0, #0
   2076c:	d101      	bne.n	20772 <lcp_nakci+0x386>
	    if (go->neg_magicnumber || no.neg_magicnumber ||
   2076e:	2b06      	cmp	r3, #6
   20770:	d0ea      	beq.n	20748 <lcp_nakci+0x35c>
    return 0;
   20772:	2000      	movs	r0, #0
   20774:	e005      	b.n	20782 <lcp_nakci+0x396>
	    if (go->neg_magicnumber || no.neg_magicnumber ||
   20776:	2a00      	cmp	r2, #0
   20778:	d1fb      	bne.n	20772 <lcp_nakci+0x386>
   2077a:	980e      	ldr	r0, [sp, #56]	; 0x38
   2077c:	2800      	cmp	r0, #0
   2077e:	d0f6      	beq.n	2076e <lcp_nakci+0x382>
    return 0;
   20780:	0010      	movs	r0, r2
}
   20782:	b02b      	add	sp, #172	; 0xac
   20784:	bdf0      	pop	{r4, r5, r6, r7, pc}
	    if (go->neg_pcompression || no.neg_pcompression
   20786:	9803      	ldr	r0, [sp, #12]
   20788:	2800      	cmp	r0, #0
   2078a:	d1f2      	bne.n	20772 <lcp_nakci+0x386>
   2078c:	980f      	ldr	r0, [sp, #60]	; 0x3c
	    if (go->neg_accompression || no.neg_accompression
   2078e:	2800      	cmp	r0, #0
   20790:	d1ef      	bne.n	20772 <lcp_nakci+0x386>
		|| cilen != CILEN_VOID)
   20792:	2b02      	cmp	r3, #2
   20794:	d0d8      	beq.n	20748 <lcp_nakci+0x35c>
   20796:	e7ec      	b.n	20772 <lcp_nakci+0x386>
	    if (go->neg_accompression || no.neg_accompression
   20798:	9804      	ldr	r0, [sp, #16]
   2079a:	2800      	cmp	r0, #0
   2079c:	d1e9      	bne.n	20772 <lcp_nakci+0x386>
   2079e:	9810      	ldr	r0, [sp, #64]	; 0x40
   207a0:	e7f5      	b.n	2078e <lcp_nakci+0x3a2>
	    if (go->neg_ssnhf || no.neg_ssnhf || cilen != CILEN_VOID)
   207a2:	9805      	ldr	r0, [sp, #20]
   207a4:	2800      	cmp	r0, #0
   207a6:	d1e4      	bne.n	20772 <lcp_nakci+0x386>
   207a8:	9811      	ldr	r0, [sp, #68]	; 0x44
   207aa:	2800      	cmp	r0, #0
   207ac:	d1e1      	bne.n	20772 <lcp_nakci+0x386>
   207ae:	2b02      	cmp	r3, #2
   207b0:	d1df      	bne.n	20772 <lcp_nakci+0x386>
	    try_.neg_ssnhf = 1;
   207b2:	9106      	str	r1, [sp, #24]
   207b4:	e7c8      	b.n	20748 <lcp_nakci+0x35c>
	    if (go->neg_endpoint || no.neg_endpoint || cilen < CILEN_CHAR)
   207b6:	9807      	ldr	r0, [sp, #28]
   207b8:	2800      	cmp	r0, #0
   207ba:	d1da      	bne.n	20772 <lcp_nakci+0x386>
   207bc:	9812      	ldr	r0, [sp, #72]	; 0x48
   207be:	2800      	cmp	r0, #0
   207c0:	d1d7      	bne.n	20772 <lcp_nakci+0x386>
   207c2:	2b02      	cmp	r3, #2
   207c4:	d1c0      	bne.n	20748 <lcp_nakci+0x35c>
    return 0;
   207c6:	9812      	ldr	r0, [sp, #72]	; 0x48
   207c8:	e7db      	b.n	20782 <lcp_nakci+0x396>
   207ca:	9301      	str	r3, [sp, #4]
		try_.neg_mru = 1;
   207cc:	9115      	str	r1, [sp, #84]	; 0x54
   207ce:	e7bb      	b.n	20748 <lcp_nakci+0x35c>

000207d0 <lcp_lowerdown>:
    if (f->flags & DELAYED_UP) {
   207d0:	0003      	movs	r3, r0
    fsm *f = &pcb->lcp_fsm;
   207d2:	0001      	movs	r1, r0
void lcp_lowerdown(ppp_pcb *pcb) {
   207d4:	b510      	push	{r4, lr}
    if (f->flags & DELAYED_UP) {
   207d6:	3335      	adds	r3, #53	; 0x35
   207d8:	781a      	ldrb	r2, [r3, #0]
    fsm *f = &pcb->lcp_fsm;
   207da:	3124      	adds	r1, #36	; 0x24
    if (f->flags & DELAYED_UP) {
   207dc:	b250      	sxtb	r0, r2
   207de:	2800      	cmp	r0, #0
   207e0:	da06      	bge.n	207f0 <lcp_lowerdown+0x20>
	f->flags &= ~DELAYED_UP;
   207e2:	207f      	movs	r0, #127	; 0x7f
   207e4:	4002      	ands	r2, r0
   207e6:	701a      	strb	r2, [r3, #0]
	UNTIMEOUT(lcp_delayed_up, f);
   207e8:	4803      	ldr	r0, [pc, #12]	; (207f8 <lcp_lowerdown+0x28>)
   207ea:	f002 f8a7 	bl	2293c <sys_untimeout>
}
   207ee:	bd10      	pop	{r4, pc}
	fsm_lowerdown(f);
   207f0:	0008      	movs	r0, r1
   207f2:	f000 f935 	bl	20a60 <fsm_lowerdown>
}
   207f6:	e7fa      	b.n	207ee <lcp_lowerdown+0x1e>
   207f8:	0001fccd 	.word	0x0001fccd

000207fc <lcp_extcode>:
static int lcp_extcode(fsm *f, int code, int id, u_char *inp, int len) {
   207fc:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
    switch( code ){
   207fe:	3908      	subs	r1, #8
static int lcp_extcode(fsm *f, int code, int id, u_char *inp, int len) {
   20800:	0005      	movs	r5, r0
    ppp_pcb *pcb = f->pcb;
   20802:	6804      	ldr	r4, [r0, #0]
static int lcp_extcode(fsm *f, int code, int id, u_char *inp, int len) {
   20804:	9f08      	ldr	r7, [sp, #32]
    switch( code ){
   20806:	0008      	movs	r0, r1
	return 0;
   20808:	2600      	movs	r6, #0
    switch( code ){
   2080a:	2905      	cmp	r1, #5
   2080c:	d839      	bhi.n	20882 <lcp_extcode+0x86>
   2080e:	f7df fdc9 	bl	3a4 <__gnu_thumb1_case_uqi>
   20812:	2303      	.short	0x2303
   20814:	2121213a 	.word	0x2121213a
    return 1;
   20818:	2601      	movs	r6, #1
    if (len < 2) {
   2081a:	42b7      	cmp	r7, r6
   2081c:	dd31      	ble.n	20882 <lcp_extcode+0x86>
    if( f->state != PPP_FSM_OPENED ){
   2081e:	7c2a      	ldrb	r2, [r5, #16]
   20820:	2a09      	cmp	r2, #9
   20822:	d12e      	bne.n	20882 <lcp_extcode+0x86>
   20824:	7859      	ldrb	r1, [r3, #1]
   20826:	781a      	ldrb	r2, [r3, #0]
   20828:	0209      	lsls	r1, r1, #8
   2082a:	4311      	orrs	r1, r2
   2082c:	ba49      	rev16	r1, r1
   2082e:	4b27      	ldr	r3, [pc, #156]	; (208cc <lcp_extcode+0xd0>)
   20830:	b289      	uxth	r1, r1
    for (i = 0; (protp = protocols[i]) != NULL; ++i)
   20832:	681c      	ldr	r4, [r3, #0]
   20834:	2c00      	cmp	r4, #0
   20836:	d103      	bne.n	20840 <lcp_extcode+0x44>
	ppp_warn("Protocol-Reject for unsupported protocol 0x%x", prot);
   20838:	4825      	ldr	r0, [pc, #148]	; (208d0 <lcp_extcode+0xd4>)
   2083a:	f7fe f9c1 	bl	1ebc0 <ppp_warn>
   2083e:	e009      	b.n	20854 <lcp_extcode+0x58>
	if (protp->protocol == prot) {
   20840:	8822      	ldrh	r2, [r4, #0]
   20842:	3304      	adds	r3, #4
   20844:	428a      	cmp	r2, r1
   20846:	d1f4      	bne.n	20832 <lcp_extcode+0x36>
		ppp_dbglog("Protocol-Reject for 0x%x received", prot);
   20848:	4822      	ldr	r0, [pc, #136]	; (208d4 <lcp_extcode+0xd8>)
   2084a:	f7fe f9dd 	bl	1ec08 <ppp_dbglog>
	    (*protp->protrej)(f->pcb);
   2084e:	68e3      	ldr	r3, [r4, #12]
   20850:	6828      	ldr	r0, [r5, #0]
   20852:	4798      	blx	r3
    return 1;
   20854:	2601      	movs	r6, #1
   20856:	e014      	b.n	20882 <lcp_extcode+0x86>
	if (f->state != PPP_FSM_OPENED)
   20858:	7c29      	ldrb	r1, [r5, #16]
    return 1;
   2085a:	2601      	movs	r6, #1
	if (f->state != PPP_FSM_OPENED)
   2085c:	2909      	cmp	r1, #9
   2085e:	d110      	bne.n	20882 <lcp_extcode+0x86>
	PUTLONG(go->magicnumber, magp);
   20860:	6ee1      	ldr	r1, [r4, #108]	; 0x6c
	fsm_sdata(f, ECHOREP, id, inp, len);
   20862:	b2d2      	uxtb	r2, r2
	PUTLONG(go->magicnumber, magp);
   20864:	0e09      	lsrs	r1, r1, #24
   20866:	7019      	strb	r1, [r3, #0]
   20868:	6ee1      	ldr	r1, [r4, #108]	; 0x6c
	fsm_sdata(f, ECHOREP, id, inp, len);
   2086a:	0028      	movs	r0, r5
	PUTLONG(go->magicnumber, magp);
   2086c:	0c09      	lsrs	r1, r1, #16
   2086e:	7059      	strb	r1, [r3, #1]
   20870:	6ee1      	ldr	r1, [r4, #108]	; 0x6c
   20872:	0a09      	lsrs	r1, r1, #8
   20874:	7099      	strb	r1, [r3, #2]
   20876:	6ee1      	ldr	r1, [r4, #108]	; 0x6c
   20878:	70d9      	strb	r1, [r3, #3]
	fsm_sdata(f, ECHOREP, id, inp, len);
   2087a:	9700      	str	r7, [sp, #0]
   2087c:	210a      	movs	r1, #10
   2087e:	f000 f948 	bl	20b12 <fsm_sdata>
}
   20882:	0030      	movs	r0, r6
   20884:	bdfe      	pop	{r1, r2, r3, r4, r5, r6, r7, pc}
    if (len < 4) {
   20886:	2f03      	cmp	r7, #3
   20888:	dc04      	bgt.n	20894 <lcp_extcode+0x98>
	ppp_dbglog("lcp: received short Echo-Reply, length %d", len);
   2088a:	0039      	movs	r1, r7
   2088c:	4812      	ldr	r0, [pc, #72]	; (208d8 <lcp_extcode+0xdc>)
   2088e:	f7fe f9bb 	bl	1ec08 <ppp_dbglog>
   20892:	e7df      	b.n	20854 <lcp_extcode+0x58>
    if (go->neg_magicnumber
   20894:	0022      	movs	r2, r4
   20896:	3264      	adds	r2, #100	; 0x64
   20898:	7812      	ldrb	r2, [r2, #0]
   2089a:	06d2      	lsls	r2, r2, #27
   2089c:	d512      	bpl.n	208c4 <lcp_extcode+0xc8>
   2089e:	785a      	ldrb	r2, [r3, #1]
   208a0:	7819      	ldrb	r1, [r3, #0]
   208a2:	0212      	lsls	r2, r2, #8
   208a4:	430a      	orrs	r2, r1
   208a6:	ba52      	rev16	r2, r2
    GETLONG(magic_val, inp);
   208a8:	7899      	ldrb	r1, [r3, #2]
   208aa:	b292      	uxth	r2, r2
   208ac:	0212      	lsls	r2, r2, #8
   208ae:	78db      	ldrb	r3, [r3, #3]
   208b0:	430a      	orrs	r2, r1
   208b2:	0212      	lsls	r2, r2, #8
   208b4:	431a      	orrs	r2, r3
	&& magic_val == go->magicnumber) {
   208b6:	6ee3      	ldr	r3, [r4, #108]	; 0x6c
   208b8:	429a      	cmp	r2, r3
   208ba:	d103      	bne.n	208c4 <lcp_extcode+0xc8>
	ppp_warn("appear to have received our own echo-reply!");
   208bc:	4807      	ldr	r0, [pc, #28]	; (208dc <lcp_extcode+0xe0>)
   208be:	f7fe f97f 	bl	1ebc0 <ppp_warn>
   208c2:	e7c7      	b.n	20854 <lcp_extcode+0x58>
    pcb->lcp_echos_pending = 0;
   208c4:	2300      	movs	r3, #0
   208c6:	34d2      	adds	r4, #210	; 0xd2
   208c8:	7023      	strb	r3, [r4, #0]
   208ca:	e7c3      	b.n	20854 <lcp_extcode+0x58>
   208cc:	00025894 	.word	0x00025894
   208d0:	00025efe 	.word	0x00025efe
   208d4:	00025edc 	.word	0x00025edc
   208d8:	00025f2c 	.word	0x00025f2c
   208dc:	00025f56 	.word	0x00025f56

000208e0 <lcp_sprotrej>:
void lcp_sprotrej(ppp_pcb *pcb, u_char *p, int len) {
   208e0:	b537      	push	{r0, r1, r2, r4, r5, lr}
    fsm_sdata(f, PROTREJ, ++f->id,
   208e2:	0005      	movs	r5, r0
void lcp_sprotrej(ppp_pcb *pcb, u_char *p, int len) {
   208e4:	000b      	movs	r3, r1
   208e6:	0011      	movs	r1, r2
    fsm_sdata(f, PROTREJ, ++f->id,
   208e8:	3536      	adds	r5, #54	; 0x36
   208ea:	782c      	ldrb	r4, [r5, #0]
    fsm *f = &pcb->lcp_fsm;
   208ec:	3024      	adds	r0, #36	; 0x24
    fsm_sdata(f, PROTREJ, ++f->id,
   208ee:	3401      	adds	r4, #1
   208f0:	b2e2      	uxtb	r2, r4
   208f2:	702a      	strb	r2, [r5, #0]
   208f4:	9100      	str	r1, [sp, #0]
   208f6:	2108      	movs	r1, #8
   208f8:	f000 f90b 	bl	20b12 <fsm_sdata>
}
   208fc:	bd37      	pop	{r0, r1, r2, r4, r5, pc}
	...

00020900 <magic_init>:
 * in startup(), then the idle counter and timer values may
 * repeat after each boot and the real time clock may not be
 * operational.  Thus we call it again on the first random
 * event.
 */
void magic_init(void) {
   20900:	b510      	push	{r4, lr}
  magic_randomseed += sys_jiffies();
   20902:	f001 ffb5 	bl	22870 <sys_jiffies>
   20906:	4b02      	ldr	r3, [pc, #8]	; (20910 <magic_init+0x10>)
   20908:	681a      	ldr	r2, [r3, #0]
   2090a:	1810      	adds	r0, r2, r0
   2090c:	6018      	str	r0, [r3, #0]
#ifndef LWIP_RAND
  /* Initialize the Borland random number generator. */
  srand((unsigned)magic_randomseed);
#endif /* LWIP_RAND */
}
   2090e:	bd10      	pop	{r4, pc}
   20910:	01002d68 	.word	0x01002d68

00020914 <magic_randomize>:
   20914:	b510      	push	{r4, lr}
   20916:	f7ff fff3 	bl	20900 <magic_init>
   2091a:	bd10      	pop	{r4, pc}

0002091c <magic>:
 * seed which is randomized by truely random events.
 * Thus the numbers will be truely random unless there have been no
 * operator or network events in which case it will be pseudo random
 * seeded by the real time clock.
 */
u32_t magic(void) {
   2091c:	b510      	push	{r4, lr}
#ifdef LWIP_RAND
  return LWIP_RAND() + magic_randomseed;
   2091e:	f001 fca9 	bl	22274 <rand>
   20922:	4b02      	ldr	r3, [pc, #8]	; (2092c <magic+0x10>)
   20924:	681b      	ldr	r3, [r3, #0]
   20926:	18c0      	adds	r0, r0, r3
#else /* LWIP_RAND */
  return ((u32_t)rand() << 16) + (u32_t)rand() + magic_randomseed;
#endif /* LWIP_RAND */
}
   20928:	bd10      	pop	{r4, pc}
   2092a:	46c0      	nop			; (mov r8, r8)
   2092c:	01002d68 	.word	0x01002d68

00020930 <fsm_sconfreq>:


/*
 * fsm_sconfreq - Send a Configure-Request.
 */
static void fsm_sconfreq(fsm *f, int retransmit) {
   20930:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
    ppp_pcb *pcb = f->pcb;
    struct pbuf *p;
    u_char *outp;
    int cilen;

    if( f->state != PPP_FSM_REQSENT && f->state != PPP_FSM_ACKRCVD && f->state != PPP_FSM_ACKSENT ){
   20932:	7c03      	ldrb	r3, [r0, #16]
   20934:	4677      	mov	r7, lr
   20936:	3b06      	subs	r3, #6
static void fsm_sconfreq(fsm *f, int retransmit) {
   20938:	0004      	movs	r4, r0
   2093a:	000d      	movs	r5, r1
    ppp_pcb *pcb = f->pcb;
   2093c:	6806      	ldr	r6, [r0, #0]
    if( f->state != PPP_FSM_REQSENT && f->state != PPP_FSM_ACKRCVD && f->state != PPP_FSM_ACKSENT ){
   2093e:	2b02      	cmp	r3, #2
   20940:	d907      	bls.n	20952 <fsm_sconfreq+0x22>
	/* Not currently negotiating - reset options */
	if( f->callbacks->resetci )
   20942:	6843      	ldr	r3, [r0, #4]
   20944:	681b      	ldr	r3, [r3, #0]
   20946:	2b00      	cmp	r3, #0
   20948:	d000      	beq.n	2094c <fsm_sconfreq+0x1c>
	    (*f->callbacks->resetci)(f);
   2094a:	4798      	blx	r3
	f->nakloops = 0;
   2094c:	2300      	movs	r3, #0
   2094e:	7563      	strb	r3, [r4, #21]
	f->rnakloops = 0;
   20950:	75a3      	strb	r3, [r4, #22]
    }

    if( !retransmit ){
   20952:	2d00      	cmp	r5, #0
   20954:	d106      	bne.n	20964 <fsm_sconfreq+0x34>
	/* New request - reset retransmission counter, use new ID */
	f->retransmits = pcb->settings.fsm_max_conf_req_transmits;
   20956:	7973      	ldrb	r3, [r6, #5]
   20958:	7523      	strb	r3, [r4, #20]
	f->reqid = ++f->id;
   2095a:	7ca3      	ldrb	r3, [r4, #18]
   2095c:	3301      	adds	r3, #1
   2095e:	b2db      	uxtb	r3, r3
   20960:	74a3      	strb	r3, [r4, #18]
   20962:	74e3      	strb	r3, [r4, #19]
    }

    f->seen_ack = 0;
   20964:	2300      	movs	r3, #0

    /*
     * Make up the request packet
     */
    if( f->callbacks->cilen && f->callbacks->addci ){
   20966:	6861      	ldr	r1, [r4, #4]
    f->seen_ack = 0;
   20968:	7323      	strb	r3, [r4, #12]
    if( f->callbacks->cilen && f->callbacks->addci ){
   2096a:	684a      	ldr	r2, [r1, #4]
   2096c:	429a      	cmp	r2, r3
   2096e:	d00c      	beq.n	2098a <fsm_sconfreq+0x5a>
   20970:	6889      	ldr	r1, [r1, #8]
   20972:	4299      	cmp	r1, r3
   20974:	d009      	beq.n	2098a <fsm_sconfreq+0x5a>
	cilen = (*f->callbacks->cilen)(f);
   20976:	0020      	movs	r0, r4
   20978:	4790      	blx	r2
	if( cilen > pcb->peer_mru - HEADERLEN )
   2097a:	0033      	movs	r3, r6
	cilen = (*f->callbacks->cilen)(f);
   2097c:	9001      	str	r0, [sp, #4]
	if( cilen > pcb->peer_mru - HEADERLEN )
   2097e:	33d0      	adds	r3, #208	; 0xd0
   20980:	881b      	ldrh	r3, [r3, #0]
   20982:	1eda      	subs	r2, r3, #3
   20984:	4290      	cmp	r0, r2
   20986:	db01      	blt.n	2098c <fsm_sconfreq+0x5c>
	    cilen = pcb->peer_mru - HEADERLEN;
   20988:	3b04      	subs	r3, #4
    } else
	cilen = 0;
   2098a:	9301      	str	r3, [sp, #4]

    p = pbuf_alloc(PBUF_RAW, (u16_t)(cilen + HEADERLEN + PPP_HDRLEN), PPP_CTRL_PBUF_TYPE);
   2098c:	9901      	ldr	r1, [sp, #4]
   2098e:	2203      	movs	r2, #3
   20990:	3108      	adds	r1, #8
   20992:	b289      	uxth	r1, r1
   20994:	2004      	movs	r0, #4
   20996:	f001 fda3 	bl	224e0 <pbuf_alloc>
   2099a:	1e05      	subs	r5, r0, #0
    if(NULL == p)
   2099c:	d005      	beq.n	209aa <fsm_sconfreq+0x7a>
        return;
    if(p->tot_len != p->len) {
   2099e:	8902      	ldrh	r2, [r0, #8]
   209a0:	8943      	ldrh	r3, [r0, #10]
   209a2:	429a      	cmp	r2, r3
   209a4:	d002      	beq.n	209ac <fsm_sconfreq+0x7c>
        pbuf_free(p);
   209a6:	f001 fdd5 	bl	22554 <pbuf_free>
    ppp_write(pcb, p);

    /* start the retransmit timer */
    --f->retransmits;
    TIMEOUT(fsm_timeout, f, pcb->settings.fsm_timeout_time);
}
   209aa:	bdf7      	pop	{r0, r1, r2, r4, r5, r6, r7, pc}
    MAKEHEADER(outp, f->protocol);
   209ac:	22ff      	movs	r2, #255	; 0xff
    outp = (u_char*)p->payload;
   209ae:	6843      	ldr	r3, [r0, #4]
    MAKEHEADER(outp, f->protocol);
   209b0:	701a      	strb	r2, [r3, #0]
   209b2:	3afc      	subs	r2, #252	; 0xfc
   209b4:	705a      	strb	r2, [r3, #1]
   209b6:	89e2      	ldrh	r2, [r4, #14]
   209b8:	0a12      	lsrs	r2, r2, #8
   209ba:	709a      	strb	r2, [r3, #2]
   209bc:	89e2      	ldrh	r2, [r4, #14]
   209be:	70da      	strb	r2, [r3, #3]
    PUTCHAR(CONFREQ, outp);
   209c0:	2201      	movs	r2, #1
   209c2:	711a      	strb	r2, [r3, #4]
    PUTCHAR(f->reqid, outp);
   209c4:	7ce2      	ldrb	r2, [r4, #19]
   209c6:	715a      	strb	r2, [r3, #5]
    PUTSHORT(cilen + HEADERLEN, outp);
   209c8:	9a01      	ldr	r2, [sp, #4]
   209ca:	1d10      	adds	r0, r2, #4
   209cc:	1201      	asrs	r1, r0, #8
   209ce:	7199      	strb	r1, [r3, #6]
   209d0:	0019      	movs	r1, r3
   209d2:	71d8      	strb	r0, [r3, #7]
   209d4:	3108      	adds	r1, #8
    if (cilen != 0) {
   209d6:	2a00      	cmp	r2, #0
   209d8:	d00d      	beq.n	209f6 <fsm_sconfreq+0xc6>
	(*f->callbacks->addci)(f, outp, &cilen);
   209da:	6863      	ldr	r3, [r4, #4]
   209dc:	aa01      	add	r2, sp, #4
   209de:	689b      	ldr	r3, [r3, #8]
   209e0:	0020      	movs	r0, r4
   209e2:	4798      	blx	r3
	LWIP_ASSERT("cilen == p->len - HEADERLEN - PPP_HDRLEN", cilen == p->len - HEADERLEN - PPP_HDRLEN);
   209e4:	896b      	ldrh	r3, [r5, #10]
   209e6:	9a01      	ldr	r2, [sp, #4]
   209e8:	3b08      	subs	r3, #8
   209ea:	4293      	cmp	r3, r2
   209ec:	d003      	beq.n	209f6 <fsm_sconfreq+0xc6>
   209ee:	0039      	movs	r1, r7
   209f0:	2016      	movs	r0, #22
   209f2:	f7e1 f88d 	bl	1b10 <panic>
    ppp_write(pcb, p);
   209f6:	0029      	movs	r1, r5
   209f8:	0030      	movs	r0, r6
   209fa:	f7fd faad 	bl	1df58 <ppp_write>
    --f->retransmits;
   209fe:	7d23      	ldrb	r3, [r4, #20]
    TIMEOUT(fsm_timeout, f, pcb->settings.fsm_timeout_time);
   20a00:	4d07      	ldr	r5, [pc, #28]	; (20a20 <fsm_sconfreq+0xf0>)
    --f->retransmits;
   20a02:	3b01      	subs	r3, #1
   20a04:	7523      	strb	r3, [r4, #20]
    TIMEOUT(fsm_timeout, f, pcb->settings.fsm_timeout_time);
   20a06:	0021      	movs	r1, r4
   20a08:	0028      	movs	r0, r5
   20a0a:	f001 ff97 	bl	2293c <sys_untimeout>
   20a0e:	20fa      	movs	r0, #250	; 0xfa
   20a10:	7933      	ldrb	r3, [r6, #4]
   20a12:	0080      	lsls	r0, r0, #2
   20a14:	4358      	muls	r0, r3
   20a16:	0022      	movs	r2, r4
   20a18:	0029      	movs	r1, r5
   20a1a:	f001 ff2d 	bl	22878 <sys_timeout>
   20a1e:	e7c4      	b.n	209aa <fsm_sconfreq+0x7a>
   20a20:	00020b99 	.word	0x00020b99

00020a24 <fsm_init>:
    f->state = PPP_FSM_INITIAL;
   20a24:	2300      	movs	r3, #0
    f->maxnakloops = pcb->settings.fsm_max_nak_loops;
   20a26:	6802      	ldr	r2, [r0, #0]
    f->state = PPP_FSM_INITIAL;
   20a28:	8203      	strh	r3, [r0, #16]
    f->flags = 0;
   20a2a:	7483      	strb	r3, [r0, #18]
    f->maxnakloops = pcb->settings.fsm_max_nak_loops;
   20a2c:	79d2      	ldrb	r2, [r2, #7]
   20a2e:	75c2      	strb	r2, [r0, #23]
    f->term_reason_len = 0;
   20a30:	7603      	strb	r3, [r0, #24]
}
   20a32:	4770      	bx	lr

00020a34 <fsm_lowerup>:
    switch( f->state ){
   20a34:	7c03      	ldrb	r3, [r0, #16]
void fsm_lowerup(fsm *f) {
   20a36:	b510      	push	{r4, lr}
   20a38:	0004      	movs	r4, r0
    switch( f->state ){
   20a3a:	2b00      	cmp	r3, #0
   20a3c:	d002      	beq.n	20a44 <fsm_lowerup+0x10>
   20a3e:	2b01      	cmp	r3, #1
   20a40:	d003      	beq.n	20a4a <fsm_lowerup+0x16>
}
   20a42:	bd10      	pop	{r4, pc}
	f->state = PPP_FSM_CLOSED;
   20a44:	2302      	movs	r3, #2
	    f->state = PPP_FSM_REQSENT;
   20a46:	7423      	strb	r3, [r4, #16]
}
   20a48:	e7fb      	b.n	20a42 <fsm_lowerup+0xe>
	if( f->flags & OPT_SILENT )
   20a4a:	2304      	movs	r3, #4
   20a4c:	7c41      	ldrb	r1, [r0, #17]
   20a4e:	4019      	ands	r1, r3
	    f->state = PPP_FSM_STOPPED;
   20a50:	3b01      	subs	r3, #1
	if( f->flags & OPT_SILENT )
   20a52:	2900      	cmp	r1, #0
   20a54:	d1f7      	bne.n	20a46 <fsm_lowerup+0x12>
	    fsm_sconfreq(f, 0);
   20a56:	f7ff ff6b 	bl	20930 <fsm_sconfreq>
	    f->state = PPP_FSM_REQSENT;
   20a5a:	2306      	movs	r3, #6
   20a5c:	e7f3      	b.n	20a46 <fsm_lowerup+0x12>
	...

00020a60 <fsm_lowerdown>:
void fsm_lowerdown(fsm *f) {
   20a60:	b510      	push	{r4, lr}
   20a62:	0004      	movs	r4, r0
    switch( f->state ){
   20a64:	7c00      	ldrb	r0, [r0, #16]
   20a66:	3802      	subs	r0, #2
   20a68:	2807      	cmp	r0, #7
   20a6a:	d810      	bhi.n	20a8e <fsm_lowerdown+0x2e>
   20a6c:	f7df fc9a 	bl	3a4 <__gnu_thumb1_case_uqi>
   20a70:	17100704 	.word	0x17100704
   20a74:	19171717 	.word	0x19171717
	f->state = PPP_FSM_INITIAL;
   20a78:	2300      	movs	r3, #0
	f->state = PPP_FSM_STARTING;
   20a7a:	7423      	strb	r3, [r4, #16]
}
   20a7c:	e007      	b.n	20a8e <fsm_lowerdown+0x2e>
	f->state = PPP_FSM_STARTING;
   20a7e:	2301      	movs	r3, #1
   20a80:	7423      	strb	r3, [r4, #16]
	if( f->callbacks->starting )
   20a82:	6863      	ldr	r3, [r4, #4]
   20a84:	6a5b      	ldr	r3, [r3, #36]	; 0x24
   20a86:	2b00      	cmp	r3, #0
   20a88:	d001      	beq.n	20a8e <fsm_lowerdown+0x2e>
	    (*f->callbacks->starting)(f);
   20a8a:	0020      	movs	r0, r4
   20a8c:	4798      	blx	r3
}
   20a8e:	bd10      	pop	{r4, pc}
	f->state = PPP_FSM_INITIAL;
   20a90:	2300      	movs	r3, #0
	f->state = PPP_FSM_STARTING;
   20a92:	7423      	strb	r3, [r4, #16]
	UNTIMEOUT(fsm_timeout, f);	/* Cancel timeout */
   20a94:	0021      	movs	r1, r4
   20a96:	4807      	ldr	r0, [pc, #28]	; (20ab4 <fsm_lowerdown+0x54>)
   20a98:	f001 ff50 	bl	2293c <sys_untimeout>
	break;
   20a9c:	e7f7      	b.n	20a8e <fsm_lowerdown+0x2e>
	f->state = PPP_FSM_STARTING;
   20a9e:	2301      	movs	r3, #1
   20aa0:	e7f7      	b.n	20a92 <fsm_lowerdown+0x32>
	if( f->callbacks->down )
   20aa2:	6863      	ldr	r3, [r4, #4]
   20aa4:	6a1b      	ldr	r3, [r3, #32]
   20aa6:	2b00      	cmp	r3, #0
   20aa8:	d001      	beq.n	20aae <fsm_lowerdown+0x4e>
	    (*f->callbacks->down)(f);
   20aaa:	0020      	movs	r0, r4
   20aac:	4798      	blx	r3
	f->state = PPP_FSM_STARTING;
   20aae:	2301      	movs	r3, #1
   20ab0:	e7e3      	b.n	20a7a <fsm_lowerdown+0x1a>
   20ab2:	46c0      	nop			; (mov r8, r8)
   20ab4:	00020b99 	.word	0x00020b99

00020ab8 <fsm_open>:
void fsm_open(fsm *f) {
   20ab8:	b510      	push	{r4, lr}
   20aba:	0004      	movs	r4, r0
    switch( f->state ){
   20abc:	7c00      	ldrb	r0, [r0, #16]
   20abe:	2809      	cmp	r0, #9
   20ac0:	d80e      	bhi.n	20ae0 <fsm_open+0x28>
   20ac2:	f7df fc6f 	bl	3a4 <__gnu_thumb1_case_uqi>
   20ac6:	0d05      	.short	0x0d05
   20ac8:	0d1a1c0e 	.word	0x0d1a1c0e
   20acc:	1c0d0d0d 	.word	0x1c0d0d0d
	f->state = PPP_FSM_STARTING;
   20ad0:	2301      	movs	r3, #1
   20ad2:	7423      	strb	r3, [r4, #16]
	if( f->callbacks->starting )
   20ad4:	6863      	ldr	r3, [r4, #4]
   20ad6:	6a5b      	ldr	r3, [r3, #36]	; 0x24
   20ad8:	2b00      	cmp	r3, #0
   20ada:	d001      	beq.n	20ae0 <fsm_open+0x28>
	    (*f->callbacks->starting)(f);
   20adc:	0020      	movs	r0, r4
   20ade:	4798      	blx	r3
}
   20ae0:	bd10      	pop	{r4, pc}
	if( f->flags & OPT_SILENT )
   20ae2:	2304      	movs	r3, #4
   20ae4:	7c61      	ldrb	r1, [r4, #17]
   20ae6:	4019      	ands	r1, r3
	    f->state = PPP_FSM_STOPPED;
   20ae8:	3b01      	subs	r3, #1
	if( f->flags & OPT_SILENT )
   20aea:	2900      	cmp	r1, #0
   20aec:	d103      	bne.n	20af6 <fsm_open+0x3e>
	    fsm_sconfreq(f, 0);
   20aee:	0020      	movs	r0, r4
   20af0:	f7ff ff1e 	bl	20930 <fsm_sconfreq>
	    f->state = PPP_FSM_REQSENT;
   20af4:	2306      	movs	r3, #6
   20af6:	7423      	strb	r3, [r4, #16]
   20af8:	e7f2      	b.n	20ae0 <fsm_open+0x28>
	f->state = PPP_FSM_STOPPING;
   20afa:	2305      	movs	r3, #5
   20afc:	7423      	strb	r3, [r4, #16]
	if( f->flags & OPT_RESTART ){
   20afe:	7c63      	ldrb	r3, [r4, #17]
   20b00:	079b      	lsls	r3, r3, #30
   20b02:	d5ed      	bpl.n	20ae0 <fsm_open+0x28>
	    fsm_lowerdown(f);
   20b04:	0020      	movs	r0, r4
   20b06:	f7ff ffab 	bl	20a60 <fsm_lowerdown>
	    fsm_lowerup(f);
   20b0a:	0020      	movs	r0, r4
   20b0c:	f7ff ff92 	bl	20a34 <fsm_lowerup>
}
   20b10:	e7e6      	b.n	20ae0 <fsm_open+0x28>

00020b12 <fsm_sdata>:
/*
 * fsm_sdata - Send some data.
 *
 * Used for all packets sent to our peer by this module.
 */
void fsm_sdata(fsm *f, u_char code, u_char id, const u_char *data, int datalen) {
   20b12:	b5f0      	push	{r4, r5, r6, r7, lr}
   20b14:	b085      	sub	sp, #20
   20b16:	9303      	str	r3, [sp, #12]
    ppp_pcb *pcb = f->pcb;
   20b18:	6803      	ldr	r3, [r0, #0]
void fsm_sdata(fsm *f, u_char code, u_char id, const u_char *data, int datalen) {
   20b1a:	9101      	str	r1, [sp, #4]
   20b1c:	9202      	str	r2, [sp, #8]
    ppp_pcb *pcb = f->pcb;
   20b1e:	9300      	str	r3, [sp, #0]
    struct pbuf *p;
    u_char *outp;
    int outlen;

    /* Adjust length to be smaller than MTU */
    if (datalen > pcb->peer_mru - HEADERLEN)
   20b20:	33d0      	adds	r3, #208	; 0xd0
   20b22:	881b      	ldrh	r3, [r3, #0]
   20b24:	990a      	ldr	r1, [sp, #40]	; 0x28
   20b26:	1eda      	subs	r2, r3, #3
void fsm_sdata(fsm *f, u_char code, u_char id, const u_char *data, int datalen) {
   20b28:	0007      	movs	r7, r0
    if (datalen > pcb->peer_mru - HEADERLEN)
   20b2a:	428a      	cmp	r2, r1
   20b2c:	dc01      	bgt.n	20b32 <fsm_sdata+0x20>
	datalen = pcb->peer_mru - HEADERLEN;
   20b2e:	3b04      	subs	r3, #4
   20b30:	930a      	str	r3, [sp, #40]	; 0x28
    outlen = datalen + HEADERLEN;
   20b32:	9b0a      	ldr	r3, [sp, #40]	; 0x28

    p = pbuf_alloc(PBUF_RAW, (u16_t)(outlen + PPP_HDRLEN), PPP_CTRL_PBUF_TYPE);
   20b34:	2203      	movs	r2, #3
    outlen = datalen + HEADERLEN;
   20b36:	1d1e      	adds	r6, r3, #4
    p = pbuf_alloc(PBUF_RAW, (u16_t)(outlen + PPP_HDRLEN), PPP_CTRL_PBUF_TYPE);
   20b38:	1d31      	adds	r1, r6, #4
   20b3a:	b289      	uxth	r1, r1
   20b3c:	2004      	movs	r0, #4
   20b3e:	f001 fccf 	bl	224e0 <pbuf_alloc>
   20b42:	1e05      	subs	r5, r0, #0
    if(NULL == p)
   20b44:	d005      	beq.n	20b52 <fsm_sdata+0x40>
        return;
    if(p->tot_len != p->len) {
   20b46:	8902      	ldrh	r2, [r0, #8]
   20b48:	8943      	ldrh	r3, [r0, #10]
   20b4a:	429a      	cmp	r2, r3
   20b4c:	d003      	beq.n	20b56 <fsm_sdata+0x44>
        pbuf_free(p);
   20b4e:	f001 fd01 	bl	22554 <pbuf_free>
    MAKEHEADER(outp, f->protocol);
    PUTCHAR(code, outp);
    PUTCHAR(id, outp);
    PUTSHORT(outlen, outp);
    ppp_write(pcb, p);
}
   20b52:	b005      	add	sp, #20
   20b54:	bdf0      	pop	{r4, r5, r6, r7, pc}
    if (datalen) /* && data != outp + PPP_HDRLEN + HEADERLEN)  -- was only for fsm_sconfreq() */
   20b56:	9b0a      	ldr	r3, [sp, #40]	; 0x28
    outp = (u_char*)p->payload;
   20b58:	6844      	ldr	r4, [r0, #4]
    if (datalen) /* && data != outp + PPP_HDRLEN + HEADERLEN)  -- was only for fsm_sconfreq() */
   20b5a:	2b00      	cmp	r3, #0
   20b5c:	d005      	beq.n	20b6a <fsm_sdata+0x58>
	MEMCPY(outp + PPP_HDRLEN + HEADERLEN, data, datalen);
   20b5e:	0020      	movs	r0, r4
   20b60:	001a      	movs	r2, r3
   20b62:	9903      	ldr	r1, [sp, #12]
   20b64:	3008      	adds	r0, #8
   20b66:	f7df fb43 	bl	1f0 <memcpy>
    MAKEHEADER(outp, f->protocol);
   20b6a:	23ff      	movs	r3, #255	; 0xff
   20b6c:	7023      	strb	r3, [r4, #0]
   20b6e:	3bfc      	subs	r3, #252	; 0xfc
   20b70:	7063      	strb	r3, [r4, #1]
   20b72:	89fb      	ldrh	r3, [r7, #14]
    ppp_write(pcb, p);
   20b74:	0029      	movs	r1, r5
    MAKEHEADER(outp, f->protocol);
   20b76:	0a1b      	lsrs	r3, r3, #8
   20b78:	70a3      	strb	r3, [r4, #2]
   20b7a:	89fb      	ldrh	r3, [r7, #14]
    ppp_write(pcb, p);
   20b7c:	9800      	ldr	r0, [sp, #0]
    MAKEHEADER(outp, f->protocol);
   20b7e:	70e3      	strb	r3, [r4, #3]
    PUTCHAR(code, outp);
   20b80:	466b      	mov	r3, sp
   20b82:	791b      	ldrb	r3, [r3, #4]
    PUTSHORT(outlen, outp);
   20b84:	71e6      	strb	r6, [r4, #7]
    PUTCHAR(code, outp);
   20b86:	7123      	strb	r3, [r4, #4]
    PUTCHAR(id, outp);
   20b88:	466b      	mov	r3, sp
   20b8a:	7a1b      	ldrb	r3, [r3, #8]
   20b8c:	7163      	strb	r3, [r4, #5]
    PUTSHORT(outlen, outp);
   20b8e:	1233      	asrs	r3, r6, #8
   20b90:	71a3      	strb	r3, [r4, #6]
    ppp_write(pcb, p);
   20b92:	f7fd f9e1 	bl	1df58 <ppp_write>
   20b96:	e7dc      	b.n	20b52 <fsm_sdata+0x40>

00020b98 <fsm_timeout>:
static void fsm_timeout(void *arg) {
   20b98:	b573      	push	{r0, r1, r4, r5, r6, lr}
    switch (f->state) {
   20b9a:	7c03      	ldrb	r3, [r0, #16]
static void fsm_timeout(void *arg) {
   20b9c:	0004      	movs	r4, r0
    switch (f->state) {
   20b9e:	1f18      	subs	r0, r3, #4
   20ba0:	2804      	cmp	r0, #4
   20ba2:	d830      	bhi.n	20c06 <fsm_timeout+0x6e>
   20ba4:	7d22      	ldrb	r2, [r4, #20]
   20ba6:	f7df fbfd 	bl	3a4 <__gnu_thumb1_case_uqi>
   20baa:	0303      	.short	0x0303
   20bac:	2f2f      	.short	0x2f2f
   20bae:	2f          	.byte	0x2f
   20baf:	00          	.byte	0x00
	if( f->retransmits <= 0 ){
   20bb0:	2a00      	cmp	r2, #0
   20bb2:	d10b      	bne.n	20bcc <fsm_timeout+0x34>
	    f->state = (f->state == PPP_FSM_CLOSING)? PPP_FSM_CLOSED: PPP_FSM_STOPPED;
   20bb4:	3b04      	subs	r3, #4
   20bb6:	1e5a      	subs	r2, r3, #1
   20bb8:	4193      	sbcs	r3, r2
   20bba:	3302      	adds	r3, #2
   20bbc:	7423      	strb	r3, [r4, #16]
	    if( (f->flags & OPT_PASSIVE) == 0 && f->callbacks->finished )
   20bbe:	6863      	ldr	r3, [r4, #4]
   20bc0:	6a9b      	ldr	r3, [r3, #40]	; 0x28
   20bc2:	2b00      	cmp	r3, #0
   20bc4:	d01f      	beq.n	20c06 <fsm_timeout+0x6e>
		(*f->callbacks->finished)(f);
   20bc6:	0020      	movs	r0, r4
   20bc8:	4798      	blx	r3
   20bca:	e01c      	b.n	20c06 <fsm_timeout+0x6e>
	    fsm_sdata(f, TERMREQ, f->reqid = ++f->id,
   20bcc:	7ca2      	ldrb	r2, [r4, #18]
   20bce:	7e23      	ldrb	r3, [r4, #24]
   20bd0:	3201      	adds	r2, #1
   20bd2:	b2d2      	uxtb	r2, r2
   20bd4:	74a2      	strb	r2, [r4, #18]
   20bd6:	74e2      	strb	r2, [r4, #19]
   20bd8:	9300      	str	r3, [sp, #0]
   20bda:	2105      	movs	r1, #5
   20bdc:	68a3      	ldr	r3, [r4, #8]
   20bde:	0020      	movs	r0, r4
    ppp_pcb *pcb = f->pcb;
   20be0:	6825      	ldr	r5, [r4, #0]
	    fsm_sdata(f, TERMREQ, f->reqid = ++f->id,
   20be2:	f7ff ff96 	bl	20b12 <fsm_sdata>
	    TIMEOUT(fsm_timeout, f, pcb->settings.fsm_timeout_time);
   20be6:	4e16      	ldr	r6, [pc, #88]	; (20c40 <fsm_timeout+0xa8>)
   20be8:	0021      	movs	r1, r4
   20bea:	0030      	movs	r0, r6
   20bec:	f001 fea6 	bl	2293c <sys_untimeout>
   20bf0:	20fa      	movs	r0, #250	; 0xfa
   20bf2:	792b      	ldrb	r3, [r5, #4]
   20bf4:	0080      	lsls	r0, r0, #2
   20bf6:	4358      	muls	r0, r3
   20bf8:	0022      	movs	r2, r4
   20bfa:	0031      	movs	r1, r6
   20bfc:	f001 fe3c 	bl	22878 <sys_timeout>
	    --f->retransmits;
   20c00:	7d23      	ldrb	r3, [r4, #20]
   20c02:	3b01      	subs	r3, #1
   20c04:	7523      	strb	r3, [r4, #20]
}
   20c06:	bd73      	pop	{r0, r1, r4, r5, r6, pc}
   20c08:	6863      	ldr	r3, [r4, #4]
	if (f->retransmits <= 0) {
   20c0a:	2a00      	cmp	r2, #0
   20c0c:	d109      	bne.n	20c22 <fsm_timeout+0x8a>
	    ppp_warn("%s: timeout sending Config-Requests", PROTO_NAME(f));
   20c0e:	6b99      	ldr	r1, [r3, #56]	; 0x38
   20c10:	480c      	ldr	r0, [pc, #48]	; (20c44 <fsm_timeout+0xac>)
   20c12:	f7fd ffd5 	bl	1ebc0 <ppp_warn>
	    f->state = PPP_FSM_STOPPED;
   20c16:	2303      	movs	r3, #3
   20c18:	7423      	strb	r3, [r4, #16]
	    if( (f->flags & OPT_PASSIVE) == 0 && f->callbacks->finished )
   20c1a:	7c63      	ldrb	r3, [r4, #17]
   20c1c:	07db      	lsls	r3, r3, #31
   20c1e:	d5ce      	bpl.n	20bbe <fsm_timeout+0x26>
   20c20:	e7f1      	b.n	20c06 <fsm_timeout+0x6e>
	    if (f->callbacks->retransmit)
   20c22:	6b1b      	ldr	r3, [r3, #48]	; 0x30
   20c24:	2b00      	cmp	r3, #0
   20c26:	d001      	beq.n	20c2c <fsm_timeout+0x94>
		(*f->callbacks->retransmit)(f);
   20c28:	0020      	movs	r0, r4
   20c2a:	4798      	blx	r3
	    fsm_sconfreq(f, 1);		/* Re-send Configure-Request */
   20c2c:	2101      	movs	r1, #1
   20c2e:	0020      	movs	r0, r4
   20c30:	f7ff fe7e 	bl	20930 <fsm_sconfreq>
	    if( f->state == PPP_FSM_ACKRCVD )
   20c34:	7c23      	ldrb	r3, [r4, #16]
   20c36:	2b07      	cmp	r3, #7
   20c38:	d1e5      	bne.n	20c06 <fsm_timeout+0x6e>
		f->state = PPP_FSM_REQSENT;
   20c3a:	3b01      	subs	r3, #1
   20c3c:	7423      	strb	r3, [r4, #16]
}
   20c3e:	e7e2      	b.n	20c06 <fsm_timeout+0x6e>
   20c40:	00020b99 	.word	0x00020b99
   20c44:	000260c3 	.word	0x000260c3

00020c48 <terminate_layer>:
static void terminate_layer(fsm *f, int nextstate) {
   20c48:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
    if( f->state != PPP_FSM_OPENED )
   20c4a:	7c03      	ldrb	r3, [r0, #16]
static void terminate_layer(fsm *f, int nextstate) {
   20c4c:	0004      	movs	r4, r0
   20c4e:	000d      	movs	r5, r1
    ppp_pcb *pcb = f->pcb;
   20c50:	6806      	ldr	r6, [r0, #0]
    if( f->state != PPP_FSM_OPENED )
   20c52:	2b09      	cmp	r3, #9
   20c54:	d020      	beq.n	20c98 <terminate_layer+0x50>
	UNTIMEOUT(fsm_timeout, f);	/* Cancel timeout */
   20c56:	0001      	movs	r1, r0
   20c58:	481b      	ldr	r0, [pc, #108]	; (20cc8 <terminate_layer+0x80>)
   20c5a:	f001 fe6f 	bl	2293c <sys_untimeout>
    f->retransmits = pcb->settings.fsm_max_term_transmits;
   20c5e:	79b3      	ldrb	r3, [r6, #6]
    fsm_sdata(f, TERMREQ, f->reqid = ++f->id,
   20c60:	7ca2      	ldrb	r2, [r4, #18]
    f->retransmits = pcb->settings.fsm_max_term_transmits;
   20c62:	7523      	strb	r3, [r4, #20]
    fsm_sdata(f, TERMREQ, f->reqid = ++f->id,
   20c64:	3201      	adds	r2, #1
   20c66:	7e23      	ldrb	r3, [r4, #24]
   20c68:	b2d2      	uxtb	r2, r2
   20c6a:	9300      	str	r3, [sp, #0]
   20c6c:	74a2      	strb	r2, [r4, #18]
   20c6e:	68a3      	ldr	r3, [r4, #8]
   20c70:	74e2      	strb	r2, [r4, #19]
   20c72:	2105      	movs	r1, #5
   20c74:	0020      	movs	r0, r4
   20c76:	f7ff ff4c 	bl	20b12 <fsm_sdata>
    if (f->retransmits == 0) {
   20c7a:	7d23      	ldrb	r3, [r4, #20]
   20c7c:	2b00      	cmp	r3, #0
   20c7e:	d111      	bne.n	20ca4 <terminate_layer+0x5c>
	f->state = nextstate == PPP_FSM_CLOSING ? PPP_FSM_CLOSED : PPP_FSM_STOPPED;
   20c80:	3d04      	subs	r5, #4
   20c82:	1e6b      	subs	r3, r5, #1
   20c84:	419d      	sbcs	r5, r3
	if( f->callbacks->finished )
   20c86:	6863      	ldr	r3, [r4, #4]
	f->state = nextstate == PPP_FSM_CLOSING ? PPP_FSM_CLOSED : PPP_FSM_STOPPED;
   20c88:	3502      	adds	r5, #2
   20c8a:	7425      	strb	r5, [r4, #16]
	if( f->callbacks->finished )
   20c8c:	6a9b      	ldr	r3, [r3, #40]	; 0x28
   20c8e:	2b00      	cmp	r3, #0
   20c90:	d001      	beq.n	20c96 <terminate_layer+0x4e>
	    (*f->callbacks->finished)(f);
   20c92:	0020      	movs	r0, r4
   20c94:	4798      	blx	r3
}
   20c96:	bdf7      	pop	{r0, r1, r2, r4, r5, r6, r7, pc}
    else if( f->callbacks->down )
   20c98:	6843      	ldr	r3, [r0, #4]
   20c9a:	6a1b      	ldr	r3, [r3, #32]
   20c9c:	2b00      	cmp	r3, #0
   20c9e:	d0de      	beq.n	20c5e <terminate_layer+0x16>
	(*f->callbacks->down)(f);	/* Inform upper layers we're down */
   20ca0:	4798      	blx	r3
   20ca2:	e7dc      	b.n	20c5e <terminate_layer+0x16>
    TIMEOUT(fsm_timeout, f, pcb->settings.fsm_timeout_time);
   20ca4:	4f08      	ldr	r7, [pc, #32]	; (20cc8 <terminate_layer+0x80>)
   20ca6:	0021      	movs	r1, r4
   20ca8:	0038      	movs	r0, r7
   20caa:	f001 fe47 	bl	2293c <sys_untimeout>
   20cae:	20fa      	movs	r0, #250	; 0xfa
   20cb0:	7933      	ldrb	r3, [r6, #4]
   20cb2:	0080      	lsls	r0, r0, #2
   20cb4:	4358      	muls	r0, r3
   20cb6:	0022      	movs	r2, r4
   20cb8:	0039      	movs	r1, r7
   20cba:	f001 fddd 	bl	22878 <sys_timeout>
    --f->retransmits;
   20cbe:	7d23      	ldrb	r3, [r4, #20]
    f->state = nextstate;
   20cc0:	7425      	strb	r5, [r4, #16]
    --f->retransmits;
   20cc2:	3b01      	subs	r3, #1
   20cc4:	7523      	strb	r3, [r4, #20]
   20cc6:	e7e6      	b.n	20c96 <terminate_layer+0x4e>
   20cc8:	00020b99 	.word	0x00020b99

00020ccc <fsm_close>:
void fsm_close(fsm *f, const char *reason) {
   20ccc:	b570      	push	{r4, r5, r6, lr}
    f->term_reason_len = (reason == NULL? 0: LWIP_MIN(strlen(reason), 0xFF) );
   20cce:	2300      	movs	r3, #0
void fsm_close(fsm *f, const char *reason) {
   20cd0:	0004      	movs	r4, r0
   20cd2:	000d      	movs	r5, r1
    f->term_reason = reason;
   20cd4:	60a1      	str	r1, [r4, #8]
    f->term_reason_len = (reason == NULL? 0: LWIP_MIN(strlen(reason), 0xFF) );
   20cd6:	4299      	cmp	r1, r3
   20cd8:	d009      	beq.n	20cee <fsm_close+0x22>
   20cda:	0008      	movs	r0, r1
   20cdc:	f7fa fb5f 	bl	1b39e <strlen>
   20ce0:	23ff      	movs	r3, #255	; 0xff
   20ce2:	28fe      	cmp	r0, #254	; 0xfe
   20ce4:	d803      	bhi.n	20cee <fsm_close+0x22>
   20ce6:	0028      	movs	r0, r5
   20ce8:	f7fa fb59 	bl	1b39e <strlen>
   20cec:	b2c3      	uxtb	r3, r0
    switch( f->state ){
   20cee:	7c20      	ldrb	r0, [r4, #16]
    f->term_reason_len = (reason == NULL? 0: LWIP_MIN(strlen(reason), 0xFF) );
   20cf0:	7623      	strb	r3, [r4, #24]
    switch( f->state ){
   20cf2:	3801      	subs	r0, #1
   20cf4:	2808      	cmp	r0, #8
   20cf6:	d808      	bhi.n	20d0a <fsm_close+0x3e>
   20cf8:	f7df fb54 	bl	3a4 <__gnu_thumb1_case_uqi>
   20cfc:	07080705 	.word	0x07080705
   20d00:	0c0c0c0a 	.word	0x0c0c0c0a
   20d04:	0c          	.byte	0x0c
   20d05:	00          	.byte	0x00
	f->state = PPP_FSM_INITIAL;
   20d06:	2300      	movs	r3, #0
	f->state = PPP_FSM_CLOSING;
   20d08:	7423      	strb	r3, [r4, #16]
}
   20d0a:	bd70      	pop	{r4, r5, r6, pc}
	f->state = PPP_FSM_CLOSED;
   20d0c:	2302      	movs	r3, #2
   20d0e:	e7fb      	b.n	20d08 <fsm_close+0x3c>
	f->state = PPP_FSM_CLOSING;
   20d10:	2304      	movs	r3, #4
   20d12:	e7f9      	b.n	20d08 <fsm_close+0x3c>
	terminate_layer(f, PPP_FSM_CLOSING);
   20d14:	2104      	movs	r1, #4
   20d16:	0020      	movs	r0, r4
   20d18:	f7ff ff96 	bl	20c48 <terminate_layer>
}
   20d1c:	e7f5      	b.n	20d0a <fsm_close+0x3e>
	...

00020d20 <fsm_protreject>:
void fsm_protreject(fsm *f) {
   20d20:	b510      	push	{r4, lr}
   20d22:	0004      	movs	r4, r0
    switch( f->state ){
   20d24:	7c00      	ldrb	r0, [r0, #16]
   20d26:	3802      	subs	r0, #2
   20d28:	2807      	cmp	r0, #7
   20d2a:	d811      	bhi.n	20d50 <fsm_protreject+0x30>
   20d2c:	f7df fb3a 	bl	3a4 <__gnu_thumb1_case_uqi>
   20d30:	11041508 	.word	0x11041508
   20d34:	17111111 	.word	0x17111111
	UNTIMEOUT(fsm_timeout, f);	/* Cancel timeout */
   20d38:	0021      	movs	r1, r4
   20d3a:	480b      	ldr	r0, [pc, #44]	; (20d68 <fsm_protreject+0x48>)
   20d3c:	f001 fdfe 	bl	2293c <sys_untimeout>
	f->state = PPP_FSM_CLOSED;
   20d40:	2302      	movs	r3, #2
	f->state = PPP_FSM_STOPPED;
   20d42:	7423      	strb	r3, [r4, #16]
	if( f->callbacks->finished )
   20d44:	6863      	ldr	r3, [r4, #4]
   20d46:	6a9b      	ldr	r3, [r3, #40]	; 0x28
   20d48:	2b00      	cmp	r3, #0
   20d4a:	d001      	beq.n	20d50 <fsm_protreject+0x30>
	    (*f->callbacks->finished)(f);
   20d4c:	0020      	movs	r0, r4
   20d4e:	4798      	blx	r3
}
   20d50:	bd10      	pop	{r4, pc}
	UNTIMEOUT(fsm_timeout, f);	/* Cancel timeout */
   20d52:	0021      	movs	r1, r4
   20d54:	4804      	ldr	r0, [pc, #16]	; (20d68 <fsm_protreject+0x48>)
   20d56:	f001 fdf1 	bl	2293c <sys_untimeout>
	f->state = PPP_FSM_STOPPED;
   20d5a:	2303      	movs	r3, #3
   20d5c:	e7f1      	b.n	20d42 <fsm_protreject+0x22>
	terminate_layer(f, PPP_FSM_STOPPING);
   20d5e:	2105      	movs	r1, #5
   20d60:	0020      	movs	r0, r4
   20d62:	f7ff ff71 	bl	20c48 <terminate_layer>
}
   20d66:	e7f3      	b.n	20d50 <fsm_protreject+0x30>
   20d68:	00020b99 	.word	0x00020b99

00020d6c <fsm_input>:
void fsm_input(fsm *f, u_char *inpacket, int l) {
   20d6c:	b5f0      	push	{r4, r5, r6, r7, lr}
   20d6e:	0004      	movs	r4, r0
   20d70:	b087      	sub	sp, #28
   20d72:	000e      	movs	r6, r1
    if (l < HEADERLEN) {
   20d74:	2a03      	cmp	r2, #3
   20d76:	dd63      	ble.n	20e40 <fsm_input+0xd4>
   20d78:	78f3      	ldrb	r3, [r6, #3]
   20d7a:	7889      	ldrb	r1, [r1, #2]
   20d7c:	021b      	lsls	r3, r3, #8
   20d7e:	430b      	orrs	r3, r1
   20d80:	ba5b      	rev16	r3, r3
   20d82:	b29b      	uxth	r3, r3
   20d84:	9303      	str	r3, [sp, #12]
    if (len < HEADERLEN) {
   20d86:	2b03      	cmp	r3, #3
   20d88:	d95a      	bls.n	20e40 <fsm_input+0xd4>
    if (len > l) {
   20d8a:	429a      	cmp	r2, r3
   20d8c:	db58      	blt.n	20e40 <fsm_input+0xd4>
    if( f->state == PPP_FSM_INITIAL || f->state == PPP_FSM_STARTING ){
   20d8e:	7c03      	ldrb	r3, [r0, #16]
   20d90:	2b01      	cmp	r3, #1
   20d92:	d955      	bls.n	20e40 <fsm_input+0xd4>
    GETCHAR(id, inp);
   20d94:	7872      	ldrb	r2, [r6, #1]
    GETCHAR(code, inp);
   20d96:	7831      	ldrb	r1, [r6, #0]
    GETCHAR(id, inp);
   20d98:	9202      	str	r2, [sp, #8]
    len -= HEADERLEN;		/* subtract header length */
   20d9a:	9a03      	ldr	r2, [sp, #12]
    switch (code) {
   20d9c:	1e48      	subs	r0, r1, #1
    GETSHORT(len, inp);
   20d9e:	1d37      	adds	r7, r6, #4
    len -= HEADERLEN;		/* subtract header length */
   20da0:	1f15      	subs	r5, r2, #4
    switch (code) {
   20da2:	2806      	cmp	r0, #6
   20da4:	d900      	bls.n	20da8 <fsm_input+0x3c>
   20da6:	e15d      	b.n	21064 <fsm_input+0x2f8>
   20da8:	f7e0 fd3a 	bl	1820 <__gnu_thumb1_case_uhi>
   20dac:	005e0007 	.word	0x005e0007
   20db0:	00b000b0 	.word	0x00b000b0
   20db4:	013200fb 	.word	0x013200fb
   20db8:	014d      	.short	0x014d
    switch( f->state ){
   20dba:	1e98      	subs	r0, r3, #2
   20dbc:	9505      	str	r5, [sp, #20]
   20dbe:	2807      	cmp	r0, #7
   20dc0:	d815      	bhi.n	20dee <fsm_input+0x82>
   20dc2:	f7e0 fd2d 	bl	1820 <__gnu_thumb1_case_uhi>
   20dc6:	00f4      	.short	0x00f4
   20dc8:	003d000e 	.word	0x003d000e
   20dcc:	0014003d 	.word	0x0014003d
   20dd0:	00140014 	.word	0x00140014
   20dd4:	0008      	.short	0x0008
	if( f->callbacks->down )
   20dd6:	6863      	ldr	r3, [r4, #4]
   20dd8:	6a1b      	ldr	r3, [r3, #32]
   20dda:	2b00      	cmp	r3, #0
   20ddc:	d001      	beq.n	20de2 <fsm_input+0x76>
	    (*f->callbacks->down)(f);	/* Inform upper layers */
   20dde:	0020      	movs	r0, r4
   20de0:	4798      	blx	r3
	fsm_sconfreq(f, 0);		/* Send initial Configure-Request */
   20de2:	2100      	movs	r1, #0
   20de4:	0020      	movs	r0, r4
   20de6:	f7ff fda3 	bl	20930 <fsm_sconfreq>
	f->state = PPP_FSM_REQSENT;
   20dea:	2306      	movs	r3, #6
   20dec:	7423      	strb	r3, [r4, #16]
    if (f->callbacks->reqci){		/* Check CI */
   20dee:	6863      	ldr	r3, [r4, #4]
   20df0:	699d      	ldr	r5, [r3, #24]
   20df2:	2d00      	cmp	r5, #0
   20df4:	d026      	beq.n	20e44 <fsm_input+0xd8>
	reject_if_disagree = (f->nakloops >= f->maxnakloops);
   20df6:	2300      	movs	r3, #0
   20df8:	7d61      	ldrb	r1, [r4, #21]
   20dfa:	7de2      	ldrb	r2, [r4, #23]
	code = (*f->callbacks->reqci)(f, inp, &len, reject_if_disagree);
   20dfc:	0020      	movs	r0, r4
	reject_if_disagree = (f->nakloops >= f->maxnakloops);
   20dfe:	4291      	cmp	r1, r2
   20e00:	415b      	adcs	r3, r3
	code = (*f->callbacks->reqci)(f, inp, &len, reject_if_disagree);
   20e02:	aa05      	add	r2, sp, #20
   20e04:	0039      	movs	r1, r7
   20e06:	47a8      	blx	r5
   20e08:	0005      	movs	r5, r0
    fsm_sdata(f, code, id, inp, len);
   20e0a:	9b05      	ldr	r3, [sp, #20]
   20e0c:	b2e9      	uxtb	r1, r5
   20e0e:	9300      	str	r3, [sp, #0]
   20e10:	9a02      	ldr	r2, [sp, #8]
   20e12:	003b      	movs	r3, r7
   20e14:	0020      	movs	r0, r4
   20e16:	f7ff fe7c 	bl	20b12 <fsm_sdata>
   20e1a:	7c23      	ldrb	r3, [r4, #16]
    if (code == CONFACK) {
   20e1c:	2d02      	cmp	r5, #2
   20e1e:	d11a      	bne.n	20e56 <fsm_input+0xea>
	if (f->state == PPP_FSM_ACKRCVD) {
   20e20:	2b07      	cmp	r3, #7
   20e22:	d115      	bne.n	20e50 <fsm_input+0xe4>
	    UNTIMEOUT(fsm_timeout, f);	/* Cancel timeout */
   20e24:	0021      	movs	r1, r4
   20e26:	489b      	ldr	r0, [pc, #620]	; (21094 <fsm_input+0x328>)
   20e28:	f001 fd88 	bl	2293c <sys_untimeout>
	    f->state = PPP_FSM_OPENED;
   20e2c:	2309      	movs	r3, #9
   20e2e:	7423      	strb	r3, [r4, #16]
	    if (f->callbacks->up)
   20e30:	6863      	ldr	r3, [r4, #4]
   20e32:	69db      	ldr	r3, [r3, #28]
   20e34:	2b00      	cmp	r3, #0
   20e36:	d001      	beq.n	20e3c <fsm_input+0xd0>
		(*f->callbacks->up)(f);	/* Inform upper layers */
   20e38:	0020      	movs	r0, r4
   20e3a:	4798      	blx	r3
	f->nakloops = 0;
   20e3c:	2300      	movs	r3, #0
	    ++f->nakloops;
   20e3e:	7563      	strb	r3, [r4, #21]
}
   20e40:	b007      	add	sp, #28
   20e42:	bdf0      	pop	{r4, r5, r6, r7, pc}
    } else if (len)
   20e44:	9b05      	ldr	r3, [sp, #20]
	code = CONFACK;
   20e46:	2502      	movs	r5, #2
    } else if (len)
   20e48:	2b00      	cmp	r3, #0
   20e4a:	d0de      	beq.n	20e0a <fsm_input+0x9e>
	code = CONFREJ;			/* Reject all CI */
   20e4c:	196d      	adds	r5, r5, r5
   20e4e:	e7dc      	b.n	20e0a <fsm_input+0x9e>
	    f->state = PPP_FSM_ACKSENT;
   20e50:	2308      	movs	r3, #8
   20e52:	7423      	strb	r3, [r4, #16]
   20e54:	e7f2      	b.n	20e3c <fsm_input+0xd0>
	if (f->state != PPP_FSM_ACKRCVD)
   20e56:	2b07      	cmp	r3, #7
   20e58:	d001      	beq.n	20e5e <fsm_input+0xf2>
	    f->state = PPP_FSM_REQSENT;
   20e5a:	2306      	movs	r3, #6
   20e5c:	7423      	strb	r3, [r4, #16]
	if( code == CONFNAK )
   20e5e:	2d03      	cmp	r5, #3
   20e60:	d1ee      	bne.n	20e40 <fsm_input+0xd4>
	    ++f->nakloops;
   20e62:	7d63      	ldrb	r3, [r4, #21]
   20e64:	3301      	adds	r3, #1
   20e66:	e7ea      	b.n	20e3e <fsm_input+0xd2>
    if (id != f->reqid || f->seen_ack)		/* Expected id? */
   20e68:	7ce3      	ldrb	r3, [r4, #19]
   20e6a:	9a02      	ldr	r2, [sp, #8]
   20e6c:	4293      	cmp	r3, r2
   20e6e:	d1e7      	bne.n	20e40 <fsm_input+0xd4>
   20e70:	7b23      	ldrb	r3, [r4, #12]
   20e72:	2b00      	cmp	r3, #0
   20e74:	d1e4      	bne.n	20e40 <fsm_input+0xd4>
    if( !(f->callbacks->ackci? (*f->callbacks->ackci)(f, inp, len):
   20e76:	6863      	ldr	r3, [r4, #4]
    ppp_pcb *pcb = f->pcb;
   20e78:	6826      	ldr	r6, [r4, #0]
    if( !(f->callbacks->ackci? (*f->callbacks->ackci)(f, inp, len):
   20e7a:	68db      	ldr	r3, [r3, #12]
   20e7c:	2b00      	cmp	r3, #0
   20e7e:	d00e      	beq.n	20e9e <fsm_input+0x132>
   20e80:	002a      	movs	r2, r5
   20e82:	0039      	movs	r1, r7
   20e84:	0020      	movs	r0, r4
   20e86:	4798      	blx	r3
   20e88:	4243      	negs	r3, r0
   20e8a:	4158      	adcs	r0, r3
   20e8c:	b2c0      	uxtb	r0, r0
   20e8e:	2800      	cmp	r0, #0
   20e90:	d009      	beq.n	20ea6 <fsm_input+0x13a>
	ppp_error("Received bad configure-ack: %P", inp, len);
   20e92:	002a      	movs	r2, r5
   20e94:	0039      	movs	r1, r7
   20e96:	4880      	ldr	r0, [pc, #512]	; (21098 <fsm_input+0x32c>)
	    ppp_error("Received bad configure-nak: %P", inp, len);
   20e98:	f7fd fe86 	bl	1eba8 <ppp_error>
   20e9c:	e7d0      	b.n	20e40 <fsm_input+0xd4>
    if( !(f->callbacks->ackci? (*f->callbacks->ackci)(f, inp, len):
   20e9e:	0028      	movs	r0, r5
   20ea0:	1e43      	subs	r3, r0, #1
   20ea2:	4198      	sbcs	r0, r3
   20ea4:	e7f2      	b.n	20e8c <fsm_input+0x120>
    f->seen_ack = 1;
   20ea6:	2301      	movs	r3, #1
    f->rnakloops = 0;
   20ea8:	75a0      	strb	r0, [r4, #22]
    switch (f->state) {
   20eaa:	7c20      	ldrb	r0, [r4, #16]
    f->seen_ack = 1;
   20eac:	7323      	strb	r3, [r4, #12]
    switch (f->state) {
   20eae:	3802      	subs	r0, #2
   20eb0:	2807      	cmp	r0, #7
   20eb2:	d8c5      	bhi.n	20e40 <fsm_input+0xd4>
   20eb4:	f7e0 fca0 	bl	17f8 <__gnu_thumb1_case_sqi>
   20eb8:	c4c47b7b 	.word	0xc4c47b7b
   20ebc:	23140904 	.word	0x23140904
	f->state = PPP_FSM_ACKRCVD;
   20ec0:	2307      	movs	r3, #7
   20ec2:	7423      	strb	r3, [r4, #16]
	f->retransmits = pcb->settings.fsm_max_conf_req_transmits;
   20ec4:	7973      	ldrb	r3, [r6, #5]
   20ec6:	7523      	strb	r3, [r4, #20]
   20ec8:	e7ba      	b.n	20e40 <fsm_input+0xd4>
	UNTIMEOUT(fsm_timeout, f);	/* Cancel timeout */
   20eca:	0021      	movs	r1, r4
   20ecc:	4871      	ldr	r0, [pc, #452]	; (21094 <fsm_input+0x328>)
   20ece:	f001 fd35 	bl	2293c <sys_untimeout>
	fsm_sconfreq(f, 0);		/* Send initial Configure-Request */
   20ed2:	2100      	movs	r1, #0
   20ed4:	0020      	movs	r0, r4
   20ed6:	f7ff fd2b 	bl	20930 <fsm_sconfreq>
	f->state = PPP_FSM_REQSENT;
   20eda:	2306      	movs	r3, #6
   20edc:	7423      	strb	r3, [r4, #16]
   20ede:	e7af      	b.n	20e40 <fsm_input+0xd4>
	UNTIMEOUT(fsm_timeout, f);	/* Cancel timeout */
   20ee0:	0021      	movs	r1, r4
   20ee2:	486c      	ldr	r0, [pc, #432]	; (21094 <fsm_input+0x328>)
   20ee4:	f001 fd2a 	bl	2293c <sys_untimeout>
	f->state = PPP_FSM_OPENED;
   20ee8:	2309      	movs	r3, #9
   20eea:	7423      	strb	r3, [r4, #16]
	f->retransmits = pcb->settings.fsm_max_conf_req_transmits;
   20eec:	7973      	ldrb	r3, [r6, #5]
   20eee:	7523      	strb	r3, [r4, #20]
	if (f->callbacks->up)
   20ef0:	6863      	ldr	r3, [r4, #4]
   20ef2:	69db      	ldr	r3, [r3, #28]
	if( f->callbacks->finished )
   20ef4:	2b00      	cmp	r3, #0
   20ef6:	d0a3      	beq.n	20e40 <fsm_input+0xd4>
	    (*f->callbacks->finished)(f);
   20ef8:	0020      	movs	r0, r4
   20efa:	4798      	blx	r3
   20efc:	e7a0      	b.n	20e40 <fsm_input+0xd4>
	if (f->callbacks->down)
   20efe:	6863      	ldr	r3, [r4, #4]
   20f00:	6a1b      	ldr	r3, [r3, #32]
   20f02:	2b00      	cmp	r3, #0
   20f04:	d0e5      	beq.n	20ed2 <fsm_input+0x166>
	    (*f->callbacks->down)(f);	/* Inform upper layers */
   20f06:	0020      	movs	r0, r4
   20f08:	4798      	blx	r3
   20f0a:	e7e2      	b.n	20ed2 <fsm_input+0x166>
    if (id != f->reqid || f->seen_ack)	/* Expected id? */
   20f0c:	7ce3      	ldrb	r3, [r4, #19]
   20f0e:	9a02      	ldr	r2, [sp, #8]
   20f10:	4293      	cmp	r3, r2
   20f12:	d195      	bne.n	20e40 <fsm_input+0xd4>
   20f14:	7b23      	ldrb	r3, [r4, #12]
   20f16:	2b00      	cmp	r3, #0
   20f18:	d000      	beq.n	20f1c <fsm_input+0x1b0>
   20f1a:	e791      	b.n	20e40 <fsm_input+0xd4>
   20f1c:	6860      	ldr	r0, [r4, #4]
    if (code == CONFNAK) {
   20f1e:	2903      	cmp	r1, #3
   20f20:	d124      	bne.n	20f6c <fsm_input+0x200>
	++f->rnakloops;
   20f22:	7da2      	ldrb	r2, [r4, #22]
	treat_as_reject = (f->rnakloops >= f->maxnakloops);
   20f24:	7de1      	ldrb	r1, [r4, #23]
	++f->rnakloops;
   20f26:	3201      	adds	r2, #1
   20f28:	b2d2      	uxtb	r2, r2
   20f2a:	75a2      	strb	r2, [r4, #22]
	if (f->callbacks->nakci == NULL
   20f2c:	6906      	ldr	r6, [r0, #16]
	treat_as_reject = (f->rnakloops >= f->maxnakloops);
   20f2e:	428a      	cmp	r2, r1
   20f30:	415b      	adcs	r3, r3
	if (f->callbacks->nakci == NULL
   20f32:	2e00      	cmp	r6, #0
   20f34:	d103      	bne.n	20f3e <fsm_input+0x1d2>
	    ppp_error("Received bad configure-nak: %P", inp, len);
   20f36:	002a      	movs	r2, r5
   20f38:	0039      	movs	r1, r7
   20f3a:	4858      	ldr	r0, [pc, #352]	; (2109c <fsm_input+0x330>)
   20f3c:	e7ac      	b.n	20e98 <fsm_input+0x12c>
	    || !(ret = f->callbacks->nakci(f, inp, len, treat_as_reject))) {
   20f3e:	002a      	movs	r2, r5
   20f40:	0039      	movs	r1, r7
   20f42:	0020      	movs	r0, r4
   20f44:	47b0      	blx	r6
   20f46:	1e06      	subs	r6, r0, #0
   20f48:	d0f5      	beq.n	20f36 <fsm_input+0x1ca>
    f->seen_ack = 1;
   20f4a:	2301      	movs	r3, #1
    switch (f->state) {
   20f4c:	7c20      	ldrb	r0, [r4, #16]
    f->seen_ack = 1;
   20f4e:	7323      	strb	r3, [r4, #12]
    switch (f->state) {
   20f50:	3802      	subs	r0, #2
   20f52:	2807      	cmp	r0, #7
   20f54:	d900      	bls.n	20f58 <fsm_input+0x1ec>
   20f56:	e773      	b.n	20e40 <fsm_input+0xd4>
   20f58:	f7e0 fc58 	bl	180c <__gnu_thumb1_case_shi>
   20f5c:	00290029 	.word	0x00290029
   20f60:	ff72ff72 	.word	0xff72ff72
   20f64:	ffb70017 	.word	0xffb70017
   20f68:	ffd10017 	.word	0xffd10017
	f->rnakloops = 0;
   20f6c:	75a3      	strb	r3, [r4, #22]
	if (f->callbacks->rejci == NULL
   20f6e:	6943      	ldr	r3, [r0, #20]
   20f70:	2b00      	cmp	r3, #0
   20f72:	d103      	bne.n	20f7c <fsm_input+0x210>
	    ppp_error("Received bad configure-rej: %P", inp, len);
   20f74:	002a      	movs	r2, r5
   20f76:	0039      	movs	r1, r7
   20f78:	4849      	ldr	r0, [pc, #292]	; (210a0 <fsm_input+0x334>)
   20f7a:	e78d      	b.n	20e98 <fsm_input+0x12c>
	    || !(ret = f->callbacks->rejci(f, inp, len))) {
   20f7c:	002a      	movs	r2, r5
   20f7e:	0039      	movs	r1, r7
   20f80:	0020      	movs	r0, r4
   20f82:	4798      	blx	r3
   20f84:	1e06      	subs	r6, r0, #0
   20f86:	d1e0      	bne.n	20f4a <fsm_input+0x1de>
   20f88:	e7f4      	b.n	20f74 <fsm_input+0x208>
	UNTIMEOUT(fsm_timeout, f);	/* Cancel timeout */
   20f8a:	0021      	movs	r1, r4
   20f8c:	4841      	ldr	r0, [pc, #260]	; (21094 <fsm_input+0x328>)
   20f8e:	f001 fcd5 	bl	2293c <sys_untimeout>
	    f->state = PPP_FSM_STOPPED;		/* kludge for stopping CCP */
   20f92:	2303      	movs	r3, #3
	if (ret < 0)
   20f94:	2e00      	cmp	r6, #0
   20f96:	dba1      	blt.n	20edc <fsm_input+0x170>
	    fsm_sconfreq(f, 0);		/* Send Configure-Request */
   20f98:	2100      	movs	r1, #0
   20f9a:	0020      	movs	r0, r4
   20f9c:	f7ff fcc8 	bl	20930 <fsm_sconfreq>
   20fa0:	e74e      	b.n	20e40 <fsm_input+0xd4>
    switch (f->state) {
   20fa2:	2b07      	cmp	r3, #7
   20fa4:	d303      	bcc.n	20fae <fsm_input+0x242>
   20fa6:	2b08      	cmp	r3, #8
   20fa8:	d909      	bls.n	20fbe <fsm_input+0x252>
   20faa:	2b09      	cmp	r3, #9
   20fac:	d00a      	beq.n	20fc4 <fsm_input+0x258>
    fsm_sdata(f, TERMACK, id, NULL, 0);
   20fae:	2300      	movs	r3, #0
   20fb0:	2106      	movs	r1, #6
   20fb2:	9a02      	ldr	r2, [sp, #8]
   20fb4:	9300      	str	r3, [sp, #0]
	    fsm_sdata(f, CODEREJ, ++f->id, inpacket, len + HEADERLEN);
   20fb6:	0020      	movs	r0, r4
   20fb8:	f7ff fdab 	bl	20b12 <fsm_sdata>
   20fbc:	e740      	b.n	20e40 <fsm_input+0xd4>
	f->state = PPP_FSM_REQSENT;		/* Start over but keep trying */
   20fbe:	2306      	movs	r3, #6
   20fc0:	7423      	strb	r3, [r4, #16]
   20fc2:	e7f4      	b.n	20fae <fsm_input+0x242>
   20fc4:	6863      	ldr	r3, [r4, #4]
    ppp_pcb *pcb = f->pcb;
   20fc6:	6826      	ldr	r6, [r4, #0]
   20fc8:	6b99      	ldr	r1, [r3, #56]	; 0x38
	if (len > 0) {
   20fca:	2d00      	cmp	r5, #0
   20fcc:	d01c      	beq.n	21008 <fsm_input+0x29c>
	    ppp_info("%s terminated by peer (%0.*v)", PROTO_NAME(f), len, p);
   20fce:	003b      	movs	r3, r7
   20fd0:	002a      	movs	r2, r5
   20fd2:	4834      	ldr	r0, [pc, #208]	; (210a4 <fsm_input+0x338>)
   20fd4:	f7fd fe0c 	bl	1ebf0 <ppp_info>
	f->retransmits = 0;
   20fd8:	2300      	movs	r3, #0
   20fda:	7523      	strb	r3, [r4, #20]
	f->state = PPP_FSM_STOPPING;
   20fdc:	3305      	adds	r3, #5
   20fde:	7423      	strb	r3, [r4, #16]
	if (f->callbacks->down)
   20fe0:	6863      	ldr	r3, [r4, #4]
   20fe2:	6a1b      	ldr	r3, [r3, #32]
   20fe4:	2b00      	cmp	r3, #0
   20fe6:	d001      	beq.n	20fec <fsm_input+0x280>
	    (*f->callbacks->down)(f);	/* Inform upper layers */
   20fe8:	0020      	movs	r0, r4
   20fea:	4798      	blx	r3
	TIMEOUT(fsm_timeout, f, pcb->settings.fsm_timeout_time);
   20fec:	4d29      	ldr	r5, [pc, #164]	; (21094 <fsm_input+0x328>)
   20fee:	0021      	movs	r1, r4
   20ff0:	0028      	movs	r0, r5
   20ff2:	f001 fca3 	bl	2293c <sys_untimeout>
   20ff6:	20fa      	movs	r0, #250	; 0xfa
   20ff8:	7933      	ldrb	r3, [r6, #4]
   20ffa:	0080      	lsls	r0, r0, #2
   20ffc:	4358      	muls	r0, r3
   20ffe:	0022      	movs	r2, r4
   21000:	0029      	movs	r1, r5
   21002:	f001 fc39 	bl	22878 <sys_timeout>
   21006:	e7d2      	b.n	20fae <fsm_input+0x242>
	    ppp_info("%s terminated by peer", PROTO_NAME(f));
   21008:	4827      	ldr	r0, [pc, #156]	; (210a8 <fsm_input+0x33c>)
   2100a:	f7fd fdf1 	bl	1ebf0 <ppp_info>
   2100e:	e7e3      	b.n	20fd8 <fsm_input+0x26c>
    switch (f->state) {
   21010:	1f18      	subs	r0, r3, #4
   21012:	2805      	cmp	r0, #5
   21014:	d900      	bls.n	21018 <fsm_input+0x2ac>
   21016:	e713      	b.n	20e40 <fsm_input+0xd4>
   21018:	f7e0 fbf8 	bl	180c <__gnu_thumb1_case_shi>
   2101c:	000f0006 	.word	0x000f0006
   21020:	ff5fff12 	.word	0xff5fff12
   21024:	ff71ff12 	.word	0xff71ff12
	UNTIMEOUT(fsm_timeout, f);
   21028:	0021      	movs	r1, r4
   2102a:	481a      	ldr	r0, [pc, #104]	; (21094 <fsm_input+0x328>)
   2102c:	f001 fc86 	bl	2293c <sys_untimeout>
	f->state = PPP_FSM_CLOSED;
   21030:	2302      	movs	r3, #2
	f->state = PPP_FSM_STOPPED;
   21032:	7423      	strb	r3, [r4, #16]
	if( f->callbacks->finished )
   21034:	6863      	ldr	r3, [r4, #4]
   21036:	6a9b      	ldr	r3, [r3, #40]	; 0x28
   21038:	e75c      	b.n	20ef4 <fsm_input+0x188>
	UNTIMEOUT(fsm_timeout, f);
   2103a:	0021      	movs	r1, r4
   2103c:	4815      	ldr	r0, [pc, #84]	; (21094 <fsm_input+0x328>)
   2103e:	f001 fc7d 	bl	2293c <sys_untimeout>
	f->state = PPP_FSM_STOPPED;
   21042:	2303      	movs	r3, #3
   21044:	e7f5      	b.n	21032 <fsm_input+0x2c6>
    if (len < HEADERLEN) {
   21046:	2d03      	cmp	r5, #3
   21048:	dc00      	bgt.n	2104c <fsm_input+0x2e0>
   2104a:	e6f9      	b.n	20e40 <fsm_input+0xd4>
    ppp_warn("%s: Rcvd Code-Reject for code %d, id %d", PROTO_NAME(f), code, id);
   2104c:	6861      	ldr	r1, [r4, #4]
   2104e:	7973      	ldrb	r3, [r6, #5]
   21050:	7932      	ldrb	r2, [r6, #4]
   21052:	6b89      	ldr	r1, [r1, #56]	; 0x38
   21054:	4815      	ldr	r0, [pc, #84]	; (210ac <fsm_input+0x340>)
   21056:	f7fd fdb3 	bl	1ebc0 <ppp_warn>
    if( f->state == PPP_FSM_ACKRCVD )
   2105a:	7c23      	ldrb	r3, [r4, #16]
   2105c:	2b07      	cmp	r3, #7
   2105e:	d000      	beq.n	21062 <fsm_input+0x2f6>
   21060:	e6ee      	b.n	20e40 <fsm_input+0xd4>
   21062:	e73a      	b.n	20eda <fsm_input+0x16e>
	if( !f->callbacks->extcode
   21064:	6863      	ldr	r3, [r4, #4]
   21066:	6b5b      	ldr	r3, [r3, #52]	; 0x34
   21068:	469c      	mov	ip, r3
   2106a:	2b00      	cmp	r3, #0
   2106c:	d108      	bne.n	21080 <fsm_input+0x314>
	    fsm_sdata(f, CODEREJ, ++f->id, inpacket, len + HEADERLEN);
   2106e:	7ca2      	ldrb	r2, [r4, #18]
   21070:	9b03      	ldr	r3, [sp, #12]
   21072:	3201      	adds	r2, #1
   21074:	b2d2      	uxtb	r2, r2
   21076:	9300      	str	r3, [sp, #0]
   21078:	74a2      	strb	r2, [r4, #18]
   2107a:	0033      	movs	r3, r6
   2107c:	2107      	movs	r1, #7
   2107e:	e79a      	b.n	20fb6 <fsm_input+0x24a>
	   || !(*f->callbacks->extcode)(f, code, id, inp, len) )
   21080:	9500      	str	r5, [sp, #0]
   21082:	003b      	movs	r3, r7
   21084:	9a02      	ldr	r2, [sp, #8]
   21086:	0020      	movs	r0, r4
   21088:	4665      	mov	r5, ip
   2108a:	47a8      	blx	r5
   2108c:	2800      	cmp	r0, #0
   2108e:	d0ee      	beq.n	2106e <fsm_input+0x302>
   21090:	e6d6      	b.n	20e40 <fsm_input+0xd4>
   21092:	46c0      	nop			; (mov r8, r8)
   21094:	00020b99 	.word	0x00020b99
   21098:	0002600a 	.word	0x0002600a
   2109c:	00026029 	.word	0x00026029
   210a0:	00026048 	.word	0x00026048
   210a4:	00026067 	.word	0x00026067
   210a8:	00026085 	.word	0x00026085
   210ac:	0002609b 	.word	0x0002609b

000210b0 <osMuxInit>:
    UINT32   uwIndex;

    LOS_ListInit(&g_stUnusedMuxList);
    if (LOSCFG_BASE_IPC_MUX_LIMIT > 0)   /*lint !e506*/
    {
        g_pstAllMux = (MUX_CB_S *)LOS_MemAlloc(m_aucSysMem0, (LOSCFG_BASE_IPC_MUX_LIMIT * sizeof(MUX_CB_S)));
   210b0:	21cc      	movs	r1, #204	; 0xcc
{
   210b2:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
        g_pstAllMux = (MUX_CB_S *)LOS_MemAlloc(m_aucSysMem0, (LOSCFG_BASE_IPC_MUX_LIMIT * sizeof(MUX_CB_S)));
   210b4:	4b12      	ldr	r3, [pc, #72]	; (21100 <osMuxInit+0x50>)
    pstList->pstNext = pstList;
   210b6:	4c13      	ldr	r4, [pc, #76]	; (21104 <osMuxInit+0x54>)
   210b8:	0049      	lsls	r1, r1, #1
   210ba:	6818      	ldr	r0, [r3, #0]
   210bc:	6064      	str	r4, [r4, #4]
    pstList->pstPrev = pstList;
   210be:	6024      	str	r4, [r4, #0]
   210c0:	f7f1 fd10 	bl	12ae4 <LOS_MemAlloc>
   210c4:	4d10      	ldr	r5, [pc, #64]	; (21108 <osMuxInit+0x58>)
   210c6:	6028      	str	r0, [r5, #0]
        if (NULL == g_pstAllMux)
   210c8:	2800      	cmp	r0, #0
   210ca:	d017      	beq.n	210fc <osMuxInit+0x4c>
        {
            return LOS_ERRNO_MUX_NO_MEMORY;
        }

        for (uwIndex = 0; uwIndex < LOSCFG_BASE_IPC_MUX_LIMIT; uwIndex++)
   210cc:	2200      	movs	r2, #0
        {
            pstMuxNode              = ((MUX_CB_S *)g_pstAllMux) + uwIndex;
   210ce:	2718      	movs	r7, #24
            pstMuxNode->ucMuxID     = uwIndex;
            pstMuxNode->ucMuxStat   = OS_MUX_UNUSED;
   210d0:	4694      	mov	ip, r2
            pstMuxNode              = ((MUX_CB_S *)g_pstAllMux) + uwIndex;
   210d2:	003b      	movs	r3, r7
   210d4:	4353      	muls	r3, r2
   210d6:	6829      	ldr	r1, [r5, #0]
   210d8:	18cb      	adds	r3, r1, r3
            pstMuxNode->ucMuxStat   = OS_MUX_UNUSED;
   210da:	4661      	mov	r1, ip
            LOS_ListTailInsert(&g_stUnusedMuxList, &pstMuxNode->stMuxList);
   210dc:	0018      	movs	r0, r3
            pstMuxNode->ucMuxStat   = OS_MUX_UNUSED;
   210de:	7019      	strb	r1, [r3, #0]
   210e0:	6821      	ldr	r1, [r4, #0]
            pstMuxNode->ucMuxID     = uwIndex;
   210e2:	605a      	str	r2, [r3, #4]
    pstNode->pstNext = pstList->pstNext;
   210e4:	684e      	ldr	r6, [r1, #4]
    pstNode->pstPrev = pstList;
   210e6:	6099      	str	r1, [r3, #8]
    pstNode->pstNext = pstList->pstNext;
   210e8:	60de      	str	r6, [r3, #12]
    pstList->pstNext->pstPrev = pstNode;
   210ea:	684b      	ldr	r3, [r1, #4]
            LOS_ListTailInsert(&g_stUnusedMuxList, &pstMuxNode->stMuxList);
   210ec:	3008      	adds	r0, #8
        for (uwIndex = 0; uwIndex < LOSCFG_BASE_IPC_MUX_LIMIT; uwIndex++)
   210ee:	3201      	adds	r2, #1
   210f0:	6018      	str	r0, [r3, #0]
    pstList->pstNext = pstNode;
   210f2:	6048      	str	r0, [r1, #4]
   210f4:	2a11      	cmp	r2, #17
   210f6:	d1ec      	bne.n	210d2 <osMuxInit+0x22>
        }
    }
    return LOS_OK;
   210f8:	2000      	movs	r0, #0
}
   210fa:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
            return LOS_ERRNO_MUX_NO_MEMORY;
   210fc:	4803      	ldr	r0, [pc, #12]	; (2110c <osMuxInit+0x5c>)
   210fe:	e7fc      	b.n	210fa <osMuxInit+0x4a>
   21100:	01002e40 	.word	0x01002e40
   21104:	01002f14 	.word	0x01002f14
   21108:	01002f10 	.word	0x01002f10
   2110c:	02001d00 	.word	0x02001d00

00021110 <LOS_MuxCreate>:
 Input        : None
 Output       : puwMuxHandle ------ Mutex operation handle
 Return       : LOS_OK on success ,or error code on failure
 *****************************************************************************/
LITE_OS_SEC_TEXT_INIT  UINT32  LOS_MuxCreate (UINT32 *puwMuxHandle)
{
   21110:	b537      	push	{r0, r1, r2, r4, r5, lr}
   21112:	1e05      	subs	r5, r0, #0
    MUX_CB_S    *pstMuxCreated;
    LOS_DL_LIST *pstUnusedMux;
    UINT32      uwErrNo;
    UINT32      uwErrLine;

    if (NULL == puwMuxHandle)
   21114:	d026      	beq.n	21164 <LOS_MuxCreate+0x54>
    {
        return LOS_ERRNO_MUX_PTR_NULL;
    }

    uwIntSave = LOS_IntLock();
   21116:	f7df f822 	bl	15e <LOS_IntLock>
    return (BOOL)(pstList->pstNext == pstList);
   2111a:	4a13      	ldr	r2, [pc, #76]	; (21168 <LOS_MuxCreate+0x58>)
   2111c:	6853      	ldr	r3, [r2, #4]
    if (LOS_ListEmpty(&g_stUnusedMuxList))
   2111e:	4293      	cmp	r3, r2
   21120:	d10a      	bne.n	21138 <LOS_MuxCreate+0x28>
    {
        LOS_IntRestore(uwIntSave);
   21122:	f7df f824 	bl	16e <LOS_IntRestore>
    LOS_ListInit(&pstMuxCreated->stMuxList);
    *puwMuxHandle               = (UINT32)pstMuxCreated->ucMuxID;
    LOS_IntRestore(uwIntSave);
    return LOS_OK;
ErrHandler:
    OS_RETURN_ERROR_P2(uwErrLine, uwErrNo);
   21126:	2300      	movs	r3, #0
   21128:	4a10      	ldr	r2, [pc, #64]	; (2116c <LOS_MuxCreate+0x5c>)
   2112a:	9300      	str	r3, [sp, #0]
   2112c:	4910      	ldr	r1, [pc, #64]	; (21170 <LOS_MuxCreate+0x60>)
   2112e:	4811      	ldr	r0, [pc, #68]	; (21174 <LOS_MuxCreate+0x64>)
   21130:	f000 fa9e 	bl	21670 <LOS_ErrHandle>
   21134:	480d      	ldr	r0, [pc, #52]	; (2116c <LOS_MuxCreate+0x5c>)
}
   21136:	bd3e      	pop	{r1, r2, r3, r4, r5, pc}
    pstNode->pstNext->pstPrev = pstNode->pstPrev;
   21138:	685a      	ldr	r2, [r3, #4]
   2113a:	6819      	ldr	r1, [r3, #0]
    pstMuxCreated->usMuxCount   = 0;
   2113c:	2400      	movs	r4, #0
   2113e:	6011      	str	r1, [r2, #0]
    pstNode->pstPrev->pstNext = pstNode->pstNext;
   21140:	681a      	ldr	r2, [r3, #0]
   21142:	6859      	ldr	r1, [r3, #4]
   21144:	6051      	str	r1, [r2, #4]
   21146:	001a      	movs	r2, r3
    pstMuxCreated->ucMuxStat    = OS_MUX_USED;
   21148:	2101      	movs	r1, #1
    pstMuxCreated->usMuxCount   = 0;
   2114a:	3a08      	subs	r2, #8
   2114c:	8054      	strh	r4, [r2, #2]
    pstMuxCreated->ucMuxStat    = OS_MUX_USED;
   2114e:	7011      	strb	r1, [r2, #0]
    pstMuxCreated->usPriority   = 0;
   21150:	8294      	strh	r4, [r2, #20]
    pstMuxCreated->pstOwner     = (LOS_TASK_CB *)NULL;
   21152:	6114      	str	r4, [r2, #16]
    pstList->pstNext = pstList;
   21154:	605b      	str	r3, [r3, #4]
    pstList->pstPrev = pstList;
   21156:	601b      	str	r3, [r3, #0]
    *puwMuxHandle               = (UINT32)pstMuxCreated->ucMuxID;
   21158:	6853      	ldr	r3, [r2, #4]
   2115a:	602b      	str	r3, [r5, #0]
    LOS_IntRestore(uwIntSave);
   2115c:	f7df f807 	bl	16e <LOS_IntRestore>
    return LOS_OK;
   21160:	0020      	movs	r0, r4
   21162:	e7e8      	b.n	21136 <LOS_MuxCreate+0x26>
        return LOS_ERRNO_MUX_PTR_NULL;
   21164:	4804      	ldr	r0, [pc, #16]	; (21178 <LOS_MuxCreate+0x68>)
   21166:	e7e6      	b.n	21136 <LOS_MuxCreate+0x26>
   21168:	01002f14 	.word	0x01002f14
   2116c:	02001d03 	.word	0x02001d03
   21170:	a1b2c3f8 	.word	0xa1b2c3f8
   21174:	000260e7 	.word	0x000260e7
   21178:	02001d02 	.word	0x02001d02

0002117c <LOS_MuxDelete>:
 Input        : uwMuxHandle------Mutex operation handle
 Output       : None
 Return       : LOS_OK on success ,or error code on failure
 *****************************************************************************/
LITE_OS_SEC_TEXT_INIT UINT32 LOS_MuxDelete(UINT32 uwMuxHandle)
{
   2117c:	b537      	push	{r0, r1, r2, r4, r5, lr}
    UINT32    uwIntSave;
    MUX_CB_S *pstMuxDeleted;
    UINT32   uwErrNo;
    UINT32   uwErrLine;

    if (uwMuxHandle >= (UINT32)LOSCFG_BASE_IPC_MUX_LIMIT)
   2117e:	2810      	cmp	r0, #16
   21180:	d80b      	bhi.n	2119a <LOS_MuxDelete+0x1e>
    {
        OS_GOTO_ERR_HANDLER(LOS_ERRNO_MUX_INVALID);
    }

    pstMuxDeleted = GET_MUX(uwMuxHandle);
   21182:	2518      	movs	r5, #24
   21184:	4b15      	ldr	r3, [pc, #84]	; (211dc <LOS_MuxDelete+0x60>)
   21186:	4368      	muls	r0, r5
   21188:	681d      	ldr	r5, [r3, #0]
   2118a:	182d      	adds	r5, r5, r0
    uwIntSave = LOS_IntLock();
   2118c:	f7de ffe7 	bl	15e <LOS_IntLock>
    if (OS_MUX_UNUSED == pstMuxDeleted->ucMuxStat)
   21190:	782b      	ldrb	r3, [r5, #0]
   21192:	2b00      	cmp	r3, #0
   21194:	d103      	bne.n	2119e <LOS_MuxDelete+0x22>
    {
        LOS_IntRestore(uwIntSave);
   21196:	f7de ffea 	bl	16e <LOS_IntRestore>
        OS_GOTO_ERR_HANDLER(LOS_ERRNO_MUX_INVALID);
   2119a:	4c11      	ldr	r4, [pc, #68]	; (211e0 <LOS_MuxDelete+0x64>)
   2119c:	e00a      	b.n	211b4 <LOS_MuxDelete+0x38>
        OS_GOTO_ERR_HANDLER(LOS_ERRNO_MUX_INVALID);
    }

    if (!LOS_ListEmpty(&pstMuxDeleted->stMuxList) || pstMuxDeleted->usMuxCount)
   2119e:	002a      	movs	r2, r5
   211a0:	68eb      	ldr	r3, [r5, #12]
   211a2:	3208      	adds	r2, #8
   211a4:	429a      	cmp	r2, r3
   211a6:	d102      	bne.n	211ae <LOS_MuxDelete+0x32>
   211a8:	886c      	ldrh	r4, [r5, #2]
   211aa:	2c00      	cmp	r4, #0
   211ac:	d00a      	beq.n	211c4 <LOS_MuxDelete+0x48>
    {
        LOS_IntRestore(uwIntSave);
   211ae:	f7de ffde 	bl	16e <LOS_IntRestore>
        OS_GOTO_ERR_HANDLER(LOS_ERRNO_MUX_PENDED);
   211b2:	4c0c      	ldr	r4, [pc, #48]	; (211e4 <LOS_MuxDelete+0x68>)

    LOS_IntRestore(uwIntSave);

    return LOS_OK;
ErrHandler:
    OS_RETURN_ERROR_P2(uwErrLine, uwErrNo);
   211b4:	2300      	movs	r3, #0
   211b6:	0022      	movs	r2, r4
   211b8:	9300      	str	r3, [sp, #0]
   211ba:	490b      	ldr	r1, [pc, #44]	; (211e8 <LOS_MuxDelete+0x6c>)
   211bc:	480b      	ldr	r0, [pc, #44]	; (211ec <LOS_MuxDelete+0x70>)
   211be:	f000 fa57 	bl	21670 <LOS_ErrHandle>
   211c2:	e008      	b.n	211d6 <LOS_MuxDelete+0x5a>
    pstNode->pstNext = pstList->pstNext;
   211c4:	4b0a      	ldr	r3, [pc, #40]	; (211f0 <LOS_MuxDelete+0x74>)
   211c6:	6859      	ldr	r1, [r3, #4]
    pstNode->pstPrev = pstList;
   211c8:	60ab      	str	r3, [r5, #8]
    pstNode->pstNext = pstList->pstNext;
   211ca:	60e9      	str	r1, [r5, #12]
    pstList->pstNext->pstPrev = pstNode;
   211cc:	600a      	str	r2, [r1, #0]
    pstList->pstNext = pstNode;
   211ce:	605a      	str	r2, [r3, #4]
    pstMuxDeleted->ucMuxStat = OS_MUX_UNUSED;
   211d0:	702c      	strb	r4, [r5, #0]
    LOS_IntRestore(uwIntSave);
   211d2:	f7de ffcc 	bl	16e <LOS_IntRestore>
}
   211d6:	0020      	movs	r0, r4
   211d8:	bd3e      	pop	{r1, r2, r3, r4, r5, pc}
   211da:	46c0      	nop			; (mov r8, r8)
   211dc:	01002f10 	.word	0x01002f10
   211e0:	02001d01 	.word	0x02001d01
   211e4:	02001d09 	.word	0x02001d09
   211e8:	a1b2c3f8 	.word	0xa1b2c3f8
   211ec:	000260e7 	.word	0x000260e7
   211f0:	01002f14 	.word	0x01002f14

000211f4 <LOS_MuxPend>:
 		       uwTimeOut  ------- waiting time,
 Output       : None
 Return       : LOS_OK on success ,or error code on failure
 *****************************************************************************/
LITE_OS_SEC_TEXT UINT32 LOS_MuxPend(UINT32 uwMuxHandle, UINT32 uwTimeout)
{
   211f4:	b5f0      	push	{r4, r5, r6, r7, lr}
   211f6:	000f      	movs	r7, r1
   211f8:	b085      	sub	sp, #20
    UINT32     uwIntSave;
    MUX_CB_S  *pstMuxPended;
    UINT32     uwRetErr;
    LOS_TASK_CB  *pstRunTsk;

    if (uwMuxHandle >= (UINT32)LOSCFG_BASE_IPC_MUX_LIMIT)
   211fa:	2810      	cmp	r0, #16
   211fc:	d90a      	bls.n	21214 <LOS_MuxPend+0x20>
    {
        OS_RETURN_ERROR(LOS_ERRNO_MUX_INVALID);
   211fe:	2300      	movs	r3, #0
   21200:	9300      	str	r3, [sp, #0]
    pstMuxPended = GET_MUX(uwMuxHandle);
    uwIntSave = LOS_IntLock();
    if (OS_MUX_UNUSED == pstMuxPended->ucMuxStat)
    {
        LOS_IntRestore(uwIntSave);
        OS_RETURN_ERROR(LOS_ERRNO_MUX_INVALID);
   21202:	4a39      	ldr	r2, [pc, #228]	; (212e8 <LOS_MuxPend+0xf4>)
   21204:	4939      	ldr	r1, [pc, #228]	; (212ec <LOS_MuxPend+0xf8>)
   21206:	483a      	ldr	r0, [pc, #232]	; (212f0 <LOS_MuxPend+0xfc>)
   21208:	f000 fa32 	bl	21670 <LOS_ErrHandle>
   2120c:	4c36      	ldr	r4, [pc, #216]	; (212e8 <LOS_MuxPend+0xf4>)

errre_uniMuxPend:
    (VOID)LOS_IntRestore(uwIntSave);
error_uniMuxPend:
    OS_RETURN_ERROR(uwRetErr);
}
   2120e:	0020      	movs	r0, r4
   21210:	b005      	add	sp, #20
   21212:	bdf0      	pop	{r4, r5, r6, r7, pc}
    pstMuxPended = GET_MUX(uwMuxHandle);
   21214:	2418      	movs	r4, #24
   21216:	4b37      	ldr	r3, [pc, #220]	; (212f4 <LOS_MuxPend+0x100>)
   21218:	4360      	muls	r0, r4
   2121a:	681c      	ldr	r4, [r3, #0]
   2121c:	1824      	adds	r4, r4, r0
    uwIntSave = LOS_IntLock();
   2121e:	f7de ff9e 	bl	15e <LOS_IntLock>
    if (OS_MUX_UNUSED == pstMuxPended->ucMuxStat)
   21222:	7825      	ldrb	r5, [r4, #0]
    uwIntSave = LOS_IntLock();
   21224:	0006      	movs	r6, r0
    if (OS_MUX_UNUSED == pstMuxPended->ucMuxStat)
   21226:	2d00      	cmp	r5, #0
   21228:	d104      	bne.n	21234 <LOS_MuxPend+0x40>
        LOS_IntRestore(uwIntSave);
   2122a:	f7de ffa0 	bl	16e <LOS_IntRestore>
        OS_RETURN_ERROR(LOS_ERRNO_MUX_INVALID);
   2122e:	9500      	str	r5, [sp, #0]
   21230:	002b      	movs	r3, r5
   21232:	e7e6      	b.n	21202 <LOS_MuxPend+0xe>
    if (OS_INT_ACTIVE && (uwTimeout != LOS_NO_WAIT))
   21234:	f7f7 f806 	bl	18244 <non_os_is_this_interrupt_context>
   21238:	2800      	cmp	r0, #0
   2123a:	d006      	beq.n	2124a <LOS_MuxPend+0x56>
   2123c:	2f00      	cmp	r7, #0
   2123e:	d004      	beq.n	2124a <LOS_MuxPend+0x56>
        LOS_IntRestore(uwIntSave);
   21240:	0030      	movs	r0, r6
   21242:	f7de ff94 	bl	16e <LOS_IntRestore>
        return LOS_ERRNO_MUX_PEND_INTERR;
   21246:	4c2c      	ldr	r4, [pc, #176]	; (212f8 <LOS_MuxPend+0x104>)
   21248:	e7e1      	b.n	2120e <LOS_MuxPend+0x1a>
    pstRunTsk = (LOS_TASK_CB *)g_stLosTask.pstRunTask;
   2124a:	4b2c      	ldr	r3, [pc, #176]	; (212fc <LOS_MuxPend+0x108>)
   2124c:	681d      	ldr	r5, [r3, #0]
    if (pstMuxPended->usMuxCount == 0)
   2124e:	8863      	ldrh	r3, [r4, #2]
   21250:	9303      	str	r3, [sp, #12]
   21252:	2b00      	cmp	r3, #0
   21254:	d109      	bne.n	2126a <LOS_MuxPend+0x76>
        pstMuxPended->usMuxCount++;
   21256:	3301      	adds	r3, #1
   21258:	8063      	strh	r3, [r4, #2]
        pstMuxPended->pstOwner = pstRunTsk;
   2125a:	6125      	str	r5, [r4, #16]
        pstMuxPended->usPriority = pstRunTsk->usPriority;
   2125c:	88eb      	ldrh	r3, [r5, #6]
   2125e:	82a3      	strh	r3, [r4, #20]
        LOS_IntRestore(uwIntSave);
   21260:	0030      	movs	r0, r6
   21262:	f7de ff84 	bl	16e <LOS_IntRestore>
        return LOS_OK;
   21266:	2400      	movs	r4, #0
   21268:	e7d1      	b.n	2120e <LOS_MuxPend+0x1a>
    if (pstMuxPended->pstOwner == pstRunTsk)
   2126a:	6923      	ldr	r3, [r4, #16]
   2126c:	42ab      	cmp	r3, r5
   2126e:	d103      	bne.n	21278 <LOS_MuxPend+0x84>
        pstMuxPended->usMuxCount++;
   21270:	9b03      	ldr	r3, [sp, #12]
   21272:	3301      	adds	r3, #1
   21274:	8063      	strh	r3, [r4, #2]
   21276:	e7f3      	b.n	21260 <LOS_MuxPend+0x6c>
    if (!uwTimeout)
   21278:	2f00      	cmp	r7, #0
   2127a:	d104      	bne.n	21286 <LOS_MuxPend+0x92>
        LOS_IntRestore(uwIntSave);
   2127c:	0030      	movs	r0, r6
   2127e:	f7de ff76 	bl	16e <LOS_IntRestore>
        return LOS_ERRNO_MUX_UNAVAILABLE;
   21282:	4c1f      	ldr	r4, [pc, #124]	; (21300 <LOS_MuxPend+0x10c>)
   21284:	e7c3      	b.n	2120e <LOS_MuxPend+0x1a>
    if (g_usLosTaskLock)
   21286:	4b1f      	ldr	r3, [pc, #124]	; (21304 <LOS_MuxPend+0x110>)
   21288:	881b      	ldrh	r3, [r3, #0]
   2128a:	2b00      	cmp	r3, #0
   2128c:	d00b      	beq.n	212a6 <LOS_MuxPend+0xb2>
    (VOID)LOS_IntRestore(uwIntSave);
   2128e:	0030      	movs	r0, r6
   21290:	f7de ff6d 	bl	16e <LOS_IntRestore>
        uwRetErr = LOS_ERRNO_MUX_PEND_IN_LOCK;
   21294:	4c1c      	ldr	r4, [pc, #112]	; (21308 <LOS_MuxPend+0x114>)
    OS_RETURN_ERROR(uwRetErr);
   21296:	2300      	movs	r3, #0
   21298:	0022      	movs	r2, r4
   2129a:	9300      	str	r3, [sp, #0]
   2129c:	4913      	ldr	r1, [pc, #76]	; (212ec <LOS_MuxPend+0xf8>)
   2129e:	4814      	ldr	r0, [pc, #80]	; (212f0 <LOS_MuxPend+0xfc>)
   212a0:	f000 f9e6 	bl	21670 <LOS_ErrHandle>
   212a4:	e7b3      	b.n	2120e <LOS_MuxPend+0x1a>
    pstRunTsk->pTaskMux = (VOID *)pstMuxPended;
   212a6:	626c      	str	r4, [r5, #36]	; 0x24
    if (pstMuxPended->pstOwner->usPriority > pstRunTsk->usPriority)
   212a8:	6920      	ldr	r0, [r4, #16]
   212aa:	88e9      	ldrh	r1, [r5, #6]
   212ac:	88c3      	ldrh	r3, [r0, #6]
   212ae:	428b      	cmp	r3, r1
   212b0:	d901      	bls.n	212b6 <LOS_MuxPend+0xc2>
        osTaskPriModify(pstMuxPended->pstOwner, pstRunTsk->usPriority);
   212b2:	f7f1 fe45 	bl	12f40 <osTaskPriModify>
    osTaskWait(&pstMuxPended->stMuxList, OS_TASK_STATUS_PEND, uwTimeout);
   212b6:	0020      	movs	r0, r4
   212b8:	003a      	movs	r2, r7
   212ba:	2108      	movs	r1, #8
   212bc:	3008      	adds	r0, #8
   212be:	f7f2 f927 	bl	13510 <osTaskWait>
    (VOID)LOS_IntRestore(uwIntSave);
   212c2:	0030      	movs	r0, r6
    if (pstRunTsk->usTaskStatus & OS_TASK_STATUS_TIMEOUT)
   212c4:	2640      	movs	r6, #64	; 0x40
    (VOID)LOS_IntRestore(uwIntSave);
   212c6:	f7de ff52 	bl	16e <LOS_IntRestore>
    LOS_Schedule();
   212ca:	f7f2 fbb7 	bl	13a3c <LOS_Schedule>
    if (pstRunTsk->usTaskStatus & OS_TASK_STATUS_TIMEOUT)
   212ce:	88ab      	ldrh	r3, [r5, #4]
    return LOS_OK;
   212d0:	2400      	movs	r4, #0
    if (pstRunTsk->usTaskStatus & OS_TASK_STATUS_TIMEOUT)
   212d2:	4233      	tst	r3, r6
   212d4:	d09b      	beq.n	2120e <LOS_MuxPend+0x1a>
        uwIntSave = LOS_IntLock();
   212d6:	f7de ff42 	bl	15e <LOS_IntLock>
        pstRunTsk->usTaskStatus &= (~OS_TASK_STATUS_TIMEOUT);
   212da:	88ab      	ldrh	r3, [r5, #4]
        uwRetErr = LOS_ERRNO_MUX_TIMEOUT;
   212dc:	4c0b      	ldr	r4, [pc, #44]	; (2130c <LOS_MuxPend+0x118>)
        pstRunTsk->usTaskStatus &= (~OS_TASK_STATUS_TIMEOUT);
   212de:	43b3      	bics	r3, r6
   212e0:	80ab      	strh	r3, [r5, #4]
        (VOID)LOS_IntRestore(uwIntSave);
   212e2:	f7de ff44 	bl	16e <LOS_IntRestore>
        goto error_uniMuxPend;
   212e6:	e7d6      	b.n	21296 <LOS_MuxPend+0xa2>
   212e8:	02001d01 	.word	0x02001d01
   212ec:	a1b2c3f8 	.word	0xa1b2c3f8
   212f0:	000260e7 	.word	0x000260e7
   212f4:	01002f10 	.word	0x01002f10
   212f8:	02001d05 	.word	0x02001d05
   212fc:	01002e70 	.word	0x01002e70
   21300:	02001d04 	.word	0x02001d04
   21304:	01002e6c 	.word	0x01002e6c
   21308:	02001d06 	.word	0x02001d06
   2130c:	02001d07 	.word	0x02001d07

00021310 <LOS_MuxPost>:
 Input        : uwMuxHandle ------ Mutex operation handle,
 Output       : None
 Return       : LOS_OK on success ,or error code on failure
 *****************************************************************************/
LITE_OS_SEC_TEXT UINT32 LOS_MuxPost(UINT32 uwMuxHandle)
{
   21310:	b573      	push	{r0, r1, r4, r5, r6, lr}
    UINT32      uwIntSave;
    MUX_CB_S    *pstMuxPosted = GET_MUX(uwMuxHandle);
   21312:	2418      	movs	r4, #24
   21314:	4b23      	ldr	r3, [pc, #140]	; (213a4 <LOS_MuxPost+0x94>)
   21316:	4344      	muls	r4, r0
   21318:	681b      	ldr	r3, [r3, #0]
{
   2131a:	0006      	movs	r6, r0
    MUX_CB_S    *pstMuxPosted = GET_MUX(uwMuxHandle);
   2131c:	191c      	adds	r4, r3, r4
    LOS_TASK_CB *pstResumedTask;
    LOS_TASK_CB *pstRunTsk;

    uwIntSave = LOS_IntLock();
   2131e:	f7de ff1e 	bl	15e <LOS_IntLock>
   21322:	0005      	movs	r5, r0

    if ((uwMuxHandle >= (UINT32)LOSCFG_BASE_IPC_MUX_LIMIT) ||
   21324:	2e10      	cmp	r6, #16
   21326:	d802      	bhi.n	2132e <LOS_MuxPost+0x1e>
   21328:	7823      	ldrb	r3, [r4, #0]
   2132a:	2b00      	cmp	r3, #0
   2132c:	d10b      	bne.n	21346 <LOS_MuxPost+0x36>
    }

    pstRunTsk = (LOS_TASK_CB *)g_stLosTask.pstRunTask;
    if ((pstMuxPosted->usMuxCount == 0) || (pstMuxPosted->pstOwner != pstRunTsk))
    {
        LOS_IntRestore(uwIntSave);
   2132e:	0028      	movs	r0, r5
   21330:	f7de ff1d 	bl	16e <LOS_IntRestore>
        OS_RETURN_ERROR(LOS_ERRNO_MUX_INVALID);
   21334:	2300      	movs	r3, #0
   21336:	4a1c      	ldr	r2, [pc, #112]	; (213a8 <LOS_MuxPost+0x98>)
   21338:	9300      	str	r3, [sp, #0]
   2133a:	491c      	ldr	r1, [pc, #112]	; (213ac <LOS_MuxPost+0x9c>)
   2133c:	481c      	ldr	r0, [pc, #112]	; (213b0 <LOS_MuxPost+0xa0>)
   2133e:	f000 f997 	bl	21670 <LOS_ErrHandle>
   21342:	4819      	ldr	r0, [pc, #100]	; (213a8 <LOS_MuxPost+0x98>)
    {
        (VOID)LOS_IntRestore(uwIntSave);
    }

    return LOS_OK;
}
   21344:	bd76      	pop	{r1, r2, r4, r5, r6, pc}
    if ((pstMuxPosted->usMuxCount == 0) || (pstMuxPosted->pstOwner != pstRunTsk))
   21346:	8863      	ldrh	r3, [r4, #2]
   21348:	2b00      	cmp	r3, #0
   2134a:	d0f0      	beq.n	2132e <LOS_MuxPost+0x1e>
    pstRunTsk = (LOS_TASK_CB *)g_stLosTask.pstRunTask;
   2134c:	4a19      	ldr	r2, [pc, #100]	; (213b4 <LOS_MuxPost+0xa4>)
    if ((pstMuxPosted->usMuxCount == 0) || (pstMuxPosted->pstOwner != pstRunTsk))
   2134e:	6920      	ldr	r0, [r4, #16]
   21350:	6812      	ldr	r2, [r2, #0]
   21352:	4290      	cmp	r0, r2
   21354:	d1eb      	bne.n	2132e <LOS_MuxPost+0x1e>
    if (--(pstMuxPosted->usMuxCount) != 0)
   21356:	3b01      	subs	r3, #1
   21358:	b29b      	uxth	r3, r3
   2135a:	8063      	strh	r3, [r4, #2]
   2135c:	2b00      	cmp	r3, #0
   2135e:	d003      	beq.n	21368 <LOS_MuxPost+0x58>
        (VOID)LOS_IntRestore(uwIntSave);
   21360:	0028      	movs	r0, r5
   21362:	f7de ff04 	bl	16e <LOS_IntRestore>
   21366:	e01a      	b.n	2139e <LOS_MuxPost+0x8e>
    if ((pstMuxPosted->pstOwner->usPriority) != pstMuxPosted->usPriority)
   21368:	8aa1      	ldrh	r1, [r4, #20]
   2136a:	88c3      	ldrh	r3, [r0, #6]
   2136c:	428b      	cmp	r3, r1
   2136e:	d001      	beq.n	21374 <LOS_MuxPost+0x64>
        osTaskPriModify(pstMuxPosted->pstOwner, pstMuxPosted->usPriority);
   21370:	f7f1 fde6 	bl	12f40 <osTaskPriModify>
    if (!LOS_ListEmpty(&pstMuxPosted->stMuxList))
   21374:	0023      	movs	r3, r4
    return (BOOL)(pstList->pstNext == pstList);
   21376:	68e0      	ldr	r0, [r4, #12]
   21378:	3308      	adds	r3, #8
   2137a:	4298      	cmp	r0, r3
   2137c:	d0f0      	beq.n	21360 <LOS_MuxPost+0x50>
        pstMuxPosted->usMuxCount    = 1;
   2137e:	2301      	movs	r3, #1
        pstResumedTask = OS_TCB_FROM_PENDLIST(LOS_DL_LIST_FIRST(&(pstMuxPosted->stMuxList))); /*lint !e413*/
   21380:	382c      	subs	r0, #44	; 0x2c
        pstMuxPosted->pstOwner      = pstResumedTask;
   21382:	6120      	str	r0, [r4, #16]
        pstMuxPosted->usMuxCount    = 1;
   21384:	8063      	strh	r3, [r4, #2]
        pstMuxPosted->usPriority    = pstResumedTask->usPriority;
   21386:	88c3      	ldrh	r3, [r0, #6]
        osTaskWake(pstResumedTask, OS_TASK_STATUS_PEND);
   21388:	2108      	movs	r1, #8
        pstMuxPosted->usPriority    = pstResumedTask->usPriority;
   2138a:	82a3      	strh	r3, [r4, #20]
        pstResumedTask->pTaskMux    = NULL;
   2138c:	2400      	movs	r4, #0
   2138e:	6244      	str	r4, [r0, #36]	; 0x24
        osTaskWake(pstResumedTask, OS_TASK_STATUS_PEND);
   21390:	f7f2 f8e4 	bl	1355c <osTaskWake>
        (VOID)LOS_IntRestore(uwIntSave);
   21394:	0028      	movs	r0, r5
   21396:	f7de feea 	bl	16e <LOS_IntRestore>
        LOS_Schedule();
   2139a:	f7f2 fb4f 	bl	13a3c <LOS_Schedule>
    return LOS_OK;
   2139e:	2000      	movs	r0, #0
   213a0:	e7d0      	b.n	21344 <LOS_MuxPost+0x34>
   213a2:	46c0      	nop			; (mov r8, r8)
   213a4:	01002f10 	.word	0x01002f10
   213a8:	02001d01 	.word	0x02001d01
   213ac:	a1b2c3f8 	.word	0xa1b2c3f8
   213b0:	000260e7 	.word	0x000260e7
   213b4:	01002e70 	.word	0x01002e70

000213b8 <osSemInit>:
 Input        : None,
 Output       : None,
 Return       : LOS_OK on success ,or error code on failure
 *****************************************************************************/
LITE_OS_SEC_TEXT_INIT UINT32 osSemInit(VOID)
{
   213b8:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    UINT32      uwIndex;

    LOS_ListInit(&g_stUnusedSemList);
    if (LOSCFG_BASE_IPC_SEM_LIMIT > 0)  /*lint !e506*/
    {
        g_pstAllSem = (SEM_CB_S *)LOS_MemAlloc(m_aucSysMem0, (LOSCFG_BASE_IPC_SEM_LIMIT * sizeof(SEM_CB_S)));
   213ba:	4b11      	ldr	r3, [pc, #68]	; (21400 <osSemInit+0x48>)
    pstList->pstNext = pstList;
   213bc:	4c11      	ldr	r4, [pc, #68]	; (21404 <osSemInit+0x4c>)
   213be:	21c0      	movs	r1, #192	; 0xc0
   213c0:	6818      	ldr	r0, [r3, #0]
   213c2:	6064      	str	r4, [r4, #4]
    pstList->pstPrev = pstList;
   213c4:	6024      	str	r4, [r4, #0]
   213c6:	f7f1 fb8d 	bl	12ae4 <LOS_MemAlloc>
   213ca:	4d0f      	ldr	r5, [pc, #60]	; (21408 <osSemInit+0x50>)
   213cc:	6028      	str	r0, [r5, #0]
        if (NULL == g_pstAllSem)
   213ce:	2800      	cmp	r0, #0
   213d0:	d014      	beq.n	213fc <osSemInit+0x44>
        {
            return LOS_ERRNO_SEM_NO_MEMORY;
        }

        /* Connect all the ECBs in a doubly linked list. */
        for (uwIndex = 0; uwIndex < LOSCFG_BASE_IPC_SEM_LIMIT; uwIndex++)
   213d2:	2200      	movs	r2, #0
        {
            pstSemNode = ((SEM_CB_S *)g_pstAllSem) + uwIndex;
            pstSemNode->usSemID = uwIndex;
            pstSemNode->usSemStat = OS_SEM_UNUSED;
   213d4:	0016      	movs	r6, r2
            pstSemNode = ((SEM_CB_S *)g_pstAllSem) + uwIndex;
   213d6:	6829      	ldr	r1, [r5, #0]
   213d8:	0113      	lsls	r3, r2, #4
   213da:	18cb      	adds	r3, r1, r3
            LOS_ListTailInsert(&g_stUnusedSemList, &pstSemNode->stSemList);
   213dc:	0018      	movs	r0, r3
            pstSemNode->usSemStat = OS_SEM_UNUSED;
   213de:	701e      	strb	r6, [r3, #0]
   213e0:	6821      	ldr	r1, [r4, #0]
            pstSemNode->usSemID = uwIndex;
   213e2:	605a      	str	r2, [r3, #4]
    pstNode->pstNext = pstList->pstNext;
   213e4:	684f      	ldr	r7, [r1, #4]
    pstNode->pstPrev = pstList;
   213e6:	6099      	str	r1, [r3, #8]
    pstNode->pstNext = pstList->pstNext;
   213e8:	60df      	str	r7, [r3, #12]
    pstList->pstNext->pstPrev = pstNode;
   213ea:	684b      	ldr	r3, [r1, #4]
            LOS_ListTailInsert(&g_stUnusedSemList, &pstSemNode->stSemList);
   213ec:	3008      	adds	r0, #8
        for (uwIndex = 0; uwIndex < LOSCFG_BASE_IPC_SEM_LIMIT; uwIndex++)
   213ee:	3201      	adds	r2, #1
   213f0:	6018      	str	r0, [r3, #0]
    pstList->pstNext = pstNode;
   213f2:	6048      	str	r0, [r1, #4]
   213f4:	2a0c      	cmp	r2, #12
   213f6:	d1ee      	bne.n	213d6 <osSemInit+0x1e>
        }
    }

    return LOS_OK;
   213f8:	2000      	movs	r0, #0
}
   213fa:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
            return LOS_ERRNO_SEM_NO_MEMORY;
   213fc:	4803      	ldr	r0, [pc, #12]	; (2140c <osSemInit+0x54>)
   213fe:	e7fc      	b.n	213fa <osSemInit+0x42>
   21400:	01002e40 	.word	0x01002e40
   21404:	01002f1c 	.word	0x01002f1c
   21408:	01002f24 	.word	0x01002f24
   2140c:	02000700 	.word	0x02000700

00021410 <LOS_SemCreate>:
 Input        : uwCount--------- semaphore count,
 Output       : puwSemHandle-----Index of semaphore,
 Return       : LOS_OK on success ,or error code on failure
 *****************************************************************************/
LITE_OS_SEC_TEXT_INIT UINT32 LOS_SemCreate (UINT16 usCount, UINT32 *puwSemHandle)
{
   21410:	b537      	push	{r0, r1, r2, r4, r5, lr}
   21412:	0004      	movs	r4, r0
   21414:	1e0d      	subs	r5, r1, #0
    SEM_CB_S    *pstSemCreated;
    LOS_DL_LIST *pstUnusedSem;
    UINT32      uwErrNo;
    UINT32      uwErrLine;

    if (NULL == puwSemHandle)
   21416:	d02a      	beq.n	2146e <LOS_SemCreate+0x5e>
    {
        return LOS_ERRNO_SEM_PTR_NULL;
    }

    if (usCount > OS_SEM_COUNT_MAX)
   21418:	4b16      	ldr	r3, [pc, #88]	; (21474 <LOS_SemCreate+0x64>)
   2141a:	4298      	cmp	r0, r3
   2141c:	d025      	beq.n	2146a <LOS_SemCreate+0x5a>
    {
        OS_GOTO_ERR_HANDLER(LOS_ERRNO_SEM_OVERFLOW);
    }

    uwIntSave = LOS_IntLock();
   2141e:	f7de fe9e 	bl	15e <LOS_IntLock>
    return (BOOL)(pstList->pstNext == pstList);
   21422:	4a15      	ldr	r2, [pc, #84]	; (21478 <LOS_SemCreate+0x68>)
   21424:	6853      	ldr	r3, [r2, #4]

    if (LOS_ListEmpty(&g_stUnusedSemList))
   21426:	4293      	cmp	r3, r2
   21428:	d10a      	bne.n	21440 <LOS_SemCreate+0x30>
    {
        LOS_IntRestore(uwIntSave);
   2142a:	f7de fea0 	bl	16e <LOS_IntRestore>
        OS_GOTO_ERR_HANDLER(LOS_ERRNO_SEM_ALL_BUSY);
   2142e:	4c13      	ldr	r4, [pc, #76]	; (2147c <LOS_SemCreate+0x6c>)
    *puwSemHandle = (UINT32)pstSemCreated->usSemID;
    LOS_IntRestore(uwIntSave);
    return LOS_OK;

ErrHandler:
    OS_RETURN_ERROR_P2(uwErrLine, uwErrNo);
   21430:	2300      	movs	r3, #0
   21432:	0022      	movs	r2, r4
   21434:	9300      	str	r3, [sp, #0]
   21436:	4912      	ldr	r1, [pc, #72]	; (21480 <LOS_SemCreate+0x70>)
   21438:	4812      	ldr	r0, [pc, #72]	; (21484 <LOS_SemCreate+0x74>)
   2143a:	f000 f919 	bl	21670 <LOS_ErrHandle>
   2143e:	e012      	b.n	21466 <LOS_SemCreate+0x56>
    pstNode->pstNext->pstPrev = pstNode->pstPrev;
   21440:	685a      	ldr	r2, [r3, #4]
   21442:	6819      	ldr	r1, [r3, #0]
   21444:	6011      	str	r1, [r2, #0]
    pstNode->pstPrev->pstNext = pstNode->pstNext;
   21446:	681a      	ldr	r2, [r3, #0]
   21448:	6859      	ldr	r1, [r3, #4]
   2144a:	6051      	str	r1, [r2, #4]
    pstSemCreated->uwSemCount = usCount;
   2144c:	001a      	movs	r2, r3
   2144e:	3a08      	subs	r2, #8
   21450:	8054      	strh	r4, [r2, #2]
    pstSemCreated->usSemStat = OS_SEM_USED;
   21452:	2101      	movs	r1, #1
    pstSemCreated->binarySem = OS_SEM_COUNTING;
   21454:	2400      	movs	r4, #0
    pstSemCreated->usSemStat = OS_SEM_USED;
   21456:	7011      	strb	r1, [r2, #0]
    pstSemCreated->binarySem = OS_SEM_COUNTING;
   21458:	7054      	strb	r4, [r2, #1]
    pstList->pstNext = pstList;
   2145a:	605b      	str	r3, [r3, #4]
    pstList->pstPrev = pstList;
   2145c:	601b      	str	r3, [r3, #0]
    *puwSemHandle = (UINT32)pstSemCreated->usSemID;
   2145e:	6853      	ldr	r3, [r2, #4]
   21460:	602b      	str	r3, [r5, #0]
    LOS_IntRestore(uwIntSave);
   21462:	f7de fe84 	bl	16e <LOS_IntRestore>
}
   21466:	0020      	movs	r0, r4
   21468:	bd3e      	pop	{r1, r2, r3, r4, r5, pc}
        OS_GOTO_ERR_HANDLER(LOS_ERRNO_SEM_OVERFLOW);
   2146a:	4c07      	ldr	r4, [pc, #28]	; (21488 <LOS_SemCreate+0x78>)
   2146c:	e7e0      	b.n	21430 <LOS_SemCreate+0x20>
        return LOS_ERRNO_SEM_PTR_NULL;
   2146e:	4c07      	ldr	r4, [pc, #28]	; (2148c <LOS_SemCreate+0x7c>)
   21470:	e7f9      	b.n	21466 <LOS_SemCreate+0x56>
   21472:	46c0      	nop			; (mov r8, r8)
   21474:	0000ffff 	.word	0x0000ffff
   21478:	01002f1c 	.word	0x01002f1c
   2147c:	02000703 	.word	0x02000703
   21480:	a1b2c3f8 	.word	0xa1b2c3f8
   21484:	000260e7 	.word	0x000260e7
   21488:	02000708 	.word	0x02000708
   2148c:	02000702 	.word	0x02000702

00021490 <LOS_BinarySemCreate>:
 Input        : uwCount--------- semaphore count,
 Output       : puwSemHandle-----Index of semaphore,
 Return       : LOS_OK on success ,or error code on failure
 *****************************************************************************/
LITE_OS_SEC_TEXT_INIT UINT32 LOS_BinarySemCreate (UINT16 usCount, UINT32 *puwSemHandle)
{
   21490:	b537      	push	{r0, r1, r2, r4, r5, lr}
   21492:	000d      	movs	r5, r1
    UINT32 uwRet;
    SEM_CB_S    *pstSem;
    UINT32      uwErrNo;
    UINT32      uwErrLine;

    if (usCount > 1)
   21494:	2801      	cmp	r0, #1
   21496:	d909      	bls.n	214ac <LOS_BinarySemCreate+0x1c>
        return LOS_OK;
    }
    else
        return uwRet;
ErrHandler:
    OS_RETURN_ERROR_P2(uwErrLine, uwErrNo);
   21498:	2300      	movs	r3, #0
   2149a:	4a0c      	ldr	r2, [pc, #48]	; (214cc <LOS_BinarySemCreate+0x3c>)
   2149c:	9300      	str	r3, [sp, #0]
   2149e:	490c      	ldr	r1, [pc, #48]	; (214d0 <LOS_BinarySemCreate+0x40>)
   214a0:	480c      	ldr	r0, [pc, #48]	; (214d4 <LOS_BinarySemCreate+0x44>)
   214a2:	f000 f8e5 	bl	21670 <LOS_ErrHandle>
   214a6:	4c09      	ldr	r4, [pc, #36]	; (214cc <LOS_BinarySemCreate+0x3c>)
}
   214a8:	0020      	movs	r0, r4
   214aa:	bd3e      	pop	{r1, r2, r3, r4, r5, pc}
    uwRet = LOS_SemCreate (usCount, puwSemHandle);
   214ac:	f7ff ffb0 	bl	21410 <LOS_SemCreate>
   214b0:	1e04      	subs	r4, r0, #0
    if(uwRet == LOS_OK)
   214b2:	d1f9      	bne.n	214a8 <LOS_BinarySemCreate+0x18>
        uwIntSave = LOS_IntLock();
   214b4:	f7de fe53 	bl	15e <LOS_IntLock>
        pstSem->binarySem = OS_SEM_BINARY;
   214b8:	4b07      	ldr	r3, [pc, #28]	; (214d8 <LOS_BinarySemCreate+0x48>)
        pstSem = GET_SEM(*puwSemHandle);
   214ba:	682a      	ldr	r2, [r5, #0]
        pstSem->binarySem = OS_SEM_BINARY;
   214bc:	681b      	ldr	r3, [r3, #0]
   214be:	0112      	lsls	r2, r2, #4
   214c0:	189b      	adds	r3, r3, r2
   214c2:	2201      	movs	r2, #1
   214c4:	705a      	strb	r2, [r3, #1]
        LOS_IntRestore(uwIntSave);
   214c6:	f7de fe52 	bl	16e <LOS_IntRestore>
        return LOS_OK;
   214ca:	e7ed      	b.n	214a8 <LOS_BinarySemCreate+0x18>
   214cc:	02000708 	.word	0x02000708
   214d0:	a1b2c3f8 	.word	0xa1b2c3f8
   214d4:	000260e7 	.word	0x000260e7
   214d8:	01002f24 	.word	0x01002f24

000214dc <LOS_SemPend>:
 		     uwTimeout   ---------- waitting time
 Output       : None
 Return       : LOS_OK on success or error code on failure
 *****************************************************************************/
LITE_OS_SEC_TEXT UINT32 LOS_SemPend(UINT32 uwSemHandle, UINT32 uwTimeout)
{
   214dc:	b5f0      	push	{r4, r5, r6, r7, lr}
   214de:	000f      	movs	r7, r1
   214e0:	b085      	sub	sp, #20
    UINT32      uwIntSave;
    SEM_CB_S    *pstSemPended;
    UINT32      uwRetErr;
    LOS_TASK_CB *pstRunTsk;

    if (uwSemHandle >= (UINT32)LOSCFG_BASE_IPC_SEM_LIMIT)
   214e2:	280b      	cmp	r0, #11
   214e4:	d90a      	bls.n	214fc <LOS_SemPend+0x20>
    {
        OS_RETURN_ERROR(LOS_ERRNO_SEM_INVALID);
   214e6:	2300      	movs	r3, #0
   214e8:	9300      	str	r3, [sp, #0]
    pstSemPended = GET_SEM(uwSemHandle);
    uwIntSave = LOS_IntLock();
    if (OS_SEM_UNUSED == pstSemPended->usSemStat)
    {
        LOS_IntRestore(uwIntSave);
        OS_RETURN_ERROR(LOS_ERRNO_SEM_INVALID);
   214ea:	4a2c      	ldr	r2, [pc, #176]	; (2159c <LOS_SemPend+0xc0>)
   214ec:	492c      	ldr	r1, [pc, #176]	; (215a0 <LOS_SemPend+0xc4>)
   214ee:	482d      	ldr	r0, [pc, #180]	; (215a4 <LOS_SemPend+0xc8>)
   214f0:	f000 f8be 	bl	21670 <LOS_ErrHandle>
   214f4:	4c29      	ldr	r4, [pc, #164]	; (2159c <LOS_SemPend+0xc0>)

errre_uniSemPend:
    (VOID)LOS_IntRestore(uwIntSave);
error_uniSemPend:
    OS_RETURN_ERROR(uwRetErr);
}
   214f6:	0020      	movs	r0, r4
   214f8:	b005      	add	sp, #20
   214fa:	bdf0      	pop	{r4, r5, r6, r7, pc}
    pstSemPended = GET_SEM(uwSemHandle);
   214fc:	4b2a      	ldr	r3, [pc, #168]	; (215a8 <LOS_SemPend+0xcc>)
   214fe:	0100      	lsls	r0, r0, #4
   21500:	681c      	ldr	r4, [r3, #0]
   21502:	1824      	adds	r4, r4, r0
    uwIntSave = LOS_IntLock();
   21504:	f7de fe2b 	bl	15e <LOS_IntLock>
    if (OS_SEM_UNUSED == pstSemPended->usSemStat)
   21508:	7826      	ldrb	r6, [r4, #0]
    uwIntSave = LOS_IntLock();
   2150a:	0005      	movs	r5, r0
    if (OS_SEM_UNUSED == pstSemPended->usSemStat)
   2150c:	2e00      	cmp	r6, #0
   2150e:	d104      	bne.n	2151a <LOS_SemPend+0x3e>
        LOS_IntRestore(uwIntSave);
   21510:	f7de fe2d 	bl	16e <LOS_IntRestore>
        OS_RETURN_ERROR(LOS_ERRNO_SEM_INVALID);
   21514:	9600      	str	r6, [sp, #0]
   21516:	0033      	movs	r3, r6
   21518:	e7e7      	b.n	214ea <LOS_SemPend+0xe>
    if (pstSemPended->uwSemCount > 0)
   2151a:	8863      	ldrh	r3, [r4, #2]
   2151c:	2b00      	cmp	r3, #0
   2151e:	d005      	beq.n	2152c <LOS_SemPend+0x50>
        pstSemPended->uwSemCount--;
   21520:	3b01      	subs	r3, #1
   21522:	8063      	strh	r3, [r4, #2]
        LOS_IntRestore(uwIntSave);
   21524:	f7de fe23 	bl	16e <LOS_IntRestore>
        return LOS_OK;
   21528:	2400      	movs	r4, #0
   2152a:	e7e4      	b.n	214f6 <LOS_SemPend+0x1a>
    if (!uwTimeout)
   2152c:	2f00      	cmp	r7, #0
   2152e:	d02b      	beq.n	21588 <LOS_SemPend+0xac>
    if (OS_INT_ACTIVE)
   21530:	f7f6 fe88 	bl	18244 <non_os_is_this_interrupt_context>
   21534:	2800      	cmp	r0, #0
   21536:	d12c      	bne.n	21592 <LOS_SemPend+0xb6>
    if (g_usLosTaskLock)
   21538:	4b1c      	ldr	r3, [pc, #112]	; (215ac <LOS_SemPend+0xd0>)
   2153a:	881b      	ldrh	r3, [r3, #0]
   2153c:	9303      	str	r3, [sp, #12]
   2153e:	2b00      	cmp	r3, #0
   21540:	d129      	bne.n	21596 <LOS_SemPend+0xba>
    osTaskWait(&pstSemPended->stSemList, OS_TASK_STATUS_PEND, uwTimeout);
   21542:	0020      	movs	r0, r4
    pstRunTsk = (LOS_TASK_CB *)g_stLosTask.pstRunTask;
   21544:	4b1a      	ldr	r3, [pc, #104]	; (215b0 <LOS_SemPend+0xd4>)
    osTaskWait(&pstSemPended->stSemList, OS_TASK_STATUS_PEND, uwTimeout);
   21546:	003a      	movs	r2, r7
    pstRunTsk = (LOS_TASK_CB *)g_stLosTask.pstRunTask;
   21548:	681e      	ldr	r6, [r3, #0]
    osTaskWait(&pstSemPended->stSemList, OS_TASK_STATUS_PEND, uwTimeout);
   2154a:	2108      	movs	r1, #8
    pstRunTsk->pTaskSem = (VOID *)pstSemPended;
   2154c:	61b4      	str	r4, [r6, #24]
    osTaskWait(&pstSemPended->stSemList, OS_TASK_STATUS_PEND, uwTimeout);
   2154e:	3008      	adds	r0, #8
   21550:	f7f1 ffde 	bl	13510 <osTaskWait>
    (VOID)LOS_IntRestore(uwIntSave);
   21554:	0028      	movs	r0, r5
    if (pstRunTsk->usTaskStatus & OS_TASK_STATUS_TIMEOUT)
   21556:	2540      	movs	r5, #64	; 0x40
    (VOID)LOS_IntRestore(uwIntSave);
   21558:	f7de fe09 	bl	16e <LOS_IntRestore>
    LOS_Schedule();
   2155c:	f7f2 fa6e 	bl	13a3c <LOS_Schedule>
    if (pstRunTsk->usTaskStatus & OS_TASK_STATUS_TIMEOUT)
   21560:	88b3      	ldrh	r3, [r6, #4]
    return LOS_OK;
   21562:	9c03      	ldr	r4, [sp, #12]
    if (pstRunTsk->usTaskStatus & OS_TASK_STATUS_TIMEOUT)
   21564:	422b      	tst	r3, r5
   21566:	d0c6      	beq.n	214f6 <LOS_SemPend+0x1a>
        uwIntSave = LOS_IntLock();
   21568:	f7de fdf9 	bl	15e <LOS_IntLock>
        pstRunTsk->usTaskStatus &= (~OS_TASK_STATUS_TIMEOUT);
   2156c:	88b3      	ldrh	r3, [r6, #4]
        uwRetErr = LOS_ERRNO_SEM_TIMEOUT;
   2156e:	4c11      	ldr	r4, [pc, #68]	; (215b4 <LOS_SemPend+0xd8>)
        pstRunTsk->usTaskStatus &= (~OS_TASK_STATUS_TIMEOUT);
   21570:	43ab      	bics	r3, r5
   21572:	80b3      	strh	r3, [r6, #4]
        (VOID)LOS_IntRestore(uwIntSave);
   21574:	f7de fdfb 	bl	16e <LOS_IntRestore>
    OS_RETURN_ERROR(uwRetErr);
   21578:	2300      	movs	r3, #0
   2157a:	0022      	movs	r2, r4
   2157c:	9300      	str	r3, [sp, #0]
   2157e:	4908      	ldr	r1, [pc, #32]	; (215a0 <LOS_SemPend+0xc4>)
   21580:	4808      	ldr	r0, [pc, #32]	; (215a4 <LOS_SemPend+0xc8>)
   21582:	f000 f875 	bl	21670 <LOS_ErrHandle>
   21586:	e7b6      	b.n	214f6 <LOS_SemPend+0x1a>
        uwRetErr = LOS_ERRNO_SEM_UNAVAILABLE;
   21588:	4c0b      	ldr	r4, [pc, #44]	; (215b8 <LOS_SemPend+0xdc>)
    (VOID)LOS_IntRestore(uwIntSave);
   2158a:	0028      	movs	r0, r5
   2158c:	f7de fdef 	bl	16e <LOS_IntRestore>
   21590:	e7f2      	b.n	21578 <LOS_SemPend+0x9c>
        uwRetErr = LOS_ERRNO_SEM_PEND_INTERR;
   21592:	4c0a      	ldr	r4, [pc, #40]	; (215bc <LOS_SemPend+0xe0>)
   21594:	e7f9      	b.n	2158a <LOS_SemPend+0xae>
        uwRetErr = LOS_ERRNO_SEM_PEND_IN_LOCK;
   21596:	4c0a      	ldr	r4, [pc, #40]	; (215c0 <LOS_SemPend+0xe4>)
   21598:	e7f7      	b.n	2158a <LOS_SemPend+0xae>
   2159a:	46c0      	nop			; (mov r8, r8)
   2159c:	02000701 	.word	0x02000701
   215a0:	a1b2c3f8 	.word	0xa1b2c3f8
   215a4:	000260e7 	.word	0x000260e7
   215a8:	01002f24 	.word	0x01002f24
   215ac:	01002e6c 	.word	0x01002e6c
   215b0:	01002e70 	.word	0x01002e70
   215b4:	02000707 	.word	0x02000707
   215b8:	02000704 	.word	0x02000704
   215bc:	02000705 	.word	0x02000705
   215c0:	02000706 	.word	0x02000706

000215c4 <LOS_SemPost>:
 Input        : uwSemHandle--------- semaphore operation handle,
 Output       : None
 Return       : LOS_OK on success or error code on failure
 *****************************************************************************/
LITE_OS_SEC_TEXT UINT32 LOS_SemPost(UINT32 uwSemHandle)
{
   215c4:	b573      	push	{r0, r1, r4, r5, r6, lr}
    UINT32      uwIntSave;
    SEM_CB_S    *pstSemPosted = GET_SEM(uwSemHandle);
    LOS_TASK_CB *pstResumedTask;

    if (uwSemHandle >= LOSCFG_BASE_IPC_SEM_LIMIT)
   215c6:	280b      	cmp	r0, #11
   215c8:	d812      	bhi.n	215f0 <LOS_SemPost+0x2c>
    SEM_CB_S    *pstSemPosted = GET_SEM(uwSemHandle);
   215ca:	4b22      	ldr	r3, [pc, #136]	; (21654 <LOS_SemPost+0x90>)
   215cc:	0100      	lsls	r0, r0, #4
   215ce:	681c      	ldr	r4, [r3, #0]
   215d0:	1824      	adds	r4, r4, r0
    {
        return LOS_ERRNO_SEM_INVALID;
    }

    uwIntSave = LOS_IntLock();
   215d2:	f7de fdc4 	bl	15e <LOS_IntLock>

    if (OS_SEM_UNUSED == pstSemPosted->usSemStat)
   215d6:	7826      	ldrb	r6, [r4, #0]
    uwIntSave = LOS_IntLock();
   215d8:	0005      	movs	r5, r0
    if (OS_SEM_UNUSED == pstSemPosted->usSemStat)
   215da:	2e00      	cmp	r6, #0
   215dc:	d10a      	bne.n	215f4 <LOS_SemPost+0x30>
    {
        LOS_IntRestore(uwIntSave);
   215de:	f7de fdc6 	bl	16e <LOS_IntRestore>
        OS_RETURN_ERROR(LOS_ERRNO_SEM_INVALID);
   215e2:	9600      	str	r6, [sp, #0]
   215e4:	0033      	movs	r3, r6
   215e6:	4a1c      	ldr	r2, [pc, #112]	; (21658 <LOS_SemPost+0x94>)
   215e8:	491c      	ldr	r1, [pc, #112]	; (2165c <LOS_SemPost+0x98>)
   215ea:	481d      	ldr	r0, [pc, #116]	; (21660 <LOS_SemPost+0x9c>)
   215ec:	f000 f840 	bl	21670 <LOS_ErrHandle>
        return LOS_ERRNO_SEM_INVALID;
   215f0:	4819      	ldr	r0, [pc, #100]	; (21658 <LOS_SemPost+0x94>)
   215f2:	e011      	b.n	21618 <LOS_SemPost+0x54>
    }

    if ((pstSemPosted->binarySem == OS_SEM_BINARY) && (pstSemPosted->uwSemCount == 1))
   215f4:	23ff      	movs	r3, #255	; 0xff
   215f6:	6822      	ldr	r2, [r4, #0]
   215f8:	439a      	bics	r2, r3
   215fa:	0013      	movs	r3, r2
   215fc:	4a19      	ldr	r2, [pc, #100]	; (21664 <LOS_SemPost+0xa0>)
   215fe:	4293      	cmp	r3, r2
   21600:	d10b      	bne.n	2161a <LOS_SemPost+0x56>
        OS_RETURN_ERROR(LOS_ERRNO_SEM_OVERFLOW);
    }

    if (OS_SEM_COUNT_MAX == pstSemPosted->uwSemCount )
    {
        (VOID)LOS_IntRestore(uwIntSave);
   21602:	0028      	movs	r0, r5
   21604:	f7de fdb3 	bl	16e <LOS_IntRestore>
        OS_RETURN_ERROR(LOS_ERRNO_SEM_OVERFLOW);
   21608:	2300      	movs	r3, #0
   2160a:	4a17      	ldr	r2, [pc, #92]	; (21668 <LOS_SemPost+0xa4>)
   2160c:	9300      	str	r3, [sp, #0]
   2160e:	4913      	ldr	r1, [pc, #76]	; (2165c <LOS_SemPost+0x98>)
   21610:	4813      	ldr	r0, [pc, #76]	; (21660 <LOS_SemPost+0x9c>)
   21612:	f000 f82d 	bl	21670 <LOS_ErrHandle>
   21616:	4814      	ldr	r0, [pc, #80]	; (21668 <LOS_SemPost+0xa4>)
        pstSemPosted->uwSemCount++;
        (VOID)LOS_IntRestore(uwIntSave);
    }

    return LOS_OK;
}
   21618:	bd76      	pop	{r1, r2, r4, r5, r6, pc}
    if (OS_SEM_COUNT_MAX == pstSemPosted->uwSemCount )
   2161a:	8863      	ldrh	r3, [r4, #2]
   2161c:	4a13      	ldr	r2, [pc, #76]	; (2166c <LOS_SemPost+0xa8>)
   2161e:	4293      	cmp	r3, r2
   21620:	d0ef      	beq.n	21602 <LOS_SemPost+0x3e>
    if (!LOS_ListEmpty(&pstSemPosted->stSemList))
   21622:	0022      	movs	r2, r4
    return (BOOL)(pstList->pstNext == pstList);
   21624:	68e0      	ldr	r0, [r4, #12]
   21626:	3208      	adds	r2, #8
   21628:	4290      	cmp	r0, r2
   2162a:	d00c      	beq.n	21646 <LOS_SemPost+0x82>
        pstResumedTask->pTaskSem = NULL;
   2162c:	2400      	movs	r4, #0
   2162e:	382c      	subs	r0, #44	; 0x2c
   21630:	6184      	str	r4, [r0, #24]
        osTaskWake(pstResumedTask, OS_TASK_STATUS_PEND);
   21632:	2108      	movs	r1, #8
   21634:	f7f1 ff92 	bl	1355c <osTaskWake>
        (VOID)LOS_IntRestore(uwIntSave);
   21638:	0028      	movs	r0, r5
   2163a:	f7de fd98 	bl	16e <LOS_IntRestore>
        LOS_Schedule();
   2163e:	f7f2 f9fd 	bl	13a3c <LOS_Schedule>
    return LOS_OK;
   21642:	2000      	movs	r0, #0
   21644:	e7e8      	b.n	21618 <LOS_SemPost+0x54>
        pstSemPosted->uwSemCount++;
   21646:	3301      	adds	r3, #1
   21648:	8063      	strh	r3, [r4, #2]
        (VOID)LOS_IntRestore(uwIntSave);
   2164a:	0028      	movs	r0, r5
   2164c:	f7de fd8f 	bl	16e <LOS_IntRestore>
   21650:	e7f7      	b.n	21642 <LOS_SemPost+0x7e>
   21652:	46c0      	nop			; (mov r8, r8)
   21654:	01002f24 	.word	0x01002f24
   21658:	02000701 	.word	0x02000701
   2165c:	a1b2c3f8 	.word	0xa1b2c3f8
   21660:	000260e7 	.word	0x000260e7
   21664:	00010100 	.word	0x00010100
   21668:	02000708 	.word	0x02000708
   2166c:	0000fffe 	.word	0x0000fffe

00021670 <LOS_ErrHandle>:
LITE_OS_SEC_TEXT_INIT UINT32 LOS_ErrHandle( CHAR *pcFileName,
                                     UINT32 uwLineNo,
                                     UINT32 uwErrorNo,
                                     UINT32 uwParaLen,
                                     VOID  *pPara)
{
   21670:	b537      	push	{r0, r1, r2, r4, r5, lr}

    if (NULL != g_stUserErrFunc.pfnHook)
   21672:	4c04      	ldr	r4, [pc, #16]	; (21684 <LOS_ErrHandle+0x14>)
   21674:	6824      	ldr	r4, [r4, #0]
   21676:	2c00      	cmp	r4, #0
   21678:	d002      	beq.n	21680 <LOS_ErrHandle+0x10>
    {
        g_stUserErrFunc.pfnHook(pcFileName, uwLineNo, uwErrorNo, uwParaLen, pPara);
   2167a:	9d06      	ldr	r5, [sp, #24]
   2167c:	9500      	str	r5, [sp, #0]
   2167e:	47a0      	blx	r4
    {
        return LOS_OK;
    }

    return LOS_OK;
}
   21680:	2000      	movs	r0, #0
   21682:	bd3e      	pop	{r1, r2, r3, r4, r5, pc}
   21684:	01002f28 	.word	0x01002f28

00021688 <osTickStart>:
Input   : none
output  : none
return  : LOS_OK - Success , or LOS_ERRNO_TICK_CFG_INVALID - failed
*****************************************************************************/
LITE_OS_SEC_TEXT_INIT UINT32 osTickStart(VOID)
{
   21688:	b510      	push	{r4, lr}
    if ((0 == OS_SYS_CLOCK)
   2168a:	f7f7 fbab 	bl	18de4 <hal_clocks_get_core_clock_mid_value>
   2168e:	2800      	cmp	r0, #0
   21690:	d101      	bne.n	21696 <osTickStart+0xe>
        || (0 == LOSCFG_BASE_CORE_TICK_PER_SECOND)
        || (LOSCFG_BASE_CORE_TICK_PER_SECOND > OS_SYS_CLOCK))/*lint !e506*/
    {
        return LOS_ERRNO_TICK_CFG_INVALID;
   21692:	480c      	ldr	r0, [pc, #48]	; (216c4 <osTickStart+0x3c>)

    *(volatile UINT32 *)OS_SYSTICK_RELOAD_REG = OS_SYS_CLOCK/LOSCFG_BASE_CORE_TICK_PER_SECOND;

    *(volatile UINT32 *)OS_SYSTICK_CONTROL_REG = 0x7;
    return LOS_OK;
}
   21694:	bd10      	pop	{r4, pc}
        || (LOSCFG_BASE_CORE_TICK_PER_SECOND > OS_SYS_CLOCK))/*lint !e506*/
   21696:	f7f7 fba5 	bl	18de4 <hal_clocks_get_core_clock_mid_value>
   2169a:	4b0b      	ldr	r3, [pc, #44]	; (216c8 <osTickStart+0x40>)
   2169c:	4298      	cmp	r0, r3
   2169e:	d9f8      	bls.n	21692 <osTickStart+0xa>
    g_ullTickCount = 0;
   216a0:	2100      	movs	r1, #0
   216a2:	2000      	movs	r0, #0
   216a4:	4b09      	ldr	r3, [pc, #36]	; (216cc <osTickStart+0x44>)
   216a6:	6018      	str	r0, [r3, #0]
   216a8:	6059      	str	r1, [r3, #4]
    *(volatile UINT32 *)OS_SYSTICK_RELOAD_REG = OS_SYS_CLOCK/LOSCFG_BASE_CORE_TICK_PER_SECOND;
   216aa:	f7f7 fb9b 	bl	18de4 <hal_clocks_get_core_clock_mid_value>
   216ae:	21fa      	movs	r1, #250	; 0xfa
   216b0:	0089      	lsls	r1, r1, #2
   216b2:	f7de fe81 	bl	3b8 <__udivsi3>
    *(volatile UINT32 *)OS_SYSTICK_CONTROL_REG = 0x7;
   216b6:	2207      	movs	r2, #7
    *(volatile UINT32 *)OS_SYSTICK_RELOAD_REG = OS_SYS_CLOCK/LOSCFG_BASE_CORE_TICK_PER_SECOND;
   216b8:	4b05      	ldr	r3, [pc, #20]	; (216d0 <osTickStart+0x48>)
   216ba:	6018      	str	r0, [r3, #0]
    *(volatile UINT32 *)OS_SYSTICK_CONTROL_REG = 0x7;
   216bc:	4b05      	ldr	r3, [pc, #20]	; (216d4 <osTickStart+0x4c>)
    return LOS_OK;
   216be:	2000      	movs	r0, #0
    *(volatile UINT32 *)OS_SYSTICK_CONTROL_REG = 0x7;
   216c0:	601a      	str	r2, [r3, #0]
    return LOS_OK;
   216c2:	e7e7      	b.n	21694 <osTickStart+0xc>
   216c4:	02000400 	.word	0x02000400
   216c8:	000003e7 	.word	0x000003e7
   216cc:	01002eb0 	.word	0x01002eb0
   216d0:	e000e014 	.word	0xe000e014
   216d4:	e000e010 	.word	0xe000e010

000216d8 <LOS_Start>:
 Input       : None
 Output      : None
 Return      : LOS_OK
 *****************************************************************************/
LITE_OS_SEC_TEXT_INIT UINT32 LOS_Start(void)
{
   216d8:	b510      	push	{r4, lr}
    UINT32 uwRet = 0;

#if (LOSCFG_BASE_CORE_TICK_HW_TIME1 == YES)

    uwRet = osTickStart();
   216da:	f7ff ffd5 	bl	21688 <osTickStart>
   216de:	1e04      	subs	r4, r0, #0
    if (uwRet != LOS_OK)
   216e0:	d101      	bne.n	216e6 <LOS_Start+0xe>
    {
        PRINT_ERR("osTickStart error\n");
        return uwRet;
    }
#endif
    LOS_StartToRun();
   216e2:	f7de fd1d 	bl	120 <LOS_StartToRun>
    return uwRet;
}
   216e6:	0020      	movs	r0, r4
   216e8:	bd10      	pop	{r4, pc}
	...

000216ec <osMain>:
    g_uwTskMaxNum = LOSCFG_BASE_CORE_TSK_LIMIT + 1; /* Reserved 1 for IDLE */
   216ec:	220b      	movs	r2, #11
   216ee:	4b10      	ldr	r3, [pc, #64]	; (21730 <osMain+0x44>)
 Input       : None
 Output      : None
 Return      : LOS_OK
 *****************************************************************************/
LITE_OS_SEC_TEXT_INIT int osMain(void)
{
   216f0:	b510      	push	{r4, lr}
    g_uwTskMaxNum = LOSCFG_BASE_CORE_TSK_LIMIT + 1; /* Reserved 1 for IDLE */
   216f2:	601a      	str	r2, [r3, #0]
    UINT32 uwRet;

    osRegister();

    uwRet = osMemSystemInit();
   216f4:	f7f1 f9ce 	bl	12a94 <osMemSystemInit>
    if (uwRet != LOS_OK) {
   216f8:	2800      	cmp	r0, #0
   216fa:	d117      	bne.n	2172c <osMain+0x40>
    {
        osHwiInit();
    }
#endif

    uwRet = osTaskInit();
   216fc:	f7f1 fcee 	bl	130dc <osTaskInit>
    if (uwRet != LOS_OK) {
   21700:	2800      	cmp	r0, #0
   21702:	d113      	bne.n	2172c <osMain+0x40>
    }
#endif

#if (LOSCFG_BASE_IPC_SEM == YES)
    {
        uwRet = osSemInit();
   21704:	f7ff fe58 	bl	213b8 <osSemInit>
        if (uwRet != LOS_OK) {
   21708:	2800      	cmp	r0, #0
   2170a:	d10f      	bne.n	2172c <osMain+0x40>
    }
#endif

#if (LOSCFG_BASE_IPC_MUX == YES)
    {
        uwRet = osMuxInit();
   2170c:	f7ff fcd0 	bl	210b0 <osMuxInit>
        if (uwRet != LOS_OK) {
   21710:	2800      	cmp	r0, #0
   21712:	d10b      	bne.n	2172c <osMain+0x40>
        }
    }
#endif
#if (LOSCFG_BASE_IPC_QUEUE == YES)
    {
        uwRet = osQueueInit();
   21714:	f7f2 fd96 	bl	14244 <osQueueInit>
        if (uwRet != LOS_OK) {
   21718:	2800      	cmp	r0, #0
   2171a:	d107      	bne.n	2172c <osMain+0x40>
    }
#endif

#if (LOSCFG_BASE_CORE_SWTMR == YES)
    {
        uwRet = osSwTmrInit();
   2171c:	f7f2 fb8c 	bl	13e38 <osSwTmrInit>
        if (uwRet != LOS_OK)
   21720:	2800      	cmp	r0, #0
   21722:	d103      	bne.n	2172c <osMain+0x40>
            return uwRet;
        }
    }
#endif
#if (LOSCFG_BASE_CORE_TIMESLICE == YES)
    osTimesliceInit();
   21724:	f7f2 fd68 	bl	141f8 <osTimesliceInit>
#endif

    uwRet = osIdleTaskCreate();
   21728:	f7f1 fed4 	bl	134d4 <osIdleTaskCreate>

    //extern void app_init( int argc, int argv[] );
    //app_init(0, NULL);

    return LOS_OK;
}
   2172c:	bd10      	pop	{r4, pc}
   2172e:	46c0      	nop			; (mov r8, r8)
   21730:	01002e68 	.word	0x01002e68

00021734 <ssp_remove_any_sleep_veto>:
    }
    non_os_exit_critical();
}

static void ssp_remove_any_sleep_veto(SSP_BUS bus)
{
   21734:	b510      	push	{r4, lr}
   21736:	0004      	movs	r4, r0
    non_os_enter_critical();
   21738:	f7f6 fd3c 	bl	181b4 <non_os_enter_critical>
    {
        if (ssp_sleep_vetoed[bus])
   2173c:	4b05      	ldr	r3, [pc, #20]	; (21754 <ssp_remove_any_sleep_veto+0x20>)
   2173e:	5d1a      	ldrb	r2, [r3, r4]
   21740:	2a00      	cmp	r2, #0
   21742:	d003      	beq.n	2174c <ssp_remove_any_sleep_veto+0x18>
        {
            ssp_sleep_vetoed[bus] = false;
   21744:	2200      	movs	r2, #0
   21746:	551a      	strb	r2, [r3, r4]
            osRemoveStopClocksVeto();
   21748:	f7f3 fa60 	bl	14c0c <osRemoveStopClocksVeto>
        }
    }
    non_os_exit_critical();
   2174c:	f7f6 fd46 	bl	181dc <non_os_exit_critical>
}
   21750:	bd10      	pop	{r4, pc}
   21752:	46c0      	nop			; (mov r8, r8)
   21754:	01002d74 	.word	0x01002d74

00021758 <ssp_busy_wait>:
{
   21758:	b570      	push	{r4, r5, r6, lr}
    while (hal_ssp_is_busy(bus) || (!hal_ssp_tx_fifo_is_empty(bus)))
   2175a:	2501      	movs	r5, #1
{
   2175c:	0006      	movs	r6, r0
    while (hal_ssp_is_busy(bus) || (!hal_ssp_tx_fifo_is_empty(bus)))
   2175e:	426d      	negs	r5, r5
   21760:	0030      	movs	r0, r6
   21762:	f000 fcdd 	bl	22120 <hal_ssp_is_busy>
   21766:	1e04      	subs	r4, r0, #0
   21768:	d106      	bne.n	21778 <ssp_busy_wait+0x20>
   2176a:	0030      	movs	r0, r6
   2176c:	f000 fcce 	bl	2210c <hal_ssp_tx_fifo_is_empty>
   21770:	2800      	cmp	r0, #0
   21772:	d001      	beq.n	21778 <ssp_busy_wait+0x20>
    return SPI_RET_OK;
   21774:	0020      	movs	r0, r4
}
   21776:	bd70      	pop	{r4, r5, r6, pc}
   21778:	3d01      	subs	r5, #1
        if (timeout > SSP_TIME_OUT)
   2177a:	2d00      	cmp	r5, #0
   2177c:	d1f0      	bne.n	21760 <ssp_busy_wait+0x8>
            return SPI_RET_BUSY;
   2177e:	2001      	movs	r0, #1
   21780:	e7f9      	b.n	21776 <ssp_busy_wait+0x1e>

00021782 <spi_set_pio>:
{
   21782:	b510      	push	{r4, lr}
   21784:	0004      	movs	r4, r0
   21786:	0008      	movs	r0, r1
    if (pin != PIN_NONE)
   21788:	2928      	cmp	r1, #40	; 0x28
   2178a:	d009      	beq.n	217a0 <spi_set_pio+0x1e>
            if (!pio_set_function(pin, other_func))
   2178c:	0019      	movs	r1, r3
        if (bus == SPI_BUS0)
   2178e:	2c00      	cmp	r4, #0
   21790:	d100      	bne.n	21794 <spi_set_pio+0x12>
            if (!pio_set_function(pin, bus0_func))
   21792:	0011      	movs	r1, r2
   21794:	f7f6 fd76 	bl	18284 <pio_set_function>
   21798:	2800      	cmp	r0, #0
   2179a:	d101      	bne.n	217a0 <spi_set_pio+0x1e>
                return SPI_RET_ERROR;
   2179c:	2003      	movs	r0, #3
}
   2179e:	bd10      	pop	{r4, pc}
    return SPI_RET_OK;
   217a0:	2000      	movs	r0, #0
   217a2:	e7fc      	b.n	2179e <spi_set_pio+0x1c>

000217a4 <ssp_helper_take_semaphore.constprop.9>:

inline static void ssp_helper_take_semaphore(SSP_BUS bus, osMutexId_t semaphore, uint32_t blockTime)
   217a4:	b510      	push	{r4, lr}
   217a6:	0004      	movs	r4, r0
   217a8:	0008      	movs	r0, r1
{
    if(osMutexAcquire(semaphore, blockTime) != osOK)
   217aa:	2101      	movs	r1, #1
   217ac:	4249      	negs	r1, r1
   217ae:	f7f3 f8f9 	bl	149a4 <osMutexAcquire>
   217b2:	2800      	cmp	r0, #0
   217b4:	d005      	beq.n	217c2 <ssp_helper_take_semaphore.constprop.9+0x1e>
    {
        if (bus == SSP_BUS0)
   217b6:	2c00      	cmp	r4, #0
   217b8:	d104      	bne.n	217c4 <ssp_helper_take_semaphore.constprop.9+0x20>
        {
            panic(PANIC_SSP0, PANIC_SSP_UNABLE_TO_TAKE_SEMAPHORE);
   217ba:	0021      	movs	r1, r4
   217bc:	201b      	movs	r0, #27
        }
        else
        {
            panic(PANIC_SSP1, PANIC_SSP_UNABLE_TO_TAKE_SEMAPHORE);
   217be:	f7e0 f9a7 	bl	1b10 <panic>
        }
    }
} //lint !e454 Semaphore not taken if error code returned, but Lint doesn't know that.
   217c2:	bd10      	pop	{r4, pc}
            panic(PANIC_SSP1, PANIC_SSP_UNABLE_TO_TAKE_SEMAPHORE);
   217c4:	2100      	movs	r1, #0
   217c6:	201c      	movs	r0, #28
   217c8:	e7f9      	b.n	217be <ssp_helper_take_semaphore.constprop.9+0x1a>

000217ca <ssp_helper_give_semaphore>:

inline static void ssp_helper_give_semaphore(SSP_BUS bus, osMutexId_t semaphore)
{
   217ca:	b510      	push	{r4, lr}
   217cc:	0004      	movs	r4, r0
    if (osMutexRelease(semaphore) != osOK)//lint !e455
   217ce:	0008      	movs	r0, r1
   217d0:	f7f3 f90c 	bl	149ec <osMutexRelease>
   217d4:	2800      	cmp	r0, #0
   217d6:	d005      	beq.n	217e4 <ssp_helper_give_semaphore+0x1a>
    {
        if (bus == SSP_BUS0)
   217d8:	2c00      	cmp	r4, #0
   217da:	d104      	bne.n	217e6 <ssp_helper_give_semaphore+0x1c>
            panic(PANIC_SSP0, PANIC_SSP_UNABLE_TO_TAKE_SEMAPHORE);
   217dc:	0021      	movs	r1, r4
   217de:	201b      	movs	r0, #27
        {
            panic(PANIC_SSP0, PANIC_SSP_UNABLE_TO_TAKE_SEMAPHORE);
        }
        else
        {
            panic(PANIC_SSP1, PANIC_SSP_UNABLE_TO_TAKE_SEMAPHORE);
   217e0:	f7e0 f996 	bl	1b10 <panic>
        }
    }
}
   217e4:	bd10      	pop	{r4, pc}
            panic(PANIC_SSP1, PANIC_SSP_UNABLE_TO_TAKE_SEMAPHORE);
   217e6:	2100      	movs	r1, #0
   217e8:	201c      	movs	r0, #28
   217ea:	e7f9      	b.n	217e0 <ssp_helper_give_semaphore+0x16>

000217ec <spi_release_pio>:
{
   217ec:	b510      	push	{r4, lr}
    if (pin != PIN_NONE)
   217ee:	2828      	cmp	r0, #40	; 0x28
   217f0:	d004      	beq.n	217fc <spi_release_pio+0x10>
        if (!pio_release(pin))
   217f2:	f7f6 fd3c 	bl	1826e <pio_release>
            return SPI_RET_ERROR;
   217f6:	2303      	movs	r3, #3
        if (!pio_release(pin))
   217f8:	2800      	cmp	r0, #0
   217fa:	d000      	beq.n	217fe <spi_release_pio+0x12>
    return SPI_RET_OK;
   217fc:	2300      	movs	r3, #0
}
   217fe:	0018      	movs	r0, r3
   21800:	bd10      	pop	{r4, pc}

00021802 <spi_pio_release.isra.2>:
static SPI_RET spi_pio_release (SPI_PIN spi_pin)
   21802:	b570      	push	{r4, r5, r6, lr}
   21804:	000d      	movs	r5, r1
   21806:	0016      	movs	r6, r2
   21808:	001c      	movs	r4, r3
    if(spi_release_pio(pin) != SPI_RET_OK)
   2180a:	f7ff ffef 	bl	217ec <spi_release_pio>
   2180e:	2800      	cmp	r0, #0
   21810:	d002      	beq.n	21818 <spi_pio_release.isra.2+0x16>
        return SPI_RET_ERROR;
   21812:	2403      	movs	r4, #3
}
   21814:	0020      	movs	r0, r4
   21816:	bd70      	pop	{r4, r5, r6, pc}
    if(spi_release_pio(pin) != SPI_RET_OK)
   21818:	0030      	movs	r0, r6
   2181a:	f7ff ffe7 	bl	217ec <spi_release_pio>
   2181e:	2800      	cmp	r0, #0
   21820:	d1f7      	bne.n	21812 <spi_pio_release.isra.2+0x10>
    if(spi_release_pio(pin) != SPI_RET_OK)
   21822:	0020      	movs	r0, r4
   21824:	f7ff ffe2 	bl	217ec <spi_release_pio>
   21828:	1e04      	subs	r4, r0, #0
   2182a:	d1f2      	bne.n	21812 <spi_pio_release.isra.2+0x10>
    if (pin != PIN_NONE)
   2182c:	2d28      	cmp	r5, #40	; 0x28
   2182e:	d0f1      	beq.n	21814 <spi_pio_release.isra.2+0x12>
        if (!pio_release(pin))
   21830:	0028      	movs	r0, r5
   21832:	f7f6 fd1c 	bl	1826e <pio_release>
   21836:	2800      	cmp	r0, #0
   21838:	d1ec      	bne.n	21814 <spi_pio_release.isra.2+0x12>
   2183a:	e7ea      	b.n	21812 <spi_pio_release.isra.2+0x10>

0002183c <spi_release>:
{
   2183c:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
   2183e:	0004      	movs	r4, r0
    if (bus >= SPI_BUS_MAX_NUM)
   21840:	2801      	cmp	r0, #1
   21842:	d902      	bls.n	2184a <spi_release+0xe>
        return SPI_RET_ERROR;
   21844:	2603      	movs	r6, #3
}
   21846:	0030      	movs	r0, r6
   21848:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
   2184a:	2705      	movs	r7, #5
   2184c:	4347      	muls	r7, r0
   2184e:	4b16      	ldr	r3, [pc, #88]	; (218a8 <spi_release+0x6c>)
   21850:	19dd      	adds	r5, r3, r7
    if (spi_pio_release(spi_pins[bus]) != SPI_RET_OK)
   21852:	792b      	ldrb	r3, [r5, #4]
   21854:	78ea      	ldrb	r2, [r5, #3]
   21856:	78a9      	ldrb	r1, [r5, #2]
   21858:	7868      	ldrb	r0, [r5, #1]
   2185a:	f7ff ffd2 	bl	21802 <spi_pio_release.isra.2>
   2185e:	1e06      	subs	r6, r0, #0
   21860:	d1f0      	bne.n	21844 <spi_release+0x8>
    spi_pins[bus].clk_pin   = PIN_NONE;
   21862:	2328      	movs	r3, #40	; 0x28
    spi_pins[bus].interface = SPI_INTERFACE_NONE;
   21864:	4a10      	ldr	r2, [pc, #64]	; (218a8 <spi_release+0x6c>)
    spi_pins[bus].clk_pin   = PIN_NONE;
   21866:	706b      	strb	r3, [r5, #1]
    spi_pins[bus].csb_pin   = PIN_NONE;
   21868:	70ab      	strb	r3, [r5, #2]
    spi_pins[bus].miso_pin  = PIN_NONE;
   2186a:	712b      	strb	r3, [r5, #4]
    spi_pins[bus].mosi_pin  = PIN_NONE;
   2186c:	70eb      	strb	r3, [r5, #3]
    spi_pins[bus].interface = SPI_INTERFACE_NONE;
   2186e:	3b24      	subs	r3, #36	; 0x24
   21870:	54bb      	strb	r3, [r7, r2]
    if (non_os_is_driver_initialised(ssp_inited[bus]) == false)
   21872:	4b0e      	ldr	r3, [pc, #56]	; (218ac <spi_release+0x70>)
   21874:	5d1d      	ldrb	r5, [r3, r4]
   21876:	0028      	movs	r0, r5
   21878:	f7f6 fcc4 	bl	18204 <non_os_is_driver_initialised>
   2187c:	2800      	cmp	r0, #0
   2187e:	d0e1      	beq.n	21844 <spi_release+0x8>
    hal_ssp_release((SSP_BUS)bus);
   21880:	0020      	movs	r0, r4
   21882:	f000 fb41 	bl	21f08 <hal_ssp_release>
    ssp_remove_any_sleep_veto((SSP_BUS)bus);
   21886:	0020      	movs	r0, r4
   21888:	f7ff ff54 	bl	21734 <ssp_remove_any_sleep_veto>
    return SPI_RET_OK;
}

static void ssp_delete_semaphore (SSP_BUS bus)
{
    if (ssp_mutex[bus] != NULL)
   2188c:	4f08      	ldr	r7, [pc, #32]	; (218b0 <spi_release+0x74>)
   2188e:	00a4      	lsls	r4, r4, #2
   21890:	59e0      	ldr	r0, [r4, r7]
   21892:	2800      	cmp	r0, #0
   21894:	d002      	beq.n	2189c <spi_release+0x60>
    {
        (void)osMutexDelete(ssp_mutex[bus]);
   21896:	f7f3 f8b9 	bl	14a0c <osMutexDelete>
        ssp_mutex[bus] = NULL;
   2189a:	51e6      	str	r6, [r4, r7]
    non_os_set_driver_initalised(ssp_inited[bus], false);
   2189c:	2100      	movs	r1, #0
   2189e:	0028      	movs	r0, r5
   218a0:	f7f6 fcba 	bl	18218 <non_os_set_driver_initalised>
   218a4:	e7cf      	b.n	21846 <spi_release+0xa>
   218a6:	46c0      	nop			; (mov r8, r8)
   218a8:	010005e1 	.word	0x010005e1
   218ac:	000260fa 	.word	0x000260fa
   218b0:	01002d6c 	.word	0x01002d6c

000218b4 <spi_claim>:
{
   218b4:	4673      	mov	r3, lr
   218b6:	b5f0      	push	{r4, r5, r6, r7, lr}
   218b8:	b087      	sub	sp, #28
   218ba:	9303      	str	r3, [sp, #12]
   218bc:	0004      	movs	r4, r0
   218be:	9104      	str	r1, [sp, #16]
   218c0:	9205      	str	r2, [sp, #20]
   218c2:	b2cb      	uxtb	r3, r1
    if ((bus == NULL) || (spi_pin.interface != SPI_INTERFACE_SINGLE_UNIDIR))
   218c4:	2800      	cmp	r0, #0
   218c6:	d101      	bne.n	218cc <spi_claim+0x18>
        return SPI_RET_ERROR;
   218c8:	2003      	movs	r0, #3
   218ca:	e0aa      	b.n	21a22 <spi_claim+0x16e>
    if ((bus == NULL) || (spi_pin.interface != SPI_INTERFACE_SINGLE_UNIDIR))
   218cc:	2b03      	cmp	r3, #3
   218ce:	d1fb      	bne.n	218c8 <spi_claim+0x14>
   218d0:	ab04      	add	r3, sp, #16
   218d2:	785e      	ldrb	r6, [r3, #1]
    if ((spi_pin.clk_pin == PIN_NONE) || ((spi_pin.miso_pin == PIN_NONE) && (spi_pin.mosi_pin == PIN_NONE)))
   218d4:	2e28      	cmp	r6, #40	; 0x28
   218d6:	d0f7      	beq.n	218c8 <spi_claim+0x14>
   218d8:	78df      	ldrb	r7, [r3, #3]
   218da:	791b      	ldrb	r3, [r3, #4]
   218dc:	9301      	str	r3, [sp, #4]
   218de:	2b28      	cmp	r3, #40	; 0x28
   218e0:	d101      	bne.n	218e6 <spi_claim+0x32>
   218e2:	2f28      	cmp	r7, #40	; 0x28
   218e4:	d0f0      	beq.n	218c8 <spi_claim+0x14>
   218e6:	ab04      	add	r3, sp, #16
   218e8:	789b      	ldrb	r3, [r3, #2]
   218ea:	9302      	str	r3, [sp, #8]
    non_os_enter_critical();
   218ec:	f7f6 fc62 	bl	181b4 <non_os_enter_critical>
    *bus = (SPI_BUS)hal_ssp_claim();
   218f0:	f000 fae0 	bl	21eb4 <hal_ssp_claim>
   218f4:	7020      	strb	r0, [r4, #0]
    non_os_exit_critical();
   218f6:	f7f6 fc71 	bl	181dc <non_os_exit_critical>
    if(*bus >= SPI_BUS_MAX_NUM)
   218fa:	7823      	ldrb	r3, [r4, #0]
   218fc:	2b01      	cmp	r3, #1
   218fe:	d8e3      	bhi.n	218c8 <spi_claim+0x14>
    assert(non_os_is_driver_initialised(ssp_inited[*bus]) == false);
   21900:	4a49      	ldr	r2, [pc, #292]	; (21a28 <spi_claim+0x174>)
   21902:	5cd0      	ldrb	r0, [r2, r3]
   21904:	f7f6 fc7e 	bl	18204 <non_os_is_driver_initialised>
   21908:	2800      	cmp	r0, #0
   2190a:	d003      	beq.n	21914 <spi_claim+0x60>
   2190c:	9903      	ldr	r1, [sp, #12]
   2190e:	2016      	movs	r0, #22
   21910:	f7e0 f8fe 	bl	1b10 <panic>
    ssp_mutex[bus]     = osMutexNew(NULL);
   21914:	2000      	movs	r0, #0
   21916:	7825      	ldrb	r5, [r4, #0]
   21918:	f7f3 f82e 	bl	14978 <osMutexNew>
   2191c:	4b43      	ldr	r3, [pc, #268]	; (21a2c <spi_claim+0x178>)
   2191e:	00ad      	lsls	r5, r5, #2
   21920:	50e8      	str	r0, [r5, r3]
   21922:	7823      	ldrb	r3, [r4, #0]
    if (ssp_mutex[bus] == NULL)
   21924:	2800      	cmp	r0, #0
   21926:	d014      	beq.n	21952 <spi_claim+0x9e>
    ssp_sleep_vetoed[*bus] = false;
   21928:	2100      	movs	r1, #0
   2192a:	4a41      	ldr	r2, [pc, #260]	; (21a30 <spi_claim+0x17c>)
   2192c:	54d1      	strb	r1, [r2, r3]
    non_os_set_driver_initalised(ssp_inited[*bus], true);
   2192e:	4a3e      	ldr	r2, [pc, #248]	; (21a28 <spi_claim+0x174>)
   21930:	3101      	adds	r1, #1
   21932:	5cd0      	ldrb	r0, [r2, r3]
   21934:	f7f6 fc70 	bl	18218 <non_os_set_driver_initalised>
    assert(!((spi_pins[*bus].clk_pin != PIN_NONE) || (spi_pins[*bus].csb_pin != PIN_NONE) \
   21938:	2305      	movs	r3, #5
   2193a:	7822      	ldrb	r2, [r4, #0]
   2193c:	4d3d      	ldr	r5, [pc, #244]	; (21a34 <spi_claim+0x180>)
   2193e:	4353      	muls	r3, r2
   21940:	18eb      	adds	r3, r5, r3
   21942:	785a      	ldrb	r2, [r3, #1]
   21944:	2a28      	cmp	r2, #40	; 0x28
   21946:	d008      	beq.n	2195a <spi_claim+0xa6>
   21948:	9903      	ldr	r1, [sp, #12]
   2194a:	2016      	movs	r0, #22
   2194c:	f7e0 f8e0 	bl	1b10 <panic>
   21950:	e00c      	b.n	2196c <spi_claim+0xb8>
        hal_ssp_release((SSP_BUS)*bus);
   21952:	0018      	movs	r0, r3
   21954:	f000 fad8 	bl	21f08 <hal_ssp_release>
   21958:	e7b6      	b.n	218c8 <spi_claim+0x14>
    assert(!((spi_pins[*bus].clk_pin != PIN_NONE) || (spi_pins[*bus].csb_pin != PIN_NONE) \
   2195a:	789a      	ldrb	r2, [r3, #2]
   2195c:	2a28      	cmp	r2, #40	; 0x28
   2195e:	d1f3      	bne.n	21948 <spi_claim+0x94>
   21960:	78da      	ldrb	r2, [r3, #3]
   21962:	2a28      	cmp	r2, #40	; 0x28
   21964:	d1f0      	bne.n	21948 <spi_claim+0x94>
   21966:	791b      	ldrb	r3, [r3, #4]
   21968:	2b28      	cmp	r3, #40	; 0x28
   2196a:	d1ed      	bne.n	21948 <spi_claim+0x94>
    if((spi_pins[*bus].clk_pin != PIN_NONE) || (spi_pins[*bus].csb_pin != PIN_NONE) \
   2196c:	2305      	movs	r3, #5
   2196e:	7822      	ldrb	r2, [r4, #0]
   21970:	4353      	muls	r3, r2
   21972:	18eb      	adds	r3, r5, r3
   21974:	7859      	ldrb	r1, [r3, #1]
   21976:	2928      	cmp	r1, #40	; 0x28
   21978:	d115      	bne.n	219a6 <spi_claim+0xf2>
   2197a:	7899      	ldrb	r1, [r3, #2]
   2197c:	2928      	cmp	r1, #40	; 0x28
   2197e:	d112      	bne.n	219a6 <spi_claim+0xf2>
        || (spi_pins[*bus].mosi_pin != PIN_NONE) || (spi_pins[*bus].miso_pin != PIN_NONE))
   21980:	78d9      	ldrb	r1, [r3, #3]
   21982:	2928      	cmp	r1, #40	; 0x28
   21984:	d10f      	bne.n	219a6 <spi_claim+0xf2>
   21986:	791b      	ldrb	r3, [r3, #4]
   21988:	2b28      	cmp	r3, #40	; 0x28
   2198a:	d10c      	bne.n	219a6 <spi_claim+0xf2>
    if (spi_pio_claim(*bus, spi_pin) != SPI_RET_OK)
   2198c:	7825      	ldrb	r5, [r4, #0]
    if(spi_set_pio(bus, pin, FUNC_SSP0CLK, FUNC_SSP1CLK) != SPI_RET_OK)
   2198e:	23c9      	movs	r3, #201	; 0xc9
   21990:	22c7      	movs	r2, #199	; 0xc7
   21992:	0031      	movs	r1, r6
   21994:	0028      	movs	r0, r5
   21996:	f7ff fef4 	bl	21782 <spi_set_pio>
   2199a:	2800      	cmp	r0, #0
   2199c:	d00f      	beq.n	219be <spi_claim+0x10a>
        (void)spi_release(*bus);
   2199e:	7820      	ldrb	r0, [r4, #0]
   219a0:	f7ff ff4c 	bl	2183c <spi_release>
   219a4:	e790      	b.n	218c8 <spi_claim+0x14>
   219a6:	2305      	movs	r3, #5
   219a8:	4353      	muls	r3, r2
   219aa:	18ed      	adds	r5, r5, r3
        if (spi_pio_release(spi_pins[*bus]) != SPI_RET_OK)
   219ac:	792b      	ldrb	r3, [r5, #4]
   219ae:	78ea      	ldrb	r2, [r5, #3]
   219b0:	78a9      	ldrb	r1, [r5, #2]
   219b2:	7868      	ldrb	r0, [r5, #1]
   219b4:	f7ff ff25 	bl	21802 <spi_pio_release.isra.2>
   219b8:	2800      	cmp	r0, #0
   219ba:	d0e7      	beq.n	2198c <spi_claim+0xd8>
   219bc:	e784      	b.n	218c8 <spi_claim+0x14>
    if(spi_set_pio(bus, pin, FUNC_SSP0TXD, FUNC_SSP1TXD) != SPI_RET_OK)
   219be:	23cb      	movs	r3, #203	; 0xcb
   219c0:	22c4      	movs	r2, #196	; 0xc4
   219c2:	0039      	movs	r1, r7
   219c4:	0028      	movs	r0, r5
   219c6:	f7ff fedc 	bl	21782 <spi_set_pio>
   219ca:	2800      	cmp	r0, #0
   219cc:	d1e7      	bne.n	2199e <spi_claim+0xea>
    if(spi_set_pio(bus, pin, FUNC_SSP0RXD, FUNC_SSP1RXD) != SPI_RET_OK)
   219ce:	23cc      	movs	r3, #204	; 0xcc
   219d0:	22c5      	movs	r2, #197	; 0xc5
   219d2:	9901      	ldr	r1, [sp, #4]
   219d4:	0028      	movs	r0, r5
   219d6:	f7ff fed4 	bl	21782 <spi_set_pio>
   219da:	2800      	cmp	r0, #0
   219dc:	d1df      	bne.n	2199e <spi_claim+0xea>
    if(spi_set_pio(bus, pin, FUNC_SSP0FSS, FUNC_SSP1FSS) != SPI_RET_OK)
   219de:	23ca      	movs	r3, #202	; 0xca
   219e0:	22c8      	movs	r2, #200	; 0xc8
   219e2:	9902      	ldr	r1, [sp, #8]
   219e4:	0028      	movs	r0, r5
   219e6:	f7ff fecc 	bl	21782 <spi_set_pio>
   219ea:	2800      	cmp	r0, #0
   219ec:	d1d7      	bne.n	2199e <spi_claim+0xea>
    spi_pins[*bus].clk_pin   = spi_pin.clk_pin;
   219ee:	2305      	movs	r3, #5
    spi_pins[*bus].csb_pin   = spi_pin.csb_pin;
   219f0:	466d      	mov	r5, sp
    spi_pins[*bus].clk_pin   = spi_pin.clk_pin;
   219f2:	7821      	ldrb	r1, [r4, #0]
   219f4:	4a0f      	ldr	r2, [pc, #60]	; (21a34 <spi_claim+0x180>)
   219f6:	4359      	muls	r1, r3
   219f8:	1851      	adds	r1, r2, r1
   219fa:	704e      	strb	r6, [r1, #1]
    spi_pins[*bus].csb_pin   = spi_pin.csb_pin;
   219fc:	7821      	ldrb	r1, [r4, #0]
   219fe:	7a2d      	ldrb	r5, [r5, #8]
   21a00:	4359      	muls	r1, r3
   21a02:	1851      	adds	r1, r2, r1
   21a04:	708d      	strb	r5, [r1, #2]
    spi_pins[*bus].miso_pin  = spi_pin.miso_pin;
   21a06:	466d      	mov	r5, sp
   21a08:	7821      	ldrb	r1, [r4, #0]
   21a0a:	792d      	ldrb	r5, [r5, #4]
   21a0c:	4359      	muls	r1, r3
   21a0e:	1851      	adds	r1, r2, r1
   21a10:	710d      	strb	r5, [r1, #4]
    spi_pins[*bus].mosi_pin  = spi_pin.mosi_pin;
   21a12:	7821      	ldrb	r1, [r4, #0]
   21a14:	4359      	muls	r1, r3
   21a16:	1851      	adds	r1, r2, r1
   21a18:	70cf      	strb	r7, [r1, #3]
    spi_pins[*bus].interface = spi_pin.interface;
   21a1a:	7821      	ldrb	r1, [r4, #0]
   21a1c:	434b      	muls	r3, r1
   21a1e:	2103      	movs	r1, #3
   21a20:	5499      	strb	r1, [r3, r2]
}
   21a22:	b007      	add	sp, #28
   21a24:	bdf0      	pop	{r4, r5, r6, r7, pc}
   21a26:	46c0      	nop			; (mov r8, r8)
   21a28:	000260fa 	.word	0x000260fa
   21a2c:	01002d6c 	.word	0x01002d6c
   21a30:	01002d74 	.word	0x01002d74
   21a34:	010005e1 	.word	0x010005e1

00021a38 <spi_activate>:
{
   21a38:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
    if(non_os_is_driver_initialised(ssp_inited[bus]) == false)
   21a3a:	4b22      	ldr	r3, [pc, #136]	; (21ac4 <spi_activate+0x8c>)
{
   21a3c:	0004      	movs	r4, r0
    if(non_os_is_driver_initialised(ssp_inited[bus]) == false)
   21a3e:	5c18      	ldrb	r0, [r3, r0]
{
   21a40:	9101      	str	r1, [sp, #4]
    if(non_os_is_driver_initialised(ssp_inited[bus]) == false)
   21a42:	f7f6 fbdf 	bl	18204 <non_os_is_driver_initialised>
{
   21a46:	ae01      	add	r6, sp, #4
        return SPI_RET_UNINIT;
   21a48:	2302      	movs	r3, #2
    if(non_os_is_driver_initialised(ssp_inited[bus]) == false)
   21a4a:	2800      	cmp	r0, #0
   21a4c:	d009      	beq.n	21a62 <spi_activate+0x2a>
    hal_ssp_disable((SSP_BUS)bus);
   21a4e:	0020      	movs	r0, r4
   21a50:	f000 fb26 	bl	220a0 <hal_ssp_disable>
    if (!((hal_ssp_set_frame_format((SSP_BUS)bus, SSP_SPI_FRF)) && (hal_ssp_set_spi_mode((SSP_BUS)bus, (SSP_SPI_CLK_MODE)config.clk_mode))))
   21a54:	2100      	movs	r1, #0
   21a56:	0020      	movs	r0, r4
   21a58:	f000 faa2 	bl	21fa0 <hal_ssp_set_frame_format>
   21a5c:	2800      	cmp	r0, #0
   21a5e:	d102      	bne.n	21a66 <spi_activate+0x2e>
        return SPI_RET_ERROR;
   21a60:	2303      	movs	r3, #3
}
   21a62:	0018      	movs	r0, r3
   21a64:	bdfe      	pop	{r1, r2, r3, r4, r5, r6, r7, pc}
    if (!((hal_ssp_set_frame_format((SSP_BUS)bus, SSP_SPI_FRF)) && (hal_ssp_set_spi_mode((SSP_BUS)bus, (SSP_SPI_CLK_MODE)config.clk_mode))))
   21a66:	78b1      	ldrb	r1, [r6, #2]
   21a68:	0020      	movs	r0, r4
   21a6a:	f000 fab5 	bl	21fd8 <hal_ssp_set_spi_mode>
   21a6e:	2800      	cmp	r0, #0
   21a70:	d0f6      	beq.n	21a60 <spi_activate+0x28>
    ssp_helper_take_semaphore((SSP_BUS)bus, ssp_mutex[bus], osWaitForever);
   21a72:	4d15      	ldr	r5, [pc, #84]	; (21ac8 <spi_activate+0x90>)
   21a74:	00a7      	lsls	r7, r4, #2
   21a76:	5979      	ldr	r1, [r7, r5]
   21a78:	0020      	movs	r0, r4
   21a7a:	f7ff fe93 	bl	217a4 <ssp_helper_take_semaphore.constprop.9>
    if (!(((hal_ssp_set_data_size((SSP_BUS)bus, config.data_size)))
   21a7e:	7831      	ldrb	r1, [r6, #0]
   21a80:	0020      	movs	r0, r4
   21a82:	f000 fa5d 	bl	21f40 <hal_ssp_set_data_size>
   21a86:	2800      	cmp	r0, #0
   21a88:	d104      	bne.n	21a94 <spi_activate+0x5c>
        ssp_helper_give_semaphore((SSP_BUS)bus, ssp_mutex[bus]);
   21a8a:	59e9      	ldr	r1, [r5, r7]
   21a8c:	0020      	movs	r0, r4
   21a8e:	f7ff fe9c 	bl	217ca <ssp_helper_give_semaphore>
   21a92:	e7e5      	b.n	21a60 <spi_activate+0x28>
            && (hal_ssp_set_serial_clock_rate((SSP_BUS)bus, SSP_SPI_DEFAULT_SCR))
   21a94:	210c      	movs	r1, #12
   21a96:	0020      	movs	r0, r4
   21a98:	f000 faba 	bl	22010 <hal_ssp_set_serial_clock_rate>
   21a9c:	2800      	cmp	r0, #0
   21a9e:	d0f4      	beq.n	21a8a <spi_activate+0x52>
            && (hal_ssp_set_clock_prescale((SSP_BUS)bus, config.clk_div))))
   21aa0:	7871      	ldrb	r1, [r6, #1]
   21aa2:	0020      	movs	r0, r4
   21aa4:	f000 face 	bl	22044 <hal_ssp_set_clock_prescale>
    if (!(((hal_ssp_set_data_size((SSP_BUS)bus, config.data_size)))
   21aa8:	2800      	cmp	r0, #0
   21aaa:	d0ee      	beq.n	21a8a <spi_activate+0x52>
    hal_ssp_disable_all_interrupts((SSP_BUS)bus);
   21aac:	0020      	movs	r0, r4
   21aae:	f000 fbb7 	bl	22220 <hal_ssp_disable_all_interrupts>
    ssp_helper_give_semaphore((SSP_BUS)bus, ssp_mutex[bus]);
   21ab2:	5979      	ldr	r1, [r7, r5]
   21ab4:	0020      	movs	r0, r4
   21ab6:	f7ff fe88 	bl	217ca <ssp_helper_give_semaphore>
    hal_ssp_enable((SSP_BUS)bus);
   21aba:	0020      	movs	r0, r4
   21abc:	f000 fade 	bl	2207c <hal_ssp_enable>
    return SPI_RET_OK;
   21ac0:	2300      	movs	r3, #0
   21ac2:	e7ce      	b.n	21a62 <spi_activate+0x2a>
   21ac4:	000260fa 	.word	0x000260fa
   21ac8:	01002d6c 	.word	0x01002d6c

00021acc <spi_send_data>:
{
   21acc:	b5f0      	push	{r4, r5, r6, r7, lr}
   21ace:	4674      	mov	r4, lr
   21ad0:	b087      	sub	sp, #28
   21ad2:	9302      	str	r3, [sp, #8]
   21ad4:	ab0c      	add	r3, sp, #48	; 0x30
   21ad6:	881b      	ldrh	r3, [r3, #0]
   21ad8:	9405      	str	r4, [sp, #20]
   21ada:	0005      	movs	r5, r0
   21adc:	9101      	str	r1, [sp, #4]
   21ade:	9203      	str	r2, [sp, #12]
   21ae0:	9304      	str	r3, [sp, #16]
    uint8  bytes       = MIN_NUMBER_OF_BYTES_TO_STORE_BITS(hal_ssp_get_data_size(ssp_bus));
   21ae2:	f000 fa4b 	bl	21f7c <hal_ssp_get_data_size>
    if (non_os_is_driver_initialised(ssp_inited[ssp_bus]) == false)
   21ae6:	4b61      	ldr	r3, [pc, #388]	; (21c6c <spi_send_data+0x1a0>)
    uint8  bytes       = MIN_NUMBER_OF_BYTES_TO_STORE_BITS(hal_ssp_get_data_size(ssp_bus));
   21ae8:	0004      	movs	r4, r0
    if (non_os_is_driver_initialised(ssp_inited[ssp_bus]) == false)
   21aea:	5d58      	ldrb	r0, [r3, r5]
   21aec:	f7f6 fb8a 	bl	18204 <non_os_is_driver_initialised>
        return SPI_RET_UNINIT;
   21af0:	2602      	movs	r6, #2
    if (non_os_is_driver_initialised(ssp_inited[ssp_bus]) == false)
   21af2:	2800      	cmp	r0, #0
   21af4:	d009      	beq.n	21b0a <spi_send_data+0x3e>
    if (((cmd_buff == NULL) && (cmd_len != 0)) || ((data_buff == NULL) && (data_len != 0)) \
   21af6:	9b01      	ldr	r3, [sp, #4]
    uint8  bytes       = MIN_NUMBER_OF_BYTES_TO_STORE_BITS(hal_ssp_get_data_size(ssp_bus));
   21af8:	3407      	adds	r4, #7
   21afa:	10e7      	asrs	r7, r4, #3
    if (((cmd_buff == NULL) && (cmd_len != 0)) || ((data_buff == NULL) && (data_len != 0)) \
   21afc:	2b00      	cmp	r3, #0
   21afe:	d107      	bne.n	21b10 <spi_send_data+0x44>
   21b00:	9b03      	ldr	r3, [sp, #12]
        return SPI_RET_ERROR;
   21b02:	3601      	adds	r6, #1
    if (((cmd_buff == NULL) && (cmd_len != 0)) || ((data_buff == NULL) && (data_len != 0)) \
   21b04:	2b00      	cmp	r3, #0
   21b06:	d100      	bne.n	21b0a <spi_send_data+0x3e>
   21b08:	e0a9      	b.n	21c5e <spi_send_data+0x192>
} //lint !e818
   21b0a:	0030      	movs	r0, r6
   21b0c:	b007      	add	sp, #28
   21b0e:	bdf0      	pop	{r4, r5, r6, r7, pc}
    if (((cmd_buff == NULL) && (cmd_len != 0)) || ((data_buff == NULL) && (data_len != 0)) \
   21b10:	9b02      	ldr	r3, [sp, #8]
   21b12:	2b00      	cmp	r3, #0
   21b14:	d103      	bne.n	21b1e <spi_send_data+0x52>
   21b16:	9b04      	ldr	r3, [sp, #16]
        return SPI_RET_ERROR;
   21b18:	2603      	movs	r6, #3
    if (((cmd_buff == NULL) && (cmd_len != 0)) || ((data_buff == NULL) && (data_len != 0)) \
   21b1a:	2b00      	cmp	r3, #0
   21b1c:	d1f5      	bne.n	21b0a <spi_send_data+0x3e>
        || ((cmd_len % bytes) != 0x00) || ((data_len % bytes) != 0x00))
   21b1e:	9c03      	ldr	r4, [sp, #12]
   21b20:	0039      	movs	r1, r7
   21b22:	0020      	movs	r0, r4
   21b24:	f7de fdb8 	bl	698 <__aeabi_idivmod>
        return SPI_RET_ERROR;
   21b28:	2603      	movs	r6, #3
        || ((cmd_len % bytes) != 0x00) || ((data_len % bytes) != 0x00))
   21b2a:	2900      	cmp	r1, #0
   21b2c:	d1ed      	bne.n	21b0a <spi_send_data+0x3e>
   21b2e:	9804      	ldr	r0, [sp, #16]
   21b30:	0039      	movs	r1, r7
   21b32:	f7de fdb1 	bl	698 <__aeabi_idivmod>
        return SPI_RET_ERROR;
   21b36:	2603      	movs	r6, #3
   21b38:	9004      	str	r0, [sp, #16]
        || ((cmd_len % bytes) != 0x00) || ((data_len % bytes) != 0x00))
   21b3a:	2900      	cmp	r1, #0
   21b3c:	d1e5      	bne.n	21b0a <spi_send_data+0x3e>
    ssp_helper_take_semaphore(ssp_bus, ssp_mutex[ssp_bus], osWaitForever);
   21b3e:	4b4c      	ldr	r3, [pc, #304]	; (21c70 <spi_send_data+0x1a4>)
   21b40:	00aa      	lsls	r2, r5, #2
   21b42:	58d1      	ldr	r1, [r2, r3]
   21b44:	0028      	movs	r0, r5
   21b46:	f7ff fe2d 	bl	217a4 <ssp_helper_take_semaphore.constprop.9>
    if (ssp_busy_wait(ssp_bus) != SPI_RET_OK)
   21b4a:	0028      	movs	r0, r5
   21b4c:	f7ff fe04 	bl	21758 <ssp_busy_wait>
   21b50:	1e06      	subs	r6, r0, #0
   21b52:	d113      	bne.n	21b7c <spi_send_data+0xb0>
    assert( ! (hal_ssp_is_busy(ssp_bus) || (!hal_ssp_tx_fifo_is_empty(ssp_bus))));  //Unless someone has accessed the hal layer under us we should not get here under normal conditions
   21b54:	0028      	movs	r0, r5
   21b56:	f000 fae3 	bl	22120 <hal_ssp_is_busy>
   21b5a:	2800      	cmp	r0, #0
   21b5c:	d010      	beq.n	21b80 <spi_send_data+0xb4>
   21b5e:	9905      	ldr	r1, [sp, #20]
   21b60:	2016      	movs	r0, #22
   21b62:	f7df ffd5 	bl	1b10 <panic>
    if (hal_ssp_is_busy(ssp_bus) || (!hal_ssp_tx_fifo_is_empty(ssp_bus)))
   21b66:	0028      	movs	r0, r5
   21b68:	f000 fada 	bl	22120 <hal_ssp_is_busy>
   21b6c:	2800      	cmp	r0, #0
   21b6e:	d00d      	beq.n	21b8c <spi_send_data+0xc0>
        ssp_helper_give_semaphore(ssp_bus, ssp_mutex[ssp_bus]);
   21b70:	4b3f      	ldr	r3, [pc, #252]	; (21c70 <spi_send_data+0x1a4>)
   21b72:	00aa      	lsls	r2, r5, #2
   21b74:	58d1      	ldr	r1, [r2, r3]
   21b76:	0028      	movs	r0, r5
   21b78:	f7ff fe27 	bl	217ca <ssp_helper_give_semaphore>
        return SPI_RET_BUSY;
   21b7c:	2601      	movs	r6, #1
   21b7e:	e7c4      	b.n	21b0a <spi_send_data+0x3e>
    assert( ! (hal_ssp_is_busy(ssp_bus) || (!hal_ssp_tx_fifo_is_empty(ssp_bus))));  //Unless someone has accessed the hal layer under us we should not get here under normal conditions
   21b80:	0028      	movs	r0, r5
   21b82:	f000 fac3 	bl	2210c <hal_ssp_tx_fifo_is_empty>
   21b86:	2800      	cmp	r0, #0
   21b88:	d0e9      	beq.n	21b5e <spi_send_data+0x92>
   21b8a:	e7ec      	b.n	21b66 <spi_send_data+0x9a>
    if (hal_ssp_is_busy(ssp_bus) || (!hal_ssp_tx_fifo_is_empty(ssp_bus)))
   21b8c:	0028      	movs	r0, r5
   21b8e:	f000 fabd 	bl	2210c <hal_ssp_tx_fifo_is_empty>
   21b92:	2800      	cmp	r0, #0
   21b94:	d0ec      	beq.n	21b70 <spi_send_data+0xa4>
    non_os_enter_critical();
   21b96:	f7f6 fb0d 	bl	181b4 <non_os_enter_critical>
        if (!ssp_sleep_vetoed[bus])
   21b9a:	4b36      	ldr	r3, [pc, #216]	; (21c74 <spi_send_data+0x1a8>)
   21b9c:	5d5a      	ldrb	r2, [r3, r5]
   21b9e:	2a00      	cmp	r2, #0
   21ba0:	d103      	bne.n	21baa <spi_send_data+0xde>
            ssp_sleep_vetoed[bus] = true;
   21ba2:	3201      	adds	r2, #1
   21ba4:	555a      	strb	r2, [r3, r5]
            osAddStopClocksVeto();
   21ba6:	f7f3 f82d 	bl	14c04 <osAddStopClocksVeto>
    non_os_exit_critical();
   21baa:	f7f6 fb17 	bl	181dc <non_os_exit_critical>
    non_os_enter_critical();
   21bae:	f7f6 fb01 	bl	181b4 <non_os_enter_critical>
    while (bytes_sent < (cmd_len / bytes))
   21bb2:	0020      	movs	r0, r4
   21bb4:	0039      	movs	r1, r7
   21bb6:	f7de fc89 	bl	4cc <__divsi3>
    uint16 bytes_sent = 0;
   21bba:	2400      	movs	r4, #0
    while (bytes_sent < (cmd_len / bytes))
   21bbc:	9003      	str	r0, [sp, #12]
   21bbe:	9b03      	ldr	r3, [sp, #12]
   21bc0:	429c      	cmp	r4, r3
   21bc2:	db14      	blt.n	21bee <spi_send_data+0x122>
    bytes_sent = 0;
   21bc4:	2400      	movs	r4, #0
    while (bytes_sent < (data_len / bytes))
   21bc6:	9b04      	ldr	r3, [sp, #16]
   21bc8:	429c      	cmp	r4, r3
   21bca:	db2c      	blt.n	21c26 <spi_send_data+0x15a>
    non_os_exit_critical();
   21bcc:	f7f6 fb06 	bl	181dc <non_os_exit_critical>
    if (callback != NULL)
   21bd0:	9b0d      	ldr	r3, [sp, #52]	; 0x34
   21bd2:	2b00      	cmp	r3, #0
   21bd4:	d001      	beq.n	21bda <spi_send_data+0x10e>
        (*callback)(SPI_RET_OK);
   21bd6:	2000      	movs	r0, #0
   21bd8:	4798      	blx	r3
    ssp_remove_any_sleep_veto(ssp_bus);                    //todo How can we do this here? the data might not have finished sending
   21bda:	0028      	movs	r0, r5
   21bdc:	f7ff fdaa 	bl	21734 <ssp_remove_any_sleep_veto>
    ssp_helper_give_semaphore(ssp_bus, ssp_mutex[ssp_bus]);
   21be0:	4b23      	ldr	r3, [pc, #140]	; (21c70 <spi_send_data+0x1a4>)
   21be2:	00aa      	lsls	r2, r5, #2
   21be4:	58d1      	ldr	r1, [r2, r3]
   21be6:	0028      	movs	r0, r5
   21be8:	f7ff fdef 	bl	217ca <ssp_helper_give_semaphore>
    return SPI_RET_OK;
   21bec:	e78d      	b.n	21b0a <spi_send_data+0x3e>
        if ((!hal_ssp_tx_fifo_is_full(ssp_bus)) && (cmd_buff != NULL))
   21bee:	0028      	movs	r0, r5
   21bf0:	f000 fa78 	bl	220e4 <hal_ssp_tx_fifo_is_full>
   21bf4:	2800      	cmp	r0, #0
   21bf6:	d1e2      	bne.n	21bbe <spi_send_data+0xf2>
   21bf8:	9b01      	ldr	r3, [sp, #4]
   21bfa:	2b00      	cmp	r3, #0
   21bfc:	d0df      	beq.n	21bbe <spi_send_data+0xf2>
   21bfe:	781b      	ldrb	r3, [r3, #0]
    if (bytes == 1)
   21c00:	2f01      	cmp	r7, #1
   21c02:	d10a      	bne.n	21c1a <spi_send_data+0x14e>
        return (uint16)(*src);
   21c04:	b219      	sxth	r1, r3
            hal_ssp_write_data(ssp_bus, (uint16)ssp_pack_into_fifo_data(bytes, cmd_buff));
   21c06:	b289      	uxth	r1, r1
   21c08:	0028      	movs	r0, r5
   21c0a:	f000 fa5b 	bl	220c4 <hal_ssp_write_data>
            cmd_buff += bytes;
   21c0e:	9b01      	ldr	r3, [sp, #4]
            bytes_sent++;
   21c10:	3401      	adds	r4, #1
            cmd_buff += bytes;
   21c12:	19db      	adds	r3, r3, r7
   21c14:	9301      	str	r3, [sp, #4]
            bytes_sent++;
   21c16:	b2a4      	uxth	r4, r4
   21c18:	e7d1      	b.n	21bbe <spi_send_data+0xf2>
        return (int16)((uint16)(*src) + (((uint16)(*(src + 1))) << 8));
   21c1a:	9a01      	ldr	r2, [sp, #4]
   21c1c:	7851      	ldrb	r1, [r2, #1]
   21c1e:	0209      	lsls	r1, r1, #8
   21c20:	18c9      	adds	r1, r1, r3
   21c22:	b209      	sxth	r1, r1
   21c24:	e7ef      	b.n	21c06 <spi_send_data+0x13a>
        if (!hal_ssp_tx_fifo_is_full(ssp_bus))
   21c26:	0028      	movs	r0, r5
   21c28:	f000 fa5c 	bl	220e4 <hal_ssp_tx_fifo_is_full>
   21c2c:	2800      	cmp	r0, #0
   21c2e:	d1ca      	bne.n	21bc6 <spi_send_data+0xfa>
            if (data_buff != NULL)
   21c30:	9b02      	ldr	r3, [sp, #8]
   21c32:	2b00      	cmp	r3, #0
   21c34:	d00a      	beq.n	21c4c <spi_send_data+0x180>
   21c36:	781b      	ldrb	r3, [r3, #0]
    if (bytes == 1)
   21c38:	2f01      	cmp	r7, #1
   21c3a:	d10a      	bne.n	21c52 <spi_send_data+0x186>
        return (uint16)(*src);
   21c3c:	b219      	sxth	r1, r3
                hal_ssp_write_data(ssp_bus, (uint16)ssp_pack_into_fifo_data(bytes, data_buff));
   21c3e:	b289      	uxth	r1, r1
   21c40:	0028      	movs	r0, r5
   21c42:	f000 fa3f 	bl	220c4 <hal_ssp_write_data>
                data_buff += bytes;
   21c46:	9b02      	ldr	r3, [sp, #8]
   21c48:	19db      	adds	r3, r3, r7
   21c4a:	9302      	str	r3, [sp, #8]
            bytes_sent++;
   21c4c:	3401      	adds	r4, #1
   21c4e:	b2a4      	uxth	r4, r4
   21c50:	e7b9      	b.n	21bc6 <spi_send_data+0xfa>
        return (int16)((uint16)(*src) + (((uint16)(*(src + 1))) << 8));
   21c52:	9a02      	ldr	r2, [sp, #8]
   21c54:	7851      	ldrb	r1, [r2, #1]
   21c56:	0209      	lsls	r1, r1, #8
   21c58:	18c9      	adds	r1, r1, r3
   21c5a:	b209      	sxth	r1, r1
   21c5c:	e7ef      	b.n	21c3e <spi_send_data+0x172>
    if (((cmd_buff == NULL) && (cmd_len != 0)) || ((data_buff == NULL) && (data_len != 0)) \
   21c5e:	9b02      	ldr	r3, [sp, #8]
        || ((cmd_len % bytes) != 0x00) || ((data_len % bytes) != 0x00))
   21c60:	9c01      	ldr	r4, [sp, #4]
    if (((cmd_buff == NULL) && (cmd_len != 0)) || ((data_buff == NULL) && (data_len != 0)) \
   21c62:	2b00      	cmp	r3, #0
   21c64:	d000      	beq.n	21c68 <spi_send_data+0x19c>
   21c66:	e762      	b.n	21b2e <spi_send_data+0x62>
   21c68:	e755      	b.n	21b16 <spi_send_data+0x4a>
   21c6a:	46c0      	nop			; (mov r8, r8)
   21c6c:	000260fa 	.word	0x000260fa
   21c70:	01002d6c 	.word	0x01002d6c
   21c74:	01002d74 	.word	0x01002d74

00021c78 <spi_recv_data>:
{
   21c78:	b5f0      	push	{r4, r5, r6, r7, lr}
   21c7a:	4674      	mov	r4, lr
   21c7c:	b089      	sub	sp, #36	; 0x24
   21c7e:	9301      	str	r3, [sp, #4]
   21c80:	ab0e      	add	r3, sp, #56	; 0x38
   21c82:	881e      	ldrh	r6, [r3, #0]
   21c84:	ab10      	add	r3, sp, #64	; 0x40
   21c86:	781b      	ldrb	r3, [r3, #0]
   21c88:	9407      	str	r4, [sp, #28]
   21c8a:	000d      	movs	r5, r1
   21c8c:	0004      	movs	r4, r0
   21c8e:	9203      	str	r2, [sp, #12]
   21c90:	9305      	str	r3, [sp, #20]
    uint8  bytes      = MIN_NUMBER_OF_BYTES_TO_STORE_BITS(hal_ssp_get_data_size(ssp_bus));
   21c92:	f000 f973 	bl	21f7c <hal_ssp_get_data_size>
    if (non_os_is_driver_initialised(ssp_inited[ssp_bus]) == false)
   21c96:	4b84      	ldr	r3, [pc, #528]	; (21ea8 <spi_recv_data+0x230>)
    uint8  bytes      = MIN_NUMBER_OF_BYTES_TO_STORE_BITS(hal_ssp_get_data_size(ssp_bus));
   21c98:	0007      	movs	r7, r0
    if (non_os_is_driver_initialised(ssp_inited[ssp_bus]) == false)
   21c9a:	5d18      	ldrb	r0, [r3, r4]
   21c9c:	f7f6 fab2 	bl	18204 <non_os_is_driver_initialised>
        return SPI_RET_UNINIT;
   21ca0:	2302      	movs	r3, #2
   21ca2:	9300      	str	r3, [sp, #0]
    if (non_os_is_driver_initialised(ssp_inited[ssp_bus]) == false)
   21ca4:	2800      	cmp	r0, #0
   21ca6:	d032      	beq.n	21d0e <spi_recv_data+0x96>
        return SPI_RET_ERROR;
   21ca8:	3301      	adds	r3, #1
   21caa:	9300      	str	r3, [sp, #0]
    if ((data_buff == NULL) || (data_len == 0) || ((cmd_buff == NULL) && (cmd_len != 0)) \
   21cac:	9b01      	ldr	r3, [sp, #4]
   21cae:	2b00      	cmp	r3, #0
   21cb0:	d02d      	beq.n	21d0e <spi_recv_data+0x96>
   21cb2:	2e00      	cmp	r6, #0
   21cb4:	d02b      	beq.n	21d0e <spi_recv_data+0x96>
   21cb6:	2d00      	cmp	r5, #0
   21cb8:	d102      	bne.n	21cc0 <spi_recv_data+0x48>
   21cba:	9b03      	ldr	r3, [sp, #12]
   21cbc:	2b00      	cmp	r3, #0
   21cbe:	d126      	bne.n	21d0e <spi_recv_data+0x96>
    uint8  bytes      = MIN_NUMBER_OF_BYTES_TO_STORE_BITS(hal_ssp_get_data_size(ssp_bus));
   21cc0:	3707      	adds	r7, #7
   21cc2:	10fb      	asrs	r3, r7, #3
   21cc4:	0019      	movs	r1, r3
   21cc6:	9803      	ldr	r0, [sp, #12]
   21cc8:	9302      	str	r3, [sp, #8]
   21cca:	f7de fce5 	bl	698 <__aeabi_idivmod>
        return SPI_RET_ERROR;
   21cce:	2303      	movs	r3, #3
   21cd0:	9004      	str	r0, [sp, #16]
   21cd2:	9300      	str	r3, [sp, #0]
        || ((cmd_len % bytes) != 0x00) || ((data_len % bytes) != 0x00))
   21cd4:	2900      	cmp	r1, #0
   21cd6:	d11a      	bne.n	21d0e <spi_recv_data+0x96>
   21cd8:	9902      	ldr	r1, [sp, #8]
   21cda:	0030      	movs	r0, r6
   21cdc:	f7de fcdc 	bl	698 <__aeabi_idivmod>
        return SPI_RET_ERROR;
   21ce0:	2303      	movs	r3, #3
   21ce2:	9006      	str	r0, [sp, #24]
   21ce4:	9300      	str	r3, [sp, #0]
        || ((cmd_len % bytes) != 0x00) || ((data_len % bytes) != 0x00))
   21ce6:	2900      	cmp	r1, #0
   21ce8:	d111      	bne.n	21d0e <spi_recv_data+0x96>
    ssp_helper_take_semaphore(ssp_bus, ssp_mutex[ssp_bus], osWaitForever);
   21cea:	4e70      	ldr	r6, [pc, #448]	; (21eac <spi_recv_data+0x234>)
   21cec:	00a7      	lsls	r7, r4, #2
   21cee:	59b9      	ldr	r1, [r7, r6]
   21cf0:	0020      	movs	r0, r4
   21cf2:	f7ff fd57 	bl	217a4 <ssp_helper_take_semaphore.constprop.9>
    if (ssp_busy_wait(ssp_bus) != SPI_RET_OK)
   21cf6:	0020      	movs	r0, r4
   21cf8:	f7ff fd2e 	bl	21758 <ssp_busy_wait>
   21cfc:	9000      	str	r0, [sp, #0]
   21cfe:	2800      	cmp	r0, #0
   21d00:	d00b      	beq.n	21d1a <spi_recv_data+0xa2>
        ssp_helper_give_semaphore(ssp_bus, ssp_mutex[ssp_bus]);
   21d02:	59b9      	ldr	r1, [r7, r6]
   21d04:	0020      	movs	r0, r4
   21d06:	f7ff fd60 	bl	217ca <ssp_helper_give_semaphore>
        return SPI_RET_BUSY;
   21d0a:	2301      	movs	r3, #1
   21d0c:	9300      	str	r3, [sp, #0]
}
   21d0e:	9800      	ldr	r0, [sp, #0]
   21d10:	b009      	add	sp, #36	; 0x24
   21d12:	bdf0      	pop	{r4, r5, r6, r7, pc}
        (void)hal_ssp_read_data(ssp_bus);
   21d14:	0020      	movs	r0, r4
   21d16:	f000 f9dd 	bl	220d4 <hal_ssp_read_data>
    while (!hal_ssp_rx_fifo_is_empty(ssp_bus))
   21d1a:	0020      	movs	r0, r4
   21d1c:	f000 f9ec 	bl	220f8 <hal_ssp_rx_fifo_is_empty>
   21d20:	2800      	cmp	r0, #0
   21d22:	d0f7      	beq.n	21d14 <spi_recv_data+0x9c>
    uint16 cmd_bytes  = cmd_len  / bytes;
   21d24:	466b      	mov	r3, sp
   21d26:	8a1e      	ldrh	r6, [r3, #16]
    uint16 ignore_first_rx_bytes = 0;
   21d28:	9b05      	ldr	r3, [sp, #20]
   21d2a:	1e5a      	subs	r2, r3, #1
   21d2c:	4193      	sbcs	r3, r2
   21d2e:	425b      	negs	r3, r3
   21d30:	4033      	ands	r3, r6
   21d32:	9304      	str	r3, [sp, #16]
    non_os_enter_critical();
   21d34:	f7f6 fa3e 	bl	181b4 <non_os_enter_critical>
        if (!ssp_sleep_vetoed[bus])
   21d38:	4b5d      	ldr	r3, [pc, #372]	; (21eb0 <spi_recv_data+0x238>)
   21d3a:	5d1a      	ldrb	r2, [r3, r4]
   21d3c:	2a00      	cmp	r2, #0
   21d3e:	d103      	bne.n	21d48 <spi_recv_data+0xd0>
            ssp_sleep_vetoed[bus] = true;
   21d40:	3201      	adds	r2, #1
   21d42:	551a      	strb	r2, [r3, r4]
            osAddStopClocksVeto();
   21d44:	f7f2 ff5e 	bl	14c04 <osAddStopClocksVeto>
    uint8 *tx_finish     = cmd_buff + cmd_len;
   21d48:	9b03      	ldr	r3, [sp, #12]
   21d4a:	18eb      	adds	r3, r5, r3
   21d4c:	9305      	str	r3, [sp, #20]
    uint16 read_bytes = data_len / bytes;
   21d4e:	466b      	mov	r3, sp
   21d50:	8b1b      	ldrh	r3, [r3, #24]
    uint16 write_bytes = cmd_bytes + read_bytes;
   21d52:	199e      	adds	r6, r3, r6
    uint16 read_bytes = data_len / bytes;
   21d54:	9306      	str	r3, [sp, #24]
    uint16 write_bytes = cmd_bytes + read_bytes;
   21d56:	b2b3      	uxth	r3, r6
   21d58:	9303      	str	r3, [sp, #12]
    non_os_exit_critical();
   21d5a:	f7f6 fa3f 	bl	181dc <non_os_exit_critical>
    hal_ssp_disable(ssp_bus);
   21d5e:	0020      	movs	r0, r4
   21d60:	f000 f99e 	bl	220a0 <hal_ssp_disable>
    while (!hal_ssp_tx_fifo_is_full(ssp_bus) && (write_bytes > 0))
   21d64:	0020      	movs	r0, r4
   21d66:	f000 f9bd 	bl	220e4 <hal_ssp_tx_fifo_is_full>
   21d6a:	2800      	cmp	r0, #0
   21d6c:	d102      	bne.n	21d74 <spi_recv_data+0xfc>
   21d6e:	9b03      	ldr	r3, [sp, #12]
   21d70:	2b00      	cmp	r3, #0
   21d72:	d132      	bne.n	21dda <spi_recv_data+0x162>
    non_os_enter_critical();
   21d74:	f7f6 fa1e 	bl	181b4 <non_os_enter_critical>
    volatile ssp_ctrl_t *base = hal_ssp_get_base(ssp_bus);
   21d78:	0020      	movs	r0, r4
   21d7a:	f000 fa6d 	bl	22258 <hal_ssp_get_base>
   21d7e:	0007      	movs	r7, r0
    hal_ssp_enable(ssp_bus);
   21d80:	0020      	movs	r0, r4
   21d82:	f000 f97b 	bl	2207c <hal_ssp_enable>
    uint16 rx_index      = 0;
   21d86:	2600      	movs	r6, #0
    while ((rx_index < read_bytes) || (write_bytes > 0))
   21d88:	9b06      	ldr	r3, [sp, #24]
   21d8a:	429e      	cmp	r6, r3
   21d8c:	d344      	bcc.n	21e18 <spi_recv_data+0x1a0>
   21d8e:	9b03      	ldr	r3, [sp, #12]
   21d90:	2b00      	cmp	r3, #0
   21d92:	d141      	bne.n	21e18 <spi_recv_data+0x1a0>
    non_os_exit_critical();
   21d94:	f7f6 fa22 	bl	181dc <non_os_exit_critical>
    assert(hal_ssp_tx_fifo_is_empty(ssp_bus));
   21d98:	0020      	movs	r0, r4
   21d9a:	f000 f9b7 	bl	2210c <hal_ssp_tx_fifo_is_empty>
   21d9e:	2800      	cmp	r0, #0
   21da0:	d103      	bne.n	21daa <spi_recv_data+0x132>
   21da2:	9907      	ldr	r1, [sp, #28]
   21da4:	3016      	adds	r0, #22
   21da6:	f7df feb3 	bl	1b10 <panic>
    assert(hal_ssp_rx_fifo_is_empty(ssp_bus));
   21daa:	0020      	movs	r0, r4
   21dac:	f000 f9a4 	bl	220f8 <hal_ssp_rx_fifo_is_empty>
   21db0:	2800      	cmp	r0, #0
   21db2:	d103      	bne.n	21dbc <spi_recv_data+0x144>
   21db4:	9907      	ldr	r1, [sp, #28]
   21db6:	3016      	adds	r0, #22
   21db8:	f7df feaa 	bl	1b10 <panic>
    ssp_remove_any_sleep_veto(ssp_bus);
   21dbc:	0020      	movs	r0, r4
   21dbe:	f7ff fcb9 	bl	21734 <ssp_remove_any_sleep_veto>
    ssp_helper_give_semaphore(ssp_bus, ssp_mutex[ssp_bus]);
   21dc2:	4b3a      	ldr	r3, [pc, #232]	; (21eac <spi_recv_data+0x234>)
   21dc4:	00a2      	lsls	r2, r4, #2
   21dc6:	58d1      	ldr	r1, [r2, r3]
   21dc8:	0020      	movs	r0, r4
   21dca:	f7ff fcfe 	bl	217ca <ssp_helper_give_semaphore>
    if (callback != NULL)
   21dce:	9b0f      	ldr	r3, [sp, #60]	; 0x3c
   21dd0:	2b00      	cmp	r3, #0
   21dd2:	d09c      	beq.n	21d0e <spi_recv_data+0x96>
        (*callback)(SPI_RET_OK);
   21dd4:	2000      	movs	r0, #0
   21dd6:	4798      	blx	r3
   21dd8:	e799      	b.n	21d0e <spi_recv_data+0x96>
        if ((cmd_buff != NULL) && (cmd_buff < tx_finish))
   21dda:	2d00      	cmp	r5, #0
   21ddc:	d017      	beq.n	21e0e <spi_recv_data+0x196>
   21dde:	9b05      	ldr	r3, [sp, #20]
   21de0:	429d      	cmp	r5, r3
   21de2:	d214      	bcs.n	21e0e <spi_recv_data+0x196>
    if (bytes == 1)
   21de4:	9a02      	ldr	r2, [sp, #8]
   21de6:	782b      	ldrb	r3, [r5, #0]
   21de8:	2a01      	cmp	r2, #1
   21dea:	d10b      	bne.n	21e04 <spi_recv_data+0x18c>
        return (uint16)(*src);
   21dec:	b219      	sxth	r1, r3
            hal_ssp_write_data(ssp_bus, (uint16)ssp_pack_into_fifo_data(bytes, cmd_buff));
   21dee:	b289      	uxth	r1, r1
   21df0:	0020      	movs	r0, r4
   21df2:	f000 f967 	bl	220c4 <hal_ssp_write_data>
            cmd_buff += bytes;
   21df6:	9b02      	ldr	r3, [sp, #8]
   21df8:	18ed      	adds	r5, r5, r3
        write_bytes--;
   21dfa:	9e03      	ldr	r6, [sp, #12]
   21dfc:	3e01      	subs	r6, #1
   21dfe:	b2b3      	uxth	r3, r6
   21e00:	9303      	str	r3, [sp, #12]
   21e02:	e7af      	b.n	21d64 <spi_recv_data+0xec>
        return (int16)((uint16)(*src) + (((uint16)(*(src + 1))) << 8));
   21e04:	7869      	ldrb	r1, [r5, #1]
   21e06:	0209      	lsls	r1, r1, #8
   21e08:	18c9      	adds	r1, r1, r3
   21e0a:	b209      	sxth	r1, r1
   21e0c:	e7ef      	b.n	21dee <spi_recv_data+0x176>
            hal_ssp_write_data(ssp_bus, 0);
   21e0e:	2100      	movs	r1, #0
   21e10:	0020      	movs	r0, r4
   21e12:	f000 f957 	bl	220c4 <hal_ssp_write_data>
   21e16:	e7f0      	b.n	21dfa <spi_recv_data+0x182>
        if (!HAL_SSP_IS_TX_FIFO_FULL(base) && write_bytes > 0)
   21e18:	2202      	movs	r2, #2
   21e1a:	68fb      	ldr	r3, [r7, #12]
   21e1c:	4213      	tst	r3, r2
   21e1e:	d014      	beq.n	21e4a <spi_recv_data+0x1d2>
   21e20:	9b03      	ldr	r3, [sp, #12]
   21e22:	2b00      	cmp	r3, #0
   21e24:	d011      	beq.n	21e4a <spi_recv_data+0x1d2>
            if ((cmd_buff != NULL) && (cmd_buff < tx_finish))
   21e26:	2d00      	cmp	r5, #0
   21e28:	d021      	beq.n	21e6e <spi_recv_data+0x1f6>
   21e2a:	9b05      	ldr	r3, [sp, #20]
   21e2c:	429d      	cmp	r5, r3
   21e2e:	d21e      	bcs.n	21e6e <spi_recv_data+0x1f6>
    if (bytes == 1)
   21e30:	9b02      	ldr	r3, [sp, #8]
   21e32:	782a      	ldrb	r2, [r5, #0]
   21e34:	2b01      	cmp	r3, #1
   21e36:	d115      	bne.n	21e64 <spi_recv_data+0x1ec>
        return (uint16)(*src);
   21e38:	b213      	sxth	r3, r2
                HAL_SSP_WRITE_DATA(base, (uint16)ssp_pack_into_fifo_data(bytes, cmd_buff));
   21e3a:	b29b      	uxth	r3, r3
   21e3c:	813b      	strh	r3, [r7, #8]
                cmd_buff += bytes;
   21e3e:	9b02      	ldr	r3, [sp, #8]
   21e40:	18ed      	adds	r5, r5, r3
            write_bytes--;
   21e42:	9b03      	ldr	r3, [sp, #12]
   21e44:	3b01      	subs	r3, #1
   21e46:	b29b      	uxth	r3, r3
   21e48:	9303      	str	r3, [sp, #12]
        if (!hal_ssp_rx_fifo_is_empty(ssp_bus))
   21e4a:	0020      	movs	r0, r4
   21e4c:	f000 f954 	bl	220f8 <hal_ssp_rx_fifo_is_empty>
   21e50:	2800      	cmp	r0, #0
   21e52:	d199      	bne.n	21d88 <spi_recv_data+0x110>
            if (ignore_first_rx_bytes > 0)
   21e54:	9b04      	ldr	r3, [sp, #16]
   21e56:	2b00      	cmp	r3, #0
   21e58:	d00c      	beq.n	21e74 <spi_recv_data+0x1fc>
                ignore_first_rx_bytes--;
   21e5a:	3b01      	subs	r3, #1
   21e5c:	b29b      	uxth	r3, r3
   21e5e:	9304      	str	r3, [sp, #16]
                (void)HAL_SSP_READ_DATA(base);
   21e60:	893b      	ldrh	r3, [r7, #8]
   21e62:	e791      	b.n	21d88 <spi_recv_data+0x110>
        return (int16)((uint16)(*src) + (((uint16)(*(src + 1))) << 8));
   21e64:	786b      	ldrb	r3, [r5, #1]
   21e66:	021b      	lsls	r3, r3, #8
   21e68:	189b      	adds	r3, r3, r2
   21e6a:	b21b      	sxth	r3, r3
   21e6c:	e7e5      	b.n	21e3a <spi_recv_data+0x1c2>
                HAL_SSP_WRITE_DATA(base, 0);
   21e6e:	2300      	movs	r3, #0
   21e70:	813b      	strh	r3, [r7, #8]
   21e72:	e7e6      	b.n	21e42 <spi_recv_data+0x1ca>
                if (bytes == 1)
   21e74:	9b02      	ldr	r3, [sp, #8]
   21e76:	2b01      	cmp	r3, #1
   21e78:	d10b      	bne.n	21e92 <spi_recv_data+0x21a>
                    if (data_buff != NULL)
   21e7a:	9b01      	ldr	r3, [sp, #4]
   21e7c:	2b00      	cmp	r3, #0
   21e7e:	d005      	beq.n	21e8c <spi_recv_data+0x214>
                        *data_buff++ = (uint8)HAL_SSP_READ_DATA(base);
   21e80:	893b      	ldrh	r3, [r7, #8]
   21e82:	9a01      	ldr	r2, [sp, #4]
   21e84:	7013      	strb	r3, [r2, #0]
   21e86:	0013      	movs	r3, r2
   21e88:	3301      	adds	r3, #1
   21e8a:	9301      	str	r3, [sp, #4]
                    rx_index++;
   21e8c:	3601      	adds	r6, #1
                    rx_index += 2;
   21e8e:	b2b6      	uxth	r6, r6
   21e90:	e77a      	b.n	21d88 <spi_recv_data+0x110>
                    if (data_buff != NULL)
   21e92:	9b01      	ldr	r3, [sp, #4]
   21e94:	2b00      	cmp	r3, #0
   21e96:	d005      	beq.n	21ea4 <spi_recv_data+0x22c>
                        local_buff = HAL_SSP_READ_DATA(base);
   21e98:	893b      	ldrh	r3, [r7, #8]
                        *(uint16*)data_buff = local_buff;   //lint !e826
   21e9a:	9a01      	ldr	r2, [sp, #4]
   21e9c:	8013      	strh	r3, [r2, #0]
                        data_buff += 2;
   21e9e:	0013      	movs	r3, r2
   21ea0:	3302      	adds	r3, #2
   21ea2:	9301      	str	r3, [sp, #4]
                    rx_index += 2;
   21ea4:	3602      	adds	r6, #2
   21ea6:	e7f2      	b.n	21e8e <spi_recv_data+0x216>
   21ea8:	000260fa 	.word	0x000260fa
   21eac:	01002d6c 	.word	0x01002d6c
   21eb0:	01002d74 	.word	0x01002d74

00021eb4 <hal_ssp_claim>:
    return hal_ssp_bases[bus]->SSPSR;
}

static bool hal_ssp_is_clock_enabled(SSP_BUS bus)
{
    if ((CLKEN_REG & (hal_ssp_clken_masks[bus])) == hal_ssp_clken_masks[bus])
   21eb4:	2301      	movs	r3, #1
{
   21eb6:	b510      	push	{r4, lr}
    if ((CLKEN_REG & (hal_ssp_clken_masks[bus])) == hal_ssp_clken_masks[bus])
   21eb8:	4a0e      	ldr	r2, [pc, #56]	; (21ef4 <hal_ssp_claim+0x40>)
   21eba:	6810      	ldr	r0, [r2, #0]
   21ebc:	4018      	ands	r0, r3
   21ebe:	d006      	beq.n	21ece <hal_ssp_claim+0x1a>
   21ec0:	6811      	ldr	r1, [r2, #0]
   21ec2:	2202      	movs	r2, #2
    return SSP_BUS_NONE;
   21ec4:	0010      	movs	r0, r2
    if ((CLKEN_REG & (hal_ssp_clken_masks[bus])) == hal_ssp_clken_masks[bus])
   21ec6:	4211      	tst	r1, r2
   21ec8:	d113      	bne.n	21ef2 <hal_ssp_claim+0x3e>
    for (SSP_BUS i =SSP_BUS0; i < SSP_BUS_MAX_NUM; i++)
   21eca:	0018      	movs	r0, r3
    if ((CLKEN_REG & (hal_ssp_clken_masks[bus])) == hal_ssp_clken_masks[bus])
   21ecc:	0013      	movs	r3, r2
    return false;
}

static void hal_ssp_enable_clock(SSP_BUS bus)
{
    CLKEN_REG_BITSET = hal_ssp_clken_masks[bus];
   21ece:	4a0a      	ldr	r2, [pc, #40]	; (21ef8 <hal_ssp_claim+0x44>)
        ssp_interrupt_handler[bus][i] = NULL;
   21ed0:	0104      	lsls	r4, r0, #4
    CLKEN_REG_BITSET = hal_ssp_clken_masks[bus];
   21ed2:	6013      	str	r3, [r2, #0]
        ssp_interrupt_handler[bus][i] = NULL;
   21ed4:	2200      	movs	r2, #0
   21ed6:	4b09      	ldr	r3, [pc, #36]	; (21efc <hal_ssp_claim+0x48>)
   21ed8:	50e2      	str	r2, [r4, r3]
   21eda:	191b      	adds	r3, r3, r4
   21edc:	605a      	str	r2, [r3, #4]
   21ede:	609a      	str	r2, [r3, #8]
   21ee0:	60da      	str	r2, [r3, #12]
            NVIC_EnableIRQ(hal_ssp_interrupt_lines[i]);
   21ee2:	4b07      	ldr	r3, [pc, #28]	; (21f00 <hal_ssp_claim+0x4c>)
  NVIC->ISER[0] = (uint32_t)(1UL << (((uint32_t)(int32_t)IRQn) & 0x1FUL));
   21ee4:	5c1a      	ldrb	r2, [r3, r0]
   21ee6:	231f      	movs	r3, #31
   21ee8:	401a      	ands	r2, r3
   21eea:	3b1e      	subs	r3, #30
   21eec:	4093      	lsls	r3, r2
   21eee:	4a05      	ldr	r2, [pc, #20]	; (21f04 <hal_ssp_claim+0x50>)
   21ef0:	6013      	str	r3, [r2, #0]
}
   21ef2:	bd10      	pop	{r4, pc}
   21ef4:	40004048 	.word	0x40004048
   21ef8:	40004448 	.word	0x40004448
   21efc:	01002d78 	.word	0x01002d78
   21f00:	00026106 	.word	0x00026106
   21f04:	e000e100 	.word	0xe000e100

00021f08 <hal_ssp_release>:
    if ((CLKEN_REG & (hal_ssp_clken_masks[bus])) == hal_ssp_clken_masks[bus])
   21f08:	4b08      	ldr	r3, [pc, #32]	; (21f2c <hal_ssp_release+0x24>)
   21f0a:	681a      	ldr	r2, [r3, #0]
   21f0c:	4b08      	ldr	r3, [pc, #32]	; (21f30 <hal_ssp_release+0x28>)
   21f0e:	5c1b      	ldrb	r3, [r3, r0]
   21f10:	401a      	ands	r2, r3
   21f12:	4293      	cmp	r3, r2
   21f14:	d109      	bne.n	21f2a <hal_ssp_release+0x22>
        NVIC_DisableIRQ(hal_ssp_interrupt_lines[bus]);
   21f16:	4a07      	ldr	r2, [pc, #28]	; (21f34 <hal_ssp_release+0x2c>)
  NVIC->ICER[0] = (uint32_t)(1UL << (((uint32_t)(int32_t)IRQn) & 0x1FUL));
   21f18:	5c11      	ldrb	r1, [r2, r0]
   21f1a:	221f      	movs	r2, #31
   21f1c:	4011      	ands	r1, r2
   21f1e:	3a1e      	subs	r2, #30
   21f20:	408a      	lsls	r2, r1
   21f22:	4905      	ldr	r1, [pc, #20]	; (21f38 <hal_ssp_release+0x30>)
   21f24:	67ca      	str	r2, [r1, #124]	; 0x7c
}

static void hal_ssp_disable_clock(SSP_BUS bus)
{
    CLKEN_REG_BITCLR = hal_ssp_clken_masks[bus];
   21f26:	4a05      	ldr	r2, [pc, #20]	; (21f3c <hal_ssp_release+0x34>)
   21f28:	6013      	str	r3, [r2, #0]
}
   21f2a:	4770      	bx	lr
   21f2c:	40004048 	.word	0x40004048
   21f30:	00026104 	.word	0x00026104
   21f34:	00026106 	.word	0x00026106
   21f38:	e000e104 	.word	0xe000e104
   21f3c:	40004848 	.word	0x40004848

00021f40 <hal_ssp_set_data_size>:
{
   21f40:	b570      	push	{r4, r5, r6, lr}
   21f42:	0005      	movs	r5, r0
   21f44:	000c      	movs	r4, r1
    assert(bus < SSP_BUS_MAX_NUM);
   21f46:	2801      	cmp	r0, #1
   21f48:	d903      	bls.n	21f52 <hal_ssp_set_data_size+0x12>
   21f4a:	4671      	mov	r1, lr
   21f4c:	2016      	movs	r0, #22
   21f4e:	f7df fddf 	bl	1b10 <panic>
    if ((data_size < SSP_MIN_DATA_SIZE) || (data_size > SSP_MAX_DATA_SIZE))
   21f52:	1f23      	subs	r3, r4, #4
        return false;
   21f54:	2000      	movs	r0, #0
    if ((data_size < SSP_MIN_DATA_SIZE) || (data_size > SSP_MAX_DATA_SIZE))
   21f56:	2b0c      	cmp	r3, #12
   21f58:	d80c      	bhi.n	21f74 <hal_ssp_set_data_size+0x34>
    hal_ssp_bases[bus]->SSPCR0 &= ~(SSP_DATA_SIZE_MASK << SSP_DATA_SIZE_SHIFT);
   21f5a:	210f      	movs	r1, #15
   21f5c:	4b06      	ldr	r3, [pc, #24]	; (21f78 <hal_ssp_set_data_size+0x38>)
   21f5e:	00ad      	lsls	r5, r5, #2
   21f60:	58eb      	ldr	r3, [r5, r3]
    hal_ssp_bases[bus]->SSPCR0 |= (uint8)(data_size - 1) << SSP_DATA_SIZE_SHIFT;
   21f62:	3c01      	subs	r4, #1
    hal_ssp_bases[bus]->SSPCR0 &= ~(SSP_DATA_SIZE_MASK << SSP_DATA_SIZE_SHIFT);
   21f64:	681a      	ldr	r2, [r3, #0]
    hal_ssp_bases[bus]->SSPCR0 |= (uint8)(data_size - 1) << SSP_DATA_SIZE_SHIFT;
   21f66:	b2e4      	uxtb	r4, r4
    hal_ssp_bases[bus]->SSPCR0 &= ~(SSP_DATA_SIZE_MASK << SSP_DATA_SIZE_SHIFT);
   21f68:	438a      	bics	r2, r1
   21f6a:	601a      	str	r2, [r3, #0]
    hal_ssp_bases[bus]->SSPCR0 |= (uint8)(data_size - 1) << SSP_DATA_SIZE_SHIFT;
   21f6c:	681a      	ldr	r2, [r3, #0]
    return true;
   21f6e:	3001      	adds	r0, #1
    hal_ssp_bases[bus]->SSPCR0 |= (uint8)(data_size - 1) << SSP_DATA_SIZE_SHIFT;
   21f70:	4314      	orrs	r4, r2
   21f72:	601c      	str	r4, [r3, #0]
}
   21f74:	bd70      	pop	{r4, r5, r6, pc}
   21f76:	46c0      	nop			; (mov r8, r8)
   21f78:	000260fc 	.word	0x000260fc

00021f7c <hal_ssp_get_data_size>:
{
   21f7c:	b510      	push	{r4, lr}
   21f7e:	0004      	movs	r4, r0
    assert(bus < SSP_BUS_MAX_NUM);
   21f80:	2801      	cmp	r0, #1
   21f82:	d903      	bls.n	21f8c <hal_ssp_get_data_size+0x10>
   21f84:	4671      	mov	r1, lr
   21f86:	2016      	movs	r0, #22
   21f88:	f7df fdc2 	bl	1b10 <panic>
    return (uint8)(((hal_ssp_bases[bus]->SSPCR0 >> SSP_DATA_SIZE_SHIFT) & SSP_DATA_SIZE_MASK) + 1);
   21f8c:	4b03      	ldr	r3, [pc, #12]	; (21f9c <hal_ssp_get_data_size+0x20>)
   21f8e:	00a4      	lsls	r4, r4, #2
   21f90:	58e3      	ldr	r3, [r4, r3]
   21f92:	6818      	ldr	r0, [r3, #0]
   21f94:	230f      	movs	r3, #15
   21f96:	4018      	ands	r0, r3
   21f98:	3001      	adds	r0, #1
}
   21f9a:	bd10      	pop	{r4, pc}
   21f9c:	000260fc 	.word	0x000260fc

00021fa0 <hal_ssp_set_frame_format>:
{
   21fa0:	b570      	push	{r4, r5, r6, lr}
   21fa2:	0005      	movs	r5, r0
   21fa4:	000c      	movs	r4, r1
    assert(bus < SSP_BUS_MAX_NUM);
   21fa6:	2801      	cmp	r0, #1
   21fa8:	d903      	bls.n	21fb2 <hal_ssp_set_frame_format+0x12>
   21faa:	4671      	mov	r1, lr
   21fac:	2016      	movs	r0, #22
   21fae:	f7df fdaf 	bl	1b10 <panic>
        return false;
   21fb2:	2000      	movs	r0, #0
    if (frame_format >= SSP_MAX_FRF)
   21fb4:	2c02      	cmp	r4, #2
   21fb6:	d80b      	bhi.n	21fd0 <hal_ssp_set_frame_format+0x30>
    hal_ssp_bases[bus]->SSPCR0 &= ~(SSP_FRF_MASK << SSP_FRF_SHIFT);
   21fb8:	2130      	movs	r1, #48	; 0x30
   21fba:	4b06      	ldr	r3, [pc, #24]	; (21fd4 <hal_ssp_set_frame_format+0x34>)
   21fbc:	00ad      	lsls	r5, r5, #2
   21fbe:	58eb      	ldr	r3, [r5, r3]
    hal_ssp_bases[bus]->SSPCR0 |= (uint32)frame_format << SSP_FRF_SHIFT;
   21fc0:	0124      	lsls	r4, r4, #4
    hal_ssp_bases[bus]->SSPCR0 &= ~(SSP_FRF_MASK << SSP_FRF_SHIFT);
   21fc2:	681a      	ldr	r2, [r3, #0]
    return true;
   21fc4:	3001      	adds	r0, #1
    hal_ssp_bases[bus]->SSPCR0 &= ~(SSP_FRF_MASK << SSP_FRF_SHIFT);
   21fc6:	438a      	bics	r2, r1
   21fc8:	601a      	str	r2, [r3, #0]
    hal_ssp_bases[bus]->SSPCR0 |= (uint32)frame_format << SSP_FRF_SHIFT;
   21fca:	681a      	ldr	r2, [r3, #0]
   21fcc:	4314      	orrs	r4, r2
   21fce:	601c      	str	r4, [r3, #0]
}
   21fd0:	bd70      	pop	{r4, r5, r6, pc}
   21fd2:	46c0      	nop			; (mov r8, r8)
   21fd4:	000260fc 	.word	0x000260fc

00021fd8 <hal_ssp_set_spi_mode>:
{
   21fd8:	b570      	push	{r4, r5, r6, lr}
   21fda:	0005      	movs	r5, r0
   21fdc:	000c      	movs	r4, r1
    assert(bus < SSP_BUS_MAX_NUM);
   21fde:	2801      	cmp	r0, #1
   21fe0:	d903      	bls.n	21fea <hal_ssp_set_spi_mode+0x12>
   21fe2:	4671      	mov	r1, lr
   21fe4:	2016      	movs	r0, #22
   21fe6:	f7df fd93 	bl	1b10 <panic>
        return false;
   21fea:	2000      	movs	r0, #0
    if (ssp_spi_clk_mode >= SSP_SPI_CLK_MAX)
   21fec:	2c03      	cmp	r4, #3
   21fee:	d80b      	bhi.n	22008 <hal_ssp_set_spi_mode+0x30>
    hal_ssp_bases[bus]->SSPCR0 &= ~(SSP_SPI_CLK_MODE_MASK << SSP_SPI_CLK_MODE_SHIFT);
   21ff0:	21c0      	movs	r1, #192	; 0xc0
   21ff2:	4b06      	ldr	r3, [pc, #24]	; (2200c <hal_ssp_set_spi_mode+0x34>)
   21ff4:	00ad      	lsls	r5, r5, #2
   21ff6:	58eb      	ldr	r3, [r5, r3]
    hal_ssp_bases[bus]->SSPCR0 |= (uint32)ssp_spi_clk_mode << SSP_SPI_CLK_MODE_SHIFT;
   21ff8:	01a4      	lsls	r4, r4, #6
    hal_ssp_bases[bus]->SSPCR0 &= ~(SSP_SPI_CLK_MODE_MASK << SSP_SPI_CLK_MODE_SHIFT);
   21ffa:	681a      	ldr	r2, [r3, #0]
    return true;
   21ffc:	3001      	adds	r0, #1
    hal_ssp_bases[bus]->SSPCR0 &= ~(SSP_SPI_CLK_MODE_MASK << SSP_SPI_CLK_MODE_SHIFT);
   21ffe:	438a      	bics	r2, r1
   22000:	601a      	str	r2, [r3, #0]
    hal_ssp_bases[bus]->SSPCR0 |= (uint32)ssp_spi_clk_mode << SSP_SPI_CLK_MODE_SHIFT;
   22002:	681a      	ldr	r2, [r3, #0]
   22004:	4314      	orrs	r4, r2
   22006:	601c      	str	r4, [r3, #0]
}
   22008:	bd70      	pop	{r4, r5, r6, pc}
   2200a:	46c0      	nop			; (mov r8, r8)
   2200c:	000260fc 	.word	0x000260fc

00022010 <hal_ssp_set_serial_clock_rate>:
{
   22010:	b570      	push	{r4, r5, r6, lr}
   22012:	0005      	movs	r5, r0
   22014:	000c      	movs	r4, r1
    assert(bus < SSP_BUS_MAX_NUM);
   22016:	2801      	cmp	r0, #1
   22018:	d903      	bls.n	22022 <hal_ssp_set_serial_clock_rate+0x12>
   2201a:	4671      	mov	r1, lr
   2201c:	2016      	movs	r0, #22
   2201e:	f7df fd77 	bl	1b10 <panic>
    hal_ssp_bases[bus]->SSPCR0 &= ~(SSP_SCR_MASK << SSP_SCR_SHIFT);
   22022:	4b06      	ldr	r3, [pc, #24]	; (2203c <hal_ssp_set_serial_clock_rate+0x2c>)
   22024:	00ad      	lsls	r5, r5, #2
   22026:	58eb      	ldr	r3, [r5, r3]
   22028:	4905      	ldr	r1, [pc, #20]	; (22040 <hal_ssp_set_serial_clock_rate+0x30>)
   2202a:	681a      	ldr	r2, [r3, #0]
    hal_ssp_bases[bus]->SSPCR0 |= (((uint32)scr) & SSP_SCR_MASK) << SSP_SCR_SHIFT;
   2202c:	0224      	lsls	r4, r4, #8
    hal_ssp_bases[bus]->SSPCR0 &= ~(SSP_SCR_MASK << SSP_SCR_SHIFT);
   2202e:	400a      	ands	r2, r1
   22030:	601a      	str	r2, [r3, #0]
    hal_ssp_bases[bus]->SSPCR0 |= (((uint32)scr) & SSP_SCR_MASK) << SSP_SCR_SHIFT;
   22032:	681a      	ldr	r2, [r3, #0]
}
   22034:	2001      	movs	r0, #1
    hal_ssp_bases[bus]->SSPCR0 |= (((uint32)scr) & SSP_SCR_MASK) << SSP_SCR_SHIFT;
   22036:	4314      	orrs	r4, r2
   22038:	601c      	str	r4, [r3, #0]
}
   2203a:	bd70      	pop	{r4, r5, r6, pc}
   2203c:	000260fc 	.word	0x000260fc
   22040:	ffff00ff 	.word	0xffff00ff

00022044 <hal_ssp_set_clock_prescale>:
{
   22044:	b570      	push	{r4, r5, r6, lr}
   22046:	0005      	movs	r5, r0
   22048:	000c      	movs	r4, r1
    assert(bus < SSP_BUS_MAX_NUM);
   2204a:	2801      	cmp	r0, #1
   2204c:	d903      	bls.n	22056 <hal_ssp_set_clock_prescale+0x12>
   2204e:	4671      	mov	r1, lr
   22050:	2016      	movs	r0, #22
   22052:	f7df fd5d 	bl	1b10 <panic>
    if ((cpsr < SSP_MIN_CPSR) || (cpsr > SSP_MAX_CPSR))
   22056:	1ea3      	subs	r3, r4, #2
   22058:	b2db      	uxtb	r3, r3
        return false;
   2205a:	2000      	movs	r0, #0
    if ((cpsr < SSP_MIN_CPSR) || (cpsr > SSP_MAX_CPSR))
   2205c:	2bfc      	cmp	r3, #252	; 0xfc
   2205e:	d80a      	bhi.n	22076 <hal_ssp_set_clock_prescale+0x32>
    hal_ssp_bases[bus]->SSPCPSR &= ~(SSP_CPSR_MASK);
   22060:	21ff      	movs	r1, #255	; 0xff
   22062:	4b05      	ldr	r3, [pc, #20]	; (22078 <hal_ssp_set_clock_prescale+0x34>)
   22064:	00ad      	lsls	r5, r5, #2
   22066:	58eb      	ldr	r3, [r5, r3]
    return true;
   22068:	3001      	adds	r0, #1
    hal_ssp_bases[bus]->SSPCPSR &= ~(SSP_CPSR_MASK);
   2206a:	691a      	ldr	r2, [r3, #16]
   2206c:	438a      	bics	r2, r1
   2206e:	611a      	str	r2, [r3, #16]
    hal_ssp_bases[bus]->SSPCPSR |= (uint32)cpsr;
   22070:	691a      	ldr	r2, [r3, #16]
   22072:	4314      	orrs	r4, r2
   22074:	611c      	str	r4, [r3, #16]
}
   22076:	bd70      	pop	{r4, r5, r6, pc}
   22078:	000260fc 	.word	0x000260fc

0002207c <hal_ssp_enable>:
{
   2207c:	b510      	push	{r4, lr}
   2207e:	0004      	movs	r4, r0
    assert(bus < SSP_BUS_MAX_NUM);
   22080:	2801      	cmp	r0, #1
   22082:	d903      	bls.n	2208c <hal_ssp_enable+0x10>
   22084:	4671      	mov	r1, lr
   22086:	2016      	movs	r0, #22
   22088:	f7df fd42 	bl	1b10 <panic>
    hal_ssp_bases[bus]->SSPCR1 |= (SSP_SSE_MASK) << SSP_SSE_SHIFT;
   2208c:	4b03      	ldr	r3, [pc, #12]	; (2209c <hal_ssp_enable+0x20>)
   2208e:	00a4      	lsls	r4, r4, #2
   22090:	58e2      	ldr	r2, [r4, r3]
   22092:	2302      	movs	r3, #2
   22094:	6851      	ldr	r1, [r2, #4]
   22096:	430b      	orrs	r3, r1
   22098:	6053      	str	r3, [r2, #4]
}
   2209a:	bd10      	pop	{r4, pc}
   2209c:	000260fc 	.word	0x000260fc

000220a0 <hal_ssp_disable>:
{
   220a0:	b510      	push	{r4, lr}
   220a2:	0004      	movs	r4, r0
    assert(bus < SSP_BUS_MAX_NUM);
   220a4:	2801      	cmp	r0, #1
   220a6:	d903      	bls.n	220b0 <hal_ssp_disable+0x10>
   220a8:	4671      	mov	r1, lr
   220aa:	2016      	movs	r0, #22
   220ac:	f7df fd30 	bl	1b10 <panic>
    hal_ssp_bases[bus]->SSPCR1 &= ~(SSP_SSE_MASK << SSP_SSE_SHIFT);
   220b0:	2102      	movs	r1, #2
   220b2:	4b03      	ldr	r3, [pc, #12]	; (220c0 <hal_ssp_disable+0x20>)
   220b4:	00a4      	lsls	r4, r4, #2
   220b6:	58e2      	ldr	r2, [r4, r3]
   220b8:	6853      	ldr	r3, [r2, #4]
   220ba:	438b      	bics	r3, r1
   220bc:	6053      	str	r3, [r2, #4]
}
   220be:	bd10      	pop	{r4, pc}
   220c0:	000260fc 	.word	0x000260fc

000220c4 <hal_ssp_write_data>:
    hal_ssp_bases[bus]->SSPDR = data;
   220c4:	4b02      	ldr	r3, [pc, #8]	; (220d0 <hal_ssp_write_data+0xc>)
   220c6:	0080      	lsls	r0, r0, #2
   220c8:	58c3      	ldr	r3, [r0, r3]
   220ca:	8119      	strh	r1, [r3, #8]
}
   220cc:	4770      	bx	lr
   220ce:	46c0      	nop			; (mov r8, r8)
   220d0:	000260fc 	.word	0x000260fc

000220d4 <hal_ssp_read_data>:
    return (hal_ssp_bases[bus]->SSPDR);
   220d4:	4b02      	ldr	r3, [pc, #8]	; (220e0 <hal_ssp_read_data+0xc>)
   220d6:	0080      	lsls	r0, r0, #2
   220d8:	58c3      	ldr	r3, [r0, r3]
   220da:	8918      	ldrh	r0, [r3, #8]
   220dc:	b280      	uxth	r0, r0
}
   220de:	4770      	bx	lr
   220e0:	000260fc 	.word	0x000260fc

000220e4 <hal_ssp_tx_fifo_is_full>:
    return hal_ssp_bases[bus]->SSPSR;
   220e4:	4b03      	ldr	r3, [pc, #12]	; (220f4 <hal_ssp_tx_fifo_is_full+0x10>)
   220e6:	0080      	lsls	r0, r0, #2
   220e8:	58c3      	ldr	r3, [r0, r3]
   220ea:	2001      	movs	r0, #1
   220ec:	68db      	ldr	r3, [r3, #12]
    if (((hal_ssp_get_status_register(bus) >> SSP_TXFIFO_FULL_SHIFT) & SSP_TXFIFO_FULL_MASK) == 0x00)
   220ee:	085b      	lsrs	r3, r3, #1
   220f0:	4398      	bics	r0, r3
}
   220f2:	4770      	bx	lr
   220f4:	000260fc 	.word	0x000260fc

000220f8 <hal_ssp_rx_fifo_is_empty>:
    return hal_ssp_bases[bus]->SSPSR;
   220f8:	4b03      	ldr	r3, [pc, #12]	; (22108 <hal_ssp_rx_fifo_is_empty+0x10>)
   220fa:	0080      	lsls	r0, r0, #2
   220fc:	58c3      	ldr	r3, [r0, r3]
   220fe:	2001      	movs	r0, #1
   22100:	68db      	ldr	r3, [r3, #12]
    if (((hal_ssp_get_status_register(bus) >> SSP_RXFIFO_EMPTY_SHIFT) & SSP_RXFIFO_EMPTY_MASK) == 0x00)
   22102:	089b      	lsrs	r3, r3, #2
   22104:	4398      	bics	r0, r3
}
   22106:	4770      	bx	lr
   22108:	000260fc 	.word	0x000260fc

0002210c <hal_ssp_tx_fifo_is_empty>:
    return hal_ssp_bases[bus]->SSPSR;
   2210c:	4b03      	ldr	r3, [pc, #12]	; (2211c <hal_ssp_tx_fifo_is_empty+0x10>)
   2210e:	0080      	lsls	r0, r0, #2
   22110:	58c3      	ldr	r3, [r0, r3]
   22112:	68d8      	ldr	r0, [r3, #12]
   22114:	2301      	movs	r3, #1
   22116:	4018      	ands	r0, r3
}
   22118:	4770      	bx	lr
   2211a:	46c0      	nop			; (mov r8, r8)
   2211c:	000260fc 	.word	0x000260fc

00022120 <hal_ssp_is_busy>:
    return hal_ssp_bases[bus]->SSPSR;
   22120:	4b03      	ldr	r3, [pc, #12]	; (22130 <hal_ssp_is_busy+0x10>)
   22122:	0080      	lsls	r0, r0, #2
   22124:	58c3      	ldr	r3, [r0, r3]
   22126:	68d8      	ldr	r0, [r3, #12]
    if (((hal_ssp_get_status_register(bus) >> SSP_BUSY_SHIFT) & SSP_BUSY_MASK) == SSP_BUSY_MASK)
   22128:	06c0      	lsls	r0, r0, #27
   2212a:	0fc0      	lsrs	r0, r0, #31
}
   2212c:	4770      	bx	lr
   2212e:	46c0      	nop			; (mov r8, r8)
   22130:	000260fc 	.word	0x000260fc

00022134 <hal_ssp_interrupt_is_set>:
{
   22134:	b570      	push	{r4, r5, r6, lr}
   22136:	0004      	movs	r4, r0
   22138:	000d      	movs	r5, r1
    assert(interr < HAL_SSPMAXINTR);
   2213a:	2903      	cmp	r1, #3
   2213c:	d903      	bls.n	22146 <hal_ssp_interrupt_is_set+0x12>
   2213e:	4671      	mov	r1, lr
   22140:	2016      	movs	r0, #22
   22142:	f7df fce5 	bl	1b10 <panic>
    uint32 inter_bit = (uint32)0x01 << (uint32)interr;
   22146:	2301      	movs	r3, #1
   22148:	40ab      	lsls	r3, r5
    if (((hal_ssp_bases[bus]->SSPMIS) & inter_bit) == inter_bit)
   2214a:	4a05      	ldr	r2, [pc, #20]	; (22160 <hal_ssp_interrupt_is_set+0x2c>)
   2214c:	00a4      	lsls	r4, r4, #2
   2214e:	58a2      	ldr	r2, [r4, r2]
   22150:	69d0      	ldr	r0, [r2, #28]
   22152:	4018      	ands	r0, r3
   22154:	1ac0      	subs	r0, r0, r3
   22156:	4243      	negs	r3, r0
   22158:	4158      	adcs	r0, r3
   2215a:	b2c0      	uxtb	r0, r0
}
   2215c:	bd70      	pop	{r4, r5, r6, pc}
   2215e:	46c0      	nop			; (mov r8, r8)
   22160:	000260fc 	.word	0x000260fc

00022164 <hal_ssp_interrupt_handler>:
{
   22164:	b510      	push	{r4, lr}
    if (hal_ssp_interrupt_is_set(bus, HAL_SSPRORINTR))
   22166:	2100      	movs	r1, #0
{
   22168:	0004      	movs	r4, r0
    if (hal_ssp_interrupt_is_set(bus, HAL_SSPRORINTR))
   2216a:	f7ff ffe3 	bl	22134 <hal_ssp_interrupt_is_set>
   2216e:	2800      	cmp	r0, #0
   22170:	d00b      	beq.n	2218a <hal_ssp_interrupt_handler+0x26>
        hal_ssp_bases[bus]->SSPICR = 0x01 << (uint32)HAL_SSPRORINTR;
   22172:	4b1e      	ldr	r3, [pc, #120]	; (221ec <hal_ssp_interrupt_handler+0x88>)
   22174:	00a2      	lsls	r2, r4, #2
   22176:	58d3      	ldr	r3, [r2, r3]
   22178:	2201      	movs	r2, #1
   2217a:	621a      	str	r2, [r3, #32]
        if (ssp_interrupt_handler[bus][HAL_SSPRORINTR] != NULL)
   2217c:	4b1c      	ldr	r3, [pc, #112]	; (221f0 <hal_ssp_interrupt_handler+0x8c>)
   2217e:	0122      	lsls	r2, r4, #4
   22180:	58d3      	ldr	r3, [r2, r3]
   22182:	2b00      	cmp	r3, #0
   22184:	d001      	beq.n	2218a <hal_ssp_interrupt_handler+0x26>
            (*ssp_interrupt_handler[bus][HAL_SSPRORINTR])(bus);
   22186:	0020      	movs	r0, r4
   22188:	4798      	blx	r3
    if (hal_ssp_interrupt_is_set(bus, HAL_SSPRTINTR))
   2218a:	2101      	movs	r1, #1
   2218c:	0020      	movs	r0, r4
   2218e:	f7ff ffd1 	bl	22134 <hal_ssp_interrupt_is_set>
   22192:	2800      	cmp	r0, #0
   22194:	d00c      	beq.n	221b0 <hal_ssp_interrupt_handler+0x4c>
        hal_ssp_bases[bus]->SSPICR = 0x01 << HAL_SSPRTINTR;
   22196:	4b15      	ldr	r3, [pc, #84]	; (221ec <hal_ssp_interrupt_handler+0x88>)
   22198:	00a2      	lsls	r2, r4, #2
   2219a:	58d3      	ldr	r3, [r2, r3]
   2219c:	2202      	movs	r2, #2
   2219e:	621a      	str	r2, [r3, #32]
        if (ssp_interrupt_handler[bus][HAL_SSPRTINTR] != NULL)
   221a0:	4b13      	ldr	r3, [pc, #76]	; (221f0 <hal_ssp_interrupt_handler+0x8c>)
   221a2:	0122      	lsls	r2, r4, #4
   221a4:	189b      	adds	r3, r3, r2
   221a6:	685b      	ldr	r3, [r3, #4]
   221a8:	2b00      	cmp	r3, #0
   221aa:	d001      	beq.n	221b0 <hal_ssp_interrupt_handler+0x4c>
            (*ssp_interrupt_handler[bus][HAL_SSPRTINTR])(bus);
   221ac:	0020      	movs	r0, r4
   221ae:	4798      	blx	r3
    if (hal_ssp_interrupt_is_set(bus, HAL_SSPRXINTR))
   221b0:	2102      	movs	r1, #2
   221b2:	0020      	movs	r0, r4
   221b4:	f7ff ffbe 	bl	22134 <hal_ssp_interrupt_is_set>
   221b8:	2800      	cmp	r0, #0
   221ba:	d007      	beq.n	221cc <hal_ssp_interrupt_handler+0x68>
        if (ssp_interrupt_handler[bus][HAL_SSPRXINTR] != NULL)
   221bc:	4b0c      	ldr	r3, [pc, #48]	; (221f0 <hal_ssp_interrupt_handler+0x8c>)
   221be:	0122      	lsls	r2, r4, #4
   221c0:	189b      	adds	r3, r3, r2
   221c2:	689b      	ldr	r3, [r3, #8]
   221c4:	2b00      	cmp	r3, #0
   221c6:	d001      	beq.n	221cc <hal_ssp_interrupt_handler+0x68>
            (*ssp_interrupt_handler[bus][HAL_SSPRXINTR])(bus);
   221c8:	0020      	movs	r0, r4
   221ca:	4798      	blx	r3
    if (hal_ssp_interrupt_is_set(bus, HAL_SSPTXINTR))
   221cc:	2103      	movs	r1, #3
   221ce:	0020      	movs	r0, r4
   221d0:	f7ff ffb0 	bl	22134 <hal_ssp_interrupt_is_set>
   221d4:	2800      	cmp	r0, #0
   221d6:	d007      	beq.n	221e8 <hal_ssp_interrupt_handler+0x84>
        if (ssp_interrupt_handler[bus][HAL_SSPTXINTR] != NULL)
   221d8:	4b05      	ldr	r3, [pc, #20]	; (221f0 <hal_ssp_interrupt_handler+0x8c>)
   221da:	0122      	lsls	r2, r4, #4
   221dc:	189b      	adds	r3, r3, r2
   221de:	68db      	ldr	r3, [r3, #12]
   221e0:	2b00      	cmp	r3, #0
   221e2:	d001      	beq.n	221e8 <hal_ssp_interrupt_handler+0x84>
            (*ssp_interrupt_handler[bus][HAL_SSPTXINTR])(bus);
   221e4:	0020      	movs	r0, r4
   221e6:	4798      	blx	r3
}
   221e8:	bd10      	pop	{r4, pc}
   221ea:	46c0      	nop			; (mov r8, r8)
   221ec:	000260fc 	.word	0x000260fc
   221f0:	01002d78 	.word	0x01002d78

000221f4 <hal_ssp_disable_interrupt>:
    hal_ssp_bases[bus]->SSPIMSC &= ~((uint32)0x01 << (uint32)interr);
   221f4:	2201      	movs	r2, #1
   221f6:	408a      	lsls	r2, r1
   221f8:	4b03      	ldr	r3, [pc, #12]	; (22208 <hal_ssp_disable_interrupt+0x14>)
   221fa:	0080      	lsls	r0, r0, #2
   221fc:	58c0      	ldr	r0, [r0, r3]
   221fe:	6943      	ldr	r3, [r0, #20]
   22200:	4393      	bics	r3, r2
   22202:	6143      	str	r3, [r0, #20]
}
   22204:	4770      	bx	lr
   22206:	46c0      	nop			; (mov r8, r8)
   22208:	000260fc 	.word	0x000260fc

0002220c <IRQ_SSP0_Handler>:
{
   2220c:	b510      	push	{r4, lr}
    hal_ssp_interrupt_handler(SSP_BUS0);
   2220e:	2000      	movs	r0, #0
   22210:	f7ff ffa8 	bl	22164 <hal_ssp_interrupt_handler>
}
   22214:	bd10      	pop	{r4, pc}

00022216 <IRQ_SSP1_Handler>:
{
   22216:	b510      	push	{r4, lr}
    hal_ssp_interrupt_handler(SSP_BUS1);
   22218:	2001      	movs	r0, #1
   2221a:	f7ff ffa3 	bl	22164 <hal_ssp_interrupt_handler>
}
   2221e:	bd10      	pop	{r4, pc}

00022220 <hal_ssp_disable_all_interrupts>:
{
   22220:	b510      	push	{r4, lr}
   22222:	0004      	movs	r4, r0
    hal_ssp_disable_interrupt(bus, HAL_SSPRORINTR);
   22224:	2100      	movs	r1, #0
   22226:	f7ff ffe5 	bl	221f4 <hal_ssp_disable_interrupt>
    hal_ssp_disable_interrupt(bus,  HAL_SSPRTINTR);
   2222a:	0020      	movs	r0, r4
   2222c:	2101      	movs	r1, #1
   2222e:	f7ff ffe1 	bl	221f4 <hal_ssp_disable_interrupt>
    hal_ssp_disable_interrupt(bus,  HAL_SSPRXINTR);
   22232:	0020      	movs	r0, r4
   22234:	2102      	movs	r1, #2
   22236:	f7ff ffdd 	bl	221f4 <hal_ssp_disable_interrupt>
    hal_ssp_disable_interrupt(bus,  HAL_SSPTXINTR);
   2223a:	0020      	movs	r0, r4
   2223c:	2103      	movs	r1, #3
   2223e:	f7ff ffd9 	bl	221f4 <hal_ssp_disable_interrupt>
    ssp_interrupt_handler[bus][interr] = callback;
   22242:	2200      	movs	r2, #0
   22244:	4b03      	ldr	r3, [pc, #12]	; (22254 <hal_ssp_disable_all_interrupts+0x34>)
   22246:	0124      	lsls	r4, r4, #4
   22248:	50e2      	str	r2, [r4, r3]
   2224a:	191c      	adds	r4, r3, r4
   2224c:	6062      	str	r2, [r4, #4]
   2224e:	60a2      	str	r2, [r4, #8]
   22250:	60e2      	str	r2, [r4, #12]
}
   22252:	bd10      	pop	{r4, pc}
   22254:	01002d78 	.word	0x01002d78

00022258 <hal_ssp_get_base>:
    return (ssp_ctrl_t *)hal_ssp_bases[bus];
   22258:	4b01      	ldr	r3, [pc, #4]	; (22260 <hal_ssp_get_base+0x8>)
   2225a:	0080      	lsls	r0, r0, #2
   2225c:	58c0      	ldr	r0, [r0, r3]
}
   2225e:	4770      	bx	lr
   22260:	000260fc 	.word	0x000260fc

00022264 <abort>:
 */

#include "stdlib_private.h"

__PDPCLIB_API__ void abort(void)
{
   22264:	b510      	push	{r4, lr}
    raise(SIGABRT);
   22266:	2001      	movs	r0, #1
   22268:	f000 f846 	bl	222f8 <raise>
    exit(EXIT_FAILURE);
   2226c:	2001      	movs	r0, #1
   2226e:	f7f8 ff90 	bl	1b192 <exit>
#if !defined(__EMX__) && !defined(__GCC__) && !defined(__WIN32__) \
  && !defined(__gnu_linux__)
    return;
#endif
   22272:	bd10      	pop	{r4, pc}

00022274 <rand>:

__PDPCLIB_API__ int rand(void)
{
    int ret;

    myseed = myseed * 1103515245UL + 12345;
   22274:	4b05      	ldr	r3, [pc, #20]	; (2228c <rand+0x18>)
   22276:	4806      	ldr	r0, [pc, #24]	; (22290 <rand+0x1c>)
   22278:	681a      	ldr	r2, [r3, #0]
   2227a:	4350      	muls	r0, r2
   2227c:	4a05      	ldr	r2, [pc, #20]	; (22294 <rand+0x20>)
   2227e:	4694      	mov	ip, r2
   22280:	4460      	add	r0, ip
   22282:	6018      	str	r0, [r3, #0]
    ret = (int)((myseed >> 16) & 0x7fff);
   22284:	0040      	lsls	r0, r0, #1
   22286:	0c40      	lsrs	r0, r0, #17
    return (ret);
}
   22288:	4770      	bx	lr
   2228a:	46c0      	nop			; (mov r8, r8)
   2228c:	010005ec 	.word	0x010005ec
   22290:	41c64e6d 	.word	0x41c64e6d
   22294:	00003039 	.word	0x00003039

00022298 <strstr>:
 */

#include "string_private.h"

__PDPCLIB_API__ char *strstr(const char *s1, const char *s2)
{
   22298:	b570      	push	{r4, r5, r6, lr}
    const char *p = s1, *p1, *p2 = s2;

    while (*p)
   2229a:	7803      	ldrb	r3, [r0, #0]
   2229c:	2b00      	cmp	r3, #0
   2229e:	d019      	beq.n	222d4 <strstr+0x3c>
    {
        if (*p == *s2)
   222a0:	780d      	ldrb	r5, [r1, #0]
        {
            p1 = p;
            p2 = s2;
            while ((*p2 != '\0') && (*p1 == *p2))
   222a2:	2601      	movs	r6, #1
   222a4:	e00b      	b.n	222be <strstr+0x26>
   222a6:	0023      	movs	r3, r4
   222a8:	5cca      	ldrb	r2, [r1, r3]
   222aa:	2a00      	cmp	r2, #0
   222ac:	d011      	beq.n	222d2 <strstr+0x3a>
   222ae:	1c5c      	adds	r4, r3, #1
   222b0:	5cc3      	ldrb	r3, [r0, r3]
   222b2:	4293      	cmp	r3, r2
   222b4:	d0f7      	beq.n	222a6 <strstr+0xe>
            if (*p2 == '\0')
            {
                return (char *)p;
            }
        }
        p++;
   222b6:	3001      	adds	r0, #1
    while (*p)
   222b8:	7803      	ldrb	r3, [r0, #0]
   222ba:	2b00      	cmp	r3, #0
   222bc:	d008      	beq.n	222d0 <strstr+0x38>
        if (*p == *s2)
   222be:	429d      	cmp	r5, r3
   222c0:	d1f9      	bne.n	222b6 <strstr+0x1e>
            while ((*p2 != '\0') && (*p1 == *p2))
   222c2:	2d00      	cmp	r5, #0
   222c4:	d005      	beq.n	222d2 <strstr+0x3a>
   222c6:	7803      	ldrb	r3, [r0, #0]
   222c8:	42ab      	cmp	r3, r5
   222ca:	d1f4      	bne.n	222b6 <strstr+0x1e>
   222cc:	0033      	movs	r3, r6
   222ce:	e7eb      	b.n	222a8 <strstr+0x10>
    }
    return NULL;
   222d0:	2000      	movs	r0, #0
}
   222d2:	bd70      	pop	{r4, r5, r6, pc}
    return NULL;
   222d4:	2000      	movs	r0, #0
   222d6:	e7fc      	b.n	222d2 <strstr+0x3a>

000222d8 <__sigdfl>:
    (handlers[sig])(sig);
    return (0);
}

__PDPCLIB_API__ void __sigdfl(int sig)
{
   222d8:	b510      	push	{r4, lr}
    handlers[sig] = SIG_DFL;
   222da:	0082      	lsls	r2, r0, #2
   222dc:	4b04      	ldr	r3, [pc, #16]	; (222f0 <__sigdfl+0x18>)
   222de:	4905      	ldr	r1, [pc, #20]	; (222f4 <__sigdfl+0x1c>)
   222e0:	50d1      	str	r1, [r2, r3]
    if (sig == SIGABRT)
   222e2:	2801      	cmp	r0, #1
   222e4:	d000      	beq.n	222e8 <__sigdfl+0x10>
    {
        exit(EXIT_FAILURE);
    }
    return;
}
   222e6:	bd10      	pop	{r4, pc}
        exit(EXIT_FAILURE);
   222e8:	f7f8 ff53 	bl	1b192 <exit>
    return;
   222ec:	e7fb      	b.n	222e6 <__sigdfl+0xe>
   222ee:	46c0      	nop			; (mov r8, r8)
   222f0:	010005f0 	.word	0x010005f0
   222f4:	000222d9 	.word	0x000222d9

000222f8 <raise>:
{
   222f8:	b510      	push	{r4, lr}
    (handlers[sig])(sig);
   222fa:	0082      	lsls	r2, r0, #2
   222fc:	4b02      	ldr	r3, [pc, #8]	; (22308 <raise+0x10>)
   222fe:	58d3      	ldr	r3, [r2, r3]
   22300:	4798      	blx	r3
}
   22302:	2000      	movs	r0, #0
   22304:	bd10      	pop	{r4, pc}
   22306:	46c0      	nop			; (mov r8, r8)
   22308:	010005f0 	.word	0x010005f0

0002230c <lwip_support_log>:
#include "apps_system_sw_module_ids.h"

#define LOG_STRING_MAX_LENGTH 100

void lwip_support_log (const char *str, ...)
{
   2230c:	b40f      	push	{r0, r1, r2, r3}
   2230e:	b57f      	push	{r0, r1, r2, r3, r4, r5, r6, lr}
    static char s[LOG_STRING_MAX_LENGTH];
    va_list args;
    int32 str_len;

    va_start(args, str);   //lint !e530 !e516 args not initialised, Lint has problems interpreting va_list
    str_len = vsprintf (s, str, args);
   22310:	4d0d      	ldr	r5, [pc, #52]	; (22348 <lwip_support_log+0x3c>)
{
   22312:	aa08      	add	r2, sp, #32
   22314:	ca02      	ldmia	r2!, {r1}
    str_len = vsprintf (s, str, args);
   22316:	0028      	movs	r0, r5
   22318:	4676      	mov	r6, lr
    va_start(args, str);   //lint !e530 !e516 args not initialised, Lint has problems interpreting va_list
   2231a:	9203      	str	r2, [sp, #12]
    str_len = vsprintf (s, str, args);
   2231c:	f7f8 fac7 	bl	1a8ae <vsprintf>
   22320:	0004      	movs	r4, r0
    UNUSED(str_len);     //for when asserts are turned off
    assert(str_len < LOG_STRING_MAX_LENGTH);
   22322:	2863      	cmp	r0, #99	; 0x63
   22324:	dd03      	ble.n	2232e <lwip_support_log+0x22>
   22326:	0031      	movs	r1, r6
   22328:	2016      	movs	r0, #22
   2232a:	f7df fbf1 	bl	1b10 <panic>
    va_end (args);

    log_event(APPS_SW_MODULE_LWIP_SUPPORT, LOG_VERBOSITY_NORMAL, LOG_FLAGS_NONE, NEUL_LOG_TYPE_STRING, (uint16)str_len, (uint8 *)s);
   2232e:	2300      	movs	r3, #0
   22330:	2101      	movs	r1, #1
   22332:	b2a4      	uxth	r4, r4
   22334:	9501      	str	r5, [sp, #4]
   22336:	9400      	str	r4, [sp, #0]
   22338:	001a      	movs	r2, r3
   2233a:	0008      	movs	r0, r1
   2233c:	f7e4 f97e 	bl	663c <log_event>

}
   22340:	bc7f      	pop	{r0, r1, r2, r3, r4, r5, r6}
   22342:	bc08      	pop	{r3}
   22344:	b004      	add	sp, #16
   22346:	4718      	bx	r3
   22348:	01002d98 	.word	0x01002d98

0002234c <memp_init_pool>:
 * @param memory pool descriptor
 */
void memp_init_pool(const struct memp_desc *desc)
{
    UNUSED(desc);
}
   2234c:	4770      	bx	lr

0002234e <memp_malloc_pool>:

/** allocate a memory pool
 * @param memory pool descriptor
 */
void *memp_malloc_pool(const struct memp_desc *desc)
{
   2234e:	b510      	push	{r4, lr}
    void *memp_ptr = NULL;
    if (desc != NULL)
   22350:	2800      	cmp	r0, #0
   22352:	d002      	beq.n	2235a <memp_malloc_pool+0xc>
    {
        memp_ptr = irmalloc(desc->size);
   22354:	8800      	ldrh	r0, [r0, #0]
   22356:	f7f0 fb53 	bl	12a00 <irmalloc>
    }
    return memp_ptr;
}
   2235a:	bd10      	pop	{r4, pc}

0002235c <memp_free_pool>:
/** free a memory pool
 * @param memory pool descriptor
 * @param address to free
 */
void  memp_free_pool(const struct memp_desc* desc, void *mem)
{
   2235c:	b510      	push	{r4, lr}
    UNUSED(desc);
    if (mem != NULL)
   2235e:	2900      	cmp	r1, #0
   22360:	d002      	beq.n	22368 <memp_free_pool+0xc>
    {
        irfree(mem);
   22362:	0008      	movs	r0, r1
   22364:	f7f0 fb68 	bl	12a38 <irfree>
    }
}
   22368:	bd10      	pop	{r4, pc}
	...

0002236c <ip4_socket_recv_notify_callback>:

/**call  ip4 recv callback
 *
 */
static void ip4_socket_recv_notify_callback(int socket_num, ssize_t length, const struct sockaddr *addr, socklen_t addr_len)
{
   2236c:	b510      	push	{r4, lr}
    UNUSED(socket_num);
    UNUSED(length);
    UNUSED(addr);
    UNUSED(addr_len);
    if (netif_callback != NULL)
   2236e:	4b03      	ldr	r3, [pc, #12]	; (2237c <ip4_socket_recv_notify_callback+0x10>)
   22370:	681b      	ldr	r3, [r3, #0]
   22372:	2b00      	cmp	r3, #0
   22374:	d000      	beq.n	22378 <ip4_socket_recv_notify_callback+0xc>
    {
        (netif_callback)();
   22376:	4798      	blx	r3
    }
}
   22378:	bd10      	pop	{r4, pc}
   2237a:	46c0      	nop			; (mov r8, r8)
   2237c:	01002dfc 	.word	0x01002dfc

00022380 <netif_ip4_socket_recv>:
{
   22380:	b5f0      	push	{r4, r5, r6, r7, lr}
    int socket_num = (int) netif_in->socket;
   22382:	0003      	movs	r3, r0
{
   22384:	0007      	movs	r7, r0
    buffer = irmalloc(buffer_length);
   22386:	20c0      	movs	r0, #192	; 0xc0
    int socket_num = (int) netif_in->socket;
   22388:	3352      	adds	r3, #82	; 0x52
{
   2238a:	b089      	sub	sp, #36	; 0x24
    buffer = irmalloc(buffer_length);
   2238c:	00c0      	lsls	r0, r0, #3
    int socket_num = (int) netif_in->socket;
   2238e:	2600      	movs	r6, #0
   22390:	5f9e      	ldrsh	r6, [r3, r6]
        return ret;
   22392:	2400      	movs	r4, #0
    buffer = irmalloc(buffer_length);
   22394:	f7f0 fb34 	bl	12a00 <irmalloc>
   22398:	0005      	movs	r5, r0
    if (buffer == NULL)
   2239a:	42a0      	cmp	r0, r4
   2239c:	d023      	beq.n	223e6 <netif_ip4_socket_recv+0x66>
    recv_size = (ssize_t) recvfrom(socket_num, buffer, buffer_length, (SOCK_MSG_FLAG) MSG_NORMAL,
   2239e:	2318      	movs	r3, #24
   223a0:	22c0      	movs	r2, #192	; 0xc0
   223a2:	9301      	str	r3, [sp, #4]
   223a4:	ab02      	add	r3, sp, #8
   223a6:	0001      	movs	r1, r0
   223a8:	9300      	str	r3, [sp, #0]
   223aa:	00d2      	lsls	r2, r2, #3
   223ac:	0023      	movs	r3, r4
   223ae:	0030      	movs	r0, r6
   223b0:	f7e5 fdb6 	bl	7f20 <recvfrom>
    if ((recv_size > 0) && (recv_size <= (ssize_t)buffer_length))
   223b4:	4b0d      	ldr	r3, [pc, #52]	; (223ec <netif_ip4_socket_recv+0x6c>)
   223b6:	1e42      	subs	r2, r0, #1
    recv_size = (ssize_t) recvfrom(socket_num, buffer, buffer_length, (SOCK_MSG_FLAG) MSG_NORMAL,
   223b8:	0001      	movs	r1, r0
    if ((recv_size > 0) && (recv_size <= (ssize_t)buffer_length))
   223ba:	429a      	cmp	r2, r3
   223bc:	d810      	bhi.n	223e0 <netif_ip4_socket_recv+0x60>
        p = buffer_to_pbuf(buffer, (size_t) recv_size);
   223be:	0028      	movs	r0, r5
   223c0:	f000 f957 	bl	22672 <buffer_to_pbuf>
   223c4:	0006      	movs	r6, r0
        if ((p != NULL) && (netif_in->output != NULL))
   223c6:	42a0      	cmp	r0, r4
   223c8:	d006      	beq.n	223d8 <netif_ip4_socket_recv+0x58>
   223ca:	6c7b      	ldr	r3, [r7, #68]	; 0x44
   223cc:	42a3      	cmp	r3, r4
   223ce:	d003      	beq.n	223d8 <netif_ip4_socket_recv+0x58>
            ret_value = (netif_in->output)(netif_in, p, NULL);
   223d0:	0001      	movs	r1, r0
   223d2:	0022      	movs	r2, r4
   223d4:	0038      	movs	r0, r7
   223d6:	4798      	blx	r3
        (void) pbuf_free(p);
   223d8:	0030      	movs	r0, r6
   223da:	f000 f8bb 	bl	22554 <pbuf_free>
        ret = true;
   223de:	2401      	movs	r4, #1
    irfree(buffer);
   223e0:	0028      	movs	r0, r5
   223e2:	f7f0 fb29 	bl	12a38 <irfree>
}
   223e6:	0020      	movs	r0, r4
   223e8:	b009      	add	sp, #36	; 0x24
   223ea:	bdf0      	pop	{r4, r5, r6, r7, pc}
   223ec:	000005ff 	.word	0x000005ff

000223f0 <netif_ip4_socket_recv_notify_register>:
    netif_callback = callback;
   223f0:	4b01      	ldr	r3, [pc, #4]	; (223f8 <netif_ip4_socket_recv_notify_register+0x8>)
   223f2:	6018      	str	r0, [r3, #0]
}
   223f4:	4770      	bx	lr
   223f6:	46c0      	nop			; (mov r8, r8)
   223f8:	01002dfc 	.word	0x01002dfc

000223fc <netif_add>:
    struct sockaddr_in sock_address;
    socklen_t sock_len = sizeof(struct sockaddr_in);

    // netif init
    ip_addr_set_zero_ip4(&netif->ip_addr);  //lint !e774 always evaluates to true
    ip_addr_set_zero_ip4(&netif->netmask);  //lint !e774 always evaluates to true
   223fc:	0002      	movs	r2, r0
    ip_addr_set_zero_ip4(&netif->ip_addr);  //lint !e774 always evaluates to true
   223fe:	2300      	movs	r3, #0
{
   22400:	b5f0      	push	{r4, r5, r6, r7, lr}
    ip_addr_set_zero_ip4(&netif->netmask);  //lint !e774 always evaluates to true
   22402:	3228      	adds	r2, #40	; 0x28
    ip_addr_set_zero_ip4(&netif->ip_addr);  //lint !e774 always evaluates to true
   22404:	6043      	str	r3, [r0, #4]
   22406:	6083      	str	r3, [r0, #8]
   22408:	60c3      	str	r3, [r0, #12]
   2240a:	6103      	str	r3, [r0, #16]
   2240c:	7503      	strb	r3, [r0, #20]
    ip_addr_set_zero_ip4(&netif->netmask);  //lint !e774 always evaluates to true
   2240e:	6183      	str	r3, [r0, #24]
   22410:	61c3      	str	r3, [r0, #28]
   22412:	6203      	str	r3, [r0, #32]
   22414:	6243      	str	r3, [r0, #36]	; 0x24
{
   22416:	b089      	sub	sp, #36	; 0x24
    ip_addr_set_zero_ip4(&netif->netmask);  //lint !e774 always evaluates to true
   22418:	7013      	strb	r3, [r2, #0]
    ip_addr_set_zero_ip4(&netif->gw);       //lint !e774 always evaluates to true
   2241a:	62c3      	str	r3, [r0, #44]	; 0x2c
   2241c:	6303      	str	r3, [r0, #48]	; 0x30
   2241e:	6343      	str	r3, [r0, #52]	; 0x34
   22420:	6383      	str	r3, [r0, #56]	; 0x38
   22422:	3214      	adds	r2, #20
   22424:	7013      	strb	r3, [r2, #0]
    ip_addr_set_zero_ip6(&netif->ip6_addr[i]);
    netif->ip6_addr_state[i] = IP6_ADDR_INVALID;
  }
  netif->output_ip6 = netif_null_output_ip6;
#endif /* LWIP_IPV6 */
    netif->flags = 0;
   22426:	7493      	strb	r3, [r2, #18]

    /* remember netif specific state information data */
    netif->state = state;
   22428:	9a0e      	ldr	r2, [sp, #56]	; 0x38
{
   2242a:	0004      	movs	r4, r0
    netif->state = state;
   2242c:	6482      	str	r2, [r0, #72]	; 0x48
    netif->num = 0;
   2242e:	0002      	movs	r2, r0
   22430:	3251      	adds	r2, #81	; 0x51
   22432:	7013      	strb	r3, [r2, #0]
    netif->input = input;
   22434:	9b10      	ldr	r3, [sp, #64]	; 0x40
{
   22436:	000e      	movs	r6, r1
    netif->input = input;
   22438:	6403      	str	r3, [r0, #64]	; 0x40

    netif_set_addr(netif, ipaddr, netmask, gw);

    if (init(netif) != ERR_OK) {
   2243a:	9b0f      	ldr	r3, [sp, #60]	; 0x3c
   2243c:	4798      	blx	r3
   2243e:	1e05      	subs	r5, r0, #0
   22440:	d003      	beq.n	2244a <netif_add+0x4e>
      return NULL;
   22442:	2400      	movs	r4, #0

    // do we need to do a connect to call raw_connect() on protocol? not for sendto

    netif->socket = (int16) sock_num;
    return netif;
}
   22444:	0020      	movs	r0, r4
   22446:	b009      	add	sp, #36	; 0x24
   22448:	bdf0      	pop	{r4, r5, r6, r7, pc}
    netif->next = NULL; // we only have 1
   2244a:	6020      	str	r0, [r4, #0]
    sock_num = socket(AF_INET, SOCK_RAW, RAW);
   2244c:	22ff      	movs	r2, #255	; 0xff
   2244e:	2103      	movs	r1, #3
   22450:	2002      	movs	r0, #2
   22452:	f7e5 fc37 	bl	7cc4 <socket>
   22456:	1e07      	subs	r7, r0, #0
    if (sock_num < 0)
   22458:	dbf3      	blt.n	22442 <netif_add+0x46>
    sock_address.sin_family = AF_INET;
   2245a:	2302      	movs	r3, #2
   2245c:	aa02      	add	r2, sp, #8
   2245e:	7013      	strb	r3, [r2, #0]
    ip_addr_set_ip4_u32(&(sock_address.sin_addr), ipaddr->addr); //lint !e774 !e506 always evaluates to true
   22460:	6833      	ldr	r3, [r6, #0]
    sock_address.sin_port   = 0;
   22462:	8055      	strh	r5, [r2, #2]
    ip_addr_set_ip4_u32(&(sock_address.sin_addr), ipaddr->addr); //lint !e774 !e506 always evaluates to true
   22464:	9301      	str	r3, [sp, #4]
   22466:	9303      	str	r3, [sp, #12]
   22468:	7515      	strb	r5, [r2, #20]
    if(neul_bind(sock_num,
   2246a:	4b05      	ldr	r3, [pc, #20]	; (22480 <netif_add+0x84>)
   2246c:	2218      	movs	r2, #24
   2246e:	a902      	add	r1, sp, #8
   22470:	f7e5 fc66 	bl	7d40 <neul_bind>
   22474:	2800      	cmp	r0, #0
   22476:	d1e4      	bne.n	22442 <netif_add+0x46>
    netif->socket = (int16) sock_num;
   22478:	0023      	movs	r3, r4
   2247a:	3352      	adds	r3, #82	; 0x52
   2247c:	801f      	strh	r7, [r3, #0]
    return netif;
   2247e:	e7e1      	b.n	22444 <netif_add+0x48>
   22480:	0002236d 	.word	0x0002236d

00022484 <netif_set_addr>:
{
    UNUSED(netif);
    UNUSED(ipaddr);
    UNUSED(netmask);
    UNUSED(gw);
}
   22484:	4770      	bx	lr

00022486 <netif_set_link_up>:
   22486:	4770      	bx	lr

00022488 <netif_set_link_down>:
   22488:	4770      	bx	lr

0002248a <ip4_input>:
 * @param p received IP packet (p->payload points to IP header)
 * @param inp the netif on which the packet was received
 * @return ERR_OK if processed ok, else ERR_error
 */
err_t ip4_input(struct pbuf *p, struct netif *inp)
{
   2248a:	b5f0      	push	{r4, r5, r6, r7, lr}
    size_t length;
    err_t ret_value;
    struct sockaddr_in sock_address;
    socklen_t sock_len = sizeof(struct sockaddr_in);

    sock_address.sin_family = AF_INET;
   2248c:	2302      	movs	r3, #2
    sock_address.sin_port   = 0;
   2248e:	2400      	movs	r4, #0
{
   22490:	b08d      	sub	sp, #52	; 0x34
    sock_address.sin_family = AF_INET;
   22492:	ad06      	add	r5, sp, #24
   22494:	702b      	strb	r3, [r5, #0]
    sock_address.sin_port   = 0;
   22496:	806c      	strh	r4, [r5, #2]
    ip_addr_set_any(false,&(sock_address.sin_addr));  //lint !e774 always evaluates to true
   22498:	9407      	str	r4, [sp, #28]
   2249a:	752c      	strb	r4, [r5, #20]

    sock_num = inp->socket;
   2249c:	3152      	adds	r1, #82	; 0x52
   2249e:	2200      	movs	r2, #0
   224a0:	5e8b      	ldrsh	r3, [r1, r2]
    message = pbuf_to_buffer(p, &length);
   224a2:	a905      	add	r1, sp, #20
{
   224a4:	0006      	movs	r6, r0
    sock_num = inp->socket;
   224a6:	9303      	str	r3, [sp, #12]
    message = pbuf_to_buffer(p, &length);
   224a8:	f000 f8be 	bl	22628 <pbuf_to_buffer>
   224ac:	0007      	movs	r7, r0
    if (message != NULL)
   224ae:	42a0      	cmp	r0, r4
   224b0:	d012      	beq.n	224d8 <ip4_input+0x4e>
    {
        tx_size = (ssize_t) sendto(sock_num, message, length, MSG_NORMAL,
   224b2:	2318      	movs	r3, #24
   224b4:	0001      	movs	r1, r0
   224b6:	9301      	str	r3, [sp, #4]
   224b8:	9500      	str	r5, [sp, #0]
   224ba:	0023      	movs	r3, r4
   224bc:	9a05      	ldr	r2, [sp, #20]
   224be:	9803      	ldr	r0, [sp, #12]
   224c0:	f7e5 fcb4 	bl	7e2c <sendto>
    else
    {
        ret_value = ERR_MEM;
    }

    free_buffer_from_pbuf(message, p);
   224c4:	0031      	movs	r1, r6
   224c6:	0038      	movs	r0, r7
   224c8:	f000 f8cb 	bl	22662 <free_buffer_from_pbuf>
    (void) pbuf_free(p);
   224cc:	0030      	movs	r0, r6
   224ce:	f000 f841 	bl	22554 <pbuf_free>
    return ret_value;
}  //lint !e818 inp const
   224d2:	0020      	movs	r0, r4
   224d4:	b00d      	add	sp, #52	; 0x34
   224d6:	bdf0      	pop	{r4, r5, r6, r7, pc}
        ret_value = ERR_MEM;
   224d8:	2401      	movs	r4, #1
   224da:	4264      	negs	r4, r4
   224dc:	e7f2      	b.n	224c4 <ip4_input+0x3a>
	...

000224e0 <pbuf_alloc>:
 * @param length size of the pbuf payload
 * @param type where to allocate PBUF (PBUF_RAM/PBUF_ROM/PBUF_REF/PBUF_POOL)
 * @return the allocated pbuf chain
 */
struct pbuf *pbuf_alloc(pbuf_layer layer, u16_t length, pbuf_type type)
{
   224e0:	b570      	push	{r4, r5, r6, lr}
   224e2:	000d      	movs	r5, r1
   224e4:	0016      	movs	r6, r2
    UNUSED(layer);
    struct pbuf *p;
    uint16 offset;

    switch(layer)
   224e6:	2801      	cmp	r0, #1
   224e8:	d005      	beq.n	224f6 <pbuf_alloc+0x16>
   224ea:	2800      	cmp	r0, #0
   224ec:	d001      	beq.n	224f2 <pbuf_alloc+0x12>
   224ee:	2804      	cmp	r0, #4
   224f0:	d10b      	bne.n	2250a <pbuf_alloc+0x2a>
    {
        case PBUF_TRANSPORT:
            offset = 0;
   224f2:	2400      	movs	r4, #0
   224f4:	e000      	b.n	224f8 <pbuf_alloc+0x18>
            break;
        case PBUF_RAW:
            offset = 0;
            break;
        case PBUF_IP:
            offset =  PBUF_LINK_ENCAPSULATION_HLEN + PBUF_LINK_HLEN + PBUF_IP_HLEN; //lint !e845 always 0
   224f6:	2414      	movs	r4, #20
    }

    uint16 alloc_length;
    uint8 *alloc_start;

    switch (type)
   224f8:	2e00      	cmp	r6, #0
   224fa:	d015      	beq.n	22528 <pbuf_alloc+0x48>
   224fc:	2e03      	cmp	r6, #3
   224fe:	d104      	bne.n	2250a <pbuf_alloc+0x2a>
    {
        case PBUF_POOL:
            alloc_length = PAD_START + LWIP_MEM_ALIGN_SIZE(sizeof(struct pbuf)) + PBUF_POOL_BUFSIZE_ALIGNED; //lint !e845 always 0
            alloc_start = (uint8 *) irzalloc(alloc_length);
   22500:	4810      	ldr	r0, [pc, #64]	; (22544 <pbuf_alloc+0x64>)
   22502:	f7f0 fa87 	bl	12a14 <irzalloc>
            if (alloc_start == NULL) {
   22506:	2800      	cmp	r0, #0
   22508:	d101      	bne.n	2250e <pbuf_alloc+0x2e>
            return NULL;
   2250a:	2000      	movs	r0, #0
   2250c:	e00b      	b.n	22526 <pbuf_alloc+0x46>
              return NULL;
            }
            p = (struct pbuf*) alloc_start;

            /* Set up internal structure of the pbuf. */
            p->payload = (u8_t *)p + LWIP_MEM_ALIGN_SIZE(sizeof(struct pbuf) + offset);
   2250e:	341b      	adds	r4, #27
   22510:	43b4      	bics	r4, r6
            p->len = p->tot_len = length;
            break;
        default:
            return NULL;
    }
    p->next = NULL;
   22512:	2300      	movs	r3, #0
    p->type = type;
    /* set reference count */
    p->ref = 1;
   22514:	2201      	movs	r2, #1
            p->payload = (u8_t *)p + LWIP_MEM_ALIGN_SIZE(sizeof(struct pbuf) + offset);
   22516:	1904      	adds	r4, r0, r4
   22518:	6044      	str	r4, [r0, #4]
            p->len = p->tot_len = length;
   2251a:	8105      	strh	r5, [r0, #8]
   2251c:	8145      	strh	r5, [r0, #10]
    p->next = NULL;
   2251e:	6003      	str	r3, [r0, #0]
    p->type = type;
   22520:	7306      	strb	r6, [r0, #12]
    p->ref = 1;
   22522:	8282      	strh	r2, [r0, #20]
    /* set flags */
    p->flags = 0;
   22524:	6103      	str	r3, [r0, #16]
    return p;
}
   22526:	bd70      	pop	{r4, r5, r6, pc}
            alloc_length = PAD_START + LWIP_MEM_ALIGN_SIZE(sizeof(struct pbuf) + offset) + LWIP_MEM_ALIGN_SIZE(length);
   22528:	2303      	movs	r3, #3
   2252a:	1ce8      	adds	r0, r5, #3
   2252c:	4398      	bics	r0, r3
   2252e:	341b      	adds	r4, #27
   22530:	3010      	adds	r0, #16
   22532:	439c      	bics	r4, r3
   22534:	1900      	adds	r0, r0, r4
            alloc_start = (uint8 *) irzalloc(alloc_length);
   22536:	b280      	uxth	r0, r0
   22538:	f7f0 fa6c 	bl	12a14 <irzalloc>
            if (alloc_start == NULL) {
   2253c:	2800      	cmp	r0, #0
   2253e:	d1e8      	bne.n	22512 <pbuf_alloc+0x32>
   22540:	e7e3      	b.n	2250a <pbuf_alloc+0x2a>
   22542:	46c0      	nop			; (mov r8, r8)
   22544:	00000604 	.word	0x00000604

00022548 <pbuf_realloc>:
 * @param pbuf chain to change size of
 * @param new_len new length of chain
 */
void pbuf_realloc(struct pbuf *p, u16_t new_len)
{
    if (new_len >= p->tot_len)
   22548:	8903      	ldrh	r3, [r0, #8]
   2254a:	428b      	cmp	r3, r1
   2254c:	d901      	bls.n	22552 <pbuf_realloc+0xa>
    {
        return;
    }
    p->tot_len = new_len;
   2254e:	8101      	strh	r1, [r0, #8]
    p->len = p->tot_len;
   22550:	8141      	strh	r1, [r0, #10]
}
   22552:	4770      	bx	lr

00022554 <pbuf_free>:
/** dereference and, if ref=0, free a pbuf/pbuf chain
 * @param pbuf chain to be dereferenced.
 * @return the number of pbufs that were freed
 */
u8_t pbuf_free(struct pbuf *p)
{
   22554:	b510      	push	{r4, lr}
    //It just frees - also not thread safe...

    struct pbuf *next;
    struct pbuf *current = p;

    while (current)
   22556:	2800      	cmp	r0, #0
   22558:	d100      	bne.n	2255c <pbuf_free+0x8>
            irfree(alloc_start);
        }
        current = next;
    }
    return 0;
}
   2255a:	bd10      	pop	{r4, pc}
        if (current->ref > 1)
   2255c:	8a83      	ldrh	r3, [r0, #20]
        next = current->next;
   2255e:	6804      	ldr	r4, [r0, #0]
        if (current->ref > 1)
   22560:	2b01      	cmp	r3, #1
   22562:	d903      	bls.n	2256c <pbuf_free+0x18>
            current->ref--;
   22564:	3b01      	subs	r3, #1
   22566:	8283      	strh	r3, [r0, #20]
{
   22568:	0020      	movs	r0, r4
   2256a:	e7f4      	b.n	22556 <pbuf_free+0x2>
            irfree(alloc_start);
   2256c:	f7f0 fa64 	bl	12a38 <irfree>
   22570:	e7fa      	b.n	22568 <pbuf_free+0x14>

00022572 <pbuf_header>:
 * @param pbuf to change the header size.
 * @param header_size_increment number of bytes to increase header by
 * @return 0 on success, else !0 on failure
 */
u8_t pbuf_header(struct pbuf *p, s16_t header_size_increment)
{
   22572:	b570      	push	{r4, r5, r6, lr}
   22574:	0005      	movs	r5, r0

    if ((header_size_increment == 0) || (p == NULL))
    {
        return 0;
   22576:	2000      	movs	r0, #0
   22578:	4676      	mov	r6, lr
{
   2257a:	000c      	movs	r4, r1
    if ((header_size_increment == 0) || (p == NULL))
   2257c:	4281      	cmp	r1, r0
   2257e:	d018      	beq.n	225b2 <pbuf_header+0x40>
   22580:	4285      	cmp	r5, r0
   22582:	d016      	beq.n	225b2 <pbuf_header+0x40>
    }

    if (header_size_increment < 0)
   22584:	4281      	cmp	r1, r0
   22586:	da09      	bge.n	2259c <pbuf_header+0x2a>
    {
        assert(abs(header_size_increment) <= p->len);
   22588:	0008      	movs	r0, r1
   2258a:	f7f8 fdf1 	bl	1b170 <abs>
   2258e:	896b      	ldrh	r3, [r5, #10]
   22590:	4298      	cmp	r0, r3
   22592:	dd03      	ble.n	2259c <pbuf_header+0x2a>
   22594:	0031      	movs	r1, r6
   22596:	2016      	movs	r0, #22
   22598:	f7df faba 	bl	1b10 <panic>
    }

    if (((uint8 *)p->payload - header_size_increment) < ((uint8 *)p + LWIP_MEM_ALIGN_SIZE(sizeof(struct pbuf))))
   2259c:	002a      	movs	r2, r5
   2259e:	686b      	ldr	r3, [r5, #4]
   225a0:	3218      	adds	r2, #24
   225a2:	1b1b      	subs	r3, r3, r4
   225a4:	4293      	cmp	r3, r2
   225a6:	d205      	bcs.n	225b4 <pbuf_header+0x42>
    {
        assert(false);
   225a8:	2016      	movs	r0, #22
   225aa:	0031      	movs	r1, r6
   225ac:	f7df fab0 	bl	1b10 <panic>
        return 1;   //lint !e527 unreachable code
   225b0:	2001      	movs	r0, #1
    p->payload = (u8_t *)p->payload - header_size_increment;
    p->len = (uint16) (p->len + header_size_increment);
    p->tot_len = (uint16) (p->tot_len + header_size_increment);

    return 0;
}
   225b2:	bd70      	pop	{r4, r5, r6, pc}
    p->payload = (u8_t *)p->payload - header_size_increment;
   225b4:	606b      	str	r3, [r5, #4]
    p->len = (uint16) (p->len + header_size_increment);
   225b6:	896b      	ldrh	r3, [r5, #10]
   225b8:	b2a4      	uxth	r4, r4
   225ba:	18e3      	adds	r3, r4, r3
   225bc:	816b      	strh	r3, [r5, #10]
    p->tot_len = (uint16) (p->tot_len + header_size_increment);
   225be:	892b      	ldrh	r3, [r5, #8]
    return 0;
   225c0:	2000      	movs	r0, #0
    p->tot_len = (uint16) (p->tot_len + header_size_increment);
   225c2:	18e4      	adds	r4, r4, r3
   225c4:	812c      	strh	r4, [r5, #8]
    return 0;
   225c6:	e7f4      	b.n	225b2 <pbuf_header+0x40>

000225c8 <pbuf_cat>:
/** Concatenate two pbufs
 * @param head pbuf
 * @param tail pbuf
 */
void pbuf_cat(struct pbuf *head, struct pbuf *tail)
{
   225c8:	b570      	push	{r4, r5, r6, lr}
   225ca:	4676      	mov	r6, lr
   225cc:	0004      	movs	r4, r0
   225ce:	000d      	movs	r5, r1
    struct pbuf *p;

    if ((head == NULL) || (tail == NULL))
   225d0:	2800      	cmp	r0, #0
   225d2:	d006      	beq.n	225e2 <pbuf_cat+0x1a>
   225d4:	2900      	cmp	r1, #0
   225d6:	d10f      	bne.n	225f8 <pbuf_cat+0x30>
    {
        assert(head!= NULL);
        assert(tail!=NULL);
   225d8:	0031      	movs	r1, r6
   225da:	2016      	movs	r0, #22
   225dc:	f7df fa98 	bl	1b10 <panic>
    }
    assert(p->tot_len == p->len);
    assert(p->next == NULL);
    p->tot_len += tail->tot_len;
    p->next = tail;
}
   225e0:	bd70      	pop	{r4, r5, r6, pc}
        assert(head!= NULL);
   225e2:	4671      	mov	r1, lr
   225e4:	2016      	movs	r0, #22
   225e6:	f7df fa93 	bl	1b10 <panic>
        assert(tail!=NULL);
   225ea:	2d00      	cmp	r5, #0
   225ec:	d1f8      	bne.n	225e0 <pbuf_cat+0x18>
   225ee:	e7f3      	b.n	225d8 <pbuf_cat+0x10>
        p->tot_len += tail->tot_len;
   225f0:	8929      	ldrh	r1, [r5, #8]
   225f2:	185b      	adds	r3, r3, r1
   225f4:	8123      	strh	r3, [r4, #8]
   225f6:	0014      	movs	r4, r2
    for (p = head; p->next != NULL; p = p->next)
   225f8:	6822      	ldr	r2, [r4, #0]
   225fa:	8923      	ldrh	r3, [r4, #8]
   225fc:	2a00      	cmp	r2, #0
   225fe:	d1f7      	bne.n	225f0 <pbuf_cat+0x28>
    assert(p->tot_len == p->len);
   22600:	8962      	ldrh	r2, [r4, #10]
   22602:	429a      	cmp	r2, r3
   22604:	d003      	beq.n	2260e <pbuf_cat+0x46>
   22606:	0031      	movs	r1, r6
   22608:	2016      	movs	r0, #22
   2260a:	f7df fa81 	bl	1b10 <panic>
    assert(p->next == NULL);
   2260e:	6823      	ldr	r3, [r4, #0]
   22610:	2b00      	cmp	r3, #0
   22612:	d003      	beq.n	2261c <pbuf_cat+0x54>
   22614:	0031      	movs	r1, r6
   22616:	2016      	movs	r0, #22
   22618:	f7df fa7a 	bl	1b10 <panic>
    p->tot_len += tail->tot_len;
   2261c:	892a      	ldrh	r2, [r5, #8]
   2261e:	8923      	ldrh	r3, [r4, #8]
    p->next = tail;
   22620:	6025      	str	r5, [r4, #0]
    p->tot_len += tail->tot_len;
   22622:	189b      	adds	r3, r3, r2
   22624:	8123      	strh	r3, [r4, #8]
   22626:	e7db      	b.n	225e0 <pbuf_cat+0x18>

00022628 <pbuf_to_buffer>:
 * to free the data buffer (safe to call even if p was not in a chain)
 * @param pbuf to convert
 * @param pointer to buffer
 */
void *pbuf_to_buffer(struct pbuf *p, size_t *length)
{
   22628:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    uint16 pbuf_data_length;
    uint8 *pbuf_data;

    if (p->tot_len != p->len)
   2262a:	8905      	ldrh	r5, [r0, #8]
   2262c:	8943      	ldrh	r3, [r0, #10]
{
   2262e:	0004      	movs	r4, r0
   22630:	000f      	movs	r7, r1
    if (p->tot_len != p->len)
   22632:	42ab      	cmp	r3, r5
   22634:	d013      	beq.n	2265e <pbuf_to_buffer+0x36>
    {
        struct pbuf *current = p;
        pbuf_data = irmalloc(p->tot_len);
   22636:	0028      	movs	r0, r5
   22638:	f7f0 f9e2 	bl	12a00 <irmalloc>
   2263c:	1e06      	subs	r6, r0, #0
        if (pbuf_data == NULL)
   2263e:	d00c      	beq.n	2265a <pbuf_to_buffer+0x32>
        {
            return NULL;
        }

        pbuf_data_length = 0;
   22640:	2500      	movs	r5, #0
        while (current)
        {
            memcpy(pbuf_data + pbuf_data_length, current->payload, current->len);
   22642:	1970      	adds	r0, r6, r5
   22644:	8962      	ldrh	r2, [r4, #10]
   22646:	6861      	ldr	r1, [r4, #4]
   22648:	f7dd fdd2 	bl	1f0 <memcpy>
            pbuf_data_length += current->len;
   2264c:	8963      	ldrh	r3, [r4, #10]
            current = current->next;
   2264e:	6824      	ldr	r4, [r4, #0]
            pbuf_data_length += current->len;
   22650:	18ed      	adds	r5, r5, r3
   22652:	b2ad      	uxth	r5, r5
        while (current)
   22654:	2c00      	cmp	r4, #0
   22656:	d1f4      	bne.n	22642 <pbuf_to_buffer+0x1a>
    {
        pbuf_data = (uint8 *)(p->payload);
        pbuf_data_length = p->len;
    }

    *length = (size_t)pbuf_data_length;
   22658:	603d      	str	r5, [r7, #0]
    return (void *)pbuf_data;
}
   2265a:	0030      	movs	r0, r6
   2265c:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
        pbuf_data = (uint8 *)(p->payload);
   2265e:	6846      	ldr	r6, [r0, #4]
   22660:	e7fa      	b.n	22658 <pbuf_to_buffer+0x30>

00022662 <free_buffer_from_pbuf>:
 * @param buffer The buffer returned from pbuf_to_buffer
 * @param p The pbuf
 */
void free_buffer_from_pbuf(void *buffer, const struct pbuf *p)
{
    if (p->tot_len != p->len)
   22662:	890a      	ldrh	r2, [r1, #8]
   22664:	894b      	ldrh	r3, [r1, #10]
{
   22666:	b510      	push	{r4, lr}
    if (p->tot_len != p->len)
   22668:	429a      	cmp	r2, r3
   2266a:	d001      	beq.n	22670 <free_buffer_from_pbuf+0xe>
    {
        irfree(buffer);
   2266c:	f7f0 f9e4 	bl	12a38 <irfree>
    }
}
   22670:	bd10      	pop	{r4, pc}

00022672 <buffer_to_pbuf>:

/** convert linear buffer tp pbuf structure
 *
 */
struct pbuf *buffer_to_pbuf(const void *buffer, size_t length)
{
   22672:	b570      	push	{r4, r5, r6, lr}
    struct pbuf *p;
    p = pbuf_alloc(PBUF_IP, (u16_t)length, PBUF_RAM);
   22674:	2200      	movs	r2, #0
{
   22676:	0006      	movs	r6, r0
   22678:	000d      	movs	r5, r1
    p = pbuf_alloc(PBUF_IP, (u16_t)length, PBUF_RAM);
   2267a:	2001      	movs	r0, #1
   2267c:	b289      	uxth	r1, r1
   2267e:	f7ff ff2f 	bl	224e0 <pbuf_alloc>
   22682:	1e04      	subs	r4, r0, #0
    if (p != NULL)
   22684:	d004      	beq.n	22690 <buffer_to_pbuf+0x1e>
    {
        memcpy(p->payload, buffer, length);
   22686:	002a      	movs	r2, r5
   22688:	0031      	movs	r1, r6
   2268a:	6840      	ldr	r0, [r0, #4]
   2268c:	f7dd fdb0 	bl	1f0 <memcpy>
    }
    return p;
}
   22690:	0020      	movs	r0, r4
   22692:	bd70      	pop	{r4, r5, r6, pc}

00022694 <serial_uart_callback>:

    return true;
}

static void serial_uart_callback(void *buffer, uint16 length, UART_RELEASE_FUNCTION finished_with_rx_fragment)
{
   22694:	b510      	push	{r4, lr}
    if (serial_rx_callback != NULL)
   22696:	4b04      	ldr	r3, [pc, #16]	; (226a8 <serial_uart_callback+0x14>)
   22698:	681b      	ldr	r3, [r3, #0]
   2269a:	2b00      	cmp	r3, #0
   2269c:	d001      	beq.n	226a2 <serial_uart_callback+0xe>
    {
        serial_rx_callback(buffer, length, finished_with_rx_fragment);	
   2269e:	4798      	blx	r3
    }
    else
    {
        finished_with_rx_fragment(buffer, length);  //No one to pass the data to, so let the uart drop it
    }
}
   226a0:	bd10      	pop	{r4, pc}
        finished_with_rx_fragment(buffer, length);  //No one to pass the data to, so let the uart drop it
   226a2:	4790      	blx	r2
}
   226a4:	e7fc      	b.n	226a0 <serial_uart_callback+0xc>
   226a6:	46c0      	nop			; (mov r8, r8)
   226a8:	01002e04 	.word	0x01002e04

000226ac <sio_open>:
{
   226ac:	4673      	mov	r3, lr
   226ae:	b5f0      	push	{r4, r5, r6, r7, lr}
    if ( (neul_lwip_uart_config.uart_rx == PIN_NONE) ||
   226b0:	4c22      	ldr	r4, [pc, #136]	; (2273c <sio_open+0x90>)
{
   226b2:	b087      	sub	sp, #28
   226b4:	9301      	str	r3, [sp, #4]
    if ( (neul_lwip_uart_config.uart_rx == PIN_NONE) ||
   226b6:	78a3      	ldrb	r3, [r4, #2]
   226b8:	2b28      	cmp	r3, #40	; 0x28
   226ba:	d102      	bne.n	226c2 <sio_open+0x16>
        return NULL;
   226bc:	2000      	movs	r0, #0
}
   226be:	b007      	add	sp, #28
   226c0:	bdf0      	pop	{r4, r5, r6, r7, pc}
    if ( (neul_lwip_uart_config.uart_rx == PIN_NONE) ||
   226c2:	78e3      	ldrb	r3, [r4, #3]
   226c4:	2b28      	cmp	r3, #40	; 0x28
   226c6:	d0f9      	beq.n	226bc <sio_open+0x10>
         (neul_lwip_uart_config.uart_tx == PIN_NONE) ||
   226c8:	6863      	ldr	r3, [r4, #4]
   226ca:	2b00      	cmp	r3, #0
   226cc:	d0f6      	beq.n	226bc <sio_open+0x10>
    if (!non_os_is_driver_initialised(DRIVER_INIT_UART))
   226ce:	2008      	movs	r0, #8
   226d0:	f7f5 fd98 	bl	18204 <non_os_is_driver_initialised>
   226d4:	2800      	cmp	r0, #0
   226d6:	d101      	bne.n	226dc <sio_open+0x30>
        uart_init();
   226d8:	f7f2 fffc 	bl	156d4 <uart_init>
    uart_config.baud_rate = neul_lwip_uart_config.baud;
   226dc:	6863      	ldr	r3, [r4, #4]
    uart_config.parity = UART_PARITY_NONE;
   226de:	2700      	movs	r7, #0
    uart_config.baud_rate = neul_lwip_uart_config.baud;
   226e0:	9304      	str	r3, [sp, #16]
    uart_config.data_bits = UART_DATA_BITS_8;
   226e2:	2303      	movs	r3, #3
    uart_config.baud_rate = neul_lwip_uart_config.baud;
   226e4:	ae04      	add	r6, sp, #16
    uart_config.data_bits = UART_DATA_BITS_8;
   226e6:	7133      	strb	r3, [r6, #4]
    uart_config.parity = UART_PARITY_NONE;
   226e8:	7177      	strb	r7, [r6, #5]
    uart_config.stop_bits = UART_STOP_BITS_1;
   226ea:	71b7      	strb	r7, [r6, #6]
    lwip_uart_pins.tx_pin  = neul_lwip_uart_config.uart_tx;
   226ec:	78e3      	ldrb	r3, [r4, #3]
   226ee:	a803      	add	r0, sp, #12
   226f0:	7003      	strb	r3, [r0, #0]
    lwip_uart_pins.rx_pin  = neul_lwip_uart_config.uart_rx;
   226f2:	78a3      	ldrb	r3, [r4, #2]
    uart_buffer_config.rx_buffer_size = NEUL_LWIP_UART_BUFFER_SIZE;
   226f4:	aa02      	add	r2, sp, #8
    lwip_uart_pins.rx_pin  = neul_lwip_uart_config.uart_rx;
   226f6:	7043      	strb	r3, [r0, #1]
    lwip_uart_pins.rts_pin = neul_lwip_uart_config.uart_rts;
   226f8:	7823      	ldrb	r3, [r4, #0]
   226fa:	70c3      	strb	r3, [r0, #3]
    lwip_uart_pins.cts_pin = neul_lwip_uart_config.uart_cts;
   226fc:	7863      	ldrb	r3, [r4, #1]
   226fe:	7083      	strb	r3, [r0, #2]
    uart_buffer_config.rx_buffer_size = NEUL_LWIP_UART_BUFFER_SIZE;
   22700:	2380      	movs	r3, #128	; 0x80
   22702:	009b      	lsls	r3, r3, #2
   22704:	8013      	strh	r3, [r2, #0]
    serial_lwip_uart = uart_claim( &lwip_uart_pins );
   22706:	f7f3 f815 	bl	15734 <uart_claim>
   2270a:	4d0d      	ldr	r5, [pc, #52]	; (22740 <sio_open+0x94>)
    bool uart_opened = uart_open(serial_lwip_uart, &uart_config, &uart_buffer_config, NULL);
   2270c:	003b      	movs	r3, r7
   2270e:	aa02      	add	r2, sp, #8
   22710:	0031      	movs	r1, r6
    serial_lwip_uart = uart_claim( &lwip_uart_pins );
   22712:	7028      	strb	r0, [r5, #0]
    bool uart_opened = uart_open(serial_lwip_uart, &uart_config, &uart_buffer_config, NULL);
   22714:	f7f3 f93c 	bl	15990 <uart_open>
    assert( uart_opened );
   22718:	42b8      	cmp	r0, r7
   2271a:	d103      	bne.n	22724 <sio_open+0x78>
   2271c:	9901      	ldr	r1, [sp, #4]
   2271e:	2016      	movs	r0, #22
   22720:	f7df f9f6 	bl	1b10 <panic>
    uart_enable_software_flow_control( serial_lwip_uart, neul_lwip_uart_config.xonxoff );
   22724:	7a21      	ldrb	r1, [r4, #8]
   22726:	7828      	ldrb	r0, [r5, #0]
   22728:	f7f3 fade 	bl	15ce8 <uart_enable_software_flow_control>
    uart_register_rx_callback(serial_lwip_uart, UART_RX_CONDITION_FULL_OR_SUFFICIENT_DATA_OR_IDLE, (NEUL_LWIP_UART_BUFFER_SIZE >> 2), serial_uart_callback);
   2272c:	7828      	ldrb	r0, [r5, #0]
   2272e:	4b05      	ldr	r3, [pc, #20]	; (22744 <sio_open+0x98>)
   22730:	2280      	movs	r2, #128	; 0x80
   22732:	2107      	movs	r1, #7
   22734:	f7f3 fb68 	bl	15e08 <uart_register_rx_callback>
        return (sio_fd_t)&serial_lwip_uart;
   22738:	0028      	movs	r0, r5
   2273a:	e7c0      	b.n	226be <sio_open+0x12>
   2273c:	0100060c 	.word	0x0100060c
   22740:	01002e00 	.word	0x01002e00
   22744:	00022695 	.word	0x00022695

00022748 <sio_send>:
{
   22748:	b510      	push	{r4, lr}
    uart_write_immediately_char(*(UART_BUS*)fd, (char) c);
   2274a:	780b      	ldrb	r3, [r1, #0]
   2274c:	0001      	movs	r1, r0
   2274e:	0018      	movs	r0, r3
   22750:	f7f3 fdee 	bl	16330 <uart_write_immediately_char>
}  //lint !e818 fd const
   22754:	bd10      	pop	{r4, pc}

00022756 <sio_write>:
{
   22756:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
   22758:	0007      	movs	r7, r0
   2275a:	0015      	movs	r5, r2
   2275c:	000c      	movs	r4, r1
   2275e:	188e      	adds	r6, r1, r2
    for (u32_t i = 0; i < len; i++)
   22760:	42b4      	cmp	r4, r6
   22762:	d101      	bne.n	22768 <sio_write+0x12>
}  //lint !e818 data const
   22764:	0028      	movs	r0, r5
   22766:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
        sio_send(data[i], fd);
   22768:	7820      	ldrb	r0, [r4, #0]
   2276a:	0039      	movs	r1, r7
   2276c:	f7ff ffec 	bl	22748 <sio_send>
   22770:	3401      	adds	r4, #1
   22772:	e7f5      	b.n	22760 <sio_write+0xa>

00022774 <neul_lwip_serial_set_pins>:
{
   22774:	b510      	push	{r4, lr}
    neul_lwip_uart_config.uart_rx = uart_rx;
   22776:	4c03      	ldr	r4, [pc, #12]	; (22784 <neul_lwip_serial_set_pins+0x10>)
   22778:	70a1      	strb	r1, [r4, #2]
    neul_lwip_uart_config.uart_tx = uart_tx;
   2277a:	70e0      	strb	r0, [r4, #3]
    neul_lwip_uart_config.uart_rts = uart_rtx;
   2277c:	7022      	strb	r2, [r4, #0]
    neul_lwip_uart_config.uart_cts = uart_ctx;
   2277e:	7063      	strb	r3, [r4, #1]
}
   22780:	bd10      	pop	{r4, pc}
   22782:	46c0      	nop			; (mov r8, r8)
   22784:	0100060c 	.word	0x0100060c

00022788 <neul_lwip_serial_set_baud>:
    neul_lwip_uart_config.baud = uart_baud;
   22788:	4b01      	ldr	r3, [pc, #4]	; (22790 <neul_lwip_serial_set_baud+0x8>)
   2278a:	6058      	str	r0, [r3, #4]
}
   2278c:	4770      	bx	lr
   2278e:	46c0      	nop			; (mov r8, r8)
   22790:	0100060c 	.word	0x0100060c

00022794 <neul_lwip_serial_enable_software_flow_control>:
    neul_lwip_uart_config.xonxoff = enabled;
   22794:	4b01      	ldr	r3, [pc, #4]	; (2279c <neul_lwip_serial_enable_software_flow_control+0x8>)
   22796:	7218      	strb	r0, [r3, #8]
}
   22798:	4770      	bx	lr
   2279a:	46c0      	nop			; (mov r8, r8)
   2279c:	0100060c 	.word	0x0100060c

000227a0 <neul_lwip_serial_set_rx_callback>:
    serial_rx_callback = callback;
   227a0:	4b01      	ldr	r3, [pc, #4]	; (227a8 <neul_lwip_serial_set_rx_callback+0x8>)
   227a2:	6018      	str	r0, [r3, #0]
}
   227a4:	4770      	bx	lr
   227a6:	46c0      	nop			; (mov r8, r8)
   227a8:	01002e04 	.word	0x01002e04

000227ac <neul_lwip_serial_deinit>:
{
   227ac:	b570      	push	{r4, r5, r6, lr}
    if ((void *)uart_handler != (void *)&serial_lwip_uart)
   227ae:	4c0f      	ldr	r4, [pc, #60]	; (227ec <neul_lwip_serial_deinit+0x40>)
   227b0:	42a0      	cmp	r0, r4
   227b2:	d119      	bne.n	227e8 <neul_lwip_serial_deinit+0x3c>
    while (uart_has_pending_transmissions(serial_lwip_uart))
   227b4:	7820      	ldrb	r0, [r4, #0]
   227b6:	f7f3 faff 	bl	15db8 <uart_has_pending_transmissions>
   227ba:	1e05      	subs	r5, r0, #0
   227bc:	d1fa      	bne.n	227b4 <neul_lwip_serial_deinit+0x8>
    non_os_enter_critical();
   227be:	f7f5 fcf9 	bl	181b4 <non_os_enter_critical>
    uart_unregister_rx_callback(serial_lwip_uart);
   227c2:	7820      	ldrb	r0, [r4, #0]
   227c4:	f7f3 fbe8 	bl	15f98 <uart_unregister_rx_callback>
    uart_register_parity_error_callback(serial_lwip_uart, NULL);
   227c8:	7820      	ldrb	r0, [r4, #0]
   227ca:	0029      	movs	r1, r5
   227cc:	f7f3 fb74 	bl	15eb8 <uart_register_parity_error_callback>
    uart_register_frame_error_callback(serial_lwip_uart, NULL);
   227d0:	0029      	movs	r1, r5
   227d2:	7820      	ldrb	r0, [r4, #0]
   227d4:	f7f3 fba8 	bl	15f28 <uart_register_frame_error_callback>
    uart_close(serial_lwip_uart);
   227d8:	7820      	ldrb	r0, [r4, #0]
   227da:	f7f3 fa3d 	bl	15c58 <uart_close>
    uart_release(serial_lwip_uart);
   227de:	7820      	ldrb	r0, [r4, #0]
   227e0:	f7f3 f87e 	bl	158e0 <uart_release>
    non_os_exit_critical();
   227e4:	f7f5 fcfa 	bl	181dc <non_os_exit_critical>
}  //lint !e818 uart_handler const
   227e8:	bd70      	pop	{r4, r5, r6, pc}
   227ea:	46c0      	nop			; (mov r8, r8)
   227ec:	01002e00 	.word	0x01002e00

000227f0 <sys_thread_new>:
 * @param stacksize stack size in bytes for the new thread (may be ignored by ports)
 * @param prio priority of the new thread (may be ignored by ports)
 */

sys_thread_t sys_thread_new(const char *name, lwip_thread_fn thread, void *arg, int stacksize, int prio)
{
   227f0:	b5f0      	push	{r4, r5, r6, r7, lr}
   227f2:	000d      	movs	r5, r1
   227f4:	0016      	movs	r6, r2
   227f6:	001c      	movs	r4, r3
   227f8:	0007      	movs	r7, r0
   227fa:	b08b      	sub	sp, #44	; 0x2c
    osThreadAttr_t attr;
    osThreadFunc_t func;
    osThreadId_t thread_create_result;

    memset(&attr, 0, sizeof(osThreadAttr_t));
   227fc:	2224      	movs	r2, #36	; 0x24
   227fe:	2100      	movs	r1, #0
   22800:	a801      	add	r0, sp, #4
   22802:	f7dd fd6d 	bl	2e0 <memset>

    //All the rest should be NULL or 0 - at the time of writing.
    attr.name = name;
    attr.stack_size = (uint16) stacksize;
    attr.priority = (osPriority_t) prio;
   22806:	9b10      	ldr	r3, [sp, #64]	; 0x40
    attr.stack_size = (uint16) stacksize;
   22808:	b2a4      	uxth	r4, r4
    func = thread;

    thread_create_result = osThreadNew(func, arg,  &attr);
   2280a:	aa01      	add	r2, sp, #4
   2280c:	0031      	movs	r1, r6
   2280e:	0028      	movs	r0, r5
    attr.name = name;
   22810:	9701      	str	r7, [sp, #4]
    attr.stack_size = (uint16) stacksize;
   22812:	9406      	str	r4, [sp, #24]
    attr.priority = (osPriority_t) prio;
   22814:	9307      	str	r3, [sp, #28]
    thread_create_result = osThreadNew(func, arg,  &attr);
   22816:	f7f1 ffe7 	bl	147e8 <osThreadNew>
    }

    // LWIP_DEBUGF(SYS_DEBUG | LWIP_DBG_TRACE, ("%s(): Created thread 0x%08x '%s'.\n", __FUNCTION__, thread_create_result, name));

    return thread_create_result;
}
   2281a:	b00b      	add	sp, #44	; 0x2c
   2281c:	bdf0      	pop	{r4, r5, r6, r7, pc}
	...

00022820 <sys_timeout_default_handler>:

/** find timeout, call it and mark it as called
 * @param address of timeout
 */
static void sys_timeout_default_handler(void *arg)
{
   22820:	b510      	push	{r4, lr}
    struct sys_timeouts *timeout = (struct sys_timeouts *) arg;
    struct sys_timeouts *timeout_list_entry = timeout_list;
   22822:	4b08      	ldr	r3, [pc, #32]	; (22844 <sys_timeout_default_handler+0x24>)
   22824:	681c      	ldr	r4, [r3, #0]

    while(timeout_list_entry)
   22826:	2c00      	cmp	r4, #0
   22828:	d008      	beq.n	2283c <sys_timeout_default_handler+0x1c>
    {
        // find the first entry that matches the time
        if (timeout == timeout_list_entry)
   2282a:	4284      	cmp	r4, r0
   2282c:	d107      	bne.n	2283e <sys_timeout_default_handler+0x1e>
        {
            // mark it as called - don't call again
            timeout_list_entry->state = TIMEOUT_STATE_IN_PROGRESS;
   2282e:	2301      	movs	r3, #1
            // call it
            (timeout_list_entry->handler)(timeout_list_entry->arg);
   22830:	68e0      	ldr	r0, [r4, #12]
            timeout_list_entry->state = TIMEOUT_STATE_IN_PROGRESS;
   22832:	7423      	strb	r3, [r4, #16]
            (timeout_list_entry->handler)(timeout_list_entry->arg);
   22834:	68a3      	ldr	r3, [r4, #8]
   22836:	4798      	blx	r3
            // mark it as done - can now be removed
            timeout_list_entry->state = TIMEOUT_STATE_COMPLETE;
   22838:	2302      	movs	r3, #2
   2283a:	7423      	strb	r3, [r4, #16]
        else
        {
            timeout_list_entry = timeout_list_entry->next;
        }
    }
}
   2283c:	bd10      	pop	{r4, pc}
            timeout_list_entry = timeout_list_entry->next;
   2283e:	6824      	ldr	r4, [r4, #0]
   22840:	e7f1      	b.n	22826 <sys_timeout_default_handler+0x6>
   22842:	46c0      	nop			; (mov r8, r8)
   22844:	01002e08 	.word	0x01002e08

00022848 <sys_timeout_init_mutex>:
{
   22848:	b510      	push	{r4, lr}
    if (timeout_mutex == NULL)
   2284a:	4c06      	ldr	r4, [pc, #24]	; (22864 <sys_timeout_init_mutex+0x1c>)
   2284c:	6820      	ldr	r0, [r4, #0]
   2284e:	2800      	cmp	r0, #0
   22850:	d107      	bne.n	22862 <sys_timeout_init_mutex+0x1a>
        if ((timeout_mutex = osMutexNew(NULL)) == NULL)
   22852:	f7f2 f891 	bl	14978 <osMutexNew>
   22856:	1e01      	subs	r1, r0, #0
   22858:	6020      	str	r0, [r4, #0]
   2285a:	d102      	bne.n	22862 <sys_timeout_init_mutex+0x1a>
            panic(PANIC_LWIP_SUPPORT, PANIC_ID_LWIP_SUPPORT_UNABLE_TO_CREATE_SEMAPHORE);
   2285c:	2022      	movs	r0, #34	; 0x22
   2285e:	f7df f957 	bl	1b10 <panic>
}
   22862:	bd10      	pop	{r4, pc}
   22864:	01002e0c 	.word	0x01002e0c

00022868 <sys_now>:
{
   22868:	b510      	push	{r4, lr}
    current_timer = osKernelGetTick2ms();
   2286a:	f7f1 ffb7 	bl	147dc <osKernelGetTick2ms>
}
   2286e:	bd10      	pop	{r4, pc}

00022870 <sys_jiffies>:
{
   22870:	b510      	push	{r4, lr}
    return sys_now();
   22872:	f7ff fff9 	bl	22868 <sys_now>
}
   22876:	bd10      	pop	{r4, pc}

00022878 <sys_timeout>:
 * @param msecs time in milliseconds after that the timer should expire
 * @param handler callback function to call when msecs have elapsed
 * @param arg argument to pass to the callback function
 */
void sys_timeout(u32_t msecs, sys_timeout_handler handler, void *arg)
{
   22878:	4673      	mov	r3, lr
   2287a:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
   2287c:	0007      	movs	r7, r0
    struct sys_timeouts *timeout;

    timeout = (struct sys_timeouts *) irmalloc(sizeof(struct sys_timeouts));
   2287e:	2018      	movs	r0, #24
   22880:	9301      	str	r3, [sp, #4]
{
   22882:	000d      	movs	r5, r1
   22884:	0016      	movs	r6, r2
    timeout = (struct sys_timeouts *) irmalloc(sizeof(struct sys_timeouts));
   22886:	f7f0 f8bb 	bl	12a00 <irmalloc>
   2288a:	1e04      	subs	r4, r0, #0
    if (timeout == NULL)
   2288c:	d04a      	beq.n	22924 <sys_timeout+0xac>
    {
        return;
    }

    timeout->handler = handler;
   2288e:	6085      	str	r5, [r0, #8]
    timeout->arg = arg;
    timeout->state = TIMEOUT_STATE_QUEUED;
   22890:	2500      	movs	r5, #0
    timeout->arg = arg;
   22892:	60c6      	str	r6, [r0, #12]
    timeout->state = TIMEOUT_STATE_QUEUED;
   22894:	7405      	strb	r5, [r0, #16]
    timeout->time = sys_now() + msecs;
   22896:	f7ff ffe7 	bl	22868 <sys_now>
   2289a:	19c0      	adds	r0, r0, r7
   2289c:	6160      	str	r0, [r4, #20]
    timeout->sys_timer = osTimerNew((osTimerFunc_t)sys_timeout_default_handler, osTimerOnce, (void *)timeout, NULL);
   2289e:	002b      	movs	r3, r5
   228a0:	0022      	movs	r2, r4
   228a2:	0029      	movs	r1, r5
   228a4:	4822      	ldr	r0, [pc, #136]	; (22930 <sys_timeout+0xb8>)
   228a6:	f7f1 ffe7 	bl	14878 <osTimerNew>
    if (osTimerStart(timeout->sys_timer, (uint32_t)osMs2Tick((uint64_t)msecs)) != osOK)
   228aa:	0029      	movs	r1, r5
    timeout->sys_timer = osTimerNew((osTimerFunc_t)sys_timeout_default_handler, osTimerOnce, (void *)timeout, NULL);
   228ac:	0006      	movs	r6, r0
   228ae:	6060      	str	r0, [r4, #4]
    if (osTimerStart(timeout->sys_timer, (uint32_t)osMs2Tick((uint64_t)msecs)) != osOK)
   228b0:	0038      	movs	r0, r7
   228b2:	f7f1 ff97 	bl	147e4 <osMs2Tick>
   228b6:	0001      	movs	r1, r0
   228b8:	0030      	movs	r0, r6
   228ba:	f7f2 f805 	bl	148c8 <osTimerStart>
   228be:	42a8      	cmp	r0, r5
   228c0:	d003      	beq.n	228ca <sys_timeout+0x52>
    {
        assert(false);
   228c2:	9901      	ldr	r1, [sp, #4]
   228c4:	2016      	movs	r0, #22
   228c6:	f7df f923 	bl	1b10 <panic>
    }

    sys_timeout_init_mutex();
   228ca:	f7ff ffbd 	bl	22848 <sys_timeout_init_mutex>

    if (osMutexAcquire(timeout_mutex, 0) != osOK)
   228ce:	4f19      	ldr	r7, [pc, #100]	; (22934 <sys_timeout+0xbc>)
   228d0:	2100      	movs	r1, #0
   228d2:	6838      	ldr	r0, [r7, #0]
   228d4:	f7f2 f866 	bl	149a4 <osMutexAcquire>
   228d8:	2800      	cmp	r0, #0
   228da:	d003      	beq.n	228e4 <sys_timeout+0x6c>
    {
        panic(PANIC_LWIP_SUPPORT, PANIC_ID_LWIP_SUPPORT_UNABLE_TO_TAKE_SEMAPHORE);
   228dc:	2101      	movs	r1, #1
   228de:	2022      	movs	r0, #34	; 0x22
   228e0:	f7df f916 	bl	1b10 <panic>
    struct sys_timeouts *previous = NULL;
   228e4:	2500      	movs	r5, #0
    }
    timeout->next = timeout_list;
   228e6:	4e14      	ldr	r6, [pc, #80]	; (22938 <sys_timeout+0xc0>)
   228e8:	6833      	ldr	r3, [r6, #0]
    timeout_list = timeout;
   228ea:	6034      	str	r4, [r6, #0]
    timeout->next = timeout_list;
   228ec:	6023      	str	r3, [r4, #0]
        next = current->next;
   228ee:	6823      	ldr	r3, [r4, #0]
   228f0:	9301      	str	r3, [sp, #4]
        if (current->state == TIMEOUT_STATE_COMPLETE) //We need to remove this from the list
   228f2:	7c23      	ldrb	r3, [r4, #16]
   228f4:	2b02      	cmp	r3, #2
   228f6:	d118      	bne.n	2292a <sys_timeout+0xb2>
            (void) osTimerDelete (current->sys_timer);
   228f8:	6860      	ldr	r0, [r4, #4]
   228fa:	f7f2 f821 	bl	14940 <osTimerDelete>
            irfree(current);
   228fe:	0020      	movs	r0, r4
   22900:	f7f0 f89a 	bl	12a38 <irfree>
                previous->next = next;
   22904:	9b01      	ldr	r3, [sp, #4]
            if (previous)
   22906:	2d00      	cmp	r5, #0
   22908:	d00d      	beq.n	22926 <sys_timeout+0xae>
                previous->next = next;
   2290a:	602b      	str	r3, [r5, #0]
   2290c:	9c01      	ldr	r4, [sp, #4]
    while (current)
   2290e:	2c00      	cmp	r4, #0
   22910:	d1ed      	bne.n	228ee <sys_timeout+0x76>
    systimeout_cleanup();
    if ( osMutexRelease(timeout_mutex) != osOK)
   22912:	6838      	ldr	r0, [r7, #0]
   22914:	f7f2 f86a 	bl	149ec <osMutexRelease>
   22918:	2800      	cmp	r0, #0
   2291a:	d003      	beq.n	22924 <sys_timeout+0xac>
    {
        panic(PANIC_LWIP_SUPPORT, PANIC_ID_LWIP_SUPPORT_UNABLE_TO_GIVE_SEMAPHORE);
   2291c:	2102      	movs	r1, #2
   2291e:	2022      	movs	r0, #34	; 0x22
   22920:	f7df f8f6 	bl	1b10 <panic>
    }
}
   22924:	bdf7      	pop	{r0, r1, r2, r4, r5, r6, r7, pc}
                timeout_list = next;
   22926:	6033      	str	r3, [r6, #0]
   22928:	e7f0      	b.n	2290c <sys_timeout+0x94>
        if (current->state == TIMEOUT_STATE_COMPLETE) //We need to remove this from the list
   2292a:	0025      	movs	r5, r4
   2292c:	e7ee      	b.n	2290c <sys_timeout+0x94>
   2292e:	46c0      	nop			; (mov r8, r8)
   22930:	00022821 	.word	0x00022821
   22934:	01002e0c 	.word	0x01002e0c
   22938:	01002e08 	.word	0x01002e08

0002293c <sys_untimeout>:
 *
 * @param handler callback function that would be called by the timeout
 * @param arg callback argument that would be passed to handler
*/
void sys_untimeout(sys_timeout_handler handler, const void *arg)
{
   2293c:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
   2293e:	0006      	movs	r6, r0
   22940:	000f      	movs	r7, r1
    struct sys_timeouts *timeout_list_entry;

    struct sys_timeouts *timeout_list_candidate_entry = NULL;

    sys_timeout_init_mutex();
   22942:	f7ff ff81 	bl	22848 <sys_timeout_init_mutex>

    if (osMutexAcquire(timeout_mutex, 0) != osOK)
   22946:	4d1a      	ldr	r5, [pc, #104]	; (229b0 <sys_untimeout+0x74>)
   22948:	2100      	movs	r1, #0
   2294a:	6828      	ldr	r0, [r5, #0]
   2294c:	f7f2 f82a 	bl	149a4 <osMutexAcquire>
   22950:	2800      	cmp	r0, #0
   22952:	d003      	beq.n	2295c <sys_untimeout+0x20>
    {
        panic(PANIC_LWIP_SUPPORT, PANIC_ID_LWIP_SUPPORT_UNABLE_TO_TAKE_SEMAPHORE);
   22954:	2101      	movs	r1, #1
   22956:	2022      	movs	r0, #34	; 0x22
   22958:	f7df f8da 	bl	1b10 <panic>
    struct sys_timeouts *timeout_list_candidate_entry = NULL;
   2295c:	2400      	movs	r4, #0
    }

    timeout_list_entry = timeout_list;
   2295e:	4b15      	ldr	r3, [pc, #84]	; (229b4 <sys_untimeout+0x78>)
   22960:	681b      	ldr	r3, [r3, #0]
    //protect if sys_timeout can be called from a timeout
    while(timeout_list_entry)
   22962:	2b00      	cmp	r3, #0
   22964:	d110      	bne.n	22988 <sys_untimeout+0x4c>
                timeout_list_candidate_entry = timeout_list_entry;
            }
        }
        timeout_list_entry = timeout_list_entry->next;
    }
    if (timeout_list_candidate_entry != NULL)
   22966:	2c00      	cmp	r4, #0
   22968:	d004      	beq.n	22974 <sys_untimeout+0x38>
    {
        // stop timer
        (void)osTimerStop(timeout_list_candidate_entry->sys_timer);
   2296a:	6860      	ldr	r0, [r4, #4]
   2296c:	f7f1 ffcc 	bl	14908 <osTimerStop>
        // mark entry
        timeout_list_candidate_entry->state = TIMEOUT_STATE_COMPLETE;
   22970:	2302      	movs	r3, #2
   22972:	7423      	strb	r3, [r4, #16]
    }
    if ( osMutexRelease(timeout_mutex) != osOK)
   22974:	6828      	ldr	r0, [r5, #0]
   22976:	f7f2 f839 	bl	149ec <osMutexRelease>
   2297a:	2800      	cmp	r0, #0
   2297c:	d003      	beq.n	22986 <sys_untimeout+0x4a>
    {
        panic(PANIC_LWIP_SUPPORT, PANIC_ID_LWIP_SUPPORT_UNABLE_TO_GIVE_SEMAPHORE);
   2297e:	2102      	movs	r1, #2
   22980:	2022      	movs	r0, #34	; 0x22
   22982:	f7df f8c5 	bl	1b10 <panic>
    }

}
   22986:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
        if ((handler == timeout_list_entry->handler) && (arg == timeout_list_entry->arg) && (timeout_list_entry->state == TIMEOUT_STATE_QUEUED))
   22988:	689a      	ldr	r2, [r3, #8]
   2298a:	42b2      	cmp	r2, r6
   2298c:	d10c      	bne.n	229a8 <sys_untimeout+0x6c>
   2298e:	68da      	ldr	r2, [r3, #12]
   22990:	42ba      	cmp	r2, r7
   22992:	d109      	bne.n	229a8 <sys_untimeout+0x6c>
   22994:	7c1a      	ldrb	r2, [r3, #16]
   22996:	2a00      	cmp	r2, #0
   22998:	d106      	bne.n	229a8 <sys_untimeout+0x6c>
            if ((timeout_list_candidate_entry == NULL) ||
   2299a:	2c00      	cmp	r4, #0
   2299c:	d006      	beq.n	229ac <sys_untimeout+0x70>
                (timeout_list_entry->time - timeout_list_candidate_entry->time > TIME_CHECK))
   2299e:	695a      	ldr	r2, [r3, #20]
   229a0:	6961      	ldr	r1, [r4, #20]
   229a2:	1a52      	subs	r2, r2, r1
            if ((timeout_list_candidate_entry == NULL) ||
   229a4:	2a02      	cmp	r2, #2
   229a6:	d801      	bhi.n	229ac <sys_untimeout+0x70>
        timeout_list_entry = timeout_list_entry->next;
   229a8:	681b      	ldr	r3, [r3, #0]
   229aa:	e7da      	b.n	22962 <sys_untimeout+0x26>
   229ac:	001c      	movs	r4, r3
   229ae:	e7fb      	b.n	229a8 <sys_untimeout+0x6c>
   229b0:	01002e0c 	.word	0x01002e0c
   229b4:	01002e08 	.word	0x01002e08
   229b8:	00000960 	.word	0x00000960
   229bc:	000012c0 	.word	0x000012c0
   229c0:	00002580 	.word	0x00002580
   229c4:	0000e100 	.word	0x0000e100
   229c8:	0001c200 	.word	0x0001c200
   229cc:	00038400 	.word	0x00038400
   229d0:	00070800 	.word	0x00070800
   229d4:	000e1000 	.word	0x000e1000
   229d8:	00010000 	.word	0x00010000
   229dc:	00000100 	.word	0x00000100
   229e0:	03000002 	.word	0x03000002
   229e4:	00030000 	.word	0x00030000
   229e8:	00000400 	.word	0x00000400
   229ec:	1e1f1c1f 	.word	0x1e1f1c1f
   229f0:	1f1f1e1f 	.word	0x1f1f1e1f
   229f4:	1f1e1f1e 	.word	0x1f1e1f1e
   229f8:	000251fe 	.word	0x000251fe
   229fc:	00000000 	.word	0x00000000
   22a00:	00024a07 	.word	0x00024a07
   22a04:	00024a1a 	.word	0x00024a1a
   22a08:	00024a2e 	.word	0x00024a2e
   22a0c:	00024a3b 	.word	0x00024a3b
   22a10:	00000000 	.word	0x00000000
   22a14:	00024a4d 	.word	0x00024a4d
   22a18:	00024a60 	.word	0x00024a60
   22a1c:	00024998 	.word	0x00024998
   22a20:	0002499f 	.word	0x0002499f
   22a24:	000249a6 	.word	0x000249a6
   22a28:	000249ad 	.word	0x000249ad
   22a2c:	00024bc7 	.word	0x00024bc7
   22a30:	00024988 	.word	0x00024988
   22a34:	00024990 	.word	0x00024990
   22a38:	00024bcd 	.word	0x00024bcd
   22a3c:	00024baa 	.word	0x00024baa
   22a40:	00024baf 	.word	0x00024baf
   22a44:	00024bb7 	.word	0x00024bb7
   22a48:	00024bbe 	.word	0x00024bbe
   22a4c:	00024a81 	.word	0x00024a81
   22a50:	00024ab6 	.word	0x00024ab6
   22a54:	00024ab8 	.word	0x00024ab8
   22a58:	00024b17 	.word	0x00024b17
   22a5c:	00024ab6 	.word	0x00024ab6
   22a60:	00024ab6 	.word	0x00024ab6
   22a64:	00024a72 	.word	0x00024a72
   22a68:	00024a72 	.word	0x00024a72
   22a6c:	000249ca 	.word	0x000249ca
   22a70:	000249d5 	.word	0x000249d5
   22a74:	000249e0 	.word	0x000249e0
   22a78:	000249ee 	.word	0x000249ee
   22a7c:	000249f9 	.word	0x000249f9
   22a80:	00002580 	.word	0x00002580
   22a84:	00000102 	.word	0x00000102
   22a88:	00000000 	.word	0x00000000
   22a8c:	000249b4 	.word	0x000249b4
   22a90:	000249bb 	.word	0x000249bb
   22a94:	000249c2 	.word	0x000249c2
   22a98:	00ffffff 	.word	0x00ffffff
   22a9c:	ffffffff 	.word	0xffffffff

00022aa0 <APP_MAIN_QUEUE_TEMP>:
   22aa0:	00000001 00707061 00637072 00676f6c     ....app.rpc.log.
   22ab0:	755f7461 00747261                       at_uart.

00022ab8 <application_incomming_command_table>:
   22ab8:	00000000                                ....

00022abc <protocol_incomming_command_table>:
   22abc:	000024a5 000024d7 00002535 00002561     .$...$..5%..a%..
   22acc:	0000258d 000025b9 00002821 00002869     .%...%..!(..i(..
   22adc:	000025e5 000028b1 00002923 000029a5     .%...(..#)...)..
   22aec:	000029f7 00002611 00002a65 00002ac5     .)...&..e*...*..
   22afc:	00002b25 00002b89 00002cbf 00002cf3     %+...+...,...,..
   22b0c:	00002d45 00002db5 00002eb1 00002cd9     E-...-.......,..
   22b1c:	00002f15 000026c1 00002e09 000026ed     ./...&.......&..
   22b2c:	00002fa7 00002719 00003009 00002745     ./...'...0..E'..
   22b3c:	00003055 00002771 000027f5 00003097     U0..q'...'...0..
   22b4c:	00002e5d                                ]...

00022b50 <security_incomming_command_table>:
   22b50:	000024a5 0000263d 00002669 00002bb5     .$..=&..i&...+..
   22b60:	00002bfb 00002c4d 00002c8f 00002695     .+..M,...,...&..
   22b70:	00002f59 0000279d 000027c9 47424425     Y/...'...'..%DBG
   22b80:	4553003a 49525543 525f5954 54455345     :.SECURITY_RESET
   22b90:	4b4e555f 4e574f4e 43455300 54495255     _UNKNOWN.SECURIT
   22ba0:	59535f59 53455253 45525445 45530051     Y_SYSRESETREQ.SE
   22bb0:	49525543 575f5954 48435441 00474f44     CURITY_WATCHDOG.
   22bc0:	55434553 59544952 4c45535f 45530046     SECURITY_SELF.SE
   22bd0:	49525543 415f5954 4f42544c 5300544f     CURITY_ALTBOOT.S
   22be0:	52554345 5f595449 5f474552 45530030     ECURITY_REG_0.SE
   22bf0:	49525543 525f5954 335f4745 43455300     CURITY_REG_3.SEC
   22c00:	54495255 54535f59 41444e41 435f4452     URITY_STANDARD_C
   22c10:	5f504948 43544157 474f4448 43455300     HIP_WATCHDOG.SEC
   22c20:	54495255 50555f59 45544144 48435f52     URITY_UPDATER_CH
   22c30:	575f5049 48435441 00474f44 43554553     IP_WATCHDOG.SEUC
   22c40:	59544952 4143535f 4e455f4e 5f524554     RITY_SCAN_ENTER_
   22c50:	54495845 43455300 54495255 4d505f59     EXIT.SECURITY_PM
   22c60:	4f505f55 5f524557 525f4e4f 54455345     U_POWER_ON_RESET
   22c70:	43455300 54495255 45525f59 5f544553     .SECURITY_RESET_
   22c80:	004e4950 55434553 59544952 4745525f     PIN.SECURITY_REG
   22c90:	534e4f49 4450555f 44455441 43455300     IONS_UPDATED.SEC
   22ca0:	54495255 4f465f59 555f4154 41524750     URITY_FOTA_UPGRA
   22cb0:	50004544 4f544f52 5f4c4f43 52535953     DE.PROTOCOL_SYSR
   22cc0:	54455345 00514552 544f5250 4c4f434f     ESETREQ.PROTOCOL
   22cd0:	5441575f 4f444843 52500047 434f544f     _WATCHDOG.PROTOC
   22ce0:	4d5f4c4f 54494e4f 525f524f 4f4f4245     OL_MONITOR_REBOO
   22cf0:	45525f54 52500051 434f544f 525f4c4f     T_REQ.PROTOCOL_R
   22d00:	545f4350 4f454d49 41005455 494c5050     PC_TIMEOUT.APPLI
   22d10:	49544143 535f4e4f 45525359 52544553     CATION_SYSRESETR
   22d20:	41005145 494c5050 49544143 575f4e4f     EQ.APPLICATION_W
   22d30:	48435441 00474f44 4c505041 54414349     ATCHDOG.APPLICAT
   22d40:	5f4e4f49 41005441 494c5050 49544143     ION_AT.APPLICATI
   22d50:	525f4e4f 545f4350 4f454d49 50005455     ON_RPC_TIMEOUT.P
   22d60:	4f544f52 5f4c4f43 49534d49 4450555f     ROTOCOL_IMSI_UPD
   22d70:	00455441 45520a0d 544f4f42 5541435f     ATE...REBOOT_CAU
   22d80:	005f4553 654e0a0d 0d206c75 0d4b4f0a     SE_...Neul ..OK.
   22d90:	6142000a 72746b63 20656361 74706544     ..Backtrace Dept
   22da0:	305b3a68 38302578 44205d78 5b617461     h:[0x%08x] Data[
   22db0:	30257830 302c7838 38302578 78302c78     0x%08x,0x%08x,0x
   22dc0:	78383025 2578302c 2c783830 30257830     %08x,0x%08x,0x%0
   22dd0:	302c7838 38302578 78302c78 78383025     8x,0x%08x,0x%08x
   22de0:	2578302c 2c783830 30257830 302c7838     ,0x%08x,0x%08x,0
   22df0:	38302578 41005d78 54524f42 00474e49     x%08x].ABORTING.
   22e00:	43204f4e 414d4d4f 5420444e 4241204f     NO COMMAND TO AB
   22e10:	0054524f 53554e2b 203a4d49 204e4950     ORT.+NUSIM: PIN 
   22e20:	55514552 44455249 554e2b00 3a4d4953     REQUIRED.+NUSIM:
   22e30:	4b555020 51455220 45524955 4e2b0044      PUK REQUIRED.+N
   22e40:	4d495355 5550203a 4c42204b 454b434f     USIM: PUK BLOCKE
   22e50:	73250044 2c64253a 002c6425 5452432b     D.%s:%d,%d,.+CRT
   22e60:	00504344 4e524e2b 004d4450 2b006925     DCP.+NRNPDM.%i.+
   22e70:	41504743 3a524444 47432b00 44444150     CGPADDR:.+CGPADD
   22e80:	00283a52 002c6925 474d432b 25203a43     R:(.%i,.+CMGC: %
   22e90:	432b0064 3a53474d 00642520 454d432b     d.+CMGS: %d.+CME
   22ea0:	52524520 203a524f 2b006425 20534d43      ERROR: %d.+CMS 
   22eb0:	4f525245 25203a52 00000064              ERROR: %d...

00022ebc <g_ceer_emm_cause_str>:
   22ebc:	00000002 0002309c 00000003 000230b0     .....0.......0..
   22ecc:	00000005 000230bb 00000006 000230cd     .....0.......0..
   22edc:	00000007 000230e4 00000008 000230d8     .....0.......0..
   22eec:	00000009 000230fd 0000000a 0002311a     .....0.......1..
   22efc:	0000000b 0002312e 0000000c 0002313f     .....1......?1..
   22f0c:	0000000d 0002314f 0000000e 0002316a     ....O1......j1..
   22f1c:	0000000f 0002318b 00000010 000231a4     .....1.......1..
   22f2c:	00000011 000232ff 00000012 000231c3     .....2.......1..
   22f3c:	00000013 000231db 00000014 000231e7     .....1.......1..
   22f4c:	00000015 000231f3 00000016 00023200     .....1.......2..
   22f5c:	00000017 0002320b 00000018 0002322d     .....2......-2..
   22f6c:	00000019 00023253 0000001a 0002326f     ....S2......o2..
   22f7c:	00000023 00023289 00000027 000232b2     #....2..'....2..
   22f8c:	00000028 000232d8 0000002a 000232f8     (....2..*....2..
   22f9c:	0000005f 0002330f 00000060 0002332a     _....3..`...*3..
   22fac:	00000061 00023348 00000062 00023371     a...H3..b...q3..
   22fbc:	00000063 0002339d 00000064 000233c5     c....3..d....3..
   22fcc:	00000065 000233da 00000066 00023401     e....3..f....4..
   22fdc:	0000006f 0002341c 000000ff 00023437     o....4......74..

00022fec <g_cmee_errno_table>:
   22fec:	0003000e 00040006 000a0028 000b0015     ........(.......
   22ffc:	000c002a 00100029 00170004 001e000b     *...)...........
   2300c:	00320002 00320003 00320001 00330005     ..2...2...2...3.
   2301c:	0034001a 009f0007 00b5002d 02000008     ..4.....-.......
   2302c:	0201000a 0202000d 0203000f 02040010     ................
   2303c:	02050011 02060012 02080017 02090018     ................
   2304c:	020a0019 020b001b 020c001c 020d001d     ................
   2305c:	020e001e 020f001f 02100020 02110013     ........ .......
   2306c:	02120025 0213002b 0214002c 0215002e     %...+...,.......
   2307c:	0216002f 02170030 02180031 02190032     /...0...1...2...

0002308c <g_cms_errno_table>:
   2308c:	012e0021 012f0022 01400023 01540027     !..."./.#.@.'.T.
   2309c:	49534d49 4b4e555f 4e574f4e 5f4e495f     IMSI_UNKNOWN_IN_
   230ac:	00535348 454c4c49 5f4c4147 49004555     HSS.ILLEGAL_UE.I
   230bc:	5f49454d 5f544f4e 45434341 44455450     MEI_NOT_ACCEPTED
   230cc:	4c4c4900 4c414745 00454d5f 5f535045     .ILLEGAL_ME.EPS_
   230dc:	5f444e41 5f4e4f4e 5f535045 56524553     AND_NON_EPS_SERV
   230ec:	53454349 544f4e5f 4c4c415f 4445574f     ICES_NOT_ALLOWED
   230fc:	5f455500 4e5f4449 445f544f 56495245     .UE_ID_NOT_DERIV
   2310c:	425f4445 454e5f59 524f5754 4d49004b     ED_BY_NETWORK.IM
   2311c:	43494c50 594c5449 5445445f 45484341     PLICITLY_DETACHE
   2312c:	4c500044 4e5f4e4d 415f544f 574f4c4c     D.PLMN_NOT_ALLOW
   2313c:	54004445 4e5f4941 415f544f 574f4c4c     ED.TAI_NOT_ALLOW
   2314c:	52004445 494d414f 4e5f474e 415f544f     ED.ROAMING_NOT_A
   2315c:	574f4c4c 495f4445 41545f4e 50450049     LLOWED_IN_TAI.EP
   2316c:	45535f53 43495652 4e5f5345 415f544f     S_SERVICES_NOT_A
   2317c:	574f4c4c 495f4445 4c505f4e 4e004e4d     LLOWED_IN_PLMN.N
   2318c:	55535f4f 42415449 435f454c 534c4c45     O_SUITABLE_CELLS
   2319c:	5f4e495f 00494154 5f43534d 504d4554     _IN_TAI.MSC_TEMP
   231ac:	5241524f 5f594c49 5f544f4e 45434341     ORARILY_NOT_ACCE
   231bc:	42415450 4300454c 4f445f53 4e49414d     PTABLE.CS_DOMAIN
   231cc:	544f4e5f 4156415f 42414c49 4500454c     _NOT_AVAILABLE.E
   231dc:	465f4d53 554c4941 4d004552 465f4341     SM_FAILURE.MAC_F
   231ec:	554c4941 53004552 5f434e59 4c494146     AILURE.SYNC_FAIL
   231fc:	00455255 474e4f43 49545345 55004e4f     URE.CONGESTION.U
   2320c:	45535f45 49525543 435f5954 42415041     E_SECURITY_CAPAB
   2321c:	54494c49 5f534549 4d53494d 48435441     ILITIES_MISMATCH
   2322c:	5f455500 55434553 59544952 444f4d5f     .UE_SECURITY_MOD
   2323c:	45525f45 5443454a 555f4445 4550534e     E_REJECTED_UNSPE
   2324c:	49464943 4e004445 415f544f 4f485455     CIFIED.NOT_AUTHO
   2325c:	45534952 4f465f44 48545f52 435f5349     RISED_FOR_THIS_C
   2326c:	4e004753 455f4e4f 415f5350 5f485455     SG.NON_EPS_AUTH_
   2327c:	43414e55 54504543 454c4241 51455200     UNACCEPTABLE.REQ
   2328c:	54534555 535f4445 49565245 4e5f4543     UESTED_SERVICE_N
   2329c:	415f544f 4f485455 45534952 4e495f44     OT_AUTHORISED_IN
   232ac:	4d4c505f 5343004e 5245535f 45434956     _PLMN.CS_SERVICE
   232bc:	45545f53 524f504d 4c495241 4f4e5f59     S_TEMPORARILY_NO
   232cc:	56415f54 414c4941 00454c42 455f4f4e     T_AVAILABLE.NO_E
   232dc:	425f5350 45524145 4f435f52 5845544e     PS_BEARER_CONTEX
   232ec:	43415f54 41564954 00444554 45564553     T_ACTIVATED.SEVE
   232fc:	4e5f4552 4f575445 465f4b52 554c4941     RE_NETWORK_FAILU
   2330c:	53004552 4e414d45 41434954 5f594c4c     RE.SEMANTICALLY_
   2331c:	4f434e49 43455252 534d5f54 4e490047     INCORRECT_MSG.IN
   2332c:	494c4156 414d5f44 5441444e 5f59524f     VALID_MANDATORY_
   2333c:	4f464e49 54414d52 004e4f49 5f47534d     INFORMATION.MSG_
   2334c:	45505954 4e4f4e5f 4958455f 4e455453     TYPE_NON_EXISTEN
   2335c:	524f5f54 544f4e5f 504d495f 454d454c     T_OR_NOT_IMPLEME
   2336c:	4445544e 47534d00 5059545f 4f4e5f45     NTED.MSG_TYPE_NO
   2337c:	4f435f54 5441504d 454c4249 5449575f     T_COMPATIBLE_WIT
   2338c:	52505f48 434f544f 535f4c4f 45544154     H_PROTOCOL_STATE
   2339c:	5f454900 45505954 4e4f4e5f 4958455f     .IE_TYPE_NON_EXI
   233ac:	4e455453 524f5f54 544f4e5f 504d495f     STENT_OR_NOT_IMP
   233bc:	454d454c 4445544e 4e4f4300 49544944     LEMENTED.CONDITI
   233cc:	4c414e4f 5f45495f 4f525245 534d0052     ONAL_IE_ERROR.MS
   233dc:	4f4e5f47 4f435f54 5441504d 454c4249     G_NOT_COMPATIBLE
   233ec:	5449575f 52505f48 434f544f 535f4c4f     _WITH_PROTOCOL_S
   233fc:	45544154 534e5500 49434550 44454946     TATE.UNSPECIFIED
   2340c:	4f52505f 4f434f54 52455f4c 00524f52     _PROTOCOL_ERROR.
   2341c:	544f5250 4c4f434f 5252455f 555f524f     PROTOCOL_ERROR_U
   2342c:	4550534e 49464943 45004445 45204d4d     NSPECIFIED.EMM E
   2343c:	524f5252 45203a20 435f4d4d 45535541     RROR : EMM_CAUSE
   2344c:	4b4e555f 4e574f4e 5f544100 54524155     _UNKNOWN.AT_UART
   2345c:	4e4f435f 5f474946 524f5453 41465f45     _CONFIG_STORE_FA
   2346c:	                                         IL.

0002346f <CSWTCH.152>:
   2346f:	01060600 06060606 060b0507 1c0e0406     ................
   2347f:	06100f06 18060606 09171112 0606061a     ................
   2348f:	06061f06 06272006 302f2e06              ..... '.../0

0002349b <CSWTCH.154>:
   2349b:	21212100 22222223 22222222 22222122     .!!!#""""""""!""
   234ab:	22222222 22222222 22222222 22222222     """"""""""""""""
   234bb:	22222222 27222224 30007830               """"$""'0x.0X.

000234c9 <CSWTCH.755>:
   234c9:	06002800 06292b15 2b29282c 50414743     .(...+).,()+CGAP
   234d9:	3a43524e 2c642500 252c6425 25002c64     NRC:.%d,%d,%d,.%
   234e9:	64252c64 2c64252c 00646c25 732a2e25     d,%d,%d,%ld.%.*s
   234f9:	4e2b002e 45575450 53585244 7325003a     ..+NPTWEDRXS:.%s
   23509:	222c6425 2c227325 22732522 45432b00     %d,"%s","%s".+CE
   23519:	53585244 7325003a 222c6425 00227325     DRXS:.%s%d,"%s".

00023529 <at_cgeqos_support_qci_value>:
   23529:	07060500 254f0908 30283a73 2c29312d     ......O%s:(0-1),
   23539:	252d3028 282c2964 00296425 283a7325     (0-%d),(%d).%s:(
   23549:	64252d30 25282c29 282c2964 252c6425     0-%d),(%d),(%d,%
   23559:	64252c64 25282c29 64252c64 31282c29     d,%d),(%d,%d),(1
   23569:	3535322d 432b0029 3a53504f 64252800     -255).+COPS:.(%d
   23579:	222c2c2c 29227325 4e2b002c 444f5051     ,,,"%s"),.+NQPOD
   23589:	003a5043 50514e2b 3a44504e 514e2b00     CP:.+NQPNPD:.+NQ
   23599:	3a534f53 43432b00 4f544f49 003a5450     SOS:.+CCIOTOPT:.
   235a9:	4943432b 504f544f 30283a54 332c312c     +CCIOTOPT:(0,1,3
   235b9:	31282c29 2c29332c 322c3128 432b0029     ),(1,3),(1,2).+C
   235c9:	3a4b4c43 64323025 432b002f 58524445     CLK:%02d/.+CEDRX
   235d9:	3a504452 222c6425 2c227325 22732522     RDP:%d,"%s","%s"
   235e9:	7325222c 432b0022 58524445 3a504452     ,"%s".+CEDRXRDP:
   235f9:	2b006425 52444543 283a5358 2c312c30     %d.+CEDRXS:(0,1,
   23609:	29332c32 2935282c 3022282c 22303030     2,3),(5),("0000"
   23619:	3131222d 29223131 45432b00 253a5245     -"1111").+CEER:%
   23629:	432b0073 3a524545 5f4d4d45 53554143     s.+CEER:EMM_CAUS
   23639:	73255f45 45432b00 3a474552 312c3028     E_%s.+CEREG:(0,1
   23649:	332c322c 352c342c 432b0029 3a4e5546     ,2,3,4,5).+CFUN:
   23659:	2b006425 4e554643 2c30283a 282c2931     %d.+CFUN:(0,1),(
   23669:	29312c30 47432b00 3a544341 252c6425     0,1).+CGACT:%d,%
   23679:	432b0064 54434147 2c30283a 2b002931     d.+CGACT:(0,1).+
   23689:	54414743 64253a54 47432b00 3a545441     CGATT:%d.+CGATT:
   23699:	312c3028 432b0029 54554147 25003a48     (0,1).+CGAUTH:.%
   236a9:	2c642573 222c6425 2c227325 22732522     s%d,%d,"%s","%s"
   236b9:	47432b00 48545541 2d30283a 2c293031     .+CGAUTH:(0-10),
   236c9:	312c3028 2c29322c 362d3028 282c2930     (0,1,2),(0-60),(
   236d9:	30362d30 432b0029 4d4f4347 2b003a44     0-60).+CGCOMD:.+
   236e9:	4f434743 4452544e 50003a50 43005050     CGCONTRDP:.PPP.C
   236f9:	454e4e4f 44455443 47432b00 41544144     ONNECTED.+CGDATA
   23709:	5022283d 29225050 47432b00 4e4f4344     =("PPP").+CGDCON
   23719:	4d003a54 4d00434e 47004343 00535250     T:.MNC.MCC.GPRS.
   23729:	64252c2c 2c64252c 2c2c2c2c 252c6425     ,,%d,%d,,,,,%d,%
   23739:	4f4e0064 0050494e 36565049 56504900     d.NONIP.IPV6.IPV
   23749:	00365634 4447432b 544e4f43 2d30283a     4V6.+CGDCONT:(0-
   23759:	2c293031 50492228 4e222c22 50494e4f     10),("IP","NONIP
   23769:	49222c22 22365650 5049222c 36563456     ","IPV6","IPV4V6
   23779:	2c2c2922 2930282c 2930282c 2c2c2c2c     "),,,(0),(0),,,,
   23789:	2c30282c 282c2931 29312c30 47432b00     ,(0,1),(0,1).+CG
   23799:	534f5145 7325003a 2c290028 432b0028     EQOS:.%s(.),(.+C
   237a9:	3a414c47 53530020 73252c42 47432b00     GLA: .SSB,%s.+CG
   237b9:	003a4e53 5347432b 30283a4e 322c312c     SN:.+CGSN:(0,1,2
   237c9:	0029332c 5447432b 003a5446 7325222c     ,3).+CGTFT:.,"%s
   237d9:	73252e00 222c0022 252e6425 2c002264     ..%s".,"%d.%d".,
   237e9:	58257830 47432b00 3a544654 282c7325     0x%X.+CGTFT:%s,(
   237f9:	36312c31 30282c29 3535322c 73252c29     1,16),(0,255),%s
   23809:	322c3028 2c293535 2c302822 33353536     (0,255),"(0,6553
   23819:	282e2935 35362c30 29353335 28222c22     5).(0,65535)","(
   23829:	35362c30 29353335 2c30282e 33353536     0,65535).(0,6553
   23839:	2c222935 30783028 4678302c 46464646     5)",(0x0,0xFFFFF
   23849:	29464646 3028222c 3535322c 30282e29     FFF),"(0,255).(0
   23859:	3535322c 252c2229 2c302873 00292933     ,255)",%s(0,3)).
   23869:	5049432b 003a4143 5049432b 283a4143     +CIPCA:.+CIPCA:(
   23879:	282c2933 29312c30 25544100 432b0073     3),(0,1).AT%s.+C
   23889:	3a45454d 2b006425 45454d43 2c30283a     MEE:%d.+CMEE:(0,
   23899:	3e002931 432b0020 3a534d4d 4d432b00     1).> .+CMMS:.+CM
   238a9:	283a534d 2c312c30 2b002932 414d4e43     MS:(0,1,2).+CNMA
   238b9:	2c31283a 25002932 2c642573 222c6425     :(1,2).%s%d,%d,"
   238c9:	00227325 4950432b 203a524e 25732500     %s".+CPINR: .%s%
   238d9:	64252c73 0064252c 4950432b 00203a4e     s,%d,%d.+CPIN: .
   238e9:	73257325 50432b00 3a534d53 25732500     %s%s.+CPSMS:.%s%
   238f9:	2c2c2c64 50432b00 3a534d53 312c3028     d,,,.+CPSMS:(0,1
   23909:	2c29322c 30282c2c 30303030 2d303030     ,2),,,(00000000-
   23919:	31313131 31313131 30282c29 30303030     11111111),(00000
   23929:	2d303030 31313131 31313131 432b0029     000-11111111).+C
   23939:	3a4d5352 30250020 2b007832 41435343     RSM: .%02x.+CSCA
   23949:	7325223a 64252c22 53432b00 3a4e4f43     :"%s",%d.+CSCON:
   23959:	002c6425 4353432b 283a4e4f 29312c30     %d,.+CSCON:(0,1)
   23969:	53432b00 203a4d49 25732500 2b002c64     .+CSIM: .%s%d,.+
   23979:	534d5343 432b003a 3a534d53 312c3028     CSMS:.+CSMS:(0,1
   23989:	432b0029 43444f53 432b0050 003a5153     ).+CSODCP.+CSQ:.
   23999:	64257325 0039392c 5153432b 2d30283a     %s%d,99.+CSQ:(0-
   239a9:	392c3133 282c2939 00293939 5a54432b     31,99),(99).+CTZ
   239b9:	2b003a52 525a5443 2c30283a 2c322c31     R:.+CTZR:(0,1,2,
   239c9:	2b002933 5354414e 44454550 2c64253a     3).+NATSPEED:%d,
   239d9:	252c6425 64252c64 0064252c 54414e2b     %d,%d,%d,%d.+NAT
   239e9:	45455053 49443a44 4c424153 45445f45     SPEED:DISABLE_DE
   239f9:	535f5045 5045454c 414e2b00 45505354     EP_SLEEP.+NATSPE
   23a09:	283a4445 30303432 3038342c 36392c30     ED:(2400,4800,96
   23a19:	352c3030 30303637 3531312c 2c303032     00,57600,115200,
   23a29:	34303332 342c3030 30383036 32392c30     230400,460800,92
   23a39:	30303631 30282c29 2930332d 2c30282c     1600),(0-30),(0,
   23a49:	282c2931 29332d30 2c31282c 282c2932     1),(0-3),(1,2),(
   23a59:	29322d30 2c30282c 2b002931 4e41424e     0-2),(0,1).+NBAN
   23a69:	2b003a44 4943434e 41003a44 2b004c4c     D:.+NCCID:.ALL.+
   23a79:	4948434e 464e4950 25003a4f 2c732573     NCHIPINFO:.%s%s,
   23a89:	2e643225 0d643125 4554000a 5600504d     %2d.%1d...TEMP.V
   23a99:	00544142 73257325 6432252c 6431252e     BAT.%s%s,%2d.%1d
   23aa9:	434e2b00 49504948 3a4f464e 4c4c4128     .+NCHIPINFO:(ALL
   23ab9:	4d45542c 42562c50 00295441 49434e2b     ,TEMP,VBAT).+NCI
   23ac9:	41545344 00535554 49434e2b 41545344     DSTATUS.+NCIDSTA
   23ad9:	3a535554 312d3028 25002930 2c732573     TUS:(0-10).%s%s,
   23ae9:	25006425 2c732573 2b007325 4e4f434e     %d.%s%s,%s.+NCON
   23af9:	3a474946 28732500 282c7325 29297325     FIG:.%s(%s,(%s))
   23b09:	312d3000 00303038 52524142 5f474e49     .0-1800.BARRING_
   23b19:	454c4552 5f455341 414c4544 2d300059     RELEASE_DELAY.0-
   23b29:	33353536 59530035 545f434e 5f454d49     65535.SYNC_TIME_
   23b39:	49524550 2500444f 73252873 6425282c     PERIOD.%s(%s,(%d
   23b49:	2964252c 45520029 5341454c 45565f45     ,%d)).RELEASE_VE
   23b59:	4f495352 5049004e 475f3656 505f5445     RSION.IPV6_GET_P
   23b69:	49464552 49545f58 4e00454d 41435f42     REFIX_TIME.NB_CA
   23b79:	4f474554 25005952 73252873 7325282c     TEGORY.%s(%s,(%s
   23b89:	2973252c 50450029 50004f43 495f4f43     ,%s)).EPCO.PCO_I
   23b99:	59545f45 54004550 00455552 534c4146     E_TYPE.TRUE.FALS
   23ba9:	4e2b0045 44435043 003a5250 25287325     E.+NCPCDPR:.%s(%
   23bb9:	64252c64 30282c29 0029312c 49444e2b     d,%d),(0,1).+NDI
   23bc9:	3a444945 464e2b00 44505557 2d30283a     EID:.+NFWUPD:(0-
   23bd9:	25002935 64253a73 474e2b00 52544341     5).%s:%d.+NGACTR
   23be9:	2c30283a 2b002931 4950494e 3a4f464e     :(0,1).+NIPINFO:
   23bf9:	2b006425 4950494e 3a4f464e 312c3028     %d.+NIPINFO:(0,1
   23c09:	4e2b0029 005a5449 54494e2b 30283a5a     ).+NITZ.+NITZ:(0
   23c19:	0029312c 4f4c4e2b 56454c47 253a4c45     ,1).+NLOGLEVEL:%
   23c29:	73252c73 43455300 54495255 52500059     s,%s.SECURITY.PR
   23c39:	434f544f 41004c4f 494c5050 49544143     OTOCOL.APPLICATI
   23c49:	2b004e4f 474f4c4e 4556454c 50283a4c     ON.+NLOGLEVEL:(P
   23c59:	4f544f52 2c4c4f43 4c505041 54414349     ROTOCOL,APPLICAT
   23c69:	2c4e4f49 55434553 59544952 56282c29     ION,SECURITY),(V
   23c79:	4f425245 4e2c4553 414d524f 41572c4c     ERBOSE,NORMAL,WA
   23c89:	4e494e52 52452c47 2c524f52 454e4f4e     RNING,ERROR,NONE
   23c99:	4e2b0029 45574f50 414c4352 003a5353     ).+NPOWERCLASS:.
   23ca9:	33282c29 362c352c 52570029 00455449     ),(3,5,6).WRITE.
   23cb9:	44414552 504e2b00 46454452 4853414c     READ.+NPRDEFLASH
   23cc9:	3025003a 45005832 45534152 504e2b00     :.%02X.ERASE.+NP
   23cd9:	4c464452 3a485341 49525728 522c4554     RDFLASH:(WRITE,R
   23ce9:	2c444145 53415245 2b002945 4d53504e     EAD,ERASE).+NPSM
   23cf9:	2b003a52 4d53504e 30283a52 0029312c     R:.+NPSMR:(0,1).
   23d09:	54504e2b 52444557 283a5358 2c312c30     +NPTWEDRXS:(0,1,
   23d19:	29332c32 2935282c 3022282c 22303030     2,3),(5),("0000"
   23d29:	3131222d 29223131 3022282c 22303030     -"1111"),("0000"
   23d39:	3131222d 29223131 42455200 49544f4f     -"1111").REBOOTI
   23d49:	2b00474e 504e534e 47440044 004d4152     NG.+NSNPD.DGRAM.
   23d59:	45525453 52004d41 41005741 4e495f46     STREAM.RAW.AF_IN
   23d69:	41005445 4e495f46 00365445 252c6425     ET.AF_INET6.%d,%
   23d79:	64252c73 2c64252c 534e2b00 4154534f     s,%d,%d,.+NSOSTA
   23d89:	00535554 4f534e2b 54415453 283a5355     TUS.+NSOSTATUS:(
   23d99:	29362d30 544e2b00 4d524550 283a4449     0-6).+NTPERMID:(
   23da9:	29312c30 2c31282c 44002932 00504d55     0,1),(1,2).DUMP.
   23db9:	4c584e2b 283a474f 504d5544 554e0029     +NXLOG:(DUMP).NU
   23dc9:	41545345 283a5354 49444152 45432c4f     ESTATS:(RADIO,CE
   23dd9:	422c4c4c 2c52454c 2c504854 53505041     LL,BLER,THP,APPS
   23de9:	2c4d454d 294c4c41 4c554e00 4e2b004c     MEM,ALL).NULL.+N
   23df9:	474e4950 2c73253a 252c6425 4e2b0064     PING:%s,%d,%d.+N
   23e09:	474e4950 3a525245 2b006425 444f5343     PINGERR:%d.+CSOD
   23e19:	3a525043 43432b00 4f544f49 3a495450     CPR:.+CCIOTOPTI:
   23e29:	504e2b00 44455754 3a505852 222c6425     .+NPTWEDRXP:%d,"
   23e39:	2c227325 22732522 7325222c 25222c22     %s","%s","%s","%
   23e49:	2b002273 52444543 253a5058 25222c64     s".+CEDRXP:%d,"%
   23e59:	222c2273 2c227325 22732522 534e2b00     s","%s","%s".+NS
   23e69:	5254534f 7325003a 252c6425 64252c64     OSTR:.%s%d,%d,%d
   23e79:	534e2b00 5244504e 7325003a 252c6425     .+NSNPDR:.%s%d,%
   23e89:	6f530064 74656b63 20642520 20646168     d.Socket %d had 
   23e99:	6e6e6f63 65746365 6f530064 74656b63     connected.Socket
   23ea9:	20642520 20646168 656b6361 64252064      %d had acked %d
   23eb9:	74796220 53007365 656b636f 64252074      bytes.Socket %d
   23ec9:	64616820 63657220 20646576 62206425      had recved %d b
   23ed9:	73657479 636f5300 2074656b 68206425     ytes.Socket %d h
   23ee9:	63206461 65736f6c 79622064 72726520     ad closed by err
   23ef9:	00642520 6b636f53 25207465 61682064      %d.Socket %d ha
   23f09:	6c632064 6465736f 20796220 76726573     d closed by serv
   23f19:	2b007265 434f534e 003a494c 25207325     er.+NSOCLI:.%s %
   23f29:	6f530064 74656b63 20642520 706f7264     d.Socket %d drop
   23f39:	20646570 62206425 73657479 74616420     ped %d bytes dat
   23f49:	75642061 6f742065 63616320 66206568     a due to cache f
   23f59:	006c6c75 4353432b 253a4e4f               ull.+CSCON:%d..

00023f68 <core_name>:
   23f68:	00023c2e 00023c37 00023c40 3230252b     .<..7<..@<..+%02
   23f78:	252d0064 00643230 2c64252c 002f6425     d.-%02d.,%d,%d/.
   23f88:	64323025 3230252f 30252c64 253a6432     %02d/%02d,%02d:%
   23f98:	3a643230 64323025 00000000              02d:%02d....

00023fa4 <g_at_cmd_table>:
   23fa4:	0000004a 00024bdd 0000f7bd 0000f6f1     J....K..........
   23fb4:	0000f6dd 00000000 0000000a 00024be3     .............K..
   23fc4:	00011131 0000f6a1 0000b3a1 00000000     1...............
   23fd4:	0000000a 00024bea 0000f601 00000000     .....K..........
   23fe4:	0001143d 00000000 0000000a 00024bf3     =............K..
	...
   24000:	0000f5ed 0000000a 00024bfe 0000f4fd     .........K......
   24010:	00000000 0000b391 0000f3a5 0000000a     ................
   24020:	00024c08 0000f329 0000cfd5 0000f289     .L..)...........
   24030:	00000000 00000009 00024c0f 0000f211     .........L......
   24040:	00000000 00011451 00000000 0000000a     ....Q...........
   24050:	00024c18 0000f0e9 00000000 0000b381     .L..............
   24060:	00000000 0000000a 00024c23 000110e5     ........#L......
   24070:	0000f0ad 0000b371 00000000 0000000a     ....q...........
   24080:	00024c29 00000000 00000000 00000000     )L..............
   24090:	0000f085 0000000a 00024c2e 00000000     .........L......
   240a0:	00000000 0001144d 0000f019 0000000a     ....M...........
   240b0:	00024c34 00000000 00000000 0000b361     4L..........a...
   240c0:	0000efd1 0000000a 00024c39 00011089     ........9L......
   240d0:	000117af 0000b351 00000000 0000000a     ....Q...........
   240e0:	00024c40 0000eed1 00000000 0000efa5     @L..............
   240f0:	0000ee31 0000000a 00024c49 00011041     1.......IL..A...
   24100:	0000eda5 0000b341 00000000 0000000a     ....A...........
   24110:	00024c50 00010a81 0000b2ed 0000b2dd     PL..............
   24120:	00000000 0000000a 00024c57 0001100b     ........WL......
   24130:	0000ed79 0000b2cd 00000000 0000002a     y...........*...
   24140:	00024c5d 0000ecd9 00000000 00000000     ]L..............
   24150:	00000000 0000000a 00024c64 0000eba5     ........dL......
   24160:	0000eacd 0000bcd9 00000000 0000002a     ............*...
   24170:	00024c6d 0000e8b1 00000000 00000000     mL..............
   24180:	00000000 0000002a 00024c74 0001034d     ....*...tL..M...
	...
   2419c:	0000002a 00024c7b 00010229 00000000     *...{L..).......
	...
   241b4:	0000002a 00024c82 0001021f 00000000     *....L..........
	...
   241cc:	0000002a 00024c89 00010215 00000000     *....L..........
	...
   241e4:	0000000a 00024c91 0000fe0d 0000fdb5     .....L..........
	...
   241fc:	0000002a 00024c98 0000fe9d 00000000     *....L..........
	...
   24214:	0000000a 00024c9f 00010fc5 00000000     .....L..........
	...
   2422c:	0000000a 00024ca6 0000e6bd 0000e4cd     .....L..........
   2423c:	0000b2bd 00000000 0000000a 00024caf     .............L..
   2424c:	0000e41d 0000e369 0000b2ad 00000000     ....i...........
   2425c:	0000000a 00024cb7 00010f71 00011869     .....L..q...i...
   2426c:	00011459 00000000 0000000a 00023c0b     Y............<..
   2427c:	00010f35 0000e325 0000b29d 00000000     5...%...........
   2428c:	0000000a 00024cbd 00010ee9 0000b261     .....L......a...
   2429c:	0000b251 00000000 0000000a 00024cc3     Q............L..
   242ac:	00000000 0000e191 0001145d 0000e215     ........].......
   242bc:	0000000a 00024cca 0000e0d5 0000e065     .....L......e...
   242cc:	0000b241 00000000 0000000a 00024cd5     A............L..
	...
   242e4:	00011445 0000e021 00000006 00024cdb     E...!........L..
   242f4:	0000f949 00000000 0000b231 0000f8e9     I.......1.......
   24304:	00000006 00024ce1 0000ded9 00000000     .....L..........
	...
   2431c:	0000000a 00024cea 0000dd6d 0000cbe1     .....L..m.......
   2432c:	0000b221 00000000 0000000a 00024cf4     !............L..
   2433c:	00010e8b 00000000 0000b211 00000000     ................
   2434c:	0000000a 00024cfe 00000000 00000000     .....L..........
   2435c:	00011441 0000dd29 0000000a 00024d04     A...)........M..
	...
   24374:	00011449 0000dc71 0000000a 00024d0a     I...q........M..
	...
   2438c:	00011455 0000dbf1 0000000a 00024d10     U............M..
   2439c:	00010969 00011525 0000b201 00000000     i...%...........
   243ac:	0000012a 00024d17 0000db69 0000db15     *....M..i.......
   243bc:	00011469 00000000 0000010a 00024d1d     i............M..
   243cc:	0000d9f1 0000d985 0000b1f1 00000000     ................
   243dc:	0000010a 00024d23 00010e53 0000d931     ....#M..S...1...
   243ec:	0000b1e1 00000000 0000012a 00024d29     ........*...)M..
   243fc:	0000d83d 00000000 0001146d 00000000     =.......m.......
   2440c:	0000012a 00024d2f 0000d7e9 00000000     *.../M..........
   2441c:	00011471 00000000 0000010a 00024d35     q...........5M..
   2442c:	0000d891 00000000 0000b1d1 00010e39     ............9...
   2443c:	0000000a 00024d3b 0000d791 0000d749     ....;M......I...
   2444c:	0000b1c1 00000000 0000000a 0002492b     ............+I..
   2445c:	00010df1 0000b185 0000b175 00000000     ........u.......
   2446c:	0000002a 0002398b 0001149d 00000000     *....9..........
   2447c:	0000d6c1 00000000 0000000a 00024d42     ............BM..
	...
   24494:	00011461 0000d597 0000000a 00022e5c     a...........\...
   244a4:	000114b7 0000d709 0000d621 00000000     ........!.......
   244b4:	0000002a 00023d4c 00010dd9 00000000     *...L=..........
   244c4:	0000d6b1 00000000 0000000a 00022e64     ............d...
   244d4:	000114ed 0000d6d1 0000d611 00000000     ................
   244e4:	0000000a 00024d4b 00000000 00000000     ....KM..........
   244f4:	00011465 0000d58d 0000000a 00024d53     e...........SM..
   24504:	0001095f 0000fd0f 0000b165 00000000     _.......e.......
   24514:	0000000a 00024d5b 00010955 0000fd05     ....[M..U.......
   24524:	0000b155 00000000 0000000a 00024d66     U...........fM..
	...
   2453c:	00011475 0000d3d9 0000000a 00024d6c     u...........lM..
	...
   24554:	00011479 0000fb6d 0000000a 00024d76     y...m.......vM..
   24564:	0000d2f5 00000000 0000b145 00000000     ........E.......
   24574:	00000009 00024d7e 0000d105 00000000     ....~M..........
   24584:	0000b135 00000000 0000002a 00024d8a     5.......*....M..
   24594:	0000bfd1 00000000 00000000 00000000     ................
   245a4:	0000000a 00024d90 0000c6ad 00000000     .....M..........
   245b4:	0000c625 0000c635 0000000a 00024d99     %...5........M..
   245c4:	00010c3d 0000d069 0000cf39 00000000     =...i...9.......
   245d4:	0000000a 00024da6 0000cecd 0000ce85     .....M..........
   245e4:	0000b125 00000000 0000000a 00024dad     %............M..
   245f4:	0000cd19 00000000 0000b115 00000000     ................
   24604:	0000000a 00024db5 00010bf5 0000b0e5     .....M..........
   24614:	0000b0d5 00000000 0000000a 00024dbe     .............M..
	...
   2462c:	0001147d 0000cb09 0000000a 00024dc6     }............M..
   2463c:	0000ca81 00000000 0000b0c5 00000000     ................
   2464c:	00000009 00024dcd 00000000 00000000     .....M..........
   2465c:	0000ad91 0000c9e1 0000000a 00024dd5     .............M..
   2466c:	0000c9a9 00000000 0000c615 0000c969     ............i...
   2467c:	0000000a 00024de0 00010ba1 0000c74d     .....M......M...
   2468c:	0000b08d 00000000 0000000a 00024de9     .............M..
   2469c:	0000c711 00000000 0000c605 00000000     ................
   246ac:	0000000a 00024df1 0000c455 0000c3f9     .....M..U.......
   246bc:	0000b07d 00000000 0000000a 00024dfb     }............M..
   246cc:	0000c381 0000c2e9 0000afbd 00000000     ................
   246dc:	0000000a 00024e03 0001043d 00011169     .....N..=...i...
   246ec:	0000c11d 00000000 0000002a 00024e0a     ........*....N..
   246fc:	0000bef9 0000be9d 00011481 00000000     ................
   2470c:	0000002a 00024e10 0000bdf5 00000000     *....N..........
   2471c:	00011485 0000bc1d 0000000a 00024e17     .............N..
   2472c:	0000bb91 00000000 00011489 00000000     ................
   2473c:	0000000a 00024e1d 00010af1 00000000     .....N..........
   2474c:	0001148d 00000000 0000000a 00024e23     ............#N..
   2475c:	0000ba59 00000000 00011491 00000000     Y...............
   2476c:	0000000a 00024e29 0000b939 00000000     ....)N..9.......
   2477c:	00011495 00000000 0000000a 00024e2f     ............/N..
   2478c:	00010ab9 00000000 00011499 00000000     ................
   2479c:	0000000a 00024e36 0000b6a1 00000000     ....6N..........
   247ac:	00011439 00000000 0000000a 00023d82     9............=..
   247bc:	0000fd31 00000000 0000afad 0000b53d     1...........=...
   247cc:	0000000a 00023ac5 00010a21 00000000     .....:..!.......
   247dc:	0000af9d 0000b42d                       ....-...

000247e4 <log_level_names>:
   247e4:	00024e7c 00024e81 00024e89 00024e90     |N...N...N...N..
   247f4:	000233d4 00024e98                       .3...N..

000247fc <mem_stats_labels>:
   247fc:	00024e3c 00024e4f 00024e5b 00024e65     <N..ON..[N..eN..
   2480c:	00024e71                                qN..

00024810 <nconfig_false_true_value_name>:
   24810:	00023ba5 00023ba0                       .;...;..

00024818 <nconfig_function_names>:
   24818:	00024e9f 00024eab 00024ec3 00024ed4     .N...N...N...N..
   24828:	00024ee3 00024ef4 00024eff 00024f09     .N...N...N...O..
   24838:	00023b11 00023b4f 00024f25 00023b2f     .;..O;..%O../;..
   24848:	00023b5f 00023b74 00024f29 00024f2d     _;..t;..)O..-O..
   24858:	00024f3b 00024f46 00024f61 00023b94     ;O..FO..aO...;..
   24868:	00024f6a 00024f88 00024f9d 50494e2b     jO...O...O..+NIP
   24878:	4f464e49 222c003a 2c225049 49222c00     INFO:.,"IP",.,"I
   24888:	22365650 222c002c 34565049 2c223656     PV6",.,"IPV4V6",
   24898:	4e222c00 50494e4f 2b002c22 4e49504e     .,"NONIP",.+NPIN
   248a8:	4500203a 524f5252 6f727720 5020676e     : .ERROR wrong P
   248b8:	28204e49 00296425 5245432b 003a4745     IN (%d).+CEREG:.
   248c8:	3430252c 30252c58 252c5838 73250064     ,%04X,%08X,%d.%s
   248d8:	252c7325 00642573 53505041 004d454d     %s,%s%d.APPSMEM.
   248e8:	5345554e 53544154 7325003a 002c7325     NUESTATS:.%s%s,.
   248f8:	52454c42 25732500 64252c73 2c64252c     BLER.%s%s,%d,%d,
   24908:	252c7525 64252c64 4c454300 4152004c     %u,%d,%d.CELL.RA
   24918:	004f4944 73257325 2c73252c 54007525     DIO.%s%s,%s,%u.T
   24928:	2b005048 4341474e 25005254 64253a73     HP.+NGACTR.%s:%d
   24938:	2c64252c                                 ,%d,%d.

0002493f <rsp_rest_string.7278>:
   2493f:	30282c2c 2c29322d 00293228 5245432b     ,,(0-2),(2).+CER
   2494f:	253a4745 54410064 6c616d20 20636f6c     EG:%d.AT malloc 
   2495f:	20646d63 6c696166 2b006465 3a544d43     cmd failed.+CMT:
   2496f:	252c6425 000a0d64 4f534e2b 00494d4e     %d,%d...+NSONMI.
   2497f:	253a7325 64252c64 4d495300 4e495020     %s:%d,%d.SIM PIN
   2498f:	4d495300 4b555020 434c5200 004c5520     .SIM PUK.RLC UL.
   2499f:	20434c52 4d004c44 55204341 414d004c     RLC DL.MAC UL.MA
   249af:	4c442043 54432b00 003a565a 5a54432b     C DL.+CTZV:.+CTZ
   249bf:	2b003a45 455a5443 53003a55 52554345     E:.+CTZEU:.SECUR
   249cf:	5f595449 52500041 434f544f 415f4c4f     ITY_A.PROTOCOL_A
   249df:	50504100 4143494c 4e4f4954 5300415f     .APPLICATION_A.S
   249ef:	52554345 5f595449 50410042 43494c50     ECURITY_B.APPLIC
   249ff:	4f495441 00425f4e 4f525245 49502052     ATION_B.ERROR PI
   24a0f:	6964204e 6c626173 50006465 61204e49     N disabled.PIN a
   24a1f:	6165726c 65207964 6c62616e 50006465     lready enabled.P
   24a2f:	72204e49 69757165 00646572 4f525245     IN required.ERRO
   24a3f:	49502052 6c62204e 656b636f 52450064     R PIN blocked.ER
   24a4f:	20524f52 6e6f7277 6f662067 74616d72     ROR wrong format
   24a5f:	52524500 5020524f 62204b55 6b636f6c     .ERROR PUK block
   24a6f:	28006465 2c307830 46467830 29464646     ed.(0x0,0xFFFFF)
   24a7f:	2822002c 2e302e30 2c312e30 2e353532     ,."(0.0.0.1,255.
   24a8f:	2e353532 2e353532 29353532 2e30282e     255.255.255).(0.
   24a9f:	2e302e30 35322c31 35322e35 35322e35     0.0.1,255.255.25
   24aaf:	35322e35 2c222935 3a282200 462c313a     5.255)",."(::1,F
   24abf:	3a464646 46464646 4646463a 46463a46     FFF:FFFF:FFFF:FF
   24acf:	463a4646 3a464646 46464646 4646463a     FF:FFFF:FFFF:FFF
   24adf:	46463a46 2e294646 313a3a28 4646462c     F:FFFF).(::1,FFF
   24aef:	46463a46 463a4646 3a464646 46464646     F:FFFF:FFFF:FFFF
   24aff:	4646463a 46463a46 463a4646 3a464646     :FFFF:FFFF:FFFF:
   24b0f:	46464646 002c2229 2e302822 2e302e30     FFFF)",."(0.0.0.
   24b1f:	35322c31 35322e35 35322e35 35322e35     1,255.255.255.25
   24b2f:	285c2935 2c313a3a 46464646 4646463a     5)\(::1,FFFF:FFF
   24b3f:	46463a46 463a4646 3a464646 46464646     F:FFFF:FFFF:FFFF
   24b4f:	4646463a 46463a46 463a4646 29464646     :FFFF:FFFF:FFFF)
   24b5f:	2e30282e 2e302e30 35322c31 35322e35     .(0.0.0.1,255.25
   24b6f:	35322e35 35322e35 285c2935 2c313a3a     5.255.255)\(::1,
   24b7f:	46464646 4646463a 46463a46 463a4646     FFFF:FFFF:FFFF:F
   24b8f:	3a464646 46464646 4646463a 46463a46     FFF:FFFF:FFFF:FF
   24b9f:	463a4646 29464646 22002c22 00225049     FF:FFFF)",."IP".
   24baf:	4e4f4e22 00225049 56504922 22002236     "NONIP"."IPV6"."
   24bbf:	34565049 00223656 44414552 49530059     IPV4V6".READY.SI
   24bcf:	5550204d 4c42204b 454b434f 432b0044     M PUK BLOCKED.+C
   24bdf:	0053504f 4147432b 2b005454 5241454e     OPS.+CGATT.+NEAR
   24bef:	004e4346 53434e2b 46524145 2b004e43     FCN.+NCSEARFCN.+
   24bff:	5345554e 53544154 424e2b00 00444e41     NUESTATS.+NBAND.
   24c0f:	44524e2b 54534554 434e2b00 49504948     +NRDTEST.+NCHIPI
   24c1f:	004f464e 5546432b 4e2b004e 2b004252     NFO.+CFUN.+NRB.+
   24c2f:	494d4943 53432b00 432b0051 47455245     CIMI.+CSQ.+CEREG
   24c3f:	47432b00 44444150 432b0052 4e4f4353     .+CGPADDR.+CSCON
   24c4f:	504e2b00 00524d53 454d432b 4e2b0045     .+NPSMR.+CMEE.+N
   24c5f:	474e4950 434e2b00 49464e4f 4e2b0047     PING.+NCONFIG.+N
   24c6f:	52434f53 534e2b00 004f434f 4f534e2b     SOCR.+NSOCO.+NSO
   24c7f:	2b004453 534f534e 4e2b0054 54534f53     SD.+NSOST.+NSOST
   24c8f:	4e2b0046 534f5351 534e2b00 0046524f     F.+NQSOS.+NSORF.
   24c9f:	4f534e2b 2b004c43 43444743 00544e4f     +NSOCL.+CGDCONT.
   24caf:	4147432b 00485455 4c43432b 432b004b     +CGAUTH.+CCLK.+C
   24cbf:	00525a54 43434e2b 2b004449 474f4c4e     TZR.+NCCID.+NLOG
   24ccf:	4556454c 432b004c 00494d47 5347432b     LEVEL.+CGMI.+CGS
   24cdf:	4e2b004e 54455354 2b004449 5354414e     N.+NTSETID.+NATS
   24cef:	44454550 544e2b00 4d524550 2b004449     PEED.+NTPERMID.+
   24cff:	4d4d4743 47432b00 2b00524d 43414c43     CGMM.+CGMR.+CLAC
   24d0f:	50432b00 00534d53 4353432b 432b0041     .+CPSMS.+CSCA.+C
   24d1f:	00534d53 4d4d432b 432b0053 0053474d     SMS.+CMMS.+CMGS.
   24d2f:	474d432b 432b0043 00414d4e 4147432b     +CMGC.+CNMA.+CGA
   24d3f:	2b005443 4f50514e 00504344 50514e2b     CT.+NQPODCP.+NQP
   24d4f:	0044504e 4445432b 00535852 54504e2b     NPD.+CEDRXS.+NPT
   24d5f:	52444557 2b005358 52454543 45432b00     WEDRXS.+CEER.+CE
   24d6f:	52585244 2b005044 5557464e 2b004450     DRXRDP.+NFWUPD.+
   24d7f:	4452504e 414c4645 2b004853 4e49504e     NPRDEFLASH.+NPIN
   24d8f:	47432b00 524e5041 4e2b0043 45574f50     .+CGAPNRC.+NPOWE
   24d9f:	414c4352 2b005353 43504943 432b0041     RCLASS.+CIPCA.+C
   24daf:	54414447 4e2b0041 4e495049 2b004f46     GDATA.+NIPINFO.+
   24dbf:	504d4e43 2b004453 4f4c584e 4e2b0047     CNMPSD.+NXLOG.+N
   24dcf:	49454944 432b0044 4e4f4347 50445254     DIEID.+CGCONTRDP
   24ddf:	434e2b00 50444350 432b0052 4f4d4347     .+NCPCDPR.+CGCMO
   24def:	432b0044 544f4943 0054504f 4547432b     D.+CCIOTOPT.+CGE
   24dff:	00534f51 5447432b 2b005446 4e495043     QOS.+CGTFT.+CPIN
   24e0f:	50432b00 00524e49 4843432b 432b004f     .+CPINR.+CCHO.+C
   24e1f:	00434843 4c47432b 432b0041 004d4953     CHC.+CGLA.+CSIM.
   24e2f:	49554e2b 2b004343 4d535243 72754300     +NUICC.+CRSM.Cur
   24e3f:	746e6572 6c6c4120 7461636f 003a6465     rent Allocated:.
   24e4f:	61746f54 7246206c 003a6565 2078614d     Total Free:.Max 
   24e5f:	65657246 754e003a 6c41206d 73636f6c     Free:.Num Allocs
   24e6f:	754e003a 7246206d 3a736565 4e4f4e00     :.Num Frees:.NON
   24e7f:	45560045 534f4252 4f4e0045 4c414d52     E.VERBOSE.NORMAL
   24e8f:	52415700 474e494e 53554300 004d4f54     .WARNING.CUSTOM.
   24e9f:	4f545541 4e4e4f43 00544345 305f5243     AUTOCONNECT.CR_0
   24eaf:	5f343533 38333330 5243535f 4c424d41     354_0338_SCRAMBL
   24ebf:	00474e49 305f5243 5f393538 415f4953     ING.CR_0859_SI_A
   24ecf:	44494f56 4d4f4300 454e4942 5454415f     VOID.COMBINE_ATT
   24edf:	00484341 4c4c4543 5345525f 43454c45     ACH.CELL_RESELEC
   24eef:	4e4f4954 414e4500 5f454c42 00504942     TION.ENABLE_BIP.
   24eff:	544c554d 4e4f5449 414e0045 49535f53     MULTITONE.NAS_SI
   24f0f:	4f505f4d 5f524557 49564153 455f474e     M_POWER_SAVING_E
   24f1f:	4c42414e 50520045 4152004d 45480049     NABLE.RPM.RAI.HE
   24f2f:	435f4441 52504d4f 00535345 5f464c52     AD_COMPRESS.RLF_
   24f3f:	41445055 43004554 454e4e4f 4f495443     UPDATE.CONNECTIO
   24f4f:	45525f4e 41545345 53494c42 4e454d48     N_REESTABLISHMEN
   24f5f:	57540054 41485f4f 54005152 34323333     T.TWO_HARQ.T3324
   24f6f:	3433545f 455f3231 435f5458 474e4148     _T3412_EXT_CHANG
   24f7f:	45525f45 54524f50 4e4f4e00 5f50495f     E_REPORT.NON_IP_
   24f8f:	535f4f4e 455f534d 4c42414e 55530045     NO_SMS_ENABLE.SU
   24f9f:	524f5050 4d535f54 4c520053 4c552043     PPORT_SMS.RLC UL
   24faf:	454c4220 75252c52 434c5200 204c4420      BLER,%u.RLC DL 
   24fbf:	52454c42 0075252c 2043414d 42204c55     BLER,%u.MAC UL B
   24fcf:	2c52454c 4d007525 44204341 4c42204c     LER,%u.MAC DL BL
   24fdf:	252c5245 6f540075 206c6174 62205854     ER,%u.Total TX b
   24fef:	73657479 0075252c 61746f54 5852206c     ytes,%u.Total RX
   24fff:	74796220 252c7365 6f540075 206c6174      bytes,%u.Total 
   2500f:	62205854 6b636f6c 75252c73 746f5400     TX blocks,%u.Tot
   2501f:	52206c61 6c622058 736b636f 0075252c     al RX blocks,%u.
   2502f:	61746f54 5452206c 6c622058 736b636f     Total RTX blocks
   2503f:	0075252c 61746f54 4341206c 414e2f4b     ,%u.Total ACK/NA
   2504f:	52204b43 75252c58 72655600 6e6f6973     CK RX,%u.Version
   2505f:	0075253a 6e676953 70206c61 7265776f     :%u.Signal power
   2506f:	0064253a 61746f54 6f70206c 3a726577     :%d.Total power:
   2507f:	54006425 6f702058 3a726577 54006425     %d.TX power:%d.T
   2508f:	69742058 253a656d 58520075 6d697420     X time:%u.RX tim
   2509f:	75253a65 6c654300 4449206c 0075253a     e:%u.Cell ID:%u.
   250af:	3a4c4345 53007525 253a524e 41450064     ECL:%u.SNR:%d.EA
   250bf:	4e434652 0075253a 3a494350 52007525     RFCN:%u.PCI:%u.R
   250cf:	3a515253 4f006425 41524550 20524f54     SRQ:%d.OPERATOR 
   250df:	45444f4d 0064253a 52525543 20544e45     MODE:%d.CURRENT 
   250ef:	444e4142 0064253a                        BAND:%d..

000250f8 <ue_stats_bler_labels>:
   250f8:	00000000 00024fa9 00024fb8 00024fc7     .....O...O...O..
   25108:	00024fd6 00024fe5 00024ff7 00025009     .O...O...O...P..
   25118:	0002501c 0002502f 00025043              .P../P..CP..

00025124 <ue_stats_labels>:
   25124:	00025058 00025063 00025073 00025082     XP..cP..sP...P..
   25134:	0002508e 00025099 000250a4 000250af     .P...P...P...P..
   25144:	000250b6 000250bd 000250c7 000250ce     .P...P...P...P..
   25154:	000250d6 000250e7                       .P...P..

0002515c <CSWTCH.25>:
   2515c:	000251f6 00025201 00025211 00025227     .Q...R...R..'R..
   2516c:	00025242 0002525e 00025279 00025292     BR..^R..yR...R..
   2517c:	000252a6 000252c7                       .R...R..

00025184 <CSWTCH.34>:
   25184:	000251bd 000251d1 000251e4 57464e2b     .Q...Q...Q..+NFW
   25194:	3a445055 50007525 414b4341 4e5f4547     UPD:%u.PACKAGE_N
   251a4:	565f544f 44494c41 4f495441 4e2b004e     OT_VALIDATION.+N
   251b4:	50555746 73253a44 43415000 4547414b     FWUPD:%s.PACKAGE
   251c4:	574f445f 414f4c4e 474e4944 43415000     _DOWNLOADING.PAC
   251d4:	4547414b 4c41565f 54414449 00474e49     KAGE_VALIDATING.
   251e4:	4b434150 5f454741 52475055 4e494441     PACKAGE_UPGRADIN
   251f4:	41500047 47414b43 4b4f5f45 43415000     G.PACKAGE_OK.PAC
   25204:	4547414b 524f435f 54505552 43415000     KAGE_CORRUPT.PAC
   25214:	4547414b 544f4e5f 4f52505f 53534543     KAGE_NOT_PROCESS
   25224:	50004445 414b4341 565f4547 44494c41     ED.PACKAGE_VALID
   25234:	4f495441 41465f4e 52554c49 41500045     ATION_FAILURE.PA
   25244:	47414b43 4e555f45 50505553 4554524f     CKAGE_UNSUPPORTE
   25254:	504f5f44 4e4f4954 41500053 47414b43     D_OPTIONS.PACKAG
   25264:	45565f45 4f495352 494d5f4e 54414d53     E_VERSION_MISMAT
   25274:	44454843 43415000 4547414b 454c455f     CHED.PACKAGE_ELE
   25284:	544e454d 4f4f545f 4e4f4c5f 41500047     MENT_TOO_LONG.PA
   25294:	47414b43 45525f45 4e4f4947 534f4c5f     CKAGE_REGION_LOS
   252a4:	41500054 47414b43 49535f45 54414e47     T.PACKAGE_SIGNAT
   252b4:	5f455255 485f524f 5f485341 4b43414c     URE_OR_HASH_LACK
   252c4:	50004445 414b4341 4e5f4547 445f544f     ED.PACKAGE_NOT_D
   252d4:	4c4e574f 4544414f 45440044 49544341     OWNLOADED.DEACTI
   252e4:	45544156 524e2b00 52544344 41283a4c     VATE.+NRDCTRL:(A
   252f4:	56495443 2c455441 43414544 41564954     CTIVATE,DEACTIVA
   25304:	522c4554 54455345 58520029 49535352     TE,RESET).RXRSSI
   25314:	524e2b00 45584544 54003a43 52455658     .+NRDEXEC:.TXVER
   25324:	00594649 45565852 59464952 25732500     IFY.RXVERIFY.%s%
   25334:	64252c73 2c64252c 54006425 53455458     s,%d,%d,%d.TXTES
   25344:	58540054 494c4143 52005453 4c414358     T.TXCALIST.RXCAL
   25354:	00545349 44524e2b 43455845 5852283a     IST.+NRDEXEC:(RX
   25364:	49535352 5458542c 2c545345 45565854     RSSI,TXTEST,TXVE
   25374:	59464952 4358542c 53494c41 58522c54     RIFY,TXCALIST,RX
   25384:	494c4143 522c5453 52455658 29594649     CALIST,RXVERIFY)
   25394:	524e2b00 50494d44 2b003a49 4d44524e     .+NRDMIPI:.+NRDM
   253a4:	3a495049 41455228 52572c44 29455449     IPI:(READ,WRITE)
   253b4:	2d30282c 29353532 2d30282c 29353532     ,(0-255),(0-255)
   253c4:	2d30282c 29353532 524e2b00 54455344     ,(0-255).+NRDSET
   253d4:	7325003a 302c7325 6c6c2578 49500078     :.%s%s,0x%llx.PI
   253e4:	7325004f 252c7325 64252c64 2c64252c     O.%s%s,%d,%d,%d,
   253f4:	73256425 49414700 4952004e 4e2b004f     %d%s.GAIN.RIO.+N
   25404:	45534452 52283a54 502c4f49 542c4f49     RDSET:(RIO,PIO,T
   25414:	2c454e4f 4e494147 00000029              ONE,GAIN)...

00025420 <production_at_cmd_table>:
   25420:	00000005 00025498 000126e9 00000000     .....T...&......
   25430:	00011e95 00000000 00000005 000254a1     .............T..
   25440:	0001255d 000124a9 00011e85 00000000     ]%...$..........
   25450:	00000005 000254a9 00011f9d 00000000     .....T..........
   25460:	00011e75 00000000 00000009 000254b2     u............T..
   25470:	00011ea5 00000000 00011e65 00000000     ........e.......
   25480:	00000009 000254bb 00012765 00000000     .....T..e'......
   25490:	00011e61 00000000 44524e2b 4c525443     a.......+NRDCTRL
   254a0:	524e2b00 54455344 524e2b00 45584544     .+NRDSET.+NRDEXE
   254b0:	4e2b0043 494d4452 2b004950 4c41434e     C.+NRDMIPI.+NCAL
   254c0:	504d4554 534e4553 4900524f 43656c64     TEMPSENSOR.IdleC
   254d0:	3065726f 53003030 545f7477 006b7361     ore000.Swt_Task.

000254e0 <uart_assert_software_rx_flow_control_functions>:
   254e0:	000150ff 000150f3 000150e7              .P...P...P..

000254ec <uart_assert_software_tx_flow_control_functions>:
   254ec:	00014e9d 00014e91 00014e85              .N...N...N..

000254f8 <uart_interrupt_handlers>:
   254f8:	0001546d 0001536d 00015201 000150dd     mT..mS...R...P..
   25508:	00015463 00015363 000151f7 000150d3     cT..cS...Q...P..
   25518:	00015459 00015359 000151ed 000150c9     YT..YS...Q...P..

00025528 <uart_release_functions>:
   25528:	00015675 0001566b 00015661              uV..kV..aV..

00025534 <uart_rx_dma_peripheral>:
   25534:	                                         ...

00025537 <uart_tx_dma_peripheral>:
   25537:	                                         ...

0002553a <cycle_type_maps.5576>:
   2553a:	05010102 01010707                        .........

00025543 <dma_addr_inc_shift>:
   25543:	20020100                                 ... .

00025548 <dma_configs_adding_fsm_handler_list>:
   25548:	00016959 000168bd 00016791 000167c5     Yi...h...g...g..

00025558 <dma_configs_adding_fsm_transit>:
   25558:	000165cd 0001655d 00016579              .e..]e..ye..

00025564 <dma_dst_addr_inc_map>:
   25564:	03020100 01000303                        .........

0002556d <dma_src_addr_inc_map>:
   2556d:	00020100 03030201                        .........

00025576 <uart_common_pin_functions>:
   25576:	0a060802 1612140e dad6d8d2              ............

00025582 <gpio_input_default_config>:
	...

00025583 <gpio_output_default_config>:
   25583:	                                         ..

00025585 <hal_dma_addr_inc_shift>:
   25585:	20020100                                 ... ...

0002558c <hal_sectors_ram_heap_size>:
   2558c:	0000cf40                                @...

00025590 <rx_level_bytes.4793>:
   25590:	18100804 0000001c                       ........

00025598 <hal_uart_bases>:
   25598:	40008000 40009000 4000a000              ...@...@...@

000255a4 <uart_interrupt_lines>:
   255a4:	00160807                                ....

000255a8 <_ctype_>:
   255a8:	20202000 20202020 28282020 20282828     .         ((((( 
   255b8:	20202020 20202020 20202020 20202020                     
   255c8:	10108820 10101010 10101010 10101010      ...............
   255d8:	04040410 04040404 10040404 10101010     ................
   255e8:	41411010 41414141 01010101 01010101     ..AAAAAA........
   255f8:	01010101 01010101 01010101 10101010     ................
   25608:	42421010 42424242 02020202 02020202     ..BBBBBB........
   25618:	02020202 02020202 02020202 10101010     ................
   25628:	00000020 00000000 00000000 00000000      ...............
	...
   256ac:	0001aa76 0001aa8a 0001aa8a 0001aa5a     v...........Z...
   256bc:	0001aa8a 0001aa8a 0001aa8a 0001aa8a     ................
   256cc:	0001aa8a 0001aa8a 0001aa64 0001aa56     ........d...V...
   256dc:	0001aa8a 0001aa74 0001aa8a 0001aa8a     ....t...........
   256ec:	0001aa5e 6c756e28 0000296c 75587864     ^...(null)..dxXu
   256fc:	00706f69 6c75654e 32694800 00353131     iop.Neul.Hi2115.

0002570c <ip_addr_any>:
	...

00025720 <ip_addr_broadcast>:
   25720:	ffffffff 00000000 00000000 00000000     ................
   25730:	00000000 45494c43 4300544e 4e45494c     ....CLIENT.CLIEN
   25740:	52455354 00524556 64707070 7473203a     TSERVER.pppd: st
   25750:	69747261 7020676e 20647070 65726874     arting pppd thre
   25760:	70006461 745f7070 61657268 70700064     ad.ppp_thread.pp
   25770:	203a6470 6d726574 74616e69 206e6f69     pd: termination 
   25780:	75716572 00747365                       request.

00025788 <memp_PPP_PCB>:
   25788:	73550124 72207265 65757165 70007473     $.User request.p
   25798:	695f7070 7475706e 5d64255b 6170203a     pp_input[%d]: pa
   257a8:	74656b63 6f6f7420 6f687320 000a7472     cket too short..
   257b8:	63736944 65647261 6f6e2064 434c2d6e     Discarded non-LC
   257c8:	61702050 74656b63 65687720 434c206e     P packet when LC
   257d8:	6f6e2050 706f2074 64006e65 61637369     P not open.disca
   257e8:	6e696472 72702067 206f746f 78257830     rding proto 0x%x
   257f8:	206e6920 73616870 64252065 736e5500      in phase %d.Uns
   25808:	6f707075 64657472 6f727020 6f636f74     upported protoco
   25818:	7830206c 72207825 69656365 00646576     l 0x%x received.
   25828:	5f707070 6974656e 756f5f66 74757074     ppp_netif_output
   25838:	5d64255b 696c203a 6e206b6e 7520746f     [%d]: link not u
   25848:	70000a70 6e5f7070 203a7765 6974656e     p..ppp_new: neti
   25858:	64615f66 61662064 64656c69 7070000a     f_add failed..pp
   25868:	69735f70 656c676e 3a667562 616e7520     p_singlebuf: una
   25878:	20656c62 61206f74 636f6c6c 77656e20     ble to alloc new
   25888:	66756220 64252820 00000a29               buf (%d)...

00025894 <protocols>:
   25894:	00025fb0 00025c84 00000000              ._...\......

000258a0 <fcstab>:
   258a0:	11890000 329b2312 57ad4624 74bf6536     .....#.2$F.W6e.t
   258b0:	9dc18c48 bed3af5a dbe5ca6c f8f7e97e     H...Z...l...~...
   258c0:	01081081 221a3393 472c56a5 643e75b7     .....3.".V,G.u>d
   258d0:	8d409cc9 ae52bfdb cb64daed e876f9ff     ..@...R...d...v.
   258e0:	308b2102 13990210 76af6726 55bd4434     .!.0....&g.v4D.U
   258f0:	bcc3ad4a 9fd18e58 fae7eb6e d9f5c87c     J...X...n...|...
   25900:	200a3183 03181291 662e77a7 453c54b5     .1. .....w.f.T<E
   25910:	ac42bdcb 8f509ed9 ea66fbef c974d8fd     ..B...P...f...t.
   25920:	538d4204 709f6116 15a90420 36bb2732     .B.S.a.p ...2'.6
   25930:	dfc5ce4c fcd7ed5e 99e18868 baf3ab7a     L...^...h...z...
   25940:	430c5285 601e7197 052814a1 263a37b3     .R.C.q.`..(..7:&
   25950:	cf44decd ec56fddf 896098e9 aa72bbfb     ..D...V...`...r.
   25960:	728f6306 519d4014 34ab2522 17b90630     .c.r.@.Q"%.40...
   25970:	fec7ef4e ddd5cc5c b8e3a96a 9bf18a78     N...\...j...x...
   25980:	620e7387 411c5095 242a35a3 073816b1     .s.b.P.A.5*$..8.
   25990:	ee46ffcf cd54dcdd a862b9eb 8b709af9     ..F...T...b...p.
   259a0:	95818408 b693a71a d3a5c22c f0b7e13e     ........,...>...
   259b0:	19c90840 3adb2b52 5fed4e64 7cff6d76     @...R+.:dN._vm.|
   259c0:	85009489 a612b79b c324d2ad e036f1bf     ..........$...6.
   259d0:	094818c1 2a5a3bd3 4f6c5ee5 6c7e7df7     ..H..;Z*.^lO.}~l
   259e0:	b483a50a 97918618 f2a7e32e d1b5c03c     ............<...
   259f0:	38cb2942 1bd90a50 7eef6f66 5dfd4c74     B).8P...fo.~tL.]
   25a00:	a402b58b 87109699 e226f3af c134d0bd     ..........&...4.
   25a10:	284a39c3 0b581ad1 6e6e7fe7 4d7c5cf5     .9J(..X...nn.\|M
   25a20:	d785c60c f497e51e 91a18028 b2b3a33a     ........(...:...
   25a30:	5bcd4a44 78df6956 1de90c60 3efb2f72     DJ.[Vi.x`...r/.>
   25a40:	c704d68d e416f59f 812090a9 a232b3bb     .......... ...2.
   25a50:	4b4c5ac5 685e79d7 0d681ce1 2e7a3ff3     .ZLK.y^h..h..?z.
   25a60:	f687e70e d595c41c b0a3a12a 93b18238     ........*...8...
   25a70:	7acf6b46 59dd4854 3ceb2d62 1ff90e70     Fk.zTH.Yb-.<p...
   25a80:	e606f78f c514d49d a022b1ab 833092b9     .........."...0.
   25a90:	6a4e7bc7 495c58d5 2c6a3de3 0f781ef1     .{Nj.X\I.=j,..x.

00025aa0 <memp_PPPOS_PCB>:
   25aa0:	00000060                                `...

00025aa4 <pppos_callbacks>:
   25aa4:	0001e13f 0001e16d 0001e121 0001e0e9     ?...m...!.......
   25ab4:	0001e3d1 0001e295 0001e0a1 0001e0d3     ................
   25ac4:	6f707070 6e695f73 5b747570 3a5d6425     pppos_input[%d]:
   25ad4:	6f724420 6e697070 6e692067 706d6f63      Dropping incomp
   25ae4:	6574656c 63617020 2074656b 000a6425     lete packet %d..
   25af4:	6f707070 6e695f73 5b747570 3a5d6425     pppos_input[%d]:
   25b04:	6f724420 6e697070 43412067 63204d43      Dropping ACCM c
   25b14:	20726168 3e64253c 7070000a 5f736f70     har <%d>..pppos_
   25b24:	75706e69 64255b74 4e203a5d 5246204f     input[%d]: NO FR
   25b34:	50204545 53465542 70000a21 736f7070     EE PBUFS!..pppos
   25b44:	74656e5f 6f5f6669 75707475 64255b74     _netif_output[%d
   25b54:	61203a5d 636f6c6c 69616620 70000a6c     ]: alloc fail..p
   25b64:	736f7070 74656e5f 6f5f6669 75707475     ppos_netif_outpu
   25b74:	64255b74 6f203a5d 75707475 61662074     t[%d]: output fa
   25b84:	64656c69 6f727020 303d6f74 2c782578     iled proto=0x%x,
   25b94:	6e656c20 25203d20 70000a64 736f7070      len = %d..pppos
   25ba4:	6972775f 255b6574 203a5d64 6f6c6c61     _write[%d]: allo
   25bb4:	61662063 000a6c69 6f707070 72775f73     c fail..pppos_wr
   25bc4:	5b657469 3a5d6425 74756f20 20747570     ite[%d]: output 
   25bd4:	6c696166 6c206465 253d6e65               failed len=%d..

00025be3 <hexchars.5160>:
   25be3:	33323130 37363534 62613938 66656463     0123456789abcdef
   25bf3:	0a732500 554e3c00 003e4c4c 252e6425     .%s..<NULL>.%d.%
   25c03:	64252e64 0064252e 6e206f4e 6f777465     d.%d.%d.No netwo
   25c13:	70206b72 6f746f72 736c6f63 6e757220     rk protocols run
   25c23:	676e696e 6e6f4300 7463656e 206e6f69     ning.Connection 
   25c33:	6d726574 74616e69 002e6465 2050434c     terminated..LCP 
   25c43:	6e776f64                                 down.

00025c48 <ipcp_callbacks>:
   25c48:	0001f47d 0001eda1 0001eddf 0001ee6d     }...........m...
   25c58:	0001f229 0001ef17 0001f4eb 0001f0e9     )...............
   25c68:	0001f0b3 00000000 0001f099 00000000     ................
	...
   25c80:	00025df4                                .]..

00025c84 <ipcp_protent>:
   25c84:	00008021 0001f055 0001f04b 0001f775     !...U...K...u...
   25c94:	0001f041 0001f037 0001f021 0001f017     A...7...!.......
   25ca4:	72656550 66657220 64657375 206f7420     Peer refused to 
   25cb4:	65726761 6f742065 72756f20 20504920     agree to our IP 
   25cc4:	72646461 00737365 75666552 20646573     address.Refused 
   25cd4:	2072756f 61205049 65726464 43007373     our IP address.C
   25ce4:	646c756f 746f6e20 74656420 696d7265     ould not determi
   25cf4:	6c20656e 6c61636f 20504920 72646461     ne local IP addr
   25d04:	00737365 6c756f43 6f6e2064 65642074     ess.Could not de
   25d14:	6d726574 20656e69 6f6d6572 49206574     termine remote I
   25d24:	64612050 73657264 64203a73 75616665     P address: defau
   25d34:	6e69746c 6f742067 00492520 72656550     lting to %I.Peer
   25d44:	20736920 20746f6e 68747561 7a69726f      is not authoriz
   25d54:	74206465 7375206f 65722065 65746f6d     ed to use remote
   25d64:	64646120 73736572 00492520 75616e55      address %I.Unau
   25d74:	726f6874 64657a69 6d657220 2065746f     thorized remote 
   25d84:	61205049 65726464 49007373 7265746e     IP address.Inter
   25d94:	65636166 6e6f6320 75676966 69746172     face configurati
   25da4:	66206e6f 656c6961 6e490064 66726574     on failed.Interf
   25db4:	20656361 6c696166 74206465 6f63206f     ace failed to co
   25dc4:	7520656d 6f6c0070 206c6163 20504920     me up.local  IP 
   25dd4:	72646461 20737365 72004925 746f6d65     address %I.remot
   25de4:	50492065 64646120 73736572 00492520     e IP address %I.
   25df4:	50435049 206f4e00 70736572 65736e6f     IPCP.No response
   25e04:	206f7420 65206425 2d6f6863 75716572      to %d echo-requ
   25e14:	73747365 72655300 206c6169 6b6e696c     ests.Serial link
   25e24:	70706120 73726165 206f7420 64206562      appears to be d
   25e34:	6f637369 63656e6e 2e646574 65655000     isconnected..Pee
   25e44:	6f6e2072 65722074 6e6f7073 676e6964     r not responding
   25e54:	73736100 69747265 6c206e6f 655f7063     .assertion lcp_e
   25e64:	5f6f6863 656d6974 75725f72 6e696e6e     cho_timer_runnin
   25e74:	303d3d67 69616620 0064656c 20677542     g==0 failed.Bug 
   25e84:	6c206e69 615f7063 69636464 7277203a     in lcp_addci: wr
   25e94:	20676e6f 676e656c 00006874              ong length..

00025ea0 <lcp_callbacks>:
   25ea0:	0001fea1 0001f781 0001fba1 0001f7ed     ................
   25eb0:	000203ed 0001f965 0001feed 000202fd     ....e...........
   25ec0:	0001fdb1 0001fda7 0001fd9d 00000000     ................
   25ed0:	00000000 000207fd 00026006 746f7250     .........`..Prot
   25ee0:	6c6f636f 6a65522d 20746365 20726f66     ocol-Reject for 
   25ef0:	78257830 63657220 65766965 72500064     0x%x received.Pr
   25f00:	636f746f 522d6c6f 63656a65 6f662074     otocol-Reject fo
   25f10:	6e752072 70707573 6574726f 72702064     r unsupported pr
   25f20:	636f746f 30206c6f 00782578 3a70636c     otocol 0x%x.lcp:
   25f30:	63657220 65766965 68732064 2074726f      received short 
   25f40:	6f686345 7065522d 202c796c 676e656c     Echo-Reply, leng
   25f50:	25206874 70610064 72616570 206f7420     th %d.appear to 
   25f60:	65766168 63657220 65766965 756f2064     have received ou
   25f70:	776f2072 6365206e 722d6f68 796c7065     r own echo-reply
   25f80:	65530021 6c616972 6e696c20 73692065     !.Serial line is
   25f90:	6f6f6c20 20646570 6b636162 6f4c002e      looped back..Lo
   25fa0:	6162706f 64206b63 63657465 00646574     opback detected.

00025fb0 <lcp_protent>:
   25fb0:	0000c021 0001fd1d 0001fce5 0001fcb5     !...............
   25fc0:	0001fe1d 000207d1 00020195 000201c9     ................
   25fd0:	65636552 64657669 6f725020 6f636f74     Received Protoco
   25fe0:	65522d6c 7463656a 726f6620 50434c20     l-Reject for LCP
   25ff0:	6f4e0021 74756120 73692068 736f7020     !.No auth is pos
   26000:	6c626973 434c0065 65520050 76696563     sible.LCP.Receiv
   26010:	62206465 63206461 69666e6f 65727567     ed bad configure
   26020:	6b63612d 5025203a 63655200 65766965     -ack: %P.Receive
   26030:	61622064 6f632064 6769666e 2d657275     d bad configure-
   26040:	3a6b616e 00502520 65636552 64657669     nak: %P.Received
   26050:	64616220 6e6f6320 75676966 722d6572      bad configure-r
   26060:	203a6a65 25005025 65742073 6e696d72     ej: %P.%s termin
   26070:	64657461 20796220 72656570 30252820     ated by peer (%0
   26080:	29762a2e 20732500 6d726574 74616e69     .*v).%s terminat
   26090:	62206465 65702079 25007265 52203a73     ed by peer.%s: R
   260a0:	20647663 65646f43 6a65522d 20746365     cvd Code-Reject 
   260b0:	20726f66 65646f63 2c642520 20646920     for code %d, id 
   260c0:	25006425 74203a73 6f656d69 73207475     %d.%s: timeout s
   260d0:	69646e65 4320676e 69666e6f 65522d67     ending Config-Re
   260e0:	73657571 6f007374 6e755f73 63657073     quests.os_unspec
   260f0:	63696669 6c69665f                        ific_file.

000260fa <ssp_inited>:
   260fa:	                                         ..

000260fc <hal_ssp_bases>:
   260fc:	4000c000 4000d000                       ...@...@

00026104 <hal_ssp_clken_masks>:
   26104:	                                         ..

00026106 <hal_ssp_interrupt_lines>:
   26106:	                                         ..

00026108 <system_status_jlink_connected>:
{
   26108:	b510      	push	{r4, lr}
    non_os_enter_critical();
   2610a:	f7f2 f853 	bl	181b4 <non_os_enter_critical>
    system_status_enter_critical();
   2610e:	4b06      	ldr	r3, [pc, #24]	; (26128 <system_status_jlink_connected+0x20>)
   26110:	4798      	blx	r3
    system_status.core.status_flags |= SYSTEM_STATUS_FLAG_JLINK_CONNECTED;
   26112:	2302      	movs	r3, #2
   26114:	4a05      	ldr	r2, [pc, #20]	; (2612c <system_status_jlink_connected+0x24>)
   26116:	6951      	ldr	r1, [r2, #20]
   26118:	430b      	orrs	r3, r1
   2611a:	6153      	str	r3, [r2, #20]
    system_status_exit_critical();
   2611c:	4b04      	ldr	r3, [pc, #16]	; (26130 <system_status_jlink_connected+0x28>)
   2611e:	4798      	blx	r3
    non_os_exit_critical();
   26120:	f7f2 f85c 	bl	181dc <non_os_exit_critical>
}
   26124:	bd10      	pop	{r4, pc}
   26126:	46c0      	nop			; (mov r8, r8)
   26128:	01000421 	.word	0x01000421
   2612c:	0100fee0 	.word	0x0100fee0
   26130:	0100043d 	.word	0x0100043d

00026134 <system_status_jlink_disconnected>:
{
   26134:	b510      	push	{r4, lr}
    non_os_enter_critical();
   26136:	f7f2 f83d 	bl	181b4 <non_os_enter_critical>
    system_status_enter_critical();
   2613a:	4b06      	ldr	r3, [pc, #24]	; (26154 <system_status_jlink_disconnected+0x20>)
   2613c:	4798      	blx	r3
    system_status.core.status_flags &= (~SYSTEM_STATUS_FLAG_JLINK_CONNECTED);
   2613e:	2102      	movs	r1, #2
   26140:	4a05      	ldr	r2, [pc, #20]	; (26158 <system_status_jlink_disconnected+0x24>)
   26142:	6953      	ldr	r3, [r2, #20]
   26144:	438b      	bics	r3, r1
   26146:	6153      	str	r3, [r2, #20]
    system_status_exit_critical();
   26148:	4b04      	ldr	r3, [pc, #16]	; (2615c <system_status_jlink_disconnected+0x28>)
   2614a:	4798      	blx	r3
    non_os_exit_critical();
   2614c:	f7f2 f846 	bl	181dc <non_os_exit_critical>
}
   26150:	bd10      	pop	{r4, pc}
   26152:	46c0      	nop			; (mov r8, r8)
   26154:	01000421 	.word	0x01000421
   26158:	0100fee0 	.word	0x0100fee0
   2615c:	0100043d 	.word	0x0100043d

Disassembly of section .init:

00026160 <_init>:
   26160:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
   26162:	46c0      	nop			; (mov r8, r8)

Disassembly of section .fini:

00026164 <_fini>:
   26164:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
   26166:	46c0      	nop			; (mov r8, r8)

Disassembly of section .ramtext:

01000400 <osEnterSleep>:
{
 1000400:	b510      	push	{r4, lr}
    system_status_set_expected_wake_time(wake_time);
 1000402:	f418 d203 	bl	1880c <system_status_set_expected_wake_time>
    system_status_signal_enter_wfi();
 1000406:	4b03      	ldr	r3, [pc, #12]	; (1000414 <__SYSTEM_STACK_END__+0x14>)
 1000408:	4798      	blx	r3
    hal_lpc_enter_wfi();
 100040a:	4b03      	ldr	r3, [pc, #12]	; (1000418 <__SYSTEM_STACK_END__+0x18>)
 100040c:	4798      	blx	r3
    system_status_signal_exit_wfi();
 100040e:	4b03      	ldr	r3, [pc, #12]	; (100041c <__SYSTEM_STACK_END__+0x1c>)
 1000410:	4798      	blx	r3
}
 1000412:	bd10      	pop	{r4, pc}
 1000414:	01000449 	.word	0x01000449
 1000418:	010004a5 	.word	0x010004a5
 100041c:	01000465 	.word	0x01000465

01000420 <system_status_enter_critical>:
    system_status.core.lock_flag = 1;
 1000420:	2201      	movs	r2, #1
 1000422:	4b05      	ldr	r3, [pc, #20]	; (1000438 <system_status_enter_critical+0x18>)
 1000424:	611a      	str	r2, [r3, #16]
    system_status.system_lock_turn = 0;
 1000426:	2200      	movs	r2, #0
 1000428:	601a      	str	r2, [r3, #0]
    while(system_status.security.lock_flag == 1 && system_status.system_lock_turn == 0)
 100042a:	685a      	ldr	r2, [r3, #4]
 100042c:	2a01      	cmp	r2, #1
 100042e:	d102      	bne.n	1000436 <system_status_enter_critical+0x16>
 1000430:	681a      	ldr	r2, [r3, #0]
 1000432:	2a00      	cmp	r2, #0
 1000434:	d0f9      	beq.n	100042a <system_status_enter_critical+0xa>
}
 1000436:	4770      	bx	lr
 1000438:	0100fee0 	.word	0x0100fee0

0100043c <system_status_exit_critical>:
    system_status.core.lock_flag = 0;
 100043c:	2200      	movs	r2, #0
 100043e:	4b01      	ldr	r3, [pc, #4]	; (1000444 <system_status_exit_critical+0x8>)
 1000440:	611a      	str	r2, [r3, #16]
}
 1000442:	4770      	bx	lr
 1000444:	0100fee0 	.word	0x0100fee0

01000448 <system_status_signal_enter_wfi>:

void system_status_signal_enter_wfi( void )
{
 1000448:	b510      	push	{r4, lr}
    system_status_enter_critical();
 100044a:	f7ff ffe9 	bl	1000420 <system_status_enter_critical>
    system_status.core.status_flags = system_status.core.status_flags & (~SYSTEM_STATUS_FLAG_NEED_FLASH_ACCESS);
 100044e:	2104      	movs	r1, #4
 1000450:	4a03      	ldr	r2, [pc, #12]	; (1000460 <system_status_signal_enter_wfi+0x18>)
 1000452:	6953      	ldr	r3, [r2, #20]
 1000454:	438b      	bics	r3, r1
 1000456:	6153      	str	r3, [r2, #20]
    system_status_exit_critical();
 1000458:	f7ff fff0 	bl	100043c <system_status_exit_critical>
}
 100045c:	bd10      	pop	{r4, pc}
 100045e:	46c0      	nop			; (mov r8, r8)
 1000460:	0100fee0 	.word	0x0100fee0

01000464 <system_status_signal_exit_wfi>:

void system_status_signal_exit_wfi( void )
{
 1000464:	b570      	push	{r4, r5, r6, lr}
#if defined SYSTEM_STATUS_WAKE_DEBUG
    uint64 end_time;
    uint64 start_time = hal_rtc_get_time();
 1000466:	4e0c      	ldr	r6, [pc, #48]	; (1000498 <system_status_signal_exit_wfi+0x34>)
 1000468:	47b0      	blx	r6
 100046a:	0005      	movs	r5, r0
    uint32 this_delay;
#endif
    system_status_enter_critical();
 100046c:	f7ff ffd8 	bl	1000420 <system_status_enter_critical>
    system_status.core.status_flags = system_status.core.status_flags | (SYSTEM_STATUS_FLAG_NEED_FLASH_ACCESS);
 1000470:	2304      	movs	r3, #4
 1000472:	4c0a      	ldr	r4, [pc, #40]	; (100049c <system_status_signal_exit_wfi+0x38>)
 1000474:	6962      	ldr	r2, [r4, #20]
 1000476:	4313      	orrs	r3, r2
 1000478:	6163      	str	r3, [r4, #20]
    system_status_exit_critical();
 100047a:	f7ff ffdf 	bl	100043c <system_status_exit_critical>
    while ((system_status.security.status_flags & SECURITY_FLAG_FLASH_LOCKED) > 0)
 100047e:	2302      	movs	r3, #2
 1000480:	68a2      	ldr	r2, [r4, #8]
 1000482:	421a      	tst	r2, r3
 1000484:	d1fc      	bne.n	1000480 <system_status_signal_exit_wfi+0x1c>
    {

    }
#if defined SYSTEM_STATUS_WAKE_DEBUG
    end_time  = hal_rtc_get_time();
 1000486:	47b0      	blx	r6
    this_delay = (uint32)(end_time - start_time);
    if (this_delay > system_status_debug_longest_wake_delay)
 1000488:	4b05      	ldr	r3, [pc, #20]	; (10004a0 <system_status_signal_exit_wfi+0x3c>)
    this_delay = (uint32)(end_time - start_time);
 100048a:	1b40      	subs	r0, r0, r5
    if (this_delay > system_status_debug_longest_wake_delay)
 100048c:	681a      	ldr	r2, [r3, #0]
 100048e:	4282      	cmp	r2, r0
 1000490:	d200      	bcs.n	1000494 <system_status_signal_exit_wfi+0x30>
    {
        system_status_debug_longest_wake_delay = this_delay;
 1000492:	6018      	str	r0, [r3, #0]
    }
#endif
}
 1000494:	bd70      	pop	{r4, r5, r6, pc}
 1000496:	46c0      	nop			; (mov r8, r8)
 1000498:	010004b1 	.word	0x010004b1
 100049c:	0100fee0 	.word	0x0100fee0
 10004a0:	01002a08 	.word	0x01002a08

010004a4 <hal_lpc_enter_wfi>:
    This function acts as a special kind of Data Memory Barrier.
    It completes when all explicit memory accesses before this instruction complete.
 */
__attribute__((always_inline)) __STATIC_INLINE void __DSB(void)
{
  __ASM volatile ("dsb 0xF":::"memory");
 10004a4:	f3bf 8f4f 	dsb	sy
  __ASM volatile ("wfi");
 10004a8:	bf30      	wfi
  __ASM volatile ("isb 0xF":::"memory");
 10004aa:	f3bf 8f6f 	isb	sy
}
 10004ae:	4770      	bx	lr

010004b0 <hal_rtc_get_time>:
{
 10004b0:	b510      	push	{r4, lr}
    high = RTC_TIME_MSBS;
 10004b2:	4b05      	ldr	r3, [pc, #20]	; (10004c8 <hal_rtc_get_time+0x18>)
        low = RTC_TIME_LSBS;
 10004b4:	4c05      	ldr	r4, [pc, #20]	; (10004cc <hal_rtc_get_time+0x1c>)
    high = RTC_TIME_MSBS;
 10004b6:	6819      	ldr	r1, [r3, #0]
        low = RTC_TIME_LSBS;
 10004b8:	6820      	ldr	r0, [r4, #0]
        high = RTC_TIME_MSBS;
 10004ba:	681a      	ldr	r2, [r3, #0]
    } while (high != last_high);   // Check for change in upper 32 bits of RTC
 10004bc:	4291      	cmp	r1, r2
 10004be:	d100      	bne.n	10004c2 <hal_rtc_get_time+0x12>
}
 10004c0:	bd10      	pop	{r4, pc}
 10004c2:	0011      	movs	r1, r2
 10004c4:	e7f8      	b.n	10004b8 <hal_rtc_get_time+0x8>
 10004c6:	46c0      	nop			; (mov r8, r8)
 10004c8:	40000084 	.word	0x40000084
 10004cc:	40000080 	.word	0x40000080
