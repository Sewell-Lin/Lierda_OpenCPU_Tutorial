#===============================================================================
# @brief    Scons make file
# Copyright (c) 2016 NEUL LIMITED
#===============================================================================

import os
import sys
import SCons.Scanner
from SCons.Script import *
from EnvironmentUtils import *
from subprocess import call

# Accumulate headers for generated FSMs. This is working around the fact that
# the objects returned by a directory's SConstruct are libraries, so we don't
# get a chance to pass back other stuff.
fsm_headers = []

# fsmgen emitter takes the target module as target
# and correctly places stuff under the correct dir
def fsm_emitter(target, source, env):
    optfile = "$OUT_DIR/${FSM_NAME}.opt"

    target.extend([
        "$OUT_DIR/${FSM_NAME}.dot",
        "$OUT_DIR/${FSM_NAME}_gen_public.h",
        "$OUT_DIR/${FSM_NAME}_gen_private.h",
        optfile,
    ])

    env.AppendUnique(STACKUSAGE_OPTFILES=[env.File(optfile)])

    return target, source

fsm_builder = Builder(
        action = Action(
            'python $FSMGEN $SOURCE --out_dir $OUT_DIR',
            'Generating FSM source from $SOURCE ...'
        ),
        src_suffix = '.fsm',
        emitter = fsm_emitter
)

def get_fsm_name_from_def_file(def_file):
    with open(def_file, 'r') as fsm:
        lines = fsm.readlines()
        for line in lines:
            if re.match('NAME:(.*)', line):
                name = line.split(':')[1].lstrip().rstrip()
                return name
    return None

# fsm_path: Absolute path to the containing FSM files.
# out_path: Absolute path to the output directory.
def generate_fsm_sources(env, fsm_path, out_path):
    if os.path.exists(fsm_path):
        fsm_defs = Glob(os.path.join(fsm_path, '*.fsm'))

        if len(fsm_defs) > 0:
            fsm_runners = []
            for fsm in fsm_defs:
                fsm_name = get_fsm_name_from_def_file(File(fsm).abspath)
                if fsm_name is None:
                    fsm_name = os.path.splitext(os.path.basename(File(fsm).path))[0]

                handwritten_fsm_headers = Glob(os.path.join(fsm_path, "..", "private", fsm_name + "*.h"))
                fsm_headers.extend(handwritten_fsm_headers)

                fsm_targets = env.FSM(
                        target = os.path.join(out_path, '%s_gen_runner.c' % fsm_name),
                        source = fsm,
                        OUT_DIR = out_path,
                        FSM_NAME = fsm_name
                )
                Depends(fsm_targets, env['FSMGEN'])
                # The runner C source file is the first item in the list of emitted files (see fsm_emitter)
                fsm_runners.extend([fsm_targets[0]])

                # Push the autogenerated headers to the list after the headers
                # which should include them to make a fully fledged header, so
                # that the pre-processor will have seen the dependencies we
                # need.
                fsm_headers.extend(fsm_targets[2:4])

            return fsm_runners

    return None

def abusively_add_subtree_to_incpath(env, where):
    env.Append(CPPPATH=Dir(where).srcnode().abspath)
    for dirname, dirnames, filenames in os.walk(Dir(where).srcnode().abspath, topdown=False):
        for subdirname in dirnames:
            env.Append(CPPPATH = Dir(os.path.join(dirname, subdirname)).srcnode().abspath)

def get_all_subdirectories( where ):
    all_subdirs = []
    subdir_iter = next(os.walk(Dir(where).srcnode().abspath), [])
    if len(subdir_iter) > 1:
        subdirs = subdir_iter[1]
        if subdirs:
            all_subdirs.extend([Dir(os.path.join(where,x)).srcnode().abspath for x in subdirs])  # get the list of subdirectories
            for sd in subdirs:
                all_subdirs.extend(get_all_subdirectories( Dir(os.path.join(where,sd)).srcnode().abspath ))
    return all_subdirs


def abusively_add_core_relevant_subtree_to_incpath(env, where):
    # if it finds the corename_core, ..., shared structure it will add just the right corename and shared
    # otherwise it adds everything by abusively_add_subtree_to_incpath
    all_sd = get_all_subdirectories( where )
    dir_names = [ os.path.split(x)[1] for x in all_sd ]
    core = NeulTargetConfig.get_build_core(env)
    dir_list = [core, 'shared']
    if core in ['protocol_core', 'application_core']:
        dir_list.append('shared_ap')
    for i in dir_list:
        if i in dir_names:
            # core structured tree
            include_dirs = [ x for x in all_sd if os.path.split(x)[1] in dir_list ]
            for idir in include_dirs:
                abusively_add_subtree_to_incpath(env, idir)
        else:
            all_sd.append(Dir(where).srcnode().abspath)
            for idir in all_sd:
                env.Append(CPPPATH=Dir(idir).srcnode().abspath)


def export_all_public_dirs(env, where):
    # Simply append any 'public' directories to CPPPATH
    for dirname, dirnames, filenames in os.walk(Dir(where).srcnode().abspath, topdown=False):
        for subdirname in dirnames:
            if subdirname == 'public':
                env.Append(CPPPATH = Dir(os.path.join(dirname, subdirname)).srcnode().abspath)

def export_all_helper_dirs(env, where, list_of_helper_tags):
    # Simply append any of the nominated 'helper' directories to HELPERPATH
    for dirname, dirnames, filenames in os.walk(Dir(where).srcnode().abspath, topdown=False):
        for subdirname in dirnames:
        	for helper_tag in list_of_helper_tags:
				if subdirname == helper_tag:
					env.Append(HELPERPATH = Dir(os.path.join(dirname, subdirname)).srcnode().abspath)


# Generate the message XML definitions file from a set of C header files
#
# Source: list of all header files
# target: XML file with autogened message definitions
#
# This is designed as a method to add to a SCons Environment, so the 'self' argument
# refers to the Environment instance the method is added to. (self == env)
def messagexml_generate_defs(env, target, source_with_duplicates):
    global fsm_headers

    # remove duplicates while preserving the order
    source = []
    sourcepaths = set()
    for h in source_with_duplicates:
        sourcepath = os.path.normpath(str(h))
        if sourcepath not in sourcepaths:
            source.append(h)
            sourcepaths.add(sourcepath)
        elif int(ARGUMENTS.get('VERBOSE', 0)) > 0:
            print "WARNING: messagexml: duplicate header:", sourcepath

    all_headers_file = os.path.join('.', 'ctypes_headers_input')
    wanted_headers = []
    for h in source:
        fileName = h.get_abspath()
        # Only add headers with "message" (or "if" or "prim_id.h") in the filename
        if fileName.find("message") != -1 or fileName.find("_if") != -1 or fileName.find("prim_id.h") != -1 or fileName.find("nvconfig") != -1:
            wanted_headers.append(h)

    wanted_headers.extend(fsm_headers)

    # Set up a new environment with a wider path which includes all the supplied headers.
    my_env = env.Clone()
    for f in source:
        my_env.AppendUnique(CPPPATH = os.path.normpath(os.path.dirname(File(f).abspath)))

    # CPPPATH needs setting to include the generated code here, as the scanner won't be able to find the included stuff otherwise.
    import ModuleUtils
    for i in ModuleUtils.fsm_inc_dirs:
        my_env.AppendUnique(CPPPATH = i)
    ModuleUtils.fsm_inc_dirs= []
    my_env.Append(CPPPATH = ".")

    # The CTypes Python library should have the extension ".py" rather than ".xml"
    target_library = target.replace(".xml", ".py")
    # Generate the CTypes Python library
    ctypes_defs = my_env.MessageCtypesgenDefs(target_library, wanted_headers)

    # Generate the XML definitions
    messagexml_defs = my_env.MessageXml(ctypes_defs)
    my_env.Depends(messagexml_defs, [env['MESSAGEXMLCONFIG'], env['MESSAGERULES']])

    # Make sure sufficient dependencies exist
    for h in source:
        Depends(ctypes_defs, h)
    for h in fsm_headers:
        Depends(ctypes_defs, h)

    # Reset our list of headers now, as we assume we'll only generate XML once for any given build type
    fsm_headers = []

    Depends(messagexml_defs, env['MESSAGEXML'])

    return messagexml_defs

messagectypes_builder = Builder(
    action = Action(
        # Re-use the target compiler $CPPFLAGS $_CPPDEFFLAGS to ensure alignment between code and ctypes.
        'python $CTYPESGEN $_CPPINCFLAGS --no-macro-warnings --cpp="$CC -E -DNEUL_DO_NOT_PACK_STRUCTS $CPPFLAGS $_CPPDEFFLAGS \"-D__attribute__(x)=\" " --output=$TARGET ${SOURCES.file}',
        'Generating Message C-Types in $TARGET ...' if not ARGUMENTS.get("VERBOSE", 0) else None
    ),
    suffix = '.py',
    src_suffix = '',
    source_scanner = SCons.Scanner.C.CScanner()
)

def messagexml_emitter(target, source, env):
	# The messages_external.xml released to customers is
	# generated in addition to messages.xml so declare that here
    target.append("messages_external.xml")
    return target, source

messagexml_builder = Builder(
    action=[
        Action(
            'python $MESSAGEXML $SOURCES $TARGET $MESSAGEXMLCONFIG $MESSAGERULES',
            'Generating Message XML in $TARGET ...' if not ARGUMENTS.get("VERBOSE", 0) else None
        ),
        Action(
            '$XML val -e -s $XSD $TARGET',
            'Validating Message XML in $TARGET ...'
        )
    ],
    suffix='.xml',
    src_suffix='',
    emitter=messagexml_emitter,
)

def install_common_tools(env):
    env['FSMGEN'] = NeulBuildConfig.FSMGEN_PATH
    env.Append(BUILDERS={'FSM': fsm_builder})
    env.AddMethod(abusively_add_core_relevant_subtree_to_incpath)
    env.AddMethod(export_all_public_dirs)
    env.AddMethod(export_all_helper_dirs)

    env['CTYPESGEN'] = NeulBuildConfig.CTYPESGEN_PATH
    env['MESSAGEXML'] = NeulBuildConfig.MESSAGEXML_PATH
    env['MESSAGEXMLCONFIG'] = NeulBuildConfig.MESSAGEXML_CONFIG
    env['MESSAGERULES'] = NeulBuildConfig.MESSAGE_RULES
    env['XML'] = NeulBuildConfig.XML_PATH
    env['XSD'] = NeulBuildConfig.XSD_PATH

    env.Append(BUILDERS = {'MessageCtypesgenDefs': messagectypes_builder})
    env.Append(BUILDERS = {'MessageXml': messagexml_builder})

    env.AddMethod(messagexml_generate_defs)
