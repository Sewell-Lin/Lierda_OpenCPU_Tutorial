#===============================================================================
# @brief    Neul YAML Python Module
# Copyright (c) 2018 Huawei Technologies Co. Ltd
#===============================================================================

import os
import yaml

CORE_TO_PREFIX = {
    'security': 'sec',
    'protocol': 'protocol',
    'application': 'apps'
}

ENUM_SPACE_FROM_COMMENT = 5


def parse_kv_defs(core, filepaths):
    values = []
    for filepath in filepaths:
        loadedyml = yaml.load(open(filepath))
        for ymlel in loadedyml:
            assert ymlel['entry'] == 'kv_definitions'
            assert ymlel['core'] == core, (ymlel['core'], core)
            for ymlkdef in ymlel['key_definitions']:
                ymlkdef['module_id'] = ymlel['module_id']
                values.append(ymlkdef)
    values.sort(key=lambda x: x['key_id'])
    return values


def parse_moduledefs(core, filepath):
    loadedyml = yaml.load(open(filepath))
    for ymlel in loadedyml:
        assert ymlel['entry'] == 'module_definitions'
        assert ymlel['core'] == core, (ymlel['core'], core)
    return sorted(ymlel['module_definitions'], key=lambda x: x['module_id'])


def _get_keys_enum(all_keys, enumname='UNDEFINED'):
    kname_max_len = 2 + max([0] + [len(k['key_name']) for k in all_keys])
    comment_offset = kname_max_len + 10

    enum_def = ''
    if all_keys:
        enum_def += 'typedef enum {\n'
        for kvk in all_keys:
            enum_line = '    %s' % kvk['key_name']
            enum_line += ' = %s' % str(kvk['key_id']) 
            enum_line += ',' 
            enum_line += ' ' * (comment_offset - len(enum_line)) 
            enum_line += '/**< key_id = %s = %s\n' % ('0x{:04X}'.format(kvk['key_id']), kvk['key_id'])
            enum_line += ' ' * (comment_offset + ENUM_SPACE_FROM_COMMENT) + 'description = %s' % kvk['description'] + '\n'
            enum_line += ' ' * (comment_offset + ENUM_SPACE_FROM_COMMENT) + 'status = %s' % kvk['key_status'] + '\n'
            enum_line += ' ' * (comment_offset + ENUM_SPACE_FROM_COMMENT) + 'structure = %s' % kvk['structure_type'] 
            enum_line += '    */'
            enum_def += enum_line + '\n'
        enum_def += '} %s;\n' % (enumname)
    return enum_def


def _get_modules_enum(all_modules, enumname='UNDEFINED', enumprefix='UNDEFINED'):
    kname_max_len = len(enumprefix) + 2 + max([0] + [len(k['module_name']) for k in all_modules])
    comment_offset = kname_max_len + 10

    enum_def = ''
    if all_modules:
        enum_def += 'typedef enum {\n'
        for kvk in all_modules:
            enum_line = '    %s_%s' % (enumprefix , kvk['module_name'])
            enum_line += ' = %s' % str(kvk['module_id']) 
            enum_line += ',' 
            enum_line += ' ' * (comment_offset - len(enum_line)) 
            enum_line += '/**< module_id = %s = %s\n' % ('0x{:04X}'.format(kvk['module_id']), kvk['module_id'])
            enum_line += ' ' * (comment_offset + ENUM_SPACE_FROM_COMMENT) + 'module_name = %s\n' % kvk['module_name'] 
            enum_line += ' ' * (comment_offset + ENUM_SPACE_FROM_COMMENT) + 'module_description = %s' % kvk['module_description']
            enum_line += '    */'
            enum_def += enum_line + '\n'
        enum_def += '} %s;\n' % (enumname)
    return enum_def


def _get_h_header(name):
    header = [
        '/******************************************************************************',
        ' * @brief    %s' % name ,
        ' * Copyright (c) 2018 Huawei Technologies Co. Ltd',
        '******************************************************************************/',
        '',
        ''
    ]
    return '\n'.join(header)


def _get_h_guard_start(guard):
    lines = [
        '#ifndef %s' % guard,
        '#define %s' % guard,
        '',
        ''        
    ]

    return '\n'.join(lines)


def _get_h_guard_end(guard):
    lines = [
        '#endif /* %s */' % guard,
        '',
        '',
    ]
    return '\n'.join(lines)


def _get_doxy_group_start(name):
    lines = []
    lines.extend([
        '/** @addtogroup %s' % name,
        ' * @{',
        ' * */',
        '',
        '',
    ])
    
    return '\n'.join(lines)


def _get_doxy_group_end(name):
    lines = []
    lines.extend([
        '/** @} end of group %s */' % name,
        '',
        '',
    ])
    
    return '\n'.join(lines)


def write_modules_hfile(core, all_modules, modules_hfile):
    # Create module_id file 
    print 'Creating %s' % modules_hfile
    with open(modules_hfile, 'w') as f:
        filename_no_extension = os.path.splitext(os.path.basename(modules_hfile))[0]
        
        guard_name = filename_no_extension.upper() + '_H_'
        
        f.write(_get_h_header('AUTOGENERATED SOFTWARE MODULES: %s' % filename_no_extension.upper()))
        f.write(_get_h_guard_start(guard_name))
        f.write(_get_doxy_group_start('SOFTWARE_MODULES'))
        
        if core == 'application':
            f.write('/**\n')
            f.write(' *  Keyspace is divded:\n')
            f.write(' *  - 8-bit module id (256 modules)\n')
            f.write(' *    - module ids 0-127: Neul/Huawei\n')
            f.write(' *    - module ids 128-255: customer configurable\n')
            f.write(' *  - 8-bit per-module key (maximum of 256 keys) per module key values are managed within the module\n')
            f.write(' */\n')
                
        f.write('%s\n\n' % _get_modules_enum(all_modules, enumprefix=CORE_TO_PREFIX[core].upper() + '_SW_MODULE', enumname=filename_no_extension.upper()))
        f.write(_get_doxy_group_end('SOFTWARE_MODULES'))
        f.write(_get_h_guard_end(guard_name))


def write_keys_hfile(module_name, mkeys, fname):
    # Create key_id files
    print 'Creating %s' % fname
    with open(fname, 'w') as f:
        filename_no_extension = os.path.splitext(os.path.basename(fname))[0]
        guard_name = filename_no_extension.upper() + '_H_'

        f.write(_get_h_header('AUTOGENERATED KEY IDS: %s' % filename_no_extension.upper()))
        f.write(_get_h_guard_start(guard_name))
        f.write(_get_doxy_group_start('KV_IDS'))
        f.write('%s\n\n' % _get_keys_enum(mkeys, enumname=(module_name + '_KV_IDS')))
        f.write(_get_doxy_group_end('KV_IDS'))
        f.write(_get_h_guard_end(guard_name))
